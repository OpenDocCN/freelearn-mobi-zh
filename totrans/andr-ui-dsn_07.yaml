- en: Chapter 7. Building a Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After doing much of the initial design work in the previous chapters, it's now
    time to move past designing and into the early stages of developing. And the first
    development task is to create a digital prototype.
  prefs: []
  type: TYPE_NORMAL
- en: After creating multiple wireframes and paper prototypes, you may be itching
    to start some *real* development work, but digital prototyping is a *crucial*
    step in the design process.
  prefs: []
  type: TYPE_NORMAL
- en: Despite all the time and effort you've already invested in your design, at this
    point it's still just a plan. Digital prototyping is where you put this plan to
    the test to see whether it works in the real world. Also, digital prototyping
    is just plain fun as it allows you to go from no code to a working version of
    your app in no time at all.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have developed a working digital prototype
    of your app. You'll have also finalized your design by planning the finer details
    of your app, which means starting to think about graphic design.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As it's the recommended development environment for Android, this chapter focuses
    on creating digital prototypes using Android Studio. If you don't have Android
    Studio installed, you can grab it from [http://developer.android.com/sdk](http://developer.android.com/sdk).
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer to use a different IDE, such as Eclipse, then the steps involved
    in creating a digital prototype will be similar, so you will still be able to
    follow along in the IDE of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a prototype in Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conveniently, one of the best tools for creating Android prototypes is something
    you probably already have installed—Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: This IDE features an advanced layout editor that's ideal for rapidly creating
    digital prototypes. This layout editor automatically opens whenever you open any
    XML layout resource file in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a prototype in Android Studio](img/B05061_7_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The quickest way of creating a digital prototype is to select the editor's **Design**
    tab (where the cursor is positioned in the previous screenshot). A new area will
    open displaying a **canvas** preview of your app's layout, plus a **Palette**
    containing lots of ready-made UI elements called **widgets**. You can quickly
    create a prototype by dragging widgets from the **Palette** and dropping them
    onto the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating prototypes (and Android apps in general), you should use the default
    widgets unless you have a very good reason not to. Not only do these ready-made
    widgets make your life as a developer easier, but most Android users will already
    be familiar with them. So they'll instantly know how to interact with at least
    some elements of your app's UI.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to make more specific changes to your app's layout, you can access
    its underlying XML by selecting the **Text** tab, making your tweaks at the code
    level, and then nipping back to the **Design** tab to see these changes rendered
    on the canvas. Using this approach, you'll have a working prototype in no time,
    which you can then test on your own Android device or in an emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Creating prototypes in Android Studio is also a great way of testing how your
    design looks and functions across a range of different screen configurations.
    If you simply happen to have multiple Android devices lying around, you can install
    your prototype on all of them, but most Android developers test their project
    across difference devices by creating multiple **Android Virtual Devices** (**AVDs**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll explore deploying and testing your digital prototypes in more detail in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also get a quick preview of your prototype across different devices
    using Android Studio''s built-in **Preview** pane. To access this pane, make sure
    the **Text** tab is selected, and then click on the **Preview** tab along the
    left-hand side of the screen (where the cursor is positioned in the following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a prototype in Android Studio](img/B05061_7_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this tab open, you''ll see a preview of your app as it appears on a single
    Android device. To check how your layout will appear on a different Android device,
    click on the name of the currently selected device (where the cursor is positioned
    in the following screenshot), and then choose a new device from the drop-down
    menu. You can even preview your UI across multiple devices at once by selecting
    **Preview all screen sizes** from the drop-down menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a prototype in Android Studio](img/B05061_7_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating your first prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can start by prototyping any screen in your app, but I find that it makes
    sense to start with the first screen users see when they launch your app. In our
    recipe app example, this is the home screen, so this is the first screen I'm going
    to prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Referring back to my wireframe, I can see that the home screen should include
    a welcome message and photos from some of the recipes featured in the app. I also
    want to include a menu, so users can easily navigate to the app's most important
    screens. Specifically, I want this menu to include a link to the search screen,
    the user's recipe scrapbook, and all the different recipe categories.
  prefs: []
  type: TYPE_NORMAL
- en: Since this menu needs to include quite a few options, I'm going to use a navigation
    drawer. A navigation drawer is an effective solution here, as it's scrollable
    and can be neatly tucked out of the way when it's no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're not familiar with the concept of navigation drawers, then you may
    want to look at Android's Material Design guidelines, which has a whole section
    dedicated to navigation drawers  [https://www.google.com/design/spec/patterns/navigation-drawer.html](https://www.google.com/design/spec/patterns/navigation-drawer.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Boot up Android Studio and create a new project. Choose whatever settings make
    the most sense for your particular project, but if you're following along with
    this example, then select the **Navigation Drawer** template. As you might already
    have guessed from the name, this template has a built-in navigation drawer, which
    will make creating your home screen digital prototype much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Finish** to go ahead and create your project. By default, this project
    already includes quite a bit of code and resources. My mission is to modify all
    this automatically generated code to match my home screen wireframe. Let''s start
    with the most straightforward task: creating the screen''s welcome message and
    adding our images.'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project's `content_main.xml` file and make sure it's using `RelativeLayout`
    as the parent container. Then, select the **Design** tab and drag one `TextView`
    and two `ImageView` widgets from the **Palette**, and drop them onto your canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Next, populate these widgets with text and images. Create a string resource
    that contains the welcome text of your choice. Find two images you want to use
    and add them to your project's `drawable` folder (in my project, I'm using `mushroomtoast.jpeg`
    and `sundayroast.jpeg`). Update `TextView` to display the string resource, and
    update `ImageViews` to display your chosen images.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Digital prototyping: Don''t waste your time!**'
  prefs: []
  type: TYPE_NORMAL
- en: A this point, you may be tempted to invest lots of time positioning your `ImageView` and
    `TextView` objects so that they look *exactly* as they should in your finished
    app. However, be wary of spending too much time perfecting your prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing to remember is that the purpose of digital prototyping isn't to
    create an early version of your project but to test the *theory* of your project's
    design. If you spend too much time getting your digital prototypes perfect, then
    you might as well have started creating the first version of your app!
  prefs: []
  type: TYPE_NORMAL
- en: Your digital prototype may end up highlighting some underlying problems with
    your design, which means you'll need to go back and make some changes to your
    wireframes or even redo them completely. If this happens, then at least you can
    console yourself with the knowledge that it's better to uncover problems with
    your design at this early stage, rather than *after* you've actually started building
    your app. Digital prototyping is a powerful and time-saving tool in your early
    detection arsenal—but *only* if you don't invest lots of time in perfecting your
    prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: Don't fall into the trap of worrying about the finer details; instead, aim to
    create your prototypes as quickly as possible. This usually means creating screens
    that are only a rough representation of how the finished screen will look, and
    that typically has little or no functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the XML for my home screen prototype. Since this is only a prototype,
    I haven''t invested too much time in aligning each UI element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Check how this looks on your emulator or Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first prototype](img/B05061_7_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next task is more complex: adding our own menu items to the navigation
    drawer.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll find all the navigation drawer code in the project's `res/menu/activity_main_drawer.xml`
    file. There's already quite a bit of code in `activity_main_drawer.xml`, but this
    code nicely illustrates how to add items to the navigation drawer, so rather than
    simply deleting it, let's use it as our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the `activity_main_drawer.xml` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As already mentioned, the menu items I want to add are the scrapbook, the search
    screen, and the different recipe categories. The first task is deciding what icons
    I want to use for each of these menu items.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, you should use the system icons as most users will already
    be familiar with them, and will therefore know what they mean. You'll find the
    entire list of Material Design system icons at [https://design.google.com/icons/](https://design.google.com/icons/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: From this long list of icons, I'm going to use the standard Search icon, so
    download this image and drop it into your project's `drawable` folder. Finding
    icons for all the other items isn't quite as straightforward, but since this is
    just a prototype, I'm going to use some placeholder icons for now. I have decided
    to use the Description icon as it kind of looks like a notebook (or a scrapbook),
    and I'm also going to use the knife-and-fork local dining icon for each of the
    recipe categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all these images are safely tucked away in the `drawable` folder, it''s
    time to add a few new entries to the navigation drawer code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s it! Run the finished prototype on your Android device or emulator,
    but this time, be sure to open the navigation drawer by dragging it on the screen.
    You will see some new additions to this drawer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first prototype](img/B05061_7_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating your second prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wireframing gives you a clearer picture of your UI, but sometimes even wireframes
    can't effectively illustrate how *every* version of a certain screen will look.
    This is the case with our app's search results screen, as this screen will vary
    depending on what the user has searched for. So, how do we create a single prototype
    that effectively represents our search results screen?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to create a flexible prototype layout, and feed it some fake data.
    This fake data should accurately represent the complete range of real-life content
    this screen will ultimately have to display. You should go out of your way to
    find the most awkward examples of your app's content, so you can really put your
    design to the test. In our recipe app example, this means using recipes that have
    unusually long or short titles.
  prefs: []
  type: TYPE_NORMAL
- en: To create a prototype of the tricky search results screen, I'm going to create
    `ListView`, and then I will create the arrays of sample recipe titles and images,
    which I'll feed to `ListView`. The `ListView` will then display these arrays in
    my layout as though they're real search results.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've created your first prototype, you can either add more screens to
    this project or create each subsequent prototype as a separate project. Personally,
    I feel like the latter is the most straightforward option, so I'm going to create
    my search results prototype as a new project—this time using a blank template.
  prefs: []
  type: TYPE_NORMAL
- en: If you also decide to prototype each screen as a separate project, then make
    sure you give each project a different package name, so you can install and test
    them all on the same Android device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring back to my wireframes, I can see that the search results screen needs
    to include a list of recipe titles and accompanying images along with a header.
    Let''s start with the most straightforward task: creating the header. Open your
    project''s `strings.xml` file and create a string that''ll provide the search
    screen''s header text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Open the `activity_main.xml` file and make sure its parent container is a vertical `LinearLayout`.
    Create a `TextView` and set it to display the `sResults` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next it''s time to tackle the part of the wireframe that makes this screen
    more difficult to prototype: the search results. As already mentioned, I''m going
    to create a `ListView` and feed it some fake data, so the first step is adding
    the `ListView` to our layout resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ListViews, adapters, and list items**'
  prefs: []
  type: TYPE_NORMAL
- en: A `ListView` is a view group that displays items as a vertical, scrollable list.
    Users can select any item in the list by giving it a tap, which makes `ListViews`
    perfect for displaying our search results, as eventually we want the user to be
    able to open a recipe by tapping its title.
  prefs: []
  type: TYPE_NORMAL
- en: To see an example of a `ListView` in action, grab your Android device and take
    a look at the stock **Contacts** app. It contains a scrollable list of all your
    contacts; you can tap any item in the list to see more information about that
    particular contact. Sound familiar?
  prefs: []
  type: TYPE_NORMAL
- en: Once you've identified one `ListView`, you'll start noticing them *everywhere*.
    Flick through a few of the apps installed on your device, and chances are you'll
    be surprised by just how often you come across `ListViews`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ListViews` are made up of *list items*. Each list item is displayed as a row
    in the `ListView`, and these items have their own layout that you define in a
    separate XML file. You can create a simple layout for your list items, or you
    can also create more complex list items that feature multiple pieces of text and
    several images arranged in a `RelativeLayout`.'
  prefs: []
  type: TYPE_NORMAL
- en: The final piece of the puzzle is an adapter that acts as a bridge between the
    `ListView` and its underlying data. The adapter pulls content from a specified
    source, such as an array, and adapts this content into views. The adapter then
    takes each view and places it inside the `ListView` as an individual row.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I'm going to be using `SimpleAdapter`, which is a type of adapter
    that maps static data to views defined in an XML file. This is a pretty straightforward
    adapter, but it does have one catch: `SimpleAdapter` require an `ArrayList` of `Maps`
    in order to define each row in the `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about `ListViews` and the different kinds of adapters,
    the best place to go is the official Android docs: [http://developer.android.com/guide/topics/ui/layout/listview.html](http://developer.android.com/guide/topics/ui/layout/listview.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the layout of the individual items/rows that''ll appear in our
    `ListView`. Create a new layout resource file called `simple_list_layout.xml`,
    and then create `TextView` and `ImageView` that will eventually hold the recipe
    titles and accompanying images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add all the images for your fake search results. I''m adding the following
    to my project''s `drawable` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blueberrypancake.jpg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brownies.jpg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calamari.jpg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chilli.jpg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fryup.jpg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kashmiricurry.jpeg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pie.jpeg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redberrypancake.jpeg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scallops.jpeg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`surfandturf.jpg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sweetandsourprawns.jpeg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tuna.jpeg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'm going to add all these images plus the corresponding recipe titles to separate
    arrays. Then, I'm going to feed these arrays to the `ListView` via an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is much more complex than the first prototype, so to speed things up I'm
    writing this code as quickly as possible, forsaking a bit of efficiency and optimization
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your project''s `MainActivity.java` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach your Android device to your computer or boot up the emulator and take
    a look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your second prototype](img/B05061_7_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spend some time interacting with your prototype and testing it across different
    screen configurations, whether that's via Android Studio's preview function or
    by creating multiple AVDs.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have two working prototypes; ask yourself whether there's any way you
    can improve these prototypes. In particular, be on the lookout for any opportunities
    to split your UI into fragments that you can then combine into multipane layouts
    that adapt to different screen configurations.
  prefs: []
  type: TYPE_NORMAL
- en: If your digital prototypes spark any new ideas, then grab a piece of paper and
    try wireframing these ideas. If these new paper-and-pencil wireframes have potential,
    then ideally you should put them through the same vigorous digital wireframing,
    paper prototyping, and usability testing stages that we covered in the previous
    chapter. At the very least, you should create a digital prototype of your new
    designs, and spend some time testing these prototypes—again—across as many different
    screen configurations as possible.
  prefs: []
  type: TYPE_NORMAL
- en: This may feel like taking a step backward, but this is all invaluable for ensuring
    that your design really is the best it possibly can be; and if it improves your
    app, then it's time well spent. If you release the first version of your app when
    you suspect you could have improved the underlying design, you're not going to
    have a good time—and neither are your users.
  prefs: []
  type: TYPE_NORMAL
- en: Also, that old cliché is right—you don't get a second chance to make a first
    impression. Your average user is going to be far more excited by an amazing app
    that seems to come out of nowhere, rather than version 2.0 of an app they tried
    ages ago but weren't too keen on.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you explore your ideas and then discard them in favor of your original
    design, at least you'll be confident that you really are releasing the best possible
    version of your app. Basically, if your digital prototypes have stirred up any
    new ideas, then now's the time to explore them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do create a new series of wireframes and prototypes, it's always good
    to get a second opinion, so you may want to consider performing another round
    of user testing—especially if you find yourself torn between two different design
    directions for your app.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a set of digital prototypes that you're 100% happy with, it's
    time to finalize these designs.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing your design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you should have a firm grasp of the fundamentals of your app's
    design, including what UI elements should appear on each screen, where they'll
    appear on the screen, and the navigation patterns that you want to use. However,
    we still haven't put much thought into the finer details of our app's look and
    feel. What kind of font are you going to use for the headings? What color should
    the buttons be? Will there be any background music or sound effects? And how is
    your app going to use Material Design properties such as elevation and shadow?
  prefs: []
  type: TYPE_NORMAL
- en: Here are some of the things you need to consider when finalizing your design.
  prefs: []
  type: TYPE_NORMAL
- en: Visuals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the finer point of how your UI elements will look. Although you should
    try and use Android's standard widgets wherever possible, there's still lots of
    scope for putting your own twist on standard elements such as buttons and menus,
    particularly in terms of the color palette you use, plus Material Design elements
    such as elevation and shadow.
  prefs: []
  type: TYPE_NORMAL
- en: The ratio of your visual content is also important; should your screen feature
    lots of images and animation, or should it be more text heavy? As always, make
    sure you're designing something that'll appeal to your specific target audience.
    An app that features lots of images and a bright and bold palette might be appropriate
    for a fun app that's targeting a younger audience, but it's probably not so appropriate
    for an app that helps busy professionals balance their finances.
  prefs: []
  type: TYPE_NORMAL
- en: Background music and sound effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sound is a powerful way of setting the mood, evoking an emotional response,
    and giving your users an immediate feeling of what they can expect from your app.
  prefs: []
  type: TYPE_NORMAL
- en: However, don't feel like you have to include sound in your app; there's nothing
    wrong with silence, and in some situations, a completely silent app is preferable,
    especially if people are likely to use your app in situations where noise could
    be annoying or inappropriate.
  prefs: []
  type: TYPE_NORMAL
- en: If you do include some form of sound, always consider how integral sound should
    be to the user being able to successfully interact with your app. As a general
    rule, your app should be usable regardless of whether users have their volume
    turned way up, way down, or if they're in a location where they can't hear your
    app clearly, such as in a busy bar or restaurant.
  prefs: []
  type: TYPE_NORMAL
- en: The only exceptions are apps that fundamentally rely on sound, such as music
    streaming apps, an app that gives the user driving directions, or some gaming
    apps. In these instances, you can be confident that no one will expect to be able
    to use your app without turning up the volume on their device.
  prefs: []
  type: TYPE_NORMAL
- en: Your text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text is your most direct method of communicating with your users. When crafting
    your text, you need to consider its content along with its visual appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Your text's appearance has a massive impact on how easily your users can read
    and understand what that text is saying, but appearance can also send your users
    subtle messages about the text. For example, you can use `textSize` to communicate
    how important each piece of text is and what category it falls into, such as whether
    it's a heading, a caption, or a block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create text styles that really speaks to your users, you can use the following
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text size**: You should decide the size of all your app''s major *types*
    of text early in the design process and *not* on a screen-by-screen basis. By
    limiting yourself to a selection of predefined sizes and using them consistently,
    your users will quickly learn what each `textSize` means. They can then use this
    information to decipher each new screen they encounter in your app, since they''ll
    instantly know which text is the subheading, the body text, and so on, based on
    its size. You specify the font size with the `android:textSize` attribute, for
    example, `android:textSize="10sp."`. The most common method of setting `textSize`
    in advance is to use themes and styles, which we''ll discuss later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text style**: Android supports bold, italic, and underlined effects, but
    make sure you use them sparingly. If you use these effects too often, you''re
    adding lots of visual clutter that can make your text difficult to read, plus
    you''ll end up diminishing the effect''s impact. You apply bold, italic, underlined,
    and `bold|italic` effects using the `android:textStyle` attribute, for example, `android:textStyle="bold."`.
    The underlining text is a bit trickier, as you''ll need to create a string resource
    and apply underlining to the text inside that resource, for example, `<string
    name="main_title"><u>This text is underlined</u>This text isn''t</string>`. Then,
    reference this resource from your project''s layout resource file (`android:text="@string/main_title"`),
    and the text will appear underlined in your UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capitalization**: Like bold, italic, and underlined effects, you should use
    capitalization sparingly so you don''t reduce its impact. You should also avoid
    using all capitals, as the all-caps text is commonly interpreted as shouting,
    plus it''s much harder for your users to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next thing you need to worry about is what your perfectly styled text is
    actually saying.
  prefs: []
  type: TYPE_NORMAL
- en: Think of text as your app's voice. This voice should align with your app's overall
    design. If your design is colorful and upbeat with cheerful music, then your text
    should be equally friendly. If your design is a bit more edgy, then you may want
    to give your text more attitude.
  prefs: []
  type: TYPE_NORMAL
- en: Just don't get carried away! Most of the time, it won't make sense to go to
    extremes with your text, and you should opt for a plain and neutral tone instead.
    Remember that the tone and content of your text should reflect the rest of your
    app's design. So, if your UI is streamlined with a focus on getting the job done,
    then chances are you'll want your text to be equally to the point.
  prefs: []
  type: TYPE_NORMAL
- en: If in doubt, play it safe with a neutral tone.
  prefs: []
  type: TYPE_NORMAL
- en: Your app's personality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I've left this one until last as it's a bit of a vague concept that incorporates
    a little bit of everything we've discussed so far.
  prefs: []
  type: TYPE_NORMAL
- en: Your app's *personality* is a combination of lots of different design elements,
    from visuals, through to background music and the tone of your text.
  prefs: []
  type: TYPE_NORMAL
- en: If your app is going to make a clear and distinct impression on your users,
    then all these different aspects need to align. If these design elements aren't
    consistent, then chances are that you're going to leave your users with the uneasy
    feeling that something is a little *off* about your app.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you created an app that uses a neutral, pretty pastel palette; is packed
    full of cutesy graphics and ends every line of cheerful, upbeat text with at least
    three exclamation points—but the background music is trash metal!
  prefs: []
  type: TYPE_NORMAL
- en: Take a critical look at all the design decisions you've just made so far. Do
    they all come together to form a cohesive whole? Or does one (or more) elements
    stick out like the proverbial sore thumb?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Rules are made to be broken!**'
  prefs: []
  type: TYPE_NORMAL
- en: Although most of the time you *will* want all your design aspects to align,
    occasionally you may decide to throw the user a curveball in the form of an element
    that intentionally clashes with the rest of your app. This technique can create
    some very powerful effects; for example, you might combine cheerful colors and
    enthusiastic text with unsettling music to create a creepy and unnerving experience,
    or you may want to combine cutesy graphics with dry and sarcastic text to get
    your users laughing.
  prefs: []
  type: TYPE_NORMAL
- en: If you do decide to break the rules, just make sure you have a clear idea of
    what you're trying to achieve and how you're trying to achieve it, as it's easy
    to get this technique wrong!
  prefs: []
  type: TYPE_NORMAL
- en: If you're struggling to decide what your app's overall personality should be,
    then think about what'll appeal the most to your target audience.
  prefs: []
  type: TYPE_NORMAL
- en: As always, if you're struggling for inspiration, head over to the Google Play
    store and hunt down a few apps that are similar to your project or that target
    the same audience.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want our recipe app to appeal to students, I'm going to visit the Play
    store and search for apps that include the word `student`. Instantly, I see a
    whole bunch of timetable and agenda apps, forums that specifically target university
    students, and homework planners. In this scenario, I'd download a few of the most
    highly-rated apps, and then spend some time flicking through them to get a feel
    for their personality. I'd also probably download a few 5 star-rated recipe apps
    and give them the same treatment before combining all my findings and using them
    to influence the look and feel of my own recipe app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating themes and styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've made some decisions regarding the finer details of your UI,
    it's time to think about how you might implement them. This is where themes and
    styles come in useful, as they're one of the quickest and easiest ways of implementing
    design decisions consistently across your views, activities, and even your entire
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've made these design decisions, it's a good idea to create styles and
    perhaps even a theme to help you implement your designs easily and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Styles and themes are essentially the same thing: a collection of properties.
    These properties can be anything from the color of your text, to the size of an
    `ImageView`, or even the `"wrap_content"` attribute. The difference isn''t how
    you create this collection of properties, but how you *apply* them to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Styles are the groups of properties that control what a view looks like; for
    example, you might apply a style to a `TextView` to specify the size and color
    of all the text within it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Themes are groups of properties that you apply to an activity or even an entire
    application. When you apply a theme to an activity, every view inside the activity
    will use any property that applies to it. If you apply a theme to an app, *every*
    view throughout that app will use all the applicable properties from this theme.
    You'll typically extend another theme rather than create one from scratch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Styles and themes do take a bit of prep work, so why should you go to the effort
    of creating themes and styles, when you could just apply properties to views directly?
    There are a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s efficient**: If you''re going to use the same collection of attributes
    multiple times throughout an app, then defining these properties in advance makes
    applying them *much* easier—as easy as typing `style="@style/captionFont"` in
    fact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It''s consistent**: Defining a collection of attributes as a style or theme
    helps create a consistent look and feel across your app. And as we''ve already
    discussed, users *love* consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It''s flexible**: Design changes are pretty much a fact of life, so you should
    expect to be tweaking your app''s visuals throughout the entire development process.
    Themes and styles provide a central place where you can make changes once and
    have them appear instantly across your app. Decided that your headings should
    be 10dp larger? Easy, just increase the `android:textSize` attribute in your `style="@style/heading"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember when we were talking about the `textSize` attribute and how using
    only a small selection of text sizes can help users decode your UI? This rule
    also applies to styles. If you use a limited number of styles, your users will
    quickly pick up what these styles mean, and then use this information to help
    them decipher new screens. To get the most out of styles (and, to a lesser extent,
    themes) pay attention to that old cliché: less is more.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a style (or series of styles), you need to create a `styles.xml` file
    in your project's `res/values` folder, if it doesn't contain this file already.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then create styles using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so this may look like a lot of work, but bear in mind that you wouldn't
    create a style to use just once. Typically, you'll define a style in advance,
    and then use it multiple times throughout your project. Plus once you've defined
    a style, you can use inheritance to create variations of this style (which we'll
    explore in more detail later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What''s in a name?**'
  prefs: []
  type: TYPE_NORMAL
- en: Put some thought into what you call each style, as a style's name can communicate
    valuable information about its purpose and relationship with other styles.
  prefs: []
  type: TYPE_NORMAL
- en: For the best results, always name your styles based on their purpose rather
    than their appearance, as this might change as you refine your UI.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, `CaptionStyle` is a good name but `ItalicsLightCaption` isn't,
    as your UI might evolve to a point where light, italicized text no longer fits
    with the rest of your UI. At this point, you have two options. You can continue
    using this inconsistent style name, which is potentially confusing, especially
    if you're collaborating on this project with others.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you'll need to open `styles.xml`, and give your style a new name,
    but you'd then also need to manually change every reference to this style throughout
    your project. As you can see, neither of these are ideal solutions!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created your style, applying it to a view is straightforward;
    just open an XML layout resource file and use the `@style` attribute, followed
    by the name of the style you want to apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Not all views accept the same style attributes; for example, an `ImageView`
    won't accept an `android:textAlignment`. The official Android docs is the best
    place to check what properties a particular view supports, specifically the view's
    corresponding class reference where you'll find a table of supported XML attributes.
    For example, if you were creating a text style, then you might want to take a
    look at the `TextView` class reference ([http://developer.android.com/reference/android/widget/TextView.html](http://developer.android.com/reference/android/widget/TextView.html)).
    Also, bear in mind that some views extend other views, so if you were creating
    a style to apply to `EditText`, it'd be worth taking a look at the `TextView`
    class reference too, as `EditText` extends the `TextView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you'll inadvertently apply incompatible properties to a view, particularly
    when you're applying a style to an entire activity, or when you're applying a
    theme. So, what happens then? The answer is *not much*. A view will only accept
    properties that it supports, and it'll ignore the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you apply a style to a view, this style is applied to that view only. If
    you apply a style to `ViewGroup`, the child view elements won't inherit the style's
    properties. If you want to apply a style to multiple views at once, then you should
    apply the style as a theme instead.
  prefs: []
  type: TYPE_NORMAL
- en: Some style properties are not supported by any view, and you can only apply
    them as a theme to an activity or across an entire app. For example, properties
    that hide the application title won't have any impact when applied to a single
    view. These attributes are easy to spot as they all begin with `window`, such
    as `windowNotTitle`, `windowTitleSize`, and `windowNoDisplay`. You'll find the
    complete list at the `R.attr` reference that's available as part of the official
    Android docs at [http://developer.android.com/reference/android/R.attr.html](http://developer.android.com/reference/android/R.attr.html).
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can quickly and easily create variations on existing styles by using them
    as **parent styles** and inheriting their attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `<parent>` attribute to specify the style you want to inherit from.
    You can then add properties and change the existing properties by overriding them
    with new values. You can inherit from the styles that you''ve created yourself
    or from the styles that are built into the Android platform, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you want to inherit from the styles that you've defined yourself, you don't
    have to use the `<parent>` attribute. However, it's generally considered best
    practice to prefix the name of the parent style to the name of your new style,
    and separate the two with a full stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine I wanted to create a new style that inherits from a custom `FooterText`
    style which I created earlier, but that increases the `textsize` from 12sp to
    20sp. I''d do this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You reference this inherited style in exactly the same way as any other style;
    in this instance that's `style="@style/FooterText.Large"`.
  prefs: []
  type: TYPE_NORMAL
- en: You can continue inheriting like this as many times as you like; just keep chaining
    these style names together with full stops. There's nothing stopping you from
    creating `FooterText.Large.Blue`, `FooterText.Large.Italic`, `FooterText.Large.Blue.Bold`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: However, to make it easier to remember all your style names correctly and help
    distinguish between styles, it's a good idea not to get carried away! After all,
    `FooterText.Large.Blue.Bold.Underlined.Monospace` isn't the easiest thing to remember.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheriting properties by chaining style names together only works for styles
    you create yourself. If you want to inherit from Android's built-in styles, you
    need to use the parent attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Working with themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point you may be wondering why we've spent so much time focusing on
    styles without really discussing themes. This is because you define a theme in
    exactly the same way you define a style. You could take any of the styles we've
    defined above, and apply them as a theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a theme, open your project''s `Manifest.xml` and add the `android:theme`
    attribute to either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The <application> tag**: If you want to apply a theme across your entire
    app, find the `<application>` tag and add the `android:theme` attribute, plus
    your style name, for example, `<application android:theme="@style/FooterFont">`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The <activity> tag**: To apply your theme to a specific activity, add `android:theme`
    to the relevant `<activity>` tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you apply a theme, every view within the activity or across the app will
    use all the theme properties that it can support. If you apply `FooterFont` to
    an activity, all `TextViews` (and views that extend `TextView`) within that activity
    will use this collection of properties. If you apply `FooterFont` across your
    app, all `TextViews` and views that extend `TextView` will assume these properties,
    but any view that *doesn't* support the `FooterFont` properties will simply ignore
    them. And if a view supports some of the `FooterFont` properties and not others,
    it'll apply the supported properties and ignore the rest.
  prefs: []
  type: TYPE_NORMAL
- en: To save you time and effort, the Android platform includes many predefined themes
    that you can use, including a selection of Material themes. You'll find a list
    of all the available styles in the **R**.style section of the official Android
    docs ([http://developer.android.com/reference/android/R.style.html](http://developer.android.com/reference/android/R.style.html)).
    To use any of the platform styles and themes, replace all the underscores in the
    style name with a period, so `Theme_Dialog` becomes `"@android:style/Theme.Dialog"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to customize a built-in theme, you should use the theme as the
    `<parent>` tag of your own custom theme, and then add your own properties or override
    the existing properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is updating your project''s `Manifest` to use your new theme.
    So, if you wanted to use `MyTheme` in a specific activity, you''d write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `MyTheme` across your entire application, you''d write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Get ready for errors!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a perfect world, users will only ever interact with your app under ideal
    conditions. If your app pulls content from the Internet, people will only ever
    open your app when they have a lightning-fast connection to the World Wide Web.
    Your app will never have to deal with interruptions such as pesky incoming calls
    or SMS messages, and your users will certainly *never* enter their username or
    password incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, this isn't the way the real world works. Your users will make mistakes,
    run out of storage space, lose their Internet connection, and get phone calls
    when they're midway through the final boss battle in your RPG app. Your app must
    be able to handle all these less-than-ideal conditions and errors.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem strange to plan for errors, but unfortunately errors happen to the
    best of us. Not only should your app be able to handle errors when they do occur,
    but it should handle them *gracefully*.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we'll look at how to design your app so
    that it can handle whatever the real world throws at it.
  prefs: []
  type: TYPE_NORMAL
- en: User input errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User input errors are where users enter incorrect information or leave a field
    blank. The most common places where user errors occur are forms such as login
    screens or payment screens.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you clearly communicated what information the user needed to enter,
    technically these errors aren't your fault, but you should still design your app
    to be able to cope with these kinds of error.
  prefs: []
  type: TYPE_NORMAL
- en: When user errors occur, your app should clearly communicate what's happened
    and give the user enough information to be able to fix the problem. Simply displaying
    a popup that says *Error* isn't going to cut it.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, your error messages will include an action that helps the user fix
    the error. In our popup example, once the user has dismissed the popup, our app
    could automatically select the `EditText` where the user had entered the incorrect
    information, ready for them to start typing.
  prefs: []
  type: TYPE_NORMAL
- en: You should only offer actions that you can actually support, so if the error
    is caused by the user running out of storage space, then offering them a **Try
    Again** button isn't going to solve the problem. If you can't help the user resolve
    an error, it's far better to explain to them what the error is, what's caused
    it, and how they can fix it, rather than offering an empty gesture that's probably
    going to leave them feeling even more frustrated.
  prefs: []
  type: TYPE_NORMAL
- en: When your app does encounter user error, it should try to preserve as much user-entered
    information as possible. So, if a user fills in a form but then enter their password
    incorrectly, your app should preserve their username, address, and any other fields
    they've filled in correctly, while highlighting the fact that they've entered
    the wrong password.
  prefs: []
  type: TYPE_NORMAL
- en: However, while you handle user input errors, don't overlook the importance of
    good design. If your app is going to fail, then it might as well fail in style!
    A well-designed error message should feel like a natural extension of your app.
    In our popup example, we could edit the popup so its colors better complement
    our app's overall color scheme, or we could change the font or include a custom
    sound effect that reflects our app's personality.
  prefs: []
  type: TYPE_NORMAL
- en: Even though I've used a popup message as an example, you should always look
    for ways to make your error messages as unobtrusive as possible, and popups aren't
    particularly subtle. More unobtrusive methods include underlining, highlighting,
    automatically selecting a field where the user has entered something incorrectly,
    reloading the screen with the addition of some text explaining the error that's
    occurred, or taking the user back to the screen where they have entered the wrong
    info.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although user input is one of the most common causes of errors, there are other
    errors and less-than-ideal conditions that your app needs to be able to handle.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lack of connectivity**: If the user is offline and tries to access a feature
    that requires the Internet or network access, you should display an unobtrusive
    message explaining that they need an Internet connection in order to complete
    this action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incompatible state**: These errors occur when the user attempts to run conflicting
    operations, such as trying to send a message via an online messaging app when
    they''re offline. When these errors occur, your app should display a message explaining
    the error and ideally provide the user with an easy way of changing their current
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Missing permissions**: If the user selects an action that requires a certain
    permission, your app should notify the user and give them the option of granting
    that permission. If the user denies this permission request, you should disable
    all related features, so the user doesn''t keep trying to access features that
    your app can''t currently support. You should also give the user an easy way of
    granting previously denied permissions, just in case they change their mind. If
    certain permissions are essential for your app, you should request them in advance.
    We''ll look at permissions in much more detail in [Chapter 10](ch10.html "Chapter 10. Best
    Practices and Securing Your Application"), *Best Practices and Securing Your Application*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Empty states:** These occur when your app can''t display regular content;
    for example, a `ListView` that contains no search results. You should design your
    app to be able to deal with missing content, although the best way to handle the
    situation will vary depending on the context and the type of content that''s missing.
    In our search results example, you could create a **No results found** screen,
    or the app could automatically widen the search query and display content that''s
    the best possible match. For example, if the user searches for `burito`, your
    app could display all recipes that include the word `burrito` instead of displaying
    nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do decide to take a best-possible-match approach, then you should signal
    that this content isn't an exact match. In our search results example, we might
    display a message along the lines of **"We couldn't find any results for burito,
    did you mean burrito?"**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content unavailable:** This is subtly different to empty states as it involves
    content that should appear in your app but for some reason isn''t available. For
    example, perhaps your UI includes images or videos that need to be downloaded
    from the Internet, but the user is currently offline. If your app includes this
    kind of content, you should create placeholders that''ll appear in your layout
    when the content is unavailable. If you don''t, then there''s the risk that your
    layout will suddenly jump about as the missing content becomes available and is
    inserted into the layout, something you may have encountered before when browsing
    slow-to-load webpages on your mobile device. Creating placeholders also ensures
    that your layout retains its intended structure even when some of its content
    is missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to quickly create digital prototypes based
    on your wireframes. Although you created paper prototypes previously, digital
    prototyping is particularly useful for testing how your screen designs will look
    and function on a real Android device and across different screen configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to take away from this chapter is that wireframes are
    a way of planning how your screens will look and function in *theory*, but digital
    prototypes are how you put that theory to the test. Sometimes, you may find that
    the theory doesn't work in practice and that you need to make some changes to
    your wireframes or even redo them completely, but that's okay—discovering problems
    with your design is all part of creating the best possible version of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've finalized your design, in the next chapter we'll take a closer
    look at how you can ensure this newly finalized design translates correctly across
    as many different Android devices as possible.
  prefs: []
  type: TYPE_NORMAL
