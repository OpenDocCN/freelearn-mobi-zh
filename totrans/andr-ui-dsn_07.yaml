- en: Chapter 7. Building a Prototype
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。构建原型
- en: After doing much of the initial design work in the previous chapters, it's now
    time to move past designing and into the early stages of developing. And the first
    development task is to create a digital prototype.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中进行了大量的初始设计工作之后，现在是时候从设计阶段过渡到开发的早期阶段。第一个开发任务是创建一个数字原型。
- en: After creating multiple wireframes and paper prototypes, you may be itching
    to start some *real* development work, but digital prototyping is a *crucial*
    step in the design process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了多个线框图和纸制原型之后，你可能迫不及待地想要开始一些真正的开发工作，但数字原型是设计过程中的一个至关重要的步骤。
- en: Despite all the time and effort you've already invested in your design, at this
    point it's still just a plan. Digital prototyping is where you put this plan to
    the test to see whether it works in the real world. Also, digital prototyping
    is just plain fun as it allows you to go from no code to a working version of
    your app in no time at all.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已经投入了大量的时间和精力在你的设计上，但在这个阶段，它仍然只是一个计划。数字原型是测试这个计划是否在现实世界中可行的地方。此外，数字原型本身也是一种纯粹的乐趣，因为它允许你在极短的时间内从无代码版本快速过渡到工作的应用版本。
- en: By the end of this chapter, you'll have developed a working digital prototype
    of your app. You'll have also finalized your design by planning the finer details
    of your app, which means starting to think about graphic design.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将开发出一个工作的数字原型。你还将通过规划应用更详细的细节来最终确定你的设计，这意味着开始考虑图形设计。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As it's the recommended development environment for Android, this chapter focuses
    on creating digital prototypes using Android Studio. If you don't have Android
    Studio installed, you can grab it from [http://developer.android.com/sdk](http://developer.android.com/sdk).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是 Android 推荐的开发环境，本章重点介绍使用 Android Studio 创建数字原型。如果你还没有安装 Android Studio，你可以从
    [http://developer.android.com/sdk](http://developer.android.com/sdk) 获取它。
- en: If you prefer to use a different IDE, such as Eclipse, then the steps involved
    in creating a digital prototype will be similar, so you will still be able to
    follow along in the IDE of your choice.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用不同的集成开发环境（IDE），例如 Eclipse，那么创建数字原型的步骤将会相似，因此你仍然可以在你选择的 IDE 中继续操作。
- en: Creating a prototype in Android Studio
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建原型
- en: Conveniently, one of the best tools for creating Android prototypes is something
    you probably already have installed—Android Studio.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 便利的是，创建 Android 原型最好的工具之一你可能已经安装了——Android Studio。
- en: This IDE features an advanced layout editor that's ideal for rapidly creating
    digital prototypes. This layout editor automatically opens whenever you open any
    XML layout resource file in Android Studio.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 IDE 具有先进的布局编辑器，非常适合快速创建数字原型。这个布局编辑器会在你打开 Android Studio 中的任何 XML 布局资源文件时自动打开。
- en: '![Creating a prototype in Android Studio](img/B05061_7_1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![在 Android Studio 中创建原型](img/B05061_7_1.jpg)'
- en: The quickest way of creating a digital prototype is to select the editor's **Design**
    tab (where the cursor is positioned in the previous screenshot). A new area will
    open displaying a **canvas** preview of your app's layout, plus a **Palette**
    containing lots of ready-made UI elements called **widgets**. You can quickly
    create a prototype by dragging widgets from the **Palette** and dropping them
    onto the canvas.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数字原型的最快方式是选择编辑器的 **设计** 选项卡（如前一张截图中的光标位置）。将打开一个新区域，显示你的应用布局的 **画布** 预览，以及一个包含许多现成
    UI 元素（称为 **小部件**）的 **调色板**。你可以通过从 **调色板** 拖动小部件并将它们拖放到画布上来快速创建原型。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When creating prototypes (and Android apps in general), you should use the default
    widgets unless you have a very good reason not to. Not only do these ready-made
    widgets make your life as a developer easier, but most Android users will already
    be familiar with them. So they'll instantly know how to interact with at least
    some elements of your app's UI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建原型（以及一般而言的 Android 应用）时，你应该使用默认的小部件，除非你有非常充分的理由不这样做。这些现成的小部件不仅使开发者的生活更加轻松，而且大多数
    Android 用户已经熟悉它们。因此，他们可以立即知道如何与你的应用 UI 的至少一些元素进行交互。
- en: If you need to make more specific changes to your app's layout, you can access
    its underlying XML by selecting the **Text** tab, making your tweaks at the code
    level, and then nipping back to the **Design** tab to see these changes rendered
    on the canvas. Using this approach, you'll have a working prototype in no time,
    which you can then test on your own Android device or in an emulator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更具体地更改应用布局，可以通过选择 **文本** 选项卡访问其底层的 XML，在代码级别进行修改，然后返回到 **设计** 选项卡以查看这些更改在画布上的渲染效果。使用这种方法，您将很快拥有一个可工作的原型，您可以在自己的
    Android 设备或模拟器上对其进行测试。
- en: Creating prototypes in Android Studio is also a great way of testing how your
    design looks and functions across a range of different screen configurations.
    If you simply happen to have multiple Android devices lying around, you can install
    your prototype on all of them, but most Android developers test their project
    across difference devices by creating multiple **Android Virtual Devices** (**AVDs**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建原型也是测试您的设计在不同屏幕配置下看起来和功能如何的绝佳方式。如果您恰好有多台 Android 设备，您可以将原型安装到所有设备上，但大多数
    Android 开发者通过创建多个 **Android 虚拟设备**（**AVD**）来在不同设备上测试他们的项目。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll explore deploying and testing your digital prototypes in more detail in
    the next chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地探讨部署和测试您的数字原型。
- en: 'You can also get a quick preview of your prototype across different devices
    using Android Studio''s built-in **Preview** pane. To access this pane, make sure
    the **Text** tab is selected, and then click on the **Preview** tab along the
    left-hand side of the screen (where the cursor is positioned in the following
    screenshot):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 Android Studio 内置的 **预览** 窗格快速预览您的原型在不同设备上的效果。要访问此窗格，请确保已选择 **文本** 选项卡，然后点击屏幕左侧的
    **预览** 选项卡（如下面的截图所示，光标所在位置）：
- en: '![Creating a prototype in Android Studio](img/B05061_7_2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![在 Android Studio 中创建原型](img/B05061_7_2.jpg)'
- en: 'With this tab open, you''ll see a preview of your app as it appears on a single
    Android device. To check how your layout will appear on a different Android device,
    click on the name of the currently selected device (where the cursor is positioned
    in the following screenshot), and then choose a new device from the drop-down
    menu. You can even preview your UI across multiple devices at once by selecting
    **Preview all screen sizes** from the drop-down menu:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此选项卡打开时，您将看到您的应用在单个 Android 设备上的预览。要检查您的布局在不同 Android 设备上的外观，请点击当前选中设备的名称（如下面的截图所示，光标所在位置），然后从下拉菜单中选择新设备。您甚至可以通过从下拉菜单中选择
    **预览所有屏幕尺寸** 来一次性预览您的 UI 在多个设备上的效果：
- en: '![Creating a prototype in Android Studio](img/B05061_7_3.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![在 Android Studio 中创建原型](img/B05061_7_3.jpg)'
- en: Creating your first prototype
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的第一个原型
- en: You can start by prototyping any screen in your app, but I find that it makes
    sense to start with the first screen users see when they launch your app. In our
    recipe app example, this is the home screen, so this is the first screen I'm going
    to prototype.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从原型化您应用中的任何屏幕开始，但我发现从用户启动应用时看到的第一个屏幕开始更有意义。在我们的食谱应用示例中，这是主页，因此这是我将要原型化的第一个屏幕。
- en: Referring back to my wireframe, I can see that the home screen should include
    a welcome message and photos from some of the recipes featured in the app. I also
    want to include a menu, so users can easily navigate to the app's most important
    screens. Specifically, I want this menu to include a link to the search screen,
    the user's recipe scrapbook, and all the different recipe categories.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我的线框图，我可以看到主页应该包括欢迎信息和来自应用中一些特色食谱的照片。我还想包括一个菜单，以便用户可以轻松导航到应用最重要的屏幕。具体来说，我希望这个菜单包括搜索屏幕、用户的食谱剪贴簿以及所有不同的食谱类别。
- en: Since this menu needs to include quite a few options, I'm going to use a navigation
    drawer. A navigation drawer is an effective solution here, as it's scrollable
    and can be neatly tucked out of the way when it's no longer needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此菜单需要包含相当多的选项，我将使用导航抽屉。在这里，导航抽屉是一个有效的解决方案，因为它可以滚动，并且在不再需要时可以整齐地收起来。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not familiar with the concept of navigation drawers, then you may
    want to look at Android's Material Design guidelines, which has a whole section
    dedicated to navigation drawers  [https://www.google.com/design/spec/patterns/navigation-drawer.html](https://www.google.com/design/spec/patterns/navigation-drawer.html)
    .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉导航抽屉的概念，那么你可能想查看Android的Material Design指南，其中有一个专门介绍导航抽屉的部分 [https://www.google.com/design/spec/patterns/navigation-drawer.html](https://www.google.com/design/spec/patterns/navigation-drawer.html)
    。
- en: Boot up Android Studio and create a new project. Choose whatever settings make
    the most sense for your particular project, but if you're following along with
    this example, then select the **Navigation Drawer** template. As you might already
    have guessed from the name, this template has a built-in navigation drawer, which
    will make creating your home screen digital prototype much easier.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Android Studio并创建一个新的项目。选择对你特定项目最有意义的设置，但如果你正在跟随这个示例，那么请选择**导航抽屉**模板。正如你可能已经从名称中猜到的，这个模板内置了导航抽屉，这将使创建你的主屏幕数字原型变得更加容易。
- en: 'Click on **Finish** to go ahead and create your project. By default, this project
    already includes quite a bit of code and resources. My mission is to modify all
    this automatically generated code to match my home screen wireframe. Let''s start
    with the most straightforward task: creating the screen''s welcome message and
    adding our images.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**完成**以继续创建你的项目。默认情况下，该项目已经包含相当多的代码和资源。我的任务是修改所有这些自动生成的代码，以匹配我的主屏幕线框图。让我们从最直接的任务开始：创建屏幕的欢迎信息和添加我们的图片。
- en: Open the project's `content_main.xml` file and make sure it's using `RelativeLayout`
    as the parent container. Then, select the **Design** tab and drag one `TextView`
    and two `ImageView` widgets from the **Palette**, and drop them onto your canvas.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目的`content_main.xml`文件，确保它使用`RelativeLayout`作为父容器。然后，选择**设计**选项卡，从**画板**拖动一个`TextView`和两个`ImageView`小部件，并将它们拖放到你的画布上。
- en: Next, populate these widgets with text and images. Create a string resource
    that contains the welcome text of your choice. Find two images you want to use
    and add them to your project's `drawable` folder (in my project, I'm using `mushroomtoast.jpeg`
    and `sundayroast.jpeg`). Update `TextView` to display the string resource, and
    update `ImageViews` to display your chosen images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，用文本和图像填充这些小部件。创建一个包含你选择的欢迎文本的字符串资源。找到你想要使用的两张图片并将它们添加到你的项目`drawable`文件夹中（在我的项目中，我使用的是`mushroomtoast.jpeg`和`sundayroast.jpeg`）。更新`TextView`以显示字符串资源，并更新`ImageViews`以显示你选择的图片。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Digital prototyping: Don''t waste your time!**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字原型设计：不要浪费时间！**'
- en: A this point, you may be tempted to invest lots of time positioning your `ImageView` and
    `TextView` objects so that they look *exactly* as they should in your finished
    app. However, be wary of spending too much time perfecting your prototypes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想投入大量时间定位你的`ImageView`和`TextView`对象，以便它们在最终的应用中看起来**完全**正确。然而，要小心不要花太多时间完善你的原型。
- en: The key thing to remember is that the purpose of digital prototyping isn't to
    create an early version of your project but to test the *theory* of your project's
    design. If you spend too much time getting your digital prototypes perfect, then
    you might as well have started creating the first version of your app!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的关键点是，数字原型设计的目的是测试你项目设计的**理论**，而不是创建项目的早期版本。如果你花太多时间使你的数字原型完美，那么你不妨直接开始创建你的应用的第一版！
- en: Your digital prototype may end up highlighting some underlying problems with
    your design, which means you'll need to go back and make some changes to your
    wireframes or even redo them completely. If this happens, then at least you can
    console yourself with the knowledge that it's better to uncover problems with
    your design at this early stage, rather than *after* you've actually started building
    your app. Digital prototyping is a powerful and time-saving tool in your early
    detection arsenal—but *only* if you don't invest lots of time in perfecting your
    prototypes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数字原型可能会突出你设计中的一些潜在问题，这意味着你需要返回并修改你的线框图，甚至完全重新制作它们。如果发生这种情况，那么至少你可以安慰自己，知道在真正开始构建你的应用之前发现设计中的问题更好。数字原型是早期检测工具箱中强大且节省时间的工具——但**仅此而已**，如果你不投入大量时间来完善你的原型。
- en: Don't fall into the trap of worrying about the finer details; instead, aim to
    create your prototypes as quickly as possible. This usually means creating screens
    that are only a rough representation of how the finished screen will look, and
    that typically has little or no functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要陷入担心细节的陷阱；相反，尽量快速地创建你的原型。这通常意味着创建的屏幕只是最终屏幕外观的粗略表示，并且通常功能很少或没有。
- en: 'Here is the XML for my home screen prototype. Since this is only a prototype,
    I haven''t invested too much time in aligning each UI element:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的主屏幕原型的XML代码。由于这只是一个原型，我没有在对齐每个UI元素上投入太多时间：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Check how this looks on your emulator or Android device:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一下在你的模拟器或Android设备上的显示效果：
- en: '![Creating your first prototype](img/B05061_7_4.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建你的第一个原型](img/B05061_7_4.jpg)'
- en: 'The next task is more complex: adding our own menu items to the navigation
    drawer.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务更复杂：向导航抽屉添加我们自己的菜单项。
- en: You'll find all the navigation drawer code in the project's `res/menu/activity_main_drawer.xml`
    file. There's already quite a bit of code in `activity_main_drawer.xml`, but this
    code nicely illustrates how to add items to the navigation drawer, so rather than
    simply deleting it, let's use it as our template.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目的`res/menu/activity_main_drawer.xml`文件中找到所有的导航抽屉代码。`activity_main_drawer.xml`中已经有相当多的代码了，但这段代码很好地说明了如何向导航抽屉添加项，所以我们不妨将其用作模板。
- en: 'Currently, the `activity_main_drawer.xml` file looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`activity_main_drawer.xml`文件看起来是这样的：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As already mentioned, the menu items I want to add are the scrapbook, the search
    screen, and the different recipe categories. The first task is deciding what icons
    I want to use for each of these menu items.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，我想添加的菜单项是剪贴簿、搜索屏幕和不同的食谱类别。第一个任务是决定为这些菜单项使用哪些图标。
- en: Wherever possible, you should use the system icons as most users will already
    be familiar with them, and will therefore know what they mean. You'll find the
    entire list of Material Design system icons at [https://design.google.com/icons/](https://design.google.com/icons/)
    .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，你应该使用系统图标，因为大多数用户已经熟悉它们，因此会知道它们的意思。你可以在[https://design.google.com/icons/](https://design.google.com/icons/)找到所有Material
    Design系统图标的完整列表。
- en: From this long list of icons, I'm going to use the standard Search icon, so
    download this image and drop it into your project's `drawable` folder. Finding
    icons for all the other items isn't quite as straightforward, but since this is
    just a prototype, I'm going to use some placeholder icons for now. I have decided
    to use the Description icon as it kind of looks like a notebook (or a scrapbook),
    and I'm also going to use the knife-and-fork local dining icon for each of the
    recipe categories.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个长长的图标列表中，我将使用标准的搜索图标，所以请下载这张图片并将其放入你的项目的`drawable`文件夹。为其他所有项目找到图标并不那么直接，但既然这只是一个原型，我将暂时使用一些占位符图标。我决定使用描述图标，因为它有点像笔记本（或剪贴簿），我还将使用刀叉本地餐饮图标为每个食谱类别。
- en: 'Once all these images are safely tucked away in the `drawable` folder, it''s
    time to add a few new entries to the navigation drawer code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些图像都安全地存放在`drawable`文件夹中，就是时候向导航抽屉代码中添加一些新的条目了：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And that''s it! Run the finished prototype on your Android device or emulator,
    but this time, be sure to open the navigation drawer by dragging it on the screen.
    You will see some new additions to this drawer:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在你的Android设备或模拟器上运行完成的原型，但这次，请确保通过在屏幕上拖动来打开导航抽屉。你将看到这个抽屉中的一些新添加项：
- en: '![Creating your first prototype](img/B05061_7_5.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![创建你的第一个原型](img/B05061_7_5.jpg)'
- en: Creating your second prototype
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你的第二个原型
- en: Wireframing gives you a clearer picture of your UI, but sometimes even wireframes
    can't effectively illustrate how *every* version of a certain screen will look.
    This is the case with our app's search results screen, as this screen will vary
    depending on what the user has searched for. So, how do we create a single prototype
    that effectively represents our search results screen?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 线框图可以给你一个更清晰的UI视图，但有时即使是线框图也无法有效地说明某个屏幕的每个版本将如何显示。我们的应用程序的搜索结果屏幕就是这样，因为这个屏幕将根据用户搜索的内容而变化。那么，我们如何创建一个能够有效地代表我们的搜索结果屏幕的单个原型呢？
- en: The answer is to create a flexible prototype layout, and feed it some fake data.
    This fake data should accurately represent the complete range of real-life content
    this screen will ultimately have to display. You should go out of your way to
    find the most awkward examples of your app's content, so you can really put your
    design to the test. In our recipe app example, this means using recipes that have
    unusually long or short titles.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是创建一个灵活的原型布局，并给它一些假数据。这些假数据应该准确地代表这个屏幕最终需要显示的完整范围的真实内容。您应该尽力找到您应用内容中最尴尬的例子，这样您才能真正测试您的设计。在我们的菜谱应用示例中，这意味着使用标题异常长或短的菜谱。
- en: To create a prototype of the tricky search results screen, I'm going to create
    `ListView`, and then I will create the arrays of sample recipe titles and images,
    which I'll feed to `ListView`. The `ListView` will then display these arrays in
    my layout as though they're real search results.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个复杂搜索结果屏幕的原型，我将创建`ListView`，然后我将创建样本菜谱标题和图像的数组，我将它们提供给`ListView`。然后`ListView`将在我布局中显示这些数组，就像它们是真实的搜索结果一样。
- en: Once you've created your first prototype, you can either add more screens to
    this project or create each subsequent prototype as a separate project. Personally,
    I feel like the latter is the most straightforward option, so I'm going to create
    my search results prototype as a new project—this time using a blank template.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了第一个原型，您可以选择为这个项目添加更多屏幕，或者将每个后续的原型作为一个单独的项目来创建。我个人觉得后者是最直接的选择，所以我会将我的搜索结果原型作为一个新的项目来创建——这次使用空白模板。
- en: If you also decide to prototype each screen as a separate project, then make
    sure you give each project a different package name, so you can install and test
    them all on the same Android device.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您也决定将每个屏幕作为一个单独的项目来原型设计，那么请确保每个项目都有一个不同的包名，这样您就可以在同一台Android设备上安装和测试它们。
- en: 'Referring back to my wireframes, I can see that the search results screen needs
    to include a list of recipe titles and accompanying images along with a header.
    Let''s start with the most straightforward task: creating the header. Open your
    project''s `strings.xml` file and create a string that''ll provide the search
    screen''s header text:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我的线框图，我可以看到搜索结果屏幕需要包括一个菜谱标题列表和相应的图像，以及一个标题。让我们从最直接的任务开始：创建标题。打开您的项目`strings.xml`文件并创建一个字符串，它将提供搜索屏幕的标题文本：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Open the `activity_main.xml` file and make sure its parent container is a vertical `LinearLayout`.
    Create a `TextView` and set it to display the `sResults` string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件，并确保其父容器是一个垂直的`LinearLayout`。创建一个`TextView`并将其设置为显示`sResults`字符串。
- en: 'Next it''s time to tackle the part of the wireframe that makes this screen
    more difficult to prototype: the search results. As already mentioned, I''m going
    to create a `ListView` and feed it some fake data, so the first step is adding
    the `ListView` to our layout resource file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是处理线框图中的这部分，它使得这个屏幕更难进行原型设计：搜索结果。如前所述，我将创建一个`ListView`并给它一些假数据，所以第一步是将`ListView`添加到我们的布局资源文件中：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**ListViews, adapters, and list items**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**ListView、适配器和列表项**'
- en: A `ListView` is a view group that displays items as a vertical, scrollable list.
    Users can select any item in the list by giving it a tap, which makes `ListViews`
    perfect for displaying our search results, as eventually we want the user to be
    able to open a recipe by tapping its title.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`是一个视图组，它以垂直、可滚动的列表形式显示项目。用户可以通过点击列表中的任何一项来选择，这使得`ListView`非常适合显示我们的搜索结果，因为我们最终希望用户能够通过点击标题来打开菜谱。'
- en: To see an example of a `ListView` in action, grab your Android device and take
    a look at the stock **Contacts** app. It contains a scrollable list of all your
    contacts; you can tap any item in the list to see more information about that
    particular contact. Sound familiar?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`ListView`的实际应用示例，请拿起您的Android设备并查看内置的**联系人**应用。它包含了一个可滚动的联系人列表；您可以在列表中点击任何一项以查看该联系人的更多信息。听起来熟悉吗？
- en: Once you've identified one `ListView`, you'll start noticing them *everywhere*.
    Flick through a few of the apps installed on your device, and chances are you'll
    be surprised by just how often you come across `ListViews`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您识别出一个`ListView`，您就会开始注意到它们无处不在。翻阅一下您设备上安装的一些应用，您可能会惊讶地发现`ListView`出现的频率有多高。
- en: '`ListViews` are made up of *list items*. Each list item is displayed as a row
    in the `ListView`, and these items have their own layout that you define in a
    separate XML file. You can create a simple layout for your list items, or you
    can also create more complex list items that feature multiple pieces of text and
    several images arranged in a `RelativeLayout`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`由*列表项*组成。每个列表项在`ListView`中显示为行，这些项有自己的布局，你在单独的XML文件中定义。你可以为列表项创建一个简单的布局，或者你也可以创建更复杂的列表项，这些列表项包含多段文本和多个图像，这些图像在`RelativeLayout`中排列。'
- en: The final piece of the puzzle is an adapter that acts as a bridge between the
    `ListView` and its underlying data. The adapter pulls content from a specified
    source, such as an array, and adapts this content into views. The adapter then
    takes each view and places it inside the `ListView` as an individual row.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个拼图的最后一块是一个适配器，它充当`ListView`及其底层数据之间的桥梁。适配器从指定的源（如数组）中提取内容，并将这些内容适配到视图中。然后，适配器将每个视图放置在`ListView`中作为一个单独的行。
- en: In this chapter, I'm going to be using `SimpleAdapter`, which is a type of adapter
    that maps static data to views defined in an XML file. This is a pretty straightforward
    adapter, but it does have one catch: `SimpleAdapter` require an `ArrayList` of `Maps`
    in order to define each row in the `ListView`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将使用`SimpleAdapter`，这是一种将静态数据映射到XML文件中定义的视图的适配器类型。这是一个相当直接的适配器，但它有一个缺点：`SimpleAdapter`需要一个`Maps`的`ArrayList`来定义`ListView`中的每一行。
- en: If you want to learn more about `ListViews` and the different kinds of adapters,
    the best place to go is the official Android docs: [http://developer.android.com/guide/topics/ui/layout/listview.html](http://developer.android.com/guide/topics/ui/layout/listview.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`ListView`和不同类型的适配器的信息，最好的地方是官方的Android文档：[http://developer.android.com/guide/topics/ui/layout/listview.html](http://developer.android.com/guide/topics/ui/layout/listview.html)。
- en: 'Let''s define the layout of the individual items/rows that''ll appear in our
    `ListView`. Create a new layout resource file called `simple_list_layout.xml`,
    and then create `TextView` and `ImageView` that will eventually hold the recipe
    titles and accompanying images:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义将在我们的`ListView`中出现的单个项目/行布局。创建一个新的布局资源文件，命名为`simple_list_layout.xml`，然后创建`TextView`和`ImageView`，它们最终将包含食谱标题和相应的图片：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, add all the images for your fake search results. I''m adding the following
    to my project''s `drawable` folder:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加你假搜索结果的所有图片。我将以下内容添加到我的项目的`drawable`文件夹中：
- en: '`blueberrypancake.jpg`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blueberrypancake.jpg`'
- en: '`brownies.jpg`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brownies.jpg`'
- en: '`calamari.jpg`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calamari.jpg`'
- en: '`chilli.jpg`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chilli.jpg`'
- en: '`fryup.jpg`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fryup.jpg`'
- en: '`kashmiricurry.jpeg`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kashmiricurry.jpeg`'
- en: '`pie.jpeg`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pie.jpeg`'
- en: '`redberrypancake.jpeg`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redberrypancake.jpeg`'
- en: '`scallops.jpeg`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scallops.jpeg`'
- en: '`surfandturf.jpg`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`surfandturf.jpg`'
- en: '`sweetandsourprawns.jpeg`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sweetandsourprawns.jpeg`'
- en: '`tuna.jpeg`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuna.jpeg`'
- en: I'm going to add all these images plus the corresponding recipe titles to separate
    arrays. Then, I'm going to feed these arrays to the `ListView` via an adapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这些图片以及相应的食谱标题添加到单独的数组中。然后，我将通过适配器将这些数组传递给`ListView`。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is much more complex than the first prototype, so to speed things up I'm
    writing this code as quickly as possible, forsaking a bit of efficiency and optimization
    along the way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这比第一个原型复杂得多，所以为了加快速度，我将尽可能快地编写这段代码，在这个过程中牺牲了一些效率和优化。
- en: 'Open your project''s `MainActivity.java` and add the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的项目的`MainActivity.java`文件，并添加以下内容：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Attach your Android device to your computer or boot up the emulator and take
    a look at the results:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的Android设备连接到计算机或启动模拟器，查看结果：
- en: '![Creating your second prototype](img/B05061_7_6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![创建你的第二个原型](img/B05061_7_6.jpg)'
- en: Spend some time interacting with your prototype and testing it across different
    screen configurations, whether that's via Android Studio's preview function or
    by creating multiple AVDs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间与你的原型互动，并在不同的屏幕配置下测试它，无论是通过Android Studio的预览功能还是通过创建多个AVD。
- en: Now you have two working prototypes; ask yourself whether there's any way you
    can improve these prototypes. In particular, be on the lookout for any opportunities
    to split your UI into fragments that you can then combine into multipane layouts
    that adapt to different screen configurations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了两个工作原型；问问自己是否有任何方法可以改进这些原型。特别是，要留意任何将你的UI拆分成可以组合成适应不同屏幕配置的多窗格布局的片段的机会。
- en: If your digital prototypes spark any new ideas, then grab a piece of paper and
    try wireframing these ideas. If these new paper-and-pencil wireframes have potential,
    then ideally you should put them through the same vigorous digital wireframing,
    paper prototyping, and usability testing stages that we covered in the previous
    chapter. At the very least, you should create a digital prototype of your new
    designs, and spend some time testing these prototypes—again—across as many different
    screen configurations as possible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数字原型激发出任何新的想法，那么拿一张纸并尝试绘制这些想法的线框图。如果这些新的纸笔线框图有潜力，那么理想情况下你应该将它们通过我们在上一章中提到的同样的严格的数字线框图、纸原型和可用性测试阶段。至少，你应该创建你新设计的数字原型，并花时间尽可能在多种不同的屏幕配置上测试这些原型。
- en: This may feel like taking a step backward, but this is all invaluable for ensuring
    that your design really is the best it possibly can be; and if it improves your
    app, then it's time well spent. If you release the first version of your app when
    you suspect you could have improved the underlying design, you're not going to
    have a good time—and neither are your users.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉像是退步，但这对确保你的设计真的是尽可能最好的至关重要；如果它改善了你的应用，那么这是值得的时间。如果你在怀疑你本可以改进基本设计的情况下发布了你应用的第一版，你不会过得愉快——你的用户也不会。
- en: Also, that old cliché is right—you don't get a second chance to make a first
    impression. Your average user is going to be far more excited by an amazing app
    that seems to come out of nowhere, rather than version 2.0 of an app they tried
    ages ago but weren't too keen on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，那个老套话是正确的——你不会得到第二次机会来留下第一印象。你的普通用户将会对一款看似从天而降的惊人应用感到更加兴奋，而不是他们很久以前尝试过但不太感兴趣的某个应用的2.0版本。
- en: Even if you explore your ideas and then discard them in favor of your original
    design, at least you'll be confident that you really are releasing the best possible
    version of your app. Basically, if your digital prototypes have stirred up any
    new ideas, then now's the time to explore them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你探索了你的想法然后放弃了它们，转而支持你的原始设计，至少你将确信你真的发布了你应用可能最好的版本。基本上，如果你的数字原型激发出了任何新的想法，那么现在是探索这些想法的时候了。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you do create a new series of wireframes and prototypes, it's always good
    to get a second opinion, so you may want to consider performing another round
    of user testing—especially if you find yourself torn between two different design
    directions for your app.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了新的线框图和原型，总是好的得到第二意见，所以你可能想要考虑进行另一轮用户测试——特别是如果你发现自己对你的应用的不同设计方向犹豫不决。
- en: Once you have a set of digital prototypes that you're 100% happy with, it's
    time to finalize these designs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一套你100%满意的数字原型，就是时候完善这些设计了。
- en: Finalizing your design
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完善你的设计
- en: At this point, you should have a firm grasp of the fundamentals of your app's
    design, including what UI elements should appear on each screen, where they'll
    appear on the screen, and the navigation patterns that you want to use. However,
    we still haven't put much thought into the finer details of our app's look and
    feel. What kind of font are you going to use for the headings? What color should
    the buttons be? Will there be any background music or sound effects? And how is
    your app going to use Material Design properties such as elevation and shadow?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该已经牢固掌握了你应用设计的根本，包括每个屏幕上应该出现哪些UI元素，它们将在屏幕上的位置，以及你想要使用的导航模式。然而，我们还没有太多地思考我们应用的外观和感觉的细节。你打算为标题使用哪种字体？按钮应该是什么颜色？会有背景音乐或音效吗？以及你的应用将如何使用如高度和阴影这样的Material
    Design属性？
- en: Here are some of the things you need to consider when finalizing your design.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在完善你的设计时，以下是一些你需要考虑的事项。
- en: Visuals
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视觉效果
- en: This is the finer point of how your UI elements will look. Although you should
    try and use Android's standard widgets wherever possible, there's still lots of
    scope for putting your own twist on standard elements such as buttons and menus,
    particularly in terms of the color palette you use, plus Material Design elements
    such as elevation and shadow.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的UI元素外观的细节之处。尽管你应该尽可能使用Android的标准小部件，但仍然有很多空间来对标准元素，如按钮和菜单，进行自己的调整，特别是在你使用的颜色调色板以及如高度和阴影这样的Material
    Design元素方面。
- en: The ratio of your visual content is also important; should your screen feature
    lots of images and animation, or should it be more text heavy? As always, make
    sure you're designing something that'll appeal to your specific target audience.
    An app that features lots of images and a bright and bold palette might be appropriate
    for a fun app that's targeting a younger audience, but it's probably not so appropriate
    for an app that helps busy professionals balance their finances.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你的视觉内容的比例也很重要；你的屏幕应该有很多图像和动画，还是应该更注重文本？像往常一样，确保你设计的是能够吸引你特定目标受众的东西。一个包含大量图像和明亮的鲜艳色调的应用可能适合一个针对年轻受众的有趣应用，但对于一个帮助忙碌的专业人士平衡财务的应用来说，可能就不太合适了。
- en: Background music and sound effects
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景音乐和音效
- en: Sound is a powerful way of setting the mood, evoking an emotional response,
    and giving your users an immediate feeling of what they can expect from your app.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是一种设置氛围、唤起情感反应并立即让用户感受到他们可以从你的应用中期待什么的强大方式。
- en: However, don't feel like you have to include sound in your app; there's nothing
    wrong with silence, and in some situations, a completely silent app is preferable,
    especially if people are likely to use your app in situations where noise could
    be annoying or inappropriate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不必觉得一定要在你的应用中包含声音；沉默并没有什么不好，而且在某些情况下，一个完全静音的应用可能更受欢迎，尤其是如果人们可能会在噪音可能令人烦恼或不合适的情况下使用你的应用。
- en: If you do include some form of sound, always consider how integral sound should
    be to the user being able to successfully interact with your app. As a general
    rule, your app should be usable regardless of whether users have their volume
    turned way up, way down, or if they're in a location where they can't hear your
    app clearly, such as in a busy bar or restaurant.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你包含某种形式的声音，始终考虑声音对于用户能够成功与你的应用交互有多重要。一般来说，无论用户音量调得很大、很小，或者他们处于一个无法清楚地听到你的应用的地方，如繁忙的酒吧或餐厅，你的应用都应该可用。
- en: The only exceptions are apps that fundamentally rely on sound, such as music
    streaming apps, an app that gives the user driving directions, or some gaming
    apps. In these instances, you can be confident that no one will expect to be able
    to use your app without turning up the volume on their device.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是那些基本依赖于声音的应用，例如音乐流媒体应用、为用户提供驾驶方向的应用或一些游戏应用。在这些情况下，你可以确信没有人会期望在没有提高设备音量的情况下使用你的应用。
- en: Your text
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您的文本
- en: Text is your most direct method of communicating with your users. When crafting
    your text, you need to consider its content along with its visual appearance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是您与用户直接沟通的最直接方法。在制作文本时，您需要考虑其内容及其视觉外观。
- en: Your text's appearance has a massive impact on how easily your users can read
    and understand what that text is saying, but appearance can also send your users
    subtle messages about the text. For example, you can use `textSize` to communicate
    how important each piece of text is and what category it falls into, such as whether
    it's a heading, a caption, or a block of code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文本的外观对用户阅读和理解文本的难易程度有巨大影响，但外观也可以向用户传达关于文本的微妙信息。例如，你可以使用`textSize`来传达每段文本的重要性以及它属于哪个类别，例如它是否是标题、字幕或代码块。
- en: 'To create text styles that really speaks to your users, you can use the following
    attributes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建真正与用户产生共鸣的文本样式，你可以使用以下属性：
- en: '**Text size**: You should decide the size of all your app''s major *types*
    of text early in the design process and *not* on a screen-by-screen basis. By
    limiting yourself to a selection of predefined sizes and using them consistently,
    your users will quickly learn what each `textSize` means. They can then use this
    information to decipher each new screen they encounter in your app, since they''ll
    instantly know which text is the subheading, the body text, and so on, based on
    its size. You specify the font size with the `android:textSize` attribute, for
    example, `android:textSize="10sp."`. The most common method of setting `textSize`
    in advance is to use themes and styles, which we''ll discuss later in this chapter.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本大小**：你应该在设计的早期阶段决定你应用中所有主要文本类型的尺寸，而不是逐屏决定。通过将自己限制在预定义尺寸的选择中并一致地使用它们，你的用户将很快学会每个`textSize`的含义。然后他们可以使用这些信息来解读他们在你的应用中遇到的每个新屏幕，因为他们会立即知道哪个文本是副标题，正文文本，等等。例如，你使用`android:textSize`属性指定字体大小，例如`android:textSize="10sp."`。在提前设置`textSize`的最常见方法是通过主题和样式，我们将在本章后面讨论。'
- en: '**Text style**: Android supports bold, italic, and underlined effects, but
    make sure you use them sparingly. If you use these effects too often, you''re
    adding lots of visual clutter that can make your text difficult to read, plus
    you''ll end up diminishing the effect''s impact. You apply bold, italic, underlined,
    and `bold|italic` effects using the `android:textStyle` attribute, for example, `android:textStyle="bold."`.
    The underlining text is a bit trickier, as you''ll need to create a string resource
    and apply underlining to the text inside that resource, for example, `<string
    name="main_title"><u>This text is underlined</u>This text isn''t</string>`. Then,
    reference this resource from your project''s layout resource file (`android:text="@string/main_title"`),
    and the text will appear underlined in your UI.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本样式**：Android 支持粗体、斜体和下划线效果，但请确保你使用得体，不要过度使用。如果你经常使用这些效果，你会添加很多视觉杂乱，这可能会使你的文本难以阅读，而且你最终会削弱效果的影响力。你可以使用
    `android:textStyle` 属性应用粗体、斜体、下划线和 `bold|italic` 效果，例如，`android:textStyle="bold."`。下划线文本稍微复杂一些，因为你需要创建一个字符串资源，并将下划线应用于该资源内的文本，例如，`<string
    name="main_title"><u>This text is underlined</u>This text isn''t</string>`。然后，从你的项目布局资源文件中引用这个资源（`android:text="@string/main_title"`），文本就会在你的用户界面中显示为下划线。'
- en: '**Capitalization**: Like bold, italic, and underlined effects, you should use
    capitalization sparingly so you don''t reduce its impact. You should also avoid
    using all capitals, as the all-caps text is commonly interpreted as shouting,
    plus it''s much harder for your users to read.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大写**：和粗体、斜体和下划线效果一样，你应该谨慎使用大写，以免降低其影响力。你也应该避免使用全大写，因为全大写的文本通常会被理解为喊叫，而且对用户来说阅读起来也更困难。'
- en: The next thing you need to worry about is what your perfectly styled text is
    actually saying.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来需要关心的是你精心设计的文本实际上在说什么。
- en: Think of text as your app's voice. This voice should align with your app's overall
    design. If your design is colorful and upbeat with cheerful music, then your text
    should be equally friendly. If your design is a bit more edgy, then you may want
    to give your text more attitude.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本视为你应用的“声音”。这个声音应该与你的应用整体设计相一致。如果你的设计色彩丰富、节奏欢快，配有愉快的音乐，那么你的文本也应该同样友好。如果你的设计更加前卫，那么你可能希望给你的文本赋予更多的态度。
- en: Just don't get carried away! Most of the time, it won't make sense to go to
    extremes with your text, and you should opt for a plain and neutral tone instead.
    Remember that the tone and content of your text should reflect the rest of your
    app's design. So, if your UI is streamlined with a focus on getting the job done,
    then chances are you'll want your text to be equally to the point.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 千万不要过分热情！大多数情况下，极端地使用文本并不会使你的文本更有意义，相反，你应该选择一种简洁和中性的语气。记住，你的文本的语气和内容应该反映你应用的整体设计。所以，如果你的用户界面简洁，专注于完成任务，那么你很可能希望你的文本也同样直截了当。
- en: If in doubt, play it safe with a neutral tone.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不确定，就用中性的语气来确保安全。
- en: Your app's personality
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的应用个性
- en: I've left this one until last as it's a bit of a vague concept that incorporates
    a little bit of everything we've discussed so far.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这一点放在最后，因为它是一个有点模糊的概念，它结合了我们之前讨论的方方面面。
- en: Your app's *personality* is a combination of lots of different design elements,
    from visuals, through to background music and the tone of your text.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用个性是一个结合了众多不同设计元素的综合体，从视觉元素到背景音乐和文本的语气。
- en: If your app is going to make a clear and distinct impression on your users,
    then all these different aspects need to align. If these design elements aren't
    consistent, then chances are that you're going to leave your users with the uneasy
    feeling that something is a little *off* about your app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用想要给你的用户留下清晰而鲜明的印象，那么所有这些不同的方面都需要保持一致。如果这些设计元素不一致，那么你可能会让你的用户感到不安，觉得你的应用有点儿*不对劲*。
- en: Imagine you created an app that uses a neutral, pretty pastel palette; is packed
    full of cutesy graphics and ends every line of cheerful, upbeat text with at least
    three exclamation points—but the background music is trash metal!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你创建了一个使用中性、漂亮的粉彩色调的应用，里面充满了可爱的图形，并且每行愉快的、乐观的文本都以至少三个感叹号结束——但是背景音乐却是垃圾金属乐！
- en: Take a critical look at all the design decisions you've just made so far. Do
    they all come together to form a cohesive whole? Or does one (or more) elements
    stick out like the proverbial sore thumb?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细审视你刚刚做出的所有设计决策。它们是否都汇聚在一起形成一个统一的整体？或者是否有一个（或多个）元素像俗语所说的那样“突出”？
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Rules are made to be broken!**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则是为了被打破的！**'
- en: Although most of the time you *will* want all your design aspects to align,
    occasionally you may decide to throw the user a curveball in the form of an element
    that intentionally clashes with the rest of your app. This technique can create
    some very powerful effects; for example, you might combine cheerful colors and
    enthusiastic text with unsettling music to create a creepy and unnerving experience,
    or you may want to combine cutesy graphics with dry and sarcastic text to get
    your users laughing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数时候你都会希望所有设计方面保持一致，但偶尔你可能会决定给用户一个意外，比如一个故意与你的应用其他部分冲突的元素。这种技术可以创造出一些非常强大的效果；例如，你可能会将明亮的颜色和热情的文字与令人不安的音乐结合起来，创造出一种令人毛骨悚然和不安的经历，或者你可能想将可爱的图形与干巴巴和讽刺的文字结合起来，让用户发笑。
- en: If you do decide to break the rules, just make sure you have a clear idea of
    what you're trying to achieve and how you're trying to achieve it, as it's easy
    to get this technique wrong!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定打破规则，请确保你清楚地知道你想要达到的目标以及你打算如何实现它，因为这很容易出错！
- en: If you're struggling to decide what your app's overall personality should be,
    then think about what'll appeal the most to your target audience.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以决定你的应用的整体个性应该是什么，那么考虑一下什么最能吸引你的目标受众。
- en: As always, if you're struggling for inspiration, head over to the Google Play
    store and hunt down a few apps that are similar to your project or that target
    the same audience.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，如果你在寻找灵感，就去谷歌应用商店搜索一些与你的项目类似或针对相同受众的应用。
- en: Since we want our recipe app to appeal to students, I'm going to visit the Play
    store and search for apps that include the word `student`. Instantly, I see a
    whole bunch of timetable and agenda apps, forums that specifically target university
    students, and homework planners. In this scenario, I'd download a few of the most
    highly-rated apps, and then spend some time flicking through them to get a feel
    for their personality. I'd also probably download a few 5 star-rated recipe apps
    and give them the same treatment before combining all my findings and using them
    to influence the look and feel of my own recipe app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望我们的食谱应用能够吸引学生，我将访问应用商店并搜索包含单词“student”的应用。立刻，我看到了一大堆时间表和日程安排应用，专门针对大学生的论坛，以及家庭作业规划器。在这种情况下，我会下载一些评分最高的应用，然后花些时间浏览它们，以了解它们的个性。我可能还会下载一些五星级的食谱应用，并给予它们同样的待遇，然后再将所有发现结合起来，用以影响我自己的食谱应用的视觉效果和感觉。
- en: Creating themes and styles
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主题和样式
- en: Now that you've made some decisions regarding the finer details of your UI,
    it's time to think about how you might implement them. This is where themes and
    styles come in useful, as they're one of the quickest and easiest ways of implementing
    design decisions consistently across your views, activities, and even your entire
    application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对UI的细节做出了一些决策，是时候考虑如何实现它们了。这就是主题和样式发挥作用的地方，因为它们是跨视图、活动甚至整个应用实现设计决策最快、最简单的方式。
- en: Once you've made these design decisions, it's a good idea to create styles and
    perhaps even a theme to help you implement your designs easily and consistently.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做出了这些设计决策，创建样式甚至是一个主题来帮助你轻松且一致地实现设计是个好主意。
- en: 'Styles and themes are essentially the same thing: a collection of properties.
    These properties can be anything from the color of your text, to the size of an
    `ImageView`, or even the `"wrap_content"` attribute. The difference isn''t how
    you create this collection of properties, but how you *apply* them to your project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 样式和主题本质上是一样的：一组属性。这些属性可以是文本的颜色、`ImageView`的大小，甚至是`"wrap_content"`属性。区别不在于你如何创建这组属性，而在于你如何将它们应用到你的项目中：
- en: Styles are the groups of properties that control what a view looks like; for
    example, you might apply a style to a `TextView` to specify the size and color
    of all the text within it.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式是一组控制视图外观的属性；例如，你可能会将一个样式应用到`TextView`上，以指定其中所有文本的大小和颜色。
- en: Themes are groups of properties that you apply to an activity or even an entire
    application. When you apply a theme to an activity, every view inside the activity
    will use any property that applies to it. If you apply a theme to an app, *every*
    view throughout that app will use all the applicable properties from this theme.
    You'll typically extend another theme rather than create one from scratch.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题是一组属性，你可以将其应用到活动或整个应用中。当你将主题应用到活动时，活动内的每个视图都将使用适用于它的任何属性。如果你将主题应用到应用中，那么应用中的每个视图都将使用此主题的所有适用属性。你通常会扩展另一个主题而不是从头创建一个。
- en: 'Styles and themes do take a bit of prep work, so why should you go to the effort
    of creating themes and styles, when you could just apply properties to views directly?
    There are a few reasons:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 样式和主题确实需要一些准备工作，所以为什么你要费心创建主题和样式，而不是直接将属性应用到视图中呢？有几个原因：
- en: '**It''s efficient**: If you''re going to use the same collection of attributes
    multiple times throughout an app, then defining these properties in advance makes
    applying them *much* easier—as easy as typing `style="@style/captionFont"` in
    fact.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它很高效**：如果你打算在应用中多次使用同一组属性，那么提前定义这些属性会使应用它们变得容易得多——实际上就像输入`style="@style/captionFont"`一样简单。'
- en: '**It''s consistent**: Defining a collection of attributes as a style or theme
    helps create a consistent look and feel across your app. And as we''ve already
    discussed, users *love* consistency.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它是一致的**：将一组属性定义为样式或主题有助于在整个应用中创建一致的视觉和感觉。而且，正如我们之前讨论的，用户喜欢一致性。'
- en: '**It''s flexible**: Design changes are pretty much a fact of life, so you should
    expect to be tweaking your app''s visuals throughout the entire development process.
    Themes and styles provide a central place where you can make changes once and
    have them appear instantly across your app. Decided that your headings should
    be 10dp larger? Easy, just increase the `android:textSize` attribute in your `style="@style/heading"`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它很灵活**：设计变更几乎是生活的常态，因此你应该在整个开发过程中预期会不断调整你的应用视觉。主题和样式提供了一个中心位置，你可以在这里一次性做出更改，然后它们会立即出现在你的应用中。决定你的标题应该比10dp大？简单，只需增加你的`style="@style/heading"`中的`android:textSize`属性。'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember when we were talking about the `textSize` attribute and how using
    only a small selection of text sizes can help users decode your UI? This rule
    also applies to styles. If you use a limited number of styles, your users will
    quickly pick up what these styles mean, and then use this information to help
    them decipher new screens. To get the most out of styles (and, to a lesser extent,
    themes) pay attention to that old cliché: less is more.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前在谈论`textSize`属性以及如何仅使用少量文本大小可以帮助用户解码你的UI吗？这条规则也适用于样式。如果你使用有限数量的样式，你的用户会很快了解这些样式的含义，然后利用这些信息来帮助他们解码新的屏幕。为了最大限度地利用样式（以及，在一定程度上，主题），请注意那个老套话：少即是多。
- en: Defining styles
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义样式
- en: To create a style (or series of styles), you need to create a `styles.xml` file
    in your project's `res/values` folder, if it doesn't contain this file already.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建样式（或一系列样式），你需要在你项目的`res/values`文件夹中创建一个`styles.xml`文件，如果它还没有这个文件的话。
- en: 'You can then create styles using the following format:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下格式创建样式：
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Okay, so this may look like a lot of work, but bear in mind that you wouldn't
    create a style to use just once. Typically, you'll define a style in advance,
    and then use it multiple times throughout your project. Plus once you've defined
    a style, you can use inheritance to create variations of this style (which we'll
    explore in more detail later in this chapter).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这看起来可能像是一项大量工作，但请记住，你不会创建一个只使用一次的样式。通常，你会在项目前期定义一个样式，然后在项目中的多个地方使用它。此外，一旦定义了样式，你就可以使用继承来创建此样式的变体（我们将在本章后面更详细地探讨）。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What''s in a name?**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**名字里有什么？**'
- en: Put some thought into what you call each style, as a style's name can communicate
    valuable information about its purpose and relationship with other styles.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在为每个样式命名时，要考虑一下你叫什么，因为样式的名称可以传达有关其目的和其他样式之间关系的有价值信息。
- en: For the best results, always name your styles based on their purpose rather
    than their appearance, as this might change as you refine your UI.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳效果，始终根据其目的而不是外观来命名你的样式，因为随着你精炼UI，外观可能会改变。
- en: As an example, `CaptionStyle` is a good name but `ItalicsLightCaption` isn't,
    as your UI might evolve to a point where light, italicized text no longer fits
    with the rest of your UI. At this point, you have two options. You can continue
    using this inconsistent style name, which is potentially confusing, especially
    if you're collaborating on this project with others.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`CaptionStyle`是一个好的名称，但`ItalicsLightCaption`就不太合适，因为你的UI可能会发展到轻量级斜体文本不再适合你的UI。在这种情况下，你有两个选择。你可以继续使用这个不一致的样式名称，这可能会造成混淆，尤其是如果你与其他人合作进行这个项目的话。
- en: Alternatively, you'll need to open `styles.xml`, and give your style a new name,
    but you'd then also need to manually change every reference to this style throughout
    your project. As you can see, neither of these are ideal solutions!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你需要打开`styles.xml`文件，给你的样式赋予一个新的名称，但这样你还需要手动更改项目中所有对这个样式的引用。正如你所看到的，这两种方法都不是理想的解决方案！
- en: 'Once you''ve created your style, applying it to a view is straightforward;
    just open an XML layout resource file and use the `@style` attribute, followed
    by the name of the style you want to apply:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了样式，将其应用到视图上就很简单了；只需打开一个XML布局资源文件，并使用`@style`属性，后跟你想应用的样式的名称：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Not all views accept the same style attributes; for example, an `ImageView`
    won't accept an `android:textAlignment`. The official Android docs is the best
    place to check what properties a particular view supports, specifically the view's
    corresponding class reference where you'll find a table of supported XML attributes.
    For example, if you were creating a text style, then you might want to take a
    look at the `TextView` class reference ([http://developer.android.com/reference/android/widget/TextView.html](http://developer.android.com/reference/android/widget/TextView.html)).
    Also, bear in mind that some views extend other views, so if you were creating
    a style to apply to `EditText`, it'd be worth taking a look at the `TextView`
    class reference too, as `EditText` extends the `TextView` class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有视图都接受相同的样式属性；例如，`ImageView`不接受`android:textAlignment`。官方Android文档是检查特定视图支持哪些属性的最佳地方，特别是视图对应的类参考，在那里你可以找到一个支持XML属性的表格。例如，如果你正在创建一个文本样式，那么你可能想查看`TextView`类参考([http://developer.android.com/reference/android/widget/TextView.html](http://developer.android.com/reference/android/widget/TextView.html))。此外，请记住，一些视图扩展了其他视图，所以如果你正在创建应用于`EditText`的样式，那么查看`TextView`类参考也是值得的，因为`EditText`扩展了`TextView`类。
- en: Sometimes, you'll inadvertently apply incompatible properties to a view, particularly
    when you're applying a style to an entire activity, or when you're applying a
    theme. So, what happens then? The answer is *not much*. A view will only accept
    properties that it supports, and it'll ignore the rest.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能会无意中将不兼容的属性应用到视图上，尤其是在你将样式应用到整个活动或应用主题时。那么会发生什么呢？答案是*不多*。视图只会接受它支持的属性，并忽略其余的。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you apply a style to a view, this style is applied to that view only. If
    you apply a style to `ViewGroup`, the child view elements won't inherit the style's
    properties. If you want to apply a style to multiple views at once, then you should
    apply the style as a theme instead.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一种样式应用到视图上时，这种样式只会应用到该视图。如果你将样式应用到`ViewGroup`上，子视图元素不会继承样式的属性。如果你想一次性将样式应用到多个视图上，那么你应该将样式作为一个主题来应用。
- en: Some style properties are not supported by any view, and you can only apply
    them as a theme to an activity or across an entire app. For example, properties
    that hide the application title won't have any impact when applied to a single
    view. These attributes are easy to spot as they all begin with `window`, such
    as `windowNotTitle`, `windowTitleSize`, and `windowNoDisplay`. You'll find the
    complete list at the `R.attr` reference that's available as part of the official
    Android docs at [http://developer.android.com/reference/android/R.attr.html](http://developer.android.com/reference/android/R.attr.html).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些样式属性不被任何视图支持，你只能将它们作为主题应用到活动或整个应用中。例如，隐藏应用标题的属性在应用到单个视图时不会有任何影响。这些属性很容易识别，因为它们都以`window`开头，例如`windowNotTitle`、`windowTitleSize`和`windowNoDisplay`。你可以在官方Android文档的`R.attr`参考中找到完整的列表，该参考作为官方Android文档的一部分在[http://developer.android.com/reference/android/R.attr.html](http://developer.android.com/reference/android/R.attr.html)提供。
- en: Inheritance
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: You can quickly and easily create variations on existing styles by using them
    as **parent styles** and inheriting their attributes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将它们用作**父样式**并继承它们的属性来快速轻松地创建现有样式的变体。
- en: 'Use the `<parent>` attribute to specify the style you want to inherit from.
    You can then add properties and change the existing properties by overriding them
    with new values. You can inherit from the styles that you''ve created yourself
    or from the styles that are built into the Android platform, such as the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<parent>` 属性来指定你想要继承的样式。然后你可以添加属性，通过用新值覆盖它们来更改现有属性。你可以从你自己创建的样式继承，或者从 Android
    平台内置的样式继承，如下所示：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you want to inherit from the styles that you've defined yourself, you don't
    have to use the `<parent>` attribute. However, it's generally considered best
    practice to prefix the name of the parent style to the name of your new style,
    and separate the two with a full stop.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要继承你定义的样式，你不需要使用 `<parent>` 属性。然而，通常认为将父样式的名称作为你的新样式的名称前缀，并用句点分隔是最佳实践。
- en: 'Imagine I wanted to create a new style that inherits from a custom `FooterText`
    style which I created earlier, but that increases the `textsize` from 12sp to
    20sp. I''d do this with the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想创建一个新的样式，它继承了我之前创建的自定义 `FooterText` 样式，但将 `textsize` 从 12sp 增加到 20sp。我会用以下代码来做这件事：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You reference this inherited style in exactly the same way as any other style;
    in this instance that's `style="@style/FooterText.Large"`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你将以与任何其他样式完全相同的方式引用这个继承的样式；在这个例子中是 `style="@style/FooterText.Large"`。
- en: You can continue inheriting like this as many times as you like; just keep chaining
    these style names together with full stops. There's nothing stopping you from
    creating `FooterText.Large.Blue`, `FooterText.Large.Italic`, `FooterText.Large.Blue.Bold`,
    and so on.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续这样继承，次数不限；只需将这些样式名称用句点连接起来。没有任何阻止你创建 `FooterText.Large.Blue`、`FooterText.Large.Italic`、`FooterText.Large.Blue.Bold`
    等等的。
- en: However, to make it easier to remember all your style names correctly and help
    distinguish between styles, it's a good idea not to get carried away! After all,
    `FooterText.Large.Blue.Bold.Underlined.Monospace` isn't the easiest thing to remember.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了更容易记住所有样式名称并帮助区分样式，最好不要过于沉迷！毕竟，`FooterText.Large.Blue.Bold.Underlined.Monospace`
    并不是最容易记住的。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Inheriting properties by chaining style names together only works for styles
    you create yourself. If you want to inherit from Android's built-in styles, you
    need to use the parent attribute.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将样式名称链接起来继承属性仅适用于你自己创建的样式。如果你想从 Android 的内置样式继承，你需要使用父属性。
- en: Working with themes
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与主题一起工作
- en: At this point you may be wondering why we've spent so much time focusing on
    styles without really discussing themes. This is because you define a theme in
    exactly the same way you define a style. You could take any of the styles we've
    defined above, and apply them as a theme.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道为什么我们花了这么多时间关注样式，而没有真正讨论主题。这是因为你定义主题的方式与定义样式的方式完全相同。你可以将上面定义的任何样式作为主题应用。
- en: 'To apply a theme, open your project''s `Manifest.xml` and add the `android:theme`
    attribute to either of the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用主题，打开你的项目 `Manifest.xml` 文件，并将 `android:theme` 属性添加到以下任何一个：
- en: '**The <application> tag**: If you want to apply a theme across your entire
    app, find the `<application>` tag and add the `android:theme` attribute, plus
    your style name, for example, `<application android:theme="@style/FooterFont">`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<application> 标签**：如果你想在整个应用中应用主题，找到 `<application>` 标签，并添加 `android:theme`
    属性以及你的样式名称，例如，`<application android:theme="@style/FooterFont">`'
- en: '**The <activity> tag**: To apply your theme to a specific activity, add `android:theme`
    to the relevant `<activity>` tag'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<activity> 标签**：要将你的主题应用到特定的活动，向相关的 `<activity>` 标签添加 `android:theme`。'
- en: When you apply a theme, every view within the activity or across the app will
    use all the theme properties that it can support. If you apply `FooterFont` to
    an activity, all `TextViews` (and views that extend `TextView`) within that activity
    will use this collection of properties. If you apply `FooterFont` across your
    app, all `TextViews` and views that extend `TextView` will assume these properties,
    but any view that *doesn't* support the `FooterFont` properties will simply ignore
    them. And if a view supports some of the `FooterFont` properties and not others,
    it'll apply the supported properties and ignore the rest.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用一个主题时，活动或应用中的每个视图都将使用它所能支持的所有的主题属性。如果你将`FooterFont`应用到活动上，该活动中的所有`TextView`（以及扩展`TextView`的视图）都将使用这些属性集合。如果你在整个应用中应用`FooterFont`，所有`TextView`和扩展`TextView`的视图都将假定这些属性，但任何不支持`FooterFont`属性的视图将简单地忽略它们。如果一个视图支持一些`FooterFont`属性但不支持其他属性，它将应用支持的属性并忽略其余的。
- en: To save you time and effort, the Android platform includes many predefined themes
    that you can use, including a selection of Material themes. You'll find a list
    of all the available styles in the **R**.style section of the official Android
    docs ([http://developer.android.com/reference/android/R.style.html](http://developer.android.com/reference/android/R.style.html)).
    To use any of the platform styles and themes, replace all the underscores in the
    style name with a period, so `Theme_Dialog` becomes `"@android:style/Theme.Dialog"`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省你的时间和精力，Android平台包括许多预定义的主题，你可以使用，包括一系列的Material主题。你可以在官方Android文档的**R.style**部分找到所有可用的样式列表([http://developer.android.com/reference/android/R.style.html](http://developer.android.com/reference/android/R.style.html))。要使用平台样式和主题，将样式名称中的所有下划线替换为点，例如`Theme_Dialog`变为`"@android:style/Theme.Dialog"`。
- en: 'If you want to customize a built-in theme, you should use the theme as the
    `<parent>` tag of your own custom theme, and then add your own properties or override
    the existing properties, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自定义内置主题，你应该将主题用作你自己的自定义主题的`<parent>`标签，然后添加你自己的属性或覆盖现有属性，如下所示：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The final step is updating your project''s `Manifest` to use your new theme.
    So, if you wanted to use `MyTheme` in a specific activity, you''d write the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新你的项目的`Manifest`以使用你的新主题。所以，如果你想在一个特定的活动中使用`MyTheme`，你会编写以下内容：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To use `MyTheme` across your entire application, you''d write the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要在整个应用中使用`MyTheme`，你会编写以下内容：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Get ready for errors!
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好错误吧！
- en: In a perfect world, users will only ever interact with your app under ideal
    conditions. If your app pulls content from the Internet, people will only ever
    open your app when they have a lightning-fast connection to the World Wide Web.
    Your app will never have to deal with interruptions such as pesky incoming calls
    or SMS messages, and your users will certainly *never* enter their username or
    password incorrectly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界里，用户只会在你应用的最佳条件下与之互动。如果你的应用从互联网获取内容，人们只有在拥有闪电般的网络连接时才会打开你的应用。你的应用永远不会遇到诸如讨厌的来电或短信消息这样的中断，而且用户当然*永远不会*输入错误的用户名或密码。
- en: Sadly, this isn't the way the real world works. Your users will make mistakes,
    run out of storage space, lose their Internet connection, and get phone calls
    when they're midway through the final boss battle in your RPG app. Your app must
    be able to handle all these less-than-ideal conditions and errors.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，现实世界并不是这样。你的用户会犯错误，耗尽存储空间，失去互联网连接，在你RPG应用的最终Boss战中途接到电话。你的应用必须能够处理所有这些不理想的情况和错误。
- en: It may seem strange to plan for errors, but unfortunately errors happen to the
    best of us. Not only should your app be able to handle errors when they do occur,
    but it should handle them *gracefully*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为错误做准备可能看起来很奇怪，但不幸的是，即使是最好的我们也会出错。不仅你的应用应该能够在出错时处理它们，而且它应该能够优雅地处理它们。
- en: In the final section of this chapter, we'll look at how to design your app so
    that it can handle whatever the real world throws at it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨如何设计你的应用，使其能够处理现实世界抛给它的任何东西。
- en: User input errors
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户输入错误
- en: User input errors are where users enter incorrect information or leave a field
    blank. The most common places where user errors occur are forms such as login
    screens or payment screens.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入错误是指用户输入错误信息或留空字段。用户错误最常见的地方是登录屏幕或支付屏幕等表单。
- en: Assuming that you clearly communicated what information the user needed to enter,
    technically these errors aren't your fault, but you should still design your app
    to be able to cope with these kinds of error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经清楚地传达了用户需要输入的信息，从技术上讲，这些错误不是你的责任，但你仍然应该设计你的应用程序能够处理这类错误。
- en: When user errors occur, your app should clearly communicate what's happened
    and give the user enough information to be able to fix the problem. Simply displaying
    a popup that says *Error* isn't going to cut it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户错误发生时，你的应用程序应该清楚地传达发生了什么，并给用户足够的信息以便他们能够解决问题。仅仅显示一个写着“错误”的弹窗是远远不够的。
- en: Ideally, your error messages will include an action that helps the user fix
    the error. In our popup example, once the user has dismissed the popup, our app
    could automatically select the `EditText` where the user had entered the incorrect
    information, ready for them to start typing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你的错误消息应包括帮助用户修复错误的操作。在我们的弹窗示例中，一旦用户关闭了弹窗，我们的应用程序可以自动选择用户输入错误信息的`EditText`字段，以便他们开始输入。
- en: You should only offer actions that you can actually support, so if the error
    is caused by the user running out of storage space, then offering them a **Try
    Again** button isn't going to solve the problem. If you can't help the user resolve
    an error, it's far better to explain to them what the error is, what's caused
    it, and how they can fix it, rather than offering an empty gesture that's probably
    going to leave them feeling even more frustrated.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只提供你可以实际支持的操作，所以如果错误是由于用户存储空间不足造成的，那么提供一个“重试”按钮是无法解决问题的。如果你无法帮助用户解决错误，那么向他们解释错误是什么、是什么原因造成的以及他们如何修复它，要比提供一个可能让他们感到更加沮丧的空洞手势要好得多。
- en: When your app does encounter user error, it should try to preserve as much user-entered
    information as possible. So, if a user fills in a form but then enter their password
    incorrectly, your app should preserve their username, address, and any other fields
    they've filled in correctly, while highlighting the fact that they've entered
    the wrong password.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序遇到用户错误时，它应该尽可能保留用户输入的信息。因此，如果一个用户填写了表单但输入了错误的密码，你的应用程序应该保留他们的用户名、地址以及他们正确填写的任何其他字段，同时突出显示他们输入了错误的密码。
- en: However, while you handle user input errors, don't overlook the importance of
    good design. If your app is going to fail, then it might as well fail in style!
    A well-designed error message should feel like a natural extension of your app.
    In our popup example, we could edit the popup so its colors better complement
    our app's overall color scheme, or we could change the font or include a custom
    sound effect that reflects our app's personality.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在处理用户输入错误的同时，不要忽视良好设计的重要性。如果你的应用程序将要失败，那么它至少应该以一种风格化的方式失败！一个设计良好的错误消息应该感觉像是你应用程序的自然延伸。在我们的弹窗示例中，我们可以编辑弹窗，使其颜色更好地与我们的应用程序整体配色方案相匹配，或者我们可以更改字体或包含反映我们应用程序个性的自定义音效。
- en: Even though I've used a popup message as an example, you should always look
    for ways to make your error messages as unobtrusive as possible, and popups aren't
    particularly subtle. More unobtrusive methods include underlining, highlighting,
    automatically selecting a field where the user has entered something incorrectly,
    reloading the screen with the addition of some text explaining the error that's
    occurred, or taking the user back to the screen where they have entered the wrong
    info.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我以弹窗消息为例，但你应该始终寻找使你的错误消息尽可能不显眼的方法，而弹窗并不特别微妙。更不显眼的方法包括下划线、突出显示、自动选择用户输入错误信息的字段、在屏幕上添加一些解释已发生错误的文本后重新加载屏幕，或者将用户带回到他们输入错误信息的屏幕。
- en: 'Although user input is one of the most common causes of errors, there are other
    errors and less-than-ideal conditions that your app needs to be able to handle.
    These include the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用户输入是导致错误最常见的原因之一，但还有其他错误和不太理想的情况，你的应用程序需要能够处理。以下是一些例子：
- en: '**Lack of connectivity**: If the user is offline and tries to access a feature
    that requires the Internet or network access, you should display an unobtrusive
    message explaining that they need an Internet connection in order to complete
    this action.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接问题**：如果用户离线并尝试访问需要互联网或网络访问的功能，你应该显示一个不显眼的提示信息，说明他们需要互联网连接才能完成此操作。'
- en: '**Incompatible state**: These errors occur when the user attempts to run conflicting
    operations, such as trying to send a message via an online messaging app when
    they''re offline. When these errors occur, your app should display a message explaining
    the error and ideally provide the user with an easy way of changing their current
    state.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不兼容状态**：当用户尝试执行冲突的操作时，例如在离线状态下尝试通过在线消息应用发送消息时，会发生这些错误。当这些错误发生时，您的应用应显示一条解释错误的消息，并最好为用户提供一种简单的方法来更改他们的当前状态。'
- en: '**Missing permissions**: If the user selects an action that requires a certain
    permission, your app should notify the user and give them the option of granting
    that permission. If the user denies this permission request, you should disable
    all related features, so the user doesn''t keep trying to access features that
    your app can''t currently support. You should also give the user an easy way of
    granting previously denied permissions, just in case they change their mind. If
    certain permissions are essential for your app, you should request them in advance.
    We''ll look at permissions in much more detail in [Chapter 10](ch10.html "Chapter 10. Best
    Practices and Securing Your Application"), *Best Practices and Securing Your Application*.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺少权限**：如果用户选择了一个需要特定权限的操作，您的应用应通知用户，并给他们提供授予该权限的选择。如果用户拒绝此权限请求，您应禁用所有相关功能，这样用户就不会继续尝试访问应用目前无法支持的功能。您还应为用户提供一种简单的方法来授予之前拒绝的权限，以防他们改变主意。如果某些权限对您的应用至关重要，您应提前请求它们。我们将在第10章[“最佳实践和应用程序安全”](ch10.html
    "第10章。最佳实践和应用程序安全")中更详细地讨论权限，*最佳实践和应用程序安全*。'
- en: '**Empty states:** These occur when your app can''t display regular content;
    for example, a `ListView` that contains no search results. You should design your
    app to be able to deal with missing content, although the best way to handle the
    situation will vary depending on the context and the type of content that''s missing.
    In our search results example, you could create a **No results found** screen,
    or the app could automatically widen the search query and display content that''s
    the best possible match. For example, if the user searches for `burito`, your
    app could display all recipes that include the word `burrito` instead of displaying
    nothing.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空状态**：当您的应用无法显示常规内容时会发生这种情况；例如，一个没有任何搜索结果的`ListView`。您应该设计您的应用能够处理缺失的内容，尽管处理这种情况的最佳方法将取决于上下文和缺失的内容类型。在我们的搜索结果示例中，您可以创建一个**“无结果找到”**屏幕，或者应用可以自动扩展搜索查询并显示最佳匹配的内容。例如，如果用户搜索`burito`，您的应用可以显示所有包含单词`burrito`的食谱，而不是显示无内容。'
- en: If you do decide to take a best-possible-match approach, then you should signal
    that this content isn't an exact match. In our search results example, we might
    display a message along the lines of **"We couldn't find any results for burito,
    did you mean burrito?"**
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你决定采取最佳匹配的方法，那么你应该表明此内容并非完全匹配。在我们的搜索结果示例中，我们可能会显示一条类似的消息，例如**“我们找不到任何关于burito的结果，您是指burrito吗？”**
- en: '**Content unavailable:** This is subtly different to empty states as it involves
    content that should appear in your app but for some reason isn''t available. For
    example, perhaps your UI includes images or videos that need to be downloaded
    from the Internet, but the user is currently offline. If your app includes this
    kind of content, you should create placeholders that''ll appear in your layout
    when the content is unavailable. If you don''t, then there''s the risk that your
    layout will suddenly jump about as the missing content becomes available and is
    inserted into the layout, something you may have encountered before when browsing
    slow-to-load webpages on your mobile device. Creating placeholders also ensures
    that your layout retains its intended structure even when some of its content
    is missing.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容不可用**：这与空状态微妙不同，因为它涉及到应该出现在您的应用中的内容，但由于某种原因不可用。例如，也许您的UI包括需要从互联网下载的图片或视频，但用户目前处于离线状态。如果您的应用包含此类内容，您应该在内容不可用时创建占位符，这些占位符将出现在您的布局中。如果您不这样做，那么当缺失的内容变得可用并被插入到布局中时，您的布局可能会突然跳动，这可能是您在移动设备上浏览加载缓慢的网页时遇到过的。创建占位符还可以确保即使某些内容缺失，您的布局也能保持其预期的结构。'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to quickly create digital prototypes based
    on your wireframes. Although you created paper prototypes previously, digital
    prototyping is particularly useful for testing how your screen designs will look
    and function on a real Android device and across different screen configurations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何快速创建基于你的线框的数字原型。虽然你之前创建了纸质原型，但数字原型对于测试你的屏幕设计在真实Android设备上以及在不同屏幕配置下的外观和功能尤其有用。
- en: The most important thing to take away from this chapter is that wireframes are
    a way of planning how your screens will look and function in *theory*, but digital
    prototypes are how you put that theory to the test. Sometimes, you may find that
    the theory doesn't work in practice and that you need to make some changes to
    your wireframes or even redo them completely, but that's okay—discovering problems
    with your design is all part of creating the best possible version of your app.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中你应吸取的最重要的一点是，线框是规划你的屏幕在*理论上*将如何看起来和工作的方式，但数字原型是你将这种理论付诸实践的方式。有时，你可能会发现理论在实际中并不适用，你可能需要对你的线框进行一些修改，甚至完全重新设计，但这没关系——发现你设计中的问题是你创建最佳应用版本过程中的一个重要部分。
- en: Now that you've finalized your design, in the next chapter we'll take a closer
    look at how you can ensure this newly finalized design translates correctly across
    as many different Android devices as possible.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了你的设计，在下一章中，我们将更深入地探讨如何确保这个新完成的设计尽可能正确地转换到尽可能多的不同Android设备上。
