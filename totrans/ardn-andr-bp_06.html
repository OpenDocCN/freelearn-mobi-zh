<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Android Phone Sensor"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Android Phone Sensor</h1></div></div></div><p>In this book so far, we have used an Android device to control Arduino projects and get readings from sensors connected to the Arduino board. In this chapter, we will do something different: we will use the phone's sensors to control an Arduino board.</p><p>We will connect a <a id="id310" class="indexterm"/>servomotor to an Arduino board so that it can be controlled from the Android phone. A servomotor is basically a motor whose angular position can be precisely controlled by a microcontroller. We will use BLE once more to receive commands from the Android device.</p><p>On the Android side, we will basically measure data coming from the phone's gyroscope sensor continuously and convert this data into meaningful commands for the servo. The goal is that the servo motor continuously follows the movement of the Android device.</p><p>In this chapter, you will learn how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connect a servo motor to the Arduino platform</li><li class="listitem" style="list-style-type: disc">Write a sketch to receive commands via BLE</li><li class="listitem" style="list-style-type: disc">Write an Android application to control the servomotor using the Android phone gyroscope</li></ul></div><div class="section" title="Hardware and software requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Hardware and software requirements</h1></div></div></div><p>The <a id="id311" class="indexterm"/>first thing you will need for this project is an Arduino Uno board.</p><p>Then you will <a id="id312" class="indexterm"/>need a BLE module. We chose the Adafruit nRF8001 chip because it comes with a nice Arduino library, and it has already existing examples of Android apps to control the module.</p><p>For the servomotor, we chose a simple 5V servo motor module. You can use one from any brand you want, as long as it can be controlled with 5V voltage levels. The following is an image of the servo that was used for this project:</p><div class="mediaobject"><img src="graphics/0389OS_06_01.jpg" alt="Hardware and software requirements"/></div><p>Finally, you <a id="id313" class="indexterm"/>will need a breadboard and some<a id="id314" class="indexterm"/> jumper wires to make the different connections.</p><p>This is the list of <a id="id315" class="indexterm"/>the required components for the project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Arduino Uno (<a class="ulink" href="https://www.adafruit.com/product/50">https://www.adafruit.com/product/50</a>)</li><li class="listitem" style="list-style-type: disc">The <a id="id316" class="indexterm"/>Adafruit nRF8001 BLE breakout board (<a class="ulink" href="https://www.adafruit.com/product/1697">https://www.adafruit.com/product/1697</a>)</li><li class="listitem" style="list-style-type: disc">A <a id="id317" class="indexterm"/>5V servo motor (<a class="ulink" href="https://www.adafruit.com/product/1143">https://www.adafruit.com/product/1143</a>)</li><li class="listitem" style="list-style-type: disc">The<a id="id318" class="indexterm"/> breadboard (<a class="ulink" href="https://www.adafruit.com/products/64">https://www.adafruit.com/products/64</a>)</li><li class="listitem" style="list-style-type: disc">Jumper wires (<a class="ulink" href="https://www.adafruit.com/products/1957">https://www.adafruit.com/products/1957</a>)</li></ul></div><p>On the software<a id="id319" class="indexterm"/> side, you<a id="id320" class="indexterm"/> will need the usual Arduino IDE. It is recommended that you use the Arduino IDE Version 1.5.7 for this chapter.</p><p>You will need the following libraries:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The library<a id="id321" class="indexterm"/> for the nRF8001 board found at <a class="ulink" href="https://github.com/adafruit/Adafruit_nRF8001">https://github.com/adafruit/Adafruit_nRF8001</a></li><li class="listitem" style="list-style-type: disc">The <a id="id322" class="indexterm"/>aREST library found at <a class="ulink" href="https://github.com/marcoschwartz/aREST">https://github.com/marcoschwartz/aREST</a></li></ul></div><p>To install a <a id="id323" class="indexterm"/>given library, simply extract the <code class="literal">library</code> folder into your <code class="literal">Arduino/libra</code>
<code class="literal">ries</code> folder.</p><div class="section" title="Configuring the hardware"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Configuring the hardware</h2></div></div></div><p>Let's now<a id="id324" class="indexterm"/> make the necessary <a id="id325" class="indexterm"/>hardware connections for the project. To help you out, this is the schematic of the project:</p><div class="mediaobject"><img src="graphics/0389OS_06_02.jpg" alt="Configuring the hardware"/></div><p>The first step is <a id="id326" class="indexterm"/>to place the Bluetooth module on the breadboard. Then, connect the power supply <a id="id327" class="indexterm"/>from the Arduino board to the breadboard: 5V of the Arduino board goes to the red power rail, and <span class="strong"><strong>GND</strong></span> goes to the blue power rail.</p><p>We will connect the BLE module. First, connect the power supply of the module: GND goes to the blue power rail, and <span class="strong"><strong>VIN</strong></span> goes to the red power rail. After this, you will need to connect the different wires responsible for the SPI interface: <span class="strong"><strong>SCK</strong></span> to Arduino pin <span class="strong"><strong>13</strong></span>, <span class="strong"><strong>MISO</strong></span> to Arduino pin <span class="strong"><strong>12</strong></span>, and <span class="strong"><strong>MOSI</strong></span> to Arduino pin <span class="strong"><strong>11</strong></span>. Then connect the <span class="strong"><strong>REQ</strong></span> pin to Arduino pin <span class="strong"><strong>10</strong></span>. Finally, connect the <span class="strong"><strong>RDY</strong></span> pin to Arduino pin <span class="strong"><strong>2</strong></span>, and the <span class="strong"><strong>RST</strong></span> pin to Arduino pin <span class="strong"><strong>9</strong></span>. If you need additional help to<a id="id328" class="indexterm"/> connect this module, you can visit the manufacturer's guide at <a class="ulink" href="https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout">https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout</a>.</p><p>For the servo motor, connect the red cable of the servo to the red power rail and the black cable of the<a id="id329" class="indexterm"/> servo to the blue power rail. Finally, connect the remaining cable to pin number 7 of the Arduino board.</p><p>The following is a<a id="id330" class="indexterm"/> picture of the assembled project:</p><div class="mediaobject"><img src="graphics/0389OS_06_03.jpg" alt="Configuring the hardware"/></div></div><div class="section" title="Testing the servo"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Testing the servo</h2></div></div></div><p>We will <a id="id331" class="indexterm"/>now write a very simple sketch to<a id="id332" class="indexterm"/> test the servomotor and also see how the Arduino Servo library is working. The following is the complete sketch for this part:</p><div class="informalexample"><pre class="programlisting">#include &lt;Servo.h&gt;
 
// Create servo object
Servo myservo;

// Servo position
int pos = 0;   

void setup()
{
  // Attaches the servo on pin 7 to the servo object
  myservo.attach(7);  
}

void loop()
{
  // Goes from 0 degrees to 180 degrees
  for(pos = 0; pos &lt; 180; pos += 1)
  {                                  
    myservo.write(pos);              
    delay(15);                       
  }
  
  // Goes from 180 degrees to 0 degrees
  for(pos = 180; pos &gt;= 1; pos -= 1)     
  {                                
    myservo.write(pos);              
    delay(15);                  
  }
}</pre></div><p>Let's now see the details of the sketch. This starts by including the Servo library as follows:</p><div class="informalexample"><pre class="programlisting">#include &lt;Servo.h&gt;</pre></div><p>Then we create an instance of the Servo library:</p><div class="informalexample"><pre class="programlisting">Servo myservo;</pre></div><p>We will also declare a variable called <code class="literal">pos</code> that will contain the angular position of the servo motor:</p><div class="informalexample"><pre class="programlisting">int pos = 0;   </pre></div><p>After this, in the <code class="literal">setup()</code> function of the sketch, we will attach the servo to pin 7 of the Arduino board:</p><div class="informalexample"><pre class="programlisting">myservo.attach(7);   </pre></div><p>After this, we<a id="id333" class="indexterm"/> will sweep the <code class="literal">pos</code> variable from <code class="literal">0</code> to <code class="literal">180</code>, meaning we cover all the possible angular positions of the servo motor:</p><div class="informalexample"><pre class="programlisting">for(pos = 0; pos &lt; 180; pos += 1)
{                                  
  myservo.write(pos);              
  delay(15);                       
}</pre></div><p>Still in <a id="id334" class="indexterm"/>this test code, we will make the servo motor go in the other direction with a similar loop.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Note that all the code <a id="id335" class="indexterm"/>for this chapter can be found in the GitHub repository of the book at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>.</p></div></div><p>It's now time to test this Arduino sketch. Simply upload the code to the Arduino board. You should see that the servo motor is going all the way in one direction, and then going back to its starting position. After this, this loop should repeat itself. If this is working, you can move on to the next section.</p></div></div></div>
<div class="section" title="Writing the Arduino sketch"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Writing the Arduino sketch</h1></div></div></div><p>We will <a id="id336" class="indexterm"/>now <a id="id337" class="indexterm"/>write the sketch to control the servo motor via BLE. This is the complete sketch for this part:</p><div class="informalexample"><pre class="programlisting">#include &lt;SPI.h&gt;
#include "Adafruit_BLE_UART.h"
#include &lt;aREST.h&gt;
#include &lt;Servo.h&gt;

// Lightweight mode
#define LIGHTWEIGHT 1

// Pins
#define ADAFRUITBLE_REQ 10
#define ADAFRUITBLE_RDY 2     // This should be pin 2 or 3
#define ADAFRUITBLE_RST 9
 
// Create servo object
Servo myservo;

// Create aREST instance
aREST rest = aREST();

// Servo position
int pos = 0;   

// BLE instance
Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);

void setup()
{
   // Start Serial
  Serial.begin(115200);
  
  // Attaches the servo on pin 7 to the servo object
  myservo.attach(7);  
  
  // Start BLE
  BTLEserial.begin();
  
  // Give name and ID to device
  rest.set_id("001");
  rest.set_name("servo_control");
  
  // Expose function to API
  rest.function("servo",servoControl);
}
 
 
void loop()
{
  // Tell the nRF8001 to do whatever it should be working on.
  BTLEserial.pollACI();
  
  // Ask what is our current status
  aci_evt_opcode_t status = BTLEserial.getState();
  
  // Handle REST calls
  if (status == ACI_EVT_CONNECTED) {
    rest.handle(BTLEserial);
  }
}

// Control servo from REST API
int servoControl(String command) {
  
  // Get position from command
  int pos = command.toInt();
  Serial.println(pos);
                            
  myservo.write(pos);              
  
  return 1;
}</pre></div><p>Let's now see<a id="id338" class="indexterm"/> the details of this sketch. It starts by including the required libraries for the project:</p><div class="informalexample"><pre class="programlisting">#include &lt;SPI.h&gt;
#include "Adafruit_BLE_UART.h"
#include &lt;aREST.h&gt;
#include &lt;Servo.h&gt;</pre></div><p>We will also declare that <a id="id339" class="indexterm"/>we want to use the lightweight mode of the aREST library:</p><div class="informalexample"><pre class="programlisting">#define LIGHTWEIGHT 1</pre></div><p>After this, we will define which pin the Bluetooth module is connected to:</p><div class="informalexample"><pre class="programlisting">#define ADAFRUITBLE_REQ 10
#define ADAFRUITBLE_RDY 2     // This should be an interrupt pin, on Uno thats #2 or #3
#define ADAFRUITBLE_RST 9</pre></div><p>We will also create an instance of the Servo library:</p><div class="informalexample"><pre class="programlisting">Servo myservo;</pre></div><p>We will also need to create an instance of the aREST library:</p><div class="informalexample"><pre class="programlisting">aREST rest = aREST();</pre></div><p>We will also need to create an instance of the nRF8001 library:</p><div class="informalexample"><pre class="programlisting">Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);</pre></div><p>In the <code class="literal">setup()</code> function of the sketch, we will attach the servo motor to pin number 7 of the Arduino board:</p><div class="informalexample"><pre class="programlisting">myservo.attach(7);  </pre></div><p>We will also initialize the BLE board:</p><div class="informalexample"><pre class="programlisting">BTLEserial.begin();</pre></div><p>After this, we will give a name and an ID to the board:</p><div class="informalexample"><pre class="programlisting">rest.set_id("001");
rest.set_name("servo_control");</pre></div><p>We will also<a id="id340" class="indexterm"/> expose the <code class="literal">servoControl</code> function to the aREST API so that <a id="id341" class="indexterm"/>we can access it via Bluetooth. We will see the details of the <code class="literal">servoControl</code> function in a moment:</p><div class="informalexample"><pre class="programlisting">rest.function("servo",servoControl);</pre></div><p>In the <code class="literal">loop()</code> function of the sketch, we will poll the Bluetooth chip to see if a device is connected to it:</p><div class="informalexample"><pre class="programlisting">BTLEserial.pollACI();</pre></div><p>We will store the state of the chip into a <code class="literal">status</code> variable:</p><div class="informalexample"><pre class="programlisting">aci_evt_opcode_t status = BTLEserial.getState();</pre></div><p>Then, if the status shows that some device is connect to the Bluetooth chip, we will handle any incoming requests:</p><div class="informalexample"><pre class="programlisting">if (status == ACI_EVT_CONNECTED) {
  rest.handle(BTLEserial);
}</pre></div><p>Let's now see the details of the <code class="literal">servoControl</code> function that we will use to control the servo motor remotely. It simply takes a string as an input, containing the position that we want to apply on the servo motor:</p><div class="informalexample"><pre class="programlisting">int servoControl(String command) {
  
  // Get position from command
  int pos = command.toInt();
  Serial.println(pos);
                            
  myservo.write(pos);              
  
  return 1;
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Note that <a id="id342" class="indexterm"/>all the code for this chapter can be found inside the GitHub repository of the book at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>.</p></div></div><p>You can <a id="id343" class="indexterm"/>now upload <a id="id344" class="indexterm"/>the code to the Arduino board and move to the next section.</p><div class="section" title="Setting up the Android app project"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Setting up the Android app project</h2></div></div></div><p>In this project, we<a id="id345" class="indexterm"/> will design a very simple Android app that will show the Bluetooth callback in a single-line text view and the sensor output in another text view. This time around, we will also implement a <span class="strong"><strong>Refresh</strong></span> button, which will restart the Bluetooth callback if there is a need for a refresh.</p><p>The part of the project that will be more sophisticated is accessing the hardware sensors available for us in order to send commands to the Servo and rotate the shaft according to the x-axis orientation of our Android device, determined by the gyroscope hardware, which is included in the device.</p><p>It is important to note that sensor readings and data could vary between different Android devices due to different hardware setups. Then again, you could use this project as a baseline to further your ventures.</p><p>We will assume that you have switched on the <code class="literal">Auto-Import</code> function within your <span class="strong"><strong>Preferences</strong></span> option. If not, kindly activate it by going to the <span class="strong"><strong>Auto-Import</strong></span> preferences and selecting all the available options. The <span class="strong"><strong>Auto-Import</strong></span> preferences are available on Mac and Windows as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On a Mac, Navigate to <span class="strong"><strong>Android Studio</strong></span> | <span class="strong"><strong>Preferences</strong></span> | <span class="strong"><strong>Editor</strong></span> | <span class="strong"><strong>Auto-Import</strong></span>.</li><li class="listitem" style="list-style-type: disc">On Windows, Navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Settings</strong></span>| <span class="strong"><strong>Editor</strong></span>| <span class="strong"><strong>Auto-Import</strong></span>.</li></ul></div><p>With all the necessary settings in place, we will first start off by creating a new project where we will choose the following within the <span class="strong"><strong>New Project</strong></span> setup:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Name</strong></span>: Android Gyroscope Servo Control</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Minimum SDK</strong></span>: <code class="literal">18</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Project</strong></span>: <code class="literal">Blank Activity</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Activity Name</strong></span>: <code class="literal">MainScreen</code></li></ul></div><p>In order to make this project work, we will need to first go over to the Android <code class="literal">Manifest</code> file, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">AndroidManifest.xml</code>.</p></div><div class="section" title="Laying out the Android user interface and permissions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Laying out the Android user interface and permissions</h2></div></div></div><p>Once we open <a id="id346" class="indexterm"/>the file, we<a id="id347" class="indexterm"/> will need to add permissions for access to Bluetooth and access to the gyroscope sensor hardware. The final Android <code class="literal">Manifest.xml</code> file will look as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.arduinoandroid.androidarduinosensserv" &gt;
    
    &lt;uses-permission android:name="android.hardware.sensor.gyroscope"/&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH"/&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;

    &lt;application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" &gt;
        &lt;activity
            android:name=".MainScreen"
            android:label="@string/app_name" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.intent.action.MAIN" /&gt;

                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;</pre></div><p>In this particular <a id="id348" class="indexterm"/>project, we will not put an emphasis on getting the user interface to be highly polished but instead, we will focus more on getting the orientation sensors to function appropriately with the servo motor.</p><p>In our project, we<a id="id349" class="indexterm"/> will navigate to the main layout file, which can be accessed by navigating to <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">res</code> &gt; <code class="literal">layout</code> &gt; <code class="literal">activity_main_screen.xml</code>.</p><p>The following code will implement a linear layout that has two <code class="literal">TextView</code> modules and a button. Go ahead and replace the current <a id="id350" class="indexterm"/>code in your <a id="id351" class="indexterm"/>project with the following:</p><div class="informalexample"><pre class="programlisting">&lt;LinearLayout 
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical"
    android:weightSum="1"&gt;

    &lt;TextView
        android:id="@+id/btView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:layout_marginTop="80dp"
        android:text="bluetooth text"
        android:textAppearance="?android:attr/textAppearanceSmall" /&gt;

    &lt;Button
        android:id="@+id/refreshButton"
        style="?android:attr/buttonStyleSmall"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:layout_marginTop="60dp"
        android:text="Refresh" /&gt;

    &lt;TextView
        android:id="@+id/tv"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|center_horizontal"
        android:layout_marginTop="250dp"
        android:text="Gyro output" /&gt;
&lt;/LinearLayout&gt;</pre></div></div><div class="section" title="Setting up the app's internals"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Setting up the app's internals</h2></div></div></div><p>We will then <a id="id352" class="indexterm"/>move on to the <code class="literal">MainScreen.java</code> file, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">java</code> &gt; <code class="literal">package name</code> &gt; <code class="literal">MainScreen.java</code>.</p><p>We will then replace the current code with the following code that we will walk through step-by-step and with <span class="strong"><strong>Auto-import</strong></span> enabled; Android Studio will automatically import all the statements that we need for our project.</p><p>We start off by declaring the class that extends <code class="literal">Activity</code> and, in addition, we will need to add the capability for the Java class to implement <code class="literal">SensorEventListener</code>, which encompasses the main methods that are needed for detection of <code class="literal">sensor activity</code>:</p><div class="informalexample"><pre class="programlisting">public class MainScreen extends Activity implements SensorEventListener {</pre></div><p>The following are all <a id="id353" class="indexterm"/>the variables that need to be declared in order to work with the BLE module, log tag for logging purposes, user interface elements, handler methods, and Bluetooth characteristics:</p><div class="informalexample"><pre class="programlisting">    // UUIDs for UAT service and associated characteristics.
    public static UUID UART_UUID = UUID.fromString("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");
    public static UUID TX_UUID = UUID.fromString("6E400002-B5A3-F393-E0A9-E50E24DCCA9E");
    public static UUID RX_UUID = UUID.fromString("6E400003-B5A3-F393-E0A9-E50E24DCCA9E");
// UUID for the BTLE client characteristic which is necessary for notifications.
    public static UUID CLIENT_UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");

    //Getting the name for Log Tags
    private final String LOG_TAG = MainScreen.class.getSimpleName();

    /**
     * Indicates which angle we are currently pointing the phone (and hence servo) in:
     * -2: 0-45 degrees
     * -1: 45-90 degrees
     * 0: 90 degrees
     * 1: 90-135 degrees
     * 2: 135-180 degrees
     * &lt;p/&gt;
     * Default is the neutral position, i.e. 0.
     */
    int currentPosition = 0;

    long lastSensorChangedEventTimestamp = 0;

    //Declaring UI Elements
    private TextView gyroTextView;
    private TextView bluetoothTv;

    //Declaring SensorManager variables
    private SensorManager sensorManager;

    //Sensor Delay Methods
    int PERIOD = 1000000000; // read sensor data each second
    Handler handler;
    boolean canTransmitSensorData = false;
    boolean isHandlerLive = false;

    private boolean areServicesAccessible = false;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The custom UART service for the Adafruit Bluetooth module uses the following UUIDs, which are the values you need to know to make our Android application talk to the appropriate<a id="id354" class="indexterm"/> characteristic. There is one characteristic for TX and another for RX, similar<a id="id355" class="indexterm"/> to the way<a id="id356" class="indexterm"/> that UART uses two lines to send and receive data as follows:</p><p>
<span class="strong"><strong>UART service UUID</strong></span>: 6E400001-B5A3-F393-E0A9-E50E24DCCA9E</p><p>
<span class="strong"><strong>TX characteristic UUID</strong></span>: 6E400002-B5A3-F393-E0A9-E50E24DCCA9E</p><p>
<span class="strong"><strong>RX characteristic UUID</strong></span>: 6E400003-B5A3-F393-E0A9-E50E24DCCA9E</p></div></div><p>The<a id="id357" class="indexterm"/> Bluetooth logic that plays an important role in our project to deal with all the callbacks is available in its entirety in our GitHub repository. The main Java activity with all the Bluetooth logic is available at <a class="ulink" href="http://git.io/XSHnow">http://git.io/XSHnow</a>.</p><p>In the <a id="id358" class="indexterm"/>following section of code, we will be declaring what will happen when the activity will be created and setting all the necessary functions to make the application logic connect to the layout files. </p><p>In the <code class="literal">onCreate()</code> method, we will also be initializing the <code class="literal">SensorManager</code> class, which will be needed to get access to the system's service.</p><div class="informalexample"><pre class="programlisting">    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main_screen);

        handler = new Handler();

        // Setup the refresh button
        final Button refreshButton = (Button) findViewById(R.id.refreshButton);
        refreshButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                restartScan();
            }
        });

        //get the TextView from the layout file
        gyroTextView = (TextView) findViewById(R.id.tv);
        bluetoothTv = (TextView) findViewById(R.id.btView);

        //get a hook to the sensor service
        sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
    }</pre></div><p>In the <code class="literal">onStart()</code> method, we will use the <code class="literal">SensorManager</code> class to register the type of sensor that we will be<a id="id359" class="indexterm"/> using. In this case, we will be using the orientation sensors and setting <code class="literal">SENSOR_DELAY_NORMAL</code>, which we will need to modify later on so as to ensure that there is enough delay between each call. In the <code class="literal">onStart()</code> method, we will also be initializing the Bluetooth adapter to start listening for devices:</p><div class="informalexample"><pre class="programlisting">    @Override
    protected void onStart() {
        super.onResume();

        /*register the sensor listener to listen to the gyroscope sensor, use the
        callbacks defined in this class, and gather the sensor information as quick
        as possible*/
        sensorManager.registerListener(this,
                sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION),
                SensorManager.SENSOR_DELAY_NORMAL
        );

        //handler.post(processSensors);

        // Scan for all BTLE devices.
        // The first one with the UART service will be chosen--see the code in the scanCallback.

        bluetoothAdaper = BluetoothAdapter.getDefaultAdapter();

        startScan();
    }</pre></div><p>It's always important to unregister the sensor listener and disconnect the BLE connection when the app is closed so as to prevent the battery drain and device memory resources:</p><div class="informalexample"><pre class="programlisting">    //When this Activity isn't visible anymore
    @Override
    protected void onStop() {
        //unregister the sensor listener
        sensorManager.unregisterListener(this);
        //disconnect and close Bluetooth Connection for better reliability
        if (gatt != null) {
            gatt.disconnect();
            gatt.close();
            gatt = null;
            tx = null;
            rx = null;
        }

        super.onStop();
        areServicesAccessible = false;
    }</pre></div><p>The following code will deal with all the <code class="literal">Sensor</code> methods that need to be implemented<a id="id360" class="indexterm"/> in order to ensure there is enough delay between each sensor reading and to send the necessary commands to the Bluetooth-enabled Arduino for the servo motor to rotate the shaft according to the <span class="emphasis"><em>x</em></span>-axis of the device:</p><div class="informalexample"><pre class="programlisting">    //SENSOR METHODS

    private final Runnable processSensors = new Runnable() {
        @Override
        public void run() {
            // Do work with the sensor values.
            canTransmitSensorData = !canTransmitSensorData;
            // The Runnable is posted to run again here:
            handler.postDelayed(this, PERIOD);
        }
    };

    @Override
    public void onAccuracyChanged(Sensor arg0, int arg1) {
        //Do nothing.
    }

    @Override
    public void onSensorChanged(SensorEvent event) {

        if ((event.accuracy != SensorManager.SENSOR_STATUS_UNRELIABLE)
                &amp;&amp; (event.timestamp - lastSensorChangedEventTimestamp &gt; PERIOD)) {

            System.out.println(event.timestamp - lastSensorChangedEventTimestamp);
            lastSensorChangedEventTimestamp = event.timestamp;

            // Truncate to an integer, since precision loss is really not a serious
            // matter here, and it will make it much easier (and cheaper) to compare.
            // We will also log the integer values of [2]
            int xTilt = (int) event.values[2];
            int yTilt = (int) event.values[1];
            int zTilt = (int) event.values[0];

            gyroTextView.setText("Orientation X (Roll) :" + xTilt + "\n" +
                    "Orientation Y (Pitch) :" + yTilt + "\n" +
                    "Orientation Z (Yaw) :" + zTilt);

            //Log.i(LOG_TAG, "The XTilt is:" + String.valueOf(xTilt));

            if (areServicesAccessible) {
                turnServoFinegrained(xTilt);
            }
        }
    }

  
    private void turnServoFinegrained(int xTilt) {

        // Default to vertical position
        int rotationAngle = 90;

        // Turn left
        if (xTilt &gt; 0) {
            rotationAngle = 90 - xTilt;
        }

        // Turn right
        else {
            rotationAngle = 90 + Math.abs(xTilt);
        }

        String setServoMessage = "/servo?params=" + rotationAngle + " /";
        tx.setValue(setServoMessage.getBytes(Charset.forName("UTF-8")));
        if (gatt.writeCharacteristic(tx)) {
            writeSensorData("Sent: " + setServoMessage);
        } else {
            writeSensorData("Couldn't write TX characteristic!");
        }
    }</pre></div><p>The following<a id="id361" class="indexterm"/> code will ensure that the commands that are sent to the BLE module are shown in the Bluetooth text output on our user interface layout:</p><div class="informalexample"><pre class="programlisting">    private void writeSensorData(final CharSequence text) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Log.e(LOG_TAG, text.toString());
                //bluetoothTv = (TextView) findViewById(R.id.btView);
                output = text.toString();
                bluetoothTv.setText(output);
            }
        });
    }
}</pre></div><p>Once you've written all the<a id="id362" class="indexterm"/> code, which you can easily follow along on our GitHub repository, available at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints/tree/master/chapter6">https://github.com/marcoschwartz/arduino-android-blueprints/tree/master/chapter6</a>, make sure that you have a physical device that is running Android 4.3 or higher and Bluetooth switched on. Once you build the project, you should see something similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/0389OS_06_04.jpg" alt="Setting up the app's internals"/></div></div><div class="section" title="How to go further"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>How to go further</h2></div></div></div><p>Orientation <a id="id363" class="indexterm"/>readings from the Android app can be further visualized in the app with real-time graphs, and this project could be further advanced and integrated into a remote object control app where the Android smartphone's user can control an object that is connected to the servo motor from a specific distance.</p><p>Simple yet useful application of such an action would be to open a gate or control a mobile robot via a gyroscope. Android smartphones also have a number <a id="id364" class="indexterm"/>of other sensors available for us, such as the accelerometer and magnetometer, which could effectively be used to control different components connected to the Arduino microcontroller.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Summary</h1></div></div></div><p>Throughout this chapter, we learned how to take advantage of one of the most important sensors on the Android phone, the gyroscope sensor, to be able to control the Arduino-controlled servo motor. We achieve this communication and action via the BLE capabilities of the Arduino equipped with the Adafruit BLE module and the possibilities of the Android operating system running 4.3 or higher.</p><p>This chapter also provides the foundation steps to the following chapter, which will access one of the Android device's most important hardwares.</p></div></body></html>