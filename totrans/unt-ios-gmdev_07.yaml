- en: 'Chapter 7. Input: Let''s Get Moving!'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point we've done some basic moving around a scene, but nothing like
    we'll need if we're going to build commercial games for iOS devices. One thing
    that is often overlooked when writing games for iOS is that while iPads, iPhones,
    etc. can perform many of the same functions as their desktop cousins — there are
    very specific techniques you need to be aware of when moving from the keyboard
    mouse world to that of touchscreens and accelerometers. In this chapter we're
    going to spend some time getting into the nitty gritty of what those details are.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the iOS touch screen interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about accelerometers and how they work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an interface on the touch screen for moving through an environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to process gestures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may not sound like a lot, but with iOS development there are many things
    that you can do incorrectly, which will lead to difficulties when working with
    Unity. Rather than assume that you'll get it all right we're going to talk through
    it step by step to make sure that you can spend your time building games and not
    trying to decipher mysterious error messages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: So let's get on with it…
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Input Capabilities
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iPhone is a collection of a wide variety of technologies that can be used
    to detect input from the user. The two most important technologies, from the perspective
    of a game developer, are the touch screen and the accelerometer. With these two
    input mechanisms nearly every game available to date has been constructed, so
    we will perform an in-depth analysis of how they work and how we can use their
    capabilities to determine the intent of the user within our game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The technology of touch
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A touch screen is a display device that can detect the presence and location
    of one or more touches within the display area. While early touch devices relied
    on passive instruments, such as a stylus to detect interactions with the touch
    surface, modern touch devices detect physical contact with the device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: While it may not seem the case, there are a variety of technologies used to
    drive touch interaction with devices. The decision on which technology is chosen
    depends upon a multitude of factors such as cost, durability, scalability, and
    versatility. It is very easy for one to suggest that one touch technology is superior
    to others, but a technology that works well for one particular application may
    be entirely inappropriate for another. For example, the technology used in the
    iPhone requires a person to make physical contact with the surface for a touch
    to be registered. However, if you're building a kiosk, you may desire that users
    are able to interact with the device with gloved hands. This seemingly innocent
    choice has radical implications on the technology chosen as well as the design
    of the device itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several common types of touch surfaces that are common in devices
    today: resistive, capacitive, and infrared. While the mechanics of their implementations
    vary, they all follow the same basic recipe — when you place your finger or stylus
    on the screen, there is some change in state on the surface that is then sent
    to a processor, which determines where that touch took place. It is how that change
    in state is measured which separates the technologies from one another.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 目前设备中常见的几种触摸表面类型包括：电阻式、电容式和红外式。虽然它们的实现机制各不相同，但它们都遵循相同的的基本步骤——当你将手指或笔尖放在屏幕上时，表面状态会发生某种变化，然后被发送到处理器，处理器确定触摸发生的位置。正是这种状态变化是如何被测量的，将技术区分开来。
- en: While all of today's iOS devices utilize a particular surface type — capacitive,
    it is foreseeable that Apple may change technologies at some point in the future
    as they expand the platform to cover new types of devices. In addition, it is
    important to understand the other types of surfaces that you may encounter as
    you port your content to other platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管今天所有的iOS设备都使用特定的表面类型——电容式，但可以预见，随着苹果将平台扩展到覆盖新类型的设备，他们可能在未来的某个时刻改变技术。此外，了解你可能在将内容移植到其他平台时遇到的其他类型的表面也很重要。
- en: Resistive technology
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电阻式技术
- en: A resistive screen is comprised of layers of conductive and resistive material.
    When pressure is placed on the screen, the pressure from the finger or stylus
    causes the resistive and conductive material to come into contact — resulting
    in a change in the electrical field. At this point, measuring the resistance on
    the circuits connected to the conductive material will denote the location of
    the touch.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻式屏幕由导电材料和电阻材料的多层组成。当施加压力到屏幕上时，手指或笔尖的压力会使导电材料和电阻材料接触——导致电场发生变化。此时，测量连接到导电材料的电路上的电阻将表示触摸的位置。
- en: Given that any pressure can cause the contact to occur, a resistive screen works
    well when you want to have a passive implement such as a stylus as a possible
    touch instrument. In addition, you can keep your gloves on with this technology,
    as a gloved hand will work just as well as a naked one. As resistive technology
    has been around for a lot longer it tends to be cheaper to produce and is the
    technology most commonly found at the lower end of the cost spectrum.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何压力都可能导致接触发生，电阻式屏幕在你想使用被动工具，如笔作为可能的触摸工具时工作得很好。此外，使用这项技术，你可以戴上手套，因为戴着手套的手和裸手一样可以工作。由于电阻式技术存在的时间较长，它往往生产成本较低，是成本谱系中常见于低端的技术。
- en: Capacitive technology
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电容式技术
- en: A capacitive screen uses a layer of capacitive material that holds an electrical
    charge. When touched, this material registers a difference in the amount of charge
    at a specific location on the surface at the point of contact. This information
    is then passed onto the processors which can determine precisely where the touch
    takes place. The iOS devices simplify this process by arranging the capacitors
    in a grid such that every point on the screen generates its own signal when touched.
    This has the added benefit of producing a very high resolution of touch data that
    can be processed by the processor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 电容式屏幕使用一层能够保持电荷的电容材料。当触摸时，这种材料会在接触点表面的特定位置记录电荷量的变化。然后，这些信息被传递到处理器，处理器可以精确地确定触摸发生的位置。iOS设备通过将电容器排列成网格来简化这一过程，使得屏幕上的每一个点在触摸时都会产生自己的信号。这带来了额外的优势，即产生非常高的分辨率触摸数据，可以被处理器处理。
- en: As the capacitive approach relies on having capacitive material in order to
    function, it requires that something that can conduct electricity performs the
    touching. Since the human body conducts electricity this works fine, but it rules
    out the stylus approach, or more specifically it requires that a special capacitive
    stylus be used.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电容式方法依赖于电容材料才能工作，它要求某种能够导电的物质进行触摸。由于人体导电，这可以很好地工作，但它排除了笔尖方法，或者更具体地说，它要求使用特殊的电容笔。
- en: Infrared technology
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 红外技术
- en: An infrared screen uses an array of infrared or LED light beams, which it projects
    beneath the protective glass, or more commonly, acrylic surface. A camera will
    then peer up at this grid of beams and look for any interruption of the signal,
    similar to the grid approach used by iOS devices — just with an infrared camera
    and beams of light. This approach is refined and deployed with the Microsoft Surface
    and has some particular unexpected benefits. Since a camera is used to determine
    the touch location, that camera can also look at the object at that location.
    If that object is a marker, it can then extract information from that marker as
    well. This is used to good effect with the Microsoft Surface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The obvious downside to the Infrared approach is that it requires a fair amount
    of space to work its magic. Due to the nature of the optics, the further you are
    away from the surface the more resolution you are able to gain on that surface.
    This makes the technology impractical for the typical iPhone application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Accelerometer
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An accelerometer is a device that measures the acceleration of motion on a
    structure. In iOS devices the accelerometer is a 3-axis system such that it can
    determine acceleration along the various axes of the device (x,y,z). When at rest,
    an accelerometer would be measuring the force of gravity (1g). As the device moves,
    the device will be able to measure the movements of the device based upon these
    accelerations along the various axes and determine the orientation of the new
    device. Without getting into the associated math, the only thing that you really
    need to know is that no matter what orientation you put the device in, the device
    is aware of that orientation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Gyroscope
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A gyroscope is a device for measuring the orientation of a device. Unlike an
    accelerometer, the orientation of a device can be derived without the device actually
    moving. Currently only available on a subset of the iOS devices, the gyroscope
    enables a much more refined detection of movement in the device. The 3-axis gyro
    in the iOS devices work in tandem with the built-in accelerometer to produce a
    complete 6-axis sensitivity for motion gestures. At the time of this writing there
    is no support within Unity for the Gyroscope so we will not focus on its use within
    the context of our game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Touch screen
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our game design calls for having a set of joysticks at the bottom on the screen
    that we can use to move around the world and manipulate the camera. The control
    scheme mirrors what a player would expect if they were familiar with an Xbox style
    controller.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Touch screen](img/978-1-84969-040-9_7_14.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: We also need to perform actions with the right button. Similar to the Xbox controller
    we want to be able to invoke actions by tapping down on the right joystick as
    an action.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The next feature we want to plan for is the ability to perform gestures on the
    surface so that we can avoid having to fill our interface with extraneous buttons.
    There are several gestures that we want to support in our gameplay.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '| Gesture | Meaning |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| Swipe Up | Throw Grenade |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| Swipe Left/Right | Dodge Left/Right |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| Swipe Down | Guard/Take Cover |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: Accelerometer/Gyroscope
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our game design doesn't call for the use of the accelerometer, but for the sake
    of instruction we will use the accelerometer as an additional mechanism for manipulating
    the camera and provide a shake command that we will use if the character is ever
    knocked down and needs to heal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '| Motion | Meaning |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| Shake | Heal |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| Turn Left/Right | Rotate Camera |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: Implementing Joysticks
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game design sketch calls for playing this game while the device is in landscape
    orientation so we need to start off the application in landscape.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Getting oriented
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From our previous applications we know that we can accomplish this by performing
    a quick orientation change within the `Awake()` method of our application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In previous examples we put our functions in the `Start()` method, but we are
    putting this call in the `Awake()` method. The reason for this is that we want
    this script, and the orientation settings, to be processed as soon as the scene
    is loaded, but before the joystick script tries to determine where to put the
    joysticks. If we didn't do this the position of the joysticks would be too close
    together as their positions would have been derived from the portrait orientation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: If you were to run your application now you would find that the application
    will hold to a single screen orientation, however, when you rotated you would
    get a black outline that rotates with the screen. This black outline represents
    the iOS keyboard interface rotating with the device. To prevent this from happening
    you need to lock the keyboard so that it is in the same orientation with the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '| Key Class/Methods | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| iPhoneSettings`.screenOrientation` | Gets/Sets the orientation of the device
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| `iPhoneScreenOrientation` | Enumerated type of the possible device orientations
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `iPhoneKeyboard.autorotateXXXX` | Sets whether or not the iPhoneKeyboard
    will rotate to a particular orientation when the device changes orientation |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What just happened?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have configured the game so that it will default to landscape orientation
    when it starts. In addition, the game will do what the users expect and you won't
    have the graphical glitch of the iOS keyboard trying to adjust for the device
    orientation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Next, our design calls for a touch interface with two joystick areas with the
    one on the left acting as the movement stick and the one on the right acting as
    the rotation joystick. We will use these to capture user interactions and drive
    our character around the game world.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Implementing the joysticks
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expand the Standard Assets (Mobile) unitypackage that we added to the project
    initially in one part of our solution. Inside of the `Prefabs` folder there is
    a `Dual Joysticks` prefab:![Time for action — Implementing the joysticks](img/978-1-84969-040-9_7_2.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is going to be moving with the user interface plane of our camera
    we can simply make it a child of the camera:![Time for action — Implementing the
    joysticks](img/978-1-84969-040-9_7_3.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Game** view to display in iPhone Wide by selecting the dropdown in
    the upper left of the Game view. This will result in a more accurate depiction
    of how the game will look at startup. Now, when we take a look at the Game view
    we can see exactly what our camera will see when our game starts:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Implementing the joysticks](img/978-1-84969-040-9_7_4.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: This figure represents what we expect to see — our two Joystick nubs in the
    user interface ready for user interaction. If you start your application on your
    iOS device you will see that as you place your fingers over the joystick nubs,
    they will move around as your fingers manipulate them during a touch. When you
    remove your finger from the nub it will snap back to the center position. This
    information is captured by the Prefab and passed off to the built-in Joystick
    script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To pass the input to some other script, simply alter the script that the Prefab
    is pointing to. Note that each Joystick can have its own script so you can have
    two entirely different behaviors per joystick.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also change the texture that the joystick uses by updating the **Texture**
    field on the **GUITexture** which represents the joystick:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Implementing the joysticks](img/978-1-84969-040-9_7_5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just implemented the primary means of input for our game — the dual
    joystick nubs. As we move these joysticks around they relay data to the Joystick
    script. While this is interesting, it still doesn't move our character around
    the scene. If all we needed were some basic joystick processing we'd be done,
    but we need to control a character and move our camera around the scene. Fortunately,
    there's a prefab for that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Moving around
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an interface which is ready to accept input we need to process
    the touches from that interface and move our character around the scene. Our plain
    joystick is one part of the plan, but now we need to handle the rest.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Implementing the camera control
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is delete our Main Camera and the Dual Joysticks
    from the previous scene. Don't be concerned that we've deleted the Main Camera
    as we will be adding a new camera to the scene.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a search for the **Camera Relative Controls** in the **Project** window:![Time
    for action — Implementing the camera control](img/978-1-84969-040-9_7_6.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Camera Relative Controls prefab into the **Hierarchy** view. When you
    drag this prefab into your **Hierarchy** view you will find that it consists of
    both the Dual Joysticks that we were using earlier, as well as something called
    **Camera Relative Controls**. Beneath the **Camera Relative Controls** you will
    find the camera pivot and the player objects.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **camera pivot** as the name suggests is the point in space around which
    the camera will pivot. When you move the right joystick to rotate the camera in
    3D space, its actions are relative to this point.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The other object is the Player which hosts our Character Controller object
    and has an aptly named child "ReplaceWithRealCharacter". When we have our real
    character we will insert it here:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Implementing the camera control](img/978-1-84969-040-9_7_37.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Switch to the **Game** view and we will see what this scene represents at runtime:![Time
    for action — Implementing the camera control](img/978-1-84969-040-9_7_7.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the joysticks are in place and the white capsule represents
    the Character Controller and Player Game Objects. If you deploy this project to
    your iOS device now you will see that you will be able to move around the scene
    with the Joysticks, the left moving you around the scene and the right one rotating
    the camera.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next let's import our player's character. Open the **Asset Store** and perform
    a search for the **Solder Character Pack:**![Time for action — Implementing the
    camera control](img/978-1-84969-040-9_7_10.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This pack contains a fully rigged character that we can use with our game.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After importing the character pack, drag the **Solider** prefab over to the
    **Camera Relative Controls**, Player node as a child. This will break the prefab
    link, but this is not a problem as we need to sever that link to add our own geometry
    to the game.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now delete the `ReplaceWithReachCharacter` child of the Player node and you
    will have a soldier in your game ready to be used. This soldier isn't the most
    efficient model we could use for our application, but it is freely available on
    the asset store and will work just fine for our purposes:![Time for action — Implementing
    the camera control](img/978-1-84969-040-9_7_9.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy this application to your iOS device and use the joysticks and you will
    find, that for your limited effort, you have a character in the world that will
    navigate the world with the left joystick and that you are able to manipulate
    the camera with the right joystick. We're starting to get something that looks
    more like a game, except that the player doesn't animate. We need a way to put
    some animations on this character and have the person walk around, move through
    the attack animations, take damage, and die if we're going to have a real game.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have extended the functionality of the existing application to include controls
    to move around our world, along with camera controls for our player character.
    Now that we have imported a character for our character controller, we need to
    animate this character based on user input.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Animating the player character
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The character that we imported is what is known as a rigged character. A rigged
    character is one that has all of its bones for animation. These bones are what
    drive the movement of the mesh itself during animation. Let's disable the rendering
    of the mesh so we can see the bones themselves..
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Select the Soldier mesh in the **Hierarchy** view.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** view, scroll down to the Mesh Render component and click
    its check box. This will disable rendering of the mesh in Unity and in the Game:![Time
    for action — Animating the player character](img/978-1-84969-040-9_7_36.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Scene** view of the project and select the mesh in the Hierarchy.
    You should only see the bones for the soldier character we imported:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Animating the player character](img/978-1-84969-040-9_7_16.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: As mentioned earlier, Unity's animation system is fairly robust and has an easily
    scriptable animation blending system built right into it. As a consequence, we
    can deal with simple animations such as walk, run, use weapon, and so on, and
    we can have Unity blend between the animations to allow us to walk while using
    the weapon.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Importing an animation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to associate an animation with this rigging so that we can
    ''drive'' our character around the scene. There are a number of ways that you
    can animate a character, such as motion capture or animating by hand. Unity supports
    two approaches for importing this content into our game: animation splitting and
    multiple animation files.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Animation splitting
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are times when you will receive an asset which already has multiple animations
    baked onto a model. In many content-purchasing scenarios this is quite a common
    practice. In these situations, when you import the model you will have to tell
    Unity how to split the single large animation into multiple distinct animations.
    You will do this in the **FBXImporter** that appears when you bring the model
    into the Unity IDE:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation splitting](img/978-1-84969-040-9_7_17.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: By selecting the option to **Split Animations**, Unity will enable a table that
    will allow you to specify each animation that is present. For example in this
    scenario there is an animation called **idle** which runs from frame **1** through
    frame **25**, a **walk** that plays from frame **26** through frame **50**, and
    so on. Once you have imported the animations you can reference them by the names
    that you have given them in the table for all animation actions. We will discuss
    this in more detail shortly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Multiple files
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preferred way to import animations is to use multiple animation files. To
    do this you create a separate model file for your animation data using the naming
    convention 'model'@'animation name'.fbx and simply drag this `.fbx` file into
    Unity, the same as you would any other asset.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Through this you can import your animations distinctly for each character and
    it becomes much easier in your workflow to modify these animations, without having
    to worry about which frames changed or ending up with extra frames in your animation
    data, to allow for potential changes. It is important to note that these files
    contain only animation data — not the actual model geometry. Further, it is important
    to note that Unity will not attempt to enforce the mapping of the model name to
    the name of your models:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple files](img/978-1-84969-040-9_7_21.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: For example, here we have imported some animations in an FBX file. There is
    no default model in our scene, but we can still use these animations since the
    bone hierarchy of these animations matches that of the character we already have
    in the game.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this animation within our game we need to select our character and in
    the **Inspector** expand the animation settings:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple files](img/978-1-84969-040-9_7_19.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'Here we see that our character has 0 animations specified. In addition in the
    **Animation** element we see that there is no animation scheduled to play. We
    can easily fix this by increasing the animation count to **3** to match the three
    animations we have imported:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple files](img/978-1-84969-040-9_7_20.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'These slots can all hold the animations that we have imported. The animation
    itself being represented by a document icon with a clock on it which, coincidentally,
    has the same name as the animation itself. Simply drag the animations onto these
    slots and you will have set up animations for the character:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple files](img/978-1-84969-040-9_7_23.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'If you want to set up a default animation for the character you can drag an
    animation onto the **Animation** slot. I have chosen to select the idle animation
    in this case:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple files](img/978-1-84969-040-9_7_24.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Now your character is all setup and ready to animate. If you run the game in
    the editor you will see that your character moves from his default T position
    to the idle animation and plays through it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple files](img/978-1-84969-040-9_7_25.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just took our rigged character from the asset store and added animations
    to it using the two approaches of animation splitting and unique FBX animation
    importing. Now our character can have emotion, driven by animation data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Importing an animation
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when you don't have animation data readily available, or
    you simply want to cut down your development time by integrating an existing animation.
    One service that is well integrated with Unity is the animation service from Mixamo.
    Mixamo provides this functionality, not only for their characters, but also for
    any rigged character that we can find.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Importing from Mixamo
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can get started by going to the [http://www.mixamo.com/](http://www.mixamo.com/)
    website (there is a plugin that is integrated into the latest versions of Unity
    as well) and browsing through their library of animations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Importing from Mixamo](img/978-1-84969-040-9_7_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'Since we want to ensure that the animation will work properly with our character
    we can upload our character to Mixamo and see the animation being played on our
    character:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Importing from Mixamo](img/978-1-84969-040-9_7_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'We have the opportunity to tweak any of the bones in our character to fit those
    that Mixamo has defined in their default skeleton. This will help ensure that
    our animation plays properly. In most cases Mixamo will map to the right bones
    by itself, but if you need to help it out because of some special mapping that
    you''ve done — all the tools are there:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Importing from Mixamo](img/978-1-84969-040-9_7_13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Once mapped, we can reference this uploaded character as we browse through the
    catalog of animations in the Mixamo library when we create our own custom animations
    using the service. Now that our model is here we can look at exactly how the animation
    will perform, as Mixamo has an integrated Unity player on the website where we
    can preview and customize the animation as necessary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We can adjust the sliders to customize our character motions in real time and
    get them precisely the way we want them. Once we've done that we can download
    our animation in the appropriate Unity animation format.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'If we already have an animation that we want to import into Unity, we can use
    this same approach to import those animations as well. Unity supports two approaches
    for importing this content into our game: animation splitting and multiple animation
    files.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just took our rigged character from the asset store and added animations
    to it using the Mixamo animation service. Using these animations we're able to
    have our character move around the scene in sync with animations. Now that we
    can move around let's deal with the other part of our input requirements — being
    able to attack enemies or perform other actions on command.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Driving our character
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing that we need to do with our character is drive him around the
    scene. This is the one area that will either make or break our game because it
    needs to be fluid with user interaction. This is important because the main character
    is likely to be one of the most used things in the game so it should be well made.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: As the character moves around, our character needs to move through the animation
    and change position in the scene as well. In addition, we need to seamlessly blend
    between different animations that the character is doing. We can't have the player
    stop walking, then swing, then start walking again.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Driving our character
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you deployed the application after the last step you would have observed
    that our current controls could already move the character around the scene. We
    can use the left joystick and the player will glide over the ground while going
    through the idle animation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Driving our character](img/978-1-84969-040-9_7_26.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'We want our character to walk when the player is moving the joystick so we
    can make a very simple change to the `CameraRelativeControl` script for this to
    happen. You can locate this script by taking a look at the **Player** object in
    the **Hierarchy** view:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Driving our character](img/978-1-84969-040-9_7_27.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'Now look at the Inspector and you will see all of the scripts that are driving
    this object. Keep track of this, as we will change some of this later:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Driving our character](img/978-1-84969-040-9_7_28.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'First let''s add a variable to the script so we can gain access to our soldier
    GameObject. You will note here that I am defining the type in this script, as
    opposed to just declaring it as var. In Unity iOS you must define the types of
    all objects, dynamic typing is not allowed for performance reasons:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we need to just look for some change in velocity in our character, which
    is conveniently managed by the Character Controller, and change the animation
    accordingly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if you go back and run the application you will find that the player moves
    into a walk animation when we move the joystick around whenever the player reaches
    a certain speed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Driving our character](img/978-1-84969-040-9_7_29.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just added in functionality to drive our player around the world using
    the joystick numbs and the standard locomotion system employed by Unity. However,
    there are a number of limitations to our approach when we want to employ multiple
    animations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We could certainly put in some code to look for when the player is beyond a
    certain velocity and have them move into a run animation with some simple conditional
    logic changes, but if you play around with the application you will find something
    very wrong with this picture. The player animates from the local origin and then
    snaps back to the origin when they reach the end of the animation. In addition
    when physics is applied to this character there will be a disconnect between the
    animation and the character hierarchy.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: You could certainly fix some of this by having the animator perform the animations
    in place, but then you would lose the ability to really see how the animation
    will look. Seeing the gait, stride, and swing of the character is only really
    possible when the character is actually in motion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: To fix all of this, however, we need another solution. What we really need to
    do is track where the character is during their animation so that when they are
    at the end of the animation we can start playing the animation again at that position
    and orientation. This will become increasingly important as we try to have our
    player walk on steps, or collide with objects. In other words we need to drive
    the character's motion with the animation itself, and we can't do that by simply
    changing the character's location and telling them to play an animation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Getting a driver's license with Root Motion Controller
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, there is a prebuilt solution that, unsurprisingly, is available
    from Mixamo that will solve this problem for us with very little impact to our
    application code - the Root Motion Controller:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Getting a driver''s license with Root Motion Controller](img/978-1-84969-040-9_7_32.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: First, go back to the **Asset Store** and search for a package known as the
    **Root Motion Controller**. This package from Mixamo, and developed by Adam Mechtley,
    has all of the functionality necessary for us to drive our character using the
    animation data — we need only configure it:![Time for action — Getting a driver's
    license with Root Motion Controller](img/978-1-84969-040-9_7_33.jpg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next we need to select the **Player** model from our hierarchy, since this
    is the component of the hierarchy that we want to control with our new controller.
    When adding this to a similar project, just be sure to add this to the same node
    that contains the Character Controller, as you want movements from the Root Motion
    Computer to result in motion on everything at this level of the Hierarchy:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you were to attach the **Root Motion Computer** to the Soldier node, for
    example, the **Camera Relative Controls** would not be aware that the player has
    actually moved.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Getting a driver''s license with Root Motion Controller](img/978-1-84969-040-9_7_30.jpg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now that we have the right node in the hierarchy selected we can add the **Root
    Motion Computer** component by selecting the **Mixamo** menu item:![Time for action
    — Getting a driver's license with Root Motion Controller](img/978-1-84969-040-9_7_31.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** view you will see the **Root Motion Computer** component
    added to our Game Object. And with that we're actually done with the vast majority
    of the work that needs to be done. So let's take it out for a test drive:![Time
    for action — Getting a driver's license with Root Motion Controller](img/978-1-84969-040-9_7_34.jpg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the settings of the animations for the character, so that the default
    animation is set to **walk:**![Time for action — Getting a driver's license with
    Root Motion Controller](img/978-1-84969-040-9_7_35.jpg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, set the **Animation Wrap Mode** for the animation to **Loop** so that
    it will play repeatedly. Now when you run the application the player will walk
    repeatedly forward until they walk off the world.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've just accomplished a significant step! Not only have we imported animations,
    but we are also using the animations to drive the character around the scene.
    With all of our animations synchronized with the location and orientation of the
    player in the scene and controlled with the joysticks we can turn our attention
    to the gameplay elements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Rotation via Accelerometer
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing we need to handle is rotating the camera based upon the user
    tilting the device. In our design we said that this would represent rotation of
    the camera so we need to detect these motions and adjust our camera based upon
    the user's intent.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Updating upon device tilt
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, iOS devices have a defined access that allows us to determine
    changes in the device''s orientation. We can detect this as changes in the x,
    y, or z values in Input.acceleration:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Updating upon device tilt](img/978-1-84969-040-9_7_38.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Since our game design requires us to manipulate the camera based upon the tilt,
    the only step we need is to check for the direction of the orientation change
    and then rotate the camera accordingly. To accomplish this we can attach a script
    to a GameObject in whose `Update()` method we examine the `Input.acceleration`
    attributes and determine how the device has changed. Remember also that we have
    specified that our application be designed to run in landscape mode so we are
    looking for rotations along the device's Z-axis.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '| Key Method | Description |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `Input.acceleration` | Returns the accelerometer readings of the device |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With `iPhoneSettings.screenOrientation` we can now tell the Unity player to
    change its orientation. You can set the orientation to any one of the `iPhoneScreenOrientations`
    available. It is recommended that you don't do anything that would be uncharacteristic
    to the way the iOS device is expected to operate as Apple may reject your application
    for that behavior.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By adding a script to our camera we get an `Update()` notification on a frame
    by frame basis. We can then look to see what the device orientation is and adjust
    our orientation accordingly. By updating the `iPhoneSettings` attributes we can
    quickly flip our scene to match whatever orientation we find ourselves in.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Shaking the device to perform a healing action
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we need to do is detect when the user has chosen to shake the
    device as our design specifies that we will use this as an indication that the
    user will perform a healing action.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Detecting a shake
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in handling an orientation change is to actually realize that
    the orientation has changed. There are two ways we can do this — we can either
    check when the game first starts up only, in which case we need to put our orientation
    detection in the `Start()` method as it is only called once. If we want to check
    orientation changes as the user is playing the game then we need to check the
    state of the orientation on a frame-by-frame basis. We do this by putting our
    orientation code in the `Update()` method.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Key Methods | Description |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `Input.acceleration` | Returns the accelerometer readings of the device |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: We will use the `deviceOrientation` attribute of the Input class to determine
    what the orientation of the device is. This information comes directly from the
    OS in real time so as the orientation changes, we will be notified and can respond
    to the change without having to interrupt gameplay.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Physician heal thyself
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know that a device shake has taken place we can perform the specific
    action that we want associated with the shake.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `player` class we have a simple representation of the player''s health
    as an integer within our `Player` class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our `Player` class is a simple heal method that we call whenever we detect
    that a shake of the device has happened.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have implemented the last input features for the game by detecting shakes
    of the device. Based upon this shake we have changed the user's state and taken
    an action. While shaking isn't a common action in games today, and I encourage
    you to use it sparingly, there are certainly times when it represents the best
    input option available.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we discussed the primary sensors used for input on iOS, namely
    the touch screen, gyroscope, and accelerometer. With this task covered we can
    provide a touch screen interface from our player which they can interact with,
    as well as gather information from movement and orientation of the iOS device.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The different types of touch technologies, their strengths and weaknesses
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a touchable user interface for the user on the device and gather
    input from it
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to import existing animations and how to import Mixamo animations
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to detect gestures and determine the user's intent
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to detect movement of the device and orientation changes
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use this information to move an on-screen character through a 3D world
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to drive a character from animation data as opposed to programmatically
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have a character that we can control through our 3D world and we can
    animate this character based on input from the user. We have the beginnings of
    an actual game now, but the world is very quiet and the game is without flair.
    In the next chapter, Multimedia, we will explore how to add sound, music, and
    video to our game to give it some sex appeal.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
