- en: '*Chapter 4*: Managing Dependencies in Android Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：在 Android 应用程序中管理依赖'
- en: In this chapter, we will analyze the concept of **dependency injection** (**DI**)
    and the benefits it provides and look at how this was done in the past in Android
    applications either through manual injection or using Dagger 2\. We will go over
    some of the libraries used in Android applications, stopping and looking in more
    detail at the Hilt library and how it simplifies DI for an Android application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析 **依赖注入**（**DI**）的概念及其提供的优势，并查看过去在 Android 应用程序中是如何通过手动注入或使用 Dagger
    2 来实现的。我们将回顾一些在 Android 应用程序中使用的库，并更详细地查看 Hilt 库以及它是如何简化 Android 应用的 DI 的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to DI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI 简介
- en: Using Dagger 2 to manage dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Dagger 2 管理依赖
- en: Using Hilt to manage dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hilt 管理依赖
- en: By the end of this chapter, you will be familiar with the DI pattern and libraries
    such as Dagger and Hilt, which can be used to manage dependencies in Android applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉 DI 模式以及 Dagger 和 Hilt 等库，这些库可以用于管理 Android 应用程序中的依赖项。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The hardware and software requirements are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件和软件要求如下：
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio Arctic Fox 2020.3.1 补丁 3
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter4](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter4).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter4](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter4)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/38yFDHz](https://bit.ly/38yFDHz)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/38yFDHz](https://bit.ly/38yFDHz)
- en: Introduction to DI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DI 简介
- en: In this section, we will look at what DI is, the benefits it provides, and how
    this concept is applied to an Android application. We will then look at some DI
    libraries and how they work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 DI 是什么，它提供的优势以及这个概念是如何应用于 Android 应用的。然后，我们将探讨一些 DI 库以及它们是如何工作的。
- en: 'When a class depends on functionality from another class, a dependency is created
    between the two classes. To invoke the functionality on the class you depend on,
    you will need to instantiate it, as in the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类依赖于另一个类的功能时，两个类之间就创建了一个依赖。要调用你依赖的类的功能，你需要实例化它，如下例所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, `ClassA` creates a new instance of `ClassB`, and then when
    `executeA` is invoked, it will invoke `executeB`. This poses a problem because
    `ClassA` will have the extra responsibility of creating `ClassB`. Let''s see what
    happens if `ClassB` needs to change to something such as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ClassA` 创建了一个新的 `ClassB` 实例，然后当调用 `executeA` 时，它将调用 `executeB`。这引发了一个问题，因为
    `ClassA` 将承担创建 `ClassB` 的额外责任。让我们看看如果 `ClassB` 需要变为以下内容时会发生什么：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we added the `myFlag` variable to `ClassB`, which is used in the `executeB`
    method. This change would cause a compile error because now `ClassA` will need
    to be modified to make the code compile.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向 `ClassB` 添加了 `myFlag` 变量，该变量在 `executeB` 方法中使用。这个更改将导致编译错误，因为现在 `ClassA`
    需要修改才能使代码编译。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we will need to supply a Boolean value when we create `ClassB`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要在创建 `ClassB` 时提供一个布尔值。
- en: 'Making these types of changes to an application as its code base increases
    will make it hard to maintain. A solution to this problem is to separate how we
    use dependencies and how we create them and delegate the creation to a different
    object. Continuing from the preceding example, we can rewrite `ClassA` as the
    following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的代码库增加时，对这些类型的变化进行修改将使维护变得困难。解决这个问题的一个方案是将我们使用依赖项的方式与我们创建依赖项的方式分开，并将创建委托给不同的对象。继续前面的例子，我们可以将
    `ClassA` 重写为以下内容：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we removed the instantiation of `ClassB` and moved the variable in the
    constructor of `ClassA`. Now, we can create a class that will be responsible for
    creating the instances of both classes that looks like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们移除了 `ClassB` 的实例化，并将变量移动到了 `ClassA` 的构造函数中。现在，我们可以创建一个负责创建两个类实例的类，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we have a new class that will create an instance of `ClassA` with `ClassB`
    as a parameter and a separate method for creating an instance of `ClassB`. Ideally,
    when the program is initialized, we would need to initialize all the dependencies
    and pass them appropriately:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个新的类，它将使用`ClassB`作为参数创建`ClassA`的实例，并且还有一个单独的方法用于创建`ClassB`的实例。理想情况下，当程序初始化时，我们需要初始化所有依赖项并适当地传递它们：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we created `Injector`, which is responsible for creating our instances,
    and then invoked the appropriate methods on `Injector` to retrieve the appropriate
    instances of each class. What we have done here is called DI. Instead of `ClassA`
    creating the instance of `ClassB`, it will have an instance of `ClassB` injected
    through the constructor, also known as *constructor injection*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了`Injector`，它负责创建我们的实例，然后调用`Injector`的适当方法来检索每个类的适当实例。我们在这里所做的是所谓的DI。不是`ClassA`创建`ClassB`的实例，而是它将通过构造函数注入一个`ClassB`的实例，这也被称为*构造函数注入*。
- en: 'In `ClassB`, we have an `if-else` statement in the `executeB` method. We can
    introduce an abstraction there, so we split the `if-else` statement into two separate
    implementations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ClassB`中，我们在`executeB`方法中有一个`if-else`语句。我们可以在那里引入一个抽象，因此我们将`if-else`语句拆分为两个单独的实现：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, `ClassA` remains the same and `ClassB` has become an interface with two
    implementations, called `ClassB1` and `ClassB2`, representing the implementations
    of the `if-else` branch. Here, we can use the `Injector` class as well to inject
    one of the two implementations without requiring any change on `ClassA`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ClassA`保持不变，而`ClassB`已成为一个接口，有两个实现，分别称为`ClassB1`和`ClassB2`，代表`if-else`分支的实现。在这里，我们也可以使用`Injector`类来注入这两个实现之一，而无需对`ClassA`进行任何更改：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `createB` method, we return an instance of `ClassB1`, which will then
    be later injected into `ClassA`. This represents another benefit of DI, where
    we can make our code depend on abstractions rather than concretions and provide
    different concretions for different purposes. Based on this, we can define the
    following roles when it comes to DI:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createB`方法中，我们返回一个`ClassB1`的实例，然后稍后将其注入到`ClassA`中。这代表了DI的另一个好处，我们可以使我们的代码依赖于抽象而不是具体实现，并为不同的目的提供不同的具体实现。基于此，我们可以定义以下角色，当涉及到DI时：
- en: '`ClassB1` and `ClassB2` in our example)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassB1`和`ClassB2`在我们的例子中）'
- en: '`ClassB` in our example)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassB`在我们的例子中）'
- en: '`ClassA` in our example)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassA`在我们的例子中）'
- en: '`Injector` in our example)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Injector`在我们的例子中）'
- en: '![Figure 4.1 – DI class diagram'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.1 – DI类图'
- en: '](img/Figure_4.01_B18320.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.01_B18320.jpg)'
- en: Figure 4.1 – DI class diagram
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.1 – DI类图
- en: The preceding figure shows the class diagram of our example and the DI pattern.
    We can observe how the `Injector` class is responsible for creating and injecting
    the dependencies, `ClassA` is the client receiving a dependency to `ClassB`, which
    is the interface, and `ClassB1` and `ClassB2` represent the services.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了我们的例子和DI模式的类图。我们可以观察到`Injector`类负责创建和注入依赖项，`ClassA`是接收依赖项的客户端，`ClassB`是接口，而`ClassB1`和`ClassB2`代表服务。
- en: 'There are multiple classifications of the types of DI, and they mainly revolve
    around two ways of injecting dependencies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: DI的类型有多种分类，它们主要围绕两种注入依赖项的方式：
- en: '**Constructor injection**: Where dependencies are passed through the constructor.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数注入**：依赖项通过构造函数传递。'
- en: '**Field injection**: Where dependencies are passed through setter methods or
    by changing the instance variables. This can also be referred to as **setter injection**
    and it can also be expanded to **interface injection** in which the setter method
    is abstracted to an interface.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段注入**：依赖项通过setter方法或更改实例变量传递。这也可以称为**setter注入**，并且还可以扩展到**接口注入**，其中setter方法被抽象为一个接口。'
- en: Another benefit of DI is the fact that it makes the code more testable. When
    dependencies are injected into an object, it makes the class easier to test, because
    in the test code, we can inject objects that allow us to mimic various behaviors,
    called **mocks**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: DI的另一个好处是它使代码更容易测试。当依赖项注入到对象中时，它使类更容易测试，因为在测试代码中，我们可以注入允许我们模拟各种行为的对象，称为**mocks**。
- en: In this section, we have introduced the DI pattern, how it works, and the problems
    it is solving. Developers can manage an application's dependencies and injection
    manually, by setting up injectors. But as an application grows, it becomes hard
    to maintain, especially when we want certain objects to live only as long as other
    objects and not as long as the application, or handle different instances of the
    same class. There are various DI frameworks and libraries that can manage all
    these cases and in Android, one of the most commonly used ones is Dagger 2.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了依赖注入（DI）模式，它的工作原理以及它解决的问题。开发者可以通过设置注入器手动管理应用程序的依赖和注入。但是，随着应用程序的增长，手动管理变得越来越困难，尤其是在我们希望某些对象只与其他对象一起存在，而不是与应用程序一样长，或者处理同一类的不同实例时。有各种
    DI 框架和库可以管理所有这些情况，在 Android 中，最常用的之一就是 Dagger 2。
- en: Using Dagger 2 to manage dependencies
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dagger 2 管理依赖项
- en: In this section, we will analyze the Dagger 2 library, how it handles DI, how
    it works, how it is integrated into an Android application, and what issues it
    might create.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析 Dagger 2 库，它如何处理 DI，它的工作原理，它如何集成到 Android 应用程序中，以及它可能引起的问题。
- en: The Dagger 2 library relies on code generation based on annotation processing,
    which will generate the boilerplate code that is required to perform DI. The library
    is written in Java, and it is used for various projects outside of Android applications.
    Because it is written in Java, it provides compatibility for apps written in Java,
    Kotlin, or both. The library is built using `@Inject`, `@Named`, `@Qualifier`,
    `@Scope`, and `@Singleton`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger 2 库依赖于基于注解处理的代码生成，这将生成执行 DI 所需的样板代码。该库是用 Java 编写的，并且用于 Android 应用程序之外的各个项目。因为它是用
    Java 编写的，所以它为用 Java、Kotlin 或两者编写的应用程序提供了兼容性。该库使用 `@Inject`、`@Named`、`@Qualifier`、`@Scope`
    和 `@Singleton` 构建）。
- en: 'When integrating Dagger 2, there are three main concepts that we will need
    to consider:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当集成 Dagger 2 时，有三个主要概念是我们需要考虑的：
- en: '`@Module` annotation for the classes and `@Provides` for the methods. To avoid
    many `@Module` definitions, we can use the `@Inject` annotation on a constructor,
    which will provide the object as a dependency.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于类的 `@Module` 注解和用于方法的 `@Provides` 注解。为了避免过多的 `@Module` 定义，我们可以在构造函数上使用 `@Inject`
    注解，这将提供对象作为依赖项。
- en: '`@Inject` annotation.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Inject` 注解。'
- en: '`@Component` annotation.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component` 注解。'
- en: 'In order to add Dagger 2 to an Android application, you will first need to
    add the Kotlin annotation processor plugin to the `build.gradle` file of the module
    in which Dagger 2 is used:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Dagger 2 添加到 Android 应用程序中，你首先需要将 Kotlin 注解处理器插件添加到使用 Dagger 2 的模块的 `build.gradle`
    文件中：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we added the `kotlin-kapt` plugin to allow Dagger 2 to generate the code
    necessary for DI. Next, we will need the Dagger 2 dependencies:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了 `kotlin-kapt` 插件以允许 Dagger 2 生成 DI 所需的代码。接下来，我们需要 Dagger 2 依赖项：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are adding a dependency to the Dagger 2 library and a dependency to
    the annotation processing library, which has the role of code generation. The
    library version should ideally be the latest stable one available in the library
    repository.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向 Dagger 2 库添加了一个依赖，以及一个用于代码生成的注解处理库的依赖。库的版本应该是库仓库中可用的最新稳定版本。
- en: 'Let''s now re-introduce the example from the previous section:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新介绍上一节中的示例：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we have the same classes with the same dependencies. Instead of defining
    an `Injector` class, we can use Dagger 2 to define an `@Module`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有相同的类和相同的依赖项。我们不需要定义 `Injector` 类，而是可以使用 Dagger 2 来定义 `@Module`：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we annotated the class with `@Module` and for each instance, we used
    the `@Provides` annotation. We can further simplify this with the `@Inject` annotation
    and delete the `@Provides` methods from `ApplicationModule`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `@Module` 注解了类，并为每个实例使用了 `@Provides` 注解。我们可以进一步使用 `@Inject` 注解来简化这一点，并从
    `ApplicationModule` 中删除 `@Provides` 方法：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we have added `@Inject` for each constructor. In the
    case of `ClassA`, it will have both the role of injecting `ClassB` and providing
    `ClassA` to other objects as a dependency. There is, however, an issue because
    `ClassA` has a dependency on the abstraction rather than the concretion, so Dagger
    will not know which instance to provide to `ClassA`. We can now add an `@Binds`
    annotated method to `ApplicationModule`, which will connect the abstraction with
    the implementation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经为每个构造函数添加了`@Inject`。对于`ClassA`来说，它将同时扮演向`ClassB`注入的角色，并将`ClassA`作为依赖提供给其他对象。然而，存在一个问题，因为`ClassA`依赖于抽象而不是具体实现，所以Dagger将不知道应该为`ClassA`提供哪个实例。现在，我们可以在`ApplicationModule`中添加一个被`@Binds`注解的方法，将抽象与实现连接起来：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we added the `bindClassB` abstract method, which is annotated with `@Binds`.
    This method will tell Dagger 2 to connect the `ClassB1` implementation with the
    `ClassB` abstraction. To avoid large `@Provides` annotations, we should try to
    use the annotation for dependencies where we cannot modify the code and instead
    rely on `@Inject` on the constructors and using `@Binds` where possible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`bindClassB`抽象方法，该方法被`@Binds`注解。这个方法将告诉Dagger 2将`ClassB1`实现与`ClassB`抽象连接起来。为了避免大的`@Provides`注解，我们应该尝试在无法修改代码的地方使用注解，而在可能的情况下使用`@Inject`在构造函数上，并使用`@Binds`。
- en: 'Now, we will need to create the connector:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建连接器：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we are defining an `@Component` in which we specify the module the application
    will use. The `@Singleton` annotation tells Dagger that all the dependencies in
    this component will live as long as the application. At this point, we should
    trigger a build on the application. This will trigger the compilation, which will
    generate a `DaggerApplicationComponent` class. This is an implementation of `ApplicationComponent`
    that Dagger 2 will handle. This class will be used to create the entire dependency
    graph. In Android, we need an entry point for this, which is represented by the
    `Application` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`@Component`，在其中我们指定应用程序将使用的模块。`@Singleton`注解告诉Dagger，这个组件中的所有依赖将与应用程序的生命周期一样长。在这个时候，我们应该在应用程序上触发构建。这将触发编译，生成一个`DaggerApplicationComponent`类。这是一个`ApplicationComponent`的实现，Dagger
    2将处理它。这个类将用于创建整个依赖图。在Android中，我们需要一个入口点，这由`Application`类表示：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, in the `MyApplication` class, we are using `DaggerApplicationComponent`
    and creating the dependency graph. This will go over all the modules in the graph
    and invoke all the `@Provides` methods. The `@Component` annotation has another
    role, which is to define member injection when constructor injection is not possible.
    In Android, this situation occurs when dealing with life cycle components such
    as activities and fragments, because we are not allowed to modify the default
    constructors of these classes. To do this, we can do the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`MyApplication`类中，我们使用`DaggerApplicationComponent`创建依赖图。这将遍历图中的所有模块并调用所有的`@Provides`方法。`@Component`注解还有另一个作用，即在构造函数注入不可用时定义成员注入。在Android中，这种情况发生在处理生命周期组件，如活动和片段时，因为我们不允许修改这些类的默认构造函数。为此，我们可以这样做：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `ApplicationComponent`, we add a method called `inject` and the `Activity`
    where we want the injection to be performed. In the `MainActivity` class, we will
    need to do the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ApplicationComponent`中，我们添加了一个名为`inject`的方法和想要执行注入的`Activity`。在`MainActivity`类中，我们需要做以下操作：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we will need to access the `ApplicationComponent` instance created in
    `MyApplication` and then invoke the `inject` method from `ApplicationComponent`.
    This will then initialize variable `a` with the instance Dagger 2 created. This
    approach has a problem, however, because all the dependencies will live as long
    as the application. This means that Dagger 2 will need to keep dependencies in
    memory when they are not required. Dagger 2 offers a solution for this in the
    form of scopes and subcomponents. We can create a new Scope, which will tell Dagger
    2 to only keep certain dependencies as long as an Activity is alive, and then
    apply this Scope to a Subcomponent, which will handle a smaller graph of dependencies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要访问在 `MyApplication` 中创建的 `ApplicationComponent` 实例，然后从 `ApplicationComponent`
    中调用 `inject` 方法。这将初始化变量 `a` 为 Dagger 2 创建的实例。然而，这种方法有一个问题，因为所有依赖项都将与应用程序的生命周期一样长。这意味着当不需要依赖项时，Dagger
    2 需要保留它们在内存中。Dagger 2 以范围和子组件的形式提供了解决方案。我们可以创建一个新的范围，这将告诉 Dagger 2 只在 Activity
    存活期间保留某些依赖项，然后将其应用于子组件，这将处理更小的依赖项图。
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we created a new `@Scope` annotation, which will indicate that dependencies
    will live as long as activities. We will next use `@ActivityScope` to create an
    `@Subcomponent` annotated class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的 `@Scope` 注解，它将指示依赖项将与活动一样长。接下来，我们将使用 `@ActivityScope` 创建一个 `@Subcomponent`
    注解的类：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we have defined a subcomponent that will use `ApplicationModule` and
    has an `inject` method for field injection into `MainActivity`. After that, we
    will need to tell Dagger 2 to create `MainSubcomponent`, by modifying `ApplicationComponent`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个子组件，它将使用 `ApplicationModule` 并为 `MainActivity` 中的字段注入提供了一个 `inject`
    方法。之后，我们需要告诉 Dagger 2 创建 `MainSubcomponent`，通过修改 `ApplicationComponent`：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we have removed `ApplicationModule` from `@Component` and replaced the
    `inject` method with a `createMainSubcomponent` method, which will allow Dagger
    to create `MainSubcomponent`. Finally, we will need to access `MainSubcomponent`
    in `MainActivity` and inject the `ClassA` dependency:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从 `@Component` 中移除了 `ApplicationModule`，并用一个 `createMainSubcomponent`
    方法替换了 `inject` 方法，这将允许 Dagger 创建 `MainSubcomponent`。最后，我们需要在 `MainActivity` 中访问
    `MainSubcomponent` 并注入 `ClassA` 依赖项：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we access the `ApplicationComponent` instance from `MyApplication`, then
    create `MainSubcomponent` and then inject the `ClassA` dependency into the `a`
    variable. The code generated by Dagger 2 can be seen in the `{module}/build/generated/source/kapt/{build
    type}` folder and will look something similar to the following figure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从 `MyApplication` 访问 `ApplicationComponent` 实例，然后创建 `MainSubcomponent`
    并将 `ClassA` 依赖项注入到 `a` 变量中。Dagger 2 生成的代码可以在 `{module}/build/generated/source/kapt/{build
    type}` 文件夹中看到，看起来类似于以下图：
- en: '![Figure 4.2 – Generated Dagger Classes'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 生成的 Dagger 类'
- en: '](img/Figure_4.02_B18320.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.02_B18320.jpg)'
- en: Figure 4.2 – Generated Dagger Classes
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 生成的 Dagger 类
- en: In the preceding figure, we can see Dagger will generate the implementation
    for the `ApplicationComponent` interface as well as the `MainSubcomponent` implementation.
    For dependencies that will need to be injected, it will generate a `Factory` class
    to create the dependency. Where we are injecting through the members, it will
    create an `Injector` class, which will be responsible for setting the value on
    the member variable, like the `MainActivity` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到 Dagger 将为 `ApplicationComponent` 接口以及 `MainSubcomponent` 实现生成实现。对于需要注入的依赖项，它将生成一个
    `Factory` 类来创建依赖项。在我们通过成员注入的地方，它将创建一个 `Injector` 类，该类将负责设置成员变量的值，例如 `MainActivity`
    类。
- en: In this section, we have discussed the Dagger 2 library and how it can be used
    to provide and inject dependencies. Because it is a library used in other frameworks
    other than Android, it requires specific workarounds for injecting in activities
    and fragments, using member injectors and Subcomponents. An attempt at fixing
    this was through the introduction of the Dagger Android library, which handled
    the creation of `@Subcomponent` annotated classes and introduced new annotations
    to indicate how Subcomponents should be created. More recently, the introduction
    of the Hilt library was more effective at solving these problems by further simplifying
    the amount of code developers needed to write and providing better compatibility
    with components such as ViewModel. In the section that follows, we will look at
    the Hilt library and how it solves these problems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了 Dagger 2 库以及如何使用它来提供和注入依赖。因为它是在 Android 之外的框架中使用的库，所以它需要特定的解决方案来在活动和片段中注入，使用成员注入器和子组件。通过引入
    Dagger Android 库来尝试解决这个问题，该库处理了创建 `@Subcomponent` 注解的类的创建，并引入了新的注解来指示子组件应该如何创建。最近，Hilt
    库的引入通过进一步简化开发者需要编写的代码量，并提供了与 ViewModel 等组件更好的兼容性，更有效地解决了这些问题。在下一节中，我们将查看 Hilt
    库以及它是如何解决这些问题的。
- en: Using Hilt to manage dependencies
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hilt 管理依赖
- en: In this section, we will discuss the Hilt DI library, how we can use it in an
    Android application, and the extra features it provides on top of the Dagger 2
    library.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 Hilt DI 库，如何在 Android 应用程序中使用它，以及它相对于 Dagger 2 库提供的额外功能。
- en: 'Hilt is a library built on top of Dagger 2 with a specific focus on Android
    applications. This is to remove the extra boilerplate code that was required to
    use Dagger 2 in an application. Hilt removes the need to use `@Component` and
    `@Subcomponent` annotated classes and in turn offers new annotations:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Hilt 是一个建立在 Dagger 2 之上的库，专注于 Android 应用程序。这是为了移除在应用程序中使用 Dagger 2 所需要的额外样板代码。Hilt
    移除了使用 `@Component` 和 `@Subcomponent` 注解的类来使用 Dagger 2 的需求，并转而提供新的注解：
- en: When injecting dependencies in Android classes, we can use `@HiltAndroidApp`
    for `Application` classes, `@AndroidEntryPoint` for activities, fragments, services,
    broadcast receivers, and views, and `@HiltViewModel` for `ViewModels`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 类中注入依赖时，我们可以为 `Application` 类使用 `@HiltAndroidApp`，为活动、片段、服务、广播接收器和视图使用
    `@AndroidEntryPoint`，以及为 `ViewModels` 使用 `@HiltViewModel`。
- en: 'When using the `@Module` annotation, we now have the option to use `@InstallIn`
    and specify an `@DefineComponent` annotated class, which represents the component
    the module will be added to. Hilt provides a set of useful components to install
    modules in:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `@Module` 注解时，我们现在可以选择使用 `@InstallIn` 并指定一个 `@DefineComponent` 注解的类，它代表模块将被添加到的组件。Hilt
    提供了一套有用的组件来安装模块：
- en: '`@SingletonComponent`: This will make the dependencies live as long as the
    application.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SingletonComponent`：这将使依赖与应用程序生命周期相同。'
- en: '`@ViewModelComponent`: This will make the dependencies live as long as a `ViewModel`.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ViewModelComponent`：这将使依赖与 `ViewModel` 生命周期相同。'
- en: '`@ActivityComponent`: This will make the dependencies live as long as an `Activity`.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ActivityComponent`：这将使依赖与 `Activity` 生命周期相同。'
- en: '`@FragmentComponent`: This will make the dependencies live as long as a `Fragment`.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@FragmentComponent`：这将使依赖与 `Fragment` 生命周期相同。'
- en: '`@ServiceComponent`: This will make the dependencies live as long as a `Service`.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ServiceComponent`：这将使依赖与 `Service` 生命周期相同。'
- en: 'In order to use Hilt in a project, it will require a Gradle plugin, which will
    need to be added as a dependency to the root `build.gradle` file in the project:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在项目中使用 Hilt，它需要一个 Gradle 插件，该插件需要作为依赖添加到项目的根 `build.gradle` 文件中：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will then need to add the annotation processor plugin and the Hilt plugin
    to the `build.gradle` file of the Gradle module that we want to use the Hilt library
    in:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将注解处理器插件和 Hilt 插件添加到我们想要在 Gradle 模块中使用 Hilt 库的 `build.gradle` 文件中：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The combination of these two plugins is what allows Hilt to generate the necessary
    source code for injecting the dependencies. Finally, we will need to add the dependency
    to the Hilt library:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个插件的组合使得 Hilt 能够生成注入依赖所需的源代码。最后，我们还需要将依赖添加到 Hilt 库中：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we need the dependency on the library itself and a dependency on the annotation
    processor like how it was necessary for Dagger 2.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要对库本身的依赖以及对注解处理器的依赖，就像在 Dagger 2 中那样必要。
- en: 'Let''s now re-introduce the example from the previous section:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新引入上一节中的示例：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we can keep the same structure of our classes and use the `@Inject` annotation
    like previously. The `@Module` annotated class that will provide these dependencies
    will look similar to a Dagger 2 Module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以保持我们类的相同结构，并像之前那样使用 `@Inject` 注解。将提供这些依赖项的 `@Module` 注解的类将类似于 Dagger
    2 模块：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `ApplicationModule` class, we keep the same implementation as before
    but now we have added the `@InstallIn` annotation, which will make the dependencies
    provided by this module live as long as the application will. Next, we will need
    to trigger the generation of components:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ApplicationModule` 类中，我们保持之前的实现不变，但现在我们添加了 `@InstallIn` 注解，这将使此模块提供的依赖项的生命周期与应用程序的生命周期相同。接下来，我们需要触发组件的生成：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we no longer need to use `DaggerApplicationComponent` to manually trigger
    the creation of the dependency graph and instead use `@HiltAndroidApp`, which
    will do this for us, as well as providing the ability to inject dependencies into
    the `MyApplication` class. Finally, we will need to inject the dependencies into
    an `Activity`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不再需要使用 `DaggerApplicationComponent` 来手动触发依赖图的创建，而是使用 `@HiltAndroidApp`，这将为我们完成这项工作，并提供将依赖项注入到
    `MyApplication` 类的能力。最后，我们需要将依赖项注入到 `Activity` 中：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we use the `@AndroidEntry` point to inform Hilt that we want to inject
    a dependency into an Activity and then use the `@Inject` annotation like how it
    worked in Dagger 2\. The code generated by Hilt will look similar to the following
    figure and can be found in `{module}/build/generated/source/kapt/{build type}`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `@AndroidEntry` 入口点通知 Hilt 我们想要将依赖注入到 Activity 中，然后像在 Dagger 2 中那样使用
    `@Inject` 注解。Hilt 生成的代码将类似于以下图示，并可在 `{module}/build/generated/source/kapt/{构建类型}`
    中找到：
- en: '![Figure 4.3 – Generated Hilt Classes'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 生成的 Hilt 类'
- en: '](img/Figure_4.03_B18320.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.03_B18320.jpg)'
- en: Figure 4.3 – Generated Hilt Classes
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 生成的 Hilt 类
- en: In the preceding figure, we can see `Factory` classes like the ones that Dagger
    2 generates, but extra classes that Hilt will generate to handle the boilerplate
    work that was required to work with Dagger 2, such as handling the injection into
    activities and fragments or creating the dependency graph in the `Application`
    class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到类似于 Dagger 2 生成的 `Factory` 类，但 Hilt 将生成额外的类来处理与 Dagger 2 一起工作时所需的样板工作，例如处理活动或片段的注入或在
    `Application` 类中创建依赖图。
- en: In this section, we discussed the Hilt library, how we can use it to manage
    dependencies in an Android application, and how it removes boilerplate code that
    Dagger 2 required. In the following section, we will look at an exercise on integrating
    Hilt into an application together with other libraries.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了 Hilt 库，我们如何使用它来管理 Android 应用程序中的依赖项，以及它如何消除了 Dagger 2 所需的样板代码。在下一节中，我们将探讨将
    Hilt 集成到应用程序中与其他库一起使用的练习。
- en: Exercise 04.01 – Using Hilt to manage dependencies
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Exercise 04.01 – 使用 Hilt 管理依赖项
- en: Modify *Exercise 03.02 – navigating using Jetpack Compose* from [*Chapter 3*](B18320_03_ePub.xhtml#_idTextAnchor055)*,
    Understanding Data Presentation on Android*, so that it will use Hilt to manage
    the dependencies across the application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 修改来自 [*第 3 章*](B18320_03_ePub.xhtml#_idTextAnchor055) 的 *Exercise 03.02 – 使用
    Jetpack Compose 进行导航*，以便它将使用 Hilt 来管理应用程序中的依赖项。
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，你需要执行以下操作：
- en: Add the Hilt library to the project.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Hilt 库添加到项目中。
- en: Create a `NetworkModule` class that will provide the Retrofit dependencies.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `NetworkModule` 类，它将提供 Retrofit 依赖项。
- en: Create a `PersistenceModule` class that will provide the Room and Data Store
    dependencies.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `PersistenceModule` 类，它将提供 Room 和 Data Store 依赖项。
- en: Clean up the `MyApplication` class, delete the `MainViewModelFactory` class,
    and instead use the `@HiltViewModel` annotation.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理 `MyApplication` 类，删除 `MainViewModelFactory` 类，并改用 `@HiltViewModel` 注解。
- en: Modify `MainActivity` to instead obtain an instance of the `MainView` model
    from the Hilt Compose Navigation library.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MainActivity`，使其从 Hilt Compose Navigation 库中获取 `MainView` 模型的实例。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'Add the Hilt Gradle plugin to the root project `build.gradle` file:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Hilt Gradle 插件添加到根项目的 `build.gradle` 文件：
- en: '[PRE29]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Apply the Gradle plugin to the `build.gradle` file in the app module:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Gradle 插件应用到 app 模块中的 `build.gradle` 文件：
- en: '[PRE30]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the Hilt library dependency to the app module''s `build.gradle` file:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Hilt 库依赖项添加到 app 模块的 `build.gradle` 文件：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we added a dependency that allows Hilt to work with the Jetpack Compose
    Navigation library.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个允许 Hilt 与 Jetpack Compose Navigation 库一起工作的依赖项。
- en: 'Create a `NetworkModule` class in which the networking dependencies are provided:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 `NetworkModule` 类中提供网络依赖项：
- en: '[PRE32]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we have moved all the dependencies for networking and split them into
    separate methods for `OkHttplClient`, `Moshi`, `Retrofit`, and finally, the `UserService`
    class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将所有网络相关的依赖项移动到单独的方法中，分别为 `OkHttplClient`、`Moshi`、`Retrofit` 以及最终的 `UserService`
    类。
- en: 'Next, create a `PersistenceModule` class, which will return all the persistence-related
    dependencies:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `PersistenceModule` 类，它将返回所有持久化相关的依赖项：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we have moved all the Room-related classes and the Data Store classes.
    For `DataStore`, we are required to declare the `Context.dataStore` file at the
    top level of the file, so we will need to keep it here. The usage of `@ApplicationContext`
    is meant to denote that the `Context` object is represented by context of the
    application and not other Context objects such as an `Activity` object or `Service`
    object. The annotation is a `Qualifier`, which is meant to distinguish between
    different instances of the same class (in this case, it's to distinguish between
    the application context and activity context).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们将所有与 Room 相关的类和数据存储类移动到了这里。对于 `DataStore`，我们要求在文件的最顶层声明 `Context.dataStore`
    文件，因此我们需要将其保留在这里。使用 `@ApplicationContext` 的目的是表示 `Context` 对象是应用程序的上下文，而不是其他上下文对象，例如
    `Activity` 对象或 `Service` 对象。这个注解是一个 `Qualifier`，其目的是区分同一类的不同实例（在这种情况下，是为了区分应用程序上下文和活动上下文）。 '
- en: 'Add the `@Inject` annotation to the constructor of the `MainTextFormatter`
    class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `@Inject` 注解添加到 `MainTextFormatter` 类的构造函数中：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will let Hilt provide a new instance of `MainTextFormatter` every time
    it will be used as a dependency. Here, again, we will need to use the `@ApplicationContext`
    annotation to use the application `Context` object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以让 Hilt 在每次使用 `MainTextFormatter` 作为依赖项时提供一个新的实例。在这里，我们还需要使用 `@ApplicationContext`
    注解来使用应用程序的 `Context` 对象。
- en: 'Delete all the dependencies in the `MyApplication` class and add the `@HiltAndroidApp`
    annotation:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MyApplication` 类中删除所有依赖项，并添加 `@HiltAndroidApp` 注解：
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Delete the `MainViewModelFactory` class.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `MainViewModelFactory` 类。
- en: 'Add the `@HiltViewModel` annotation to the `MainViewModel` class and `@Inject`
    to the constructor:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `@HiltViewModel` 注解添加到 `MainViewModel` 类，并将 `@Inject` 添加到构造函数：
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Delete the reference to `MainViewModelFactory` in the `Users` `@Composable`
    method in `MainActivity`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 的 `Users` `@Composable` 方法中删除对 `MainViewModelFactory` 的引用：
- en: '[PRE37]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change the `@Composable` `App` method in `MainActivity` so that it provides
    a `MainViewModel` instance when it invokes the `Users` method:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MainActivity` 中的 `@Composable` `App` 方法修改为在调用 `Users` 方法时提供 `MainViewModel`
    实例：
- en: '[PRE38]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are using the `hiltViewModel` method, which is from the Hilt compatibility
    library with the Navigation library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了 `hiltViewModel` 方法，它来自与 Navigation 库兼容的 Hilt 库。
- en: 'Add the `@AndroidEntryPoint` annotation to `MainActivity`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 上添加 `@AndroidEntryPoint` 注解：
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you encounter a `Records requires ASM8` error when building the application,
    then add the following to the root project''s `gradle.properties` file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在构建应用程序时遇到 `Records requires ASM8` 错误，请在根项目的 `gradle.properties` 文件中添加以下内容：
- en: '[PRE40]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This error is caused by an incompatibility that currently exists in the Android
    build tools and should be resolved when later updates are available.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是由当前 Android 构建工具中存在的兼容性问题引起的，应该在后续更新中解决。
- en: If we run the application covered in this exercise, the functionality and user
    interface should remain the same as before. The role of Hilt here was to simplify
    how we manage dependencies, shown by how we have simplified the `MyApplication`
    class, leaving it with a simple annotation, and the fact that we have removed
    `MainViewModelFactory`, which itself had to depend on the `MyApplication` class.
    We can also see how easy it is to integrate Hilt with the rest of the libraries
    we used in the exercise.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行本练习涵盖的应用程序，功能界面应该与之前相同。Hilt 在这里的作用是简化我们管理依赖项的方式，这体现在我们如何简化了 `MyApplication`
    类，仅留下一个简单的注解，以及我们移除了 `MainViewModelFactory`，它本身必须依赖于 `MyApplication` 类。我们还可以看到将
    Hilt 与我们在练习中使用的其他库集成是多么容易。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the DI pattern and some of the more popular libraries
    that are available to apply this pattern to an Android application. We looked
    initially at Dagger 2 and how it can be integrated into an application, and then
    we analyzed the Hilt library, which is built on top of Dagger 2 and solves further
    problems that are specific to Android development.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了DI模式以及一些可用于将此模式应用于Android应用的流行库。我们最初探讨了Dagger 2及其如何集成到应用中，然后分析了基于Dagger
    2构建的Hilt库，该库解决了Android开发中的一些特定问题。
- en: There are other libraries that can be used to manage dependencies, such as Koin,
    which uses the Service Locator pattern (in which a registry is created and dependencies
    can be obtained) and is developed for Kotlin development. The exercise in this
    chapter showed how Hilt can be integrated with other libraries into an Android
    application. The problem is that the application still has no shape; there isn't
    anything we can point to that indicates what the use cases are. In the chapters
    that follow, we will look further into how we can structure our code to give it
    a shape using the Clean Architecture principles, starting with defining entities
    and use cases.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他库可以用来管理依赖关系，例如Koin，它使用服务定位器模式（其中创建一个注册表，可以从中获取依赖项）并专为Kotlin开发而开发。本章的练习展示了如何将Hilt与其他库集成到Android应用中。问题是，应用仍然没有形状；没有我们可以指出的东西来表明用例是什么。在接下来的章节中，我们将进一步探讨如何使用Clean
    Architecture原则来结构化我们的代码，从而给它一个形状，从定义实体和用例开始。
