<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Setting Up the Development Environment</h1>
            </header>

            <article>
                
<p>After the introduction about system programming in the last chapter, we need to set up a development environment first before we can go further. We need to know how to build and test <strong>Android Open Source Project</strong> (<strong>AOSP</strong>) while we explore various Android system programming topics in this book. We will cover the following topics in this chapter:</p>
<ul>
<li>Installing the Android SDK and setting up an Android Virtual Device</li>
<li>Setting up the AOSP build environment and building a testing image</li>
<li>Creating your own source code repository mirror</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary of Android versions</h1>
            </header>

            <article>
                
<p>Since we will use Android emulator as one of the virtual hardware platforms, we need to use one particular Android version throughout this book. At the time of writing, the latest Android version is Android 7 (Nougat). We will use Android 7 throughout the book. I started work on this book with Android 6, so the source code for Android 6 is also available in my GitHub repository at <span class="URLPACKT"><a href="https://github.com/shugaoye">https://github.com/shugaoye</a>.</span></p>
<p>From the first release to Android 7, both the development environment and the AOSP source code have been changed a lot. We will have a brief look at various Android versions first before we talk about the development environment setup.</p>
<p>To set up the AOSP build environment, there are two things that you need to pay special attention to the host environment and Java SDK. Even though the recommended host environment is Ubuntu running on Intel architecture, the hardware architecture and Ubuntu versions have changed from release to release. You can always refer to the following URL at Google for the latest AOSP build environment setup:</p>
<p><span class="URLPACKT"><a href="https://source.android.com/source/index.html">https://source.android.com/source/index.html</a></span></p>
<p>For Gingerbread (2.3.x) and above, a 64-bit build environment is required. For older versions, the build environment is 32-bit systems.</p>
<p>The Ubuntu versions used range from Ubuntu 10.04 to 14.04, but for each release there is a recommended Ubuntu version. If it is a new setup, it is suggested to use the recommended Ubuntu version to make the job easier. However, there are no hard requirements here. You should be able to use any Ubuntu version higher than the recommended Ubuntu version. There are also many articles about how to set up the AOSP build using a different Linux distribution such as RedHat or Debain.</p>
<p>Oracle JDK was used to build AOSP until Lollipop. From Lollipop and the above, OpenJDK was used instead of Oracle JDK.</p>
<p>The following table summarizes all Android releases, required hosts, and JDK environments until Nougat; you can refer to it for full details.</p>
<p><strong>AOSP releases</strong>:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Nickname</strong></p>
</td>
<td>
<p><strong>AOSP</strong></p>
</td>
<td>
<p><strong>SDK API level</strong></p>
</td>
<td>
<p><strong>Host</strong></p>
</td>
<td>
<p><strong>JDK</strong></p>
</td>
<td>
<p><strong>OS/Ubuntu</strong></p>
</td>
<td>
<p><strong>Goldfish</strong></p>
</td>
<td>
<p><strong>Ranchu</strong></p>
</td>
</tr>
<tr>
<td>
<p>Cupcake</p>
</td>
<td>
<p>1.5</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>x86</p>
</td>
<td>
<p>Oracle JDK 5</p>
</td>
<td>
<p>10.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Donut</p>
</td>
<td>
<p>1.6</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>x86</p>
</td>
<td>
<p>Oracle JDK 5</p>
</td>
<td>
<p>10.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Eclair</p>
</td>
<td>
<p>2.0/2.1</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>x86</p>
</td>
<td>
<p>Oracle JDK 5</p>
</td>
<td>
<p>10.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Eclair</p>
</td>
<td>
<p>2.0.1</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>x86</p>
</td>
<td>
<p>Oracle JDK 5</p>
</td>
<td>
<p>10.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Eclair</p>
</td>
<td>
<p>2.1</p>
</td>
<td>
<p>7</p>
</td>
<td>
<p>x86</p>
</td>
<td>
<p>Oracle JDK 5</p>
</td>
<td>
<p>10.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Froyo</p>
</td>
<td>
<p>2.2</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>x86</p>
</td>
<td>
<p>Oracle JDK 5</p>
</td>
<td>
<p>10.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Gingerbread</p>
</td>
<td>
<p>2.3.1</p>
</td>
<td>
<p>9</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Gingerbread</p>
</td>
<td>
<p>2.3.3</p>
</td>
<td>
<p>10</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Honeycomb</p>
</td>
<td>
<p>3.0</p>
</td>
<td>
<p>11</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Honeycomb</p>
</td>
<td>
<p>3.1</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Honeycomb</p>
</td>
<td>
<p>3.2</p>
</td>
<td>
<p>13</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Ice Cream Sandwich</p>
</td>
<td>
<p>4.0</p>
</td>
<td>
<p>14</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Ice Cream Sandwich</p>
</td>
<td>
<p>4.0.3</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Jelly Bean</p>
</td>
<td>
<p>4.1.2</p>
</td>
<td>
<p>16</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Jelly Bean</p>
</td>
<td>
<p>4.2.2</p>
</td>
<td>
<p>17</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Jelly Bean</p>
</td>
<td>
<p>4.3.1</p>
</td>
<td>
<p>18</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td/>
</tr>
<tr>
<td>
<p>KitKat</p>
</td>
<td>
<p>4.4.2</p>
</td>
<td>
<p>19</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td>
<p>x</p>
</td>
</tr>
<tr>
<td>
<p>KitKat</p>
</td>
<td>
<p>4.4W.2</p>
</td>
<td>
<p>20</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Oracle JDK 6</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td>
<p>x</p>
</td>
</tr>
<tr>
<td>
<p>Lollipop</p>
</td>
<td>
<p>5.0.1</p>
</td>
<td>
<p>21</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Open JDK 7</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td>
<p>x</p>
</td>
</tr>
<tr>
<td>
<p>Lollipop</p>
</td>
<td>
<p>5.1.1</p>
</td>
<td>
<p>22</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Open JDK 7</p>
</td>
<td>
<p>12.04</p>
</td>
<td>
<p>x</p>
</td>
<td>
<p>x</p>
</td>
</tr>
<tr>
<td>
<p>Mashmallow</p>
</td>
<td>
<p>6.0</p>
</td>
<td>
<p>23</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Open JDK 7</p>
</td>
<td>
<p>14.04</p>
</td>
<td>
<p>x</p>
</td>
<td>
<p>x</p>
</td>
</tr>
<tr>
<td>
<p>Nougat</p>
</td>
<td>
<p>7.0.x</p>
</td>
<td>
<p>24</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Open JDK 8</p>
</td>
<td>
<p>14.04</p>
</td>
<td>
<p>x</p>
</td>
<td>
<p>x</p>
</td>
</tr>
<tr>
<td>
<p>Nougat</p>
</td>
<td>
<p>7.1.1</p>
</td>
<td>
<p>25</p>
</td>
<td>
<p>x64</p>
</td>
<td>
<p>Open JDK 8</p>
</td>
<td>
<p>14.04</p>
</td>
<td>
<p>x</p>
</td>
<td>
<p>x</p>
</td>
</tr>
</tbody>
</table>
<p>From the preceding table, you can see that the ranchu emulator is supported by KitKat and the others. If you install and download the system image of Kitkat or the others on Android SDK, you should be able to find two kernel files, <kbd>kernel-qemu</kbd> and <kbd>kernel-ranchu</kbd>.</p>
<p>There are two API levels in the Nougat releases. Android 7.0.0 and 7.1.0 are API level 24. Android 7.1.1 and 7.1.2 are API level 25. All source code in this book can support up to API level 25.</p>
<div class="packt_infobox">The code name of the original Android emulator is goldfish. It is based on an older version of QEMU. A new Android emulator version was released based on QEMU 2.x in 2016. The code name of this new emulator is ranchu. It is supported by KitKat and the others.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Installing Android SDK and setting up an Android Virtual Device</h1>
            </header>

            <article>
                
<p>Ideally, if you have an AOSP build environment, you can build everything including Android SDK from scratch. However, it is much more convenient to have an Android SDK installation to help with virtual device creation or running emulator images.</p>
<p>You can always download the latest Android SDK from the following website:</p>
<p><a href="https://developer.android.com/index.html">https://developer.android.com/index.html</a></p>
<p>The host environment that we use in this book is Ubuntu 14.04. Download the Android SDK for Linux and decompress it to a folder in your <kbd>Home</kbd> directory.</p>
<p>The tools in Android SDK have been changed since API level 25. You may use an older version of Android SDK or the latest Android SDK so I gave the instructions for both cases here.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating AVD in an older version of SDK</h1>
            </header>

            <article>
                
<p>For the older version of SDK, such as <kbd>android-sdk_r24.4.1-linux.tgz</kbd>, it includes all necessary components and we can use it after decompression. We can find the following contents after decompressing:</p>
<pre>
<strong>$ ls android-sdk-linux</strong><br/><strong>add-ons      platforms       SDK Readme.txt  temp</strong><br/><strong>build-tools  platform-tools  system-images   tools</strong>
</pre>
<p>You can add the <kbd>platform-tools</kbd> and <kbd>tools</kbd> directory to your <kbd>PATH</kbd> environment variable.</p>
<p>We will use a virtual device based on API level 25 in this book to test our image.</p>
<p>To create a virtual device, we can launch <strong>Android Virtual Device</strong> (<strong>AVD</strong>) Manager using the following command, as shown in the following screenshot:</p>
<pre>
<strong>$ android avd</strong>  
</pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="415" width="596" class=" image-border" src="assets/image_02_001.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">AVD Manager</div>
<p>Click the <span class="packt_screen">Create...</span> button in AVD Manager and create a new virtual device named <kbd>a25x86</kbd> with the following configuration, as shown in the following screenshot:</p>
<ul>
<li>Android 7.1.1 - API level 25</li>
<li>1024 MB RAM</li>
<li>400 MB SD card</li>
<li>400 MB internal storage</li>
<li>Display size at 480 x 800: hdpi</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="477" width="329" class=" image-border" src="assets/image_02_002.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Android Virtual Device a25x86</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating AVD in the latest version of SDK</h1>
            </header>

            <article>
                
<p>For the newer versions, there is only SDK command-line tools available for download. For example, if you download the command-line tools for r25, such as <kbd>tools_r25.2.3-linux.zip</kbd>, you can find the <kbd>tools</kbd> folder only. In this case, you need to use Android SDK Manager at <kbd>tools/bin/sdkmanager</kbd> to download the rest of SDK components. To download the rest of SDK components, you can use the following command:</p>
<pre>
<strong>$ sdkmanager --update</strong>
</pre>
<p>If you use the latest version of Android SDK, you may get the following error message, if you follow the previous instructions:</p>
<pre>
<strong>$ android avd</strong><br/><strong>*********************************************************************</strong><br/><strong>The "android" command is deprecated.</strong><br/><strong>For manual SDK, AVD, and project management, please use Android Studio.</strong><br/><strong>For command-line tools, use tools/bin/sdkmanager and tools/bin/avdmanager</strong><br/><strong>*********************************************************************</strong><br/><strong>Invalid or unsupported command "avd"</strong><br/><br/><strong>Supported commands are:</strong><br/><strong>android list target</strong><br/><strong>android list avd</strong><br/><strong>android list device</strong><br/><strong>android create avd</strong><br/><strong>android move avd</strong><br/><strong>android delete avd</strong><br/><strong>android list sdk</strong><br/><strong>android update sdk</strong>
</pre>
<p>In this case, you can create AVD using the following command.</p>
<pre>
<strong>$ avdmanager create avd -n a25x86 --tag google_apis -k 'system-images;android-25;google_apis;x86'</strong><br/><strong>Auto-selecting single ABI x86</strong><br/><strong>Do you wish to create a custom hardware profile? [no]</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Testing the goldfish emulator</h1>
            </header>

            <article>
                
<p>In Android 7, both the ranchu and goldfish emulators are supported. Let's test the goldfish emulator first. We can run this virtual device in the goldfish emulator using the following command:</p>
<pre>
<strong>$ emulator @a25x86 -verbose -show-kernel -shell -engine classic</strong><br/><strong>emulator:Found AVD name 'a25x86'</strong><br/><strong>emulator:Found AVD target architecture: x86</strong><br/><strong>emulator:Looking for emulator-x86 to emulate 'x86' CPU</strong><br/><strong>...</strong><br/><strong>  kernel.path = /home/roger/android-sdk-linux/system-images/android-  <br/>  25/default/x86/</strong>kernel-qemu<br/><strong>...</strong>  
</pre>
<p>To monitor the status of a virtual device, we can use the following Android emulator options:</p>
<ul>
<li><kbd>-verbose</kbd>: Shows the emulator debug information.</li>
<li><kbd>-show-kernel</kbd>: Shows kernel debug information.</li>
<li><kbd>-shell</kbd>: Uses <kbd>stdio</kbd> as the command line prompt.</li>
<li><kbd>-engine</kbd>: Selects the emulator engine. The choice can be <kbd>auto</kbd>, <kbd>classic</kbd>, or <kbd>qemu2</kbd>. The <kbd>classic</kbd> option is to use the goldfish emulator and the <kbd>qemu2</kbd> option is to use the ranchu emulator. If the option is <kbd>auto</kbd> or without the <kbd>engine</kbd> option, the system will check the environment and try to launch ranchu first. If it fails, it will fall back to goldfish.</li>
</ul>
<p>From the preceding log, we can see that the <kbd>kernel-qemu</kbd> kernel file is used for the goldfish emulator.</p>
<p>Both the ranchu and goldfish emulators are developed on top of QEMU, but they use different kernel and QEMU versions. We can verify the QEMU version used for either goldfish or ranchu using the following emulator commands.</p>
<p>To verify the QEMU version used by goldfish, we can run the following command:</p>
<pre>
<strong>$ emulator -engine classic -qemu -version</strong><br/><strong>QEMU PC emulator version 0.10.50 Android, Copyright (c) 2003-2008 Fabrice Bellard</strong>  
</pre>
<p>From the preceding output, we can see that QEMU version 0.10.50 is used for the goldfish emulator.</p>
<p>For the latest emulator version, it seems there is a bug with regard to handling the classic engine. You may get the following error message, when you execute the preceding command:</p>
<pre>
<strong>$ emulator -engine classic -qemu -version</strong><br/><strong>emulator: ERROR: android_qemud_get_serial_line: can't create charpipe to serial port</strong>  
</pre>
<div class="packt_infobox">The emulator command is a wrapper for QEMU. Any command-line options after <kbd>-qemu</kbd> are passed to QEMU as the command lines of QEMU directly.<br/>
To find out the emulator version, we can use the following command:<br/>
<kbd><strong>$ emulator -version<br/></strong></kbd>The following command will show the QEMU version:<br/>
<kbd><strong>$ emulator -qemu -version</strong></kbd></div>
<p>After the Android device has started successfully, from the Android UI, we can go to <span class="packt_screen">Settings</span> -&gt; <span class="packt_screen">About Phone</span> and see the screen shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="458" width="266" class="image-border" src="assets/image_02_003.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Android kernel version of goldfish</div>
<p>Pay attention to the following information on the <span class="packt_screen">About Phone</span> screen:</p>
<ul>
<li><span class="packt_screen">Android version: 7.1</span></li>
<li><span class="packt_screen">Kernel version: 3.4.67</span></li>
<li><span class="packt_screen">Build number: sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys</span></li>
</ul>
<p>As we can see from the preceding information, the kernel version is <kbd>3.4.67</kbd> and the filesystem build number is <kbd>sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys</kbd> for goldfish emulator. In the next section, we can see that ranchu emulator uses a different kernel version, even though both emulators share the same filesystem.</p>
<p>The Android system build includes two parts: the AOSP system and an Android-compatible Linux kernel. The build result of the AOSP system includes all image files for the Android system except the kernel image. They are built separately and are also under difference licenses. The preferred license for the AOSP is the Apache Software License, while the Linux kernel is under the GPLv2 License. Be aware of this difference. It also means that the AOSP build doesn't include the kernel build. We have to build the kernel separately. We can also use different kernel images with the same filesystem as in the test of the goldfish and ranchu emulator.</p>
<p>When we talk about the Android version, we have to look into the details of the kernel version and filesystem build number.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Testing ranchu emulator</h1>
            </header>

            <article>
                
<p>We can test ranchu emulator as well with the same virtual device. We can use a similar command without the <kbd>-engine</kbd> option or with the <kbd>-engine qemu2</kbd> option to start ranchu emulator:</p>
<pre>
<strong>$ emulator @a25x86 -verbose -show-kernel -shell</strong><br/><strong>emulator:Found AVD name 'a25x86'</strong><br/><strong>emulator:Found AVD target architecture: x86</strong><br/><strong>emulator:  Found directory: /home/roger/android-sdk-linux/system-images/android-25/default/x86/</strong><br/><br/><strong>emulator:Probing for /home/roger/android-sdk-linux/system-images/android-25/default/x86//</strong>kernel-ranchu: file exists<br/><strong>emulator:Auto-config: -engine qemu2 (based on configuration)</strong><br/><strong>emulator:Found target-specific 64-bit emulator binary: /home/roger/android-sdk-linux/tools/qemu/linux-x86_64/qemu-system-i386</strong><br/><strong>...</strong>  
</pre>
<p>From the preceding log, we can see that the kernel file <kbd>kernel-ranchu</kbd> is used in ranchu emulator.</p>
<p>We can also verify the QEMU version used by ranchu emulator using the following command:</p>
<pre>
<strong>$ emulator -qemu -version</strong><br/><strong>QEMU emulator version 2.2.0 , Copyright (c) 2003-2008 Fabrice Bellard</strong>  
</pre>
<p>We can see that ranchu uses a much newer QEMU version that can support many new features, which we will discuss later in this book.</p>
<p>Again, let's review the version information in <span class="packt_screen">Settings</span> as we did for goldfish emulator; refer to the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="415" width="242" class=" image-border" src="assets/image_02_004.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Android kernel version of ranchu</div>
<p>We can see that the ranchu emulator uses the kernel version 3.10.0, which is different from the goldfish emulator. The filesystem build is the same as for the goldfish emulator.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The AOSP build environment and the Android emulator build</h1>
            </header>

            <article>
                
<p>In order to create our own Android system, we have to set up the AOSP build environment and build our own AOSP target for the Android emulator. Since Android is under rapid development, the build process and environment setup can change from time to time. You can always refer to Google's website for the latest information,<span class="URLPACKT"> <a href="https://source.android.com/source/building.html">https://source.android.com/source/building.html</a>.</span></p>
<p>While the Google website and other sources can give general guidelines and procedures about the AOSP build, in this section we will look specifically at how to build AOSP for Android emulator image for API level 25.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The AOSP build environment</h1>
            </header>

            <article>
                
<p>Since we want to set up a build environment for API level 25, you can refer to the table of AOSP releases for the basic requirements about the host and JDK. It is recommended to use the Ubuntu 14.04 64-bit host with Open JDK 8. For the hardware requirement, you may want to have a powerful enough computer with at least 8 GB RAM and 500 GB hard disk space.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Installing the required packages</h1>
            </header>

            <article>
                
<p>We use the Ubuntu 14.04 64-bit version as our host operating system. After installing Ubuntu 14.04, the first thing you have to do is to install all necessary software packages as follows. If you use a different Linux distribution, you can refer to Google's website or search on the Internet for the relevant setup procedures. Let's execute the following commands to install all necessary packages for Ubuntu 14.04:</p>
<pre>
<strong>$ sudo apt-get install git-core gnupg flex bison gperf build-essential\ </strong><br/><strong>  zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386\ </strong><br/><strong>  lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache\ </strong><br/><strong>  libgl1-mesa-dev libxml2-utils xsltproc unzip</strong>  
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Installing Open JDK 7 and 8</h1>
            </header>

            <article>
                
<p>We will install both Open JDK 7 and 8 so we can build both Android 6 and 7 in our build environment.</p>
<p>To build Android API level 23, we need to install OpenJDK 7. We can execute the following commands from the Linux console to install OpenJDK 7:</p>
<pre>
<strong>$ sudo apt-get update</strong><br/><strong>$ sudo apt-get install openjdk-7-jdk</strong>  
</pre>
<p>For Android 7, we need to use OpenJDK 8 to build. There are no available supported OpenJDK 8 packages for Ubuntu 14.04 yet, but the Ubuntu 15.04 OpenJDK 8 packages have been used successfully with Ubuntu 14.04. We need to install OpenJDK 8 on Ubuntu 14.04 using the following instructions.</p>
<p>Download the <kbd>.deb</kbd> packages for 64-bit architecture from <a href="http://archive.ubuntu.com">archive.ubuntu.com</a>:</p>
<pre>
<strong>openjdk-8-jre-headless_8u45-b14-1_amd64.deb with SHA256 0f5aba8db39088283b51e00054813063173a4d8809f70033976f83e214ab56c0</strong><br/><strong>openjdk-8-jre_8u45-b14-1_amd64.deb with SHA256 9ef76c4562d39432b69baf6c18f199707c5c56a5b4566847df908b7d74e15849</strong><br/><strong>openjdk-8-jdk_8u45-b14-1_amd64.deb with SHA256 6e47215cf6205aa829e6a0a64985075bd29d1f428a4006a80c9db371c2fc3c4c</strong>
</pre>
<p>Optionally, confirm the checksums of the downloaded files against the SHA256 string listed with each preceding package.</p>
<p>For example, with the <em>sha256sum</em> tool:</p>
<pre>
<strong>$ sha256sum {downloaded.deb file}</strong>  
</pre>
<p>Install the packages:</p>
<pre>
<strong>$ sudo apt-get update</strong>  
</pre>
<p>Run <kbd>dpkg</kbd> for each of the <kbd>.deb</kbd> files you downloaded. It may produce errors due to missing dependencies:</p>
<pre>
<strong>$ sudo dpkg -i {downloaded.deb file}</strong>  
</pre>
<p>To fix missing dependencies:</p>
<pre>
<strong>$ sudo apt-get -f install</strong>  
</pre>
<p>With both OpenJDK 7 and 8 installed, we can update the default Java version by running the following commands:</p>
<pre>
<strong>$ sudo update-alternatives --config java</strong><br/><strong>$ sudo update-alternatives --config javac</strong>  
</pre>
<p>We have a build environment ready now. You may want to refer to Google's website to set up other things. For example, we may want to use cache to speed up the build or set up a separate output directory out of the AOSP tree.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Downloading the AOSP source</h1>
            </header>

            <article>
                
<p>Once we have a build environment ready, we need to get the AOSP source code. Again, refer to Google's website or the Internet to get more information.</p>
<p>You need to download the Android 7 source code from <a href="https://source.android.com/">source.android.com</a>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Installing repo</h1>
            </header>

            <article>
                
<p>AOSP consists of a large number of Git repositories, and we have to use the repo tool to manage these Git repositories. To download and install repo, we can use the following commands:</p>
<pre>
<strong>$ mkdir ~/bin</strong><br/><strong>$ PATH=~/bin:$PATH</strong><br/><strong>$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</strong><br/><strong>$ chmod a+x ~/bin/repo</strong>  
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Initializing a repo client and downloading the AOSP source tree</h1>
            </header>

            <article>
                
<p>After we have the repo tool, we can initialize the repo and download the AOSP source tree by executing the following commands:</p>
<pre>
<strong>$ repo init -u https://android.googlesource.com/platform/manifest -b android-7.1.1_r4</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>Pay attention to the AOSP tag <kbd>android-7.1.1_r4</kbd> here. This is the version of AOSP source code that we use throughout this book.</p>
<p>It will take quite a long time to get the AOSP source tree. After we get the source tree, let's take a look at the top level folders:</p>
<pre>
<strong>$ ls -F</strong><br/><strong>abi/      cts/         docs/       libcore/         packages/  tools/</strong><br/><strong>art/      dalvik/      external/   libnativehelper/ pdk/</strong><br/><strong>bionic    developers   filelist    Makefile         prebuilts</strong><br/><strong>bootable  development  frameworks  ndk              sdk</strong><br/><strong>build     device       hardware    out              system</strong>  
</pre>
<p>I won't explore the details about the source tree here; we will cover this in <a href="e0f861c2-5832-402f-89d3-cfc75785e759.xhtml">Chapter 3</a>, <em>Discovering Kernel, HAL, and Virtual Hardware</em>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Building AOSP Android emulator images</h1>
            </header>

            <article>
                
<p>In this book, we will use x86-based emulators. The x86-based emulator can use virtualization technology on the host, so it is much faster than the ARM emulator. We want to build the one that comes with the AOSP source code first. To create an Android emulator build, we can execute the following commands from the AOSP top-level folder:</p>
<pre>
<strong>$ . build/envsetup.sh </strong><br/><strong>including device/generic/mini-emulator-arm64/vendorsetup.sh</strong><br/><strong>including device/generic/mini-emulator-armv7-a-neon/vendorsetup.sh</strong><br/><strong>including device/generic/mini-emulator-mips/vendorsetup.sh</strong><br/><strong>including device/generic/mini-emulator-x86_64/vendorsetup.sh</strong><br/><strong>including device/generic/mini-emulator-x86/vendorsetup.sh</strong><br/><strong>including sdk/bash_completion/adb.bash</strong><br/><strong>$ lunch</strong><br/><br/><strong>You're building on Linux</strong><br/><br/><strong>Lunch menu... pick a combo:</strong><br/><strong>     1. aosp_arm-eng</strong><br/><strong>     2. aosp_arm64-eng</strong><br/><strong>     3. aosp_mips-eng</strong><br/><strong>     4. aosp_mips64-eng</strong><br/><strong>     5. aosp_x86-eng</strong><br/><strong>     6. aosp_x86_64-eng</strong><br/><strong>     7. mini_emulator_arm64-userdebug</strong><br/><strong>     8. m_e_arm-userdebug</strong><br/><strong>     9. mini_emulator_mips-userdebug</strong><br/><strong>     10. mini_emulator_x86_64-userdebug</strong><br/><strong>     11. mini_emulator_x86-userdebug</strong><br/><br/><strong>Which would you like? [aosp_arm-eng] 5</strong><br/><br/><strong>============================================</strong><br/><strong>PLATFORM_VERSION_CODENAME=REL</strong><br/><strong>PLATFORM_VERSION=7.1.1</strong><br/><strong>TARGET_PRODUCT=aosp_x86</strong><br/><strong>TARGET_BUILD_VARIANT=eng</strong><br/><strong>TARGET_BUILD_TYPE=release</strong><br/><strong>TARGET_BUILD_APPS=</strong><br/><strong>TARGET_ARCH=x86</strong><br/><strong>TARGET_ARCH_VARIANT=x86</strong><br/><strong>TARGET_CPU_VARIANT=</strong><br/><strong>TARGET_2ND_ARCH=</strong><br/><strong>TARGET_2ND_ARCH_VARIANT=</strong><br/><strong>TARGET_2ND_CPU_VARIANT=</strong><br/><strong>HOST_ARCH=x86_64</strong><br/><strong>HOST_2ND_ARCH=x86</strong><br/><strong>HOST_OS=linux</strong><br/><strong>HOST_OS_EXTRA=Linux-4.2.0-27-generic-x86_64-with-Ubuntu-14.04-trusty</strong><br/><strong>HOST_CROSS_OS=windows</strong><br/><strong>HOST_CROSS_ARCH=x86</strong><br/><strong>HOST_CROSS_2ND_ARCH=x86_64</strong><br/><strong>HOST_BUILD_TYPE=release</strong><br/><strong>BUILD_ID=NMF26O</strong><br/><strong>OUT_DIR=out</strong><br/><strong>============================================</strong>  
</pre>
<p>We set up the environment variables first using the startup script <kbd>envsetup.sh</kbd>. After that, we execute the command <kbd>lunch</kbd> to choose a build target. To build for the Android-x86 emulator, we can choose the target <kbd>aosp_x86-eng</kbd>, which will build an Android emulator version for x86. To learn more about the script file <kbd>envsetup.sh</kbd> and command <kbd>lunch</kbd>, refer to the Google website at <span class="URLPACKT"><a href="https://source.android.com">https://source.android.com</a>.</span></p>
<p>The actual build is started after we execute the following <kbd>make</kbd> command:</p>
<pre>
<strong>$ make -j4</strong><br/><strong>============================================</strong><br/><strong>PLATFORM_VERSION_CODENAME=REL</strong><br/><strong>PLATFORM_VERSION=7.1.1</strong><br/><strong>TARGET_PRODUCT=aosp_x86</strong><br/><strong>TARGET_BUILD_VARIANT=eng</strong><br/><strong>TARGET_BUILD_TYPE=release</strong><br/><strong>TARGET_BUILD_APPS=</strong><br/><strong>TARGET_ARCH=x86</strong><br/><strong>TARGET_ARCH_VARIANT=x86</strong><br/><strong>TARGET_CPU_VARIANT=</strong><br/><strong>TARGET_2ND_ARCH=</strong><br/><strong>TARGET_2ND_ARCH_VARIANT=</strong><br/><strong>TARGET_2ND_CPU_VARIANT=</strong><br/><strong>HOST_ARCH=x86_64</strong><br/><strong>HOST_OS=linux</strong><br/><strong>HOST_OS_EXTRA=Linux-4.2.0-27-generic-x86_64-with-Ubuntu-14.04-trusty</strong><br/><strong>HOST_BUILD_TYPE=release</strong><br/><strong>BUILD_ID=MOB30M</strong><br/><strong>OUT_DIR=out</strong><br/><strong>============================================</strong><br/><strong>including ./abi/cpp/Android.mk ...</strong><br/><strong>including ./art/Android.mk ...</strong><br/><strong>...</strong><br/><strong>make_ext4fs -S out/target/product/generic_x86/root/file_contexts -l 576716800 -a system out/target/product/generic_x86/obj/PACKAGING/systemimage_intermediates/system.img out/target/product/generic_x86/system</strong><br/><strong>+ make_ext4fs -S out/target/product/generic_x86/root/file_contexts -l 576716800 -a system out/target/product/generic_x86/obj/PACKAGING/systemimage_intermediates/system.img out/target/product/generic_x86/system</strong><br/><strong>Creating filesystem with parameters:</strong><br/><strong>    Size: 576716800</strong><br/><strong>    Block size: 4096</strong><br/><strong>    Blocks per group: 32768</strong><br/><strong>    Inodes per group: 7040</strong><br/><strong>    Inode size: 256</strong><br/><strong>    Journal blocks: 2200</strong><br/><strong>    Label: </strong><br/><strong>    Blocks: 140800</strong><br/><strong>    Block groups: 5</strong><br/><strong>    Reserved block group size: 39</strong><br/><strong>Created filesystem with 1277/35200 inodes and 82235/140800 blocks</strong><br/><strong>+ '[' 0 -ne 0 ']'</strong><br/><strong>Install system fs image: out/target/product/generic_x86/system.img</strong><br/><strong>out/target/product/generic_x86/system.img+ maxsize=588791808 blocksize=2112   <br/>    total=576716800 reserve=5947392</strong>
</pre>
<p>The entire build time is dependent on your hardware configuration. Even on a high-end CORE i7 Intel processor, it may take about 40 minutes. The option <kbd>-j4</kbd> starts the parallel build using four processor cores. You can choose the number according to your computer hardware.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Testing AOSP images</h1>
            </header>

            <article>
                
<p>After the build is completed, we find all images in the output folder, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="318" width="496" class=" image-border" src="assets/image_02_005.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Build output of generic_x86</div>
<p>The AOSP build output is stored under the <kbd>$AOSP/out</kbd> folder. This folder includes the build results for both target and host. The build results for different devices are stored separately at <kbd>$AOSP/out/target/product/{device name}</kbd>. In our case, it is <kbd>$AOSP/out/target/product/generic_x86</kbd>.</p>
<p>The images <kbd>system.img</kbd>, <kbd>userdata.img</kbd>, and <kbd>ramdisk.img</kbd> are necessary to run the emulator, but as you can see there is no kernel image. We will discuss kernel builds later in this book. For now, we will use the kernel image from Android SDK to test our AOSP build.</p>
<p>To test using our AOSP images, we can create a script as follows:</p>
<pre>
#!/bin/sh <br/><br/>emulator @a25x86 -verbose -show-kernel -system $OUT/system.img -ramdisk $OUT/ramdisk.img -initdata $OUT/userdata.img 
</pre>
<p>We can put this script <kbd>test_aosp.sh</kbd> in the <kbd>$HOME/bin</kbd> folder. Usually, we can add <kbd>$HOME/bin</kbd> to the executable search <kbd>path</kbd> variable so that we can run this script <kbd>test_aosp.sh</kbd> from the command line as follows:</p>
<pre>
<strong>$ test_aosp.sh</strong>  
</pre>
<div class="packt_infobox">If you test your AOSP build using Android 6 or earlier, you need to use classic engines instead of ranchu. The ranchu build has a problem in the Android 6 AOSP build, but this issue has been fixed in the Android 7 build. To support ranchu in the 6.0.1 AOSP build, we have to change the manifest to include the latest emulator device. The Android SDK release doesn't have this issue. Google fixed this issue internally, but didn't publish the fixes until Android 7.</div>
<p>After the emulator starts, we can check the version information as we did before. In the following screenshot, we can see the version information in AOSP images:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="387" width="223" class=" image-border" src="assets/image_02_006.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Android version of AOSP image</div>
<p>As we can see, kernel version 3.10.0 is used; this is because we use the ranchu emulator. Let's compare the information with SDK images that we tested before. From the following table, we can see that the model number is <span class="packt_screen">AOSP on IA Emulator</span> instead of <span class="packt_screen">sdk</span>. The Android version is 7.1 for SDK and 7.1.1 for AOSP. The AOSP image build number is the build target <kbd>aosp_x86-eng</kbd>, which we chose previously, and this also includes the date and time of the build.</p>
<p><strong>SDK and AOSP versions</strong>:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td/>
<td>
<p><strong>SDK (goldfish)</strong></p>
</td>
<td>
<p><strong>SDK (ranchu)</strong></p>
</td>
<td>
<p><strong>AOSP</strong></p>
</td>
</tr>
<tr>
<td>
<p><span class="BOLD"><span class="packt_screen">Model</span></span>  </p>
</td>
<td>
<p><span class="packt_screen">sdk</span></p>
</td>
<td>
<p><span class="packt_screen">sdk</span></p>
</td>
<td>
<p><span class="packt_screen">AOSP on IA Emulator</span></p>
</td>
</tr>
<tr>
<td>
<p><span class="BOLD"><span class="packt_screen">Android version</span></span></p>
</td>
<td>
<p><span class="packt_screen">7.1</span></p>
</td>
<td>
<p><span class="packt_screen">7.1</span></p>
</td>
<td>
<p><span class="packt_screen">7.1.1</span></p>
</td>
</tr>
<tr>
<td>
<p><span class="BOLD"><span class="packt_screen">Kernel version</span></span></p>
</td>
<td>
<p><span class="packt_screen">3.4.67</span></p>
</td>
<td>
<p><span class="packt_screen">3.10.0</span></p>
</td>
<td>
<p><span class="packt_screen">3.10.0</span></p>
</td>
</tr>
<tr>
<td>
<p><span class="BOLD"><span class="packt_screen">Build number</span></span></p>
</td>
<td>
<p><span class="packt_screen">sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys</span></p>
</td>
<td>
<p><span class="packt_screen">sdk_google_phone_x86-userdebug 7.1 NPF26K 3479480 test-keys</span></p>
</td>
<td>
<p><span class="packt_screen">aosp_x86-eng 7.1.1 NMF26O eng.sgye 20170126.183237 test-keys</span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating your own repository mirror</h1>
            </header>

            <article>
                
<p>It usually takes a very long time to download the AOSP source code. After you have downloaded the AOSP source code, you have actually downloaded a specific version of the AOSP source code from the remote repository. You may have to test different configurations or versions in your development work. It is a very time-consuming task to switch to a different version or create a new copy of the AOSP source code.</p>
<p>In this book, we will use the AOSP source code as the base for our development. To reuse some of the existing open source projects that are not included in AOSP, we have to modify the repo manifest from time to time. This involves changing the repo configuration. To work more efficiently, we can use a local mirror. It can save a lot of time to create a local mirror instead of downloading source code from remote repositories for all configuration changes. It may take hours to change a configuration from a remote repository, but it will need just a few minutes with the local repository.</p>
<p>When we work with open source projects, the server to host the project may change from time to time. It is always good to have your own mirror so that we won't rely too much on the remote repositories. With a local mirror, we can still work without too much impact even though the remote server may be not available for a certain period. This is exactly the issue that I face when I try to integrate Android-x86 projects in the later part of this book.</p>
<p>I will explain how to create a mixed local mirror of AOSP, Android-x86, and GitHub in this section.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Repo and manifest</h1>
            </header>

            <article>
                
<p>To create and manage repository mirrors, we need to understand the <kbd>repo</kbd> command and the directory structure managed by <kbd>repo</kbd> a little more. The <kbd>repo</kbd> command deals with a XML file manifest and it stores everything in a folder called <kbd>.repo</kbd>.</p>
<p>After we run the <kbd>repo init</kbd> command as we did in the previous section, a <kbd>.repo</kbd> folder is created under the current folder. If we take a look at the <kbd>.repo</kbd> folder, we can see the following contents:</p>
<pre>
<strong>$ ls -F .repo</strong><br/><strong>manifests/  manifests.git/  manifest.xml@  repo/</strong>  
</pre>
<p>Three folders and a symbolic link are created. The following is an explanation of each:</p>
<ul>
<li><kbd>manifests</kbd>: This is a working copy of the Git repository of the manifest itself.</li>
<li><kbd>manifests.git</kbd>: This is the Git repository of the manifest. The manifest itself is under the version control using Git.</li>
<li><kbd>manifest.xml</kbd>: This is a symbolic link to the file <kbd>.repo/manifests/default.xml</kbd>. This file is the main configuration file used by <kbd>repo</kbd>. We will look into the details later.</li>
<li><kbd>repo</kbd>: The repo tool itself is written in the Python language. Python scripts are stored in this folder.</li>
</ul>
<p>After we run the <kbd>repo init</kbd> command to initialize the repo data structure, we can run the <kbd>repo sync</kbd> command to retrieve a working copy. If we look at the <kbd>.repo</kbd> folder again after the <kbd>repo sync</kbd> command, we can see that there are two project related folders created:</p>
<pre>
<strong>$ ls -F .repo</strong><br/><strong>manifests/      manifest.xml@  project-objects/  repo/</strong><br/><strong>manifests.git/  project.list   projects/</strong>  
</pre>
<p>The following is an explanation of the newly created file and folders:</p>
<ul>
<li><kbd>project.list</kbd>: This is a list of all projects downloaded.</li>
<li><kbd>project-objects</kbd>: This is a copy of the remote repository.</li>
<li><kbd>projects</kbd>: This is the repository hierarchy matching the working copy. The path may be rearranged after a repository is copied to local. The contents in this folder are symbolic links to the items in <kbd>project-objects</kbd>.</li>
</ul>
<p>The most important file in the <kbd>.repo</kbd> folder is <kbd>.repo/manifests/default.xml</kbd> or its symbolic link <kbd>manifest.xml</kbd>. The detailed specification of this file can be found in the document under the <kbd>.repo</kbd> folder at <kbd>.repo/repo/docs/manifest-format.txt</kbd>. We won't go into any details, but let's take look at the most commonly used elements. </p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="aosp" <br/>           fetch=".." /&gt; <br/>  &lt;default revision="refs/tags/android-7.1.1_r4" <br/>           remote="aosp" <br/>           sync-j="4" /&gt; <br/><br/>  &lt;project path="build" name="platform/build" groups="pdk" &gt; <br/>    &lt;copyfile src="core/root.mk" dest="Makefile" /&gt; <br/>  &lt;/project&gt; <br/>  &lt;project path="abi/cpp" name="platform/abi/cpp" groups="pdk" /&gt; <br/>  &lt;project path="art" name="platform/art" groups="pdk" /&gt; <br/>  &lt;project path="bionic" name="platform/bionic" groups="pdk" /&gt; <br/>... <br/>&lt;/manifest&gt; 
</pre>
<p>In the preceding code snippet, we can see that there are three XML elements inside manifest:</p>
<ul>
<li><kbd>remote</kbd>: The <kbd>remote</kbd> element provides the details about remote repository. We can give it a name such as <kbd>aosp</kbd>. The URL of the remote repository can be specified in the <kbd>fetch</kbd> field. It can be a relative path or a full path.</li>
<li><kbd>default</kbd>: There are multiple <kbd>remote</kbd> elements that can be specified in manifest. The <kbd>default</kbd> element defines which <kbd>remote</kbd> is the default one.</li>
<li><kbd>project</kbd>: Each <kbd>project</kbd> element defines a Git repository. The <kbd>path</kbd> field supplies the local path after it is downloaded. The <kbd>name</kbd> field supplies the remote path of the Git repository. The <kbd>revision</kbd> field supplies the branch that we want to get and the <kbd>remote</kbd> field tells us which remote server we use to get the Git repository.</li>
</ul>
<p>There are other XML elements that can be used in manifest as well. You can find out what they are by looking at the preceding specification yourself.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using a local mirror for AOSP</h1>
            </header>

            <article>
                
<p>If you refer to the article from the Google website about downloading the source, you can find a section called <em><span class="ChapterrefPACKT">Using a local mirror</span></em>. It reveals that if you need two different configurations of the AOSP build environment, the download for two clients is larger than the size of a full mirror of the repository. It is very simple to set up a mirror as follows:</p>
<pre>
<strong>$ mkdir -p /usr/local/mirror/aosp</strong><br/><strong>$ cd /usr/local/mirror/aosp</strong><br/><strong>$ repo init -u https://android.googlesource.com/mirror/manifest --mirror</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>From the preceding commands, we can see that we actually use a different manifest to create a mirror. If we look at the content of the manifest for a mirror, we can see the following XML code:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/>  &lt;remote  name="aosp" <br/>           fetch=".." /&gt; <br/>  &lt;default revision="master" <br/>           remote="aosp" <br/>           sync-j="4" /&gt; <br/>  &lt;project name="accessories/manifest" /&gt; <br/>  &lt;project name="brillo/manifest" /&gt; <br/>... <br/>&lt;/manifest&gt; 
</pre>
<p>We can see that for all projects, there are only the project names without other information in each project item. This is because we actually copy each Git repository to the local as a bare Git repository. We won't check out a working copy, so we don't need to worry about the version.</p>
<p>If we look at the manifest to check out a working copy, we will see the following:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="aosp" <br/>           fetch=".." /&gt; <br/>  &lt;default revision="refs/tags/android-6.0.1_r61" <br/>           remote="aosp" <br/>           sync-j="4" /&gt; <br/><br/>  &lt;project path="build" name="platform/build" groups="pdk" &gt; <br/>    &lt;copyfile src="core/root.mk" dest="Makefile" /&gt; <br/>  &lt;/project&gt; <br/>  &lt;project path="abi/cpp" name="platform/abi/cpp" groups="pdk" /&gt; <br/>  &lt;project path="art" name="platform/art" groups="pdk" /&gt; <br/>... <br/>&lt;/manifest&gt; 
</pre>
<p>It includes more items than the one to create a mirror. The <kbd>name</kbd> field specifies the path at the remote repository and the <kbd>path</kbd> field specifies the local path after the repository is downloaded to the local. We also need to specify <kbd>revision</kbd> that we want to retrieve.</p>
<p>After we have a mirror, we can check out a copy of the AOSP source from that mirror as follows:</p>
<pre>
<strong>$ mkdir -p $HOME/aosp/master</strong><br/><strong>$ cd $HOME/aosp/master</strong><br/><strong>$ repo init -u /usr/local/mirror/aosp/platform/manifest.git</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>If you need, you can check out multiple copies from the local mirror. No matter if you check out multiple copies or you change to a different version, you can save a lot of time compared to checking out from a remote repository.</p>
<p>When you work on a system-level project, you may need projects out of the AOSP source. For example, in this book, we use multiple projects from CyanogenMod, Android-x86, and my own projects in GitHub. In this case, we can actually create our own manifest to mix all projects that we need together from our local mirror. Our local mirror will become a superset of the public mirror. We can create branches and tags from time to time in local repositories, but we only push the baselines that we want to release to the public repositories. This is exactly what the Google development team does in their private repositories.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating your own mirror of GitHub</h1>
            </header>

            <article>
                
<p>All source code used in this book is stored in GitHub. We also use source from other projects in GitHub, because many open source projects are hosted on GitHub, such as CyanogenMod, OmniROM, Team Win Recovery, and so on. We can create a mirror for all projects that we have used in local storage so that we can commit any changes and create our own baselines. If you want to make changes to any projects that are not owned by yourself, you can create your own copy using the <span class="packt_screen">Fork</span> function of GitHub.</p>
<p>To create your own manifest for GitHub, you can create a repository in GitHub, call it <kbd>mirror</kbd>, and then add an XML file called <kbd>default.xml</kbd> to it as follows:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="cm" <br/>           fetch="git://github.com/CyanogenMod" <br/>           review="review.cyanogenmod.org" <br/>           revision="refs/heads/cm-13.0" /&gt; <br/><br/>  &lt;remote  name="twrp" <br/>           fetch="git://github.com/TeamWin" <br/>           revision="master" /&gt; <br/><br/>  &lt;remote  name="omnirom" <br/>           fetch="https://github.com/omnirom" /&gt; <br/><br/>  &lt;remote  name="github" <br/>           fetch=".." /&gt; <br/>  &lt;default revision="master" <br/>           remote="github" <br/>           sync-j="4" /&gt; <br/><br/>  &lt;!-- configuration of github repositories v1.0 --&gt; <br/>  &lt;project name="manifests" /&gt; <br/>  &lt;project name="manifest" /&gt; <br/>  &lt;project name="mirror" /&gt; <br/>  &lt;project name="local_manifests" /&gt; <br/>... <br/>  &lt;!-- CyanogenMod --&gt; <br/>  &lt;project name="android_bootable_recovery" remote="cm" /&gt; <br/>  &lt;project name="android_external_busybox" remote="cm" /&gt; <br/>  &lt;project name="android" remote="cm" /&gt; <br/><br/>  &lt;!-- Team Win Recovery Project --&gt; <br/>  &lt;project name="Team-Win-Recovery-Project" remote="twrp" /&gt; <br/>  &lt;project name="android_device_emulator_twrp" remote="twrp" /&gt; <br/>  &lt;project name="android_device_emulator_twrpx86" remote="twrp" /&gt; <br/>  &lt;project name="android_device_emulator_twrpx8664" remote="twrp" /&gt; <br/><br/>  &lt;!-- omnirom --&gt; <br/>  &lt;project path="external/lz4" name="android_external_lz4" remote="omnirom" <br/>  revision="android-6.0" groups="pdk-cw-fs,pdk-fs" /&gt; <br/><br/>  &lt;!-- from original Android repositories --&gt; <br/>... <br/>&lt;/manifest&gt; 
</pre>
<p>From the preceding <kbd>default.xml</kbd>, we can see that we actually fetch multiple projects from CyanogenMod, TWRP, OmniROM, and our own GitHub repositories using a single XML file. We put all of them together to form our own GitHub local mirror.</p>
<p>To create the local mirror, we can use the following commands:</p>
<pre>
<strong>$ mkdir -p /media/aosp-mirror/github</strong><br/><strong>$ cd /media/aosp-mirror/github</strong><br/><strong>$ repo init -u https://github.com/shugaoye/mirror.git --mirror</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>After we have created the local mirror, we can check what we have downloaded via the following screen:</p>
<div class="CDPAlignCenter CDPAlign"><img height="280" width="425" class=" image-border" src="assets/image_02_007.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Content of the local mirror</div>
<p>From the preceding screenshot, we can see that all Git repositories that we specified in <kbd>default.xml</kbd> are copied to our local storage. The manifest file for the local mirror that I use in this book can be found at<span class="URLPACKT"> <a href="https://github.com/shugaoye/mirror">https://github.com/shugaoye/mirror</a>.</span></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Fetching Git repositories outside GitHub</h1>
            </header>

            <article>
                
<p>As we can see from the preceding example, we created our manifest repository for the GitHub mirror. After that, we use it to initialize our mirror repo. Then we use the <kbd>repo sync</kbd> command to fetch all Git repositories from GitHub to our local mirror.</p>
<p>How about repositories that we don't have write access to? In this book, we use a lot of projects from Android-x86. However, we don't have write permission to Android-x86 repositories. The Android-x86 project also doesn't have a mirror manifest available for use.</p>
<p>We can actually create a mirror manifest file from the original Android-x86 manifest. We can refer to the document at the following link for how to get Android-x86 source code:</p>
<p><a href="http://www.android-x86.org/getsourcecode"><span class="URLPACKT">http://www.android-x86.org/getsourcecode</span></a></p>
<p>The previous document mentioned that we can use the following command to initialize and sync repo from the Android-x86 repository:</p>
<pre>
<strong>$ mkdir android-x86</strong><br/><strong>$ cd android-x86</strong><br/><strong>$ repo init -u git://git.osdn.net/gitroot/android-x86/manifest -b $branch</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>We can clone the preceding Android-x86 manifest repository to a folder and analyze it:</p>
<pre>
<strong>$ git clone git://git.osdn.net/gitroot/android-x86/manifest -b marshmallow-x86</strong><br/><strong>$ ls</strong><br/><strong>cm.xml  default.xml</strong>  
</pre>
<p>After we clone it, we can find the preceding two files. <kbd>default.xml</kbd> is used to initialize the Android-x86 repo and <kbd>cm.xml</kbd> is used to initialize Android-x86 for the CyanogenMod build.</p>
<p>If we look at the content of <kbd>default.xml</kbd>, we can see the following code snippet:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="aosp" <br/>           fetch="https://android.googlesource.com/" /&gt; <br/>  &lt;remote  name="x86" <br/>           fetch="." /&gt; <br/>  &lt;default revision="refs/tags/android-6.0.1_r61" <br/>           remote="aosp" <br/>           sync-c="true" <br/>           sync-j="4" /&gt; <br/><br/>  &lt;!-- from x86 port repositories --&gt; <br/>  &lt;project path="build" name="platform/build" groups="pdk" remote="x86" <br/>  revision="marshmallow-x86" &gt; <br/>    &lt;copyfile src="core/root.mk" dest="Makefile" /&gt; <br/>  &lt;/project&gt; <br/>  &lt;project path="kernel" name="kernel/common" remote="x86" <br/>  revision="kernel-4.4" /&gt; <br/>  &lt;project path="art" name="platform/art" groups="pdk" remote="x86" <br/>  revision="marshmallow-x86" /&gt; <br/>... <br/>  &lt;!-- from original Android repositories --&gt; <br/>  &lt;project path="abi/cpp" name="platform/abi/cpp" groups="pdk" /&gt; <br/>  &lt;project path="bootable/recovery" name="platform/bootable/recovery" <br/>  groups="pdk" /&gt; <br/>... <br/>&lt;/manifest&gt; 
</pre>
<p>We can see that the Android-x86 manifest includes two parts. The first part is Android-x86, its own repositories, and the rest are the original AOSP repositories.</p>
<p>We can retrieve the first part and compose a mirror manifest for Android-x86. Where should we put this file? We can put it in a branch of the same mirror manifest repository in our GitHub.</p>
<p>In the working copy of our GitHub mirror repository, we can create a branch called <kbd>android-x86</kbd>. We can replace <kbd>default.xml</kbd> in our GitHub mirror with the first part in Android-x86 manifest and we get the one in the following listing:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="github" <br/>           fetch=".." /&gt; <br/><br/>  &lt;remote  name="x86" <br/>           fetch=" git://git.osdn.net/gitroot/android-x86/" /&gt; <br/><br/>  &lt;default revision="android-x86" <br/>           remote="github" <br/>           sync-j="4" /&gt; <br/><br/>  &lt;!-- from x86 port repositories --&gt; <br/>  &lt;project name="manifest" remote="x86" /&gt; <br/>  &lt;project name="platform/build" remote="x86" /&gt; <br/>  &lt;project name="kernel/common" remote="x86" /&gt; <br/>  &lt;project name="platform/art" remote="x86" /&gt; <br/>... <br/>  &lt;project name="platform/system/extras" remote="x86" /&gt; <br/>  &lt;project name="platform/system/vold" remote="x86" /&gt; <br/><br/>&lt;/manifest&gt; 
</pre>
<p>As we can see from the preceding listing, we removed unnecessary fields such as <kbd>path</kbd> or <kbd>groups</kbd>, and so on. With this manifest for the Android-x86 mirror, we can create a local mirror for Android-x86 now as follows:</p>
<pre>
<strong>$ mkdir -p /media/aosp-mirror/android-x86</strong><br/><strong>$ cd /media/aosp-mirror/android-x86</strong><br/><strong>$ repo init -u https://github.com/shugaoye/mirror.git -b android_x86 --mirror</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>After we download all Git repositories, we can see the content as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="331" width="517" class=" image-border" src="assets/image_02_008.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Local mirror of android-x86</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating your own manifest for client download</h1>
            </header>

            <article>
                
<p>With all local mirrors, we can create our own manifest to check out our source code now. We can put it in our GitHub in a new repository called <kbd>manifests</kbd>. In this repository, we can create an XML file, <kbd>default.xml</kbd>, as follows:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="github" <br/>           fetch="." /&gt; <br/><br/>  &lt;remote  name="aosp" <br/>           fetch="../android" /&gt; <br/><br/>  &lt;remote  name="x86" <br/>           fetch="../android-x86" /&gt; <br/><br/>  &lt;default revision="refs/tags/android-7.1.1_r4" <br/>           remote="aosp" <br/>           sync-c="true" <br/>           sync-j="4" /&gt; <br/><br/>  &lt;!-- android-x86 --&gt; <br/>  &lt;project path="bootable/newinstaller"  <br/>  name="platform/bootable/newinstaller" <br/>  remote="x86" revision="nougat-x86" /&gt; <br/>... <br/>  &lt;!-- GitHub --&gt; <br/>  &lt;project path="external/busybox" name="android_external_busybox" <br/>  remote="github" revision="cm-14.0" /&gt; <br/>... <br/>  &lt;!-- TWRP, use the below repositories for TWRP build --&gt; <br/>  &lt;project path="bootable/recovery" name="Team-Win-Recovery-Project" <br/>  remote="github" groups="pdk"  revision="android-7.0" /&gt; <br/>... <br/>  &lt;!-- AOSP --&gt; <br/>  &lt;project path="build" name="platform/build" groups="pdk" &gt; <br/>    &lt;copyfile src="core/root.mk" dest="Makefile" /&gt; <br/>  &lt;/project&gt; <br/>  &lt;project path="abi/cpp" name="platform/abi/cpp" groups="pdk" /&gt; <br/>... <br/>  &lt;project path="tools/swt" name="platform/tools/swt"  <br/>  groups="notdefault,tools" /&gt; <br/>  &lt;project path="tools/tradefederation" <br/>  name="platform/tools/tradefederation" <br/>  groups="notdefault,tradefed" /&gt; <br/><br/>&lt;/manifest&gt; 
</pre>
<p>In the preceding listing, this is a manifest modified based on the AOSP release <kbd>android-7.1.1_r4</kbd> manifest. In this file, we combined multiple projects from AOSP, Android-x86, TWRP, and our own GitHub projects into one. Usually, we have to do this using <kbd>local_manifests</kbd> to fetch all non-AOSP projects into our local copy. This approach usually takes a very long time and it is difficult to create baselines for our own configurations.</p>
<div class="packt_infobox">The <kbd>local_manifests</kbd> file can be used to overwrite the configuration of the manifest file temporarily. You can refer to <span class="ChapterrefPACKT"><em>Appendix B</em> of <em>Embedded Programming with Android</em></span> to find out more details.</div>
<p>With a local mirror and our own manifest, we can find a clean way to do this. When you have one copy for AOSP and one copy for Android-x86, you have a lot of duplicated projects in your storage because Android-x86 manifests include many original projects from AOSP. With the preceding setup, there are no duplicated projects in your local mirror.</p>
<p>To check out a working copy, we can use the following commands:</p>
<pre>
<strong>$ mkdir -p $HOME/aosp/android</strong><br/><strong>$ cd $HOME/aosp/android</strong><br/><strong>$ repo init -u /usr/local/mirror/github/manifests.git</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>If we want to check out a build of Android-x86, it becomes a different configuration instead of a totally different repository now:</p>
<pre>
<strong>$ cd $HOME/aosp/android</strong><br/><strong>$ repo init -u /usr/local/mirror/github/manifests.git -b nougat-x86</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>Since we have our own local mirror, we can use the <kbd>sync-c="true"</kbd> option in the manifest, as we can see in the previous listing. With this option, the <kbd>repo</kbd> command will only check out the version we need in our working copy instead of creating the Git repositories with all revisions. This can save a lot of space for the working copy. However, this is not recommended without a local mirror, because it will take even longer when you switch to a different version.</p>
<p>You can find the manifest to check out a working copy at my GitHub<span class="URLPACKT"> <a href="https://github.com/shugaoye/manifests">https://github.com/shugaoye/manifests</a>.</span></p>
<p>We will use this to manage all different build configurations in this book.</p>
<div class="packt_infobox">I introduced two kinds of manifest files here:<br/>
<ul>
<li>To create a local mirror, you can refer to the manifest file at <span class="URLPACKT"><a href="https://github.com/shugaoye/mirror">https://github.com/shugaoye/mirror</a></span></li>
<li>To check out a working copy, you can refer to the manifest file at <span class="URLPACKT"><a href="https://github.com/shugaoye/manifests">https://github.com/shugaoye/manifests</a></span></li>
</ul>
</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we set up the environment for SDK and AOSP. We built the Android emulator images for AOSP. We also tested and compared the Android images in Android SDK and AOSP. All these steps are necessary before we continue exploring how to create our own Android system later. We also spent some time discussing how to set up our own repo mirror. This tip can help us later, when we start to create projects from multiple open source projects. In the next chapter, we will start to explore the architecture of Android. We will look into the details of layers related to the porting and customization of the Android system.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>