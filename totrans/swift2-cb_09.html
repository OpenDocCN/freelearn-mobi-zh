<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Dealing with Other Languages</h1></div></div></div><p class="calibre7">In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem">Using my old address book</li><li class="listitem">Compressing a message</li><li class="listitem">Using assembly code with Swift</li><li class="listitem">Sharing C++ code with Swift</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec71" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">Swift is a new language in a world of libraries that are already done. Sometimes you need the help of other languages otherwise you might need to spend a lot of time creating the functionalities that you want.</p><p class="calibre7">As you might know, since the 70s, C has been the default language regardless of the platform you want to develop on. There are thousands or maybe millions of libraries written in C, and you can find a lot of them that are open source, which makes it easier to port them to your iOS or Mac OS project.</p><p class="calibre7">In this chapter, we are going to learn how to use external languages on a Swift project. Here, we are going to see how to use C, C++, and even assembly code.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec72" class="calibre1"/>Using my old address book</h1></div></div></div><p class="calibre7">In this recipe, we are <a id="id402" class="calibre1"/>going to learn how to use a C code inside a Swift project. In this case, let's imagine that we want to recycle one linked list of an address book written in C, that way you can read the contacts from the device address book and store them in a file. The advantage of storing structures on a file is that you can open the same file using other platforms that don't have Swift, such as Linux or Windows.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec222" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new project called <code class="email">Chapter 9 Address Book</code>; make sure that this project is a Swift project.</p><p class="calibre7">We are going to check that a new file will be created inside an application subfolder. As you know, we can't see any device application folder without using a third-party application. In this case we will download an application that can explore your device files called <strong class="calibre8">iFunBox</strong>. This app can be freely downloaded from <a class="calibre1" href="http://www.i-funbox.com/">http://www.i-funbox.com/</a> but if you <a id="id403" class="calibre1"/>prefer there are other free apps and commercial apps such as <a id="id404" class="calibre1"/>iBrowser and iPad Folder.</p><div><h3 class="title2"><a id="tip46" class="calibre1"/>Tip</h3><p class="calibre7">Downloading the iFunBox is necessary only if you are going to use a physical device, if you are going to use only the simulator you can use a traditional <strong class="calibre8">Finder</strong> window.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec223" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">The first step we need to take is to add a new file; in this case you should select a C file:<div><img src="img/00118.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Then it will ask for the filename; let's call it <code class="email">AddressBook.c</code> and make sure that the option <a id="id405" class="calibre1"/><strong class="calibre8">Also create a header file</strong> is checked:<div><img src="img/00119.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Select the same folder where the project source codes are stored for storing this new file. After that you will see that it will ask you about creating an Objective-C bridge file; click on <strong class="calibre8">Yes</strong>:<div><img src="img/00120.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Now you can see that there are three new files: <code class="email">AddressBook.c</code>, <code class="email">AddressBook.h</code>, and <code class="email">Chapter 9 Address Book-Bridging-Header.h</code>:<div><img src="img/00121.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">Before coding, start by clicking on the bridge file and import the <code class="email">AddressBook.h</code> file:<div><pre class="programlisting">#import "AddressBook.h"</pre></div></li><li class="listitem" value="6">Now go to <a id="id406" class="calibre1"/><code class="email">AddressBook.h</code>. The first action we need to take here is to remove the <code class="email">stdio.h</code> include. After that you have to add the structs that are going to be used on our application:<div><pre class="programlisting">struct Contact {
    char name[60];
    char phone[20];
    struct date {
        int day;
        int month;
        int year;
    } birthday;
};

struct ContactList {
    struct Contact contact;
    struct ContactList * next;
};</pre></div></li><li class="listitem" value="7">Once the structures and other types are defined, we are going to add the function headers of the operations that can be done with our contact list: create a new contact, initialize the list, destroy the list, add a new contact, and save the contacts list into a file:<div><pre class="programlisting">struct Contact createContact();
void initializeContactList(struct ContactList ** );
void insertContact(struct ContactList **, struct Contact);
void saveContactList(struct ContactList *, const char *);
void destroyContactList(struct ContactList **);</pre></div></li><li class="listitem" value="8">The header file is done. If you wish to complete it with more operations such as finding a contact on the list or deleting a contact, feel free to do so. Now let's go to the implementation file (<code class="email">AddressBook.c</code>) and let's code the operations. Don't worry if you <a id="id407" class="calibre1"/>don't understand this code; usually when you are using C code in Swift you only need to understand what the operation does by reading its header:<div><pre class="programlisting">struct Contact createContact(){
    struct Contact newContact;
    strcpy(newContact.name, "");
    strcpy(newContact.phone, "");
    newContact.birthday.day = 0;
    newContact.birthday.month = 0;
    newContact.birthday.year = 0;
    return newContact;
}

void initializeContactList(struct ContactList ** contactList ){
    *contactList = NULL;
}

void insertContact(struct ContactList ** contactList, struct Contact contact){
    struct ContactList * newContactList = malloc(sizeof(struct ContactList));
    newContactList-&gt;next = *contactList;
    newContactList-&gt;contact = contact;
    *contactList = newContactList;
}

void saveContactList(struct ContactList * contactList, const char * filename){
    FILE * file = fopen(filename, "wb");
    if (file) {
        while (contactList) {
            fwrite(&amp;contactList-&gt;contact, sizeof(struct Contact), 1, file);
            contactList = contactList-&gt;next;
        }
        fclose(file);
    }
}

void destroyContactList(struct ContactList ** contactList){
    struct ContactList * aux;
    while ((aux = *contactList)) {
        *contactList = (*contactList)-&gt;next;
        free(aux);
    }
}</pre></div></li><li class="listitem" value="9">The C part is done, now you can return to the way we used to create our apps by clicking on the <a id="id408" class="calibre1"/>storyboard and adding two buttons; one for loading the contacts and another one for saving the contacts into a file. Link the first button with a function called <code class="email">fillContacts</code> and the other one with a function called <code class="email">saveContacts</code>. Don't implement anything yet, we are going to return to these functions soon.</li><li class="listitem" value="10">As we need to read the contacts from the device address book, we need to add it into our project, so click on the project in the project navigator, then make sure that the <strong class="calibre8">General Info</strong> tab of the target <code class="email">Chapter 9 AddressBook</code> is selected. Here, you have to scroll down to the <strong class="calibre8">Linked Frameworks and Libraries</strong> and add the framework <strong class="calibre8">AddressBook</strong>:<div><img src="img/00122.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="11">Return to the view controller, scroll up to the beginning, and import the address book:<div><pre class="programlisting">import AddressBook</pre></div></li><li class="listitem" value="12">Inside the view controller class, we are going to start with the attributes, in this case we only need a list as a pointer of <code class="email">ContactList</code>:<div><pre class="programlisting">var list:UnsafeMutablePointer&lt;ContactList&gt; = nil</pre></div></li><li class="listitem" value="13">Even if we have initialized the list assigning a nil value, we still need to initialize it using the C-specific function and we can do this on the <code class="email">viewDidLoad</code> method:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        <strong class="calibre8">initializeContactList(&amp;list)</strong>
    }</pre></div></li><li class="listitem" value="14">As you might have noticed, there is also a function that destroys the list, meaning that we need to call it on the deinitializer:<div><pre class="programlisting">    deinit{
        destroyContactList(&amp;list)
    }</pre></div></li><li class="listitem" value="15">Now we can <a id="id409" class="calibre1"/>implement the button events, let's start with the button that loads the contacts from the device address book:<div><pre class="programlisting">    @IBAction func fillContacts(sender: UIButton) {
        let status = ABAddressBookGetAuthorizationStatus()
        
        switch status {
        case .Authorized:
            // When the user has already authorized previously.
            self.readContacts()
        case .NotDetermined:
            // this case happens when it is the first time the user opens the app, so we have to request his permission
            var ok = false
            ABAddressBookRequestAccessWithCompletion(nil) {
                (granted:Bool, err:CFError!) in
                if granted {
                    self.readContacts()
                }
            }
        case .Restricted:
            fallthrough
        case .Denied:
            // These cases are when for any reason the app can't access the contacts
            UIAlertView(title: "Not authorized", message: "This app isn't authorized for reading your contacts", delegate: nil, cancelButtonTitle: "OK").show()
        }
    }</pre></div><div><h3 class="title2"><a id="note35" class="calibre1"/>Note</h3><p class="calibre7">Remember that in iOS and also in OS X, you can't read the address book without the user's permission.</p></div></li><li class="listitem" value="16">As you can see, there are two calls for the method <code class="email">readContacts</code>, so that's the <a id="id410" class="calibre1"/>method we need to implement now:<div><pre class="programlisting">    private func readContacts(){
        var err : Unmanaged&lt;CFError&gt;? = nil
        var myAddressBook: ABAddressBook = ABAddressBookCreateWithOptions(nil, &amp;err).takeRetainedValue()
        let myContacts = ABAddressBookCopyArrayOfAllPeople(myAddressBook).takeRetainedValue() as NSArray as [ABRecord]
        
        for aContact in myContacts {
            var newContactRecord:Contact = createContact();

            // Retrieving name
            var nameString = ABRecordCopyCompositeName(aContact).takeRetainedValue() as String
            copyIntoCString(&amp;newContactRecord.name, swiftString:nameString)

            // Retrieving phone
            var phones:ABMultiValue = ABRecordCopyValue(aContact, kABPersonPhoneProperty).takeRetainedValue() as ABMultiValue
            if(ABMultiValueGetCount(phones) &gt; 0){
                var phoneString = ABMultiValueCopyValueAtIndex(phones, 0).takeRetainedValue() as String
                copyIntoCString(&amp;newContactRecord.phone, swiftString:phoneString)
            }
            // Retrieving birthday
            if let date = ABRecordCopyValue(aContact, kABPersonBirthdayProperty).takeRetainedValue() as? NSDate {
                var calendar = NSCalendar.currentCalendar().components([.Day, .Month, .Year], fromDate: date)
                newContactRecord.birthday.day = Int32(calendar.day)
                newContactRecord.birthday.month = Int32(calendar.month)
                newContactRecord.birthday.year = Int32(calendar.year)
            }
            insertContact(&amp;list, newContactRecord)
        }
        UIAlertView(title: nil, message: "The contacts were loaded", delegate: nil, cancelButtonTitle: "OK").show()
    }</pre></div></li><li class="listitem" value="17">Now let's implement the button that saves the contacts onto a file; this one is much easier because <a id="id411" class="calibre1"/>we just need to set the full path for the storing file and call the function that saves the contacts:<div><pre class="programlisting">    @IBAction func saveContacts(sender: UIButton) {
        let documentDir:NSString = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as NSString
        var filename:NSString = documentDir.stringByAppendingPathComponent("contacts.dat") as NSString
        saveContactList(list, filename.UTF8String)
        UIAlertView(title: "Contacts saved", message: "contacts.dat was saved.", delegate: nil, cancelButtonTitle: "Ok").show()
    }</pre></div></li><li class="listitem" value="18">The application looks finished but if you try compiling it you will get an error because there is a missing implementation: the function <code class="email">copyIntoCString</code>. It's an auxiliary function that we have to create. As you might need it in other projects, let's implement it on a new file. Create a new file called <code class="email">CstringUtils.swift</code> and add the following code:<div><pre class="programlisting">func copyIntoCString&lt;T&gt;(inout cstring: T, swiftString: String){
    withUnsafeMutablePointer(&amp;cstring, { (cstr) -&gt; Void in
        let fullSwinftString = swiftString + String(UnicodeScalar(0))
        let newCString = fullSwinftString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!
        newCString.getBytes(cstr, length: sizeofValue(cstring))
    })
}</pre></div></li><li class="listitem" value="19">Good, now the application is done, however you still need to test it. Press play, accept every permission when requested, and press the button that retrieves the contacts from the address book. When you receive a dialog that the contacts were loaded, you can press the save button. On screen the only result that you might have is just a dialog like this one:<div><img src="img/00123.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p><p class="calibre15">If you think that you didn't receive much visual information you are 100% right, because this app wasn't created to do something visual; rather it was created for generating a file.</p></li><li class="listitem" value="20">If you are using a <a id="id412" class="calibre1"/>physical device, open your iFunBox application, which was downloaded at the beginning of this recipe (please note, at the time of writing, iFunBox does not run with 8.3 or higher), expand the <strong class="calibre8">User Application</strong> section, and click on your app (<strong class="calibre8">Chapter 9 Address Book</strong>). On the right-hand side, double-click on the document folder and you should see a file called <code class="email">contacts.dat</code>:<div><img src="img/00124.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="21">You can copy this file if you want, and you can also do the opposite process by reading this file <a id="id413" class="calibre1"/>on another platform, but this task will be left as homework.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec224" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">Although Xcode asks you about creating an Objective-C bridge file, actually it creates a file that can also be a C bridge file. Once your C header files are imported here you can use them on Swift. As you might have noticed, C doesn't work with objects; the only thing you can do is create a struct (which doesn't have methods in C) and send it through some functions as arguments.</p><p class="calibre7">C types have their equivalent type in Swift by prefixing the C on its name, as in <code class="email">CChar</code>, <code class="email">CInt</code>, <code class="email">CFloat</code> and structs just keep their names without the word <code class="email">struct</code> as you can see on the <code class="email">ContactList</code> and <code class="email">Contact</code>.</p><p class="calibre7">Another feature that you have to consider is that C works with pointers. A pointer is an information reference like we had on the contact list. When you have pointers in C they are converted to <code class="email">UnsafeMutablePointer</code> in Swift, double pointers are converted to <code class="email">UnsafeMutablePointer</code> of <code class="email">UnsafeMutablePointer</code>, and so on; that's the C style of receiving function arguments by reference.</p><p class="calibre7">When you want to call a C function that requires an argument by reference, you have to use the <code class="email">&amp;</code> operator. It means that you are sending the memory address of that variable. However, the Swift way of declaring an argument by reference is different: you have to add the <code class="email">inout</code> attribute before the argument name.</p><p class="calibre7">Using some C types on Swift sometimes needs some tricks, for example, C doesn't have a type of strings; the most similar one is the array of characters, which sometimes is converted as <code class="email">[CChar]</code> and sometimes it is converted as a tuple of <code class="email">UInt8</code>. If you need to use a C variable without casting it by retrieving its memory address you have to use the function <a id="id414" class="calibre1"/>
<code class="email">withUnsafeMutablePointer</code>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec73" class="calibre1"/>Compressing a message</h1></div></div></div><p class="calibre7">Even if you work only on <a id="id415" class="calibre1"/>an internal project, you will probably have to use a library. Sometimes it is a Swift framework but sometimes it is a C library. Using C libraries is very common nowadays, mainly because there are a lot of them.</p><p class="calibre7">For this recipe we are going to use a library that can be very useful: BCL. This simple library can be easily compiled on Xcode and you can use it every time your project needs to compress any information.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec225" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Before we start coding this <a id="id416" class="calibre1"/>project, let's download the BCL library. It can be found at <a class="calibre1" href="http://bcl.comli.eu/">http://bcl.comli.eu/</a> and it's free to download the source code. Uncompress the downloaded file and leave its finder window opened.</p><p class="calibre7">If you are going to install this application onto a physical device you need to download the iFunBox as mentioned in the previous recipe.</p><p class="calibre7">For this recipe, instead of creating a project, start creating a workspace and call it <code class="email">Chapter 9 Compressing Workspace</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec226" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">First, you need to create a project, but in this case instead of creating a single view application, select <strong class="calibre8">Cocoa Touch Static Library</strong> from the <strong class="calibre8">Framework and Library</strong> section and press <strong class="calibre8">Next</strong>:<div><img src="img/00125.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p><div><h3 class="title2"><a id="note36" class="calibre1"/>Note</h3><p class="calibre7">Selecting <strong class="calibre8">Cocoa Touch Static Library</strong> implies developing it in C, C++, or Objective-C. Swift doesn't have a static library.</p></div></li><li class="listitem" value="2">Now call your <a id="id417" class="calibre1"/>project <code class="email">Chapter 9 BCL</code>. Notice that it is not asking whether it is a Swift project:<div><img src="img/00126.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">On the next screen you have to select the destination folder where the project is going to be stored, but before pressing the <strong class="calibre8">Create</strong> button, make sure that this project belongs to <a id="id418" class="calibre1"/>your workspace:<div><img src="img/00127.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Check that this project starts with two source code files: <code class="email">Chapter_9_BCL.h</code> and <code class="email">Chapter_9_BCL.m</code>. Delete them as they are not needed. While deleting, you can move them to trash instead of only removing the reference:<div><img src="img/00128.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">Now drag the files <a id="id419" class="calibre1"/>that end with <code class="email">.c</code> and <code class="email">.h</code> from the BCL library (located at the <code class="email">src</code> folder) into your source code group:<div><img src="img/00129.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p><div><h3 class="title2"><a id="note37" class="calibre1"/>Note</h3><p class="calibre7">Actually you don't need to copy the file <code class="email">bcltest.c</code> and <code class="email">bcl.c</code> because they belong to BCL as a program not as a library, but we are copying them to make life easier.</p></div></li><li class="listitem" value="6">Although you have the necessary files for building the library you still need to indicate the header files that should be used externally. This is a procedure you have to do every time you build a library written in C, C++, or Objective-C. To do it, select the <strong class="calibre8">Build Phases</strong> tab from the target <strong class="calibre8">Chapter 9 BCL</strong>; after that expand the section <strong class="calibre8">Copy Files</strong>:<div><img src="img/00130.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="7">Now press the plus sign, which is located on the bottom of this section; a new dialog will appear <a id="id420" class="calibre1"/>showing the files that can be exported. Select only the header files such as <code class="email">huffman.h</code>, <code class="email">shannonfano.h</code>, and <code class="email">rle.h</code>:<div><h3 class="title2"><a id="note38" class="calibre1"/>Note</h3><p class="calibre7">Remember that you can select more than one file by holding the command key and clicking over the files.</p></div><div><img src="img/00131.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="8">The library is done, you need to check whether everything is OK by pressing <em class="calibre9">command</em> + <em class="calibre9">b</em>; you should see a message that the build has succeeded.</li><li class="listitem" value="9">The next part of this recipe is creating an app that compresses a user message. To do it don't close your project and create a new project; this time, instead of a static library select <a id="id421" class="calibre1"/>a single view application done with Swift and call it <code class="email">Chapter 9 BCLApp</code>. Something that is very important is that you have to add this project to the workspace and group <code class="email">Chapter 9 Compressing Workspace</code>.</li><li class="listitem" value="10">Notice that now we have two projects. Make sure that the app is selected by clicking on it, then click on the target <code class="email">Chapter 9 BCLApp</code> and select the general info tab. Scroll down to the <strong class="calibre8">Linked Framework and Libraries</strong> section, expand it if necessary and press the plus sign.</li><li class="listitem" value="11">A dialog will appear but this time there will be a new group called <strong class="calibre8">Workspace</strong>; here you have to select <strong class="calibre8">libChapter 9 BCL.a</strong>:<div><h3 class="title2"><a id="note39" class="calibre1"/>Note</h3><p class="calibre7">The static libraries always have the prefix <code class="email">lib</code> and the extension <code class="email">.a</code> on their names.</p></div><div><img src="img/00132.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="12">Once you have added the library you will need to add a new header file to your project; let's call <a id="id422" class="calibre1"/>this file <code class="email">BridgeHeader.h</code>.</li><li class="listitem" value="13">Before we start coding this file, let's set this file as the bridge file for the app; hence you have to go to <strong class="calibre8">Build Settings</strong> of your app, write <strong class="calibre8">Bridging</strong> on the search box, and once you have found field <strong class="calibre8">Objective-C Bridging Header</strong>, write <code class="email">Chapter 9 BCLApp/BridgeHeader.h</code>:<div><img src="img/00133.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="14">Let's return to <code class="email">BridgeHead.h</code> and add a few include statements for using the compression library:<div><pre class="programlisting">#include &lt;Chapter 9 BCL/huffman.h&gt;
#include &lt;Chapter 9 BCL/lz.h&gt;
#include &lt;Chapter 9 BCL/rice.h&gt;
#include &lt;Chapter 9 BCL/rle.h&gt;
#include &lt;Chapter 9 BCL/shannonfano.h&gt;
#include &lt;Chapter 9 BCL/systimer.h&gt;</pre></div></li><li class="listitem" value="15">The application is <a id="id423" class="calibre1"/>now linked with the library, which means that from now on you can return to the Swift programming. Go to the storyboard and add a text view and two buttons. Usually the text views come with a text by default; if you want you can leave it so it will be handier when testing. Link the text view, naming it as <code class="email">textView</code>:<div><pre class="programlisting">    @IBOutlet weak var textView: UITextView!</pre></div></li><li class="listitem" value="16">After that you have to add the actions for the buttons. For the first button, change its label to Huffman and link with the following action:<div><pre class="programlisting">    @IBAction func huffman(sender: UIButton) {
        let text = self.textView.text
        let textIn:UnsafeMutablePointer&lt;UInt8&gt; = UnsafeMutablePointer&lt;UInt8&gt;((text as NSString).UTF8String)
        let textOut:UnsafeMutablePointer&lt;UInt8&gt; = UnsafeMutablePointer&lt;UInt8&gt;.alloc(countElements(text) * 101 / 100 + 320)
        let outsize = Huffman_Compress(textIn, textOut, UInt32( countElements(text)))
        save("huffman.dat", data: textOut, dataSize: Int(outsize))
    }</pre></div></li><li class="listitem" value="17">With the second button you can do the same; change its label to <code class="email">lz</code> and link it with this similar code:<div><pre class="programlisting">    @IBAction func lz(sender: UIButton) {
        let text = self.textView.text
        let textIn:UnsafeMutablePointer&lt;UInt8&gt; = UnsafeMutablePointer&lt;UInt8&gt;((text as NSString).UTF8String)
        let textOut:UnsafeMutablePointer&lt;UInt8&gt; = UnsafeMutablePointer&lt;UInt8&gt;.alloc(countElements(text) * 257 / 256 + 1)
        let outsize = LZ_Compress(textIn, textOut, UInt32( countElements(text)))
        save("lz.dat", data: textOut, dataSize: Int(outsize))
    }</pre></div></li><li class="listitem" value="18">The last step as you may imagine, is implementing the save function, which can be as easy as this code:<div><pre class="programlisting">    private func save(filename: String, data: UnsafePointer&lt;UInt8&gt;, dataSize: Int){
        let nsData = NSData(bytes: data, length: dataSize)
        let path = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as String + "/\(filename)"
        NSFileManager.defaultManager().createFileAtPath(path, contents: nsData, attributes: nil)
    }</pre></div></li><li class="listitem" value="19">The application is <a id="id424" class="calibre1"/>done, however it is still necessary to test it. To do this you have to make sure that the app is selected at the schema combo, otherwise nothing will happen when you press play:<div><img src="img/00134.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="20">Now press play, write a message on the text field and press the <code class="email">huffman</code> button, then press the <code class="email">lz</code> button. Similar to the previous recipe, you won't see anything visually attractive but if you open your iFunBox, expand the app and open the document folder. If you would like to see the file sizes without copying them just <a id="id425" class="calibre1"/>click on the list view:<div><img src="img/00135.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec227" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">When you have a big project you can divide it into small components; to do this, you can divide your project into small projects. A good way of doing this is by creating workspaces.</p><p class="calibre7">A workspace is like a connection between projects, making the usage of one project (in this case the BCL static library) into the other project (in this case the application) easier.</p><div><h3 class="title2"><a id="tip47" class="calibre1"/>Tip</h3><p class="calibre7">Avoid creating a huge project, and instead try to divide it into small projects; it will make your project easier to maintain, and simplify finding issue solutions and even creating unit tests.</p><p class="calibre7">A static library is something <a id="id426" class="calibre1"/>that is copied into your project as is, meaning that your project will grow in size but you won't be worried about a library update that can break your app. Every time you create a static library you must export the header files, which contain the functions that can be used publicly.</p><p class="calibre7">Remember that even if you have a static library on the same workspace, you still need to link it on your project and create a bridge file.</p></div><p class="calibre7">You can also see that we used a new method: <code class="email">alloc</code>. The method <code class="email">alloc</code> was used for creating the C array with a specific size; remember that arrays in C are not resizable and if you were to store anything on them, you must have allocated enough memory for it.</p><p class="calibre7">There is a new type also: <code class="email">UnsafePointer</code>. The reason for this is that C functions can receive constants or variables as arguments, for example, receiving <code class="email">const char *</code> is different from <code class="email">char *</code>; the first one is considered an <code class="email">UnsafePointer</code> and the second one is a <code class="email">UnsafeMutablePointer</code>. Unsafe mutable pointers can be casted to unsafe pointers implicitly, but it is not true the other way round.</p><div><div><div><div><h3 class="title2"><a id="ch09lvl2sec228" class="calibre1"/>There's more…</h3></div></div></div><p class="calibre7">As you can see, there are <a id="id427" class="calibre1"/>more compression types in this library; you can try using a few of them to see which one is the best.</p><p class="calibre7">In the next recipe we are going to learn how to use assembly code with Swift. This feature is very useful if you really need performance.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec74" class="calibre1"/>Using assembly code with Swift</h1></div></div></div><p class="calibre7">In this recipe, we <a id="id428" class="calibre1"/>are going to learn how to use assembly code with <a id="id429" class="calibre1"/>Swift. Of course, nowadays nobody develops using only assembly code, but using it in part of an app is very common when you need performance. Image manipulation programs, for example, use assembly code as it is much faster when you have to process something via hardware than via software.</p><p class="calibre7">Obviously programming with assembly language has its drawbacks, the first one being that you might have to rewrite your source code for different processors, for example, if you have an assembly code done for old iPhones (32-bit ARM processor) you might have to rewrite them for the new devices (64-bit ARM processor), and even with both codes you might write your code for a third time if you wish to see your app working on the iPhone simulator (Intel processor).</p><p class="calibre7">This time we are going to use a very simple code as it is out of the scope of this book to teach the ARM architecture. In this case, we are going to create a simple variable swap function.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec229" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">For this recipe, it is recommended having a physical device but it is not mandatory because you can compile from the command line specifying the architecture that you want to compile for.</p><p class="calibre7">Create a new Swift single view application called <code class="email">Chapter 9 Assembly</code>, add a new file called <code class="email">AssemblyCode.c,</code> and click on <strong class="calibre8">Yes</strong> when Xcode asks for the bridging file.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec230" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">First, you have to click on the bridging header file (<code class="email">Chapter 9 Assembly-Bridging-Header.h</code>) and include the file <code class="email">AssemblyCode.h</code>:<div><pre class="programlisting">#include "AssemblyCode.h"</pre></div></li><li class="listitem" value="2">Then, go to <a id="id430" class="calibre1"/><code class="email">AssemblyCode.h</code> and add the following header:<div><pre class="programlisting">void swap(int * firstnumber, int * secondnumber);</pre></div></li><li class="listitem" value="3">Once the definition is done you have to code the implementation on <code class="email">AssemblyCode.c</code>. Here we are going to use a very simple code that can be used on 32 bits <a id="id431" class="calibre1"/>and 64 bits, but bear in mind that you might need to separate them in the case of more complex codes:<div><pre class="programlisting">void swap(int * firstnumber, int * secondnumber){
#if defined __arm64__ || defined __arm__
    asm volatile (
                  "EOR %[first],%[first], %[second] \n\t"
                  "EOR %[second],%[second], %[first] \n\t"
                  "EOR %[first],%[first], %[second] \n\t"
                  : /* outputs */ [first]"=r"(*firstnumber), [second]"=r"(*secondnumber)
                  : /* inputs */ [first]"r"(*firstnumber), [second]"r"(*secondnumber)
                  );
#else
#error "Architecture not allowed"
#endif
}</pre></div></li><li class="listitem" value="4">The assembly part is done; click on the storyboard and create a layout with two labels, two text fields, and a button. Change the labels text to <strong class="calibre8">First Number</strong> and <strong class="calibre8">Second Number</strong>; on the text fields replace the place holders with some sample number, and change the button text to <strong class="calibre8">Swap numbers</strong>. The final result should be something similar to the following:<div><img src="img/00136.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">Click on <a id="id432" class="calibre1"/>each text field on the storyboard and <a id="id433" class="calibre1"/>change the keyboard type on the attribute inspector to <strong class="calibre8">Number and Punctuation</strong>:<div><img src="img/00137.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="6">After placing the user views into the storyboard you have to link the text fields with the view controller and call them <code class="email">firstNumberTextField</code> and <code class="email">secondNumberTextField</code>:<div><pre class="programlisting">    @IBOutlet weak var firstNumberTextField: UITextField!
    @IBOutlet weak var secondNumberTextField: UITextField!</pre></div></li><li class="listitem" value="7">Then, link the button with this action:<div><pre class="programlisting">    @IBAction func swapNumbers(sender: UIButton) {
        var number1 = Int32(Int(self.firstNumberTextField.text!))
        var number2 = Int32(Int(self.secondNumberTextField.text!))
        swap(&amp;number1, &amp;number2)
        self.firstNumberTextField.text = "\(number1)"
        self.secondNumberTextField.text = "\(number2)"
    }</pre></div></li><li class="listitem" value="8">The application <a id="id434" class="calibre1"/>is done, let's test it. First, change the <a id="id435" class="calibre1"/>device to the <strong class="calibre8">iPhone 6</strong> simulator and press play:<div><img src="img/00138.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="9">If you receive an error message it's alright. Just pay attention that the message is the same as the one you wrote on the file <code class="email">AssemblyCode.c</code>:<div><img src="img/00139.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="10">Now plug your Apple device into the computer, select it on the active schema and press play again. You should see the app, so type two different numbers (one on each text field), and press the swap button. The result is that they exchange <a id="id436" class="calibre1"/>their text fields.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec231" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Writing assembly <a id="id437" class="calibre1"/>code is something that you need to do on the C or Objective-C layer, meaning that you still need to know how these languages are converted to Swift. Using the statement as volatile allows you to write assembly code. Inside that statement you have up to four parts delimited by a colon:</p><div><ul class="itemizedlist"><li class="listitem">The first part is a string (only one) that is your assembly template; we didn't write more than one string. Notice that on C and Objective C if you write two constant strings they are treated as only one. Here you can specify the variables using <code class="email">%[assembly variable name]</code> or <code class="email">%0, %1</code>….</li><li class="listitem">The second part is the output variables; you can name them for your assembly template by using square brackets, and between parentheses you can specify the equivalent C variable.</li><li class="listitem">The third part is the input variables, which work in a similar way as the output variables.</li><li class="listitem">The last part (which we haven't used) is what is called "clobbers". Clobber registers are registers that have their value modified in the assembly chunk. Compiler will know not to expect that the old register value is preserved.<div><h3 class="title2"><a id="tip48" class="calibre1"/>Tip</h3><p class="calibre7">Take care writing huge assembly code, as debugging it could be very hard.</p></div></li></ul></div><p class="calibre7">As mentioned before, assembly code is platform dependent, meaning that it can be different when you use it on the simulator, on an old Apple device, or using the new 64-bit device. To differentiate them you can use the macro <code class="email">__arm__</code> for 32-bit devices and <code class="email">__arm64__</code> for new arm devices.</p><p class="calibre7">Usually you are going to see functions that contain assembly code with the keyword <code class="email">inline</code>. This is done due to assembly code being used when performance is really necessary, and the programmer is trying to tell the compiler to copy the function code where it is called instead of jumping to the function implementation. Unfortunately to do it you have to implement the function on the header file and Swift doesn't accept this.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec232" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Assembly code is also something very interesting when you need to debug an application that was compiled on release configuration. There is a good website for learning the arm assembly code: <a class="calibre1" href="http://www.peter-cockerell.net/aalp/html/frames.html">http://www.peter-cockerell.net/aalp/html/frames.html</a>.</p><p class="calibre7">You can also investigate NEON to learn about how to work with vectors, double word registers, and so on, and if you would like to know even more you can investigate intrinsics, which are C functions that call arm instructions.</p><p class="calibre7">If you are asking <a id="id438" class="calibre1"/>yourself how games that require big performance <a id="id439" class="calibre1"/>are developed if assembly code is very complicated, the answer by is using C++. In the next recipe we are going to use it with Swift.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec75" class="calibre1"/>Sharing C++ code with Swift</h1></div></div></div><p class="calibre7">If you have <a id="id440" class="calibre1"/>some code or an external library written in C++ or <a id="id441" class="calibre1"/>Objective-C++, you probably had a big surprise when you received Apple's note that you can't use C++ on Swift directly as we did with C or Objective C.</p><p class="calibre7">There is still a solution and <a id="id442" class="calibre1"/>that is creating your own wrapper. There are some attempts like SwiftPP (<a class="calibre1" href="https://github.com/sandym/swiftpp">https://github.com/sandym/swiftpp</a>) but they are still very immature. In this recipe we are going to see how you can wrap your C++ class for using it on Swift.</p><p class="calibre7">In this recipe we are going to wrap a C++ xml creator for use on Swift. Don't worry if you don't know C++ as the idea of this recipe is just letting you know how to create this kind of proxy class.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec233" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">For this recipe we will need to download a pure C++ library for creating XML files; in this case the library chosen <a id="id443" class="calibre1"/>was <code class="email">pugixml</code>. So before we start, open your web browser, go to <a class="calibre1" href="http://pugixml.org/">http://pugixml.org/</a> (or just Google pugixml) and uncompress it. After that, create a new Swift single view project called <code class="email">Chapter 9 Xml Wrapper</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec234" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">First of all we are going to create two project groups, so right click on the source code group and select <strong class="calibre8">New Group</strong> and call it <code class="email">Pugi</code>. Repeat the operation calling the second group <code class="email">PugiWrapper</code>.</li><li class="listitem" value="2">Now return <a id="id444" class="calibre1"/>to the <strong class="calibre8">Pugi</strong> source code finder window. Here you have to open the folder <code class="email">src</code>, then you have to select all files with the <a id="id445" class="calibre1"/>shortcut <em class="calibre9">command</em> + <em class="calibre9">a</em> and drag them to the group <code class="email">Pugi</code>. Accept the creation of the bridging file when it is requested:<div><img src="img/00140.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Now go to the <code class="email">PugiWrapper</code> group and create a new file; this time you have to choose <strong class="calibre8">Cocoa Touch Class</strong> from the <strong class="calibre8">iOS source</strong> section. This file should be named <code class="email">PugiBase</code>. It must be a subclass of <code class="email">NSObject</code> and make sure that Objective-C was selected as the language:<div><img src="img/00141.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Click on the file <code class="email">PugiBase.h</code> that was just created, start including the <code class="email">pugixml.hpp</code> <a id="id446" class="calibre1"/>file in case of being imported from <a id="id447" class="calibre1"/>a C++ file:<div><pre class="programlisting">#ifdef __cplusplus
#include "pugixml.hpp"
#endif
Now we can define this class with the following code.
@interface PugiBase : NSObject
@property (nonatomic, assign) void * element;
-(instancetype) init;
@end
Once this class interface is defined we can implement it, in this case only the initializer is necessary by setting the property to NULL.
@implementation PugiBase
-(instancetype) init{
    self = [super init];
    if(self){
        self.element = NULL;
    }
    return self;
}
@end</pre></div><div><h3 class="title2"><a id="tip49" class="calibre1"/>Tip</h3><p class="calibre7">Now that you have MinGW and MSYS, there's no need to be jealous of those with a Linux installation anymore, since they implement in your system the most important parts of a Linux development environment.</p></div></li><li class="listitem" value="5">This class is done, so the next step is to create a class that will inherit from <code class="email">PugiBase</code>. To do this, add a new <strong class="calibre8">Cocoa Touch Class</strong> to the <code class="email">PugiWrapper</code> group and call it <code class="email">PugiNodeAttribute</code>. For this class the only method that we are going to create is the <code class="email">setValue</code>. Knowing this, go to the <code class="email">PugiNodeAttribute.h</code> file and add the following code:<div><pre class="programlisting">#import "PugiBase.h"

@interface PugiNodeAttribute : PugiBase
-(void) setValue:(NSString *) value;
@end</pre></div></li><li class="listitem" value="6">Implementing this class is easy, however there is an important detail: the implementation of this class will have C++; this means that before typing anything, rename this file from <code class="email">PugiNoteAttribute.m</code> to <code class="email">PugiNodeAttribute.mm</code> (Objective-C++ extension):<div><img src="img/00142.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="7">Click on the <a id="id448" class="calibre1"/>renamed file and complete the class <a id="id449" class="calibre1"/>implementation with the following code:<div><pre class="programlisting">@implementation PugiNodeAttribute

-(void) setValue:(NSString *) value{
    if(self.element){
        reinterpret_cast&lt;pugi::xml_attribute *&gt;(self.element)-&gt;set_value([value UTF8String]);
    }
}

@end</pre></div></li><li class="listitem" value="8">Now that the attribute is done we can repeat the operation for the node (XML tag), so create a Cocoa Touch Class file called <code class="email">PugiNode</code>, rename the <code class="email">.m</code> to <code class="email">.mm</code>, go to the header file and add the following code:<div><pre class="programlisting">#import "PugiBase.h"
#import "PugiNodeAttribute.h"

@interface PugiNode : PugiBase
-(PugiNode*) appendChild:(NSString *) name;
-(PugiNodeAttribute *) appendAttribute:(NSString *) name;
@end
For the implementation just add this code.
#import "PugiNode.h"
#import "PugiNodeAttribute.h"

@implementation PugiNode

-(PugiNode*) appendChild:(NSString *) name{
    if (self.element) {
        PugiNode * newNode = [PugiNode new];
        newNode.element = new pugi::xml_node(reinterpret_cast&lt;pugi::xml_node*&gt;(self.element)-&gt;append_child([name UTF8String]));
        return  newNode;
    }
    return nil;
}
-(PugiNodeAttribute *) appendAttribute:(NSString *) name{
    if (self.element){
        PugiNodeAttribute * newAttribute = [PugiNodeAttribute new];
        newAttribute.element = new pugi::xml_attribute(reinterpret_cast&lt;pugi::xml_node*&gt;(self.element)-&gt;append_attribute(name.UTF8String));
        return newAttribute;
    }
    return nil;
}

@end</pre></div></li><li class="listitem" value="9">For finishing the wrapper classes, we only need to create another class that represents an <a id="id450" class="calibre1"/>XML document. Again, create a new Cocoa <a id="id451" class="calibre1"/>Touch Class and this time call it <code class="email">PugiDocument</code>. Rename the implementation file from <code class="email">.m</code> to <code class="email">.mm</code> and add the following code into the <code class="email">.h</code> file:<div><pre class="programlisting">#import "PugiBase.h"
#import "PugiNode.h"

@interface PugiDocument : PugiBase

-(instancetype) init;
-(PugiNode *) appendChild:(NSString *) name;
-(void) saveFile:(NSString *) path;

@end
On the implementation file (PugiDocument.mm) add the following code.
@implementation PugiDocument

-(instancetype) init{
    self = [super init];
    if(self){
        self.element = new pugi::xml_document;
    }
    return self;
}

-(PugiNode *) appendChild:(NSString *) name{
    if(self.element){
        PugiNode * newNode = [PugiNode new];
        newNode.element = new pugi::xml_node(reinterpret_cast&lt;pugi::xml_document *&gt;(self.element)-&gt;append_child([name UTF8String]));
        return newNode;
    }
    return nil;
}

-(void) saveFile:(NSString *) path{
    if (self.element) {
        reinterpret_cast&lt;pugi::xml_document *&gt;(self.element)-&gt;save_file(path.UTF8String);
    }
}

@end</pre></div></li><li class="listitem" value="10">The wrapping step has finished, so now we can use these classes in our app, but we still need to <a id="id452" class="calibre1"/>create another class that is going to be used by our app and will store the user information before creating the XML <a id="id453" class="calibre1"/>file. This class will be a pure Swift one, so add a new Swift file called <code class="email">Task.swift</code> into the project and add the following code:<div><pre class="programlisting">class Task {
    var description:String
    var important :Bool
    
    init(description:String, important: Bool){
        self.description = description
        self.important = important
    }
}</pre></div></li><li class="listitem" value="11">Before we start coding the view controller, don't forget that you have to import the header files of the wrapper classes into the bridging file. So click on the bridging file (<code class="email">Chapter 9 Xml Wrapper-Bridging-Header.h</code>) and add the following lines:<div><pre class="programlisting">#import "PugiDocument.h"
#import "PugiNode.h"
#import "PugiNodeAttribute.h"</pre></div></li><li class="listitem" value="12">Now let's mock up our view by clicking on the storyboard file and adding three labels, two buttons, one text field, and one UISwitch, something like the following image:<div><img src="img/00143.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="13">Now, connect the <a id="id454" class="calibre1"/>text field with the view controller <a id="id455" class="calibre1"/>and call it <code class="email">taskTextField</code>, and the <code class="email">UISwitch</code> should be called as <code class="email">importantSwitch</code>. So the generated code should be like this one:<div><pre class="programlisting">    @IBOutlet var taskTextField: UITextField!
    @IBOutlet var importantSwitch: UISwitch!</pre></div></li><li class="listitem" value="14">Now we can add a new attribute for storing the user tasks:<div><pre class="programlisting">    var tasks = [Task]()</pre></div></li><li class="listitem" value="15">The last thing we need to do is create the events for the buttons. Connect the add button with the following code:<div><pre class="programlisting">    @IBAction func addTask(sender: AnyObject) {
        tasks.append(Task(description: taskTextField.text, important: importantSwitch.on))
        taskTextField.text = ""
        importantSwitch.on = false
    }</pre></div></li><li class="listitem" value="16">Good, now we <a id="id456" class="calibre1"/>can finalize by linking the save button <a id="id457" class="calibre1"/>with the following action:<div><pre class="programlisting">    @IBAction func saveXml(sender: AnyObject) {
        var document = PugiDocument()!
        var mainNode = document.appendChild("tasks")
        var path = (NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as NSString).stringByAppendingPathComponent("tasks.xml") as String;
        for task in tasks {
            let node = mainNode.appendChild("task")
            let attributeDescription = node.appendAttribute("description")
            attributeDescription.setValue(task.description)
            let attributeImporant = node.appendAttribute("important")
            attributeImporant.setValue(task.important ? "yes" : "no")
        }
        document.saveFile(path)
    }</pre></div></li><li class="listitem" value="17">Congratulations, the app is done! Press play and add some tasks, such as <strong class="calibre8">Clean the room</strong> or <strong class="calibre8">Study Swift very hard</strong>. Once you've finished you can press the <strong class="calibre8">Save</strong> button. What happened? Open your iFunBox or equivalent application and check the <code class="email">Documents</code> folder of your app.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec235" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">pugixml is a minimalist XML library that can be easily used. In this case we wrapped only the minimal necessary code <a id="id458" class="calibre1"/>that was the tag attribute, the XML tag (called <strong class="calibre8">node</strong>), and the complete XML called document. Of course, there are more classes in this library and you can complete the code if you want.</p><p class="calibre7">As mentioned before, C++ can't be used directly on Swift, but you can create Objective-C class that calls C++. Here there is a big detail: you can create Objective-C classes but not Objective-C++ classes, which means that the class interface can't contain any C++ objects.</p><p class="calibre7">How can we solve this issue? Every C++ object (like attributes or properties) must be declared as <code class="email">void*</code> (an unsafe pointer to anything) and the arguments or returning values must be another wrapper class.</p><div><h3 class="title2"><a id="tip50" class="calibre1"/>Tip</h3><p class="calibre7">For better compatibility between Swift and Objective-C, try to use types that are common to both <a id="id459" class="calibre1"/>languages instead of the C or C++ types, such <a id="id460" class="calibre1"/>as <code class="email">NSString</code> instead of <code class="email">char*</code>.</p></div></div></div></body></html>