<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Location Services and Maps</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Determining location</li><li class="listitem" style="list-style-type: disc">Determining heading</li><li class="listitem" style="list-style-type: disc">Using region monitoring</li><li class="listitem" style="list-style-type: disc">Using significant-change location service</li><li class="listitem" style="list-style-type: disc">Location services in the background</li><li class="listitem" style="list-style-type: disc">Displaying maps</li><li class="listitem" style="list-style-type: disc">Geocoding</li><li class="listitem" style="list-style-type: disc">Adding map annotations</li><li class="listitem" style="list-style-type: disc">Adding map overlays</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec01"/>Introduction</h1></div></div></div><p>Today's smartphones and handheld devices are equipped with high-accuracy Global Positioning System (GPS) hardware. GPS hardware receives location information from a constellation of satellites. Apart from the satellites, iOS devices take advantage of the cellular and Wi-fi networks to provide location information to the user.<a id="id755" class="indexterm"/>
</p><p>In this chapter, we will discuss how to use the appropriate frameworks to take advantage of the location services of the device. Furthermore, we will learn how to display maps and annotate them. Specifically, we will focus on the following subjects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Location services:</strong> They provide the available services on a device for providing location information. These services are:<a id="id757" class="indexterm"/><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Standard location service:</strong> This is the location service that depends fully on the device's GPS module and provides the highest accuracy location data<a id="id758" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Region monitoring service:</strong> This is the location service that monitors boundary crossings<a id="id759" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Significant-change location service:</strong> This is the service that monitors for significant changes in location<a id="id760" class="indexterm"/></li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">CLLocationManager:</code> This is the class that allows us to use the location services<a id="id761" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Compass:</code> This is the class that shows us how to use the built-in compass<a id="id762" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MKMapView:</code> This is the view that is used to display maps<a id="id763" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MKAnnotation:</code> This is the class that allows us to add annotations on maps<a id="id764" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MKOverlay:</code> This is the class that allows us to add overlays on maps<a id="id765" class="indexterm"/></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec02"/>Determining location</h1></div></div></div><p>In this recipe, we will discuss how to receive the location information from the built-in GPS hardware.<a id="id766" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec01"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> LocationApp</code>. Add two buttons and a label on the view of<code class="literal"> MainController</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec02"/>How to do it...</h2></div></div></div><p>To retrieve location data from the built-in GPS hardware, we need to use the<code class="literal"> CoreLocaction</code> framework. It is exposed through the<code class="literal"> MonoTouch.CoreLocation</code> namespace:<a id="id767" class="indexterm"/>
</p><div><pre class="programlisting">using MonoTouch.CoreLocation;
</pre></div><div><ol class="orderedlist"><li class="listitem"> Add the following code in the<code class="literal"> MainController</code> class:<a id="id768" class="indexterm"/><div><pre class="programlisting">private CLLocationManager locationManager;
public override void ViewDidLoad (){
base.ViewDidLoad ();
this.locationManager = new CLLocationManager();
this.locationManager.UpdatedLocation += this.LocationManager_UpdatedLocation;
this.locationManager.Failed += this.LocationManager_Failed;
this.buttonStart.TouchUpInside += delegate {
this.lblOutput.Text = "Determining location...";
this.locationManager.StartUpdatingLocation();
} ;
this.buttonStop.TouchUpInside += delegate {
this.locationManager.StopUpdatingLocation();
this.lblOutput.Text = "Location update stopped.";
} ;
}
private void LocationManager_Failed (object sender, NSErrorEventArgs e){
this.lblOutput.Text = string.Format("Location update failed! Error message: {0}", e.Error.LocalizedDescription);
}
private void LocationManager_UpdatedLocation (object sender, CLLocationUpdatedEventArgs e){
double latitude = Math.Round(e.NewLocation.Coordinate. Latitude, 4);
double longitude = Math.Round(e.NewLocation.Coordinate. Longitude, 4);
double accuracy = Math.Round(e.NewLocation. HorizontalAccuracy, 0);
this.lblOutput.Text = string.Format("Latitude: {0}\nLongitude: {1},\nAccuracy: {2}m", latitude, longitude, accuracy);
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Tap the start button to view your location coordinates on the screen.</li></ol></div><div><h3 class="title"><a id="note45"/>Note</h3><p>Projects using the<code class="literal"> CoreLocation</code> framework to determine current position can work on the simulator. However, the coordinates will be fixed, with values of either Apple's headquarters in California, or the central coordinates for the country of the Mac computer of which the simulator is running on.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec03"/>How it works...</h2></div></div></div><p>The location data the GPS module provides can be accessed through the<code class="literal"> CLLocationManager</code> class. After initializing an instance of the class, we need to subscribe to its<code class="literal"> UpdatedLocation</code> event:<a id="id769" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager = new CLLocationManager();
this.locationManager.UpdatedLocation += this.LocationManager_UpdatedLocation;
</pre></div><p>Location data will become available as they are issued through this event. It is good practice to also subscribe to the<code class="literal"> Failed</code> event:<a id="id770" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.Failed += this.LocationManager_Failed;
</pre></div><p>When the location manager first requests for location updates, the user is informed through a system-specific alert, similar to the following screenshot:</p><div><img src="img/1468EXP_10_01.jpg" alt="How it works..."/></div><p>This alert basically asks for user permission to allow the application to retrieve location data. If the user denies this request, the<code class="literal"> Failed</code> event will be triggered with the appropriate message. Future location requests will not trigger the permission alert, and the user will have to enable location services for the application through the device settings, so we need to handle this scenario accordingly.<a id="id771" class="indexterm"/>
</p><p>After subscribing to the appropriate events, we request the delivery of location updates through the<code class="literal"> StartUpdatingLocation</code> method:<a id="id772" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.StartUpdatingLocation();
</pre></div><p>To stop receiving location updates, we call the<code class="literal"> StopUpdatingLocation</code> method:<a id="id773" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.StopUpdatingLocation();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec04"/>There's more...</h2></div></div></div><p>The<code class="literal"> UpdatedLocation</code> event accepts delegates of the type<code class="literal"> EventHandler&lt;CLLocationUpdatedEventArgs&gt;</code>. The<code class="literal"> CLLocationUpdatedEventArgs</code> parameter contains two properties of the type<code class="literal"> CLLocationCoordinate2D</code>. The<code class="literal"> NewLocation</code> property contains the most recent location information, while the<code class="literal"> OldLocation</code> property contains the previous location information. On the first location update, the<code class="literal"> OldLocation</code> property will return<code class="literal"> null</code>.<a id="id774" class="indexterm"/>
</p><p>The coordinates are returned as values of the type<code class="literal"> double</code> and represent the coordinates of the position in degrees:</p><div><pre class="programlisting">double latitude = Math.Round(e.NewLocation.Coordinate.Latitude, 4);
double longitude = Math.Round(e.NewLocation.Coordinate.Longitude, 4);
double accuracy = Math.Round(e.NewLocation.HorizontalAccuracy, 0);
</pre></div><p>Negative<code class="literal"> latitude</code> values indicate south coordinates, and positive values indicate north coordinates. Negative<code class="literal"> longitude</code> values indicate west coordinates, while positive<code class="literal"> longitude</code> values indicate east coordinates.</p><p>The<code class="literal"> HorizontalAccuracy</code> property returns the accuracy in meters of the GPS fix. For example, a value of<code class="literal"> 17m</code> indicates that the location is determined within a circle of a diameter of 17m. Lower values indicate better accuracy.<a id="id775" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec01"/>GPS accuracy</h3></div></div></div><p>The<code class="literal"> UpdateLocation</code> event might be triggered without a new reading from the GPS. This is why we are provided with the previous location, so that we can compare the two values for determining whether we have a location change. Also, there is always a margin of error in the location data, which is independent of GPS hardware, and there are variable factors that define it, such as surrounding buildings, various obstacles, and so on. You will notice that the<code class="literal"> HorizontalAccuracy</code> will return lower values when the device is outdoors, while higher values will be returned when we use the GPS indoors or on a city street with tall buildings.<a id="id776" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec02"/>Location services availability</h3></div></div></div><p>Not all devices are equipped with location services hardware. Furthermore, even if a device is equipped with the appropriate hardware, location services could be disabled by the user.<a id="id777" class="indexterm"/>
</p><p>To determine if the location services are available or enabled on the device, we read the return value of the<code class="literal"> CLLocationManager.LocationServicesEnabled</code> static property before initializing the location manager object:<a id="id778" class="indexterm"/>
</p><div><pre class="programlisting">if (CLLocationManager.LocationServicesEnabled) {
// Initialize the location manager
//...
}
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec03"/>Location services usage indicator</h3></div></div></div><p>When any type of location service is used, the location services icon appears on the right side of the status bar, next to the battery indicator:<a id="id779" class="indexterm"/>
</p><div><img src="img/1468EXP_10_02.jpg" alt="Location services usage indicator"/></div><p>This indicator only appears on the device and not on the simulator.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec05"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Determining heading</em></li><li class="listitem" style="list-style-type: disc"><em>Location services in the background</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec03"/>Determining heading</h1></div></div></div><p>In this recipe, we will learn how to use the built-in compass to determine heading.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec06"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> HeadingApp</code>. Just like in the previous task, add two buttons and a label on the view of<code class="literal"> MainController</code>.<a id="id780" class="indexterm"/>
</p><div><h3 class="title"><a id="note46"/>Note</h3><p>The project in this task cannot be tested on the simulator. A device with compass hardware (magnetometer) is required.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec07"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Heading information is once more retrieved through the<code class="literal"> CLLocationManager</code> class. Create and initialize an instance in the<code class="literal"> MainController</code> class.<a id="id781" class="indexterm"/></li><li class="listitem"> Add the following code in the<code class="literal"> ViewDidLoad</code> method:<a id="id782" class="indexterm"/><div><pre class="programlisting">this.locationManager = new CLLocationManager();
this.locationManager.UpdatedHeading += this.LocationManager_UpdatedHeading;
this.buttonStart.TouchUpInside += delegate {
this.lblOutput.Text = "Starting updating heading...";
this.locationManager.StartUpdatingHeading();
} ;
this.buttonStop.TouchUpInside += delegate {
this.locationManager.StopUpdatingHeading();
this.lblOutput.Text = "Stopped updating heading.";
} ;
</pre></div></li><li class="listitem"> Add the following method:<div><pre class="programlisting">private void LocationManager_UpdatedHeading (object sender, CLHeadingUpdatedEventArgs e){
this.lblOutput.Text = string.Format("Magnetic heading: {0}", Math.Round(e.NewHeading.MagneticHeading, 1));
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Tap the start button and rotate the device to view the different heading values.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec08"/>How it works...</h2></div></div></div><p>To retrieve the heading information, we first need to subscribe to the location manager's<code class="literal"> UpdatedHeading</code> event:<a id="id783" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.UpdatedHeading += this.LocationManager_UpdatedHeading;
</pre></div><p>To initiate the delivery of heading information, we call the<code class="literal"> StartUpdatingHeading</code> method:<a id="id784" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.StartUpdatingHeading();
</pre></div><p>Inside the<code class="literal"> UpdatedHeading</code> event handler, we retrieve the heading information through the<code class="literal"> MagneticHeading</code> property of the<code class="literal"> CLHeading</code> object, exposed through the event arguments'<code class="literal"> NewHeading</code> property:<a id="id785" class="indexterm"/>
</p><div><pre class="programlisting">this.lblOutput.Text = string.Format("Magnetic heading: {0}", Math.Round(e.NewHeading.MagneticHeading, 1));
</pre></div><p>To stop retrieving heading updates, we call the<code class="literal"> StopUpdatingHeading</code> method:<a id="id786" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.StopUpdatingHeading();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec09"/>There's more...</h2></div></div></div><p>The heading is measured in degrees. The values for the four points of the horizon, as can be viewed on a simple compass, are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">0</code><strong> or</strong><code class="literal"> 360</code><strong> degrees:</strong> North; the magnetometer will return values of up to<code class="literal"> 359.99</code> degrees, and then go to<code class="literal"> 0</code> when the device is heading north</li><li class="listitem" style="list-style-type: disc"><code class="literal">90</code><strong> degrees:</strong> East</li><li class="listitem" style="list-style-type: disc"><code class="literal">180</code><strong> degrees:</strong> South</li><li class="listitem" style="list-style-type: disc"><code class="literal">270</code><strong> degrees:</strong> West</li></ul></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec04"/>Magnetic versus true heading</h3></div></div></div><p>
<strong>Magnetic heading</strong> is the heading that is based on what a normal compass will show as north.<strong> True heading</strong> is the true direction of north, based on the actual position of the Earth's north pole. There is a slight difference between the two, which varies with time, and it is usually about<code class="literal"> 2</code> degrees.<a id="id787" class="indexterm"/>
</p><p>The<code class="literal"> CLHeading</code> class provides both readings through the<code class="literal"> MagneticHeading</code> and<code class="literal"> TrueHeading</code> properties. This provides a significant help to developers, since calculating the difference between the two requires either expensive equipment, or very difficult calculations based on the time of year and other factors.<a id="id788" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec05"/>Compass availability</h3></div></div></div><p>The magnetometer, a module that can determine the heading in degrees and provides compass functionality to devices, is not available on all devices. To check if a device can provide heading information, retrieve the value from the<code class="literal"> CLLocationManager.HeadingAvailable</code> static property:<a id="id789" class="indexterm"/>
</p><div><pre class="programlisting">if (CLLocationManager.HeadingAvailable) {
// Start updating heading
//...
}
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec10"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Determining location</em></li><li class="listitem" style="list-style-type: disc"><em>Location services in the background</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec04"/>Using region monitoring</h1></div></div></div><p>In this recipe, we will discuss how to use the GPS to respond to region-specific position changes.<a id="id790" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec11"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> RegionApp</code>. Add two buttons and a label on the view of<code class="literal"> MainController</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec12"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Create two fields in the<code class="literal"> MainController</code> class:<a id="id791" class="indexterm"/><div><pre class="programlisting">private CLLocationManager locationManager;
private CLRegion region;
</pre></div></li><li class="listitem"> In the<code class="literal"> ViewDidLoad</code> method, initialize it, and subscribe to the<code class="literal"> UpdatedLocation, RegionEntered</code>, and<code class="literal"> RegionLeft</code> events:<a id="id792" class="indexterm"/><div><pre class="programlisting">this.locationManager.RegionEntered += this.LocationManager_RegionEntered;
this.locationManager.RegionLeft += this.LocationManager_RegionLeft;
this.locationManager.UpdatedLocation += this.LocationManager_UpdatedLocation;
</pre></div></li><li class="listitem"> Enter the following event handlers in the class:<div><pre class="programlisting">private void LocationManager_UpdatedLocation (object sender, CLLocationUpdatedEventArgs e){
if (e.NewLocation.HorizontalAccuracy &lt; 100){
this.region = new CLRegion(e.NewLocation.Coordinate, 100, "Home");
this.locationManager.StartMonitoring(this.region, 65);
this.locationManager.StopUpdatingLocation();
}
}
private void LocationManager_RegionLeft (object sender, CLRegionEventArgs e){
this.lblOutput.Text = string.Format("{0} region left.", e.Region.Identifier);
}
private void LocationManager_RegionEntered (object sender, CLRegionEventArgs e){
this.lblOutput.Text = string.Format("{0} region entered.", e.Region.Identifier);
}
</pre></div></li><li class="listitem"> In the start button's<code class="literal"> TouchUpInside</code> handler, call the<code class="literal"> StartUpdatingLocation</code> method:<a id="id793" class="indexterm"/><div><pre class="programlisting">this.locationManager.StartUpdatingLocation();
</pre></div></li><li class="listitem"> In the stop button's<code class="literal"> TouchUpInside</code> handler, call the<code class="literal"> StopMonitoring</code> method:<div><pre class="programlisting">this.locationManager.StopMonitoring(this.region);
</pre></div></li></ol></div><p>This application needs to be tested on a device that supports region monitoring.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec13"/>How it works...</h2></div></div></div><p>Region monitoring is a feature that monitors for boundary crossings. When a boundary of a specific region is crossed, the<code class="literal"> CLLocationManager</code> object issues the appropriate events:<a id="id794" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.RegionEntered += this.LocationManager_RegionEntered;
this.locationManager.RegionLeft += this.LocationManager_RegionLeft;
this.locationManager.UpdatedLocation += this.LocationManager_UpdatedLocation;
</pre></div><p>In this example, we define the region based on the current location; hence, we also subscribe to the<code class="literal"> UpdatedLocation</code> event.<a id="id795" class="indexterm"/>
</p><p>When the application starts receiving location updates, it first checks for location accuracy:<a id="id796" class="indexterm"/>
</p><div><pre class="programlisting">if (e.NewLocation.HorizontalAccuracy &lt; 100)
</pre></div><p>If the desired accuracy is achieved (&lt;100m, modify at your discretion), we initialize the<code class="literal"> CLRegion</code> object:</p><div><pre class="programlisting">this.region = new CLRegion(e.NewLocation.Coordinate, 100, "Home");
</pre></div><p>The<code class="literal"> CLRegion</code> class is used to define regions. Here, we create the region to be monitored based on our current location in the first parameter. The second parameter declares the radius around the coordinate, in meters, defining the region boundary. The third parameter is a string identifier for the region.<a id="id797" class="indexterm"/>
</p><p>To start monitoring the region, we call the<code class="literal"> StartMonitoring</code> method:<a id="id798" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.StartMonitoring(this.region, 65);
</pre></div><p>The first parameter is the region to be monitored, while the second parameter defines the desired accuracy in meters for the boundary crossings. This value acts as an accuracy offset that prevents the system from triggering successive<code class="literal"> enter</code> and<code class="literal"> left</code> events when the user is traveling close to the region's boundary.</p><p>When region monitoring has started, the appropriate events will be triggered when the device enters or leaves the region based on the desired accuracy value.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec14"/>There's more...</h2></div></div></div><p>Region monitoring is a very useful feature. For example, an application could provide specific information to users based on their proximity to various areas. Furthermore, it can notify of boundary crossings while the application is in the background.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec06"/>Region monitoring availability</h3></div></div></div><p>To check if a device supports region monitoring, retrieve the value of the<code class="literal"> RegionMonitoringAvailable</code> static property:<a id="id799" class="indexterm"/>
</p><div><pre class="programlisting">if (CLLocationManager.RegionMonitoringAvailable) {
// Start monitoring a region
//...
}
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec15"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Using significant-change location service</em></li><li class="listitem" style="list-style-type: disc"><em>Location services in the background</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec05"/>Using significant-change location service</h1></div></div></div><p>In this recipe, we will learn how to use the significant-change location monitoring feature.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec16"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> SLCApp</code>. Add a label and two buttons on the view of<code class="literal"> MainController</code>.<a id="id800" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec17"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add the following code in the<code class="literal"> ViewDidLoad</code> method:<a id="id801" class="indexterm"/><div><pre class="programlisting">this.locationManager = new CLLocationManager();
this.locationManager.UpdatedLocation += this.LocationManager_UpdatedLocation;
this.buttonStart.TouchUpInside += delegate {
this.lblOutput.Text = "Starting monitoring significant location changes...";
this.locationManager. StartMonitoringSignificantLocationChanges();
} ;
this.buttonStop.TouchUpInside += delegate {
this.locationManager.StopMonitoringSignificantLocationChanges();
this.lblOutput.Text = "Stopped monitoring significant location changes.";
} ;
</pre></div></li><li class="listitem"> Add the following method:<div><pre class="programlisting">private void LocationManager_UpdatedLocation (object sender, CLLocationUpdatedEventArgs e){
double latitude = Math.Round(e.NewLocation.Coordinate. Latitude, 4);
double longitude = Math.Round(e.NewLocation.Coordinate. Longitude, 4);
double accuracy = Math.Round(e.NewLocation. HorizontalAccuracy, 0);
this.lblOutput.Text = string.Format("Latitude: {0}\nLongitude: {1}\nAccuracy: {2}", latitude, longitude, accuracy);
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Tap the<strong> start</strong> button to start monitoring for significant location changes.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec18"/>How it works...</h2></div></div></div><p>The significant-change location service monitors for significant location changes and provides location information when these changes occur. In terms of power consumption, it is the less demanding location service. It uses the device's cellular radio transceiver to determine the user's location. Only devices equipped with a cellular radio transceiver can use this service.<a id="id802" class="indexterm"/>
</p><p>The code for using the significant-change location service is similar to the code of the standard location services. The only differences are the methods of starting and stopping the service. To start the service, we call the<code class="literal"> StartMonitoringSignificantLocationChanges</code> method:<a id="id803" class="indexterm"/>
</p><div><pre class="programlisting">this.locationManager.StartMonitoringSignificantLocationChanges();
</pre></div><p>Location updates are issued through the<code class="literal"> UpdatedLocation</code> event handler, which is the same event that we use for the standard location service:</p><div><pre class="programlisting">this.locationManager.UpdatedLocation += this.LocationManager_UpdatedLocation;
//...
private void LocationManager_UpdatedLocation (object sender, CLLocationUpdatedEventArgs e){
//...
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec19"/>There's more...</h2></div></div></div><p>The significant-change location service can report location changes while in the background, waking up the application.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec07"/>Significant-change location service availability</h3></div></div></div><p>To determine if a device is capable of using the significant-change location service, retrieve the value of the<code class="literal"> SignificantLocationChangeMonitoringAvailable</code> static property:<a id="id804" class="indexterm"/>
</p><div><pre class="programlisting">if (CLLocationManager.SignificantLocationChangeMonitoringAvailable) {
// Start monitoring for significant location changes.
//...
}
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec20"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Using region monitoring</em></li><li class="listitem" style="list-style-type: disc"><em>Location services in the background</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec06"/>Location services in the background</h1></div></div></div><p>In this recipe, we will discuss how to use location services while the application is in the background.<a id="id805" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec21"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> BackgroundLocationApp</code>. Just like in the previous tasks, add a label and two buttons on the view of<code class="literal"> MainController</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec22"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> In the<strong> Solution</strong> pane, double-click on the<strong> Info.plist</strong> file to open it.</li><li class="listitem"> Under the<strong> Advanced</strong> tab, add a new key by clicking on the plus (+) sign or by right-clicking and selecting<strong> New Key</strong> from the context menu.</li><li class="listitem"> Select<strong> Required background modes</strong> from the drop-down list, or just type<code class="literal"> UIBackgroundModes</code> in the field.</li><li class="listitem"> Expand the key and right-click on the empty item below it. Click<strong> New Key</strong> on the context menu. In its<strong> Value</strong> field, enter the word<code class="literal"> location</code>.</li><li class="listitem"> Save the document. When done, you should have something like in the following screenshot:<div><img src="img/1468EXP_10_03.jpg" alt="How to do it..."/></div></li><li class="listitem"> In the<code class="literal"> MainController</code> class, enter the same code as the one used in the<em> Determining location</em> recipe in this chapter.<a id="id806" class="indexterm"/></li><li class="listitem"> At the bottom of the<code class="literal"> LocationManager_UpdatedLocation</code> method, add the following line:<a id="id807" class="indexterm"/><div><pre class="programlisting">Console.WriteLine("{0}:\n\t{1} ", DateTime.Now, this.lblOutput.Text);
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Tap the<strong> Start</strong> button to start receiving location updates. Press the<strong> Home</strong> button on the device to make the application move to the background. Watch MonoDevelop's<strong> Application Output</strong> pad displaying location updates.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec23"/>How it works...</h2></div></div></div><p>To receive location updates while the application is in the background, we need to set the location value to the<code class="literal"> UIBackgroundModes</code> key in the<strong> Info.plist</strong> file. This basically makes sure that the application has the appropriate permission to receive location updates while it is in the background and that it will not get suspended.</p><p>To make sure that the application is receiving location updates, check the status bar. The location services icon should be displayed:</p><div><img src="img/1468EXP_10_04.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec24"/>There's more...</h2></div></div></div><p>Setting the<code class="literal"> UIBackgroundModes</code> key for location services is only needed for the standard location service. By default both the region monitoring and significant-change location services support delivery of location updates while the application is in the background. While one of these location services has started updating for location data, the application can even be terminated. When a location update is received, the application is started or woken up from the suspended state and is given a limited amount of time to execute code.<a id="id808" class="indexterm"/>
</p><p>To determine if an application has been started by one of these two location services, check the options parameter of the<code class="literal"> FinishedLaunching</code> method in the<code class="literal"> AppDelegate</code> class:<a id="id809" class="indexterm"/>
</p><div><pre class="programlisting">if (null != options){
<strong>if (options.ContainsKey (UIApplication.LaunchOptionsLocationKey)){</strong>
Console.WriteLine ("Woken from location service!");
CLLocationManager locationManager = new CLLocationManager();
locationManager.UpdatedLocation += this.LocationUpdatedHandler;
locationManager.StartMonitoringSignificantLocationChanges();
}
}
</pre></div><p>The options parameter is of the type<code class="literal"> NSDictionary</code>. If this dictionary contains the<code class="literal"> LaunchOptionsLocationKey</code>, then the application has been started or woken up from suspended state due to a location service. When that is the case, we need to call the<code class="literal"> StartMonitoringSignificantLocationChanges</code> method on a<code class="literal"> CLLocationManager</code> instance again to retrieve the location data.<a id="id810" class="indexterm"/>
</p><p>The same applies to region monitoring location service. Note that if we use either of these two location services, but our application does not support the background delivery of location events, then we have to make sure to stop monitoring for location updates when they are no longer needed. If we do not, then the location services will continue to run, causing significant battery drain.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec08"/>Restricting to supported hardware</h3></div></div></div><p>If our application's features are fully dependent on location services and cannot operate correctly on devices that do not support them, we have to add the key<code class="literal"> UIRequiredDeviceCapabilities</code> in the<strong> Info.plist</strong> file, with the value<code class="literal"> location-services</code>.<a id="id811" class="indexterm"/>
</p><p>Furthermore, when the application requires the use of the standard location service, which uses the GPS hardware, we need to add the value<code class="literal"> gps</code> to this key. This way, we make sure the application will not be available through the application store to devices that are not equipped with the appropriate hardware.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec25"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Determining location</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, Development Tools:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating an iPhone project in MonoDevelop</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec07"/>Displaying maps</h1></div></div></div><p>In this recipe, we will learn how to display maps on the screen.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec26"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> MapDisplayApp</code>.<a id="id812" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec27"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add an<code class="literal"> MKMapView</code> on the view of<code class="literal"> MainController</code>. Enter the following<code class="literal"> using</code> directives:<div><pre class="programlisting">using MonoTouch.MapKit;
using MonoTouch.CoreLocation;
</pre></div></li><li class="listitem"> Add the following code in the<code class="literal"> MainController</code> class:<a id="id813" class="indexterm"/><div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
this.mapView.ShowsUserLocation = true;
this.mapView.RegionChanged += this.MapView_RegionChanged;
}
private void MapView_RegionChanged (object sender, MKMapViewChangeEventArgs e){
if (this.mapView.UserLocation.Location != null){
CLLocationCoordinate2D mapCoordinate = this.mapView.UserLocation.Location.Coordinate;
Console.WriteLine("Current coordinates: LAT: {0}, LON: {1}", mapCoordinate.Latitude, mapCoordinate.Longitude);
}
}
</pre></div></li><li class="listitem"> Compile and run the application either on the simulator or on the device. If the application is run on the simulator, the default location will be Apple's headquarters in<strong> Cupertino:</strong><a id="id814" class="indexterm"/><div><img src="img/1468EXP_10_05.jpg" alt="How to do it..."/></div></li><li class="listitem"> Zoom or pan the map to output the current location in the<strong> Application Output</strong>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec28"/>How it works...</h2></div></div></div><p>The<code class="literal"> MonoTouch.MapKit</code> namespace wraps all the objects contained in the<code class="literal"> MapKit</code> framework. The<code class="literal"> MapKit</code> framework uses Google maps to display maps.<a id="id815" class="indexterm"/>
</p><p>The<code class="literal"> MKMapView</code> is the default iOS view that displays maps. It is especially designed for this purpose, and it should not be sub-classed.</p><p>To display the user's location on the map, we set its<code class="literal"> ShowsUserLocation</code> property to<code class="literal"> true:</code>
</p><div><pre class="programlisting">this.mapView.ShowsUserLocation = true;
</pre></div><p>This activates the standard location service to start receiving location updates and handing them over to the<code class="literal"> MKMapView</code> object internally.</p><p>To determine when the user zooms or pans the map, we subscribe to the<code class="literal"> RegionChanged</code> event:</p><div><pre class="programlisting">this.mapView.RegionChanged += this.MapView_RegionChanged;
</pre></div><p>Inside the event handler, we retrieve the current location through the<code class="literal"> UserLocation</code> property:</p><div><pre class="programlisting">if (this.mapView.UserLocation.Location != null){
CLLocationCoordinate2D mapCoordinate = this.mapView.UserLocation.Location.Coordinate;
Console.WriteLine("Current coordinates: LAT: {0}, LON: {1}", mapCoordinate.Latitude, mapCoordinate.Longitude);
}
</pre></div><p>If the<code class="literal"> ShowsUserLocation</code> property is set to<code class="literal"> false</code>, the location services will not be activated, and the<code class="literal"> UserLocation.Location</code> property will return<code class="literal"> null</code>. It will also return<code class="literal"> null</code> when the application runs for the first time, since it will ask the user for permission of using location services. However, a map will be displayed, as long as the device or simulator have an active Internet connection.<a id="id816" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec29"/>There's more...</h2></div></div></div><p>We can set the center coordinate of the map to be displayed with the<code class="literal"> SetCenterCoordinate</code> method:<a id="id817" class="indexterm"/>
</p><div><pre class="programlisting">CLLocationCoordinate2D mapCoordinates = new CLLocationCoordinate2D(0, 0);
this.mapView.SetCenterCoordinate(mapCoordinates, true);
</pre></div><p>The first parameter is the map coordinates that we want the map to be centered at, represented by an object of the type<code class="literal"> CLLocationCoordinate2D</code>. The second parameter declares if we want the centering of the map to be animated or not.</p><p>Apart from centering the map, we can also set its zoom level. We do this through the<code class="literal"> SetRegion</code> method:</p><div><pre class="programlisting">this.mapView.SetRegion(MKCoordinateRegion.FromDistance( mapCoordinates, 1000, 1000), true);
</pre></div><p>The first parameter is of type<code class="literal"> MKCoordinateRegion</code>. Here, its<code class="literal"> FromDistance</code> static method is used to create an instance. Its first parameter is the coordinate of the region's center, while the next two parameters represent the horizontal and vertical span of the map to display, in meters. What this basically means is that the region represented by this<code class="literal"> MKCoordinateRegion</code> instance will have<code class="literal"> mapCoordinates</code> at the center, and the horizontal and vertical part of the map will each represent<code class="literal"> 1000</code> meters on the map.<a id="id818" class="indexterm"/>
</p><p>Note that the<code class="literal"> MKMapView</code> will set the actual region to an approximation to the values of<code class="literal"> MKCoordinateRegion</code>. This is because the dimensions of<code class="literal"> MKMapView</code> cannot always match the horizontal and vertical span values provided. For example, here we set a square region of<code class="literal"> 1000x1000</code> meters, but our<code class="literal"> MKMapView</code> layout is not an absolute square, since it basically takes over all of the screen. We can retrieve the actual region of map the<code class="literal"> MKMapView</code> is displaying through its<code class="literal"> Region</code> property.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec09"/>Things to have in mind when using MapKit</h3></div></div></div><p>The<code class="literal"> MapKit</code> framework uses the Google Maps and Google Earth APIs to display maps. Usage of this framework binds the developer with Google's terms of service, which can be viewed at<a class="ulink" href="http://code.google.com/apis/maps/iphone/terms.html"> http://code.google.com/apis/maps/iphone/terms.html</a>.<a id="id819" class="indexterm"/>
</p><p>One important term that can directly affect whether your application will be rejected or not on the Application Store is the usage of the Google logo over the maps. Care should be taken that the logo is always visible when displaying maps.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec30"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Geocoding</em></li><li class="listitem" style="list-style-type: disc"><em>Adding map annotations</em></li><li class="listitem" style="list-style-type: disc"><em>Adding map overlays</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec08"/>Geocoding</h1></div></div></div><p>In this recipe, we will learn how to provide address, city, or country information based on location coordinates.<a id="id820" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec31"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> GeocodingApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec32"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add an<code class="literal"> MKMapView</code> on the top half of the view of<code class="literal"> MainController</code> and a label and a button on the bottom half. Add the<code class="literal"> MonoTouch.MapKit</code> and<code class="literal"> MonoTouch.CoreLocation</code> namespaces.<a id="id821" class="indexterm"/></li><li class="listitem"> Enter the following<code class="literal"> ViewDidLoad</code> override in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private MKReverseGeocoder reverseGeocoder;
public override void ViewDidLoad (){
base.ViewDidLoad ();
this.mapView.ShowsUserLocation = true;
this.buttonGeocode.TouchUpInside += delegate {
this.lblOutput.Text = "Reverse geocoding location...";
this.buttonGeocode.Enabled = false;
CLLocationCoordinate2D currentLocation = this.mapView.UserLocation.Location.Coordinate;
this.mapView.SetRegion(MKCoordinateRegion.FromDistance( currentLocation, 1000, 1000), true);
this.reverseGeocoder = new MKReverseGeocoder(currentLocation);
this.reverseGeocoder.Delegate = new ReverseGeocoderDelegate(this);
this.reverseGeocoder.Start();
} ;
}
</pre></div></li><li class="listitem"> Create the following nested class:<div><pre class="programlisting">private class ReverseGeocoderDelegate : MKReverseGeocoderDelegate{
public ReverseGeocoderDelegate(MainController parentController){
this.parentController = parentController;
}
private MainController parentController;
public override void FoundWithPlacemark (MKReverseGeocoder geocoder, MKPlacemark placemark){
<strong>
this.parentController.lblOutput.Text = string.Format( "Locality: {0}\nAdministrative area: {1}\nCountry: {2}", placemark.Locality, placemark.AdministrativeArea, placemark.Country);
</strong>
geocoder.Dispose();
this.parentController.buttonGeocode.Enabled = true;
}
public override void FailedWithError (MKReverseGeocoder geocoder, NSError error){
this.parentController.lblOutput.Text = string.Format( "Reverse geocoding failed with error: {0}", error.LocalizedDescription);
this.parentController.buttonGeocode.Enabled = true;
}
}
</pre></div></li><li class="listitem"> Compile and run the application either on the simulator or on the device. If run on the device, when you tap on the button, location information about the country and area you are in at the present time will be displayed on the label.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec33"/>How it works...</h2></div></div></div><p>
<strong>Geocoding</strong> is the process of matching address information to geographic coordinates.<strong> Reverse geocoding</strong> is the process of matching geographic coordinates to address information. Only the latter is available on iOS. There are forward geocoding services available online that can be used, however.<a id="id822" class="indexterm"/>
</p><p>To reverse geocode geographic coordinates, we use the<code class="literal"> MKReverseGeocoder</code> class:<a id="id823" class="indexterm"/>
</p><div><pre class="programlisting">private MKReverseGeocoder reverseGeocoder;
</pre></div><p>This class needs a delegate object that will provide the information. The class we will create for the delegate object of<code class="literal"> MKReverseGeocoder</code> must inherit the<code class="literal"> MKReverseGeocoderDelegate</code> class:<a id="id824" class="indexterm"/>
</p><div><pre class="programlisting">private class ReverseGeocoderDelegate : MKReverseGeocoderDelegate
</pre></div><p>Inside the delegate object, we need to override two methods. The first one is<code class="literal"> FoundWithPlacemark:</code>
</p><div><pre class="programlisting">public override void FoundWithPlacemark (MKReverseGeocoder geocoder, MKPlacemark placemark)
</pre></div><p>This is the method that will be triggered when the reverse geocoder retrieves the geocoding information. The information is contained in the<code class="literal"> placemark</code> parameter, which is of the type<code class="literal"> MKPlacemark</code>. As shown in the previous highlighted code, the information is available through various properties of the<code class="literal"> MKPlacemark</code> class.<a id="id825" class="indexterm"/>
</p><p>The second method we need to override is<code class="literal"> FailedWithError:</code>
</p><div><pre class="programlisting">public override void FailedWithError (MKReverseGeocoder geocoder, NSError error)
</pre></div><p>This method is triggered when reverse geocoding fails for some reason. The information is contained in the<code class="literal"> error</code> parameter.</p><p>To initialize the instance of the<code class="literal"> MKReverseGeocoder</code> class, we pass the coordinates with an object of the type<code class="literal"> CLLocationCoordinate2D</code> that we want geocoding information for, to its constructor:</p><div><pre class="programlisting">this.reverseGeocoder = new MKReverseGeocoder(currentLocation);
</pre></div><p>After assigning its delegate object, we call the<code class="literal"> Start</code> method to reverse geocode the coordinates:<a id="id826" class="indexterm"/>
</p><div><pre class="programlisting">this.reverseGeocoder.Delegate = new ReverseGeocoderDelegate(this);
this.reverseGeocoder.Start();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec34"/>There's more...</h2></div></div></div><p>Detailed information on the location address can be retrieved through the<code class="literal"> AddressDisctionary</code> property of the<code class="literal"> MKPlacemark</code> class, which is of the type<code class="literal"> NSDictionary</code>.<a id="id827" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec10"/>Things to have in mind when using the MKReverseGeocoder class</h3></div></div></div><p>The<code class="literal"> MKReverseGeocoder</code> class is part of the<code class="literal"> MapKit</code> framework. Usage of this class binds the developer to Google's terms of service:<a class="ulink" href="http://code.google.com/apis/maps/iphone/terms.html"> http://code.google.com/apis/maps/iphone/terms.html</a>.<a id="id828" class="indexterm"/>
</p><p>One important term of using the reverse geocoding service is that it should always be used in combination with a Google map. Furthermore, to avoid abuse of the service, Apple recommends not to make more than one reverse geocoding call per minute.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec35"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying maps</em></li><li class="listitem" style="list-style-type: disc"><em>Adding map annotations</em></li><li class="listitem" style="list-style-type: disc"><em>Adding map overlays</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec09"/>Adding map annotations</h1></div></div></div><p>In this recipe, we will discuss annotating a map to display various information.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec36"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> MapAnnotateApp</code>.<a id="id829" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec37"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add an<code class="literal"> MKMapView</code> on the view of<code class="literal"> MainController</code>. Leave some room at the bottom, and add a button.</li><li class="listitem"> Add the namespaces<code class="literal"> MonoTouch.MapKit</code> and<code class="literal"> Monotouch.CoreLocation</code>, and enter the following code in the<code class="literal"> ViewDidLoad</code> override:<div><pre class="programlisting">this.mapView.ShowsUserLocation = true;
this.mapView.Delegate = new MapViewDelegate();
this.buttonAddPin.TouchUpInside += delegate {
CLLocationCoordinate2D mapCoordinate = this.mapView.UserLocation.Location.Coordinate;
this.mapView.SetRegion(MKCoordinateRegion.FromDistance( mapCoordinate, 1000, 1000), true);
MKPointAnnotation myAnnotation = new MKPointAnnotation();
myAnnotation.Coordinate = mapCoordinate;
myAnnotation.Title = "MyAnnotation";
myAnnotation.Subtitle = "Standard annotation";
this.mapView.AddAnnotation(myAnnotation);
} ;
</pre></div></li><li class="listitem"> Create the following nested class:<a id="id830" class="indexterm"/><div><pre class="programlisting">private class MapViewDelegate : MKMapViewDelegate{
public override MKAnnotationView GetViewForAnnotation (MKMapView mapView, NSObject annotation){
if (annotation is MKUserLocation){
return null;
} else{
string reuseIdentifier = "MyAnnotation";
MKPinAnnotationView pinView = mapView.DequeueReusableAnnotation(reuseIdentifier) as MKPinAnnotationView;
if (null == pinView){
pinView = new MKPinAnnotationView(annotation, reuseIdentifier);
pinView.PinColor = MKPinAnnotationColor.Purple;
pinView.AnimatesDrop = true;
pinView.CanShowCallout = true;
}
return pinView;
}
}
}
</pre></div></li><li class="listitem"> Compile and run the application either on the simulator or on the device. If run on the simulator, when you tap on the button, the result should be similar to the following screenshot:</li></ol></div><div><img src="img/1468EXP_10_06.jpg" alt="How to do it..."/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">Tapping on Add pin displays the callout bubble, with the annotation title and subtitle.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec38"/>How it works...</h2></div></div></div><p>Annotating maps is very useful for providing various information along with map data. We can use the<code class="literal"> MKPointAnnotation</code> class to create a simple annotation:<a id="id831" class="indexterm"/>
</p><div><pre class="programlisting">MKPointAnnotation myAnnotation = new MKPointAnnotation();
myAnnotation.Coordinate = mapCoordinate;
myAnnotation.Title = "MyAnnotation";
myAnnotation.Subtitle = "Standard annotation";
this.mapView.AddAnnotation(myAnnotation);
</pre></div><p>We assign the map coordinates the annotation will appear on and, optionally, a title and a subtitle. We then add the annotation to the map view with the<code class="literal"> AddAnnotation</code> method.<a id="id832" class="indexterm"/>
</p><p>Just adding an annotation object to a map view is not enough. The annotation needs a view that will display its information. This is accomplished by creating a delegate object for the map view and overriding its<code class="literal"> GetViewForAnnotation</code> method:<a id="id833" class="indexterm"/>
</p><div><pre class="programlisting">public override MKAnnotationView GetViewForAnnotation (MKMapView mapView, NSObject annotation)
</pre></div><p>Since the map already displays the user location, an annotation already exists, and it is of the type<code class="literal"> MKUserLocation</code>. Inside the<code class="literal"> GetViewForAnnotation</code>, we have to make sure to provide a view for our own annotation by checking the type of annotation parameter:</p><div><pre class="programlisting">if (annotation is MKUserLocation)
</pre></div><p>In this case, we just return<code class="literal"> null</code>. If the annotation parameter is of the type<code class="literal"> MKPointAnnotation</code>, then we first try to retrieve the view for it, in a similar fashion to the<code class="literal"> UITableView</code> that creates the cells it contains:</p><div><pre class="programlisting">MKPinAnnotationView pinView = mapView.DequeueReusableAnnotation( reuseIdentifier) as MKPinAnnotationView;
</pre></div><p>If the result of the<code class="literal"> DequeueReusableAnnotation</code> method is<code class="literal"> null</code>, then we initialize a new instance for our annotation view:<a id="id834" class="indexterm"/>
</p><div><pre class="programlisting">pinView = new MKPinAnnotationView(annotation, reuseIdentifier);
pinView.PinColor = MKPinAnnotationColor.Purple;
pinView.AnimatesDrop = true;
pinView.CanShowCallout = true;
</pre></div><p>The view we create for the annotation here is of the type<code class="literal"> MKPinAnnotationView</code>. This is the standard view that is represented by a pin on the map. The properties that we set are pretty straightforward and define its appearance and behavior. The<code class="literal"> PinColor</code> property defines the color of the pin, the<code class="literal"> AnimatesDrop</code> property defines if the pin will be displayed on the map with an animation, and the<code class="literal"> CanShowCallout</code> property defines if the annotation view will display the information of its underlying annotation in a callout "bubble".</p><p>After we have created the view for the annotation, we just return it from the method:</p><div><pre class="programlisting">return pinView;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec39"/>There's more...</h2></div></div></div><p>We can also create custom annotations and annotation views. For annotations, we have to override the<code class="literal"> MKAnnotation</code> class, while for annotation views we can override the<code class="literal"> MKAnnotationView</code> class.<a id="id835" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec11"/>Annotation performance</h3></div></div></div><p>Theoretically, we can add as many annotations as we want to a map view. Although the<code class="literal"> MKMapView</code> can manage a large amount of annotations efficiently, it is strongly advised to take into account a performance degradation. A way to overcome this is to display annotations depending on the current map region, which basically manages the zoom level of the map. Another way is to make sure we use the same instances of annotation views for the annotations that do not need different annotation views.<a id="id836" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec40"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying maps</em></li><li class="listitem" style="list-style-type: disc"><em>Adding map overlays</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch05.html" title="Chapter 5. Displaying Data">Chapter 5</a>, Displaying Data:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying data in a table</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec10"/>Adding map overlays</h1></div></div></div><p>In this recipe, we will discuss using overlays to draw on a map.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec41"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> MapOverlayApp</code>.<a id="id837" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec42"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add an<code class="literal"> MKMapView</code> on the view of<code class="literal"> MainController</code>. Leave some room at the bottom, and add a button.</li><li class="listitem"> Add the namespaces<code class="literal"> MonoTouch.MapKit</code> and<code class="literal"> Monotouch.CoreLocation</code>, and enter the following code in the<code class="literal"> ViewDidLoad</code> override:<div><pre class="programlisting">this.mapView.ShowsUserLocation = true;
this.mapView.Delegate = new MapViewDelegate();
this.buttonAddOverlay.TouchUpInside += delegate {
CLLocationCoordinate2D mapCoordinate = this.mapView.UserLocation.Location.Coordinate;
this.mapView.SetRegion(MKCoordinateRegion.FromDistance( mapCoordinate, 1000, 1000), true);
MKCircle circleOverlay = MKCircle.Circle(mapCoordinate, 250);
this.mapView.AddOverlay(circleOverlay);
} ;
</pre></div></li><li class="listitem"> Add the following nested class:<a id="id838" class="indexterm"/><div><pre class="programlisting">private class MapViewDelegate : MKMapViewDelegate{
public override MKOverlayView GetViewForOverlay (MKMapView mapView, NSObject overlay){
MKCircle circleOverlay = overlay as MKCircle;
if (null != circleOverlay){
MKCircleView circleView = new MKCircleView(circleOverlay);
circleView.FillColor = UIColor.FromRGBA( 1.0f, 0.5f, 0.5f, 0.5f);
circleView.StrokeColor = UIColor.Red;
circleView.LineWidth = 2f;
return circleView;
} else{
return null;
}
}
}
</pre></div></li><li class="listitem"> Compile and run the application either on the simulator or on the device. If run on the simulator, after tapping the button, the result should be similar to the following:</li></ol></div><div><img src="img/1468EXP_10_07.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec43"/>How it works...</h2></div></div></div><p>While an<code class="literal"> MKAnnotation</code> represents a point on a map, an<code class="literal"> MKOverlay</code> object can represent an area on a map. In this example, we use the<code class="literal"> MKCircle</code> class, which inherits from<code class="literal"> MKOverlay</code>, to display a circle over an area on the map.<a id="id839" class="indexterm"/>
</p><p>We initialize an<code class="literal"> MKCircle</code> instance with its<code class="literal"> Circle</code> static method:</p><div><pre class="programlisting">MKCircle circleOverlay = MKCircle.Circle(mapCoordinate, 250);
</pre></div><p>The first parameter represents the coordinates of the center of the circle, while the second parameter represents the radius of the circle, in meters. After initialization, we add the overlay to the map view with the<code class="literal"> AddOverlay</code> method:<a id="id840" class="indexterm"/>
</p><div><pre class="programlisting">this.mapView.AddOverlay(circleOverlay);
</pre></div><p>Just like annotations, overlays require a view to display their information. To provide a view for our overlay, we override the<code class="literal"> GetViewForOverlay</code> method in the map view's delegate object implementation:<a id="id841" class="indexterm"/>
</p><div><pre class="programlisting">public override MKOverlayView GetViewForOverlay (MKMapView mapView, NSObject overlay)
</pre></div><p>Inside this method, we first check if the overlay parameter is the type we want; in this case, an<code class="literal"> MKCircle:</code>
</p><div><pre class="programlisting">MKCircle circleOverlay = overlay as MKCircle;
if (null != circleOverlay)
</pre></div><p>Then, we create an instance of the<code class="literal"> MKCircleView</code> class and return it:<a id="id842" class="indexterm"/>
</p><div><pre class="programlisting">MKCircleView circleView = new MKCircleView(circleOverlay);
circleView.FillColor = UIColor.FromRGBA(1.0f, 0.5f, 0.5f, 0.5f);
circleView.StrokeColor = UIColor.Red;
circleView.LineWidth = 2f;
return circleView;
</pre></div><p>We set the appropriate properties that will define the appearance of our overlay. In this case, we set the<code class="literal"> FillColor, StrokeColor</code>, and<code class="literal"> LineWidth</code> properties.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec44"/>There's more...</h2></div></div></div><p>Overlays are handled efficiently by the map view. One important thing that the map view takes care for us is that when we scale the map, the overlay is automatically scaled to match each zoom level. This way, we do not need to scale the overlay manually in code.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec12"/>Creating custom overlays</h3></div></div></div><p>We can create our own custom overlays. To do this, we need to override the<code class="literal"> MKOverlay</code> class for the overlay and the<code class="literal"> MKOverlayView</code> class for the overlay view.<a id="id843" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec13"/>Standard overlay objects</h3></div></div></div><p>Apart from the<code class="literal"> MKCircle</code>, the other standard overlay objects are<code class="literal"> MKPolygon</code> for creating polygon shapes and<code class="literal"> MKPolyline</code> for creating polylines, like in a track-recording application.<a id="id844" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec45"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying maps</em></li><li class="listitem" style="list-style-type: disc"><em>Adding map annotations</em></li></ul></div></div></div></body></html>