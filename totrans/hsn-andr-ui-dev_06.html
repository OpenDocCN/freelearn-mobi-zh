<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Storing and Retrieving Data</h1>
                </header>
            
            <article>
                
<p class="mce-root">Data storage might not, at first glance, seem to be at all related to a user interface, but in the majority of applications, the user interface exists to manipulate long-lived data both on the device and on the network. This means that while it does not directly influence the look of the application, it does influence the user experience. Users expect the application to always reflect the latest data available to them, as we explored in <a href="6afcbdf4-555b-4073-9e53-4a87bc0f6459.xhtml" target="_blank">Chapter 5</a>, <em>Binding Data to Widgets</em>. Applications written using a reactive pattern ensure that the user interface is always up to date with the latest data available to the application, and the Android data binding system helps to make writing reactive applications easy. Even without the data binding framework, Android itself has always been built for reactive applications from the very bottom layers upward, but until recently, this behavior required huge amounts of boilerplate code.</p>
<p class="mce-root">When you develop any sort of application, it's important to establish a data container or authority within the application. In most web systems, this will be a database. The system may have many other layers to its data storage, such as caches and in-memory object models, but the <em>authority</em> in this case will be the database. Android applications may appear more complex at first; you typically have a server with some data, you often have a local database, and then there is also whatever is on screen and in-memory. Keeping all of these states in-sync might appear to be a nightmare, but it's actually well taken care of.</p>
<p>The Android team have built a collection of APIs known collectively as the Architecture Components. These collectively simplify the job of writing reactive applications by taking care of the most common problems when writing an application. They include APIs for storing and retrieving data, and for reacting to changes in state of the application.</p>
<p class="mce-root">In this chapter, we'll look at the following topics:</p>
<ul>
<li>How data and storage can influence the user experience</li>
<li>The tools Android provides to store and retrieve structured data</li>
<li>The best ways to keep the user interface up to date with the data store</li>
<li>Building an SQLite database store using the Room persistence API</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data storage in Android</h1>
                </header>
            
            <article>
                
<p>Almost every application needs to store data persistently at some point. Any data that needs to remain intact when your application is stopped must be placed in some kind of data storage system where you can retrieve it again later. You can store all the data on the server, but then your application will only function when the user has an active internet connection and will only ever be as fast as their available connection. You can also store data as files on the device's local filesystem, but this means you need to either load all the data into memory and save the whole application state every time it changes, or you need to write complicated logic to maintain integrity between the various files your application will write.</p>
<p>The Android ecosystem has a large number of database systems available, the most popular of which is probably SQLite. Data can be saved in SQLite tables and retrieved through structured queries. This provides an ideal way to store all of your application data on the device, while only ever retrieving what the application needs. An SQLite database can be instructed to exactly which fields on which records you need to retrieve, and you can use indices to make this process very fast.</p>
<p>Persistent data storage and object mapping does come at a significant cost--as fast as a database lookup might be, it takes significantly longer than is acceptable on the main thread, where it creates delays in graphics rendering and event dispatching. So once again, you want data to be loaded from a background thread. This can create some additional challenges: how do you ensure that the data is always up to date, and doesn't get stagnated when it's involved in <kbd>Activity</kbd> life cycles and is being persisted and loaded from multiple storage systems? This <span>can</span> quickly get out of hand, but again, Android has a whole ecosystem of structures that are designed to keep things under control.</p>
<p class="mce-root">When creating an Android application, it's best to design it so that anything being edited by the user on the current <kbd>Activity</kbd> remains in a mutable in-memory model, as in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="149" width="248" src="assets/302c94cf-42fe-472b-bd10-c0d014d3dd03.jpg"/></div>
<p>This design pattern will provide your application with good performance, while also allowing you to easily <em>cancel</em> changes by simply discarding the in-memory model that the user has been changing. When the user is viewing rather than editing data, a different approach is needed. When a user is looking at a screen such as their email inbox, or a chat conversation, they expect it to update without their interaction. When this is the case, it's better to follow a unidirectional data flow design, such as the one in this diagram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="187" width="281" src="assets/28f796f6-2f10-4afb-bc40-112c2363ed76.jpg"/></div>
<p>The <strong>Incoming Change</strong> in this diagram can be from absolutely anywhere. It can be from another part of the application, or it can be from the network, or it can even be from another part of the screen the user is looking at. The important thing is that the database (<strong>DB</strong>) is always updated first, which then triggers the <strong>Model</strong> to be reloaded or updated, and that in turn triggers the <strong>User Interface</strong> to update. This is in opposition to a <strong>Model</strong> where the <strong>User Interface</strong> receives the incoming event and fetches the new data. Here, the <strong>User Interface</strong> will always receive the latest data directly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the SQLite database</h1>
                </header>
            
            <article>
                
<p>SQLite is an excellent little SQL compatible database that is embedded into the core Android system. This allows you to leverage a complete SQL database without having to ship one with your application (which will raise your code size dramatically). This makes it the most common tool for storing structured data on Android, but it's by no means the only option.</p>
<p class="mce-root">For many applications that require real-time synchronization with a server, people use Firebase Database. <strong>Firebase</strong> is a Google cloud product that includes a powerful document database that synchronizes its data in real time, all the way to the client. This means that an event is triggered on a client when any of its data is modified from outside, making it suitable for chat and messaging applications. However, tools such as Firebase require a large additional client-side API, tie your application to a service, and are very difficult to port your application away for later. Applications built with them may also violate privacy laws in some countries if the application were to store private information without first encrypting it on the client side. In these cases, you'll either need to set up your own synchronization system, or use a database with filtered real-time synchronization, such as the <em>CouchDB project</em> from Apache.</p>
<p class="mce-root">Most typically though, SQLite serves as an excellent choice for storing structured data on the client. It's flexible, very powerful, and very fast, and because it's baked into the Android platform, it doesn't add any direct size overhead to your application. Most Java developers will be used to JDBC when accessing an SQL database, and while Android does have JDBC support, the <kbd>android.database</kbd> and <kbd>android.database.sqlite</kbd> packages are the preferred methods of accessing the database and are much faster. Android also offers an additional layer of abstraction above the direct use of SQLite, which we'll explore next.</p>
<div class="mce-root packt_tip">For more information about SQLite and how to get the most out of it, it's worth browsing the project's excellent documentation at <a href="https://sqlite.org/">https://sqlite.org/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Room</h1>
                </header>
            
            <article>
                
<p>Direct use of SQLite requires a huge amount of code dedicated to converting the SQLite structured data into Java objects, and then preparing SQL statements to store those objects back into the database. Mapping an SQL record to a Java object normally takes the following form:</p>
<pre>public Attachment selectById(final long id) {<br/>   final Cursor cursor = db.query(<br/>           "attachments",<br/>           new String[]{"file", "type"},<br/>           "_id=?",<br/>           new String[]{Long.toString(id)},<br/>           null, null, null);<br/><br/>   try {<br/>       if (cursor.moveToFirst()) {<br/>           return new Attachment(<br/>                   new File(cursor.getString(0)),<br/>                   Attachment.Type.valueOf(cursor.getString(1))<br/>           );<br/>       }<br/>   } finally {<br/>       cursor.close();<br/>   }<br/>   return null;<br/>}</pre>
<p>As you can immediately see, there's a lot of code there that you will need to repeat again and again for every one of your data-model objects.</p>
<p class="mce-root">Fortunately, Google has produced a solution to this boilerplate as part of their Architecture Components, and it's called <strong>Room</strong>. Room is an API and code generator that allows you to define your object model and the SQL queries you want to execute while it writes the boilerplate <strong>Data Access Objects</strong> (<strong>DAO</strong>) classes for you. Room is an excellent choice because all the heavy lifting is done at compile time by generating source code for your application. This also means that it requires much less additional code to be included in your application, which helps keep your application smaller on the end user's device.</p>
<p class="mce-root">Room isn't a traditional <strong>Object/Relational</strong> (<strong>O/R</strong>) mapping layer, but rather allows you to define the <kbd>SELECT</kbd> statements, and copies whatever data they return to an object model that you specify. As a result, it doesn't directly handle inter-object relationships (such as <kbd>ClaimItem</kbd> containing an array of <kbd>Attachment</kbd> objects). While this may seem like a problem, it's a very important feature! Relationships like these are common in object models, but are expensive to implement in an Object/Relational layer, since every call to <kbd>ClaimItem.getAttachments</kbd> would require another database query, and on Android, those calls are likely to leak onto the main thread.</p>
<p class="mce-root">Instead, Room is designed so that you can create object models that are suitable for data-binding, and build SQL queries that can return them directly. This pushes the complexity back into the database, and helps encourage a single query to display programming behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding Room to the project</h1>
                </header>
            
            <article>
                
<p>Room is part of the Architecture Components, and is not imported into projects by default. Instead, you need to add them as a dependency to your project by following these simple steps:</p>
<ol>
<li>In the Android panel, open the <span class="packt_screen">Gradle Scripts</span> subsection and then open the <kbd>build.gradle</kbd> for the app module:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="114" width="380" src="assets/2d3959c0-ae5d-4725-a438-6d57e0b53eca.png"/></div>
<ol start="2">
<li>At the bottom of the file, you'll find a dependencies block; at the bottom of the block, add the following two lines of code:</li>
</ol>
<pre style="padding-left: 60px">implementation 'android.arch.persistence.room:runtime:+'<br/>annotationProcessor 'android.arch.persistence.room:compiler:+'</pre>
<ol start="3">
<li style="font-weight: 400">Use the <span class="packt_screen">Sync Now</span> link at the top of the editor to synchronize your project with its Gradle file. Android Studio will automatically download the new Room dependencies for your project.</li>
</ol>
<ol start="4">
<li>Your project now has the Room API and its code generators integrated, and you can start creating a persistent object model and database schema.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Entity model</h1>
                </header>
            
            <article>
                
<p>Room, much like an SQL database, is optionally asymmetric; what you write to it might not be in the exact same format as what you read from it. When you write to a <kbd>Room</kbd> database, you save <kbd>Entity</kbd> objects, but when you read, you can read virtually any Java object. This allows you to define object models that best suit your user interface, and load them with <kbd>JOIN</kbd> queries rather than resorting to one or more additional queries for each object you wish to present to the user. While <kbd>JOIN</kbd> queries might be overly expensive on a server, on a mobile device they are often significantly faster than a multiquery alternative. As such, when defining an entity model, it's worth considering what you will need to save in your database as well as what specific fields you will need on your user interface. The data you need to write to storage becomes your entity, while the fields on your user interface become fields in Java objects that can be queried through Room.</p>
<p>An <kbd>Entity</kbd> class in Room is annotated with <kbd>@Entity</kbd>, and is expected to follow certain rules:</p>
<ul>
<li style="font-weight: 400">Fields must either be <kbd>public</kbd> or have Java Beans style getters and setters</li>
<li style="font-weight: 400">At least one field must be marked as a primary key using the <kbd>@PrimaryKey</kbd> annotation</li>
<li style="font-weight: 400">Room expects a single <kbd>public</kbd> constructor, so you may need to mark the other constructors with an <kbd>@Ignore</kbd> annotation in order for your code to compile. It's often best to leave only a default (no arguments) constructor for Room to use</li>
</ul>
<p>In order to start storing claim data using Room, we will need to modify the existing <kbd>ClaimItem</kbd> and <kbd>Attachment</kbd> classes so that they are valid entities. This will involve making them usable as relational structures; <kbd>ClaimItem</kbd> and <kbd><span>Attachment</span></kbd> will both need an ID primary key, and attachment will need a foreign key identifier for the <kbd>ClaimItem</kbd> that it belongs to. Perform the following steps to modify these two data model classes so that they can be stored as entities using Room:</p>
<ol>
<li style="font-weight: 400">Start by opening the <kbd>ClaimItem</kbd> source file in Android Studio.</li>
<li>Annotate the class declaration with <kbd>@Entity</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Entity<br/>public class ClaimItem implements Parcelable {</pre>
<ol start="3">
<li>Add an ID field, annotate it with <kbd>@PrimaryKey</kbd>, and tell Room that you want it generated by the database rather than having to create IDs manually (you can also add getters and setters for this field if you like):</li>
</ol>
<pre style="padding-left: 60px">@PrimaryKey(autoGenerate = true)<br/>public long id;</pre>
<div class="packt_tip">Leaving the fields <kbd>public</kbd> means that Room will directly access the fields in preference to using getters and setters. Field access can be much faster than method calls to the getters and setters.</div>
<ol start="4">
<li>Tell Room to ignore the <kbd>List</kbd> of <kbd>Attachment</kbd>. Room is unable to directly persist these sorts of relationships, and your application will fail to compile when it tries to generate mapping code for this field:</li>
</ol>
<pre>@Ignore List&lt;Attachment&gt; attachments = new ArrayList&lt;&gt;();</pre>
<ol start="5">
<li>Modify the <kbd>Parcelable</kbd> implementation of <kbd>ClaimItem</kbd> to save and restore the ID field:</li>
</ol>
<pre>protected ClaimItem(final Parcel in) {<br/>       <strong>id = in.readLong();</strong><br/>       description = in.readString();<br/>       amount = in.readDouble();<br/>       // …<br/>}<br/><br/>public void writeToParcel(final Parcel dest, final int flags) {<br/>   <strong>dest.writeLong(id);</strong><br/>   dest.writeString(description);<br/>   dest.writeDouble(amount);<br/>   dest.writeLong(timestamp != null ? timestamp.getTime() : -1);<br/>   dest.writeInt(category != null ? category.ordinal() : -1);<br/>   dest.writeTypedList(attachments);<br/>}</pre>
<ol start="6">
<li>Open the <kbd>Attachment</kbd> source file.</li>
</ol>
<ol start="7">
<li>Add the <kbd>Entity</kbd> annotation to the <kbd>Attachment</kbd> class; this time you'll need to include an <kbd>@Index</kbd> annotation as well to tell Room to generate a database index on a new field you'll be adding--<kbd>claimItemId</kbd>. The index will ensure that queries to fetch the attachments for a specific <kbd>ClaimItem</kbd> record are nice and fast:</li>
</ol>
<pre><strong>@Entity(indices = @Index("claimItemId"))</strong><br/>public class Attachment implements Parcelable {</pre>
<ol start="8">
<li>Add the database primary key field for the <kbd>Attachment</kbd>, and the new <kbd>claimItemId</kbd> field that will be used to indicate which <kbd>ClaimItem</kbd> the <kbd>Attachment</kbd> belongs to when it's stored in the database:</li>
</ol>
<pre>@PrimaryKey(autoGenerate = true)<br/>public long id;<br/>public long claimItemId;</pre>
<ol start="9">
<li>Ensure that there is a <kbd>public</kbd> default constructor, and that any other <kbd>public</kbd> constructors are marked with <kbd>@Ignore</kbd>:</li>
</ol>
<pre><strong>public Attachment() {}</strong><br/><strong>@Ignore</strong> public Attachment(final File file, final Type type) {<br/>    this.file = file;<br/>    this.type = type;<br/>}</pre>
<ol start="10">
<li>Update the <kbd>Attachment</kbd> classes <kbd>Parcelable</kbd> implementation to include the new fields:</li>
</ol>
<pre>protected Attachment(final Parcel in) {<br/>    <strong>id = in.readLong();</strong><br/><strong>    claimItemId = in.readLong();</strong><br/>    file = new File(in.readString());<br/>    type = Type.values()[in.readInt()];<br/>}<br/><br/>public void writeToParcel(final Parcel dest, final int flags) {<br/>    <strong>dest.writeLong(id);</strong><br/><strong>    dest.writeLong(claimItemId);</strong><br/>    dest.writeString(file.getAbsolutePath());<br/>    dest.writeInt(type.ordinal());<br/>}</pre>
<p>As you can see, modifying an existing object model to be stored in a <kbd>Room</kbd> database is very simple. Room will now be able to generate code to load and save these objects from tables in its database; it'll also be able to generate the database schema from these classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Data Access Layer</h1>
                </header>
            
            <article>
                
<p>Now that you have something to write into the database, you need some way to actually write it, and a way to retrieve it again. The most common pattern is to have a dedicated class to deal with this for each class--a Data Access Object class, also known as a DAO. In Room, however, all you have to do is declare what they should look like using an interface; Room will write the implementation code for you. You define your queries using the <kbd>@Query</kbd> annotation on a method, like this:</p>
<pre>@Query(“SELECT * FROM users WHERE _id = :id”)<br/>public User selectById(long id);</pre>
<p>This has a huge advantage over traditional O/R mapping layers in that you can still write any form of SQL query, and let Room figure out how to convert it into the object model you ask for. If it can't write the code, you get an error at compile time, rather than potentially having your app crash for your users. This also has an additional advantage: Room can bind your SQL queries to non-entity classes, allowing you to leverage the full power of your SQLite database without having to do all the column/field/object mapping by hand. For example, you can define a special <kbd>DisplayContact</kbd> class for displaying the summary data for a contact in a list, and then query them directly using a <kbd>join</kbd>:</p>
<pre>@Query(“<strong>SELECT contacts.firstname, contacts.lastname, emails.address FROM contacts, emails WHERE emails._id = contacts.primaryEmailId ORDER BY contacts.lastname</strong>”)<br/>public List&lt;DisplayContact&gt; selectDisplayContacts()</pre>
<p>The preceding query doesn't return an object that can be directly saved in the database; it's the result of looking at two different tables and collecting fields from both of them. Room copes with this just fine though, and doesn't need any sort of annotations on the classes to be returned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The LiveData class</h1>
                </header>
            
            <article>
                
<p>Room does much more than binding your database structures to objects and back again; it offers you the ability to write reactive programs much more simply. As already mentioned, Room is one of the Android Architecture Components libraries. Architecture Components collectively provide generic infrastructure that can be used to more rapidly build reactive applications, while also maintaining excellent performance and safety. One of the most important classes in the architecture components is <kbd>LiveData</kbd>. <kbd>LiveData</kbd> is a generic encapsulation of data that is subject to external changes. <kbd>LiveData</kbd> can be observed, much like the classes used for data-bound layouts. The primary difference is that <kbd>LiveData</kbd> will always trigger a <em>first</em> event on any new observer, providing it with the current data state.</p>
<p class="mce-root">Room has built-in support for <kbd>LiveData</kbd>, meaning that you can return any object wrapped in a <kbd>LiveData</kbd> in order to receive any changes that occur to that object. At the time of writing, Room implements this by watching each of the tables for changes. This means you may receive updates to objects, even though they haven't actually changed. This should not be a problem for most applications, because the queries still run on a worker thread and only the notification happens on the main thread. This makes <kbd>LiveData</kbd> the preferred method for querying the database in most situations, because it takes care of running and processing the query on a worker, freeing your main thread to handle events and keep your application running smoothly.</p>
<p><kbd>LiveData</kbd> is not part of Room directly, so you'll need to follow these steps to add <kbd>LiveData</kbd> and the other Architecture Components to your project:</p>
<ol>
<li>In the Android panel, open the <span class="packt_screen">Gradle Scripts</span> subsection and then open the <span class="packt_screen">build.gradle</span> for the app module:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="114" width="380" src="assets/9ad95035-2fd3-4ea9-adeb-fcfa1f8491b8.png"/></div>
<ol start="2">
<li style="font-weight: 400">At the bottom of the file, you'll find a dependencies block; at the bottom of the block, add the following two lines of code:</li>
</ol>
<pre>implementation 'android.arch.lifecycle:runtime:+'<br/>implementation 'android.arch.lifecycle:extensions:+<span>'</span><br/>annotationProcessor 'android.arch.lifecycle:compiler:+'</pre>
<ol start="3">
<li style="font-weight: 400">Use the <span class="packt_screen">Sync Now</span> link at the top of the editor to synchronize your project with it's Gradle file, and download the new dependencies.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing Data Access Objects in Room</h1>
                </header>
            
            <article>
                
<p>You'll need to implement two different Data Access Object classes for the Claim application, one for each <kbd>Entity</kbd> object. Technically speaking, Room doesn't enforce one DAO per entity, and you can have a single DAO interface for your entire application or have one per screen. However, the most common pattern is to have one DAO class per entity type, even when some of its query methods return statistics or other views on the data. When working with more complex datasets, it's worth considering introducing additional DAO interfaces to cover queries that are either screen-specific or where the data overlaps several entities.</p>
<p class="mce-root">Here's how to implement the Data Access Object interfaces for the Claim example application, step by step:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>model</kbd> package in Android Studio and select <span class="packt_screen">New | Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>db.ClaimItemDao</kbd>.</li>
<li style="font-weight: 400">Change the <span class="packt_screen">Kind</span> field to <span class="packt_screen">Interface</span>. Room DAO types are normally interfaces, although this isn't a strict requirement, and they can also be abstract classes.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new package and class.</li>
<li style="font-weight: 400">Annotate the interface with <kbd>@Dao</kbd> to mark it as a data-access-object:</li>
</ol>
<pre style="padding-left: 60px">@Dao<br/>public interface ClaimItemDao {</pre>
<ol start="6">
<li>Declare a query method to fetch all the <kbd>ClaimItem</kbd> objects in order of the most recent first; ensure that it returns a <kbd>LiveData</kbd> so that the changes are reflected:</li>
</ol>
<pre style="padding-left: 60px">@Query("SELECT * FROM claimitem ORDER BY timestamp DESC")<br/>LiveData&lt;List&lt;ClaimItem&gt;&gt; selectAll();</pre>
<ol start="7">
<li>Next, you need methods to insert, update, and delete the <kbd>ClaimItem</kbd> objects in the database; these methods always take only the <kbd>Entity</kbd> object and instead of a query, are annotated with their operation. In the case of the insert method, it's useful to have it return the generated ID of the new record:</li>
</ol>
<pre style="padding-left: 60px">@Insert long insert(ClaimItem item);<br/>@Update void update(ClaimItem item);<br/>@Delete void delete(ClaimItem item);</pre>
<ol start="8">
<li style="font-weight: 400">Now, right-click on the <kbd>db</kbd> package again, and select <span class="packt_screen">New | Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>AttachmentDao</kbd>, and make <span class="packt_screen">Kind</span> to <span class="packt_screen">Interface</span>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the <kbd>AttachmentDao</kbd> class.</li>
<li style="font-weight: 400">Declare the new interface as a <kbd>Dao</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>@Dao</strong><br/>public interface AttachmentDao {</pre>
<ol start="12">
<li>Write a query method to fetch the <kbd>Attachment</kbd> objects for a single <kbd>ClaimItem</kbd>. This is where the index you declared on <kbd>Attachment</kbd> becomes important:</li>
</ol>
<pre>@Query("SELECT * FROM attachment WHERE claimItemId = :claimItemId")<br/>LiveData&lt;List&lt;Attachment&gt;&gt; selectForClaimItemId(final long claimItemId);</pre>
<ol start="13">
<li>Declare the insert, update, and delete methods for the <kbd>Attachment</kbd> classes, just as you did with the <kbd>ClaimItem</kbd> methods:</li>
</ol>
<pre>@Insert long insert(Attachment attachment);<br/>@Update void update(Attachment attachment);<br/>@Delete void delete(Attachment attachment);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a database</h1>
                </header>
            
            <article>
                
<p>When writing an application using Room, you'll need to define at least one <em>Database</em> class. Each of these corresponds to a specific database schema--a collection of Entity classes and the various ways in which they can be saved, and loaded from storage. It may also serve as a convenient place to write other database-related logic for your application. For example, the <kbd>ClaimItem</kbd> and <kbd>Attachment</kbd> classes need to save and load various types that Room will not understand; for example, <kbd>Date</kbd>, <kbd>File</kbd>, the <kbd>Category</kbd> enum, and <kbd>Attachment</kbd> <kbd>Type</kbd> enum. Each of these classes will need a <kbd>TypeConverter</kbd> method that can be used to convert it to and from primitives that are understood by Room.</p>
<p class="mce-root">Room Database classes are abstract. This is because they are extended by the Room annotation processor to produce the implementation you'll use at runtime. This allows you to define any number of concrete method implementations in a database class that might be useful for your application. Follow these steps to declare your new Room enabled database class:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>db</kbd> package in Android Studio, and select <span class="packt_screen">New | Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>ClaimDatabase</kbd>, and change its <span class="packt_screen">Superclass</span> to <kbd>RoomDatabase</kbd>.</li>
</ol>
<ol start="3">
<li style="font-weight: 400">Select the <span class="packt_screen">Abstract</span> modifier.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new class.</li>
<li style="font-weight: 400">Annotate the class to indicate it as a database, and declare that it will store the <kbd>ClaimItem</kbd> and <kbd>Attachment</kbd> entities. You'll also need to specify the schema version, which will be <kbd>1</kbd> for the first version:</li>
</ol>
<pre>@Database(<br/>        entities = {ClaimItem.class, Attachment.class},<br/>        version = 1,<br/>        exportSchema = false)<br/>public abstract class ClaimDatabase extends RoomDatabase {</pre>
<ol start="6">
<li>As mentioned earlier, you'll need to declare <kbd>TypeConverter</kbd> methods for all the non-primitive fields that <kbd>ClaimItem</kbd> and <kbd>Attachment</kbd> use. You need to tell the database where these methods can be found, and in this case, it'll be the <kbd>ClaimDatabase</kbd> class itself:</li>
</ol>
<pre>@Database(<br/>        entities = {ClaimItem.class, Attachment.class},<br/>        version = 1,<br/>        exportSchema = false)<br/><strong>@TypeConverters(ClaimDatabase.class)</strong><br/>public abstract class ClaimDatabase extends RoomDatabase {</pre>
<ol start="7">
<li>Now, define <kbd>abstract</kbd> methods to retrieve the Data Access Object implementations you created earlier; these methods will be implemented by the subclass generated by Room:</li>
</ol>
<pre>public abstract ClaimItemDao claimItemDao();<br/>public abstract AttachmentDao attachmentDao();</pre>
<ol start="8">
<li>Now, you'll need to tell Room how to convert the various fields to and from the primitives supported by the database. Start by implementing methods to convert <kbd>Date</kbd> objects into a timestamp long that can be stored in the database (SQLite has no <kbd>DATE</kbd> or <kbd>DATETIME</kbd> types):</li>
</ol>
<pre>@TypeConverter<br/>public static Long fromDate(final Date date) {<br/>    return date == null ? null : date.getTime();<br/>}<br/><br/>@TypeConverter<br/>public static Date toDate(final Long value) {<br/>    return value == null ? null : new Date(value);<br/>}</pre>
<ol start="9">
<li>Now continue with this pattern for the other types that the <kbd>ClaimItem</kbd> and <kbd>Attachment</kbd> need:</li>
</ol>
<pre>@TypeConverter<br/>public static String fromFile(final File value) {<br/>    return value == null ? null : value.getAbsolutePath();<br/>}<br/><br/>@TypeConverter<br/>public static File toFile(final String path) {<br/>    return path == null ? null : new File(path);<br/>}<br/><br/>@TypeConverter<br/>public static String fromCategory(final Category value) {<br/>    return value == null ? null : value.name();<br/>}<br/><br/>@TypeConverter<br/>public static Category toCategory(final String name) {<br/>    return name == null ? null : Category.valueOf(name);<br/>}<br/><br/>@TypeConverter<br/>public static String fromAttachmentType(final Attachment.Type value) {<br/>    return value == null ? null : value.name();<br/>}<br/><br/>@TypeConverter<br/>public static Attachment.Type toAttachmentType(final String name) {<br/>    return name == null ? null : Attachment.Type.valueOf(name);<br/>}</pre>
<p>The <kbd>TypeConverter</kbd> methods will be found and used by the Room annotation processor. They are invoked directly from the generated code, based on the types used in the Java classes being stored or retrieved. This means that they have almost no additional runtime overhead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing your Room database</h1>
                </header>
            
            <article>
                
<p>So far, you've built all the components for a Room managed SQLite database, but you still don't actually have access to it. You can't instantiate the <kbd>ClaimDatabase</kbd> class directly because it's abstract, and you have the same problem with the DAO interfaces, so what's the best way to access the database? Room provides you with an entry class that will correctly instantiate the generated <kbd>ClaimDatabase</kbd> implementation, but that isn't the whole story; your entire application relies on this database, and it should be set up when the application starts and should be accessible by the entire application.</p>
<p class="mce-root">You can use a singleton <kbd>ClaimDatabase</kbd> object, but then where will the SQLite database file be placed? In order for it to be stored in your application's private space, you need a Context object. Enter the <kbd>Application</kbd> class, which when used, holds the first <kbd>onCreate</kbd> method that will be invoked in your application. Follow these quick steps to build a simple <kbd>Application</kbd> class that will instantiate and hold a reference to your <kbd>ClaimDatabase</kbd>:</p>
<ol>
<li style="font-weight: 400">Right-click on your root package (that is, <kbd>com.packtpub.claim</kbd>) and select <span class="packt_screen">New | Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>ClaimApplication</kbd>.</li>
<li style="font-weight: 400">Make its <span class="packt_screen">Superclass</span> <kbd>android.app.Application</kbd>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the application class.</li>
<li style="font-weight: 400">Declare a static <kbd>ClaimDatabase</kbd> to be used by the application:</li>
</ol>
<pre>private static ClaimDatabase DATABASE;</pre>
<ol start="6">
<li>Override the <kbd>onCreate</kbd> method and use it to instantiate the <kbd>ClaimDatabase</kbd> object using Room; this will happen before anything else in your application:</li>
</ol>
<pre>@Override<br/>public void onCreate() {<br/>    super.onCreate();<br/>    <strong>DATABASE = Room.databaseBuilder(</strong><br/><strong>            this,</strong>                 /* Context */<br/>            <strong>ClaimDatabase.class,</strong>  /* Abstract Database Class */<br/>            <strong>"Claims"</strong>              /* Filename */ <br/>    <strong>).build();</strong><br/>}</pre>
<ol start="7">
<li>Provide a <kbd>public</kbd> <kbd>static</kbd> method for other parts of the application to use, to access the singleton database instance:</li>
</ol>
<pre>public static ClaimDatabase getClaimDatabase() {<br/>    return DATABASE;<br/>}</pre>
<ol start="8">
<li>You need to register the <kbd>ClaimApplication</kbd> with the Android platform so that it knows to initialize it when the application is started. You do this by opening the <span class="packt_screen">manifests</span> directory and opening the <kbd>AndroidManifest.xml</kbd> file.</li>
<li>In the <kbd>&lt;application&gt;</kbd> element, you'll need to add an <kbd>android:name</kbd> attribute to tell the Android platform the name of the class that represents the root of your application:</li>
</ol>
<pre>&lt;application<br/>    <strong>android:name=".ClaimApplication"</strong><br/>    android:icon="@mipmap/ic_launcher"<br/>    android:label="@string/app_name"<br/>    android:roundIcon="@mipmap/ic_launcher_round"<br/>    android:supportsRtl="true"<br/>    android:theme="@style/AppTheme"&gt;</pre>
<p>Now, whenever any part of your application needs the database, it can simply invoke <kbd>ClaimApplication.getClaimDatabase()</kbd> to retrieve a global instance, and because it's no longer tied to a specific context instance, it can be invoked from anywhere (even a presenter).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<ol>
<li>The Room API for Android provides which of the following?
<ul>
<li style="font-weight: 400">A complete database solution</li>
<li style="font-weight: 400">A lightweight API on top of SQLite</li>
<li style="font-weight: 400">An object storage engine</li>
</ul>
</li>
<li>Returning <kbd>LiveData</kbd> from a Room DAO requires that you do which of these?
<ul>
<li style="font-weight: 400">You observe it for changes in order to retrieve data</li>
<li style="font-weight: 400">You run the query on the main thread</li>
<li style="font-weight: 400">You call the query method again when notified by the <kbd>LiveData</kbd> object</li>
</ul>
</li>
</ol>
<ol start="3">
<li>Database queries that don't return <kbd>LiveData</kbd> should do what?
<ul>
<li style="font-weight: 400">Be avoided</li>
<li style="font-weight: 400">Be run on a worker thread</li>
<li style="font-weight: 400">Return <kbd>Cursor</kbd> objects</li>
</ul>
</li>
<li>Writing an update method for Room requires which of the listed?
<ul>
<li style="font-weight: 400">An <kbd>@Query(“UPDATE</kbd> method on a DAO interface</li>
<li style="font-weight: 400">An <kbd>@Update</kbd> method taking an <kbd>Entity</kbd> object on an interface</li>
<li style="font-weight: 400">Will be added to your <kbd>Entity</kbd> implementations</li>
</ul>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The way you store and retrieve structured data in an Android application has a direct knock-on-effect on how your user will experience your application. When you choose to use a system like Room, CouchDB, or Firebase, where data changes are pushed through the application as updates, the user will naturally have a reactive application. What's more, the application will generally be responsive because these patterns naturally keep slow running queries and updates off the application main thread.</p>
<p class="mce-root">Room provides an excellent addition to the standard Android data storage ecosystem, not only dramatically reducing the need to write boilerplate data access code, but also providing a well-defined and excellently-written interface to run reactive queries for data. Of course, not all of your application needs to be reactive; once an object is delivered via a <kbd>LiveData</kbd> object, it's just an object and can be used as an in-memory snapshot or even edited if it's mutable.</p>
<p class="mce-root">When using Room, it's important to remember that you should avoid complex relationships between objects, because Room won't be able to save and resolve these for you. They're normally a sign that you might need to rethink how you are structuring your data; complex relationships will dramatically slow down the queries and therefore any user interface that depends on them. Typically, these relationships should be handled by creating presentation-specific object models, and then using a join in your query to fetch all the required data. For more information about SQL and how to use it in SQLite, take a look at the SQLite documentation and tutorials on the SQLite project's website, at <a href="https://sqlite.org/">https://sqlite.org/</a>.</p>
<p class="mce-root">In the next chapter, we'll look at building overview screens. These are extremely common start screens in applications; they often form the central screen of an application, somewhere that the user is brought back to again and again during navigation. Android has a massively versatile widget for these screens--the <kbd>RecyclerView</kbd>. Also, we'll explore how to use the <kbd>RecyclerView</kbd>, by coupling it to <kbd>LiveData</kbd> and using Data Binding to keep it up to date with the rest of the application.</p>


            </article>

            
        </section>
    </body></html>