- en: Chapter 3. Exploring the AsyncTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Performing Work with Looper, Handler,
    and HandlerThread"), *Performing Work with Looper, Handler and HandlerThread*,
    we familiarized ourselves with the most basic asynchronous and concurrency constructs
    available on the Android platform: `Handler` and `Looper`. Those constructs underpin
    most of the evented and sequential processing used by the main thread to render
    the UI and to run the Android components life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore `android.os.AsyncTask`, a higher level
    construct that provides us with a neat and lean interface to perform background
    work and publish results back to the main thread without having to manage the
    thread creation and the handler manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AsyncTask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring AsyncTask types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing AsyncTasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing indeterministic progress feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing deterministic progress feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling an AsyncTask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the level of concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common AsyncTask issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications of AsyncTask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing AsyncTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AsyncTask` was introduced on the Android platform with Android Cupcake (API
    Level 3), with the express purpose of helping developers to avoid blocking the
    main thread. The Async part of the name of this class comes from the word asynchronous,
    which literally means that the blocking task is not occurring at the same time
    we call it.'
  prefs: []
  type: TYPE_NORMAL
- en: The `AsyncTask` encloses the creation of the background thread, the synchronization
    with the main thread, and the publishing of the progress of the execution in a
    single construct.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the `Handler` and `Looper` constructs, the `AsyncTask` exempts
    the developer from the management of low level components, thread creation, and
    synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncTask` is an abstract class, and as such, must be subclassed for use.
    At the minimum, our subclass must provide an implementation for the abstract `doInBackground`
    method, which defines the work that we want to get done off the main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doInBackground` is going to be executed in the current process in a parallel
    thread with the priority `THREAD_PRIORITY_BACKGROUND` (Nice level 10)and with
    the name following the next form `AsyncTask #<N>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the method `doInBackground` the construct offers distinct methods
    which the developer might implement in the subclass to set up the task, publish
    progress, and post the final result into the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five other methods of `AsyncTask` which we may choose to override:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Although we could override one or more of these five methods, we will not invoke
    them directly from our own code. These are callback methods, meaning that they
    will be invoked for us (called back) at the appropriate time throughout the `AsyncTask`
    lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference between `doInBackground()` and the other four methods is
    the thread on which they execute.
  prefs: []
  type: TYPE_NORMAL
- en: Before any background work begins, `onPreExecute()` will be invoked and will
    run synchronously to completion on the main thread when we call the execute (Params…)
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `onPreExecute`() method, we could set up the task or any progress dialog
    on the UI to indicate to the user that your task has just begun.
  prefs: []
  type: TYPE_NORMAL
- en: Once `onPreExecute()` completes, `doInBackground()` will be scheduled and will
    start work on a background thread.
  prefs: []
  type: TYPE_NORMAL
- en: During the background work, the developer can publish progress updates from
    `doInBackground()`, which trigger the main thread to execute `onProgressUpdate`
    with the progress values we provide. Internally, the `AsyncTask` makes use of
    a `Handler` bound to the main Thread `Looper` to publish results on the main Thread
    as explained in [Chapter 2](ch02.html "Chapter 2. Performing Work with Looper,
    Handler, and HandlerThread"), *Performing Work with Looper, Handler and HandlerThread*.
  prefs: []
  type: TYPE_NORMAL
- en: By invoking this on the main thread, `AsyncTask` makes it easy for us to update
    the user interface to show progress (remember that we can only update the user
    interface from the main thread).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the background work completes successfully, `doInBackground()` may return
    a result. This result is passed to `onPostExecute(),` which is invoked for us
    on the main thread. With the result received on the `onPostExecute()`, we can
    update the user interface with the results of our background processing:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pattern of passing data from one thread to another is very important, because
    it allows us to run intensive and long tasks away from the crucial main thread.
    This construct simplifies the communication in the main thread and provides a
    high level API for executing asynchronous work on background threads.
  prefs: []
  type: TYPE_NORMAL
- en: Our `AsyncTask` could manipulate fields of the enclosing Activity class, but
    then we would have to take extra precautions, such as adding synchronization to
    prevent race conditions and ensure visibility of updates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing AsyncTask](img/Image_B05062_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: AsyncTask callback execution function'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure displays a sequence of method calls executed by `AsyncTask`,
    illustrating which methods run on the main thread versus the `AsyncTask` background
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `onPreExecute()`, `onProgressUpdate()`, `onPostExecute()`, and `onCancelled()`
    methods are invoked on the main thread, we must not perform long-running/blocking
    operations in these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `AsyncTask` reference invoking the `cancel` method before `doInBackground()`
    completes, `onPostExecute()` will not be called. Instead, the alternative `onCancelled()`
    callback method is invoked on the UI thread so that we can implement different
    behavior for a successful versus cancelled completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing AsyncTask](img/Image_B05062_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: AsyncTask cancelled task execution sequence'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure displays the sequence of method calls when a task is cancelled
    before the `doInBackground()` finishes. Like we have shown in the previous figure,
    the `cancel()` might be called by the main thread or from any other thread with
    access to the `AsyncTask` object reference.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring AsyncTask types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AsyncTask` is a generically typed class that exposes three generic type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In order to use a generic type, we must provide one type argument per type parameter
    that was declared for the generic type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The generic type class provides a way to re-use the same generic algorithms
    for different input types. A generic type could have one or more type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we declare an `AsyncTask` subclass, we''ll specify the types for Params,
    Progress, and Result; for example, if we want to pass a `String` parameter to
    `doInBackground`, report progress as a `Float`, and return a `Boolean` result,
    we would declare our `AsyncTask` subclass as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we don't need to pass any parameters, or don't want to report progress, a
    good type to use for those parameters is `java.lang.Void`, which signals our intent
    clearly, because `Void` is an uninstantiable class representing the void keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only reference types can be used as type arguments of a generic type. This
    includes classes, interfaces, enum types, nested and inner types, and array types.
    Primitive types are not allowed to be used as a type argument. The next declaration
    is considered illegal on a generic type class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at our first example, performing an expensive image download
    in the background and reporting the result into the current UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `DownloadImageTask` extends `AsyncTask`, specifying the Params type as
    a URL so that we can retrieve an image based on its url, Progress as Integer,
    and the Result type as Bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: We pass `ImageView` to the constructor so that `DownloadImageTask` has a weak
    reference to the user interface that it should update upon completion.
  prefs: []
  type: TYPE_NORMAL
- en: We've implemented `doInBackground` to download the image in the background,
    where url is a URL parameter with the image resource location.
  prefs: []
  type: TYPE_NORMAL
- en: In `onPostExecute`, when the view weak reference is not null, we simply load
    the bitmap into the view that we stored in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The `WeakReference` does not prevent the view from being garbage collected when
    the activity where the view was created is no longer active.
  prefs: []
  type: TYPE_NORMAL
- en: Executing AsyncTasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having implemented `doInBackground` and `onPostExecute`, we want to get our
    task running. There are two methods we can use for this, each offering different
    levels of control over the degree of concurrency with which our tasks are executed.
    Let''s look at the simpler of the two methods first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type is the type of our `AsyncTask` subclass, which is simply for
    convenience so that we can use method chaining to instantiate and start a task
    in a single line and still record a reference to the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Params... params` argument is the same Params type we used in our class
    declaration, because the values we supply to the execute method are later passed
    to our `doInBackground` method as its Params... params arguments. Notice that
    it is a varargs (variable number of parameters) parameter, meaning that we can
    pass any number of parameters of that type (including none).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each instance of AsyncTask is a single-use object—once we have started an AsyncTask,
    it can never be started again, even if we cancel it or wait for it to complete
    first.
  prefs: []
  type: TYPE_NORMAL
- en: This is a safety feature, designed to protect us from concurrency issues such
    as the race condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `DownloadImageTask` is straightforward—we need `Activity`, which
    constructs an instance of `DownloadImageTask` with a view to update, and then
    we invoke the `execute` method with a suitable value for the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once we click on the UI show button, a new `DownloadAsyncTask` is created and
    attached to an `imageView` and we call the `execute()` method to start the async
    task in the background. When we call the `execute()` method on the task, this
    will result in a call to the `onPreExecute()` method followed by a call to the
    `doInBackground()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Like we explained before, once the download is finished, the `onPostExecute()`
    is called to load the image downloaded (`Bitmap`) on the image view.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt Publishing books you have
    purchased from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Providing indeterministic progress feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having started what we know to be a potentially long-running task, we probably
    want to let the user know that something is happening. There are a lot of ways
    of doing this, but a common approach is to present a dialog displaying a relevant
    message.
  prefs: []
  type: TYPE_NORMAL
- en: A good place to present our dialog is from the `onPreExecute()` method of `AsyncTask`
    which executes on the main thread so it is allowed to interact with the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified `DownloadImageTask` will need a reference to a Context, so that
    it can prepare a `ProgressDialog`, which it will show and dismiss in `onPreExecute()`
    and `onPostExecute()` respectively. As `doInBackground()` has not changed, it
    is not shown in the following code, for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains is to pass a `Context` to the constructor of our modified
    `DownloadImageTask`. As `Activity` is a subclass of `Context`, we can simply pass
    a reference to the host `Activity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Providing indeterministic progress feedback](img/Image_B05062_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3 : Indeterministic Progress Dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Once the async task is started, the `onPreExecute()` callback will create an
    indeterministic progress dialog and display it as shown in Figure 3.3\. The non-cancelable
    dialog will be placed over the UI screen in an opaque layer with the title defined.
    By indeterministic, we mean that beforehand, we can't estimate how much longer
    we have to wait for the task to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Until the download finishes, and the dialog gets dismissed on `onPostExecute()`,
    the user is not able to interact with the application and the dialog will remain
    in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When any long computation is required before you are able to present your content
    in your application UI, you must present an indication that something is happening
    in the background while the user is waiting.
  prefs: []
  type: TYPE_NORMAL
- en: Providing deterministic progress feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing that something is happening is a great relief to our users, but they
    might be getting impatient and wondering how much longer they need to wait. Let's
    show them how we're getting on by adding a progress bar to our dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we aren't allowed to update the user interface directly from `doInBackground()`,
    because we aren't on the main thread. How, then, can we tell the main thread to
    make these updates for us?
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncTask` comes with a handy callback method for this, whose signature we
    saw at the beginning of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can override `onProgressUpdate()` to update the user interface from the
    main thread, but when does it get called and where does it get its `Progress...
    values` from? The glue between `doInBackground()` and `onProgressUpdate()` is
    another of AsyncTask''s methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To update the user interface with our progress, we simply publish progress updates
    from the background thread by invoking `publishProgress()` from within `doInBackground()`.
    Each time we call `publishProgress()`, the main thread will be scheduled to invoke
    `onProgressUpdate()` for us with these progress values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modifications to our running example to show a deterministic progress bar
    are quite simple. Since we have already defined the `DownloadImageTask` Progress
    type as Integer, now, we must change the setting progress values in the range
    0 (`setProgress`) to 100 (`setMax`) and set the style and the bounds of the progress
    bar. We can do that with the following additions to `onPreExecute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to implement the `onProgressUpdate` callback to update the progress
    bar from the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The final modification is to calculate the progress at each iteration of the
    `for` loop, and invoke `publishProgress()` so that the main thread knows to call
    back `onProgressUpdate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that invoking `publishProgress()` does not directly
    invoke the main thread, but adds a task to the main thread's queue, which will
    be processed at some time in the near future by the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we''re being careful to publish progress only when the percentage
    actually changes, avoiding any unnecessary overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is important to know that every time you invoke `publishProgress()` on the background
    thread, in `downloadBitmat()`, a new Handler message is sent automatically internally
    to push the progress to the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing deterministic progress feedback](img/Image_B05062_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Deterministic Progress Dialog showing the task progress'
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in Figure 3.4, the deterministic dialog created in `onPreExecute()`
    is updated continuously in `doInBackground()` with the current progress of the
    task. The progress is calculated as a ratio, as in the following division:'
  prefs: []
  type: TYPE_NORMAL
- en: The delay between publishing the progress and seeing the user interface update
    will be extremely short for this example and for any application that doesn't
    have too much UI work to process. The progress bar will update smoothly following
    the golden rule of not blocking the main thread for any of our code, since we
    only dispatch a progress update when the percentage changes.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling an AsyncTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another nice usability touch we can provide for our users is the ability to
    cancel a task before it completes—for example, if after starting the execution,
    the user is no longer interested in the operation result. `AsyncTask` provides
    support for cancellation with the cancel method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `mayInterruptIfRunning` parameter allows us to specify whether an AsyncTask
    thread that is in an interruptible state, may actually be interrupted—for example,
    if our doInBackground code is performing a blocking interruptible function, such
    as `Object.wait()`. When we set the `mayInterruptIfRunning` as `false`, the AsyncTask
    won't interrupt the current interruptible blocking operation and the AsyncTask
    background processing will only finish once the blocking operation terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In well behaved interruptible blocking functions, such as `Thread.sleep()`,
    `Thread.join(),` or `Object.wait(),` the execution is stopped immediately when
    the thread is interrupted with `Thread.interrupt()` and it throws an `InterruptedException`.
    The `InterruptedException` should be properly handled and swallowed only if you
    know the background thread is about to exit.
  prefs: []
  type: TYPE_NORMAL
- en: Simply invoking cancel is not sufficient to cause our task to finish early.
    We need to actively support cancellation by periodically checking the value returned
    from `isCancelled` and reacting appropriately in `doInBackground`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s set up our `ProgressDialog` to trigger the AsyncTask''s `cancel`
    method by adding a few lines to `onPreExecute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we can trigger cancel by touching outside the progress dialog, or pressing
    the device's back button while the dialog is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll invoke `cancel` with `false`, as we don''t want to immediately suspend
    the current IO operation during a network read or check the return value of the
    `Thread.interrupted()` function. We still need to check for the cancellation in
    `doInBackground`, so we will modify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, in our Anonymous subclass of `BufferInputStream` we are able
    to intercept each read that happens on the connection. When that is in place,
    and once we cancel the AsyncTask, we are able to stop the data stream by simple
    returning a -1(End of stream) as the result of the read invoke. As soon as the
    `BitmapFactory.decodeStream` receives the end of the stream, it returns immediately
    and we return null as the result of the `downloadBitmap` invoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cancelled `AsyncTask` does not receive the `onPostExecute` callback. Instead,
    we have the opportunity to implement different behavior for a cancelled execution
    by implementing `onCancelled`. There are two variants of this callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The default implementation of the parameterized `onCancelled`(Result result)
    method delegates to the `onCancelled()` method after it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: If AsyncTask cannot provide either a partial result (such as a partial image
    data) or nothing, then we will probably want to override the zero argument `onCancelled()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we are performing an incremental computation in `syncTask`,
    we might choose to override the `onCancelled(Result result)` version when the
    partial result has some meaning to your application.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, since `onPostExecute()` does not get called on a canceled `AsyncTask`,
    we will want to make sure that our `onCancelled()` callbacks update the user interface
    appropriately—in our example, this entails dismissing the progress dialog we opened
    in `onPreExecute()`, and updating the image view with a default image available
    as drawable on the application package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, when the task is cancelled, the result from `doInBackground()`
    is a null object so we will override the no-argument `onCancelled()` function
    to add the behavior described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Another situation to be aware of occurs when we cancel an AsyncTask that has
    not yet begun its `doInBackground()` method. If this happens, `doInBackground()`
    will never be invoked, though `onCancelled()` will still be called on the main
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: AsyncTask Execution State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `execute()` method, could finish in a cancelled state or in a completed
    state, however if the user tries to call `execute()` a second time, the task will
    fail and throw an IllegalStateException exception saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cannot execute task, a task can be executed only once/the task is already
    running*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a reference to an `AsyncTask` object in hand, we can ascertain the status
    of your task over the `getStatus()` method, and react according to the status
    result. Let''s take a look at the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using the `getStatus()` instance method provided by `AsyncTask` we can keep
    up with the execution of the background task and know exactly what the current
    status of your background work is.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to repeat your background you have to instantiate a new task and
    call the `execute()` method again.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The callback methods defined by `AsyncTask` dictate that we cannot throw checked
    exceptions, so we must wrap any code that throws checked exceptions with try/catch
    blocks. Unchecked exceptions that propagate out of `AsyncTask`'s methods will
    crash our application, so we must test carefully and handle these if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: For the callback methods that run on the main thread—`onPreExecute()`, `onProgressUpdate()`,
    `onPostExecute()`, and `onCancelled()`—we can catch exceptions in the method and
    directly update the user interface to alert the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, exceptions are likely to arise in our `doInBackground()` method
    too, as this is where the bulk of the work of `AsyncTask` is done, but unfortunately,
    we can''t update the user interface from `doInBackground()`. A simple solution
    is to have `doInBackground()` return an object that may contain either the result
    or an exception. First we are going to create a generic class for storing the
    result of an operation and a member to store an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step we will create a new download `AsyncTask`, called `SafeDownloadImageTask`,
    that takes care of the exception handling and has a result of type `Result<Bitmap>`
    instead of the `Bitmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can check in `onPostExecute` for the presence of an `Exception` in the
    `Result` object. If there is one, we can deal with it, perhaps by alerting the
    user; otherwise, we just use the actual result as normal and use the bitmap from
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With a safe implementation like the one above, any error thrown on the background
    thread is safely forwarded to the main thread and does not affect the normal lifecycle
    of the `AsyncTask`. Let''s try to retrieve an image that does not exist and see
    if the exception is handled properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the error was caught, wrapped in a `Result` object, and printed
    in the Android log with a stack trace pointing to the `SafeDownloadImageTask.doInBrackground`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the level of concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've carefully avoided being too specific about what exactly happens
    when we invoke the `AsyncTask` execute method. We know that `doInBackground()`
    will execute off the main thread, but what exactly does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: The original goal of `AsyncTask` was created to help developers avoid blocking
    the main thread. In its initial form at API level 3, `AsyncTask`s were queued
    and executed serially (that is, one after the other) on a single background thread,
    guaranteeing that they would complete in the order they were started.
  prefs: []
  type: TYPE_NORMAL
- en: This changed in API level 4 to use a pool of up to 128 threads to execute multiple
    `AsyncTask`s concurrently with each other—a level of concurrency of up to 128\.
    At first glance, this seems like a good thing, since a common use case for `AsyncTask`
    is to perform blocking I/O, where the thread spends much of its time idly waiting
    for data.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we saw in [Chapter 1](ch01.html "Chapter 1. Asynchronous Programming
    in Android"), *Building Responsive Android Applications*, there are many issues
    that commonly arise in concurrent programming, and indeed, the Android team realized
    that by executing `AsyncTask`s concurrently by default, they were exposing developers
    to potential programming problems (for example, when executed concurrently, there
    are no guarantees that `AsyncTask`s will complete in the same order they were
    started).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, a further change was made at API level 11, switching back to serial
    execution by default, and introducing a new method that gives concurrency control
    back to the app developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From API level 11 onwards, we can start AsyncTasks with `executeOnExecutor`,
    and in doing so, choose the level of concurrency for ourselves by supplying an
    Executor object.
  prefs: []
  type: TYPE_NORMAL
- en: Executor is an interface from the `java.util.concurrent` package of the JDK,
    as described in more detail in [Chapter 1](ch01.html "Chapter 1. Asynchronous
    Programming in Android"), *Building Responsive Android Applications*. Its purpose
    is to present a way to submit tasks for execution without spelling out precisely
    how or when the execution will be carried out. Implementations of `Executor` may
    run tasks sequentially using a single thread, use a limited pool of threads to
    control the level of concurrency, or even directly create a new thread for each
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AsyncTask` class provides two Executor instances that allow you to choose
    between the concurrency levels described earlier in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SERIAL_EXECUTOR`: This Executor queues tasks and makes sure that the tasks
    are executed by the AsyncTask ThreadPool sequentially, in the order they were
    submitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREAD_POOL_EXECUTOR`: This `Executor` runs tasks using a pool of threads
    for efficiency (starting a new thread comes with some overhead cost that can be
    avoided through pooling and reuse). `THREAD_POOL_EXECUTOR` is an instance of the
    JDK class `ThreadPoolExecutor`, which uses a pool of threads that grows and shrinks
    with demand. In the case of `AsyncTask`, the pool is configured to maintain at
    least five threads, and expands up to 128 threads. In Android Lollipop 5.0 (API
    Level 21), the maximum number of threads was reduced to the number of CPU cores
    * 2 + 1 and the `ThreadPool` global enqueuing capacity was increased.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To execute `AsyncTask` using a specific executor, we invoke the `executeOnExecutor`
    method, supplying a reference to the executor we want to use, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As the default behavior of execute since API level 11 is to run AsyncTasks
    serially on a single background thread, the following two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next image we will show the differences between the serial executor
    and thread pool when either executors process a group of `AsyncTask` that were
    enqueued sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Controlling the level of concurrency](img/Image_B05062_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding image, the serial executor uses the threads available
    in the `AsyncTask` Thread Pool, however they will only process the next `AsyncTask`
    when the previous `AsyncTask` finishes. Alternatively, `ThreadPoolExecutor` will
    start processing the next task as soon as it has a thread available to do the
    job without guaranteeing that they would complete in the order they were started:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to mention that all the `AsyncTasks` from the system will share
    the same static executor `AsyncTask.THREAD_POOL_EXECUTOR`. For the `SerialExecutor`
    the situation is worse because if an `AsyncTask` is occupying the single executor
    for a long period of time the next tasks will wait on a queue to get processed.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the default executors provided by `AsyncTask` and the ones that are
    available on the `java.util.concurrent`, we can choose to create our own. For
    example, we might want to allow some concurrency by operating off a small pool
    of threads, and allow many tasks to be queued if all threads are currently busy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easily achieved by configuring our own instance of `ThreadPoolExecutor`
    as a static member of one of our own classes—for example, our `Activity` class.
    Here''s how we might configure an executor with a pool of four to eight threads
    and an effectively infinite queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The parameters to the constructor indicate the core pool size (4), the maximum
    pool size (8), the time for which idle additional threads may live in the pool
    before being removed (1), the unit of time (minutes), and the queue to append
    work when the pool threads are occupied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our own Executor is then as simple as invoking our `AsyncTask` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Common AsyncTask issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any powerful programming abstraction, `AsyncTask` is not entirely free
    from issues and compromises. In the next sections we are going to list some of
    the pitfalls that we could face when we want to make use of this construct in
    our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Fragmentation issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Controlling the level of concurrency section, we saw how `AsyncTask`
    has evolved with new releases of the Android platform, resulting in behavior that
    varies with the platform of the device running the task, which is a part of the
    wider issue of fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: The simple fact is that if we target a broad range of API levels, the execution
    characteristics of our `AsyncTask`s—and therefore, the behavior of our apps— can
    vary considerably on different devices. So what can we do to reduce the likelihood
    of encountering AsyncTask issues due to fragmentation?
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious approach is to deliberately target devices running at least
    Honeycomb, by setting a `minSdkVersion` of 11 in the Android Manifest file. This
    neatly puts us in the category of devices, which, by default, execute `AsyncTasks`
    serially, and therefore, much more predictably.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing in October 2015, only 4% of Android devices run a version
    of Android in the danger zone between API Levels 4 and 10, and therefore targeting
    your application to Level 11 would not reduce your market reach significantly.
  prefs: []
  type: TYPE_NORMAL
- en: When the `ThreadPoolExecutor` is used as the executor, the changes introduced
    in Lollipop (API Level 21) could also bring behavior drifts in relation to older
    versions (API Level >10). The modern `AsyncTask's` `ThreadPoolExecutor` is limited
    to the device's CPU cores * 2 + 1 concurrent threads, with an additional queue
    of 128 tasks to queue up work.
  prefs: []
  type: TYPE_NORMAL
- en: A second option is to design our code carefully and test exhaustively on a range
    of devices—always commendable practices of course, but as we've seen, concurrent
    programming is hard enough without the added complexity of fragmentation, and
    invariably, subtle bugs will remain.
  prefs: []
  type: TYPE_NORMAL
- en: A third solution that has been suggested by the Android development community
    is to reimplement `AsyncTask` in a package within your own project, then extend
    your own `AsyncTask` class instead of the SDK version. In this way, you are no
    longer at the mercy of the user's device platform, and can regain control of your
    `AsyncTasks`. Since the source code for `AsyncTask` is readily available, this
    is not difficult to do.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In cases where we keep a reference to an `Activity` or a `View`, we could prevent
    an entire tree of objects from being garbage collected when the activity is destroyed.
    The developer needs to make sure that it cancels the task and removes the reference
    to the destroyed activity or view.
  prefs: []
  type: TYPE_NORMAL
- en: Activity lifecycle issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having deliberately moved any long-running tasks off the main thread, we've
    made our applications nice and responsive—the main thread is free to respond very
    quickly to any user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we have also created a potential problem for ourselves, because
    the main thread is able to finish the Activity before our background tasks complete.
    The Activity might finish for many reasons, including configuration changes caused
    by the user rotating the device (the Activity is destroyed and created again with
    a new address in the memory), the user connecting the device to a docking station,
    or any other kind of context change.
  prefs: []
  type: TYPE_NORMAL
- en: If we continue processing a background task after the Activity has finished,
    we are probably doing unnecessary work, and therefore wasting CPU and other resources
    (including battery life), which could be put to better use.
  prefs: []
  type: TYPE_NORMAL
- en: On occasions after a device rotation, the `AsyncTask` continues to be meaningful
    and has valid content to deliver, however, it has reference to an activity or
    a view that was destroyed and therefore is no longer able to update the UI and
    finish its work and deliver its result.
  prefs: []
  type: TYPE_NORMAL
- en: Also, any object references held by the `AsyncTask` will not be eligible for
    garbage collection until the task explicitly nulls those references or completes
    and is itself eligible for **GC** (**garbage collection**). Since our `AsyncTask`
    probably references the Activity or parts of the View hierarchy, we can easily
    leak a significant amount of memory in this way.
  prefs: []
  type: TYPE_NORMAL
- en: A common usage of `AsyncTask` is to declare it as an anonymous inner class of
    the host Activity, which creates an implicit reference to the Activity and an
    even bigger memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: There are two approaches for preventing these resource wastage problems.
  prefs: []
  type: TYPE_NORMAL
- en: Handling lifecycle issues with early cancellation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First and foremost, we can synchronize our `AsyncTask` lifecycle with that of
    the Activity by canceling running tasks when our Activity is finishing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an `Activity` finishes, its lifecycle callback methods are invoked on
    the main thread. We can check to see why the lifecycle method is being called,
    and if the `Activity` is finishing, cancel the background tasks. The most appropriate
    `Activity` lifecycle method for this is `onPause`, which is guaranteed to be called
    before the `Activity` finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If the `Activity` is not finishing—say, because it has started another `Activity`
    and is still on the back stack—we might simply allow our background task to continue
    to completion.
  prefs: []
  type: TYPE_NORMAL
- en: This solution is straightforward and clean but far from ideal because you might
    waste precious resources by starting over the background work again unaware that
    you might already have a valid result or that your `AsyncTask` is still running.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond that, when you start multiple `AsyncTasks` and start them again when
    the device rotation happens, the waste grows substantially since we have to cancel
    and fire up the same number of tasks again.
  prefs: []
  type: TYPE_NORMAL
- en: Handling lifecycle issues with retained headless fragments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Activit`y is finishing because of a configuration change, it may still
    be useful to use the results of the background task and display them in the restarted
    `Activity`. One pattern for achieving this is through the use of retained Fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments were introduced to Android at API level 11, but are available through
    a support library to applications targeting earlier API Levels. All of the downloadable
    examples use the support library, and target API Levels 7 through 23\. To use
    `Fragment`, our `Activity` must extend the `FragmentActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: The Fragment lifecycle is closely bound to that of the host `Activity`, and
    a fragment will normally be disposed when the activity restarts. However, we can
    explicitly prevent this by invoking `setRetainInstance(true)` on our `Fragment`
    so that it survives across Activity restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a `Fragment` will be responsible for creating and managing at least
    a portion of the user interface of an `Activity`, but this is not mandatory. A
    `Fragment` that does not manage a view of its own is known as a headless `Fragment`.
    Since they do not have a UI related to them, they do not have to be destroyed
    and recreated again when the user rotates the device, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Isolating our `AsyncTask` in a retained headless `Fragment` makes it less likely
    that we will accidentally leak references to objects such as the `View` hierarchy,
    because the `AsyncTask` will no longer directly interact with the user interface.
    To demonstrate this, we''ll start by defining an interface that our `Activity`
    will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll create a retained headless Fragment, which wraps our `AsyncTask`.
    For brevity, `doInBackground` is omitted, as it is unchanged from the previous
    examples—see the downloadable samples for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you might know, a fragment has its lifecycle tied to its own `Activity`,
    and therefore the callbacks are invoked in an orderly fashion following the current
    activity lifecycle events. For example, when the activity is stopped, all the
    fragments attached to it will be detached and notified of the `Activity` state
    change.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we're using the `Fragment` lifecycle methods (`onAttach` and
    `onDetach`) to save or remove the current `Activity` reference in our retained
    fragment.
  prefs: []
  type: TYPE_NORMAL
- en: When the `Activity` gets attached to our fragment, the `onCreate` method is
    invoked to create the private `DownloadImageTask` object and thereafter, the execute
    method is invoked to start the download in the background.
  prefs: []
  type: TYPE_NORMAL
- en: The `newInstance` static method is used to initialize and setup a new fragment,
    without having to call its constructor and a URL setter. As soon as we create
    the fragment object instance, we save the image URL in the bundle object stored
    by the fragment arguments member, using the `setArguments` function. If the Android
    system restores our fragment, it calls the default constructor with no arguments,
    and moreover it could make use of the old bundle to recreate the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the activity gets destroyed and recreated during a configuration change,
    the `setRetainInstance(true)` forces the fragment to survive during the activity
    recycling transition. As you can perceive, this technique could be extremely useful
    in situations where we don't want to reconstruct objects that are expensive to
    recreate again or objects that have an independent lifecycle when an Activity
    is destroyed through a configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to know that the `retainInstance()` can only be used with fragments
    that are not in the back stack. On retained fragments, `onCreate()` and `onDestroy()`
    are not called when the activity is re-attached to a new Activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, our `Fragment` has to manage and execute a `DownloadImageTask`, that
    proxies progress updates and results back to the `Activity` via the `AsyncListener`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As described previously, the `AsyncListener`, is the entity that is responsible
    for updating the UI with the result that will come from our background task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need is the host Activity that implements `AsyncListener` and uses
    `DownloadImageHeadlessFragment` to implement its long-running task. The full source
    code is available to download from the Packt Publishing website, so we''ll just
    take a look at the highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First, when the activity is created in the `onCreate` callback, we check if
    the fragment already exists in `FragmentManager`, and we only create the instance
    if it is missing.
  prefs: []
  type: TYPE_NORMAL
- en: When the fragment is created, we build a fragment instance over the `newInstance`
    method and then we push the fragment to `FragmentManager`, the entity that will
    store and make the transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our `Activity` has been restarted, it will need to re-display the progress
    dialog when a progress update callback is received, so we check and show it if
    necessary, before updating the progress bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `Activity` will need to implement the `onPostExecute` and `onCancelled`
    callbacks defined by `AsyncListener`. The `onPostExecute` will update the `resultView`
    as in the previous examples, and both will do a little cleanup—dismissing the
    dialog and removing Fragment as its work is now done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This technique, well known in the Android development community as a headless
    `Fragment`, is simple and consistent, since it attaches the recreated activity
    to the headless `Fragment` each time a configuration change happens. An activity
    reference is maintained, on the fragment, and updated when the fragment gets attached
    (Activity creation) and gets detached (Activity destroyed).
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of this pattern, the `AsyncTask` never has to follow the unpredictable
    occurrence of configuration changes or worry about UI updates when it finishes
    its work because it forwards the lifecycle callbacks to the current `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Applications of AsyncTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to use `AsyncTask`, we might ask ourselves when we
    should use it.
  prefs: []
  type: TYPE_NORMAL
- en: Good candidate applications for `AsyncTask` tend to be relatively short-lived
    operations (at most, for a second or two), which pertain directly to a specific
    `Fragment` or `Activity` and need to update its user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncTask` is ideal for running short, CPU-intensive tasks, such as number
    crunching or searching for words in large text strings, moving them off the main
    thread so that it can remain responsive to input and maintain high frame rates.'
  prefs: []
  type: TYPE_NORMAL
- en: Blocking I/O operations such as reading and writing text files, or loading images
    from local files with `BitmapFactory` are also good use cases for `AsyncTask`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are use cases for which `AsyncTask` is not ideally suited.
    For anything that requires more than a second or two, we should weigh the cost
    of performing this operation repeatedly if the user rotates the device, or switches
    between apps or activities, or whatever else may be going on that we cannot control.
  prefs: []
  type: TYPE_NORMAL
- en: Taking these things into account, and the rate at which complexity increases
    as we try to deal with them (for example, retained headless fragments!), `AsyncTask`
    starts to lose its shine for longer operations.
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncTask` is often used to fetch data from remote web servers, but this can
    fall foul of the Activity lifecycle issues we looked at earlier. End users may
    be working with a flaky 3G or HSDPA connection, where network latencies and bandwidth
    can vary widely, and a complete HTTP request-response cycle can easily span many
    seconds. This is especially important when we are uploading a significant amount
    of data, such as an image, as the available bandwidth is often asymmetric.'
  prefs: []
  type: TYPE_NORMAL
- en: While we must perform network I/O off the main thread, `AsyncTask` is not necessarily
    the ideal option—as we'll see later; there are more appropriate constructs available
    for offloading this kind of work from the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to compose or chain background processing over `AsyncTasks`, we
    could end up in situation where it is extremely difficult to manage the callbacks
    and coordinate the work so `AsyncTask` will not help you here.
  prefs: []
  type: TYPE_NORMAL
- en: Other techniques will be introduced and detailed in the next chapters for handling
    these kinds of problems in a clear way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've taken a detailed look at `AsyncTask` and how to use it
    to write responsive applications that perform operations without blocking the
    main thread.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to keep users informed of the progress, and even allow them to cancel
    operations early. We also learned how to deal with issues that can arise when
    the Activity lifecycle conspires against our background tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we considered when to use `AsyncTask`, and when it might not be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll learn about Loader—a construct designed to streamline
    the asynchronous loading of data on the Android platform.
  prefs: []
  type: TYPE_NORMAL
