- en: Chapter 3. Exploring the AsyncTask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。探索 `AsyncTask`
- en: 'In [Chapter 2](ch02.html "Chapter 2. Performing Work with Looper, Handler,
    and HandlerThread"), *Performing Work with Looper, Handler and HandlerThread*,
    we familiarized ourselves with the most basic asynchronous and concurrency constructs
    available on the Android platform: `Handler` and `Looper`. Those constructs underpin
    most of the evented and sequential processing used by the main thread to render
    the UI and to run the Android components life cycle.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章。使用 Looper、Handler 和 HandlerThread 执行工作") 中，*使用 Looper、Handler
    和 HandlerThread 执行工作*，我们熟悉了 Android 平台上最基本的后台和并发结构：`Handler` 和 `Looper`。这些结构支撑了主线程用于渲染
    UI 和运行 Android 组件生命周期的几乎所有事件和顺序处理。
- en: In this chapter, we are going to explore `android.os.AsyncTask`, a higher level
    construct that provides us with a neat and lean interface to perform background
    work and publish results back to the main thread without having to manage the
    thread creation and the handler manipulation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 `android.os.AsyncTask`，这是一个高级结构，它为我们提供了一个整洁且精简的接口来执行后台工作，并将结果发布回主线程，而无需管理线程创建和处理器的操作。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing AsyncTask
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 `AsyncTask`
- en: Declaring AsyncTask types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明 `AsyncTask` 类型
- en: Executing AsyncTasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `AsyncTasks`
- en: Providing indeterministic progress feedback
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供不确定的进度反馈
- en: Providing deterministic progress feedback
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供确定的进度反馈
- en: Canceling an AsyncTask
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消 `AsyncTask`
- en: Handling exceptions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Controlling the level of concurrency
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制并发级别
- en: Common AsyncTask issues
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的 `AsyncTask` 问题
- en: Applications of AsyncTask
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncTask` 的应用'
- en: Introducing AsyncTask
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 `AsyncTask`
- en: '`AsyncTask` was introduced on the Android platform with Android Cupcake (API
    Level 3), with the express purpose of helping developers to avoid blocking the
    main thread. The Async part of the name of this class comes from the word asynchronous,
    which literally means that the blocking task is not occurring at the same time
    we call it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 是在 Android 平台的 Android Cupcake（API 级别 3）中引入的，其明确目的是帮助开发者避免阻塞主线程。这个类名中的
    Async 部分来自异步这个词，字面上意味着阻塞的任务不是在我们调用它的时候发生的。'
- en: The `AsyncTask` encloses the creation of the background thread, the synchronization
    with the main thread, and the publishing of the progress of the execution in a
    single construct.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 将后台线程的创建、与主线程的同步以及执行进度的发布封装在一个结构中。'
- en: In contrast to the `Handler` and `Looper` constructs, the `AsyncTask` exempts
    the developer from the management of low level components, thread creation, and
    synchronization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Handler` 和 `Looper` 结构相比，`AsyncTask` 使开发者免于管理低级组件、线程创建和同步。
- en: '`AsyncTask` is an abstract class, and as such, must be subclassed for use.
    At the minimum, our subclass must provide an implementation for the abstract `doInBackground`
    method, which defines the work that we want to get done off the main thread.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 是一个抽象类，因此必须进行子类化才能使用。我们的子类至少必须为抽象的 `doInBackground` 方法提供一个实现，该方法定义了我们想要在主线程之外完成的工作。'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `doInBackground` is going to be executed in the current process in a parallel
    thread with the priority `THREAD_PRIORITY_BACKGROUND` (Nice level 10)and with
    the name following the next form `AsyncTask #<N>`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`doInBackground` 将在当前进程中以 `THREAD_PRIORITY_BACKGROUND`（友好级别 10）的优先级在一个并行线程中执行，并且名称遵循以下格式
    `AsyncTask #<N>`。'
- en: Apart from the method `doInBackground` the construct offers distinct methods
    which the developer might implement in the subclass to set up the task, publish
    progress, and post the final result into the main thread.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `doInBackground` 方法之外，该结构还提供了开发者可以在子类中实现的不同方法，用于设置任务、发布进度和将最终结果发布到主线程。
- en: 'There are five other methods of `AsyncTask` which we may choose to override:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 有五种其他方法，我们可以选择重写：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although we could override one or more of these five methods, we will not invoke
    them directly from our own code. These are callback methods, meaning that they
    will be invoked for us (called back) at the appropriate time throughout the `AsyncTask`
    lifecycle.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以重写这五个方法中的一个或多个，但我们不会直接从自己的代码中调用它们。这些是回调方法，意味着它们将在 `AsyncTask` 生命周期的适当时间为我们调用（回调）。
- en: The key difference between `doInBackground()` and the other four methods is
    the thread on which they execute.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`doInBackground()` 和其他四个方法之间的关键区别是它们执行的线程。'
- en: Before any background work begins, `onPreExecute()` will be invoked and will
    run synchronously to completion on the main thread when we call the execute (Params…)
    method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何后台工作开始之前，`onPreExecute()`将被调用，并且当我们调用execute (Params…)方法时，它将在主线程上同步运行到完成。
- en: In the `onPreExecute`() method, we could set up the task or any progress dialog
    on the UI to indicate to the user that your task has just begun.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onPreExecute()`方法中，我们可以设置任务或任何进度对话框在UI上，以向用户指示任务刚刚开始。
- en: Once `onPreExecute()` completes, `doInBackground()` will be scheduled and will
    start work on a background thread.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`onPreExecute()`完成，`doInBackground()`将被安排，并将在后台线程上开始工作。
- en: During the background work, the developer can publish progress updates from
    `doInBackground()`, which trigger the main thread to execute `onProgressUpdate`
    with the progress values we provide. Internally, the `AsyncTask` makes use of
    a `Handler` bound to the main Thread `Looper` to publish results on the main Thread
    as explained in [Chapter 2](ch02.html "Chapter 2. Performing Work with Looper,
    Handler, and HandlerThread"), *Performing Work with Looper, Handler and HandlerThread*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台工作期间，开发者可以从`doInBackground()`发布进度更新，这会触发主线程执行我们提供的进度值的`onProgressUpdate`。内部，`AsyncTask`使用绑定到主线程`Looper`的`Handler`来在主线程上发布结果，如[第2章](ch02.html
    "第2章。使用Looper、Handler和HandlerThread执行工作")中所述，*使用Looper、Handler和HandlerThread执行工作*。
- en: By invoking this on the main thread, `AsyncTask` makes it easy for us to update
    the user interface to show progress (remember that we can only update the user
    interface from the main thread).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在主线程上调用此方法，`AsyncTask`使我们能够轻松地更新用户界面以显示进度（记住我们只能从主线程更新用户界面）。
- en: 'When the background work completes successfully, `doInBackground()` may return
    a result. This result is passed to `onPostExecute(),` which is invoked for us
    on the main thread. With the result received on the `onPostExecute()`, we can
    update the user interface with the results of our background processing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当后台工作成功完成时，`doInBackground()`可能返回一个结果。这个结果传递给`onPostExecute()`，它将在主线程上为我们调用。在`onPostExecute()`接收到结果后，我们可以使用后台处理的结果更新用户界面：
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This pattern of passing data from one thread to another is very important, because
    it allows us to run intensive and long tasks away from the crucial main thread.
    This construct simplifies the communication in the main thread and provides a
    high level API for executing asynchronous work on background threads.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从一条线程向另一条线程传递数据的方式非常重要，因为它允许我们将密集和长时间的任务从关键的主线程中移开。这种结构简化了主线程中的通信，并为在后台线程上执行异步工作提供了一个高级API。
- en: Our `AsyncTask` could manipulate fields of the enclosing Activity class, but
    then we would have to take extra precautions, such as adding synchronization to
    prevent race conditions and ensure visibility of updates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`AsyncTask`可以操作封装的Activity类的字段，但那时我们必须采取额外的预防措施，例如添加同步来防止竞态条件和确保更新的可见性。
- en: '![Introducing AsyncTask](img/Image_B05062_03_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![介绍AsyncTask](img/Image_B05062_03_01.jpg)'
- en: 'Figure 3.1: AsyncTask callback execution function'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：AsyncTask回调执行函数
- en: The preceding figure displays a sequence of method calls executed by `AsyncTask`,
    illustrating which methods run on the main thread versus the `AsyncTask` background
    thread.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了`AsyncTask`执行的方法调用序列，说明了哪些方法在主线程上运行，哪些在`AsyncTask`后台线程上运行。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since `onPreExecute()`, `onProgressUpdate()`, `onPostExecute()`, and `onCancelled()`
    methods are invoked on the main thread, we must not perform long-running/blocking
    operations in these methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`onPreExecute()`、`onProgressUpdate()`、`onPostExecute()`和`onCancelled()`方法是在主线程上调用的，因此在这些方法中我们不应执行长时间运行/阻塞的操作。
- en: 'With the `AsyncTask` reference invoking the `cancel` method before `doInBackground()`
    completes, `onPostExecute()` will not be called. Instead, the alternative `onCancelled()`
    callback method is invoked on the UI thread so that we can implement different
    behavior for a successful versus cancelled completion:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`doInBackground()`完成之前，通过`AsyncTask`引用调用`cancel`方法，`onPostExecute()`将不会被调用。相反，替代的`onCancelled()`回调方法将在UI线程上被调用，这样我们就可以为成功完成和取消完成实现不同的行为：
- en: '![Introducing AsyncTask](img/Image_B05062_03_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![介绍AsyncTask](img/Image_B05062_03_02.jpg)'
- en: 'Figure 3.2: AsyncTask cancelled task execution sequence'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：AsyncTask取消任务执行序列
- en: The preceding figure displays the sequence of method calls when a task is cancelled
    before the `doInBackground()` finishes. Like we have shown in the previous figure,
    the `cancel()` might be called by the main thread or from any other thread with
    access to the `AsyncTask` object reference.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了在 `doInBackground()` 完成之前取消任务时的方法调用序列。就像我们在前面的图中所示，`cancel()` 可能由主线程或从任何可以访问
    `AsyncTask` 对象引用的其他线程调用。
- en: Declaring AsyncTask types
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明 AsyncTask 类型
- en: '`AsyncTask` is a generically typed class that exposes three generic type parameters:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 是一个泛型类，它公开了三个泛型类型参数：'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In order to use a generic type, we must provide one type argument per type parameter
    that was declared for the generic type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用泛型类型，我们必须为泛型类型中声明的每个类型参数提供一个类型参数。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The generic type class provides a way to re-use the same generic algorithms
    for different input types. A generic type could have one or more type parameters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型类提供了一种方法，可以针对不同的输入类型重用相同的泛型算法。一个泛型类型可以有一个或多个类型参数。
- en: 'When we declare an `AsyncTask` subclass, we''ll specify the types for Params,
    Progress, and Result; for example, if we want to pass a `String` parameter to
    `doInBackground`, report progress as a `Float`, and return a `Boolean` result,
    we would declare our `AsyncTask` subclass as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明 `AsyncTask` 子类时，我们将指定 Params、Progress 和 Result 的类型；例如，如果我们想将 `String`
    参数传递给 `doInBackground`，以 `Float` 报告进度，并返回 `Boolean` 结果，我们就会声明我们的 `AsyncTask` 子类如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we don't need to pass any parameters, or don't want to report progress, a
    good type to use for those parameters is `java.lang.Void`, which signals our intent
    clearly, because `Void` is an uninstantiable class representing the void keyword.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要传递任何参数，或者不想报告进度，对于这些参数使用 `java.lang.Void` 是一个好的选择，因为这可以清楚地表达我们的意图，因为
    `Void` 是一个不可实例化的类，代表 void 关键字。
- en: 'Only reference types can be used as type arguments of a generic type. This
    includes classes, interfaces, enum types, nested and inner types, and array types.
    Primitive types are not allowed to be used as a type argument. The next declaration
    is considered illegal on a generic type class definition:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 只能使用引用类型作为泛型类型的类型参数。这包括类、接口、枚举类型、嵌套和内部类型，以及数组类型。不允许使用原始类型作为类型参数。以下声明在泛型类型类定义中被认为是非法的：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s take a look at our first example, performing an expensive image download
    in the background and reporting the result into the current UI:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的第一个例子，在后台执行昂贵的图像下载并将结果报告到当前 UI：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `DownloadImageTask` extends `AsyncTask`, specifying the Params type as
    a URL so that we can retrieve an image based on its url, Progress as Integer,
    and the Result type as Bitmap.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DownloadImageTask` 扩展了 `AsyncTask`，指定 Params 类型为 URL，以便我们可以根据其 URL 获取图像，Progress
    为 Integer，Result 类型为 Bitmap。
- en: We pass `ImageView` to the constructor so that `DownloadImageTask` has a weak
    reference to the user interface that it should update upon completion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `ImageView` 传递给构造函数，这样 `DownloadImageTask` 就有一个弱引用到它应该在其完成后更新的用户界面。
- en: We've implemented `doInBackground` to download the image in the background,
    where url is a URL parameter with the image resource location.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了 `doInBackground` 以在后台下载图像，其中 url 是一个带有图像资源位置的 URL 参数。
- en: In `onPostExecute`, when the view weak reference is not null, we simply load
    the bitmap into the view that we stored in the constructor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onPostExecute` 中，当视图弱引用不为 null 时，我们只需将位图加载到我们在构造函数中存储的视图中。
- en: The `WeakReference` does not prevent the view from being garbage collected when
    the activity where the view was created is no longer active.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakReference` 在创建视图的活动不再活跃时，不会阻止视图被垃圾回收。'
- en: Executing AsyncTasks
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 AsyncTask
- en: 'Having implemented `doInBackground` and `onPostExecute`, we want to get our
    task running. There are two methods we can use for this, each offering different
    levels of control over the degree of concurrency with which our tasks are executed.
    Let''s look at the simpler of the two methods first:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了 `doInBackground` 和 `onPostExecute` 之后，我们希望让我们的任务运行。我们可以使用两种方法来实现这一点，每种方法都提供了不同级别的控制，以控制任务执行的并发程度。让我们先看看两种方法中较简单的一种：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The return type is the type of our `AsyncTask` subclass, which is simply for
    convenience so that we can use method chaining to instantiate and start a task
    in a single line and still record a reference to the instance:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型是 `AsyncTask` 子类的类型，这只是为了方便，这样我们就可以使用方法链在一个单行中实例化和启动一个任务，同时仍然记录实例的引用：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Params... params` argument is the same Params type we used in our class
    declaration, because the values we supply to the execute method are later passed
    to our `doInBackground` method as its Params... params arguments. Notice that
    it is a varargs (variable number of parameters) parameter, meaning that we can
    pass any number of parameters of that type (including none).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Params... params` 参数与我们在类声明中使用的 Params 类型相同，因为我们提供给 execute 方法的值稍后会被传递给我们的
    `doInBackground` 方法作为其 Params... params 参数。请注意，它是一个可变参数（variable number of parameters）参数，这意味着我们可以传递任何数量的该类型参数（包括零个）。'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each instance of AsyncTask is a single-use object—once we have started an AsyncTask,
    it can never be started again, even if we cancel it or wait for it to complete
    first.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `AsyncTask` 实例都是一个单次使用的对象——一旦我们启动了一个 `AsyncTask`，它就永远不能再次启动，即使我们取消它或等待它完成。
- en: This is a safety feature, designed to protect us from concurrency issues such
    as the race condition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个安全特性，旨在保护我们免受并发问题，如竞态条件的影响。
- en: 'Executing `DownloadImageTask` is straightforward—we need `Activity`, which
    constructs an instance of `DownloadImageTask` with a view to update, and then
    we invoke the `execute` method with a suitable value for the URL:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `DownloadImageTask` 是直接的——我们需要 `Activity`，它使用一个视图来构建 `DownloadImageTask`
    的实例，然后我们使用适合 URL 的值调用 `execute` 方法：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once we click on the UI show button, a new `DownloadAsyncTask` is created and
    attached to an `imageView` and we call the `execute()` method to start the async
    task in the background. When we call the `execute()` method on the task, this
    will result in a call to the `onPreExecute()` method followed by a call to the
    `doInBackground()` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击 UI 显示按钮，就会创建一个新的 `DownloadAsyncTask` 并将其附加到一个 `imageView` 上，然后我们调用 `execute()`
    方法以在后台启动异步任务。当我们对任务调用 `execute()` 方法时，这将导致调用 `onPreExecute()` 方法，然后调用 `doInBackground()`
    方法。
- en: Like we explained before, once the download is finished, the `onPostExecute()`
    is called to load the image downloaded (`Bitmap`) on the image view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，一旦下载完成，就会调用 `onPostExecute()` 来在图像视图中加载下载的图像（`Bitmap`）。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can download the example code files for all Packt Publishing books you have
    purchased from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    Publishing 书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以将文件直接通过电子邮件发送给您。
- en: Providing indeterministic progress feedback
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供不确定进度反馈
- en: Having started what we know to be a potentially long-running task, we probably
    want to let the user know that something is happening. There are a lot of ways
    of doing this, but a common approach is to present a dialog displaying a relevant
    message.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经启动了一个可能需要很长时间才能完成的任务，我们可能想让用户知道正在发生某些事情。有很多种方法可以做到这一点，但一种常见的方法是显示一个显示相关消息的对话框。
- en: A good place to present our dialog is from the `onPreExecute()` method of `AsyncTask`
    which executes on the main thread so it is allowed to interact with the user interface.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AsyncTask` 的 `onPreExecute()` 方法中展示我们的对话框是一个好地方，因为 `AsyncTask` 在主线程上执行，因此允许与用户界面交互。
- en: 'The modified `DownloadImageTask` will need a reference to a Context, so that
    it can prepare a `ProgressDialog`, which it will show and dismiss in `onPreExecute()`
    and `onPostExecute()` respectively. As `doInBackground()` has not changed, it
    is not shown in the following code, for brevity:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的 `DownloadImageTask` 需要一个 `Context` 的引用，以便它可以准备一个 `ProgressDialog`，它将在 `onPreExecute()`
    中显示并在 `onPostExecute()` 中取消显示。由于 `doInBackground()` 没有改变，为了简洁起见，以下代码中没有显示：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All that remains is to pass a `Context` to the constructor of our modified
    `DownloadImageTask`. As `Activity` is a subclass of `Context`, we can simply pass
    a reference to the host `Activity`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是将一个 `Context` 传递给修改后的 `DownloadImageTask` 的构造函数。由于 `Activity` 是 `Context`
    的子类，我们可以简单地传递主机 `Activity` 的引用：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Providing indeterministic progress feedback](img/Image_B05062_03_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![提供不确定进度反馈](img/Image_B05062_03_03.jpg)'
- en: 'Figure 3.3 : Indeterministic Progress Dialog'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：不确定进度对话框
- en: Once the async task is started, the `onPreExecute()` callback will create an
    indeterministic progress dialog and display it as shown in Figure 3.3\. The non-cancelable
    dialog will be placed over the UI screen in an opaque layer with the title defined.
    By indeterministic, we mean that beforehand, we can't estimate how much longer
    we have to wait for the task to complete.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦异步任务开始，`onPreExecute()`回调将创建一个不确定性的进度对话框，并如图3.3所示显示它。这个不可取消的对话框将以不透明的层覆盖在UI屏幕上，并显示标题。我们所说的“不确定”是指在此之前，我们无法估计任务完成还需要等待多长时间。
- en: Until the download finishes, and the dialog gets dismissed on `onPostExecute()`,
    the user is not able to interact with the application and the dialog will remain
    in the foreground.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 直到下载完成，对话框在`onPostExecute()`中被关闭，用户无法与应用程序交互，对话框将保持在前景。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When any long computation is required before you are able to present your content
    in your application UI, you must present an indication that something is happening
    in the background while the user is waiting.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够向你的应用程序UI展示内容之前，需要执行任何长时间的计算时，你必须向用户显示一个指示，表明后台正在发生某些操作，而用户正在等待。
- en: Providing deterministic progress feedback
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供确定性的进度反馈
- en: Knowing that something is happening is a great relief to our users, but they
    might be getting impatient and wondering how much longer they need to wait. Let's
    show them how we're getting on by adding a progress bar to our dialog.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 知道正在发生某些事情对用户来说是一种极大的安慰，但他们可能会变得不耐烦，想知道他们还需要等待多长时间。让我们通过向我们的对话框添加进度条来向他们展示我们的进度。
- en: Remember that we aren't allowed to update the user interface directly from `doInBackground()`,
    because we aren't on the main thread. How, then, can we tell the main thread to
    make these updates for us?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们不允许直接从`doInBackground()`更新用户界面，因为我们不在主线程上。那么，我们如何告诉主线程为我们执行这些更新呢？
- en: '`AsyncTask` comes with a handy callback method for this, whose signature we
    saw at the beginning of the chapter:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`提供了一个方便的回调方法来完成这个任务，我们在本章开头看到了它的签名：'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can override `onProgressUpdate()` to update the user interface from the
    main thread, but when does it get called and where does it get its `Progress...
    values` from? The glue between `doInBackground()` and `onProgressUpdate()` is
    another of AsyncTask''s methods:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写`onProgressUpdate()`来从主线程更新用户界面，但它在何时被调用，以及它从哪里获取`Progress...值`？`doInBackground()`和`onProgressUpdate()`之间的粘合剂是AsyncTask的另一个方法：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To update the user interface with our progress, we simply publish progress updates
    from the background thread by invoking `publishProgress()` from within `doInBackground()`.
    Each time we call `publishProgress()`, the main thread will be scheduled to invoke
    `onProgressUpdate()` for us with these progress values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新用户界面以反映我们的进度，我们只需通过在`doInBackground()`中调用`publishProgress()`从后台线程发布进度更新。每次我们调用`publishProgress()`时，主线程都会被安排调用`onProgressUpdate()`，并带上这些进度值。
- en: 'The modifications to our running example to show a deterministic progress bar
    are quite simple. Since we have already defined the `DownloadImageTask` Progress
    type as Integer, now, we must change the setting progress values in the range
    0 (`setProgress`) to 100 (`setMax`) and set the style and the bounds of the progress
    bar. We can do that with the following additions to `onPreExecute()`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的运行示例进行修改以显示确定性进度条非常简单。由于我们已经将`DownloadImageTask`的Progress类型定义为Integer，现在，我们必须将设置进度值从0（`setProgress`）到100（`setMax`）的范围，并设置进度条的样式和边界。我们可以在`onPreExecute()`中通过以下添加来实现：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also need to implement the `onProgressUpdate` callback to update the progress
    bar from the main thread:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现`onProgressUpdate`回调，以便从主线程更新进度条：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The final modification is to calculate the progress at each iteration of the
    `for` loop, and invoke `publishProgress()` so that the main thread knows to call
    back `onProgressUpdate()`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的修改是在`for`循环的每次迭代中计算进度，并调用`publishProgress()`，以便主线程知道调用`onProgressUpdate()`：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is important to understand that invoking `publishProgress()` does not directly
    invoke the main thread, but adds a task to the main thread's queue, which will
    be processed at some time in the near future by the main thread.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，调用`publishProgress()`并不会直接调用主线程，而是将一个任务添加到主线程的队列中，这个任务将在不久的将来由主线程处理。
- en: 'Notice that we''re being careful to publish progress only when the percentage
    actually changes, avoiding any unnecessary overhead:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们非常小心地只在百分比实际改变时发布进度，以避免任何不必要的开销：
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Is important to know that every time you invoke `publishProgress()` on the background
    thread, in `downloadBitmat()`, a new Handler message is sent automatically internally
    to push the progress to the main thread.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，每次你在后台线程上调用`publishProgress()`，在`downloadBitmat()`中，都会自动发送一个新的Handler消息，将进度推送到主线程。
- en: '![Providing deterministic progress feedback](img/Image_B05062_03_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![提供确定性的进度反馈](img/Image_B05062_03_04.jpg)'
- en: 'Figure 3.4: Deterministic Progress Dialog showing the task progress'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：确定性进度对话框显示任务进度
- en: 'As can be seen in Figure 3.4, the deterministic dialog created in `onPreExecute()`
    is updated continuously in `doInBackground()` with the current progress of the
    task. The progress is calculated as a ratio, as in the following division:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.4所示，在`onPreExecute()`中创建的确定性对话框在`doInBackground()`中会持续更新，显示任务的当前进度。进度是按比例计算的，如下面的除法所示：
- en: The delay between publishing the progress and seeing the user interface update
    will be extremely short for this example and for any application that doesn't
    have too much UI work to process. The progress bar will update smoothly following
    the golden rule of not blocking the main thread for any of our code, since we
    only dispatch a progress update when the percentage changes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例以及任何没有太多UI工作要处理的程序，发布进度和看到用户界面更新之间的延迟将非常短。进度条将根据黄金法则平滑更新，即不阻塞主线程的任何代码，因为我们只在百分比变化时派发进度更新。
- en: Canceling an AsyncTask
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消`AsyncTask`
- en: Another nice usability touch we can provide for our users is the ability to
    cancel a task before it completes—for example, if after starting the execution,
    the user is no longer interested in the operation result. `AsyncTask` provides
    support for cancellation with the cancel method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为用户提供另一个很好的可用性功能，即在任务完成之前取消任务——例如，如果用户在执行开始后不再对操作结果感兴趣。`AsyncTask`通过`cancel`方法提供取消支持。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `mayInterruptIfRunning` parameter allows us to specify whether an AsyncTask
    thread that is in an interruptible state, may actually be interrupted—for example,
    if our doInBackground code is performing a blocking interruptible function, such
    as `Object.wait()`. When we set the `mayInterruptIfRunning` as `false`, the AsyncTask
    won't interrupt the current interruptible blocking operation and the AsyncTask
    background processing will only finish once the blocking operation terminates.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`mayInterruptIfRunning`参数允许我们指定处于可中断状态的`AsyncTask`线程是否可以被实际中断——例如，如果我们的`doInBackground`代码正在执行一个阻塞的可中断函数，如`Object.wait()`。当我们设置`mayInterruptIfRunning`为`false`时，`AsyncTask`不会中断当前的阻塞可中断操作，并且`AsyncTask`的后台处理将仅在阻塞操作终止后完成。'
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In well behaved interruptible blocking functions, such as `Thread.sleep()`,
    `Thread.join(),` or `Object.wait(),` the execution is stopped immediately when
    the thread is interrupted with `Thread.interrupt()` and it throws an `InterruptedException`.
    The `InterruptedException` should be properly handled and swallowed only if you
    know the background thread is about to exit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为良好的可中断阻塞函数中，例如`Thread.sleep()`、`Thread.join()`或`Object.wait()`，当线程被`Thread.interrupt()`中断时，执行会立即停止，并抛出`InterruptedException`。应该适当地处理`InterruptedException`，并且只有当你知道后台线程即将退出时才应该吞没它。
- en: Simply invoking cancel is not sufficient to cause our task to finish early.
    We need to actively support cancellation by periodically checking the value returned
    from `isCancelled` and reacting appropriately in `doInBackground`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地调用取消并不足以使我们的任务提前完成。我们需要通过定期检查`isCancelled`返回的值，并在`doInBackground`中适当地做出反应来积极支持取消。
- en: 'First, let''s set up our `ProgressDialog` to trigger the AsyncTask''s `cancel`
    method by adding a few lines to `onPreExecute`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置我们的`ProgressDialog`，通过在`onPreExecute`中添加几行代码来触发`AsyncTask`的`cancel`方法：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we can trigger cancel by touching outside the progress dialog, or pressing
    the device's back button while the dialog is visible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过触摸进度对话框外部或按设备上的返回按钮来触发取消操作，当对话框可见时。
- en: 'We''ll invoke `cancel` with `false`, as we don''t want to immediately suspend
    the current IO operation during a network read or check the return value of the
    `Thread.interrupted()` function. We still need to check for the cancellation in
    `doInBackground`, so we will modify it as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`false`调用`cancel`，因为我们不希望在执行网络读取或检查`Thread.interrupted()`函数的返回值时立即挂起当前的IO操作。我们仍然需要在`doInBackground`中检查取消操作，因此我们将对其进行如下修改：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the code above, in our Anonymous subclass of `BufferInputStream` we are able
    to intercept each read that happens on the connection. When that is in place,
    and once we cancel the AsyncTask, we are able to stop the data stream by simple
    returning a -1(End of stream) as the result of the read invoke. As soon as the
    `BitmapFactory.decodeStream` receives the end of the stream, it returns immediately
    and we return null as the result of the `downloadBitmap` invoke.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，在我们的 `BufferInputStream` 匿名子类中，我们能够拦截连接上发生的每次读取操作。当这个拦截机制到位后，一旦我们取消
    AsyncTask，我们就可以通过简单地返回读取调用的结果为 -1（流结束）来停止数据流。一旦 `BitmapFactory.decodeStream` 接收到流结束信号，它将立即返回，并且我们将
    `downloadBitmap` 调用的结果返回为 null。
- en: 'The cancelled `AsyncTask` does not receive the `onPostExecute` callback. Instead,
    we have the opportunity to implement different behavior for a cancelled execution
    by implementing `onCancelled`. There are two variants of this callback method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 被取消的 `AsyncTask` 不会收到 `onPostExecute` 回调。相反，我们可以通过实现 `onCancelled` 来实现取消执行的不同行为。这个回调方法有两种变体：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The default implementation of the parameterized `onCancelled`(Result result)
    method delegates to the `onCancelled()` method after it finishes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化的 `onCancelled`(Result result) 方法的默认实现是在完成之后委托给 `onCancelled()` 方法。
- en: If AsyncTask cannot provide either a partial result (such as a partial image
    data) or nothing, then we will probably want to override the zero argument `onCancelled()`
    method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 AsyncTask 无法提供部分结果（例如部分图像数据）或没有任何结果，那么我们可能需要重写无参数的 `onCancelled()` 方法。
- en: On the other hand, if we are performing an incremental computation in `syncTask`,
    we might choose to override the `onCancelled(Result result)` version when the
    partial result has some meaning to your application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们正在 `syncTask` 中执行增量计算，并且部分结果对应用程序有实际意义时，我们可能会选择重写 `onCancelled(Result
    result)` 版本。
- en: In both cases, since `onPostExecute()` does not get called on a canceled `AsyncTask`,
    we will want to make sure that our `onCancelled()` callbacks update the user interface
    appropriately—in our example, this entails dismissing the progress dialog we opened
    in `onPreExecute()`, and updating the image view with a default image available
    as drawable on the application package.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，由于在取消的 `AsyncTask` 上不会调用 `onPostExecute()`，我们想要确保我们的 `onCancelled()`
    回调适当地更新用户界面——在我们的例子中，这包括关闭我们在 `onPreExecute()` 中打开的进度对话框，并使用应用程序包中可用的默认图像更新图像视图。
- en: 'In our example, when the task is cancelled, the result from `doInBackground()`
    is a null object so we will override the no-argument `onCancelled()` function
    to add the behavior described previously:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，当任务被取消时，`doInBackground()` 的结果是 null 对象，因此我们将重写无参数的 `onCancelled()`
    函数来添加之前描述的行为：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another situation to be aware of occurs when we cancel an AsyncTask that has
    not yet begun its `doInBackground()` method. If this happens, `doInBackground()`
    will never be invoked, though `onCancelled()` will still be called on the main
    thread.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的情况是当我们取消尚未开始 `doInBackground()` 方法的 AsyncTask 时。如果发生这种情况，`doInBackground()`
    将不会被调用，尽管 `onCancelled()` 仍然会在主线程上被调用。
- en: AsyncTask Execution State
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AsyncTask 执行状态
- en: 'The `execute()` method, could finish in a cancelled state or in a completed
    state, however if the user tries to call `execute()` a second time, the task will
    fail and throw an IllegalStateException exception saying:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()` 方法可能以取消状态或完成状态结束，然而如果用户尝试第二次调用 `execute()`，任务将失败并抛出 `IllegalStateException`
    异常，表示：'
- en: '*Cannot execute task, a task can be executed only once/the task is already
    running*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*无法执行任务，任务只能执行一次/任务已经在运行*'
- en: 'With a reference to an `AsyncTask` object in hand, we can ascertain the status
    of your task over the `getStatus()` method, and react according to the status
    result. Let''s take a look at the next snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 `AsyncTask` 对象的引用后，我们可以通过 `getStatus()` 方法确定任务的状态，并根据状态结果做出反应。让我们看一下下一个代码片段：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the `getStatus()` instance method provided by `AsyncTask` we can keep
    up with the execution of the background task and know exactly what the current
    status of your background work is.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `AsyncTask` 提供的 `getStatus()` 实例方法，我们可以跟踪后台任务的执行情况，并确切知道后台工作的当前状态。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to repeat your background you have to instantiate a new task and
    call the `execute()` method again.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要重复后台操作，你必须实例化一个新的任务并再次调用 `execute()` 方法。
- en: Handling exceptions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: The callback methods defined by `AsyncTask` dictate that we cannot throw checked
    exceptions, so we must wrap any code that throws checked exceptions with try/catch
    blocks. Unchecked exceptions that propagate out of `AsyncTask`'s methods will
    crash our application, so we must test carefully and handle these if necessary.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由`AsyncTask`定义的回调方法规定我们无法抛出受检异常，因此我们必须将任何抛出受检异常的代码用try/catch块包裹起来。从`AsyncTask`的方法中传播出来的未检查异常会导致我们的应用程序崩溃，因此我们必须仔细测试并在必要时处理这些异常。
- en: For the callback methods that run on the main thread—`onPreExecute()`, `onProgressUpdate()`,
    `onPostExecute()`, and `onCancelled()`—we can catch exceptions in the method and
    directly update the user interface to alert the user.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在主线程上运行的回调方法——`onPreExecute()`、`onProgressUpdate()`、`onPostExecute()`和`onCancelled()`——我们可以在方法中捕获异常并直接更新用户界面以提醒用户。
- en: 'Of course, exceptions are likely to arise in our `doInBackground()` method
    too, as this is where the bulk of the work of `AsyncTask` is done, but unfortunately,
    we can''t update the user interface from `doInBackground()`. A simple solution
    is to have `doInBackground()` return an object that may contain either the result
    or an exception. First we are going to create a generic class for storing the
    result of an operation and a member to store an exception:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，异常也可能出现在我们的`doInBackground()`方法中，因为`AsyncTask`的大部分工作都是在那里完成的，但不幸的是，我们无法从`doInBackground()`更新用户界面。一个简单的解决方案是让`doInBackground()`返回一个可能包含结果或异常的对象。首先，我们将创建一个用于存储操作结果的泛型类和一个用于存储异常的成员：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the next step we will create a new download `AsyncTask`, called `SafeDownloadImageTask`,
    that takes care of the exception handling and has a result of type `Result<Bitmap>`
    instead of the `Bitmap`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将创建一个新的下载`AsyncTask`，称为`SafeDownloadImageTask`，它负责异常处理，并有一个类型为`Result<Bitmap>`的结果，而不是`Bitmap`：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can check in `onPostExecute` for the presence of an `Exception` in the
    `Result` object. If there is one, we can deal with it, perhaps by alerting the
    user; otherwise, we just use the actual result as normal and use the bitmap from
    the result:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`onPostExecute`中检查`Result`对象中是否存在`Exception`。如果有，我们可以处理它，例如通过提醒用户；否则，我们只需像平常一样使用实际的结果，并使用结果中的位图：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With a safe implementation like the one above, any error thrown on the background
    thread is safely forwarded to the main thread and does not affect the normal lifecycle
    of the `AsyncTask`. Let''s try to retrieve an image that does not exist and see
    if the exception is handled properly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述安全实现，后台线程上抛出的任何错误都会安全地转发到主线程，并且不会影响`AsyncTask`的正常生命周期。让我们尝试检索一个不存在的图像，看看异常是否被正确处理：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As expected, the error was caught, wrapped in a `Result` object, and printed
    in the Android log with a stack trace pointing to the `SafeDownloadImageTask.doInBrackground`
    method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，错误被捕获，封装在一个`Result`对象中，并在Android日志中打印出来，堆栈跟踪指向`SafeDownloadImageTask.doInBrackground`方法：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Controlling the level of concurrency
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制并发级别
- en: So far, we've carefully avoided being too specific about what exactly happens
    when we invoke the `AsyncTask` execute method. We know that `doInBackground()`
    will execute off the main thread, but what exactly does that mean?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已小心翼翼地避免过于具体地说明当我们调用`AsyncTask`的execute方法时会发生什么。我们知道`doInBackground()`将在主线程之外执行，但那究竟意味着什么呢？
- en: The original goal of `AsyncTask` was created to help developers avoid blocking
    the main thread. In its initial form at API level 3, `AsyncTask`s were queued
    and executed serially (that is, one after the other) on a single background thread,
    guaranteeing that they would complete in the order they were started.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`的原始目标是帮助开发者避免阻塞主线程。在其API级别3的初始形式中，`AsyncTask`被排队并按顺序（即一个接一个）在一个单独的后台线程上执行，保证了它们会按照启动的顺序完成。'
- en: This changed in API level 4 to use a pool of up to 128 threads to execute multiple
    `AsyncTask`s concurrently with each other—a level of concurrency of up to 128\.
    At first glance, this seems like a good thing, since a common use case for `AsyncTask`
    is to perform blocking I/O, where the thread spends much of its time idly waiting
    for data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这在API级别4中发生了变化，使用最多128个线程的线程池来并发执行多个`AsyncTask`——并发级别高达128。乍一看，这似乎是个好事，因为`AsyncTask`的一个常见用途是执行阻塞I/O，其中线程的大部分时间都在空闲地等待数据。
- en: However, as we saw in [Chapter 1](ch01.html "Chapter 1. Asynchronous Programming
    in Android"), *Building Responsive Android Applications*, there are many issues
    that commonly arise in concurrent programming, and indeed, the Android team realized
    that by executing `AsyncTask`s concurrently by default, they were exposing developers
    to potential programming problems (for example, when executed concurrently, there
    are no guarantees that `AsyncTask`s will complete in the same order they were
    started).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在[第1章](ch01.html "第1章。Android中的异步编程")中看到的，*构建响应式Android应用程序*，在并发编程中经常会出现许多问题，实际上，Android团队意识到，通过默认并发执行`AsyncTask`s，他们使开发者暴露于潜在的编程问题（例如，当并发执行时，没有保证`AsyncTask`s将按它们启动的顺序完成）。
- en: 'As a result, a further change was made at API level 11, switching back to serial
    execution by default, and introducing a new method that gives concurrency control
    back to the app developer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在API级别11上进行了进一步的更改，默认切换回串行执行，并引入了一个新的方法，将并发控制权交回给应用开发者：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From API level 11 onwards, we can start AsyncTasks with `executeOnExecutor`,
    and in doing so, choose the level of concurrency for ourselves by supplying an
    Executor object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从API级别11开始，我们可以使用`executeOnExecutor`启动AsyncTasks，并且通过提供Executor对象，我们可以自己选择并发的级别。
- en: Executor is an interface from the `java.util.concurrent` package of the JDK,
    as described in more detail in [Chapter 1](ch01.html "Chapter 1. Asynchronous
    Programming in Android"), *Building Responsive Android Applications*. Its purpose
    is to present a way to submit tasks for execution without spelling out precisely
    how or when the execution will be carried out. Implementations of `Executor` may
    run tasks sequentially using a single thread, use a limited pool of threads to
    control the level of concurrency, or even directly create a new thread for each
    task.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器是JDK中`java.util.concurrent`包的一个接口，如[第1章](ch01.html "第1章。Android中的异步编程")中更详细地描述的，*构建响应式Android应用程序*。它的目的是提供一个提交任务以供执行的方式，而无需精确说明执行将如何或何时进行。`Executor`的实现可能使用单个线程顺序运行任务，使用有限线程池来控制并发级别，或者甚至为每个任务直接创建一个新线程。
- en: 'The `AsyncTask` class provides two Executor instances that allow you to choose
    between the concurrency levels described earlier in this section:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`类提供了两个执行器实例，允许你选择本节之前描述的并发级别：'
- en: '`SERIAL_EXECUTOR`: This Executor queues tasks and makes sure that the tasks
    are executed by the AsyncTask ThreadPool sequentially, in the order they were
    submitted.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERIAL_EXECUTOR`: 这个执行器将任务排队，并确保任务按提交的顺序由`AsyncTask`线程池顺序执行。'
- en: '`THREAD_POOL_EXECUTOR`: This `Executor` runs tasks using a pool of threads
    for efficiency (starting a new thread comes with some overhead cost that can be
    avoided through pooling and reuse). `THREAD_POOL_EXECUTOR` is an instance of the
    JDK class `ThreadPoolExecutor`, which uses a pool of threads that grows and shrinks
    with demand. In the case of `AsyncTask`, the pool is configured to maintain at
    least five threads, and expands up to 128 threads. In Android Lollipop 5.0 (API
    Level 21), the maximum number of threads was reduced to the number of CPU cores
    * 2 + 1 and the `ThreadPool` global enqueuing capacity was increased.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREAD_POOL_EXECUTOR`: 这个`Executor`通过使用线程池来运行任务以提高效率（启动新线程会带来一些开销，这些开销可以通过池化和重用来避免）。`THREAD_POOL_EXECUTOR`是JDK类`ThreadPoolExecutor`的一个实例，它使用一个线程池，该线程池根据需求增长和缩减。在`AsyncTask`的情况下，线程池被配置为至少维护五个线程，并扩展到128个线程。在Android
    Lollipop 5.0（API级别21）中，线程的最大数量减少到CPU核心数乘以2再加1，并且`ThreadPool`的全局入队容量增加了。'
- en: 'To execute `AsyncTask` using a specific executor, we invoke the `executeOnExecutor`
    method, supplying a reference to the executor we want to use, for example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用特定的执行器执行`AsyncTask`，我们调用`executeOnExecutor`方法，提供我们想要使用的执行器的引用，例如：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As the default behavior of execute since API level 11 is to run AsyncTasks
    serially on a single background thread, the following two statements are equivalent:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API级别11以来执行默认行为是在单个后台线程上串行运行AsyncTasks，以下两个语句是等价的：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the next image we will show the differences between the serial executor
    and thread pool when either executors process a group of `AsyncTask` that were
    enqueued sequentially:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图中，我们将展示串行执行器和线程池在处理按顺序入队的`AsyncTask`组时的区别：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Controlling the level of concurrency](img/Image_B05062_03_05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![控制并发级别](img/Image_B05062_03_05.jpg)'
- en: 'As shown in the preceding image, the serial executor uses the threads available
    in the `AsyncTask` Thread Pool, however they will only process the next `AsyncTask`
    when the previous `AsyncTask` finishes. Alternatively, `ThreadPoolExecutor` will
    start processing the next task as soon as it has a thread available to do the
    job without guaranteeing that they would complete in the order they were started:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，串行执行器使用`AsyncTask`线程池中的可用线程，但它们只有在之前的`AsyncTask`完成时才会处理下一个`AsyncTask`。或者，`ThreadPoolExecutor`将立即开始处理下一个任务，只要它有可用的线程来完成工作，而不保证它们会按照启动的顺序完成：
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to mention that all the `AsyncTasks` from the system will share
    the same static executor `AsyncTask.THREAD_POOL_EXECUTOR`. For the `SerialExecutor`
    the situation is worse because if an `AsyncTask` is occupying the single executor
    for a long period of time the next tasks will wait on a queue to get processed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，系统中的所有`AsyncTasks`都将共享同一个静态执行器`AsyncTask.THREAD_POOL_EXECUTOR`。对于`SerialExecutor`来说，情况更糟，因为如果一个`AsyncTask`长时间占用单个执行器，那么下一个任务将等待在队列中以便处理。
- en: Besides the default executors provided by `AsyncTask` and the ones that are
    available on the `java.util.concurrent`, we can choose to create our own. For
    example, we might want to allow some concurrency by operating off a small pool
    of threads, and allow many tasks to be queued if all threads are currently busy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`AsyncTask`提供的默认执行器和`java.util.concurrent`中可用的执行器之外，我们还可以选择创建自己的。例如，我们可能希望通过操作一小批线程来允许一些并发性，并且当所有线程都忙碌时允许许多任务排队。
- en: 'This is easily achieved by configuring our own instance of `ThreadPoolExecutor`
    as a static member of one of our own classes—for example, our `Activity` class.
    Here''s how we might configure an executor with a pool of four to eight threads
    and an effectively infinite queue:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将我们的`ThreadPoolExecutor`实例配置为我们的某个类（例如我们的`Activity`类）的静态成员来轻松实现。以下是如何配置一个具有四到八线程池和有效无限队列的执行器的方法：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The parameters to the constructor indicate the core pool size (4), the maximum
    pool size (8), the time for which idle additional threads may live in the pool
    before being removed (1), the unit of time (minutes), and the queue to append
    work when the pool threads are occupied.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的参数表示核心池大小（4），最大池大小（8），空闲额外线程在池中被移除之前可以存活的时间（1），时间单位（分钟），以及当池线程忙碌时附加工作的队列。
- en: 'Using our own Executor is then as simple as invoking our `AsyncTask` as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们自己的Executor就像如下调用我们的`AsyncTask`一样简单：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Common AsyncTask issues
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的`AsyncTask`问题
- en: As with any powerful programming abstraction, `AsyncTask` is not entirely free
    from issues and compromises. In the next sections we are going to list some of
    the pitfalls that we could face when we want to make use of this construct in
    our applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何强大的编程抽象一样，`AsyncTask`并非完全没有问题和妥协。在接下来的几节中，我们将列出我们在应用中使用此结构时可能遇到的一些陷阱。
- en: Fragmentation issues
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碎片化问题
- en: In the Controlling the level of concurrency section, we saw how `AsyncTask`
    has evolved with new releases of the Android platform, resulting in behavior that
    varies with the platform of the device running the task, which is a part of the
    wider issue of fragmentation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在“控制并发级别”部分，我们看到了`AsyncTask`如何随着Android平台的新版本发布而发展，导致任务运行设备的平台行为各异，这是碎片化更广泛问题的一部分。
- en: The simple fact is that if we target a broad range of API levels, the execution
    characteristics of our `AsyncTask`s—and therefore, the behavior of our apps— can
    vary considerably on different devices. So what can we do to reduce the likelihood
    of encountering AsyncTask issues due to fragmentation?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果我们针对广泛的API级别，我们的`AsyncTask`的执行特性——因此，我们应用的行为——在不同设备上可能会有很大的差异。那么我们如何减少由于碎片化而遇到`AsyncTask`问题的可能性？
- en: The most obvious approach is to deliberately target devices running at least
    Honeycomb, by setting a `minSdkVersion` of 11 in the Android Manifest file. This
    neatly puts us in the category of devices, which, by default, execute `AsyncTasks`
    serially, and therefore, much more predictably.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的方法是故意针对至少运行Honeycomb的设备，通过在AndroidManifest文件中设置`minSdkVersion`为11。这巧妙地将我们归类到默认情况下以串行方式执行`AsyncTasks`的设备类别，因此行为更加可预测。
- en: At the time of writing in October 2015, only 4% of Android devices run a version
    of Android in the danger zone between API Levels 4 and 10, and therefore targeting
    your application to Level 11 would not reduce your market reach significantly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到2015年10月写作时，只有4%的安卓设备运行在API级别4和10之间的危险区域，因此将你的应用程序定位到11级不会显著减少你的市场覆盖范围。
- en: When the `ThreadPoolExecutor` is used as the executor, the changes introduced
    in Lollipop (API Level 21) could also bring behavior drifts in relation to older
    versions (API Level >10). The modern `AsyncTask's` `ThreadPoolExecutor` is limited
    to the device's CPU cores * 2 + 1 concurrent threads, with an additional queue
    of 128 tasks to queue up work.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`ThreadPoolExecutor`作为执行器时，Lollipop（API级别21）引入的变化也可能导致与旧版本（API级别>10）相关的行为漂移。现代`AsyncTask`的`ThreadPoolExecutor`限制为设备的CPU核心数乘以2加1个并发线程，还有一个额外的128个任务的队列来排队工作。
- en: A second option is to design our code carefully and test exhaustively on a range
    of devices—always commendable practices of course, but as we've seen, concurrent
    programming is hard enough without the added complexity of fragmentation, and
    invariably, subtle bugs will remain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是精心设计我们的代码，并在一系列设备上彻底测试——当然，这是值得赞扬的做法，但正如我们所看到的，在没有碎片化增加复杂性的情况下，并发编程就已经足够困难了，而且不可避免地，微小的错误仍然会存在。
- en: A third solution that has been suggested by the Android development community
    is to reimplement `AsyncTask` in a package within your own project, then extend
    your own `AsyncTask` class instead of the SDK version. In this way, you are no
    longer at the mercy of the user's device platform, and can regain control of your
    `AsyncTasks`. Since the source code for `AsyncTask` is readily available, this
    is not difficult to do.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓开发社区提出的第三种解决方案是在自己的项目中重新实现`AsyncTask`，然后在SDK版本之外扩展自己的`AsyncTask`类。这样，你就不再受用户设备平台的摆布，可以重新控制你的`AsyncTasks`。由于`AsyncTask`的源代码很容易获得，这并不难做到。
- en: Memory leaks
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: In cases where we keep a reference to an `Activity` or a `View`, we could prevent
    an entire tree of objects from being garbage collected when the activity is destroyed.
    The developer needs to make sure that it cancels the task and removes the reference
    to the destroyed activity or view.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们保留对`Activity`或`View`的引用的情况下，我们可以在活动被销毁时防止整个对象树被垃圾回收。开发者需要确保取消任务并移除对已销毁活动或视图的引用。
- en: Activity lifecycle issues
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动生命周期问题
- en: Having deliberately moved any long-running tasks off the main thread, we've
    made our applications nice and responsive—the main thread is free to respond very
    quickly to any user interaction.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将任何长时间运行的任务从主线程移除，这使得我们的应用程序变得非常响应——主线程可以快速响应用户的任何交互。
- en: Unfortunately, we have also created a potential problem for ourselves, because
    the main thread is able to finish the Activity before our background tasks complete.
    The Activity might finish for many reasons, including configuration changes caused
    by the user rotating the device (the Activity is destroyed and created again with
    a new address in the memory), the user connecting the device to a docking station,
    or any other kind of context change.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们也为自己创造了一个潜在的问题，因为主线程能够在我们的后台任务完成之前完成Activity。Activity可能因为多种原因而结束，包括用户旋转设备导致的配置更改（Activity被销毁并再次创建，带有新的内存地址），用户将设备连接到坞站，或任何其他类型的上下文更改。
- en: If we continue processing a background task after the Activity has finished,
    we are probably doing unnecessary work, and therefore wasting CPU and other resources
    (including battery life), which could be put to better use.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在活动结束后继续处理后台任务，我们可能正在进行不必要的操作，因此浪费CPU和其他资源（包括电池寿命），这些资源本可以用于更好的用途。
- en: On occasions after a device rotation, the `AsyncTask` continues to be meaningful
    and has valid content to deliver, however, it has reference to an activity or
    a view that was destroyed and therefore is no longer able to update the UI and
    finish its work and deliver its result.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备旋转后的某些情况下，`AsyncTask`仍然有意义，并且有有效的内容要交付，然而，它引用了一个已销毁的活动或视图，因此不再能够更新UI并完成其工作以及交付其结果。
- en: Also, any object references held by the `AsyncTask` will not be eligible for
    garbage collection until the task explicitly nulls those references or completes
    and is itself eligible for **GC** (**garbage collection**). Since our `AsyncTask`
    probably references the Activity or parts of the View hierarchy, we can easily
    leak a significant amount of memory in this way.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AsyncTask`持有的任何对象引用在任务明确null化这些引用或完成并自身符合**GC**（**垃圾回收**）条件之前，都不符合垃圾收集的资格。由于我们的`AsyncTask`可能引用了活动或视图层次结构的一部分，我们很容易以这种方式泄露大量的内存。
- en: A common usage of `AsyncTask` is to declare it as an anonymous inner class of
    the host Activity, which creates an implicit reference to the Activity and an
    even bigger memory leak.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`的常见用法是将它声明为主活动的一个匿名内部类，这会创建对活动的隐式引用，并导致更大的内存泄漏。'
- en: There are two approaches for preventing these resource wastage problems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这些资源浪费问题有两种方法。
- en: Handling lifecycle issues with early cancellation
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用早期取消处理生命周期问题
- en: First and foremost, we can synchronize our `AsyncTask` lifecycle with that of
    the Activity by canceling running tasks when our Activity is finishing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过在活动结束时取消正在运行的任务来同步我们的`AsyncTask`生命周期与活动。
- en: 'When an `Activity` finishes, its lifecycle callback methods are invoked on
    the main thread. We can check to see why the lifecycle method is being called,
    and if the `Activity` is finishing, cancel the background tasks. The most appropriate
    `Activity` lifecycle method for this is `onPause`, which is guaranteed to be called
    before the `Activity` finishes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个`Activity`结束时，其生命周期回调方法会在主线程上被调用。我们可以检查生命周期方法被调用的原因，如果活动正在结束，则取消后台任务。最适合此目的的`Activity`生命周期方法是`onPause`，它在活动结束时一定会被调用：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the `Activity` is not finishing—say, because it has started another `Activity`
    and is still on the back stack—we might simply allow our background task to continue
    to completion.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Activity`没有结束——比如说，因为它启动了另一个`Activity`并且仍然在后台栈上——我们可能简单地允许我们的后台任务继续完成。
- en: This solution is straightforward and clean but far from ideal because you might
    waste precious resources by starting over the background work again unaware that
    you might already have a valid result or that your `AsyncTask` is still running.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案简单明了，但远非理想，因为你可能会在不了解你可能已经有一个有效结果或你的`AsyncTask`仍在运行的情况下，再次启动后台工作，从而浪费宝贵的资源。
- en: Beyond that, when you start multiple `AsyncTasks` and start them again when
    the device rotation happens, the waste grows substantially since we have to cancel
    and fire up the same number of tasks again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你启动多个`AsyncTasks`，并在设备旋转时再次启动它们时，浪费会大幅增加，因为我们不得不再次取消并启动相同数量的任务。
- en: Handling lifecycle issues with retained headless fragments
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用保留的无头`Fragments`处理生命周期问题
- en: If the `Activit`y is finishing because of a configuration change, it may still
    be useful to use the results of the background task and display them in the restarted
    `Activity`. One pattern for achieving this is through the use of retained Fragments.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Activit`y因为配置更改而结束，仍然可能有用的是使用后台任务的结果并在重新启动的`Activit`y中显示它们。实现这一点的模式之一是通过使用保留的`Fragments`。
- en: Fragments were introduced to Android at API level 11, but are available through
    a support library to applications targeting earlier API Levels. All of the downloadable
    examples use the support library, and target API Levels 7 through 23\. To use
    `Fragment`, our `Activity` must extend the `FragmentActivity` class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fragments`是在Android API级别11中引入的，但可以通过支持库提供给针对更早API级别的应用程序。所有可下载的示例都使用支持库，并针对API级别7到23。要使用`Fragment`，我们的`Activity`必须扩展`FragmentActivity`类。'
- en: The Fragment lifecycle is closely bound to that of the host `Activity`, and
    a fragment will normally be disposed when the activity restarts. However, we can
    explicitly prevent this by invoking `setRetainInstance(true)` on our `Fragment`
    so that it survives across Activity restarts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fragment`的生命周期与宿主`Activit`y的生命周期紧密相连，并且当活动重新启动时，`Fragment`通常会销毁。然而，我们可以通过在`Fragment`上调用`setRetainInstance(true)`来显式地防止这种情况，使其能够在活动重新启动后继续存在。'
- en: Typically, a `Fragment` will be responsible for creating and managing at least
    a portion of the user interface of an `Activity`, but this is not mandatory. A
    `Fragment` that does not manage a view of its own is known as a headless `Fragment`.
    Since they do not have a UI related to them, they do not have to be destroyed
    and recreated again when the user rotates the device, for example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个`Fragment`将负责创建和管理`Activity`用户界面的一部分，但这不是强制性的。不管理自身视图的`Fragment`被称为无头`Fragment`。由于它们没有与之相关的UI，因此当用户旋转设备时，它们不需要被销毁和重新创建。
- en: 'Isolating our `AsyncTask` in a retained headless `Fragment` makes it less likely
    that we will accidentally leak references to objects such as the `View` hierarchy,
    because the `AsyncTask` will no longer directly interact with the user interface.
    To demonstrate this, we''ll start by defining an interface that our `Activity`
    will implement:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`AsyncTask`隔离在保留的无头`Fragment`中，使得我们意外泄露对诸如`View`层次结构等对象的引用的可能性降低，因为`AsyncTask`将不再直接与用户界面交互。为了演示这一点，我们首先定义一个我们的`Activity`将实现的接口：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, we'll create a retained headless Fragment, which wraps our `AsyncTask`.
    For brevity, `doInBackground` is omitted, as it is unchanged from the previous
    examples—see the downloadable samples for the complete code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个保留的无头`Fragment`，它封装了我们的`AsyncTask`。为了简洁，省略了`doInBackground`，因为它与前面的示例没有变化——请参阅可下载的示例以获取完整的代码。
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you might know, a fragment has its lifecycle tied to its own `Activity`,
    and therefore the callbacks are invoked in an orderly fashion following the current
    activity lifecycle events. For example, when the activity is stopped, all the
    fragments attached to it will be detached and notified of the `Activity` state
    change.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，一个片段的生命周期与其自身的`Activity`紧密相连，因此回调函数会按照当前活动生命周期事件的顺序有序调用。例如，当活动停止时，所有附加到该活动的片段都将被分离并通知`Activity`状态变化。
- en: In our example, we're using the `Fragment` lifecycle methods (`onAttach` and
    `onDetach`) to save or remove the current `Activity` reference in our retained
    fragment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`Fragment`生命周期方法（`onAttach`和`onDetach`）在保留片段中保存或删除当前的`Activity`引用。
- en: When the `Activity` gets attached to our fragment, the `onCreate` method is
    invoked to create the private `DownloadImageTask` object and thereafter, the execute
    method is invoked to start the download in the background.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Activity`附加到我们的片段时，会调用`onCreate`方法来创建私有的`DownloadImageTask`对象，然后调用`execute`方法在后台开始下载。
- en: The `newInstance` static method is used to initialize and setup a new fragment,
    without having to call its constructor and a URL setter. As soon as we create
    the fragment object instance, we save the image URL in the bundle object stored
    by the fragment arguments member, using the `setArguments` function. If the Android
    system restores our fragment, it calls the default constructor with no arguments,
    and moreover it could make use of the old bundle to recreate the fragment.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`newInstance`静态方法用于初始化和设置一个新的片段，无需调用其构造函数和URL设置器。一旦我们创建了片段对象实例，我们就会使用`setArguments`函数将图像URL保存到由片段参数成员存储的bundle对象中。如果Android系统恢复我们的片段，它将调用不带参数的默认构造函数，并且还可以利用旧的bundle来重新创建片段。'
- en: Whenever the activity gets destroyed and recreated during a configuration change,
    the `setRetainInstance(true)` forces the fragment to survive during the activity
    recycling transition. As you can perceive, this technique could be extremely useful
    in situations where we don't want to reconstruct objects that are expensive to
    recreate again or objects that have an independent lifecycle when an Activity
    is destroyed through a configuration change.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置更改期间，每当活动被销毁和重新创建时，`setRetainInstance(true)`强制片段在活动回收过渡期间存活。正如你所感知的，这种技术在某些情况下可能非常有用，在这些情况下我们不希望重建那些难以重新创建的对象，或者当活动通过配置更改被销毁时具有独立生命周期的对象。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to know that the `retainInstance()` can only be used with fragments
    that are not in the back stack. On retained fragments, `onCreate()` and `onDestroy()`
    are not called when the activity is re-attached to a new Activity.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，`retainInstance()`只能与不在返回栈中的片段一起使用。在保留片段上，当活动重新附加到新的`Activity`时，`onCreate()`和`onDestroy()`不会被调用。
- en: 'Next, our `Fragment` has to manage and execute a `DownloadImageTask`, that
    proxies progress updates and results back to the `Activity` via the `AsyncListener`
    interface:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的`Fragment`必须管理和执行一个`DownloadImageTask`，该任务通过`AsyncListener`接口代理进度更新和结果回传到`Activity`：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As described previously, the `AsyncListener`, is the entity that is responsible
    for updating the UI with the result that will come from our background task.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`AsyncListener` 是负责使用从我们的后台任务中获取的结果更新 UI 的实体。
- en: 'Now, all we need is the host Activity that implements `AsyncListener` and uses
    `DownloadImageHeadlessFragment` to implement its long-running task. The full source
    code is available to download from the Packt Publishing website, so we''ll just
    take a look at the highlights:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要一个实现了 `AsyncListener` 并使用 `DownloadImageHeadlessFragment` 来实现其长时间运行任务的主
    Activity。完整的源代码可以从 Packt Publishing 网站下载，所以我们将只关注亮点：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, when the activity is created in the `onCreate` callback, we check if
    the fragment already exists in `FragmentManager`, and we only create the instance
    if it is missing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当活动在 `onCreate` 回调中创建时，我们检查 Fragment 是否已存在于 `FragmentManager` 中，并且只有在它缺失时才创建其实例。
- en: When the fragment is created, we build a fragment instance over the `newInstance`
    method and then we push the fragment to `FragmentManager`, the entity that will
    store and make the transition.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Fragment 创建时，我们通过 `newInstance` 方法构建一个 Fragment 实例，然后将 Fragment 推送到 `FragmentManager`，该实体将存储并执行转换。
- en: 'If our `Activity` has been restarted, it will need to re-display the progress
    dialog when a progress update callback is received, so we check and show it if
    necessary, before updating the progress bar:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 `Activity` 已经被重新启动，当接收到进度更新回调时，它需要重新显示进度对话框，因此我们在更新进度条之前检查并显示它（如果需要的话）：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, `Activity` will need to implement the `onPostExecute` and `onCancelled`
    callbacks defined by `AsyncListener`. The `onPostExecute` will update the `resultView`
    as in the previous examples, and both will do a little cleanup—dismissing the
    dialog and removing Fragment as its work is now done:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Activity` 需要实现 `AsyncListener` 定义的 `onPostExecute` 和 `onCancelled` 回调。`onPostExecute`
    将更新 `resultView`，就像之前的示例一样，两者都会进行一些清理工作——关闭对话框并移除 Fragment，因为其工作已经完成：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This technique, well known in the Android development community as a headless
    `Fragment`, is simple and consistent, since it attaches the recreated activity
    to the headless `Fragment` each time a configuration change happens. An activity
    reference is maintained, on the fragment, and updated when the fragment gets attached
    (Activity creation) and gets detached (Activity destroyed).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术，在 Android 开发社区中广为人知，被称为无头 `Fragment`，简单且一致，因为它在每次配置更改发生时将重新创建的活动附加到无头 `Fragment`
    上。在 Fragment 上维护一个活动引用，并在 Fragment 附加（活动创建）和分离（活动销毁）时更新。
- en: Taking advantage of this pattern, the `AsyncTask` never has to follow the unpredictable
    occurrence of configuration changes or worry about UI updates when it finishes
    its work because it forwards the lifecycle callbacks to the current `Activity`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这种模式，`AsyncTask` 永远不必跟随配置更改的不可预测发生，或者担心在完成工作后进行 UI 更新，因为它将生命周期回调转发到当前的 `Activity`。
- en: Applications of AsyncTask
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AsyncTask` 的应用'
- en: Now that we have seen how to use `AsyncTask`, we might ask ourselves when we
    should use it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用 `AsyncTask`，我们可能会问自己何时应该使用它。
- en: Good candidate applications for `AsyncTask` tend to be relatively short-lived
    operations (at most, for a second or two), which pertain directly to a specific
    `Fragment` or `Activity` and need to update its user interface.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于 `AsyncTask` 的良好候选应用通常是相对短暂的操作（最多一秒或两秒），这些操作直接关联到特定的 `Fragment` 或 `Activity`，并需要更新其用户界面。
- en: '`AsyncTask` is ideal for running short, CPU-intensive tasks, such as number
    crunching or searching for words in large text strings, moving them off the main
    thread so that it can remain responsive to input and maintain high frame rates.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 对于运行短时间、CPU 密集型任务（如数值计算或在大文本字符串中搜索单词）非常理想，这样可以将其从主线程移除，以便保持对输入的响应性并维持高帧率。'
- en: Blocking I/O operations such as reading and writing text files, or loading images
    from local files with `BitmapFactory` are also good use cases for `AsyncTask`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞 I/O 操作，如读取和写入文本文件，或使用 `BitmapFactory` 从本地文件加载图像，也是 `AsyncTask` 的良好用例。
- en: Of course, there are use cases for which `AsyncTask` is not ideally suited.
    For anything that requires more than a second or two, we should weigh the cost
    of performing this operation repeatedly if the user rotates the device, or switches
    between apps or activities, or whatever else may be going on that we cannot control.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于 `AsyncTask` 来说不太适合的场景也存在。对于任何需要超过一秒或两秒的操作，如果用户旋转设备，或者在不同应用或活动之间切换，或者发生我们无法控制的其他情况，我们应该权衡重复执行此操作的成本。
- en: Taking these things into account, and the rate at which complexity increases
    as we try to deal with them (for example, retained headless fragments!), `AsyncTask`
    starts to lose its shine for longer operations.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，以及我们在尝试处理它们时复杂性的增加速度（例如，保留的无头片段！），`AsyncTask` 在处理长时间操作时开始失去其光泽。
- en: '`AsyncTask` is often used to fetch data from remote web servers, but this can
    fall foul of the Activity lifecycle issues we looked at earlier. End users may
    be working with a flaky 3G or HSDPA connection, where network latencies and bandwidth
    can vary widely, and a complete HTTP request-response cycle can easily span many
    seconds. This is especially important when we are uploading a significant amount
    of data, such as an image, as the available bandwidth is often asymmetric.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 通常用于从远程网络服务器获取数据，但这可能会遇到我们之前探讨的活动生命周期问题。最终用户可能在使用不稳定的 3G 或 HSDPA
    连接，其中网络延迟和带宽可能差异很大，一个完整的 HTTP 请求-响应周期可能轻易跨越数秒。当我们上传大量数据时，例如图像，这一点尤为重要，因为可用带宽通常是不对称的。'
- en: While we must perform network I/O off the main thread, `AsyncTask` is not necessarily
    the ideal option—as we'll see later; there are more appropriate constructs available
    for offloading this kind of work from the main thread.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们必须在主线程之外执行网络 I/O，但 `AsyncTask` 并不一定是最理想的选择——正如我们稍后将会看到的；还有更多适合从主线程卸载此类工作的结构。
- en: When we want to compose or chain background processing over `AsyncTasks`, we
    could end up in situation where it is extremely difficult to manage the callbacks
    and coordinate the work so `AsyncTask` will not help you here.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在 `AsyncTasks` 上组合或链式处理后台处理时，我们可能会陷入一个难以管理回调和协调工作的情况，因此 `AsyncTask` 在这里不会帮到你。
- en: Other techniques will be introduced and detailed in the next chapters for handling
    these kinds of problems in a clear way.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍并详细说明其他技术，以清晰的方式处理这些类型的问题。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've taken a detailed look at `AsyncTask` and how to use it
    to write responsive applications that perform operations without blocking the
    main thread.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了 `AsyncTask` 及其如何用于编写响应式应用程序，这些应用程序可以在不阻塞主线程的情况下执行操作。
- en: We saw how to keep users informed of the progress, and even allow them to cancel
    operations early. We also learned how to deal with issues that can arise when
    the Activity lifecycle conspires against our background tasks.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何让用户了解进度，甚至允许他们提前取消操作。我们还学习了如何处理当活动生命周期与我们后台任务作对时可能出现的问题。
- en: Finally, we considered when to use `AsyncTask`, and when it might not be appropriate.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们考虑了何时使用 `AsyncTask`，以及何时可能不合适。
- en: In the next chapter we'll learn about Loader—a construct designed to streamline
    the asynchronous loading of data on the Android platform.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于 Loader 的内容——这是一个旨在简化 Android 平台上异步加载数据的结构。
