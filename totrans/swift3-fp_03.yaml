- en: Chapter 3. Types and Type casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter starts with explaining types, touching on the concept of type in
    the category theory very briefly. Then, it explains value and reference types
    and compares them in detail. Finally, it talks about equality, identity, and type
    casting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics with coding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value versus reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value and reference type constants
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing value and reference types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Value type characteristics
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Equality, identity, and comparing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type checking and casting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may have heard that functional programming uses concepts of the category
    theory. This link is the reason why some people find functional programming closer
    to mathematics. In an upcoming chapter, we will talk briefly about the category
    theory so we are not going to dive into those concepts now. At this point, it
    is good to know that theoretically category refers to a collection that contains
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of objects (types in Swift)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of morphisms, each of which ties two objects together (functions
    in Swift)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A notion of composition of the morphisms (function composition in Swift)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already discussed functions and function composition and now we are
    going to explore types.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to categorize types in two different ways. The first is the concept
    of named types and compound types in Swift. The second is the categorization of
    types based on value versus reference.
  prefs: []
  type: TYPE_NORMAL
- en: Any type that we can give a name to while we define it is a named type. For
    instance, if we create a class named `OurClass`, any instance of `OurClass` will
    be of the `OurClass` type.
  prefs: []
  type: TYPE_NORMAL
- en: Function types and tuple types are compound types. A compound type may contain
    named types and other compound types. For instance, `(String, (Double, Double))`
    is a compound type and in fact is a tuple of `String` and another tuple of the
    `(Double, Double)` type.
  prefs: []
  type: TYPE_NORMAL
- en: We can use named types and compound types in type annotation, identification,
    and aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we have seen that we can use Swift inference that infers
    the types unless we want to specify the type explicitly. We annotate the type
    in case we need to specify the type explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we did not talk a lot about reference versus value types and type casting.
    In the following sections of this chapter, we will explore these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Value versus reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, there are two kinds of types: value and reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value type instances keep a copy of their data. Each type has its own data
    and is not referenced by another variable. `Structures`, `enums`, and `tuples`
    are value types; therefore, they do not share data between their instances. Assignments
    copy the data of an instance to the other and there is no reference counting involved.
    The following example presents a `struct` with copying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As seen from the preceding example, changing `valueA.data` does not change `valueB.data`.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, arrays, dictionaries, strings, and sets are all value types.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, reference type instances share the same copy of the data.
    Classes and closures are reference types so assignment only adds a reference but
    does not copy the data. In fact, initialization of a reference type creates a
    shared instance that will be used by different instances of a reference type such
    as class or closure. Two variables of the same class type will refer to a single
    instance of the data, so if we modify the data in one of the variables, it will
    also affect the other variable. The following example presents a class with referencing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As seen from the preceding example, changing `referenceA.data` also changes
    `referenceB.data` as they refer to the same shared instance.
  prefs: []
  type: TYPE_NORMAL
- en: This fundamental difference between value and reference types can have a huge
    impact on our system architecture. In functional programming, it is recommended
    to prefer value types over reference types as it is easier to trace and reason
    about value types. As we always get a unique copy of data and the data is not
    shared among instances, we can reason that no other part of our program is going
    to change the data. This feature of value types makes them especially helpful
    in multithreaded environments where a different thread will be able to change
    our data without informing us. This can create bugs that are very hard to debug
    and fix.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use this feature in Swift with classes, we can develop immutable
    classes using only immutable stored properties and avoiding exposing any APIs
    that can alter state. However, Swift does not provide any language mechanism to
    enforce class immutability the way it enforces immutability for `struct` and `enum`.
    Any API user can subclass our provided class and make it mutable unless we define
    them as **final**. This is not the case with `struct`, `enum`, and `tuples` as
    basically we cannot subclass them.
  prefs: []
  type: TYPE_NORMAL
- en: Value and reference type constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constants behave differently if they are value or reference types. We will be
    able to change the variables in a constant class but we cannot change them for
    structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a class named `User` and two constants that point to
    the instance of the class. Also, we have a `Student` `struct` that has a variable
    of the `User` type.
  prefs: []
  type: TYPE_NORMAL
- en: We create `student` using the `Student` structure. If we try to change the `user`
    variable in `student`, the compiler gives us an error telling that `student` is
    a constant even though we defined `user` as a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we cannot change any variable in `struct` if we instantiate it as a constant.
    In other words, `let student = Student(user: julie)` makes the whole `struct`
    immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try the same operation with classes. In the following code, we change
    the name of `steve`, which is defined as a constant. The compiler does not give
    us an error and accepts this assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even though we defined `steve` as a constant, we could change the `name` variable
    as it was a `class`.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding examples, we have seen that we can change the value of a
    variable on a constant that is an instance of a `class` (reference type), but
    we cannot change the value of a variable on a constant that is an instance of
    a `struct` (value type).
  prefs: []
  type: TYPE_NORMAL
- en: As `steve` is an instance of a reference type, it refers to the instance of
    `User`. When we change `name`, we are not actually changing what `steve` is, which
    is a reference to `User`. We change the name that we made mutable by defining
    it as a variable. This is not the case for our `student` constant as it is a value
    type. Defining it as a constant makes its variables constant too.
  prefs: []
  type: TYPE_NORMAL
- en: This property of reference types makes them hard to track and since we are defining
    them as constants, it is not going to make them immune to changes. To be able
    to make them immutable, we will need to define their properties as constants.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing value and reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In real-world problems, we may need to mix reference types with value types.
    For instance, we may need to have a reference to `class` in `struct` like our
    previous example or we may need to have a `struct` variable in `class`. How would
    we reason about the assignments and copying in these circumstances?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a `User` class, a `Student` struct that has the user
    variable. We define a constant, `student` with `julie`, which is of the `class`
    type. If we print `student.user.name`, the result will be `julie`.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we define `anotherStudent` and copy `student` to it by assignment, changing
    the name of Julie will change the name of `anotherStudent` too.
  prefs: []
  type: TYPE_NORMAL
- en: We would expect `anotherStudent` to have a copy of `student` but `name` has
    been changed. It is changed because the `user` variable is of the `User` type,
    which is `class` and therefore a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: This example presents the complexity of using reference types in value types.
    To avoid these complications, it is recommended to avoid using reference type
    variables inside value types. If we need to use reference types in our value types,
    as we have stated before, we should define them as constants.
  prefs: []
  type: TYPE_NORMAL
- en: Copying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assignment operations on value types copy values from one value type to another
    value type. There are two types of copying in different programming languages,
    shallow and deep copying.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow copying duplicates as little as possible. For instance, a shallow copy
    of a collection is a copy of the collection structure, not its elements. With
    a shallow copy, two collections share the same individual elements.
  prefs: []
  type: TYPE_NORMAL
- en: Deep copying duplicates everything. For instance, a deep copy of a collection
    results in another collection with all of the elements in the original collection
    duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift does the shallow copying and does not provide a mechanism for deep copying.
    Let''s examine an example to understand shallow copying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created a new `User` named `alain` and added three
    users to a new array named `users`. In the following example, we copy the `users`
    array to a new array named `copyOfUsers`. Then we change the name of one of our
    users in the `users` array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Printing `users` and `copyOfUsers` will show us that changing `name` of `Alain`
    to `Jean-Marc` in the `users` array has changed the name of `Alain` in `copyOfUsers`
    to `Jean-Marc` too. The `users` and `copyOfUsers` are arrays, and we would expect
    assignment expression to copy the values from `users` to `copyOfUsers` as arrays
    are value types but, as we have seen from the preceding example, changing the
    name of `user` in one array changed the username in the copied array. There are
    two reasons for this behavior. First of all, `User` is a type of `class`. So it
    is a reference type. Secondly, Swift does the shallow copying.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow copying does not provide a distinct copy of an instance as we have seen
    in this example. Shallow copying duplicates the references to the same elements
    of the instance. So again, this example presents complications with using reference
    types in value types as Swift does not provide deep copying to overcome these
    complications.
  prefs: []
  type: TYPE_NORMAL
- en: Copying reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two variables can point to the same object so changing one variable changes
    the other too. Having lots of objects point to the same data can be useful in
    some circumstances, but mostly we will want to modify copies so that modifying
    one object doesn''t have an effect on the others. To make this work, we need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Our class should be of the `NSObject` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our class should conform to the `NSCopying` protocol (which is not mandatory
    but makes our intent clear for our API user)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our class should implement the `copy(with: NSZone)` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To copy the object, we will need to call the `copy()` method on the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of a `Manager` class that conforms fully to the `NSCopying`
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copyWithZone()` function is implemented by creating a new `Manager` object
    using the information of current `Manager`. To test our class, we create two instances
    and copy one instance over the other as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Value type characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have examined the notion of value types and reference types. We have looked
    into simple scenarios of value type versus reference type usage. We understand
    that using value types makes our code simpler and easier to trace and reason.
    Now let's look into the characteristics of value types in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Value types do not behave. A value type stores data and provides methods to
    use its data. A value type can only have a single owner and it does not have deinitializers
    as there are no references involved. Some of the value type methods may cause
    the value type to mutate itself, but control flow is rigidly controlled by the
    single owner of the instance. As the code will only execute when directly invoked
    by a single owner and not from many sources, it is easy to reason about the value
    type code execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a reference type might subscribe itself as a target of other
    systems. It might receive notifications from other systems. This sort of interactions
    require reference types as they can have multiple owners. It's unnecessarily difficult
    to develop value types that perform side effects on their own in most of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical value type has no implicit dependencies on the behavior of any external
    system. Therefore, a value type is isolated. It interacts only with its owner
    and it is easy to understand how it interacts in comparison to a reference type's
    interactions with multiple number of owners.
  prefs: []
  type: TYPE_NORMAL
- en: If we access a reference to a mutable instance, we have an implicit dependency
    on all its other owners and they could change the instance at any time without
    notifying us.
  prefs: []
  type: TYPE_NORMAL
- en: Interchangeability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a value type is copied when it is assigned to a new variable, all of those
    copies are completely interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: We can safely store a value that is passed to us, then later utilize this value
    as if it were a new value. It will not be possible to compare the instance with
    another instance using anything but its data.
  prefs: []
  type: TYPE_NORMAL
- en: Interchangeability also means that it does not matter how a given value was
    defined. Two value types are equal by all means if comparing them via `==` results
    in equality.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no need for a mocking framework to write unit tests that deal with
    value types. We can directly define values indistinguishable from the instances
    in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: If we use reference types that behave, we have to test the interactions between
    the reference type that we will test and the rest of the system. This typically
    means a lot of mocking or extensive setup code to establish the required relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, value types are isolated and interchangeable, so we can directly
    define a value, call a method, and examine the result. Simpler tests with greater
    coverage yield a code that is easier to change and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Threats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the structure of value types encourages testability, isolation, and interchangeability,
    one can define value types that diminish these advantages. Value types containing
    code that executes without being called by its owner are generally hard to track
    and reason about, and should often be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Also, value types containing reference types are not necessarily isolated. Using
    reference types in value types should generally be avoided as they are dependent
    on all other owners of that referent. These kinds of value types are also not
    easily interchangeable as the external reference might interact with the rest
    of the system and cause some complications.
  prefs: []
  type: TYPE_NORMAL
- en: Using value and reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The Swift Programming Language (Swift 3.0)* by*Apple Inc.* has a section on
    comparing structs (value type) and classes (reference type) and how to prefer
    one over the other. It is highly recommended to read that section to understand
    why we prefer one over the other. Although we touched on the topic briefly in
    *[Chapter 1](ch01.html "Chapter 1. Getting Started with Functional Programming
    in Swift")* , *Getting Started With Functional Programming in Swift*, we will
    explore this topic further as the distinction between reference and value types
    is very important in functional programming.'
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, we model real-world objects as classes and interfaces.
    For instance, to model an Italian restaurant with different types of pizzas, we
    may have a pizza object and subclasses of it such as margherita, napoletana, or
    romana. Each of these pizzas will have different ingredients. Different restaurants
    may make them slightly differently, and whenever we read their recipes in different
    books or websites, we may understand it differently. This level of abstraction
    enables us to refer to a specific pizza without caring about how other people
    really imagine that pizza. Whenever we talk about that pizza, we do not transfer
    it, we just refer to it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in our Italian restaurant, we will need to provide bills
    to our customers. Whenever they ask for the bill, we are going to provide real
    information about quantity and prices. Anyone has the same perception about quantities,
    prices in dollars, and in fact values. Our customers can calculate the invoice
    total. If our customers modify the bill, it is not going to modify the source
    that we used to provide the bill. No matter if they write something on the bill
    or spill wine on it, the value and bill total amount is not going to change. The
    preceding example presents a simple real-world usage of reference versus value
    types. Value types and reference types have their own usages in the Swift programming
    language and in web, mobile, or desktop application programming.
  prefs: []
  type: TYPE_NORMAL
- en: Value types enable us to make architectures clearer, simpler, and more testable.
    Value types typically have fewer or no dependencies on the outside state, so there's
    less that we have to consider when reasoning about them.
  prefs: []
  type: TYPE_NORMAL
- en: Also, value types are essentially more reusable because they are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: As we use more value types and immutable entities, our system will become easier
    to test and maintain over time.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, reference types are acting entities in the system. They have identity.
    They can behave. Their behavior is often complex and hard to reason about, but
    some of the details can usually be represented by simple values and isolated functions
    involving those values.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types maintain state defined by values, but these values can be considered
    independently of the reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types perform side effects such as I/O, file and database operations,
    and networking.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types can interact with other reference types, but they generally
    send values, not references, unless they truly plan to create a persistent connection
    with the external system.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to use value types (`enums`, `tuples`, or `structs`) as much
    as possible unless we need to create a shared mutable state. There are cases where
    we have to use classes. For instance, when we work with **Cocoa**, many APIs expect
    subclasses of `NSObject` so we have to use classes in these cases. Whenever we
    need to use classes, we avoid variables; we define our properties as constants
    and avoid exposing any APIs that can alter states.
  prefs: []
  type: TYPE_NORMAL
- en: Equality versus identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two instances are equal if they have the same value. Equality is used to determine
    the equality of two value types. For instance, two `Strings` are equal if they
    have the same text value. The `==` operator is used to check for equality. The
    following example presents equality checking for two `Int` numbers (`Int` is a
    value type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, two instances are identical if they refer to the same instance
    of memory. Identity is used to determine if two reference types are identical.
    The `===` operator is used to check for identity. The following example presents
    identity checking for two instances of the `User` class that we have defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The identity checking operator is available only for reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Equatable and Comparable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are able to compare two value types such as `String`, `Int`, and `Double`,
    but we cannot compare two value types that we have developed. To make our custom
    value types comparable, we need to implement Equatable and Comparable protocols.
    Let''s first examine an example of equality checking without conforming to protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the compiler will complain that **Binary operator ''=='' cannot
    be applied to two ''Point'' operands**. Let''s fix this problem by conforming
    to the `Equatable` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The value for `isEqual` is going to be false as they are not equal. To be able
    to compare two points, we need to conform to the `Comparable` protocol. Our example
    becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The result of the comparison will be true.
  prefs: []
  type: TYPE_NORMAL
- en: Type checking and casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swift provides type checking and type casting. We can check the type of a variable
    with the `is` keyword. It is most commonly used in `if` statements, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As `String` is a value type and the compiler can infer the type, the Swift
    compiler will issue a warning because it already knows that `aConstant` is `String`.
    Another example can be the following, where we check whether `anyString` is `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using the `is` operator is useful to check the type of a class instance, specifically,
    the ones that have subclasses. We can use the `is` operator to determine if an
    object is an instance of a specific class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can use the `as` operator to actually coerce an object to another
    type than what the compiler has inferred it to be. The `as` operator comes in
    two flavors: the plain `as` operator and `as?`. The former casts the object into
    the desired type without asking. If the object cannot be cast to that type, a
    runtime error is thrown. The `as?` operator asks an object if it can be cast to
    a given type. If the object can be cast, then *some* value is returned; otherwise,
    `nil` is returned. The `as?` operator is most often used as part of an `if` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, it's best to use `as?` whenever possible. We should use `as` only
    if we know it will not result in a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked into types in general and explored reference versus
    value types in detail. We covered topics such as value and reference type constants,
    mixing value and reference types, and copying. Then we learned the characteristics
    of value types, key differences between value and reference types, and how we
    should decide which one to use. We continued by exploring equality, identity,
    type checking, and casting topics. Even though we explored the topic of value
    types, we did not explore a related topic—immutability—in this chapter. [Chapter
    9](ch09.html "Chapter 9. Importance of Immutability") , *Importance of Immutability* will
    cover the importance of immutability.Furthermore, for in depth coverage of these
    concepts it is recommended to watch the following videos from: WWDC 2015 - Session
    414, WWDC 2016 - Session 418, and WWDC 2016 - Session 419.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore the enumeration and pattern matching
    topics. We will familiarize ourselves with associated and raw values. We will
    be introduced to algebraic data types and finally, we will cover patterns and
    pattern matching.
  prefs: []
  type: TYPE_NORMAL
