<html><head></head><body>
		<div><h1 id="_idParaDest-183" class="chapter-number"><a id="_idTextAnchor329"/><st c="0">10</st></h1>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor330"/><st c="3">Swift Macros</st></h1>
			<p><st c="16">Developers frequently encounter various challenges with their IDEs, often related to missing functionalities, mostly about missing functionalities. </st><st c="165">With each new Xcode or Swift version, Apple introduces additional features that enhance productivity and simplify tasks. </st><st c="286">However, even Apple has a hard time fulfilling our needs and demands. </st><st c="356">Fortunately, this time, we can create customized functionalities using </st><st c="427">Swift Macros.</st></p>
			<p><strong class="bold"><st c="440">Swift Macros</st></strong><st c="453"> is an</st><a id="_idIndexMarker549"/><st c="459"> exciting new feature added to Xcode 15 and iOS 17, and this chapter will help us increase our productivity by achieving more from </st><st c="590">our IDE.</st></p>
			<p><st c="598">In this chapter, we will cover the </st><st c="634">following topics:</st></p>
			<ul>
				<li><st c="651">Learning about </st><st c="667">Swift Macros</st></li>
				<li><st c="679">Exploring the </st><code><st c="694">SwiftSyntax</st></code><st c="705"> library, which stands behind </st><st c="735">Swift Macros</st></li>
				<li><st c="747">Creating our first </st><st c="767">Swift macro</st></li>
				<li><st c="778">Handling errors and providing more clarity when something </st><st c="837">goes wrong</st></li>
				<li><st c="847">Testing our macro, making sure it runs as expected </st><st c="899">over time</st></li>
			</ul>
			<p><st c="908">But now, let’s start with the basics and discover </st><st c="959">Swift Macros.</st></p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor331"/><st c="972">Technical requirements</st></h1>
			<p><st c="995">You must download Xcode version 16.0 or above for this chapter from Apple’s </st><st c="1072">App Store.</st></p>
			<p><st c="1082">You’ll also need to run the latest version of macOS (Ventura or above). </st><st c="1155">Search for Xcode in the App Store and select and download the latest version. </st><st c="1233">Launch Xcode and follow any additional installation instructions that your system may prompt you with. </st><st c="1336">Once Xcode has fully launched, you’re ready </st><st c="1380">to go.</st></p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor332"/><st c="1386">What is a Swift macro?</st></h1>
			<p><st c="1409">You probably heard the term “macro” before in the context of programming. </st><st c="1484">That’s perhaps because programming languages such as C/C++ have macros </st><st c="1555">as well.</st></p>
			<p><st c="1563">A </st><strong class="bold"><st c="1566">macro</st></strong><st c="1571"> is a</st><a id="_idIndexMarker550"/><st c="1576"> structure that lets us define a code pattern that is being replaced by the compiler with a specific set </st><st c="1681">of instructions.</st></p>
			<p><st c="1697">Let’s see a short </st><st c="1716">C example:</st></p>
			<pre class="source-code"><st c="1726">
#define SQUARE(x) ((x) * (x))
int num = 5;
int result = SQUARE(num);</st></pre>			<p><st c="1795">In our preceding code, we declare a macro called </st><code><st c="1845">SQUARE</st></code><st c="1851"> that receives one parameter named </st><code><st c="1886">X</st></code><st c="1887">, and our compiler replaces it with </st><code><st c="1923">(</st></code><code><st c="1924">x) *(x)</st></code><st c="1931">.</st></p>
			<p><st c="1932">The initial question that comes to mind is this: why? </st><st c="1987">Can’t we just define </st><st c="2008">a function?</st></p>
			<p><st c="2019">So, in this case, a simple function that calculates a number’s square can be </st><st c="2097">helpful here.</st></p>
			<p><st c="2110">But a macro’s primary goal is not to</st><a id="_idIndexMarker551"/><st c="2147"> replace functions, as they are great for </st><st c="2189">several reasons:</st></p>
			<ul>
				<li><strong class="bold"><st c="2205">Code reuse</st></strong><st c="2216">: Notice that code reuse is not “functionality reuse.” Code reuse is where we take an actual code snippet and reuse it in different places. </st><st c="2357">For example, if we constantly repeat the same line sequence when declaring a class, a macro can help us avoid </st><st c="2467">repeating ourselves.</st></li>
				<li><strong class="bold"><st c="2487">Improve abstraction</st></strong><st c="2507">: Macros can help us add another abstraction layer to our code. </st><st c="2572">Imagine writing a macro that generates functions declaration. </st><st c="2634">That’s another level we can construct </st><st c="2672">our code.</st></li>
				<li><strong class="bold"><st c="2681">Performance</st></strong><st c="2693">: In some cases, macros can help us optimize our code. </st><st c="2749">Sometimes, the trade-off between optimization and readability/simplicity can be solved using a macro. </st><st c="2851">A macro can generate a piece of harder-to-read code and yet be optimized. </st><st c="2925">One feature that macro can optimize code for is </st><strong class="bold"><st c="2973">loop unrolling</st></strong><st c="2987"> – a way to </st><a id="_idIndexMarker552"/><st c="2999">iterate a loop faster with instruction-level parallelism. </st><st c="3057">Loop unrolling </st><a id="_idIndexMarker553"/><st c="3072">produces less </st><a id="_idIndexMarker554"/><st c="3086">readable code but is </st><st c="3107">much quicker.</st></li>
			</ul>
			<p><st c="3120">In the bottom line, a macro</st><a id="_idIndexMarker555"/><st c="3148"> is just a tool that replaces one code with another and inserts a specific code snippet before the compile time. </st><st c="3261">But C macros</st><a id="_idIndexMarker556"/><st c="3273"> are full of issues. </st><st c="3294">They are difficult to test, not type-safety, their errors are not clear enough, and sharing them with other developers is not trivial. </st><st c="3429">As part of Xcode 15, the Swift team released a new tool called </st><strong class="bold"><st c="3492">Swift Macros</st></strong><st c="3504"> – the </st><a id="_idIndexMarker557"/><st c="3511">Swift version of macros that lets us create macros more efficiently </st><st c="3579">and elegantly.</st></p>
			<p><st c="3593">Let’s go over a simple </st><a id="_idIndexMarker558"/><st c="3617">example of </st><st c="3628">macro usage.</st></p>
			<p><st c="3640">In our project, we want to add a macro that adds a function named</st><code><st c="3706"> log(issue:String)</st></code><st c="3724"> to classes and structs. </st><st c="3749">That function prints an issue to our log and adds the class or the struct name. </st><st c="3829">We can call that macro </st><code><st c="3852">@AddDebugLogger</st></code><st c="3867">, and we can use it </st><st c="3887">as follows:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="3898">@AddDebugerLogger</st></strong><st c="3916">
class MyClass {
}</st></pre>			<p><st c="3934">In the preceding code, we declared a class named </st><code><st c="3984">MyClass</st></code><st c="3991"> and attached a macro named </st><code><st c="4019">@AddDebugerLogger</st></code><st c="4036">, which expands to the </st><st c="4059">following code:</st></p>
			<pre class="source-code"><st c="4074">
class MyClass {
    func printLog(issue: String) {
        #if DEBUG
        print("In class named MyClass - \(issue)")
        #endif
    }
}</st></pre>			<p><st c="4185">The macro adds a function named </st><code><st c="4218">printLog()</st></code><st c="4228">, which prints an issue to the console while mentioning the class name as part of the log message. </st><st c="4327">This serves as an example of primary macro usage, illustrating the capabilities of </st><st c="4410">this tool.</st></p>
			<p><st c="4420">But how is the macro familiar with the class name? </st><st c="4472">How does it generate a new function in the right place inside the class? </st><st c="4545">To answer these questions, we first need to meet </st><code><st c="4594">SwiftSyntax</st></code><st c="4605">, a </st><a id="_idIndexMarker559"/><st c="4609">library that stands in the heart of </st><st c="4645">Swift Macros.</st></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor333"/><st c="4658">Exploring SwiftSyntax</st></h1>
			<p><code><st c="4680">SwiftSyntax</st></code><st c="4692"> is not a </st><a id="_idIndexMarker560"/><st c="4702">new library, and it’s part of Swift’s code base from its early beginnings. </st><st c="4777">In fact, Swift Macros is part of </st><code><st c="4810">SwiftSyntax</st></code><st c="4821">, and it uses </st><st c="4835">its capabilities.</st></p>
			<p><st c="4852">Before we dive into </st><code><st c="4873">SwiftSyntax</st></code><st c="4884"> (and there’s enough to dive into it), let’s learn about how the Swift compiler works (</st><em class="italic"><st c="4971">Figure 10</st></em><em class="italic"><st c="4981">.1</st></em><st c="4983">):</st></p>
			<div><div><img src="img/B21795_figure_10.01.jpg" alt="Figure 10.1: The Swift compiler process"/><st c="4986"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4988">Figure 10.1: The Swift compiler process</st></p>
			<p><st c="5027">Don’t fear the different expressions you see in </st><em class="italic"><st c="5076">Figure 10</st></em><em class="italic"><st c="5085">.1</st></em><st c="5087">. This figure is a high-level overview of how the compiler takes our source code and generates machine code our device can run (the </st><code><st c="5219">*.o</st></code><st c="5222"> files). </st><st c="5231">We don’t have to understand every step in that flow, but knowing how it works is essential, especially where </st><code><st c="5340">SwiftSyntax</st></code><st c="5351"> fits in </st><st c="5360">the process.</st></p>
			<p><st c="5372">Let’s go over the </st><st c="5391">steps together:</st></p>
			<ol>
				<li><strong class="bold"><st c="5406">Parse and abstract syntax tree (AST)</st></strong><st c="5443">: The</st><a id="_idIndexMarker561"/><st c="5449"> compiler takes our source code and builds an AST. </st><st c="5500">The AST represents our code hierarchical structure, including classes, structs, variables, </st><st c="5591">and expressions.</st></li>
				<li><strong class="bold"><st c="5607">Semantic analysis (sema)</st></strong><st c="5632">: In this </st><a id="_idIndexMarker562"/><st c="5643">phase, the compiler takes our generated AST and performs semantic analysis. </st><st c="5719">The analysis looks out for semantic issues in our code and goes over issues such as type-checking name resolutions and more (when we see “semantic” issues in our build phase; that’s the result of </st><st c="5915">this phase).</st></li>
				<li><strong class="bold"><st c="5927">Swift Intermediate Language Generation (SILGen)</st></strong><st c="5975">: In this phase, the compiler</st><a id="_idIndexMarker563"/><st c="6005"> generates a representation that captures the semantic structure of </st><st c="6073">the code.</st></li>
				<li><strong class="bold"><st c="6082">Intermediate Representation Generation (IRGen)</st></strong><st c="6129">: In IRGen, the</st><a id="_idIndexMarker564"/><st c="6145">	 compiler takes the SILGen result and </st><a id="_idIndexMarker565"/><st c="6183">converts it to a binary close to machine-level code. </st><st c="6236">This process is done with the help</st><a id="_idIndexMarker566"/><st c="6270"> of </st><strong class="bold"><st c="6274">Low-Level Virtual Machine</st></strong><st c="6299"> (</st><strong class="bold"><st c="6301">LLVM</st></strong><st c="6305">), and the code goes through </st><st c="6335">several optimizations.</st></li>
				<li><strong class="bold"><st c="6357">LLVM linking</st></strong><st c="6370">: The LLVM </st><a id="_idIndexMarker567"/><st c="6382">links everything together and prepares our code for the final </st><st c="6444">binary creation.</st></li>
			</ol>
			<p><st c="6460">The process may look scary and complex, but remember that this is a significant enrichment for us as iOS developers and is not required for Swift Macros understanding. </st><st c="6629">I demonstrated it because of the first two steps – parse and AST. </st><st c="6695">Let’s talk about them for </st><st c="6721">a second.</st></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor334"/><st c="6730">Parsing and AST</st></h2>
			<p><st c="6746">Parsing Swift code</st><a id="_idIndexMarker568"/><st c="6765"> is not an easy task. </st><st c="6787">In addition, building the AST is even </st><st c="6825">more complex.</st></p>
			<p><st c="6838">In the building process, we just saw the parsing, and the AST is handled by the </st><code><st c="6919">SwiftSyntax</st></code><st c="6930"> library. </st><st c="6940">So, when </st><a id="_idIndexMarker569"/><st c="6949">we work with the </st><code><st c="6966">SwiftSyntax</st></code><st c="6977"> library, we have the full compiler capabilities. </st><st c="7027">This means we can parse code, analyze it, and even generate new code like the compiler. </st><st c="7115">The </st><code><st c="7119">SwiftSyntax</st></code><st c="7130"> library is a powerful and essential tool when working with Swift macros because when we think of it, it is what Swift macros are all about – understanding the given code and generating a </st><st c="7318">new one.</st></p>
			<p><st c="7326">We understand that learning SwiftSyntax is a prerequisite for writing Swift macros, so let’s </st><st c="7420">dive in.</st></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor335"/><st c="7428">Setting up SwiftSyntax</st></h2>
			<p><code><st c="7451">SwiftSyntax</st></code><st c="7463"> is a </st><strong class="bold"><st c="7469">Swift package</st></strong><st c="7482">, meaning </st><a id="_idIndexMarker570"/><st c="7492">it can be linked easily to an existing iOS or </st><st c="7538">macOS project.</st></p>
			<p class="callout-heading"><st c="7552">What is a Swift package?</st></p>
			<p class="callout"><st c="7577">A Swift package</st><a id="_idIndexMarker571"/><st c="7593"> is a unit of code distribution in Swift. </st><st c="7635">It’s a way to organize, share, and manage Swift code across </st><st c="7695">different projects.</st></p>
			<p><st c="7714">To play with and</st><a id="_idIndexMarker572"/><st c="7731"> learn </st><code><st c="7738">SwiftSyntax</st></code><st c="7749">, we will create a new project and add </st><code><st c="7788">SwiftSyntax</st></code><st c="7799"> as a Swift package to that project, including a playground. </st><st c="7860">To do so, follow </st><st c="7877">these steps:</st></p>
			<ol>
				<li><st c="7889">Let’s start with opening Xcode and adding a </st><st c="7934">new project.</st></li>
				<li><st c="7946">Then, we’ll add our </st><code><st c="7967">SwiftSyntax</st></code><st c="7978"> Swift package by selecting </st><strong class="bold"><st c="8006">File</st></strong><st c="8010"> | </st><strong class="bold"><st c="8013">Add </st></strong><strong class="bold"><st c="8017">Package Dependencies…</st></strong><st c="8038">.</st><p class="list-inset"><st c="8039">Now, we are in the adding dependencies window of Xcode (</st><em class="italic"><st c="8096">Figure 10</st></em><em class="italic"><st c="8106">.2</st></em><st c="8108">):</st></p></li>
			</ol>
			<div><div><img src="img/B21795_figure_10.02.jpg" alt="Figure 10.2: The adding dependencies Xcode window"/><st c="8111"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="9048">Figure 10.2: The adding dependencies Xcode window</st></p>
			<p class="callout-heading"><st c="9097">Dependencies window?</st></p>
			<p class="callout"><st c="9118">If that’s the first time you’ve seen that window, then this is an excellent chance to perform a short introduction. </st><st c="9235">When Swift Package Manager had just started, its management was completely manual, using </st><st c="9324">the Terminal.</st></p>
			<p class="callout"><st c="9337">Over the years, Swift Package Manager</st><a id="_idIndexMarker573"/><st c="9375"> has become an integral part of Xcode, and now, it is even possible to manage collections and search for packages right </st><st c="9495">from Xcode.</st></p>
			<p class="callout"><st c="9506">You can learn</st><a id="_idIndexMarker574"/><st c="9520"> more </st><st c="9526">at </st><a href="https://www.swift.org/documentation/package-manager/"><st c="9529">https://www.swift.org/documentation/package-manager/</st></a><st c="9581">.</st></p>
			<ol>
				<li value="3"><st c="9582">Back to </st><a id="_idIndexMarker575"/><st c="9591">Xcode – in the top-right corner of the adding dependencies window, we can fill the </st><code><st c="9674">SwiftSyntax</st></code> <st c="9685">GitHub repository:</st><pre class="source-code"><st c="9704">
https://github.com/apple/swift-syntax</st></pre></li>				<li><st c="9742">We will choose the </st><code><st c="9762">swift-syntax</st></code><st c="9774"> package from the left column and click the </st><strong class="bold"><st c="9818">Add </st></strong><strong class="bold"><st c="9822">Package</st></strong><st c="9829"> button.</st></li>
				<li><st c="9837">Xcode will now resolve the Swift package and present its libraries so we can choose what we want to import to our project (</st><em class="italic"><st c="9961">Figure 10</st></em><em class="italic"><st c="9971">.3</st></em><st c="9973">):</st></li>
			</ol>
			<div><div><img src="img/B21795_figure_10.03.jpg" alt="Figure 10.3: Choosing the SwiftSyntax package products"/><st c="9976"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10391">Figure 10.3: Choosing the SwiftSyntax package products</st></p>
			<p><st c="10445">We will choose the </st><code><st c="10465">SwiftSyntax</st></code><st c="10476"> library and click on the </st><code><st c="10542">SwiftSyntax</st></code><st c="10553"> to </st><st c="10557">our project!</st></p>
			<p><st c="10569">Now, let’s add a playground file (anywhere we like) and explore what </st><code><st c="10639">SwiftSyntax</st></code><st c="10650"> is.</st></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor336"/><st c="10654">Building our Abstract Syntax Tree</st></h2>
			<p><st c="10688">To try and analyze a piece of </st><a id="_idIndexMarker576"/><st c="10719">Swift code using the </st><code><st c="10740">SwiftSyntax</st></code><st c="10751"> library, we need to generate some Swift code and work </st><st c="10806">on it.</st></p>
			<p><st c="10812">We open the playground file we created in the previous section, and add the </st><st c="10889">following code:</st></p>
			<pre class="source-code"><st c="10904">
import SwiftSyntax
import SwiftSyntaxParser
</st><strong class="bold"><st c="10949">let</st></strong> <strong class="bold"><st c="10952">sourceCode</st></strong><st c="10963"> = """
func hello() {
    print("Hello World")
}
"""</st></pre>			<p><st c="11011">Our code starts with importing two important libraries – </st><code><st c="11069">SwiftSyntax</st></code><st c="11080"> and </st><code><st c="11085">SwiftSyntaxParser</st></code><st c="11102">. The </st><code><st c="11108">SwiftSyntaxParser</st></code><st c="11125"> library contains the </st><code><st c="11147">SwiftParser</st></code><st c="11158"> class, which helps convert a source code to a tree we can traverse </st><st c="11226">and analyze.</st></p>
			<p><st c="11238">We added a string </st><a id="_idIndexMarker577"/><st c="11257">constant named </st><code><st c="11272">sourceCode</st></code><st c="11282"> with a simple </st><em class="italic"><st c="11297">“Hello World”</st></em><st c="11310"> function to see how it works. </st><st c="11341">Imagine that </st><code><st c="11354">sourceCode</st></code><st c="11364"> represents the content of a </st><st c="11393">Swift file.</st></p>
			<p><st c="11404">To parse the “Hello World” code, we’ll </st><st c="11444">use </st><code><st c="11448">SwiftParser</st></code><st c="11459">:</st></p>
			<pre class="source-code"><st c="11461">
do {
</st><strong class="bold"><st c="11467">    let syntax = try SyntaxParser.parse(source: sourceCode)</st></strong><st c="11522">
} catch {
    print("Error parsing code: \(error)")
}</st></pre>			<p><st c="11572">The parsing code is straightforward. </st><code><st c="11610">SyntaxParser</st></code><st c="11622"> calls the parse method with our </st><code><st c="11655">sourceCode</st></code><st c="11665"> constant from earlier and returns a syntax. </st><st c="11710">But what is this syntax? </st><st c="11735">Well, that’s our full code tree! </st><st c="11768">The syntax variable is from the type </st><code><st c="11805">SourceFileSyntex</st></code><st c="11821">, and that type represents the syntax structure of our code. </st><st c="11882">It’s the most high-level syntax node, encapsulating all our source code’s imports, classes, </st><st c="11974">and functions.</st></p>
			<p><st c="11988">Now, it’s time to understand what this syntax tree </st><st c="12040">looks like.</st></p>
			<h3><st c="12051">Investigating the tree</st></h3>
			<p><st c="12074">One of</st><a id="_idIndexMarker578"/><st c="12081"> the best things about working with </st><strong class="bold"><st c="12117">Swift Playgrounds</st></strong><st c="12134"> is that it’s not only great for playing with code </st><a id="_idIndexMarker579"/><st c="12185">snippets but also for examining their results without having to place breakpoints in </st><st c="12270">our code.</st></p>
			<p><st c="12279">After we run our </st><a id="_idIndexMarker580"/><st c="12297">Playground code, we can see the type </st><code><st c="12334">SourceFileSyntax</st></code><st c="12350"> in the window’s right column. </st><st c="12381">When we tap the small square next to it, we can see how the syntax constant is built (see </st><em class="italic"><st c="12471">Figure 10</st></em><em class="italic"><st c="12480">.4</st></em><st c="12482">):</st></p>
			<div><div><img src="img/B21795_figure_10.04.jpg" alt="Figure 10.4: The syntax object structure"/><st c="12485"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="13432">Figure 10.4: The syntax object structure</st></p>
			<p><st c="13472">It’s an excellent time to take a moment, run it for yourself, and try to understand what we see in </st><em class="italic"><st c="13572">Figure 10</st></em><em class="italic"><st c="13581">.4</st></em><st c="13583">. Notice that I marked all the </st><st c="13614">juicy parts.</st></p>
			<p><st c="13626">The</st><a id="_idIndexMarker581"/><st c="13630"> syntax instance contains a list of statements. </st><st c="13678">A </st><strong class="bold"><st c="13680">statement</st></strong><st c="13689"> is </st><a id="_idIndexMarker582"/><st c="13693">everything we can work with – an import, a class declaration, or even an expression. </st><st c="13778">A statement can contain its </st><st c="13806">own statements.</st></p>
			<p><st c="13821">The base statement class is </st><code><st c="13850">CodeBlockItemListSyntax</st></code><st c="13873">, and each statement type comes with a different subclass </st><st c="13931">of </st><code><st c="13934">CodeBlockItemListSyntax</st></code><st c="13957">.</st></p>
			<p><st c="13958">In our case, we have one statement from the type of </st><code><st c="14011">FunctionDeclSyntax</st></code><st c="14029">, which indicates a </st><st c="14049">function declaration.</st></p>
			<p><st c="14070">Expanding </st><code><st c="14081">FunctionDeclSyntax</st></code><st c="14099"> reveals additional information about the function. </st><st c="14151">For example, its name is represented by the </st><code><st c="14195">identifier</st></code><st c="14205"> property (highlighted with a box in </st><em class="italic"><st c="14242">Figure 10</st></em><em class="italic"><st c="14251">.4</st></em><st c="14253">).</st></p>
			<p><code><st c="14256">FunctionDeclSyntax</st></code><st c="14275"> has a </st><code><st c="14282">body</st></code><st c="14286"> property, which contains the property of a statement with all the function statements, including the call for the </st><code><st c="14401">print</st></code><st c="14406"> function.</st></p>
			<p><st c="14416">So, we can see that </st><code><st c="14437">SwiftParser</st></code><st c="14448"> has done all the dirty work for us! </st><st c="14485">Now that we have a tree, we can traverse it. </st><st c="14530">Let’s extract the </st><st c="14548">function statement:</st></p>
			<pre class="source-code"><st c="14567">
if let </st><strong class="bold"><st c="14575">funcDecl</st></strong><st c="14583"> = syntax.statements.first?.item.as(</st><strong class="bold"><st c="14619">FunctionDeclSyntax</st></strong><st c="14638">.self) {
       // We'll fill that part soon
 }</st></pre>			<p><st c="14677">In the preceding code, we are taking the first statement item and trying to convert it to a function </st><st c="14779">declaration type.</st></p>
			<p><st c="14796">There are various declaration types, each providing specific tools to help us traverse and extract more information. </st><st c="14914">Here are some of the most common types we can try </st><st c="14964">to extract:</st></p>
			<ul>
				<li><code><st c="14975">VariableDeclSyntax</st></code><st c="14994">: This is </st><st c="15005">for variables</st></li>
				<li><code><st c="15018">EnumDeclSyntax</st></code><st c="15033">: This is for </st><st c="15048">enum declaration</st></li>
				<li><code><st c="15064">ClassDeclSyntax</st></code><st c="15080">: This is for </st><st c="15095">class declaration</st></li>
				<li><code><st c="15112">ProtocolDeclSyntax</st></code><st c="15131">: This is for </st><st c="15146">protocol declaration</st></li>
				<li><code><st c="15166">TypealiasDeclSyntax</st></code><st c="15186">: This is for type </st><st c="15206">alias declaration</st></li>
				<li><code><st c="15223">InitialzerDeclSyntax</st></code><st c="15244">: This is for </st><st c="15259">construct declaration</st></li>
				<li><code><st c="15280">OperatorDeclSyntax</st></code><st c="15299">: This is for </st><st c="15314">operator declaration</st></li>
			</ul>
			<p><st c="15334">These are just some</st><a id="_idIndexMarker583"/><st c="15354"> syntax node types available in </st><code><st c="15386">SwiftSyntax</st></code><st c="15397">, and converting existing statement items to their corresponding types can provide us with the </st><st c="15492">needed functionality.</st></p>
			<p><st c="15513">Let’s continue our code example and see what we can get </st><st c="15570">from </st><code><st c="15575">FunctionDeclSyntax</st></code><st c="15593">:</st></p>
			<pre class="source-code"><st c="15595">
if let </st><strong class="bold"><st c="15603">funcCallExpression</st></strong><st c="15621"> = funcDecl.body?.statements.first?.item.as(</st><strong class="bold"><st c="15665">FunctionCallExprSyntax</st></strong><st c="15688">.self) {
   // Checking the print function
  }</st></pre>			<p><st c="15729">Let’s dissect the preceding code snippet to understand what it accomplishes. </st><st c="15807">With a function declaration, we can dig in and try to analyze the different statements that it contains. </st><st c="15912">In this instance, we can find a statement from the type of </st><code><st c="15971">FunctionCallExprSyntax</st></code><st c="15993">. This type represents a function call, specifically, a call </st><st c="16054">to </st><code><st c="16057">print()</st></code><st c="16064">.</st></p>
			<p><st c="16065">Now that we converted the statement to the right type, we can get more information </st><st c="16149">about it:</st></p>
			<pre class="source-code"><st c="16158">
let functionName = funcCallExpression.</st><strong class="bold"><st c="16197">calledExpression</st></strong><st c="16214">.firstToken?.text
            if functionName == "print" {
                let value = funcCallExpression.</st><strong class="bold"><st c="16292">argumentList</st></strong><st c="16305">.first?.expression.as(StringLiteralExprSyntax.self)?
                    .</st><st c="16359">segments
                    .first?.firstToken?.text
            }</st></pre>			<p><code><st c="16395">funcCallExpression</st></code><st c="16414"> has a </st><code><st c="16421">calledExpression</st></code><st c="16437"> property that encapsulates the information about actual </st><st c="16494">expression components.</st></p>
			<p><code><st c="16516">firstToken</st></code><st c="16527"> contains the</st><a id="_idIndexMarker584"/><st c="16540"> function name itself. </st><st c="16563">But what does “token” mean? </st><st c="16591">Well, </st><code><st c="16736">text</st></code><st c="16740"> property returns the </st><st c="16762">function name.</st></p>
			<p><st c="16776">Next, we check if the function name is indeed </st><code><st c="16823">print</st></code><st c="16828">, and now we can check the value being printed by examining the function arguments list. </st><st c="16917">Once we convert the first expression to </st><code><st c="16957">StringLiteralExprSyntax</st></code><st c="16980">, we can extract its first segment token and store it in the </st><code><st c="17041">value</st></code><st c="17046"> constant.</st></p>
			<p><st c="17056">Does it sound confusing and a little bit cumbersome? </st><st c="17110">Well, we should remember that the </st><code><st c="17144">SwiftSyntax</st></code><st c="17155"> library is not considered easy to work with. </st><st c="17201">It has a steep learning curve with many options </st><st c="17249">and features.</st></p>
			<p><st c="17262">But this complexity is not a coincidence – parsing and analyzing programming language, especially an advanced and full-featured language such as Swift, is not simple. </st><st c="17430">Just like we have </st><code><st c="17448">funcCallExpression</st></code><st c="17466">, </st><code><st c="17468">calledExpression</st></code><st c="17484"> or </st><code><st c="17488">StringLiteralExprSyntax</st></code><st c="17511">, we have dozens of different types for different expressions. </st><st c="17574">Looking at the </st><code><st c="17589">SwiftSyntax</st></code><st c="17600"> documentation is the best way to learn to traverse and analyze more of </st><st c="17672">the language.</st></p>
			<p><st c="17685">Now that we understand Swift code analysis using </st><code><st c="17735">SwiftSyntax</st></code><st c="17746">, let’s explore how we can leverage </st><code><st c="17782">SwiftSyntax</st></code><st c="17793"> in the reverse direction – how to generate </st><st c="17837">Swift code.</st></p>
			<h3><st c="17848">Generating Swift Code</st></h3>
			<p><st c="17870">Generating</st><a id="_idIndexMarker586"/><st c="17881"> code in </st><code><st c="17890">SwiftSyntax</st></code><st c="17901"> is based on the built-in types and string literals. </st><st c="17954">We can try and structure Swift code just by creating </st><st c="18007">strings instances:</st></p>
			<pre class="source-code"><st c="18025">
let initString: String = "</st><strong class="bold"><st c="18052">init(title: String) {</st></strong>
<code><st c="18150">SwiftSyntax</st></code><st c="18161"> types:</st></p>
			<pre class="source-code"><st c="18168">
let initSyntax = try </st><strong class="bold"><st c="18190">InitializerDeclSyntax</st></strong><st c="18211">("init(title: String)") {
            </st><strong class="bold"><st c="18238">ExprSyntax</st></strong><st c="18248">("self.title = title")
        }</st></pre>			<p><st c="18273">In the preceding code, </st><code><st c="18297">InitializerDeclSyntax</st></code><st c="18318"> is a constructor declaration, and </st><code><st c="18353">ExprSyntax</st></code><st c="18363"> is a base type </st><st c="18379">for expressions.</st></p>
			<p><st c="18395">In the context of Swift Macros, in most cases, using </st><code><st c="18449">String</st></code><st c="18455"> literals will be enough. </st><st c="18481">That’s because the </st><code><st c="18500">SwiftSyntax</st></code><st c="18511"> types support </st><code><st c="18526">String</st></code><st c="18532"> literals. </st><st c="18543">However, using the built-in</st><a id="_idIndexMarker587"/><st c="18570"> expressions will ensure the generated code will be valid in future </st><st c="18638">Swift updates.</st></p>
			<p><st c="18652">Speaking of Swift Macros, let’s create our first Swift macro now that we know what </st><code><st c="18736">SwiftSyntax</st></code><st c="18747"> is and how </st><st c="18759">it works.</st></p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor337"/><st c="18768">Creating our first Swift macro</st></h1>
			<p><st c="18799">As I </st><a id="_idIndexMarker588"/><st c="18805">mentioned earlier (in the </st><em class="italic"><st c="18831">What is a Swift macro?</st></em><st c="18853"> section), the Swift Macros feature is part of the </st><code><st c="18904">SwiftSyntax</st></code><st c="18915"> library. </st><st c="18925">Macros don’t run as part of our app but as a plugin in </st><st c="18980">the IDE.</st></p>
			<p><st c="18988">Macros can be created by adding a new Swift package with a </st><st c="19048">macro template.</st></p>
			<p><st c="19063">It is obvious why Apple selected the Swift package feature to create macros – a Swift package is a great way to encapsulate code, including tests </st><st c="19210">and documentation.</st></p>
			<p><st c="19228">Let’s add our first Swift macro by creating a new </st><st c="19279">Swift package.</st></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor338"/><st c="19293">Adding a new Swift macro</st></h2>
			<p><st c="19318">To create a new </st><a id="_idIndexMarker589"/><st c="19335">Swift macro, we should open Xcode and follow </st><st c="19380">these steps:</st></p>
			<ol>
				<li><st c="19392">Select </st><strong class="bold"><st c="19400">File</st></strong><st c="19404"> | </st><strong class="bold"><st c="19407">New</st></strong><st c="19410"> | </st><strong class="bold"><st c="19413">Package…</st></strong><st c="19421">.</st></li>
				<li><st c="19422">Then, select </st><strong class="bold"><st c="19436">Swift Macro</st></strong><st c="19447"> followed by tapping on </st><strong class="bold"><st c="19471">Next</st></strong><st c="19475"> (see </st><em class="italic"><st c="19481">Figure 10</st></em><em class="italic"><st c="19490">.5</st></em><st c="19492">):</st></li>
			</ol>
			<div><div><img src="img/B21795_figure_10.05.jpg" alt="Figure 10.5: Selecting Swift Macro in the choose template window"/><st c="19495"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="19632">Figure 10.5: Selecting Swift Macro in the choose template window</st></p>
			<ol>
				<li value="3"><st c="19696">In the </st><a id="_idIndexMarker590"/><st c="19704">opening screen, we will give a name for our struct and press the </st><code><st c="19936">StructInit</st></code><st c="19946"> (see </st><em class="italic"><st c="19952">Figure 10</st></em><em class="italic"><st c="19961">.6</st></em><st c="19963">):</st></li>
			</ol>
			<div><div><img src="img/B21795_figure_10.06.jpg" alt="Figure 10.6: Adding a StructInit macro"/><st c="19966"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="20054">Figure 10.6: Adding a StructInit macro</st></p>
			<ol>
				<li value="4"><st c="20092">After saving, Xcode </st><a id="_idIndexMarker591"/><st c="20113">opens a window with our new package containing an </st><st c="20163">example macro.</st></li>
			</ol>
			<p><st c="20177">Let’s see how a Swift Macros package is </st><st c="20218">built next!</st></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor339"/><st c="20229">Examining our Swift Macros package structure</st></h2>
			<p><st c="20274">Now that we</st><a id="_idIndexMarker592"/><st c="20286"> have a Swift Macros package, we can reveal its file’s structure (</st><em class="italic"><st c="20352">Figure 10</st></em><em class="italic"><st c="20362">.7</st></em><st c="20364">):</st></p>
			<div><div><img src="img/B21795_figure_10.07.jpg" alt="Figure 10.7: The Swift Macros package file’s structure"/><st c="20367"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="20612">Figure 10.7: The Swift Macros package file’s structure</st></p>
			<p><st c="20666">Looking at the Swift Macros package (</st><em class="italic"><st c="20704">Figure 10</st></em><em class="italic"><st c="20714">.7</st></em><st c="20716">), we can see that </st><code><st c="20736">SwiftSyntax</st></code><st c="20747"> is defined as a dependency of the package for us, with the latest stable version already linked to </st><st c="20847">our package.</st></p>
			<p><st c="20859">The macro itself is built upon three different </st><st c="20907">source files:</st></p>
			<ul>
				<li><code><st c="20920">StructInit</st></code><st c="20931">: That’s our macro definition file. </st><st c="20968">Here, we define the macro name </st><st c="20999">and type.</st></li>
				<li><code><st c="21008">StructInitClient</st></code><st c="21025">: That’s our Swift Macros package executable product. </st><st c="21080">This is where we add an executable code that uses </st><st c="21130">our macro.</st></li>
				<li><code><st c="21140">StructInitMacros</st></code><st c="21157">: That’s our macro implementation and where all the </st><st c="21210">magic happens.</st></li>
			</ul>
			<p><st c="21224">In addition, we also have a </st><code><st c="21253">Test</st></code><st c="21257"> target where we can test our </st><st c="21287">macro code.</st></p>
			<p><st c="21298">Our first step toward the </st><code><st c="21325">StructInit</st></code><st c="21335"> macro is by declaring its name </st><st c="21367">and type.</st></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor340"/><st c="21376">Declaring our macro</st></h2>
			<p><st c="21396">If we</st><a id="_idIndexMarker593"/><st c="21402"> open the </st><code><st c="21412">StructInit</st></code><st c="21422"> file, we can see it has a concise yet </st><st c="21461">important declaration:</st></p>
			<pre class="source-code"><st c="21483">
@freestanding(expression)
public macro stringify&lt;T&gt;(_ value: T) -&gt; (T, String) = #externalMacro(module: "StructInitMacros",
    type: "StringifyMacro")</st></pre>			<p><st c="21631">This short declaration has </st><st c="21659">many components:</st></p>
			<ul>
				<li><code><st c="21675">@freestanding(expression)</st></code><st c="21701">: That’s the macro role. </st><st c="21727">We’ll go over roles in the </st><em class="italic"><st c="21754">Giving our macro a </st></em><em class="italic"><st c="21773">role</st></em><st c="21777"> section.</st></li>
				<li><code><st c="21786">public macro stringify&lt;T&gt;</st></code><st c="21812">: The </st><st c="21819">macro name.</st></li>
				<li><code><st c="21830">(_ value: T) -&gt; (T, String)</st></code><st c="21858">: The macro parameters </st><st c="21882">and output.</st></li>
				<li><code><st c="21893">#externalMacro</st></code><st c="21908">: This means that the macro will be used as a plug in </st><st c="21963">the compiler.</st></li>
				<li><code><st c="21976">module: "StructInitMacros"</st></code><st c="22003">: The name of the plugin that will </st><st c="22039">be used.</st></li>
				<li><code><st c="22047">type: "StringifyMacro"</st></code><st c="22070">: That’s the macro type, as defined in the </st><code><st c="22114">Package.swift</st></code><st c="22127"> file.</st></li>
			</ul>
			<p><st c="22133">The first component is the macro role, so let’s discuss what </st><st c="22195">roles are.</st></p>
			<h3><st c="22205">Giving our macro a role</st></h3>
			<p><strong class="bold"><st c="22229">Macro roles</st></strong><st c="22241"> define </st><a id="_idIndexMarker594"/><st c="22249">the fundamental behavior of our macros. </st><st c="22289">There are two primary </st><st c="22311">role categories:</st></p>
			<ul>
				<li><code><st c="22473">#</st></code> <st c="22474">sign.</st><p class="list-inset"><st c="22479">Here’s an example of a </st><st c="22503">freestanding macro:</st></p><pre class="source-code"><st c="22522">
#URL("https://swift.org/")</st></pre><p class="list-inset"><st c="22549">The </st><code><st c="22554">#URL</st></code><st c="22558"> macro checks whether the provided value is a valid URL. </st><st c="22615">If not, it raises an error on compile time. </st><st c="22659">Otherwise, it returns a </st><st c="22683">non-optional value.</st></p><p class="list-inset"><st c="22702">We can see</st><a id="_idIndexMarker596"/><st c="22713"> that the </st><code><st c="22723">#URL</st></code><st c="22727"> macro can be anywhere in our code. </st><st c="22763">That’s why it is </st><st c="22780">called </st><em class="italic"><st c="22787">freestanding</st></em><st c="22799">.</st></p></li>				<li><code><st c="22974">@</st></code> <st c="22975">sign.</st><p class="list-inset"><st c="22980">Here’s an example of an </st><st c="23005">attached macro:</st></p><pre class="source-code">
<strong class="bold"><st c="23020">@StructInit</st></strong><st c="23032">
struct Book {
    var id: Int
    var title: String
    var subtitle: String
    var description: String
    var author: String
}</st></pre><p class="list-inset"><st c="23142">In the preceding code, the </st><code><st c="23170">@StructInit</st></code><st c="23181"> macro is “attached” to the </st><code><st c="23209">Book</st></code><st c="23213"> struct and inserts an </st><code><st c="23236">init</st></code><st c="23240"> function based on the </st><st c="23263">struct properties.</st></p></li>			</ul>
			<p><st c="23281">The two categories of macro types, namely freestanding and attached, represent distinct sets of roles. </st><st c="23385">Here is the list of </st><st c="23405">all roles:</st></p>
			<ul>
				<li><code><st c="23415">#freestanding(expression)</st></code><st c="23441">: This</st><a id="_idIndexMarker598"/><st c="23448"> just returns a new expression based on an </st><st c="23491">existing one</st></li>
				<li><code><st c="23503">#freestanding(declaration)</st></code><st c="23530">: This creates a </st><st c="23548">new declaration</st></li>
				<li><code><st c="23563">@attached(peer)</st></code><st c="23579">: This adds new declaration next to the </st><st c="23620">attached one</st></li>
				<li><code><st c="23632">@attached(accessor)</st></code><st c="23652">: This adds accessors to </st><st c="23678">a property</st></li>
				<li><code><st c="23688">@attached(memberAttribute)</st></code><st c="23715">: This adds attributes to the declarations in the type it’s </st><st c="23776">attached to</st></li>
				<li><code><st c="23787">@attached(member)</st></code><st c="23805">: This adds new declarations inside the type it’s </st><st c="23856">attached to</st></li>
				<li><code><st c="23867">@attached(conformance)</st></code><st c="23890">: This </st><a id="_idIndexMarker599"/><st c="23898">adds conformance to the type it’s </st><st c="23932">attached to</st></li>
			</ul>
			<p><st c="23943">The role we define when we declare the macro tells the created plugin </st><em class="italic"><st c="24014">how to</st></em><st c="24020"> change an </st><st c="24031">existing code.</st></p>
			<p><st c="24045">The role is the first part of declaring a macro. </st><st c="24095">Let’s continue with the rest of </st><st c="24127">the declaration.</st></p>
			<h3><st c="24143">Defining the StructInit macro</st></h3>
			<p><st c="24173">Our </st><code><st c="24178">StructInit</st></code><st c="24188"> macro goal is to</st><a id="_idIndexMarker600"/><st c="24205"> create the init method for a struct. </st><st c="24243">Our macro doesn’t exist independently; its purpose is to insert new declarations into an existing struct. </st><st c="24349">Therefore, we will choose the </st><code><st c="24379">@attached(member)</st></code><st c="24396"> macro from the roles list in the </st><em class="italic"><st c="24430">Giving our macro a </st></em><em class="italic"><st c="24449">role</st></em><st c="24453"> section:</st></p>
			<pre class="source-code"><st c="24462">
@attached(member)</st></pre>			<p><st c="24480">However, mentioning the role type is not enough. </st><st c="24530">We also need to specify what declaration types we expect our macro to generate. </st><st c="24610">In this case, we expect the macro to generate an </st><code><st c="24659">init</st></code><st c="24663"> function. </st><st c="24674">Let’s add that to the </st><st c="24696">role declaration:</st></p>
			<pre class="source-code"><st c="24713">
@attached(member, names: named(init))</st></pre>			<p><st c="24751">Adding role types helps the compiler cover different cases where the macro generates something else that was not declared. </st><st c="24875">It also behaves as a documentation for </st><st c="24914">our macro.</st></p>
			<p><st c="24924">Here is another example of </st><code><st c="24952">names</st></code> <st c="24957">argument usage:</st></p>
			<pre class="source-code"><st c="24973">
@attached(member, names: named(rawValue))</st></pre>			<p><st c="25015">In this case, the </st><code><st c="25034">names</st></code><st c="25039"> argument declares a usage of the </st><code><st c="25073">RawValue</st></code><st c="25081"> declaration.</st></p>
			<p><st c="25094">We can also add </st><code><st c="25111">arbitrary</st></code><st c="25120"> for </st><st c="25125">general purposes:</st></p>
			<pre class="source-code"><st c="25142">
@attached(member, names: arbitrary)</st></pre>			<p><st c="25178">Using </st><code><st c="25185">arbitrary</st></code><st c="25194"> counts for all types </st><st c="25216">of declarations.</st></p>
			<p><st c="25232">Moving forward, we will reconfigure the predefined macro with the </st><st c="25299">following declaration:</st></p>
			<pre class="source-code"><st c="25321">
@attached(member, names: named(init))
public macro </st><strong class="bold"><st c="25373">StructInit</st></strong><st c="25383">() = #externalMacro(module:
    "</st><code><st c="25541">StructInit</st></code><st c="25551">.</st></p>
			<p><st c="25552">The macro is short but tells a lot about its goal and behavior. </st><st c="25617">Here comes the important part – the </st><st c="25653">macro implementation.</st></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor341"/><st c="25674">Implementing the macro</st></h2>
			<p><st c="25697">Unlike other Swift types, in </st><a id="_idIndexMarker602"/><st c="25727">macros, we separate our declaration and implementation into different files. </st><st c="25804">In a way, it resembles Objective-C or C++, when the header and the implementation were </st><st c="25891">other parts.</st></p>
			<p><st c="25903">We will open our </st><code><st c="25921">StructInitMacros</st></code><st c="25937"> file and clear its content for a clean start. </st><st c="25984">Afterward, we can proceed to import the </st><st c="26024">relevant libraries:</st></p>
			<pre class="source-code"><st c="26043">
import SwiftCompilerPlugin
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros</st></pre>			<p><st c="26140">These are the standard libraries in most macros we will write. </st><st c="26204">Notice that we have </st><code><st c="26224">SwiftSyntax</st></code><st c="26235"> and </st><code><st c="26240">SwiftSyntaxBuilder</st></code><st c="26258"> as part of what we’ve learned in the </st><em class="italic"><st c="26296">Exploring </st></em><em class="italic"><st c="26306">SwiftSyntax</st></em><st c="26317"> section.</st></p>
			<p><st c="26326">Now, let’s move on to the main dish – the </st><code><st c="26369">StructInit</st></code><st c="26379"> struct.</st></p>
			<h3><st c="26387">Declaring the StructInit struct</st></h3>
			<p><st c="26419">In Swift Macros, Apple </st><a id="_idIndexMarker603"/><st c="26443">continues its trend of working mainly with structs and protocols instead of classes </st><st c="26527">and inheritance.</st></p>
			<p><st c="26543">To implement a new macro, we will add a new struct with the macro name that conforms to a protocol </st><st c="26643">named </st><code><st c="26649">MemberMacro</st></code><st c="26660">:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="26662">public</st></strong><st c="26668"> struct StructInit: </st><strong class="bold"><st c="26688">MemberMacro</st></strong><st c="26699"> {
   public static func expansion() {
      //Implementation details are detailed in the next section
   }
}</st></pre>			<p><st c="26796">The compiler looks for a struct with an identical name to the macro name we declared earlier under the </st><em class="italic"><st c="26900">Adding a new Swift macro</st></em><st c="26924"> section. </st><st c="26934">We also declared the </st><code><st c="26955">StructInit</st></code><st c="26965"> as </st><code><st c="26969">public</st></code><st c="26975"> – remember that a macro is part of a Swift package, so we need to have it accessible from other modules </st><st c="27080">as well.</st></p>
			<p><st c="27088">So, what is the </st><code><st c="27105">MemberMacro</st></code><st c="27116"> protocol? </st><st c="27127">The </st><code><st c="27131">MemberMacro</st></code><st c="27142"> protocol contains one crucial function that performs the expansion operation, with the non-surprising name </st><st c="27250">of </st><code><st c="27253">expansion()</st></code><st c="27264">.</st></p>
			<p><st c="27265">However, we won’t use </st><code><st c="27288">MemberMacro</st></code><st c="27299"> every time we create a macro, as it is relevant only to the macro’s </st><code><st c="27368">attached(member)</st></code><st c="27384"> role. </st><st c="27391">Each role has a different protocol we need to </st><st c="27437">conform to.</st></p>
			<p><st c="27448">Here is the list of the different roles and their </st><st c="27499">corresponding protocol:</st></p>
			<ul>
				<li><code><st c="27522">@freestanding(expression) -&gt; </st></code><code><st c="27552">ExpressionMacro</st></code></li>
				<li><code><st c="27567">@freestanding(declaration) -&gt; </st></code><code><st c="27598">DeclarationMacro</st></code></li>
				<li><code><st c="27614">@attached(peer) -&gt; </st></code><code><st c="27634">PeerMacro</st></code></li>
				<li><code><st c="27643">@attached(accessor) -&gt; </st></code><code><st c="27667">AccessorMacro</st></code></li>
				<li><code><st c="27680">@attached(memberAttribute) -&gt; </st></code><code><st c="27711">MemberAttributeMacro</st></code></li>
				<li><code><st c="27731">@attached(member) -&gt; </st></code><code><st c="27753">MemberMacro</st></code></li>
				<li><code><st c="27764">@attached(conformance) -&gt; </st></code><code><st c="27791">ConformanceMacro</st></code></li>
			</ul>
			<p><st c="27807">Since we are building a</st><a id="_idIndexMarker604"/><st c="27831"> Swift macro with the </st><code><st c="27853">@attached(member)</st></code><st c="27870"> role, we will focus only on </st><code><st c="27899">MemberMacro</st></code><st c="27910">, even though the concept is similar to the </st><st c="27954">other protocols.</st></p>
			<p><st c="27970">Let’s go over </st><st c="27985">it together!</st></p>
			<h3><st c="27997">Implementing the expansion function</st></h3>
			<p><st c="28033">I’ll start by </st><a id="_idIndexMarker605"/><st c="28048">showing you the </st><code><st c="28064">expansion</st></code><st c="28073"> function:</st></p>
			<pre class="source-code"><st c="28083">
    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some
          DeclGroupSyntax,
        in context: some MacroExpansionContext
    ) throws -&gt; [SwiftSyntax.DeclSyntax]</st></pre>			<p><st c="28269">While the function may look a little bit complex, we need to remember </st><st c="28340">two things:</st></p>
			<ol>
				<li><st c="28351">Most types mentioned in the function signature should already be recognizable to us, as they are components of the </st><code><st c="28467">SwiftSyntax</st></code><st c="28478"> library.</st></li>
				<li><st c="28487">There’s only one function in this protocol. </st><st c="28532">No need to implement </st><st c="28553">another one!</st></li>
			</ol>
			<p><st c="28565">The </st><code><st c="28570">expansion</st></code><st c="28579"> function aims to receive information about the attached object or the macro parameters and return a piece of Swift code, represented by an array of </st><code><st c="28728">SwiftSyntax</st></code> <st c="28739">expressions (</st><code><st c="28753">DeclSyntax</st></code><st c="28764">).</st></p>
			<p><st c="28767">The expansion function has </st><st c="28795">three parameters:</st></p>
			<ol>
				<li><code><st c="28812">node: AtributeSyntax</st></code><st c="28833">: This node represents that actual macro in the original piece of </st><st c="28900">Swift code.</st></li>
				<li><code><st c="28911">declaration: some DeclGroupSyntax</st></code><st c="28945">: The declaration struct that describes the struct/class the macro is </st><st c="29016">attached to.</st></li>
				<li><code><st c="29028">context: some MacroExpansionContext</st></code><st c="29064">: The context provides us with more information about the compiler. </st><st c="29133">Remember that the compiler serves as the “environment” in which the </st><st c="29201">macro functions.</st></li>
			</ol>
			<p><st c="29217">Now, we can start creating our struct </st><code><st c="29256">init</st></code><st c="29260"> method.</st></p>
			<p><st c="29268">First, we need to have a list of all the struct properties, including names and types. </st><st c="29356">To do that, we need to analyze the code using </st><code><st c="29402">SwiftSyntax</st></code><st c="29413">, which we just learned in this chapter ( in the </st><em class="italic"><st c="29462">Exploring </st></em><em class="italic"><st c="29472">SwiftSyntax</st></em><st c="29483"> section).</st></p>
			<p><st c="29493">So, let’s get</st><a id="_idIndexMarker606"/><st c="29507"> all the struct information that </st><st c="29540">we need:</st></p>
			<pre class="source-code"><st c="29548">
let members = declaration.memberBlock.members </st><strong class="bold"><st c="29595">// 1</st></strong><st c="29599">
let variableDecl = members.compactMap {
  $0.decl.as(VariableDeclSyntax.self) } </st><strong class="bold"><st c="29678">// 2</st></strong><st c="29682">
let variablesName = variableDecl.compactMap {
  $0.bindings.first?.pattern } </st><strong class="bold"><st c="29758">// 3</st></strong><st c="29762">
let variablesType = variableDecl.compactMap {
  $0.bindings.first?.typeAnnotation?.type } </st><strong class="bold"><st c="29851">// 4</st></strong></pre>			<p><st c="29855">Let’s explain the preceding code, line </st><st c="29895">by line:</st></p>
			<ol>
				<li><st c="29903">We use the declaration parameter to get all the </st><st c="29952">struct members.</st></li>
				<li><st c="29967">All the struct members also include their functions, so we filter it only </st><st c="30042">to variables.</st></li>
				<li><st c="30055">We create an array of all the variable’s names using their </st><code><st c="30115">pattern</st></code><st c="30122"> attribute.</st></li>
				<li><st c="30133">We create another variety with all the variable types, using their </st><code><st c="30201">typeAnnotation</st></code><st c="30215"> attribute.</st></li>
			</ol>
			<p><st c="30226">Now that we have all the information we need, we can generate our Swift code for the </st><code><st c="30312">init</st></code><st c="30316"> function.</st></p>
			<p><st c="30326">First, we generate the </st><code><st c="30350">init</st></code><st c="30354"> function signature based on the list of variable names </st><st c="30410">and types:</st></p>
			<pre class="source-code"><st c="30420">
var code = "</st><strong class="bold"><st c="30433">init(</st></strong><st c="30439">"
for (name, type) in zip(variablesName, variablesType) {
    code += </st><strong class="bold"><st c="30506">"\(name): \(type),</st></strong><st c="30524"> "
}
code = String(code.dropLast(2))
code += "</st><strong class="bold"><st c="30570">)</st></strong><st c="30572">"</st></pre>			<p><st c="30573">The preceding code starts by creating a mutable string, looping all the variable names and types, and adding them to the function signature. </st><st c="30714">Once the code adds all the function parameters, it closes with a </st><st c="30779">closing parenthesis.</st></p>
			<p><st c="30799">Next, it’s time to </st><a id="_idIndexMarker607"/><st c="30819">add the function body. </st><st c="30842">We can do that using a special </st><code><st c="30873">SwiftSyntax</st></code><st c="30884"> struct that represents an initializer declaration </st><st c="30935">called </st><code><st c="30942">InitializerDeclSyntax</st></code><st c="30963">:</st></p>
			<pre class="source-code"><st c="30965">
let initializer = try </st><strong class="bold"><st c="30988">InitializerDeclSyntax</st></strong><st c="31009">(SyntaxNodeString
  (stringLiteral: code)) {
      for name in variablesName {
          ExprSyntax("self.\(name) = \(name)")
      }
}</st></pre>			<p><st c="31121">The </st><code><st c="31126">InitializerDeclSyntax</st></code><st c="31147"> “init” function receives two parameters – the function signature and a closure with the “init” body represented </st><st c="31260">by </st><code><st c="31263">ExprSyntax</st></code><st c="31273">.</st></p>
			<p><st c="31274">Now that we have </st><code><st c="31292">initializer</st></code><st c="31303">, we can return an array </st><st c="31328">of </st><code><st c="31331">DeclSyntax</st></code><st c="31341">:</st></p>
			<pre class="source-code"><st c="31343">
return [DeclSyntax(initializer)]</st></pre>			<p><st c="31376">Let’s see the </st><st c="31391">full code:</st></p>
			<pre class="source-code"><st c="31401">
let members = structDecl.memberBlock.members
        let variableDecl = members.compactMap {
          $0.decl.as(VariableDeclSyntax.self) }
        let variablesName = variableDecl.compactMap {
          $0.bindings.first?.pattern }
        let variablesType = variableDecl.compactMap {
          $0.bindings.first?.typeAnnotation?.type }
        var code = "</st><strong class="bold"><st c="31700">init(</st></strong><st c="31706">"
        for (name, type) in zip(variablesName,
          variablesType) {
            code += </st><strong class="bold"><st c="31773">"\(name): \(type),</st></strong><st c="31791"> "
        }
        code = String(code.dropLast(2))
        code += "</st><strong class="bold"><st c="31837">)</st></strong><st c="31839">"
        let initializer = try InitializerDeclSyntax(SyntaxNodeString
          (stringLiteral: code)) {
            for name in variablesName {
                ExprSyntax("</st><strong class="bold"><st c="31967">self.\(name) = \(name)</st></strong><st c="31990">")
            }
        }
        return [DeclSyntax(initializer)]</st></pre>			<p><st c="32030">The code takes the struct list of variables and generates its own </st><code><st c="32097">init</st></code><st c="32101"> function.</st></p>
			<p><st c="32111">How does it look? </st><st c="32130">Let’s</st><a id="_idIndexMarker608"/><st c="32135"> demonstrate that with a </st><st c="32160">small struct:</st></p>
			<pre class="source-code"><st c="32173">
struct Book {
    var id: Int
    var title: String
}</st></pre>			<p><st c="32219">The </st><code><st c="32224">expansion</st></code><st c="32233"> method </st><a id="_idIndexMarker609"/><st c="32241">creates the following </st><code><st c="32263">init</st></code><st c="32267"> function:</st></p>
			<pre class="source-code"><st c="32277">
init(id: Int, title: String) {
    self.id = id
    self.title = title
}</st></pre>			<p><st c="32342">But the fact that we just defined the macro behavior doesn’t mean we can use it. </st><st c="32424">Remember that the macro runs as a compiler plugin. </st><st c="32475">That’s our </st><st c="32486">next step.</st></p>
			<h3><st c="32496">Adding the compiler plugin</st></h3>
			<p><st c="32523">The compiler plugin is our </st><a id="_idIndexMarker610"/><st c="32551">macro “product,” or, in other words, the macro </st><st c="32598">entry point.</st></p>
			<p><st c="32610">In iOS, macros are invoked in a sandbox without network access and system file changes. </st><st c="32699">The question is this: How does the compiler instantiate and store Swift macros to be used as </st><st c="32792">a plugin?</st></p>
			<p><st c="32801">The answer is that it doesn’t. </st><st c="32833">If we have another look at our code, we’ll notice that Swift Macros functions are all static, and that’s an important issue when creating a </st><st c="32973">new macro.</st></p>
			<p><st c="32983">So, to create a compiler plugin, we need to define a new struct that conforms to the </st><code><st c="33069">CompilerPlugin</st></code><st c="33083"> protocol and has the </st><code><st c="33105">@main</st></code> <st c="33110">attribute mark:</st></p>
			<pre class="source-code"><st c="33126">
@main
struct struct_initial_macroPlugin: CompilerPlugin {
    let providingMacros: [Macro.Type] = [
        StructInit.self,
    ]
}</st></pre>			<p><st c="33243">The preceding code shows that </st><code><st c="33274">struct_initial_macroPlugin</st></code><st c="33300"> implements one variable </st><code><st c="33325">get</st></code><st c="33328"> method – </st><code><st c="33338">providingMacros</st></code><st c="33353"> – and returns an array of macro types instead </st><st c="33400">of instances.</st></p>
			<p><st c="33413">Another essential thing to notice here is the struct name (</st><code><st c="33473">struct_initial_macroPlugin</st></code><st c="33500">). </st><st c="33504">It doesn’t matter what name we give it as long as it conforms </st><a id="_idIndexMarker611"/><st c="33566">to the </st><code><st c="33573">CompilerPlugin</st></code><st c="33587"> protocol and has the </st><code><st c="33609">@</st></code><code><st c="33610">main</st></code><st c="33614"> attribute.</st></p>
			<p><st c="33625">Now that we have a compiler plugin, our compiler is ready to </st><st c="33687">run it.</st></p>
			<h3><st c="33694">Running our macro using a client</st></h3>
			<p><st c="33727">Macro executables are</st><a id="_idIndexMarker612"/><st c="33749"> different than apps or libraries since they run in a compiler environment. </st><st c="33825">If we go back in our chapter to the section where we create the Swift Macros Swift package (</st><em class="italic"><st c="33917">Examining our Swift Macros package structure</st></em><st c="33962"> section), we see that the Swift macro has another folder </st><st c="34020">called </st><code><st c="34027">StructInitClient</st></code><st c="34043">.</st></p>
			<p><code><st c="34044">StructInitClient</st></code><st c="34061"> is our Swift macro executable, also defined in the macro’s </st><code><st c="34121">package.swift</st></code> <st c="34134">manifest file:</st></p>
			<pre class="source-code"><st c="34149">
.executable(
    name: "StructInitClient",
    targets: ["StructInitClient"]
),</st></pre>			<p><st c="34220">Now, we can change the code we have in the </st><code><st c="34264">main.swift</st></code><st c="34274"> file to </st><st c="34283">the following:</st></p>
			<pre class="source-code"><st c="34297">
import StructInit
import Foundation
</st><strong class="bold"><st c="34334">@StructInit</st></strong><st c="34345">
struct Book {
    var id: Int
    var title: String
    var subtitle: String
    var description: String
    var author: String
}</st></pre>			<p><st c="34455">In the preceding </st><a id="_idIndexMarker613"/><st c="34473">code, we have a simple struct named </st><code><st c="34509">Book</st></code><st c="34513">, but now, we have also attached the </st><code><st c="34550">@StructInit</st></code><st c="34561"> macro we </st><st c="34571">just created.</st></p>
			<p><st c="34584">Right-click on the macro itself and choose </st><strong class="bold"><st c="34628">Expand Macro</st></strong><st c="34640">, which reveals the generated code (</st><em class="italic"><st c="34676">Figure 10</st></em><em class="italic"><st c="34686">.8</st></em><st c="34688">):</st></p>
			<div><div><img src="img/B21795_figure_10.08.jpg" alt="Figure 10.8: Swift macro expansion"/><st c="34691"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="35057">Figure 10.8: Swift macro expansion</st></p>
			<p><st c="35091">Using our macro executable is a great way to see our macro in action! </st><st c="35162">At this point, everything should work as expected. </st><st c="35213">It’s time to level up our macro implementation with some </st><st c="35270">error handling.</st></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor342"/><st c="35285">Handling macros errors</st></h1>
			<p><st c="35308">When we create a </st><a id="_idIndexMarker614"/><st c="35326">Swift macro, things obvious to us, as the macro developers, are not obvious to our </st><st c="35409">macro users.</st></p>
			<p><st c="35421">Our </st><code><st c="35426">StructInit</st></code><st c="35436"> macro is designed to function exclusively with structs, not classes. </st><st c="35506">Therefore, we need to check whether the attached element is indeed </st><st c="35573">a struct.</st></p>
			<p><st c="35582">Inside the </st><code><st c="35594">expansion()</st></code><st c="35605"> function, we can perform a simple </st><code><st c="35640">guard</st></code><st c="35645"> statement and throw an error in case the attached declaration is not </st><st c="35715">a struct:</st></p>
			<pre class="source-code"><st c="35724">
guard let structDecl = declaration.as(StructDeclSyntax.self)
    else {
      throw StructInitError.onlyStructs
    }</st></pre>			<p><st c="35828">In the preceding code, </st><code><st c="35852">StructInitError</st></code><st c="35867"> is an enum that conforms </st><st c="35893">to </st><code><st c="35896">Error</st></code><st c="35901">:</st></p>
			<pre class="source-code"><st c="35903">
enum StructInitError: CustomStringConvertible, Error {
    case onlyStructs
    var description: String {
        switch self {
        case . </st><st c="36023">onlyStructs: return "@StructInit can only be applied to a structure"
        }
    }
}</st></pre>			<p><st c="36097">Having an enum </st><a id="_idIndexMarker615"/><st c="36113">with different error types and messages can make a developer’s life much easier. </st><st c="36194">Remember that this error appears in compile time (</st><em class="italic"><st c="36244">Figure 10</st></em><em class="italic"><st c="36254">.9</st></em><st c="36256">):</st></p>
			<div><div><img src="img/B21795_figure_10.09.jpg" alt="Figure 10.9: An error message is thrown when implementing a Swift macro"/><st c="36259"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="36309">Figure 10.9: An error message is thrown when implementing a Swift macro</st></p>
			<p><st c="36380">But sometimes, we want to handle more complex errors. </st><st c="36435">For example, sometimes we want to show a warning, not just an error. </st><st c="36504">Or, in other cases, we even want to offer our developer a fix for </st><st c="36570">their problem.</st></p>
			<p><st c="36584">In these cases, we can </st><a id="_idIndexMarker616"/><st c="36608">add something called a </st><code><st c="36631">Diagnostic</st></code><st c="36641"> struct. </st><st c="36650">A </st><code><st c="36652">Diagnostic</st></code><st c="36662"> struct is more suitable for showing errors in a compiler environment and has more capabilities than just </st><st c="36768">throwing errors.</st></p>
			<p><st c="36784">Let’s create a </st><code><st c="36800">DiagnosticMessage</st></code><st c="36817"> enum and a </st><code><st c="36829">Diagnostic</st></code><st c="36839"> struct:</st></p>
			<pre class="source-code"><st c="36847">
enum CustomDiagnostic: String, DiagnosticMessage {
    case notAStruct
    var </st><strong class="bold"><st c="36919">severity</st></strong><st c="36927">: DiagnosticSeverity { return .error}
    var </st><strong class="bold"><st c="36970">message</st></strong><st c="36977">: String {
        switch self {
        case .notAStruct:
            return "@StructInit can only be applied to a structure"
        }
    }
    var </st><strong class="bold"><st c="37085">diagnosticID</st></strong><st c="37097">: MessageID {
        return MessageID(domain: "StructInitMacro",
                         id: rawValue)
    }
}
</st><strong class="bold"><st c="37174">let diagnostic = Diagnostic(node: node,</st></strong>
<code><st c="37383">SwiftSyntax</st></code><st c="37394"> library.</st></p>
			<p><st c="37403">If you wondered why we need the </st><code><st c="37436">context</st></code><st c="37443"> parameter in the </st><code><st c="37461">expansion</st></code><st c="37470"> function, now you’ll have </st><st c="37497">the answer:</st></p>
			<pre class="source-code"><st c="37508">
context.diagnose(diagnostic)</st></pre>			<p><st c="37537">Remember we said that context links us to the compiler environment? </st><st c="37606">So, we use it to invoke a </st><st c="37632">diagnostic message.</st></p>
			<p><st c="37651">Let’s see the </st><code><st c="37666">guard</st></code><st c="37671"> declaration now that we have a </st><code><st c="37703">diagnostic</st></code><st c="37713"> structure:</st></p>
			<pre class="source-code"><st c="37724">
guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            let diagnostic = Diagnostic(node: node,
                                        message: MyLibDiagnostic.notAStruct)
            </st><strong class="bold"><st c="37870">context.diagnose(diagnostic)</st></strong><st c="37898">
            throw StructInitError.onlyAStruct
        }</st></pre>			<p><st c="37934">We can see that </st><code><st c="37951">SwiftSyntax</st></code><st c="37962"> is like peeling an onion – we uncover new features every time we dig deeper, and </st><code><st c="38044">Diagnostic</st></code><st c="38054"> is one of </st><st c="38065">these features.</st></p>
			<p><st c="38080">Now, we have a significant error handling – descriptive and precise. </st><st c="38150">But what about checking our macro in various </st><st c="38195">use cases?</st></p>
			<p><st c="38205">To see our macro at work, we used </st><code><st c="38240">StructInitClient</st></code><st c="38256">. However, relying on the client to verify that</st><a id="_idIndexMarker618"/><st c="38303"> our macro works as expected is not sustainable </st><st c="38351">over time.</st></p>
			<p><st c="38361">So, another great feature we get from having a macro written in a Swift package is </st><st c="38445">unit tests.</st></p>
			<p><st c="38456">Let’s see how we test </st><st c="38479">a macro.</st></p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor343"/><st c="38487">Adding tests</st></h1>
			<p><st c="38500">The principle of testing a macro</st><a id="_idIndexMarker619"/><st c="38533"> is to test a code block </st><em class="italic"><st c="38558">before and after</st></em><st c="38574"> the </st><st c="38579">macro expansion.</st></p>
			<p><st c="38595">As part of our Swift Macros package, we have a test target (</st><em class="italic"><st c="38656">Figure 10</st></em><em class="italic"><st c="38666">.10</st></em><st c="38669">):</st></p>
			<div><div><img src="img/B21795_figure_10.10.jpg" alt="Figure 10.10: A testing target for StructInitMacro"/><st c="38672"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="38877">Figure 10.10: A testing target for StructInitMacro</st></p>
			<p><st c="38927">Each Swift package comes with a testing target, and in this case, we already have one test with the </st><code><st c="39028">stringify</st></code><st c="39037"> macro that comes when we create a new Swift </st><st c="39082">Macros package.</st></p>
			<p><st c="39097">Let’s clear the test file and start our </st><st c="39138">own test.</st></p>
			<p><st c="39147">To test a macro, we need to create the </st><code><st c="39187">XCTestCase</st></code><st c="39197"> subclass and create a new method called </st><code><st c="39238">testMacro</st></code><st c="39247">. Remember that test functions in </st><code><st c="39281">XCTest</st></code><st c="39287"> always start with the phrase “test” followed by the </st><st c="39340">test name.</st></p>
			<p><st c="39350">To test a macro expansion, we will use a particular </st><code><st c="39403">SwiftSyntax</st></code><st c="39414"> function called </st><code><st c="39431">assertMacroExpansion</st></code><st c="39451">. The most important function parameters are </st><st c="39496">as follows:</st></p>
			<ul>
				<li><code><st c="39507">_originalSource</st></code><st c="39523">: The original code before the expansion, including the macro </st><st c="39586">attribute itself</st></li>
				<li><code><st c="39602">expandedSource</st></code><st c="39617">: The code </st><em class="italic"><st c="39629">after</st></em> <st c="39634">the expansion</st></li>
				<li><code><st c="39648">macros</st></code><st c="39655">: The list of macro types </st><st c="39682">being tested</st></li>
			</ul>
			<p><st c="39694">Let’s see a basic</st><a id="_idIndexMarker620"/><st c="39712"> test case for testing our </st><code><st c="39739">StructInit</st></code><st c="39749"> macro:</st></p>
			<pre class="source-code"><st c="39756">
let testMacros: [String: Macro.Type] = [
    "StructInit": StructInit.self,
]
final class StructInitTests: XCTestCase {
    func testMacro() {
        assertMacroExpansion(
            """
            @StructInit
            struct Book {
                var id: Int
                var title: String
                var subtitle: String
            }
            """,
            expandedSource:
            """
            struct Book {
                var id: Int
                var title: String
                var subtitle: String
                init(id: Int, title: String,
                  subtitle: String) {
                    self.id = id
                    self.title = title
                    self.subtitle = subtitle
                }
            }
            """,
            macros: testMacros
        )
    }
}</st></pre>			<p><st c="40226">We can see </st><a id="_idIndexMarker621"/><st c="40238">that </st><code><st c="40243">assertMacroExpansion</st></code><st c="40263"> received the three parameters I </st><st c="40296">mentioned earlier.</st></p>
			<p><st c="40314">We compare the </st><code><st c="40330">Book</st></code><st c="40334"> struct expansion with the </st><code><st c="40361">Book</st></code><st c="40365"> struct desired structure, including the </st><code><st c="40406">init</st></code><st c="40410"> function.</st></p>
			<p><code><st c="40420">assertMacroExpansion</st></code><st c="40441"> compares the expanded code of the macro to the </st><code><st c="40489">expandedSource</st></code><st c="40503"> parameter, and if there are any differences, it fails </st><st c="40558">the test.</st></p>
			<p><st c="40567">Testing is a crucial part of Swift packages in general. </st><st c="40624">Swift packages are meant to be reusable and rely on testing to ensure </st><st c="40694">their stability.</st></p>
			<p><st c="40710">Things get even more important when creating Swift macros since they run as a compiler plugin, which makes it harder to debug. </st><st c="40838">So, we shouldn’t give up tests, especially not </st><st c="40885">in macros.</st></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor344"/><st c="40895">Practice exercises</st></h1>
			<p><st c="40914">Swift Macros is a complex topic, and it is a challenge to understand how to create a Swift macro without trying it yourself. </st><st c="41040">Here are two exercises that can help you </st><st c="41081">get started:</st></p>
			<ul>
				<li><st c="41093">Create an attached Swift macro that adds a function called </st><code><st c="41153">printVariables</st></code><st c="41167">. The function prints the list of the class properties and </st><st c="41226">their values.</st></li>
				<li><st c="41239">Create a freestanding macro called </st><code><st c="41275">#colorhex</st></code><st c="41284"> that receives a hex color value and generates an RGB color expression. </st><st c="41356">For example, </st><code><st c="41369">#colorhex("#FFFFFF")</st></code><st c="41389"> will generate </st><code><st c="41404">Color(red: 0.0, green: 0.0, </st></code><code><st c="41432">blue: 0.0)</st></code><st c="41442">.</st></li>
			</ul>
			<p><st c="41443">In addition, here are some links that can help you get more insights about </st><st c="41519">Swift Macros:</st></p>
			<ul>
				<li><strong class="bold"><st c="41532">Swift Macros documentation from the Swift.org </st></strong><strong class="bold"><st c="41579">projects</st></strong><st c="41587">:</st><a href=" https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/ "><st c="41589"> https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/</st></a></li>
				<li><strong class="bold"><st c="41676">A GitHub repository about great Swift macros we can use and learn </st></strong><strong class="bold"><st c="41743">from</st></strong><st c="41747">: </st><a href="https://github.com/krzysztofzablocki/Swift-Macros"><st c="41750">https://github.com/krzysztofzablocki/Swift-Macros</st></a></li>
			</ul>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor345"/><st c="41799">Summary</st></h1>
			<p><st c="41807">This chapter covered a new and exciting feature of Xcode 15 and iOS 17 – </st><st c="41881">Swift Macros.</st></p>
			<p><st c="41894">We explored the </st><code><st c="41911">SwiftSyntax</st></code><st c="41922"> library and learned how to set up, parse, and generate Swift code. </st><st c="41990">We also created our first Swift macro, handled errors, and even wrote </st><st c="42060">one test.</st></p>
			<p><st c="42069">Swift Macros is a comprehensive, complex, yet effective feature, and by now, you are ready to implement it in your </st><st c="42185">own projects!</st></p>
			<p><st c="42198">In the next chapter, we’ll discuss another exciting framework – </st><st c="42263">Combine.</st></p>
		</div>
	<div></body></html>