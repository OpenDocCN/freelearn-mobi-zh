<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Views, Widgets, and Styles</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inserting a widget into a layout</li><li class="listitem" style="list-style-type: disc">Using graphics to show the button state</li><li class="listitem" style="list-style-type: disc">Creating a widget at runtime</li><li class="listitem" style="list-style-type: disc">Creating a custom component</li><li class="listitem" style="list-style-type: disc">Applying a style to a View</li><li class="listitem" style="list-style-type: disc">Turning a style into a theme</li><li class="listitem" style="list-style-type: disc">Selecting a theme based on the Android OS version</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Introduction</h1></div></div></div><p>The term <strong>widgets</strong>
<a id="id115" class="indexterm"/> can refer to several different concepts in Android. When most people talk about widgets, they are referring to <a id="id116" class="indexterm"/>
<strong>app widgets</strong>, which are typically seen on the home screen. App widgets are like mini applications by themselves as they usually provide a subset of functionality, based on their main application. (Usually, most app widgets are installed along with an application, but that is not a requirement. They can be standalone apps in a widget format.) A common app widget example is a weather application that offers several different app widgets for the home screen. <a class="link" href="ch05.html" title="Chapter 5. Exploring Fragments, AppWidgets, and the System UI">Chapter 5</a>, <em>Exploring Fragments, AppWidgets, and the System UI</em>, will discuss home screen app widgets and provide recipes to create your own.</p><p>When developing for Android, the term widgets generally refers to specialized Views placed in the layout files, such as a Button, TextView, CheckBox, and so on. In this chapter, we will focus on widgets for app development.</p><p>To see the list of widgets provided in the <a id="id117" class="indexterm"/>
<strong>Android SDK</strong>, open a layout file in Android Studio, and click on the <strong>Design</strong> tab. Along the left side of the Design view, you will see the <strong>Widget</strong> section below the <strong>Layout</strong> section, as in the following screenshot:</p><div><img src="img/B05057_03_01.jpg" alt="Introduction"/></div><p>As you can see from the list, the <strong>Android SDK</strong>
<a id="id118" class="indexterm"/> provides many useful widgets—from a simple TextView, Button, or Checkbox to the much more complex widgets such as the Clock, DatePicker, and Calendar. As useful as the built-in widgets are, it's also very easy to expand on what's provided in the SDK. We can extend an existing widget to customize its functionality, or we can create our own widget from scratch by extending the base View class. (We will provide an example of this in the <em>Creating a custom component</em> recipe later.)</p><p>The visual look of widgets can also be customized. These settings can be used to create <a id="id119" class="indexterm"/>
<strong>styles</strong>, which in turn can be used to create<a id="id120" class="indexterm"/> <strong>themes</strong>. Just like with other development environments, creating a theme offers the benefit of easily changing the appearance throughout our entire application with minimal effort. Lastly, the Android SDK also provides many built-in themes and variations, such as the Holo theme from Android 3/4 and the Material theme from Android 5. (Android 6.0 did not release a new theme.)</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Inserting a widget into a layout</h1></div></div></div><p>As you may have seen<a id="id121" class="indexterm"/> from previous recipes, <strong>widgets</strong> are declared in a <a id="id122" class="indexterm"/>layout file, or created in code. For this recipe, we will go step-by-step to add a button with the Android Studio Designer. (For later recipes, we will just show the layout XML from the TextView.) After creating the button, we will create an <code class="literal">onClickListener()</code>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec76"/>Getting ready</h2></div></div></div><p>Start a new project in Android Studio and call it <code class="literal">InsertWidget</code>. Use the default options for creating a Phone and Tablet project and select <strong>Empty Activity</strong> when prompted for the Activity Type. You can delete the default TextView (or leave it) as it will not be needed for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec77"/>How to do it...</h2></div></div></div><p>To insert a widget into a layout, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <strong>activity_main.xml</strong> file in Android Studio and click on the <strong>Design</strong> tab.<div><img src="img/B05057_03_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Find <strong>Button</strong> in the <a id="id123" class="indexterm"/>widget list and drag it to the center of the <a id="id124" class="indexterm"/>activity screen on the right. Android will automatically set the layout parameters based on where the button is dropped. If you center the button as shown in the screenshot, Android Studio will set those parameters in the XML.<div><img src="img/B05057_03_03.jpg" alt="How to do it..."/></div></li><li class="listitem">To view the <code class="literal">xml</code> <a id="id125" class="indexterm"/>created, click on the <strong>Text</strong> tab as <a id="id126" class="indexterm"/>shown in the following screenshot. See how the button is centered using the <code class="literal">RelativeLayout</code> parameters. Also, take note of the default ID as we will need it for the next step.<div><img src="img/B05057_03_04.jpg" alt="How to do it..."/></div></li><li class="listitem">Now, open the <code class="literal">MainActivity.java</code> file to edit the code. Add the following code to the <code class="literal">onCreate()</code> method to set up the <code class="literal">onClickListener()</code>:<div><pre class="programlisting">Button button = (Button)findViewById(R.id.button);
button.setOnClickListener(new View.OnClickListener() {
    <strong>@Override</strong>
    public void onClick(View view) {
        Toast.<strong>makeText</strong>(MainActivity.this,<strong>"Clicked"</strong>,Toast.<strong>LENGTH_SHORT</strong>).show();
    }
});</pre></div></li><li class="listitem">Run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec78"/>How it works...</h2></div></div></div><p>Creating the UI<a id="id127" class="indexterm"/> with the Android Studio is as simple as dragging <a id="id128" class="indexterm"/>and dropping Views. You can also edit the properties of the Views directly in the <strong>Design</strong> tab. Switching to the XML code is as simple as hitting the <strong>Text</strong> tab.</p><p>What we did here is very common in Android development—creating the UI in XML, then hooking up the UI components (Views) in the Java code. To reference a View from code, it must have a resource identifier associated with it. This is done using the <code class="literal">id</code> parameter:</p><div><pre class="programlisting">android:id="@+id/button"</pre></div><p>Our <code class="literal">onClickListener</code> function <a id="id129" class="indexterm"/>displays a pop-up message on the screen <a id="id130" class="indexterm"/>called<a id="id131" class="indexterm"/> <strong>Toast</strong>, when the button is pressed.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec79"/>There's more...</h2></div></div></div><p>Take a look again at the format of the identifier we created previously, <code class="literal">@+id/button</code>. The <code class="literal">@ </code>specifies this is going to be a resource and the <strong>+</strong> sign indicates a new resource. (If we failed to include the plus sign, we would get a compile time error stating <strong>No resource matched the indicated name</strong>).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec80"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Butter Knife (Open Source Project)—Field and <a id="id132" class="indexterm"/>method binding for Android Views: <a class="ulink" href="http://jakewharton.github.io/butterknife/">http://jakewharton.github.io/butterknife/</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Using graphics to show button state</h1></div></div></div><p>We've talked about <a id="id133" class="indexterm"/>the versatility of Android Views and <a id="id134" class="indexterm"/>how behavior and visual appearance can be customized. In this recipe, we will create a drawable<a id="id135" class="indexterm"/> <strong>state selector</strong>, which is a resource defined in XML that specifies the drawable to use based on the View's state. The most commonly used states, along with the possible values, include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">state_pressed=["true" | "false"]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">state_focused=["true" | "false"]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">state_selected=["true" | "false"]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">state_checked=["true" | "false"]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">state_enabled=["true" | "false"]</code></li></ul></div><p>To define a state selector, create an XML file with the <code class="literal">&lt;selector&gt;</code> element, as shown:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;selector  &gt;
&lt;/selector&gt;</pre></div><p>Within the <code class="literal">&lt;selector&gt;</code> element, we define an <code class="literal">&lt;item&gt;</code> to identify the drawable to be used based on the specified state(s). Here's an example <code class="literal">&lt;item&gt;</code> element using multiple states:</p><div><pre class="programlisting">&lt;item
    android:drawable="@android:color/darker_gray"
    android:state_checked="true"
    android:state_selected="false"/&gt;</pre></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>It's important to remember the file is read from top to bottom so the first item that meets the state requirements will be used. A default drawable, one with no states included, would need to go last.</p></div></div><p>For this recipe, we will <a id="id136" class="indexterm"/>use a state selector to change the<a id="id137" class="indexterm"/> background color based on the <code class="literal">ToggleButton</code> state.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec81"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it <code class="literal">StateSelector</code> using the default <strong>Phone &amp; Tablet</strong> options. When prompted for the <strong>Activity Type</strong>, select <strong>Empty Activity</strong>. To make it easier to type the code for this recipe, we will use a color as the graphic to represent the button state.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec82"/>How to do it...</h2></div></div></div><p>We will start by creating the state selector, which is a resource file defined with XML code. We will then set up the button to use our new state selector. Here are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new <code class="literal">XML</code> file in the <code class="literal">res/drawable</code> folder and call it: <code class="literal">state_selector.xml</code>. The file should consist of the following XML code:<div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;selector &gt;
    &lt;item
        android:drawable="@android:color/darker_gray"
        android:state_checked="true"/&gt;
    &lt;item
        android:drawable="@android:color/white"
        android:state_checked="false"/&gt;
&lt;/selector&gt;</pre></div></li><li class="listitem">Now open the <strong>activity_main.xml</strong> file and drop in a <code class="literal">ToggleButton</code> as follows:<div><pre class="programlisting">&lt;ToggleButton
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="New ToggleButton"
    android:id="@+id/toggleButton"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true"
    android:background="@drawable/state_selector" /&gt;</pre></div></li><li class="listitem">Run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec83"/>How it works...</h2></div></div></div><p>The main <a id="id138" class="indexterm"/>concept to understand here is the Android <a id="id139" class="indexterm"/>State Selector. As shown in Step 2, we created a resource file which specified a<a id="id140" class="indexterm"/> <strong>drawable</strong> (a color in this case) based on <code class="literal">state_checked</code>.</p><p>Android supports many other state conditions besides checked. While typing in <code class="literal">android:state</code>, look at the autocomplete dropdown to see the list of other options.</p><p>Once we have the drawable resource created (the XML from step 1), we just have to tell the view to use it. Since we wanted the background color to change based on the state, we use the <code class="literal">android:background</code> property.</p><p>
<code class="literal">state_selector.xml</code> is a drawable resource that can be passed to any property that accepts a drawable. We could, for example, replace the button in a checkbox with the following XML:</p><div><pre class="programlisting">android:button="@drawable/state_selector"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec84"/>There's more...</h2></div></div></div><p>What if we wanted actual images for the graphics instead of just a color change? This is as easy as changing the drawable referenced in the item state.</p><p>The source code available for download uses two graphic images, downloaded from: <a class="ulink" href="https://pixabay.com/">https://pixabay.com/</a> (this was chosen because the images are free to use and didn't require a login.)</p><p>Once you have your desired images, place them in the <code class="literal">res/drawable</code> folder. Then, change the state item line in the XML to reference your images. Here's an example:</p><div><pre class="programlisting">&lt;item
    android:drawable="@drawable/checked_on"
    android:state_checked="true"/&gt;</pre></div><p>(Change <code class="literal">check_on</code> to match your image resource name.)</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Using designated folders for screen-specific resources</h3></div></div></div><p>When Android <a id="id141" class="indexterm"/>encounters a <code class="literal">@drawable</code> <a id="id142" class="indexterm"/>reference, it expects to find the target in one of the <code class="literal">res/drawable</code> folders. These are designed for different screen densities: <code class="literal">ldpi</code> (low dots per inch), <code class="literal">mdpi</code> (medium), <code class="literal">hdpi</code> (high), and <code class="literal">xhdpi</code> (extra-high) and they allow us to create resources for specific target devices. When an application is running on a specific device, Android will load resources from the designated folder that most closely matches the actual screen density. </p><p>If it finds this folder empty, it will try the next nearest match and so on until it finds the named resource. For tutorial purposes, a separate set of files for each possible density is not required, and so placing our images in the <code class="literal">drawable</code> folder is a simple way to run the exercise on any device.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>For a complete list of resource identifiers<a id="id143" class="indexterm"/> available, visit <a class="ulink" href="http://developer.android.com/guide/topics/resources/providing-resources.html">http://developer.android.com/guide/topics/resources/providing-resources.html</a>.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec85"/>See also</h2></div></div></div><p>For another example on Android resource selection, see the recipe on <em>Selecting theme based on the OS version later</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Creating a widget at runtime</h1></div></div></div><p>As <a id="id144" class="indexterm"/>mentioned before, generally, the UI is declared in <code class="literal">XML</code> files <a id="id145" class="indexterm"/>and then modified during runtime through the Java code. It is possible to create the UI completely in Java code, though for a complex layout, it would generally not be considered best practice.</p><p>The GridView example from the previous chapter was created in code. But unlike the GridView recipe, in this recipe, we are going to add a view to the existing layout defined in <code class="literal">activity_main.xml</code>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec86"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it <code class="literal">RuntimeWidget</code>. Select the <strong>Empty Activity</strong> option when prompted for the <strong>Activity type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec87"/>How to do it...</h2></div></div></div><p>We will start by adding an ID attribute to the existing layout so we can access the layout in code. Once we have a reference to the layout in code, we can add new views to the existing layout. Here are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">res/layout/activity_main.xml</code> and add an ID attribute to the main <code class="literal">RelativeLayout</code>, as follows:<div><pre class="programlisting">android:id="@+id/layout"</pre></div></li><li class="listitem">Completely remove the default <code class="literal">&lt;TextView&gt;</code> element.</li><li class="listitem">Open the <code class="literal">MainActivity.java</code> file so we can add code to the <code class="literal">onCreate()</code> method. Add the following code (after <code class="literal">setContentView())</code> to get a reference to the <code class="literal">RelativeLayout</code>:<div><pre class="programlisting">RelativeLayout layout = (RelativeLayout)findViewById(R.id.layout);</pre></div></li><li class="listitem">Create a DatePicker and add it to the layout with the following code:<div><pre class="programlisting">DatePicker datePicker = new DatePicker(this);
layout.addView(datePicker);</pre></div></li><li class="listitem">Run the program on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec88"/>How it works...</h2></div></div></div><p>This is hopefully <a id="id146" class="indexterm"/>very straightforward code. First, we get a reference <a id="id147" class="indexterm"/>to the parent layout using <code class="literal">findViewById</code>. We added the ID to the existing RelativeLayout (in step 1) to make it easier to reference. We create a DatePicker in code and add it to the layout with the <code class="literal">addView()</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec89"/>There's more...</h2></div></div></div><p>What if we wanted to create the entire layout from code? Though it may not be considered best practice, there are times when it is certainly easier (and less complex) to create a layout from code. Let's see how this example would look if we didn't use the layout from <code class="literal">activity_main.xml</code>. Here's how the onCreate() would look:</p><div><pre class="programlisting">
<strong>@Override</strong>
<strong>protected void </strong>onCreate(Bundle savedInstanceState) {
    <strong>super</strong>.onCreate(savedInstanceState);
    RelativeLayout layout = <strong>new </strong>RelativeLayout(<strong>this</strong>);
    DatePicker datePicker = <strong>new </strong>DatePicker(<strong>this</strong>);
    layout.addView(datePicker);
    setContentView(layout);
}</pre></div><p>In this example, it's really<a id="id148" class="indexterm"/> not that different. If you create a view in code and want <a id="id149" class="indexterm"/>to reference it later, you either need to keep a reference to the object, or assign the view an ID to use <code class="literal">findViewByID()</code>. To give a view an ID, use the <strong>setID()</strong> method by passing in <strong>View.generateViewId()</strong> (to generate a unique ID) or define the ID using <strong>&lt;resources&gt;</strong> in xml.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Creating a custom component</h1></div></div></div><p>As we have seen in <a id="id150" class="indexterm"/>previous recipes, the Android SDK provides a wide range of components. But what happens when you can't find a prebuilt component that fits your unique needs? You can always create your own!</p><p>In this recipe, we will walk through creating a custom component that derives from the View class, just like the built-in widgets. Here's a high-level overview:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new class that extends View.</li><li class="listitem">Create custom constructor(s).</li><li class="listitem">Override <code class="literal">onMeasure()</code>, and the default implementation returns a size of 100 x 100.</li><li class="listitem">Override <code class="literal">onDraw()</code>, and the default implementation draws nothing.</li><li class="listitem">Define custom methods and listeners (such as on&lt;<em>Event</em>&gt;()).</li><li class="listitem">Implement custom functionality.</li></ol></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>While overriding <code class="literal">onMeasure()</code>
<a id="id151" class="indexterm"/> and <code class="literal">onDraw()</code>
<a id="id152" class="indexterm"/> is not strictly required, the default behavior is likely not what you would want.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec90"/>Getting ready</h2></div></div></div><p>Start a new project in Android Studio and call it <code class="literal">CustomView</code>. Use the default wizard options, including the <strong>Phone &amp; Tablet SDK</strong> and select <strong>Empty Activity</strong> when prompted for the Activity type. Once the project files are created and open in Android Studio, you are ready to begin.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec91"/>How to do it...</h2></div></div></div><p>We will create a new class for our custom component to derive from the Android View class. Our custom component could be a subclass of an existing class, such as the Activity, but we will create it in a separate file to make it easier to maintain. Here are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start by creating a new Java class and also call it <code class="literal">CustomView</code>. This is where we will implement our custom component, as described in the introduction.</li><li class="listitem">Change the class constructor so it extends View. It should look as follows:<div><pre class="programlisting">public class CustomView extends View {</pre></div></li><li class="listitem">Define a <code class="literal">Paint</code> object for the class, which will be used in the onDraw():<div><pre class="programlisting">final Paint mPaint = new Paint();</pre></div></li><li class="listitem">Create a default constructor, which requires the activity <code class="literal">Context</code>, so we can inflate the view. We will set the paint properties here as well. The constructor should look as follows:<div><pre class="programlisting">public CustomView(Context context) {
    super(context);
    mPaint.setColor(Color.BLACK);
    mPaint.setTextSize(30);
}</pre></div></li><li class="listitem">Override the <a id="id153" class="indexterm"/>onDraw() method as follows:<div><pre class="programlisting">@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    setBackgroundColor(Color.CYAN);
    canvas.drawText("Custom Text", 100, 100, mPaint);
    invalidate();
}</pre></div></li><li class="listitem">Finally, inflate our custom view in <code class="literal">MainActivity.java</code> by replacing the <code class="literal">setContentView()</code> with our view, as shown:<div><pre class="programlisting">setContentView(new CustomView(this));</pre></div></li><li class="listitem">Run the application on a device or emulator to see it in action.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec92"/>How it works...</h2></div></div></div><p>We start by extending the View class, just as the built-in components do. Next, we create the default constructor. This is important as we need the context to pass down to the super class, which we do with the call:</p><div><pre class="programlisting">super(context);</pre></div><p>We need to override <code class="literal">onDraw()</code>, otherwise, as mentioned in the introduction, our custom view won't display anything. When <code class="literal">onDraw()</code> is called, the system passes in a <strong>Canvas</strong> object. The canvas<a id="id154" class="indexterm"/> is the area of the screen for our view. (Since we didn't override <code class="literal">onMeasure()</code>, our view would be 100 x 100, but since our entire activity consists of just this view, we get the whole screen as our canvas.)</p><p>We created the <code class="literal">Paint</code> object at the class level, and as <code class="literal">final</code>, to be more efficient with memory allocation. (<code class="literal">onDraw()</code> should be as efficient as possible since it can be called multiple times per second.) As you see from running the program, our onDraw() implementation just sets the <a id="id155" class="indexterm"/>background color to cyan and prints text to the screen (using <code class="literal">drawText()</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec93"/>There's more...</h2></div></div></div><p>Actually, there's a lot more. We've just touched the surface of what you can do with a custom component. Fortunately, as you see from this example, it doesn't take a lot of code to get basic functionality. We could easily spend an entire chapter on topics such as passing layout parameters to the view, adding listener callbacks, overriding <code class="literal">onMeasure()</code>, using our view in the IDE, and so on. These are all features you can add as your needs dictate.</p><p>While a custom component should be able to handle any solution, there are other options that might require less coding. Extending an existing widget is often sufficient without the overhead of a custom component from scratch. If what you need is a solution with multiple widgets, there's also the<a id="id156" class="indexterm"/> <strong>compound control</strong>. A compound control, such as a combo box, is just two or more controls grouped together as a single widget.</p><p>A compound control would generally extend from a layout, not a View, since you will be adding multiple widgets. You probably wouldn't need to override onDraw() and onMeasure(), as each widget would handle the drawing in their respective methods.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec94"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information on drawing, look at <em>Chapter 9, Graphics and Animation</em>. For full details on the<a id="id157" class="indexterm"/> View object, refer to the Android Developer resource at: <a class="ulink" href="http://developer.android.com/reference/android/view/View.html">http://developer.android.com/reference/android/view/View.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Applying a style to a View</h1></div></div></div><p>A <strong>style</strong> <a id="id158" class="indexterm"/>is a collection<a id="id159" class="indexterm"/> of property settings to define the look of a View. As<a id="id160" class="indexterm"/> you have already seen while defining layouts, a view offers many settings to determine how it looks, as well as functions. We have already set a view height, width, background color, and padding, plus there are many more settings such as text color, font, text size, margin, and so on. Creating a style is as simple as pulling these settings from the layout and putting them in a style resource.</p><p>In this recipe, we will go through the steps of creating a style and hooking it up to a view. </p><p>Similar to Cascading Style Sheets, Android Styles allow you to specify your design settings separate from the UI code.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec95"/>Getting ready</h2></div></div></div><p>Create a new Android <a id="id161" class="indexterm"/>Studio project and call it <code class="literal">Styles</code>. Use the default wizard <a id="id162" class="indexterm"/>options to create a Phone &amp; Tablet project and select Empty Activity when prompted for the Activity. By default, the wizard also creates a <code class="literal">styles.xml</code> file, which we will use for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec96"/>How to do it...</h2></div></div></div><p>We will create our own style resource to change the appearance of a <code class="literal">TextView</code>. We can add our new style to the <code class="literal">styles.xml</code> resource created by Android Studio using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the default <code class="literal">styles.xml</code> file located in <code class="literal">res/values</code>, as shown here:<div><img src="img/B05057_03_05.jpg" alt="How to do it..."/></div></li><li class="listitem">We will create a new style called <code class="literal">MyStyle</code> by adding the following XML below the existing <code class="literal">AppTheme </code>style:<div><pre class="programlisting">&lt;style name="MyStyle"&gt;
    &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt;
    &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt;
    &lt;item name="android:background"&gt;#000000&lt;/item&gt;
    &lt;item name="android:textColor"&gt;#AF0000&lt;/item&gt;
    &lt;item name="android:textSize"&gt;20sp&lt;/item&gt;
    &lt;item name="android:padding"&gt;8dp&lt;/item&gt;
    &lt;item name="android:gravity"&gt;center&lt;/item&gt;
&lt;/style&gt;</pre></div></li><li class="listitem">Now tell the view to use this style. Open the <code class="literal">activity_main.xml</code> file and add the following attribute to the existing <code class="literal">&lt;TextView&gt;</code> element:<div><pre class="programlisting">style="@style/MyStyle"</pre></div></li><li class="listitem">Either run the application or view the results in the <strong>Design</strong> tab.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec97"/>How it works...</h2></div></div></div><p>A <strong>style</strong> is a <a id="id163" class="indexterm"/>resource, defined by using the <code class="literal">&lt;style&gt;</code> element nested<a id="id164" class="indexterm"/> in a <code class="literal">&lt;resources&gt; </code>element of an xml file. We used the existing <code class="literal">styles.xml</code> file, but that is not a requirement, as we can use whatever filename we want. As seen in this recipe, multiple <code class="literal">&lt;style&gt; </code>elements can be included in one xml file.</p><p>Once the style is created, you can easily apply it to any number of other views as well. What if you wanted to have a button with the same style? Just drop a button in the layout and assign the same style.</p><p>What if we created a new button, but wanted the button to expand the full width of the view? How do we override the style for just that view? Simple, specify the attribute in the layout as you've always done. The local attribute will take priority over the attribute in the <strong>style</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec98"/>There's more...</h2></div></div></div><p>There is another feature<a id="id165" class="indexterm"/> of styles<strong>: inheritance</strong>. By specifying a parent when defining the style, we can have styles build on each other, creating a hierarchy of styles. If you look at the default style in <code class="literal">styles.xml</code>: <code class="literal">AppTheme</code>, you will see the following line:</p><div><pre class="programlisting">&lt;<strong>style </strong>name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;</pre></div><p>
<code class="literal">AppTheme</code> inherits from a theme defined in the Android SDK.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>If you want to inherit from a style you have created yourself, there is a shortcut method. Instead of using the parent attribute, you can specify the parent name first, followed by a period, then the new name, such as: </p><p>
<code class="literal">&lt;style name="MyParent.MyStyle" &gt;</code>
</p></div></div><p>You saw how to specify a style for a view, but what if we wanted all the TextViews in our application to use a specific style? We'd have to go back to each TextView and specify the style. But there's another way. We can include a <code class="literal">textViewStyle</code> item<a id="id166" class="indexterm"/> in a style to automatically assign a style to all TextViews. (There's a style for each of the widget types so you can do this for Buttons, ToggleButtons, TextViews, and so on.)</p><p>To set the style for all TextViews, add the following line to the <code class="literal">AppTheme</code> style:</p><div><pre class="programlisting">&lt;<strong>item </strong>name="android:textViewStyle"&gt;@style/MyStyle&lt;/<strong>item</strong>&gt;</pre></div><p>Since the theme for our application already uses <code class="literal">AppThem</code>, we only have to add that single line to <code class="literal">AppTheme</code> to have all our TextViews styled with our custom <code class="literal">MyStyle</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec99"/>See also</h2></div></div></div><p>The Android Design Support Library<a id="id167" class="indexterm"/> at:</p><p>
<a class="ulink" href="http://android-developers.blogspot.de/2015/05/android-design-support-library.html">http://android-developers.blogspot.de/2015/05/android-design-support-library.html</a>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Turning a style into a theme</h1></div></div></div><p>A <strong>theme</strong> is a style<a id="id168" class="indexterm"/> applied to an Activity or the whole application. To set a<a id="id169" class="indexterm"/> theme, use the <code class="literal">android:theme</code> attribute in the <code class="literal">AndroidManifest.xml</code> file. The <code class="literal">theme</code> attribute applies to the <code class="literal">&lt;Application&gt;</code> element as well as the <code class="literal">&lt;Activity&gt;</code> elements. All views within that element will be styled with the theme specified.</p><p>It's common to set the Application theme, but then override a specific Activity with a different theme.</p><p>In the previous recipe, we set the <code class="literal">textViewStyle</code> using the AppTheme style (which the wizard created automatically.) In this recipe, you will learn how to set both the Application and Activity themes.</p><p>Along with the style settings we have already explored, there are additional style options we didn't discuss because they don't apply to a View, they apply to the window as a whole. Settings such as hiding the application title or Action Bar and setting the window background, just to name a few, apply to the window and therefore must be set as a theme.</p><p>For this recipe, we are going to create a new theme based on the auto-generated <code class="literal">AppTheme</code>. Our new theme will modify the window appearance to make it a <strong>dialog</strong>. We will also look at the <code class="literal">theme</code> settings in the <code class="literal">AndroidManifest.xml</code>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec100"/>Getting ready</h2></div></div></div><p>Start a new project in Android Studio and call it <code class="literal">Themes</code>. Use the default wizard options and select the <strong>Empty Activity</strong> when prompted for the Activity type.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec101"/>How to do it...</h2></div></div></div><p>We start by adding a<a id="id170" class="indexterm"/> new theme to the existing <code class="literal">styles.xml</code> file to <a id="id171" class="indexterm"/>make our activity look like a dialog. Here are the steps to create the new theme and set activity to use the new theme:</p><div><ol class="orderedlist arabic"><li class="listitem">Since <strong>themes</strong> are defined in the same resource as <strong>styles</strong>, open the <code class="literal">styles.xml</code> file located in <code class="literal">res/values</code> and create a new style. We will create a new style based on the AppTheme already provided, and set <code class="literal">windowIsFloating</code>. The XML will be as follows:<div><pre class="programlisting">&lt;style name="AppTheme.MyDialog"&gt;
    &lt;item name="android:windowIsFloating"&gt;true&lt;/item&gt;
&lt;/style&gt;</pre></div></li><li class="listitem">Next, set the Activity to use this new dialog theme. Open the <code class="literal">AndroidManifest.xml</code> file and add a <code class="literal">theme</code> attribute to the Activity element, as shown:<div><pre class="programlisting">&lt;activity android:name=".MainActivity"
    android:theme="@style/AppTheme.MyDialog"&gt;</pre></div><p>Note that both Application and Activity will now have a theme specified.</p></li><li class="listitem">Now run the application on a device or emulator to see the dialog theme in action.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec102"/>How it works...</h2></div></div></div><p>Our new theme <code class="literal">MyDialog</code> inherits the base <code class="literal">AppTheme</code> using the alternative parent declaration, since <code class="literal">AppTheme</code> is defined in our code (and not a system theme). As mentioned in the introduction, some settings apply to the window as a whole, which is what we see with the <code class="literal">windowIsFloating</code> setting. Once our new theme is declared, we assign our theme to the activity in the <code class="literal">AndroidManifest</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec103"/>There's more...</h2></div></div></div><p>You might have noticed we could have just added the <code class="literal">windowIsFloating</code> to the existing <code class="literal">AppTheme</code> and been done. Since this application only has one Activity, the end result would be the same, but then, any new activities would also appear as a dialog.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Selecting theme based on the Android version</h1></div></div></div><p>Most users prefer to <a id="id172" class="indexterm"/>see apps using the latest themes provided by Android. <strong>Now supports Material Theme</strong> is common for apps upgrading to Android Lollipop. To be competitive with the many other apps in the market, you'll probably want to upgrade your app as well, but what about your users who are still running older versions of Android? By setting up our resources properly, we can use <strong>resource selection</strong>
<a id="id173" class="indexterm"/> in Android to automatically define the parent theme based on the Android OS version the user is running.</p><p>First, let's explore the three main themes available in Android:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Theme – Gingerbread and earlier</li><li class="listitem" style="list-style-type: disc">Theme.Holo – Honeycomb (API 11)</li><li class="listitem" style="list-style-type: disc">Theme.Material – Lollipop (API 21)</li></ul></div><p>(As of writing this, there does not appear to be a new theme in Android 6.0.)</p><p>This recipe will show how to properly set up the resource directories for Android to use the most appropriate theme based on the API version the app is running on.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec104"/>Getting ready</h2></div></div></div><p>Start a new project in Android Studio and call it <code class="literal">AutomaticThemeSelector</code>. Use the default wizard option to make a Phone &amp; Tablet project. Select the <strong>Empty Activity</strong> when prompted for the Activity Type.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec105"/>How to do it...</h2></div></div></div><p>Depending on the API version selected, Android Studio may use the App Compatability libraries. We don't want to use these libraries for this project since we want to explicitly set which theme to use. We will start by making sure we are extending from the generic Activity class, then we can add our new style resources to select the theme based on the API. Here are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">We need to make sure <code class="literal">MainActivity</code> extends from <code class="literal">Activity</code> and not <code class="literal">AppCompatActivity</code>. Open <code class="literal">ActivityMain.java</code> and if necessary, change it to read as follows:<div><pre class="programlisting">public class MainActivity extends Activity {</pre></div></li><li class="listitem">Open <code class="literal">activity_main.xml</code> and drop in two views: a Button and a Checkbox.</li><li class="listitem">Open <code class="literal">styles.xml</code> and remove <code class="literal">AppTheme</code> as it will not be used. Add our new theme so the file reads as follows:<div><pre class="programlisting">&lt;resources&gt;
    &lt;style name="AutomaticTheme" parent="android:Theme.Light"&gt;
    &lt;/style&gt;
&lt;/resources&gt;</pre></div></li><li class="listitem">We need to create<a id="id174" class="indexterm"/> two new values folders for API 11 and 21. To do this, we need to change Android Studio to use the Project view rather than the Android view. (Otherwise, we won't see the new folders in the next step.) At the top of the <strong>Project</strong> window, it shows <strong>Android</strong>, change this to <strong>Project</strong> for the Project View. See the following screenshot:<div><img src="img/B05057_03_06.jpg" alt="How to do it..."/></div></li><li class="listitem">Create a new <a id="id175" class="indexterm"/>directory by right-clicking on the <code class="literal">res</code> folder and navigating to <strong>New</strong> | <strong>Directory</strong>, as shown in this screenshot:<div><img src="img/B05057_03_07.jpg" alt="How to do it..."/></div><p>Use the <a id="id176" class="indexterm"/>following name for the first directory: <code class="literal">values-v11</code>
</p><p>Repeat this for the second directory using <code class="literal">values-v21</code>
</p></li><li class="listitem">Now create a <code class="literal">styles.xml</code> file in each of the new directories. (Right-click on the <code class="literal">values-v11</code> directory and go to the <strong>New</strong> | <strong>File</strong> option.) For <code class="literal">values-v11</code>, use the following style to define the Holo theme:<div><pre class="programlisting">&lt;resources&gt;
    &lt;style name="AutomaticTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;/style&gt;
&lt;/resources&gt;
For the values-v21, use the following code to define the Material theme:
&lt;resources&gt;
    &lt;style name="AutomaticTheme" parent="android:Theme.Material.Light"&gt;
    &lt;/style&gt;
&lt;/resources&gt;</pre></div></li><li class="listitem">The last step is to tell the application to use our new theme. To do this, open <code class="literal">AndroidManifest.xml</code> and change the <code class="literal">android:theme</code> attribute to <code class="literal">AutomaticTheme</code>. It should read as follows:<div><pre class="programlisting">android:theme="@style/AutomaticTheme"</pre></div></li><li class="listitem">Now run the application on a physical device or emulator. If you want to see the three different themes, you will need to have a device or emulator running the different versions of Android.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec106"/>How it works...</h2></div></div></div><p>In this recipe, we<a id="id177" class="indexterm"/> are using the Android resource selection process to assign the appropriate theme (which is a resource) based on the API version. Since we need to choose the theme based on the OS version in which it was released, we created two new values folders specifying the API version. This gives us a total of three <code class="literal">styles.xml </code>files: the default style, one in the <code class="literal">values-v11</code> directory, and the last in the <code class="literal">values-v21</code> directory.</p><p>Notice the same theme name is defined in all three <code class="literal">styles.xml</code> files. This is how the resource selection works. Android will use the resource from the directory that best fits our values. Here we are using the API level, but other criteria are available as well. It is very common to define separate resources based on other criteria, such as screen size, screen density, and even orientation.</p><p>The last step was to specify our new theme as the application theme, which we did in the Android Manifest. </p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec107"/>There's more…</h2></div></div></div><p>For more information on resource selection, see the <em>Using designated folders for screen-specific resources</em> topic in the previous recipe, <em>Using graphics to show button state</em>.</p></div></div></body></html>