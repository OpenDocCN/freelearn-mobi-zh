- en: Chapter 12. Publishing Apps to Google Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"I always believe that the sky is the beginning of the limit."            
                                                                   - MC Hammer*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Testing is an important precursor to the distribution of the app via Google
    Play store. In this chapter, we will provide an overview of the importance of
    testing our Android Wear app and the tooling available for it, as well as how
    to automate UI testing. We will conclude the chapter with step-by-step instructions
    on how to get the app ready for publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It does not take too long for any programmer to learn the hard and valuable
    lesson that testing code is as important as coding itself. Ignore that lesson
    and a QA team worth its salt will be sure to bring you to your knees. Testing
    all on its own is a topic that deserves a lot of attention. There are countless
    resources, including books, out there that will sell you on a wide array of testing
    methodologies and philosophies. **Test-driven Development** (**TDD**) is worth
    researching if you are new to testing.
  prefs: []
  type: TYPE_NORMAL
- en: However, all that is out of the scope of this book. In this chapter, we are
    more concerned about the testing tooling provided by the Android platform geared
    toward Wear development, as well as the test APIs that are at your disposal. Let's
    take a closer look at that in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: The need for testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The single most compelling reason to test code, in general, is to catch regressions
    as early as possible in the application development life cycle. With every code
    change that is made, there is a possibility that it has impacted the way another
    area of the system works, often negatively. But by crafting well thought out (repeatable)
    tests for every isolated and smallest possible unit of code, we have a means to
    ensure that it continues to function as it is meant to. These unit tests are critical
    validation points that, through their failures, raise flags of code instability.
  prefs: []
  type: TYPE_NORMAL
- en: Since each piece of code is to be tested in isolation, it often becomes necessary
    to simulate the forces that are external to the unit of code in question. Mocking
    frameworks used in conjunction with unit tests make this easy; for example, mocking
    an external service that is called by the unit under test.
  prefs: []
  type: TYPE_NORMAL
- en: Types of unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on whether the unit of code runs independent of the Android platform,
    there are two types of tests, local tests and instrumented test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local tests**: These tests are the unit tests that run on the local **Java
    Virtual Machine** (**JVM**). Any code run as a local test will run without any
    dependency on the Android system, or it will at the very least be able to simulate
    such a dependency through a mocking framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The online documentation for the step-by-step instruction on unit tests can
    found at [https://developer.android.com/training/testing/unit-testing/index.html](https://developer.android.com/training/testing/unit-testing/index.html).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrumented tests**: These tests, in contrast, run on an Android device
    or emulator and are the recommended approach to run unit tests that have Android
    dependencies that are too complex or involved to simulate using mocking frameworks.
    These tests provide ready access to instrumentation information, such as access
    to the global information about an application environment through the `android.content.Context`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For step-by-step instructions on building instrumented tests, refer to the documentation
    at [https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html](https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One difference that will jump out at you right away is that in your Android
    Studio project, the source files for local unit tests are stored in the `module-name/src/test/java`
    folder, while the source files for instrumented unit tests are stored in the `module-name/src/androidTest/java`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Automating user interface tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Wear apps in particular, there are certain aspects of development that need
    to be tested very carefully, and unit tests may not be sufficient in these cases.
    Complex UI interactions are one such example. Ideally, a human tester would be
    able to catch many of these issues, but it does not take long for that to prove
    inefficient in terms of time and cost, not to mention prone to human error and
    oversight.
  prefs: []
  type: TYPE_NORMAL
- en: By writing our UI tests to simulate human interaction, we can save time and
    increase confidence in the quality of our tests. Automated UI tests are coded
    in the same designated Android test folder as our instrumented unit tests, that
    is, the `module-name/src/androidTest/java` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Code implemented in this folder is built by the Android plugin for Gradle and
    executed on the same device that the app is intended to run on. This lets us use
    UI testing frameworks to simulate user interactions on the target app. Furthermore,
    automated UI tests may span a single app or multiple apps.
  prefs: []
  type: TYPE_NORMAL
- en: Single app tests, using a UI testing framework such as **Espresso**, allow us
    to programmatically simulate user interactions such as entering a specific input
    on a specific activity. They also let us exercise the effects of user interactions
    on various activities of the app by letting us test that the correct UI output
    is rendered in response to a piece of user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-app tests (also known as the cross-app functional tests), using a UI testing
    framework such as UI Automator, let us verify interactions between apps. For instance,
    if we wanted our test to launch (say) the calculator app and perform a calculation
    that will, in turn, be used to drive an input to a field in our app, **UI Automator**
    makes this possible.
  prefs: []
  type: TYPE_NORMAL
- en: Test APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android tests are based on **JUnit**. We write our unit or integration test
    classes as JUnit 4 classes.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JUnit is an instance of the **xUnit** architecture for unit testing frameworks.
    It offers a way to perform common setup, teardown, and assertion operations in
    our unit tests. A test class can contain one or more methods. Common JUnit annotations
    can be used to mark a method that performs setup work (the `@Before` class) or
    teardown work (the `@After` class) work. The `@Test` annotation marks a test method.
  prefs: []
  type: TYPE_NORMAL
- en: From within a JUnit test class, we can use the `AndroidJUnitRunner` test runner
    class to invoke the Espresso or UI Automator APIs to implement our user interactions
    and inter-app simulations.
  prefs: []
  type: TYPE_NORMAL
- en: The AndroidJUnitRunner class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `AndroidJUnitRunner` class is a test runner that lets us run JUnit test
    classes on Android devices. The test runner loads our test package and our app
    to a device and then runs our tests and reports results. Apart from JUnit support,
    the `AndroidJUnitRunner` class includes the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access to instrumentation information**: An `InstrumentationRegistry` class
    provides easy access to the instrumentation object, the target app''s `Context`
    object, and the test app''s `Context` object. This data becomes particularly useful
    when our tests use the UI Automator framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test filtering**: In addition to standard annotations supported by JUnit
    4, some Android-specific annotations are also available. The `@RequiresDevice`
    annotation specifies that the test should run only on physical devices (and not
    on emulators). The `@SdkSuppress` annotation keeps the test from running on an
    Android API level that is lower than a specified level; for example, the `@SDKSupress(minSdkVersion=18)`
    annotation will suppress tests on all API levels that are lower than 18.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Sharding**: The `AndroidJUnitRunner` class provides support to split
    a test suite into multiple shards thereby allowing the grouping of tests by any
    given shard (identifiable by an index number).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Espresso
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Espresso is a testing framework geared toward testing user flows within an app.
    It provides a set of APIs that let us craft tests that use the implementation
    details from the app that is being tested. Features include view and adapter matching,
    action APIs, and UI thread synchronization, each discussed briefly in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: View and Adapter matching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Expresso.onView()` method gives us access to a specific UI component in
    the target app. The method searches the view hierarchy for a match and returns
    a View reference that meets the specified criteria (which is supplied as part
    of the matcher argument passed to the method). Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The returned reference can then be used to perform user actions on it or test
    assertions against it.
  prefs: []
  type: TYPE_NORMAL
- en: While View matching lets you bring back a View reference, Adapter matching is
    useful when the target View is inside a layout that is subclassed from the `AdapterView`
    class. In this case, only a subset of the layout's views may be loaded in the
    current view hierarchy. The `Espresso.onData()` method can be used to access a
    target view element.
  prefs: []
  type: TYPE_NORMAL
- en: Action APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `android.support.test.espresso.action.ViewActions` API, we can perform
    user actions such as clicks, swipes, button presses, text entry, and hyperlinking.
  prefs: []
  type: TYPE_NORMAL
- en: UI Automator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Google's UI Automator provides a set of APIs that enables UI tests to interact
    with user apps and system apps. The UI Automator API lets us programmatically
    open the **Settings** menu or the app launcher on a test device. If the test code
    does not depend on the implementation details of the target app, then the UI Automator
    framework can be a good candidate for writing automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This framework includes the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: The UI Automator viewer to inspect layout hierarchy and view properties of UI
    components that are visible in the device foreground. This tool is located in
    the `<android-sdk>/tools` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `android.support.test.uiautomator.UiDevice` API to retrieve state information
    and perform operations on the device on which the target app is running. The `UiDevice`
    class supports operations such as changing the device rotation, pressing the back,
    home, or menu buttons; and taking a screenshot of the current view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how the `UiDevice` class can be used
    easily to simulate a short press on the home button:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The UI Automator APIs that support cross-app UI testing. These APIs let us capture
    and manipulate UI components across multiple apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monkey and monkeyrunner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Monkey is a command-line tool that sends pseudorandom streams of gestures, keystrokes
    and touches to devices. It is run via the **Android Debug Bridge** (**ADB**) tool,
    and is primarily meant to stress test your app.
  prefs: []
  type: TYPE_NORMAL
- en: Monkeyrunner is an API and execution environment for test programmers coded
    in Python. It includes functions for connecting to a device, installing and uninstalling
    packages, taking screenshots, and so on. A monkeyrunner command-line tool is available
    to run programs that use the monkeyrunner API.
  prefs: []
  type: TYPE_NORMAL
- en: For a more in-depth look at these topics, as well as how to measure UI performance
    and automate UI performance tests, we should take a look at the online documentation
    on the developer's site ([https://developer.android.com/training/testing/start/index.html](https://developer.android.com/training/testing/start/index.html))
    as our primary reference.
  prefs: []
  type: TYPE_NORMAL
- en: The human touch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter how solid our automated testing strategy, we really haven't tested
    our app until we have used it. That is why it is paramount to set time aside in
    our development cycle to test out the various features of our app, as well as
    user interactions. Every UI implementation code path must be exercised. There
    is no substitute for visual verification when it comes to confirming that our
    screens render acceptably in both square and round watch faces.
  prefs: []
  type: TYPE_NORMAL
- en: There may also be valuable insights gained to help us improve the way our user
    interactions are implemented. We should leverage the material design concepts
    we covered in previous chapters and use them to our advantage as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: App distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we covered in some detail how to test our app. Testing
    is a prerequisite for distribution, and it would serve us well to familiarize
    ourselves with what differentiates a Wear app in terms of quality. Check out the
    article from the online documentation at [https://developer.android.com/distribute/essentials/quality/wear.html](https://developer.android.com/distribute/essentials/quality/wear.html),
    which serves as a reminder in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have implemented our well-designed app and tested it as much as we can,
    we can start preparing to distribute it to potential users. That is the focus
    of this section to examine how to ready and distribute our Wear apps to users
    through Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we go through the process of building our release APKs using Android Studio,
    we find that two different APKs are generated, one for mobile and one for wearable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packaging a wearable app in Android Studio involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Replicate all permissions from the manifest file of the wearable app module
    to the manifest file of the handheld app module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the wearable and handheld app modules have the same package name
    and version number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a Gradle dependency in the handheld app's `build.gradle` file to the
    wearable app module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Build** | **Generate Signed APK...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps are illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging](img/image00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Pick a module to generate the APK for mobile or wear, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging](img/image00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Specify your release keystore by creating a new one or picking the one you
    already have available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging](img/image00236.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we create a new keystore path and sign our app using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging](img/image00237.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Specify a destination folder for the APK files and then click **Finish**, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging](img/image00238.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We should now find the two APK files available in the folder we specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging](img/image00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Publishing and opt-in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have built our APKs, run it through our tests for Wear app quality and
    determined that it is ready for release, we upload it to the **Developer Console**.
    This is the step during which we set up distribution options and update the store
    listing with any screenshots of our Wear app. A detailed launch checklist is available
    in the online documentation ([https://developer.android.com/distribute/tools/launch-checklist.html](https://developer.android.com/distribute/tools/launch-checklist.html)),
    and it is recommended that you read it prior to publishing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our app is ready for release, we may opt into Android Wear from the *Pricing
    and Distribution* section of the Developer Console. Opt-in implies that our app
    meets the Wear app quality criteria and is an affirmation that we want our app
    to be made more discoverable to Android Wear users through Google Play. Consider
    the following diagram depicting the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing and opt-in](img/image00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once we have opted in, we can publish our app as usual, at which stage Google
    Play submits our app for review against the **Wear App Quality criteria**. We
    are notified of the results once they become available. If the app is found to
    meet all the Wear App quality criteria, Google Play will proceed to make it more
    discoverable to Android Wear users.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, the app is found to fall short, then an e-mail notification is
    sent to our developer account address with the areas highlighted requiring our
    attention. Once we address these issues, we can upload a new version of our app
    to the Developer Console to initiate another round of opt-in and review.
  prefs: []
  type: TYPE_NORMAL
- en: The *Pricing and Distribution* page in the *Android Wear* section of the **Google
    Play Developer Console** holds the review and approval status of our app at any
    given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We click on the **Add new application** button, as shown in the following screenshot,
    to upload our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing and opt-in](img/image00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We specify a default language and a title before proceeding to upload the APK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing and opt-in](img/image00242.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose the type of release, that is, **Production**, **Beta**, or **Alpha Testing** ,
    and then click the relevant **Upload** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing and opt-in](img/image00243.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then pick our Wear (or mobile) APK file and attempt the upload, depicted
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing and opt-in](img/image00244.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we are prompted to fill in app metadata that is necessary for
    publishing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing and opt-in](img/image00245.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can click on the **Why can''t I publish?**  link in the top-right corner
    to display any items that are missing. Here is an example of all the items needed
    to publish the app. Once they are added, the app should be ready for publishing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publishing and opt-in](img/image00246.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced Android testing and distinguished between local
    unit tests and instrumented tests. We then summarized the tooling available for
    testing our wear apps in Android Studio before we took a brief look at how to
    accomplish automation with UI testing. We concluded with a discussion of the stages
    that must be traversed when preparing our apps for distribution via Google Play.
  prefs: []
  type: TYPE_NORMAL
