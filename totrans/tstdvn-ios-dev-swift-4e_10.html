<html><head></head><body>
		<div><h1 id="_idParaDest-108"><em class="italic"><a id="_idTextAnchor177"/>Chapter 7</em>: Building a Table View Controller for the To-Do Items</h1>
			<p>If you have talked to other iOS developers about unit testing and the test-driven development of iOS apps, you might have heard the opinion that the user interface of iOS apps is not testable and also shouldn't be tested. Many developers state that it is enough to check whether the user interface is correct by running the app during development and testing it manually.</p>
			<p>That might be true for the initial implementation of the user interface. During the development process, you run the app often on the iOS simulator or on your test devices and most bugs and errors in the user interface are quite obvious.</p>
			<p>However, the main benefit of a user interface that is backed by unit tests is the ability to fearlessly refactor code that is no longer perfect. As a developer, you gain experience every day, and each year, Apple releases new APIs that make our code easier to understand and sometimes easier to write. Long-living apps need to be refactored all the time to keep them manageable.</p>
			<p>This is the main argument for writing tests for user interfaces in iOS development. When you are confident that the user interface is backed by good tests, you can execute extreme refactoring without breaking tested features.</p>
			<p>In this chapter, we are going to build a table view controller that shows the information of the to-do items. This view controller is the main part of the app, so it is a good idea to start with it. The chapter is structured as follows:</p>
			<ul>
				<li>Adding the table view for the to-do items</li>
				<li>Testing the data source of a table view</li>
				<li>Refactoring to a diffable data source</li>
				<li>Presenting two sections</li>
				<li>Implementing the delegate of a table view </li>
			</ul>
			<p>After you have worked through this chapter, you will be able to write unit tests for table view controllers and table view cells.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor178"/>Technical requirements</h1>
			<p>The source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07</a>. </p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor179"/>Adding the table view for the to-do items</h1>
			<p>As always, we <a id="_idIndexMarker214"/>start with a test. But before we can write the test, we need a new test class. Follow these steps to add a test class for the view controller that shows the to-do items:</p>
			<ol>
				<li>Select the <code>ToDoItemsListViewControllerTests</code>.</li>
				<li>In the created file, add <code>@testable import ToDo</code> and remove the two template test methods.</li>
				<li>Add a property for the system under test (<code>sut</code>):<pre>// ToDoItemsListViewControllerTests.swift
class ToDoItemsListViewControllerTests: XCTestCase {
 
  var sut: ToDoItemsListViewController!
 
  override func setUpWithError() throws {
    // Put setup code here. This ...
  }
 
  override func tearDownWithError() throws {
    // Put teardown code here. This ...
  }
}</pre></li>
			</ol>
			<p>Xcode complains that it <strong class="bold">Cannot find type 'ToDoItemsListViewController' in scope</strong>. This is expected as we haven't added this class yet.</p>
			<ol>
				<li value="4">Select the <code>ToDoItemsListViewController</code> in the <strong class="bold">Class</strong> field and make it a <strong class="bold">Subclass of</strong>: <strong class="bold">UIViewController</strong>. Make sure that <strong class="bold">Also create XIB file</strong> is not checked.</li>
			</ol>
			<div><div><img src="img/Figure_7.01_B18127.jpg" alt="Figure 7.1 – Options for ToDoItemsListViewController&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Options for ToDoItemsListViewController</p>
			<p>Remove all the template code within the <code>ToDoItemsListViewController</code> class.</p>
			<ol>
				<li value="5">We are going to <a id="_idIndexMarker216"/>switch between <code>ToDoItemsListViewController</code> and its test class several times. So, it might be a good idea to open both files side by side. In Xcode, you can do that by clicking the <code>ToDoItemsListViewControllerTests.swift</code> file in the Project navigator and then holding down the <em class="italic">Option</em> key and clicking the <code>ToDoItemsListViewController.swift</code> file. Xcode then opens the second file in the Assistant editor.</li>
			</ol>
			<div><div><img src="img/Figure_7.02_B18127.jpg" alt="Figure 7.2 – Test code and production code side by side in Xcode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Test code and production code side by side in Xcode</p>
			<ol>
				<li value="6">Before we can test anything in the view controller, we need to set up the system under test. Replace the <code>setUpWithError()</code> method with the following code:<pre>// ToDoItemsListViewControllerTests.swift
override func setUpWithError() throws {
  let storyboard = UIStoryboard(name: "Main", bundle: nil)
  sut = try XCTUnwrap(
    storyboard.instantiateInitialViewController()
    as? ToDoItemsListViewController
  )
  sut.loadViewIfNeeded()
}</pre></li>
			</ol>
			<p>As the view <a id="_idIndexMarker217"/>controller will be set up in the <code>Main</code> storyboard, we need to load it from the storyboard in the setup code. Note that the call to <code>loadViewIfNeeded()</code> is the actual loading of the view. If we don't call that method, the view does not get loaded and all outlets are <code>nil</code>.</p>
			<ol>
				<li value="7">To be a good citizen, we also need to clean up after each test. Replace the <code>tearDownWithError()</code> method with the following:<pre>// ToDoItemsListViewControllerTests.swift
override func tearDownWithError() throws {
  sut = nil
}</pre></li>
			</ol>
			<p>Loading from a storyboard can go wrong. Let's add a test to make sure this works.</p>
			<ol>
				<li value="8">Add the following test to <code>ToDoItemsListViewControllerTests</code>:<pre>// ToDoItemsListViewControllerTests.swift
func test_shouldBeSetup() {
  XCTAssertNotNil(sut)
}</pre></li>
			</ol>
			<p>This test asserts that the system under test is not nil after being loaded from the storyboard.</p>
			<p>Run the tests to make sure that setting up the system under tests works. This test fails in <code>setupWithError</code>.</p>
			<p>The setup method can't instantiate an instance of <code>ToDoItemsListViewController</code> from the storyboard because the initial view controller in the storyboard is of the <code>ViewController</code> type. Let's fix that.</p>
			<ol>
				<li value="9">Open <code>ToDoItemsListViewController</code>. </li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_7.03_B18127.jpg" alt="Figure 7.3 – Changing the initial view controller in the Main storyboard &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Changing the initial view controller in the Main storyboard </p>
			<p>Run the tests again to confirm that all the tests now pass.</p>
			<p>Finally, we are ready to write the first test in this new test class. In the following steps, we add a test that asserts that the view controller has a <code>tableView</code> property for the to-do items. Let's go:</p>
			<ol>
				<li value="1">Add the<a id="_idIndexMarker219"/> following test method to <code>ToDoItemsListViewControllerTests</code>:<pre>// ToDoItemsListViewControllerTests.swift
func test_shouldHaveTableView() {
  XCTAssertTrue(sut.tableView.isDescendant(of: sut.view))
}</pre></li>
			</ol>
			<p>The <code>isDescendant(of:)</code> method is defined on <code>UIView</code> and it returns <code>true</code> if the view on which it is called is in the hierarchy of the view that is passed in as a parameter. This means that this test asserts that <code>tableView</code> is added to <code>sut.view</code> or one of its subviews.</p>
			<p>Xcode complains that a <code>tableView</code> property to <code>ToDoItemsListViewController</code>.</p>
			<ol>
				<li value="2">Open <strong class="bold">Main.storyboard</strong> in the interface builder and open the library by clicking the plus button in the toolbar and dragging a table view onto the view of the view controller.</li>
			</ol>
			<div><div><img src="img/Figure_7.04_B18127.jpg" alt="Figure 7.4 – Adding a table view to the view controller&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Adding a table view to the view controller</p>
			<ol>
				<li value="3">Open the Assistant <a id="_idIndexMarker220"/>editor using the <code>ToDoItemsListViewController</code> class.</li>
			</ol>
			<div><div><img src="img/Figure_7.05_B18127.jpg" alt="Figure 7.5 – Dragging a connection from the storyboard into the class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Dragging a connection from the storyboard into the class</p>
			<ol>
				<li value="4">Set the name of<a id="_idIndexMarker221"/> this property to <code>tableView</code> and click <strong class="bold">Connect</strong>.</li>
			</ol>
			<p>Run all the tests. All the tests pass. We have added a table view to the view of the view controller.</p>
			<p>A table view is managed by a data source and a delegate. In the next section, we will implement parts of the data source of the table view.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor180"/>Testing the data source of a table view</h1>
			<p>In this<a id="_idIndexMarker222"/> section, we will implement parts of the data source<a id="_idIndexMarker223"/> for the table view using test-driven development. We will use the traditional approach by using the view controller as the data source. In the next section, we will switch <a id="_idTextAnchor181"/><a id="_idTextAnchor182"/>to a diffable data source. Our challenge in this section is to write the tests so that they are independent of the actual implementation of the data source.</p>
			<p>But first, we need to talk about test doubles.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor183"/>Adding a test double</h2>
			<p>In the film industry, doubles<a id="_idIndexMarker224"/> are used in scenes that are too dangerous for the actor. The double must look and act like the actor. In software testing, we have something similar: test doubles. Test doubles look and act like a piece of code, but can be controlled completely from within the test. For example, to test the data source of our table view, we need to connect the view controller with a store of to-do items. We could use the store we already implemented. But this would make the tests for the table view depend on the implementation of <code>ToDoItemStore</code>. It would be better to have a test double for <code>ToDoItemStore</code> we could use in the tests for <code>ToDoItemsListViewController</code>.</p>
			<p>Follow these steps to add a test double for <code>ToDoItemStore</code>:</p>
			<ol>
				<li value="1">The first step in implementing a test double for <code>ToDoItemStore</code> is to create a protocol that defines the interface our view controller expects. Add the following protocol to <code>ToDoItemStore.swift</code>:<pre>// ToDoItemStore.<a id="_idTextAnchor184"/><a id="_idTextAnchor185"/>swift
protocol ToDoItemStoreProtocol {
  var itemPublisher:
    CurrentValueSubject&lt;[ToDoItem], Never&gt;
      { get set }
  func check(_: ToDoItem)
}</pre></li>
			</ol>
			<p>The protocol defines the elements the view controller needs. It needs to subscribe to changes of the items and it also needs a way to check a to-do item.</p>
			<ol>
				<li value="2">Now that we have the protocol, we can add the conformance to the protocol to <code>ToDoItemStore</code>:<pre>// ToDoItemStore.swift
class ToDoItemStore: ToDoItemStoreProtocol {
  // …
}</pre></li>
				<li>Next, we need a test <a id="_idIndexMarker225"/>double conforming to that protocol. Select the <code>ToDoItemStoreProtocolMock</code>. Replace the contents of that file with this<a id="_idTextAnchor188"/><a id="_idTextAnchor189"/> code:<pre>// ToDoItemStoreProtocolMock.swift
import Foundation
import Combine
@testable import ToDo
 
class ToDoItemStoreProtocolMock: ToDoItemStoreProtocol {
  var itemPublisher =
    CurrentValueSubject&lt;[ToDoItem], Never&gt;([])
 
  var checkLastCallArgument: ToDoItem?
  func check(_ item: ToDoItem) {
    checkLastCallArgument = item
  }
}</pre></li>
			</ol>
			<p>With this implementation of the test double, we can control how the store used in the view controller behaves. We will see next how we can use this test double in a test.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor190"/>Using test doubles to implement a number of rows</h2>
			<p>A table <a id="_idIndexMarker226"/>view data source needs to provide two kinds of information: first, the number of rows in a given section and second, the cell for a given item. Sure, there are other methods defined in the <code>UITableViewDataSource</code> protocol, but those are optional.</p>
			<p>Let's start with the number of rows in a given section. In the default case, the number of sections in a table view is one. This means we are interested in the number of rows in the first and only section. Follow these steps to implement the correct number of rows for the table<a id="_idIndexMarker227"/> view:</p>
			<ol>
				<li value="1">Add the following property to <code>ToDoItemsListViewControllerTests</code>:<pre>// ToDoItemsListViewControllerTes<a id="_idTextAnchor191"/><a id="_idTextAnchor192"/><a id="_idTextAnchor193"/>ts.s<a id="_idTextAnchor194"/><a id="_idTextAnchor195"/><a id="_idTextAnchor196"/>wift
var toDoItemSt<a id="_idTextAnchor197"/><a id="_idTextAnchor198"/>oreMock: ToDoItemStoreProtocolMock!</pre></li>
				<li>Next, set it up in <code>setUpWithError()</code> and make the system under test use it:<pre>// ToDoItemsListViewControllerTests.swift
override func setUpWithError() throws {
  let storyboard = UIStoryboard(name: "Main", bundle: nil)
  sut = try XCTUnwrap(
    storyboard.instantiateInitialViewController()
    as? ToDoItemsListViewController
  )
  toDoItemStoreMock = ToDoItemStoreProtocolMock()
  sut.toDoItemStore = toDoItemStoreMock
  sut.loadViewIfNeeded()
}</pre></li>
			</ol>
			<p>This code does not compile<a id="_idTextAnchor199"/><a id="_idTextAnchor200"/> because <code>toDoItemStore</code> is missing in <code>ToDoItemsListViewController</code>.</p>
			<ol>
				<li value="3">Open <code>ToDoItemsListViewController</code> in the editor and add the missing property: <pre>// ToDoItemsListViewController.swift 
class ToDoItemsListViewController: UIViewController { 
  
  @IBOutlet weak var tableView: UITab<a id="_idTextAnchor201"/><a id="_idTextAnchor202"/>leView! 
  var toDoItemStore: ToDoItemStoreProtocol? 
}</pre></li>
				<li>Next, add<a id="_idIndexMarker228"/> the following test to <code>ToDoItemsListViewControllerTests</code>:<pre>// ToDoItemsListViewControllerTe<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/><a id="_idTextAnchor205"/>sts.swift
func test_numberOfRows_whenOneItemIsSent_shouldReturnOne() {
  toDoItemStoreMock.itemPublisher
    .send([ToDoItem(title: "dummy 1")])
  let result = sut.tableView.numberOfRows(inSection: 0)
  XCTAssertEqual(result, 1)
}</pre></li>
			</ol>
			<p>In this test, we send a <code>ToDoItem</code> instance using its <code>itemPublisher</code>. We expect that the table view should then have one row in section zero.</p>
			<p>Run all the tests to confirm that this new test fails.</p>
			<ol>
				<li value="5">At the moment, the table view has no data source set. The <code>dataSource</code> property is nil. To make this test pass, we first need to assign <code>ToDoItemsListViewController</code> to the <code>dataSource</code> property of the table view. Add the following method to <code>ToDoItemsListViewController</code>:<pre>// ToDoItemsListViewControl<a id="_idTextAnchor206"/><a id="_idTextAnchor207"/>ler.swift
override func viewDidLoad() {
  super.viewDid<a id="_idTextAnchor208"/><a id="_idTextAnchor209"/>Load()
  tableView.dataSource = self
}</pre></li>
			</ol>
			<p>Xcode complains that it <code>ToDoItemsListViewController</code> does not yet conform to the <code>UITableViewDataSource</code> protocol.</p>
			<ol>
				<li value="6">Add the<a id="_idIndexMarker229"/> following extension to <code>ToDoItemsListViewController.swift</code>:<pre>// ToDoItemsListViewContro<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/>ller.swift
extension ToDoItemsListViewController: 
  UITableViewDataSource {
  func tableView(
    _ tableView: UITableView,
    numberOfRowsInSection section: Int) -&gt; Int {
 
      return 1
    }
 
  func tableView(
    _ tableView: UITableView,
    cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
 
      return UITableViewCell()
    }
}</pre></li>
			</ol>
			<p>This is the minimal code to make <code>ToDoItemsListViewController</code> conform to the <code>UITableViewDataSource</code> protocol and make the test pass.</p>
			<p>You might be wondering why we return a hardcoded fixed value from <code>tableView(_:numberOfRowsInSection:)</code>. This is clearly wrong and won't result in a working app. Patience. At the moment, our task is to make the test pass and this is what we have accomplished. Our feeling that this implementation is wrong just means we need another test to make sure the implementation is correct. </p>
			<ol>
				<li value="7">Add the <a id="_idIndexMarker230"/>following test method to <code>ToDoItemsListViewControllerTests</code>:<pre>// ToDoItemsListViewController<a id="_idTextAnchor212"/><a id="_idTextAnchor213"/><a id="_idTextAnchor214"/>Tests.swift
func test_numberOfRows_whenTwoItemsAreSent_shouldReturnTwo() 
{
  toDoItemStoreMock.itemPublisher
    .send([
      ToDoItem(title: "dummy 1"),
      ToDoItem(title: "dummy <a id="_idTextAnchor215"/><a id="_idTextAnchor216"/>2")
    ])
  let result = sut.tableView.numberOfRows(inSection: 0)
  XCTAssertEqual(result, 2)
}</pre></li>
			</ol>
			<p>To make this test pass without breaking any previous tests, we need to process the items that are sent by the item publisher in the view controller.</p>
			<ol>
				<li value="8">First, import Combine and add two properties, <code>items</code> and <code>token</code>, to <code>ToDoItemsListViewController</code>:<pre>// ToDoItemsListViewController.swift
class ToDoItemsListViewController: UIViewController {
 
  @IBOutlet weak var tableView: UITableView!
  var toDoItemStore: ToDoItemSto<a id="_idTextAnchor217"/><a id="_idTextAnchor218"/>reProtocol?
  private var items: [ToDoItem] = []
  private var token: AnyCancellable?
 
  // …
}</pre></li>
			</ol>
			<p>The <code>items</code> property will hold the items sent by the item publisher and the <code>token</code> property will hold a reference to the subscriber subscribed to that publisher. Without <a id="_idIndexMarker231"/>a reference to the subscriber, <code>Combine</code> would destroy the subscriber before we can use it.</p>
			<ol>
				<li value="9">Next, change <code>viewDidLoad()</code> in <code>ToDoItemsListViewController</code> so that it looks like this:<pre>// ToDoItemsListViewController.swift
override func viewDidLoad() {
  super.vi<a id="_idTextAnchor219"/><a id="_idTextAnchor220"/>ewDidLoad()
  tableView.dataSource = self
  token = toDoItemStore?.itemPublisher
    .sink(receiveValue: { [weak self] items in
      self?.items = items
  })
}</pre></li>
			</ol>
			<p>With this code, we subscribe to changes sent by the item publisher of <code>toDoItemStore</code>. We store the sent items in the <code>items</code> property we just added.</p>
			<ol>
				<li value="10">Finally, we can<a id="_idIndexMarker232"/> return the number of items in <code>tableView(_:numberOfRowsInSection:)</code>:<pre>// ToDoItemsListViewController.swift
func tableView(
  _ tableView: UITableView,
  numberOfRowsInSection section: Int) <a id="_idTextAnchor221"/><a id="_idTextAnchor222"/>-&gt; Int {
    return items.count
  }</pre></li>
			</ol>
			<p>Run the tests. All the tests pass.</p>
			<p>Next, we are going to use our test double to implement the to-do item cell for the table view.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor223"/>Using test doubles to implement setting up the to-do item cell</h2>
			<p>As always, when <a id="_idIndexMarker233"/>implementing a new microfeature, we need a test. Follow these steps to add the failing test and the implementation that makes the test pass:</p>
			<ol>
				<li value="1">Add the following test method to <code>ToDoItemsListViewControllerTests.swift</code>:<pre>// ToDoItemsListViewControl<a id="_idTextAnchor224"/><a id="_idTextAnchor225"/>lerTests.swift
func test_cellForRowAt_shouldReturnCellWithTitle() throws 
{
  let titleUnderTest = "dummy 1"
  toDoItemStoreMock.itemPublisher
    .send([ToDoItem(title: titleUnderTest)])
  let tableView = try XCTUnwrap(sut.tableView)
  let indexPath = IndexPath(row: 0, section: 0)
  let cell = try XCTUnwrap(
    tableView.dataSource?
      .tableView(tableView,
                 cellForRowAt: indexPath)
    as? ToDoItemCell
  )
}</pre></li>
			</ol>
			<p>This is not the complete test, but we need to pause here because the <code>ToDoItemCell</code> type is not yet defined. </p>
			<ol>
				<li value="2">Select the <code>ToDoItemCell</code> and make it a <code>UITableViewCell</code>. Remove the template code within the class.</li>
				<li>Go back to <code>ToDoItemsListViewControllerTests</code> and add the test assertion, as<a id="_idIndexMarker234"/> shown in the following code block:<pre>// ToDoItemsListViewControllerTests.swift
func test_cellForRowAt_shouldReturnCellWithTitle1() throws {
  let titleUnderTest = "dummy 1"
  toDoItemStoreMock.itemPublisher
    .send([ToDoItem(title: titleUnderTest)])
  let tableView = try XCTUnwrap(sut.tableView)
  let indexPath = IndexPath(row: 0, section: 0)
  let cell = try XCTUnwrap(
    tableView.dataSource?
      .tableView(tableView,
                 cellForRowAt: indexPath)
    as? To<a id="_idTextAnchor228"/><a id="_idTextAnchor229"/>Do<a id="_idTextAnchor230"/><a id="_idTextAnchor231"/>ItemCell
  )
  XCTAssertEqual(cell.titleLabel.text, titleUnderTest)
}</pre></li>
			</ol>
			<p>In this test, we publish a list with one to-do item using our test double. Then we execute the <code>tableView(_:cellForRowAt:)</code> method defined in the data source of the table view. The returned table view cell should have a label showing the title of the to-do item sent by the publisher. This test does not compile at the moment because the cell doesn't have a property with the name <code>titleLabel</code>.</p>
			<ol>
				<li value="4">Add the<a id="_idIndexMarker235"/> property to <code>ToDoItemCell</code>:<pre>// ToDoItemCell.swift
class ToDoItemCell: UIT<a id="_idTextAnchor232"/><a id="_idTextAnchor233"/>ableViewCell {
  let titleLabel = UILabel()
}</pre></li>
			</ol>
			<p>Now the tests compile. Run the tests to confirm that the new test fails.</p>
			<p>If you are an experienced iOS developer, you might have realized that this code is not enough. The label is initialized, but it is not added to the cell. We will fix that later in this section.</p>
			<ol>
				<li value="5">The test we have just added fails because the data source of the table view does not return a cell of the <code>ToDoItemCell</code> type. Go to <code>ToDoItemsListViewController</code>  and replace the <code>tableView(_:cellForRowAt:)</code> method with the following code:<pre>// ToDoItemsListViewController.swift
func tableView(
  _ tableView: UITableView,
  cellForRowAt indexPath: IndexPath) -&gt; U<a id="_idTextAnchor234"/><a id="_idTextAnchor235"/>ITableViewCell {
    let cell = ToDoItemCell()
    cell.titleLabel.text = "dummy 1"
    return cell
  }</pre></li>
			</ol>
			<p>Even though this code makes all the tests pass (run the tests to confirm), these few lines of code have several issues. One issue is that the text in <code>titleLabel</code> is hardcoded to the string expected by the test. It might seem stupid to write code like this, but this is kind of essential to TDD. Code that uses hardcoded values to make the tests pass tells us that we need more tests.</p>
			<ol>
				<li value="6">Add the<a id="_idIndexMarker236"/> following test to <code>ToDoItemsListViewController</code>:<pre>// ToDoItemsListViewCont<a id="_idTextAnchor236"/><a id="_idTextAnchor237"/>rollerTests.swift
func test_cellForRowAt_shouldReturnCellWithTitle2() throws 
{
  let titleUnderTest = "dummy 2"
  toDoItemStoreMock.itemPublisher
    .send([
      ToDoItem(title: "dummy 1"),
      ToDoItem(title: titleUnderTest)
    ])
  let tableView = try XCTUnwrap(sut.tableView)
  let indexPath = IndexPath(row: 1, section: 0)
  let cell = try XCTUnwrap(
    tableView.dataSource?
      .tab<a id="_idTextAnchor238"/><a id="_idTextAnchor239"/>leView(tableView,
                 cellForRowAt: indexPath)
    as? ToDoItemCell
  )
  XCTAssertEqual(cell.titleLabel.text, titleUnderTest)
}</pre></li>
			</ol>
			<p>You should try to find a better name for this test. I use this name here to keep the method name kind of short. Long method names do not look good in printed books.</p>
			<p>In this test, we send two to-do items to the system under test and check the text in the second cell. Run the tests. This new test fails because the text in <code>titleLabel</code> is hardcoded.</p>
			<ol>
				<li value="7">Change the<a id="_idIndexMarker237"/> implementation of <code>tableView(_:cellForRowAt:)</code> such that it looks like this:<pre>// ToDoItemsListViewController.swift
func tableView(
  _ tableView: UITableView,
  cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    let cell<a id="_idTextAnchor240"/><a id="_idTextAnchor241"/> = ToDoItemCell()
    let item = items[indexPath.row]
    cell.titleLabel.text = item.title
    return cell
  }</pre></li>
			</ol>
			<p>In this code, we get the item for that row from the <code>items</code> property and assign its title to the text of the <code>titleLabel</code> property. Run the tests to confirm that all the tests pass.</p>
			<p>The implementation code still has an issue. The cells in a table view should be reused to improve the rendering performance of the table view. Let's refactor the code without breaking the tests.</p>
			<ol>
				<li value="8">To opt in to the cell reuse capability of <code>UITableView</code>, add the following lines of code to <code>viewDidLoad()</code> in <code>ToDoItemsListViewController</code>:<pre>// ToDoItemsListVi<a id="_idTextAnchor242"/><a id="_idTextAnchor243"/>ewController.swift
tableView.register(
  ToDoItemCell.self,
  forCellReuseIdentifier: "ToDoItemCell"
)</pre></li>
			</ol>
			<p>With this call, we register <code>ToDoItemCell</code> for the reuse queue of the table view. </p>
			<ol>
				<li value="9">Now we<a id="_idIndexMarker238"/> can ask the table view to dequeue such a cell in <code>tableView(_:cellForRowAt:)</code>:<pre>// ToDoItemsListViewController.swift
func tableView(
  _ tableView: UITableView,
  cellForRowAt indexPath: IndexPath) -&gt;<a id="_idTextAnchor244"/><a id="_idTextAnchor245"/> UITableViewCell {
    let cell = tableView.dequeueReusableCell(
      withIdentifier: "ToDoItemCell",
      for: indexPath
    ) as! ToDoItemCell
    let item = items[indexPath.row]
    cell.titleLabel.text = item.title
    return cell
  }</pre></li>
			</ol>
			<p>Run the tests to confirm that we didn't break anything.</p>
			<p>The implementation of <code>ToDoItemCell</code> is not enough to make the cell show the title in the user interface. We have initialized the label, but we haven't added it to any view yet. This is<a id="_idIndexMarker239"/> what we will do next.</p>
			<p>We could write tests that check whether the label is added to the table view cell in the tests for the view controller. But if we think about it, they belong to dedicated tests for the cell itself. Follow these steps to add the test and the implementation that make the test pass:</p>
			<ol>
				<li value="1">Select the <code>ToDoItemCellTests</code> in the <strong class="bold">Text</strong> field next to <strong class="bold">Class</strong> and create the file. Remove the two template tests in the created file.</li>
				<li>Below the existing import statement, add the testable import of the <code>ToDo</code> module:<pre>// ToDoItemCellTests<a id="_idTextAnchor248"/><a id="_idTextAnchor249"/>.swift
import XCTest
@testable import ToDo</pre></li>
				<li>Before we can test anything relating to the table view cell, we need to set it up. Replace the implementation of the <code>ToDoItemCellTests</code> class with the following code:<pre>// ToD<a id="_idTextAnchor250"/><a id="_idTextAnchor251"/>oItemCellTests.swift
class ToDoItemCellT<a id="_idTextAnchor252"/><a id="_idTextAnchor253"/>ests: XCTestCase {
 
  var sut: ToDoItemCell!
 
  override func setUpWithError() throws {
    sut = ToDoItemCell()
  }
 
  override func tearDownWithError() throws {
    sut = nil
  }
}</pre></li>
				<li>Now we are<a id="_idIndexMarker240"/> ready to add the first test to this new test class. Add the following test method:<pre>// To<a id="_idTextAnchor254"/><a id="_idTextAnchor255"/>DoItemCellTests.swift
func test_hasTitleLabelSubview() {
  let subview = sut.titleLabel
  XCTAssertTrue(subview.isDescendant(of: sut.contentView))
}</pre></li>
			</ol>
			<p>The <code>isDescendant(of:)</code> method is defined on <code>UIView</code>. We have already seen this call earlier in this chapter when we wrote a test that asserted that the table view was added to the view of the view controller.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="5">To make this test pass, change the code in <code>ToDoItemCell</code> such that it looks like this:<pre>// ToDoItemCell.swift
class ToDoItemCell: UITableViewCell {
  let ti<a id="_idTextAnchor256"/><a id="_idTextAnchor257"/>tleLabel = UILabel()
  override init(style: UITableViewCell.CellStyle,
                reuseIdentifier: String?) {
    super.init(style: style, 
               reuseIdentifier: reuseIdentifier)
    contentView.addSubview(titleLabel)
  }
  required init?(coder: NSCoder) { fatalError() }
}</pre></li>
			</ol>
			<p>Run the tests to confirm that this code makes the test pass.</p>
			<ol>
				<li value="6">Now that the test <a id="_idIndexMarker241"/>passes, we move to the refactoring stage of the TDD workflow. Depending on your style of development, you may already be satisfied with this implementation. I like to structure the initialization of user interface elements differently. I would refactor that code to this:<pre>// ToDoItemCell.swift
class ToDoItemCell:<a id="_idTextAnchor258"/><a id="_idTextAnchor259"/> UITableViewCell {
 
  let titleLabel: UILabel
 
  override init(style: UITableViewCell.CellStyle,
                reuseIdent<a id="_idTextAnchor260"/><a id="_idTextAnchor261"/>ifier: String?) {
 
    titleLabel = UILabel()
 
    super.init(style: style,
               reuseIdentifier: reuseIdentifier)
 
    contentView.addSubview(titleLabel)
  }
 
  required init?(coder: NSCoder) { fatalError() }
}</pre></li>
			</ol>
			<p>The difference is that I prefer to initialize the elements within the <code>init</code> method. Run the test to confirm that all the tests still pass.</p>
			<p>Note that we have <a id="_idIndexMarker242"/>intentionally not implemented any positioning of the label. In my opinion, this is something we shouldn't test with a unit test. The positioning and the size of user interface elements depend on the size of the screen and the version of iOS. We could write tests for these values, but most probably, those would often break even though the app still works for the user. With our tests, we want to catch the real bugs.</p>
			<p>OK, this test was easy. Let's now add the two other required labels – <code>dateLabel</code> and <code>locationLabel</code>:</p>
			<ol>
				<li value="1">Add this test method to <code>ToDoItemCellTests</code>:<pre>// <a id="_idTextAnchor262"/><a id="_idTextAnchor263"/>ToDoItemCellTests.swift
func test_hasDateLabelSubview() {
  let subview = sut.dateLabel
  XCTAssertTrue(subview.isDescendant(of: sut.contentView))
}</pre></li>
				<li>Run the tests to confirm that this new test fails. The test fails because the <code>dateLabel</code> property is missing.</li>
				<li>Go to <code>ToDoItemCell</code> and add <a id="_idIndexMarker243"/>this property:<pre>// ToDoItemCell.swift
class ToDoItemCell: UITableViewCell {
 
  l<a id="_idTextAnchor264"/><a id="_idTextAnchor265"/>et titleLabel: UILabel
  let dateLabel: UILabel
 
  override init(style: UITableViewCell.CellStyle,
                reuseIdentifier: String?) {
 
    ti<a id="_idTextAnchor266"/><a id="_idTextAnchor267"/>tleLabel = UILabel()
    dateLabel = UILabel()
 
    super.init(style: style,
               reuseIdentifier: reuseIdentifier)
 
    contentView.addSubview(titleLabel)
  }
 
  required init?(coder: NSCoder) { fatalError() }
}</pre></li>
			</ol>
			<p>"Wait a minute, Dominik," I hear you say, "why didn't you add the label to the content view?" Good question! In TDD, you should only add code that makes the test pass. The test failed because the label was not defined. So, our task in this step is to add this <code>dateLabel</code> property. At the moment, we don't know whether this is enough to make the test pass. We have the feeling that this is not enough based on our previous experience with <code>titleLabel</code>, but it's better to confirm our feeling.</p>
			<p>Run the <a id="_idIndexMarker244"/>tests to confirm that the test is still failing. It still fails, but this time in the line of the assert function call. </p>
			<ol>
				<li value="4">To make it pass, add the following line below the existing <code>addSubview</code> ca<a id="_idTextAnchor268"/><a id="_idTextAnchor269"/>ll:<pre>// ToDoItemCell.swift
contentView.addSubview(dateLabel)</pre></li>
			</ol>
			<p>Run the tests again. Now, all the tests pass again.</p>
			<ol>
				<li value="5">When the <code>location</code> property of the to-do item is set, the cell should show the name of the <code>location</code> property. Add the following test to <code>ToDoItemCellTests</code>:<pre>/<a id="_idTextAnchor270"/><a id="_idTextAnchor271"/>/ ToDoItemCellTests.swift
func test_hasLocationLabelSubview() {
  let subview = sut.locationLabel
  XCTAssertTrue(subview.isDescendant(of: sut.  contentView))
}</pre></li>
			</ol>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="6">Add the property for the <code>location</code> label to <code>ToDoItemCell</code>:<pre>// ToDoItemCell.swift
class ToDoItemCell: UITableViewCell {
 
  let titleLabel: UILabel<a id="_idTextAnchor272"/><a id="_idTextAnchor273"/>
  let dateLabel: UILabel
  let locationLabel: UILabel
 
  override init(style: UITableViewCell.CellStyle,
                reuseIdentifier: String?) {
 
    titleLabel = UILabel()
    <a id="_idTextAnchor274"/><a id="_idTextAnchor275"/>dateLabel = UILabel()
    locationLabel = UILabel()
 
    super.init(style: style,
               reuseIdentifier: reuseIdentifier)
 
    contentView.addSubview(titleLabel)
    contentView.addSubview(dateLabel)
  }
 
  required init?(coder: NSCoder) { fatalError() }
}</pre></li>
			</ol>
			<p>Run the tests<a id="_idIndexMarker245"/> to see the last test still failing, but now in the line with the assert function call.</p>
			<ol>
				<li value="7">Add the line that adds <code>locationLabel</code> as a subview to <code>contentView</code> of the ce<a id="_idTextAnchor276"/><a id="_idTextAnchor277"/>ll:<pre>// ToDoItemCell.swift:
contentView.addSubview(locationLabel)</pre></li>
			</ol>
			<p>Run all the tests to make sure they all pass now.</p>
			<p>The next step is <a id="_idIndexMarker246"/>to fill the labels in the data source of the table view. Open <code>ToDoItemsListViewControllerTests</code> and follow these steps to add this feature to our app:</p>
			<ol>
				<li value="1">Add the following test to <code>ToDoItemsListViewControllerTests</code>:<pre>// ToDoItemsLi<a id="_idTextAnchor278"/><a id="_idTextAnchor279"/>stViewControllerTests.swift
func test_cellForRowAt_shouldReturnCellWithDate() throws {
  let date = Date()
  toDoItemStoreMock.itemPublisher
    .send([
      ToDoItem(title: "dummy 1",
               timestamp: date.timeIntervalSince1970)
    ])
  let tableView = try XCTUnwrap(sut.tableView)
  let indexPath = IndexPath(row: 0, section: 0)
  let cell = try XCTUnwrap(
    tableView.dataSource?
      .tableView(tableView,
                 cellForRowAt: indexPath)
    as? ToDoItemCell
  )
  XCTAssertEqual(cell.dateLabel.text,
                 sut.dateFormatter.string(from: date))
} </pre></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker247"/>now use <code>toDoItemStoreMock</code> to send a to-do item with a timestamp. In the <code>assert</code> function, we use a <code>dateFormatter</code> property that is not defined yet. Let's add this property to make the test compile.</p>
			<ol>
				<li value="2">Go to <code>ToDoItemsListViewController</code> and add the following property:<pre>// ToDoI<a id="_idTextAnchor280"/><a id="_idTextAnchor281"/>temsListViewController.swift
let dateFormatter = DateFormatter()</pre></li>
			</ol>
			<p>Now the test compiles. Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="3">To make the test pass, we need to set the date label in <code>tableView(_:cellForRowAt:)</code>. Add the following code right below <code>cell.textLabel.text = item.title</code>:<pre>// ToDoI<a id="_idTextAnchor282"/><a id="_idTextAnchor283"/>temsListViewController.swift
if let timestamp = item.timestamp {
  let date = Date(timeIntervalSince1970: timestamp)
  cell.dateLabel.text = dateFormatter.string(from: date)
}</pre></li>
			</ol>
			<p>We use the timestamp of the item to generate a date from it and ask the date formatter for a string representation of that date.</p>
			<p>Run all the tests to confirm that all the tests pass.</p>
			<p>The next step is to refactor the implementation. We could move the generation of the date string to the model object, but then the model object would need to know how the data is presented to the user. This is not a good idea. It would be better to move that code to a view model. That is a class connected to the view controller that converts the model data such that it can be presented in the user interface.</p>
			<p>We will leave it as it is because for our small app, it's OK to have this code in the view controller.</p>
			<p>You will implement <a id="_idIndexMarker248"/>the setting of the <code>location</code> label in the exercises later in this chapter.</p>
			<p>We have now implemented the presentation and the setup of the to-do item table view cells. With the tests in place, we can now look at the implementation and see whether we can improve it to better fit modern concepts in iOS development. The implementation we have built here is based on how table views have been implemented for many years. Over the last few years, better ways have emerged to set up a table view.</p>
			<p>In the following section, we will refactor our implementation to use a diffable data source.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor284"/>Refactoring to a diffable data source</h1>
			<p>In iOS 13, Apple introduced the <code>UITableViewDiffableDataSource</code> class. This class manages the update of a<a id="_idIndexMarker249"/> table view when the data changes and it can be used as the data source of any table view. It should be used, when possible, because implementing updates of a table view is a bit complicated and can lead to strange bugs and even crashes. In addition, the code needed to set up such a data source is often easier to read and reason about than the traditional implementation we used in the previous section.</p>
			<p>Follow these steps to<a id="_idIndexMarker250"/> transform our implementation to one that uses a diffable data source:</p>
			<ol>
				<li value="1">A diffable data source manages the data in the table view using a section and an item that both need to conform to the <code>Hashable</code> protocol. We already have an item we can use in the diffable data source, the <code>ToDoItem</code> structure. However, this structure does not yet conform to <code>Hashable</code>. To make it conform to that protocol, add the following code to <code>ToDoItem.swift</code> outside of the current <code>ToDoItem</code> im<a id="_idTextAnchor285"/><a id="_idTextAnchor286"/>plementation:<pre>// ToDoItem.swift
extension ToDoItem: Hashable {
  func hash(into hasher: inout Hasher) {
    hasher.combine(id)
  }
}</pre></li>
			</ol>
			<p>With this code, we tell the hasher provided by Swift to use the ID of the to-do item to generate the hash value. The ID of the to-do item is unique and therefore a good basis for a hash value.</p>
			<ol>
				<li value="2">Next, we need a<a id="_idIndexMarker251"/> section type that also conforms to <code>Hashable</code>. Add the following <code>enum</code> type to <code>ToDoItemsListViewController.swift</code>:<pre>// T<a id="_idTextAnchor287"/><a id="_idTextAnchor288"/>oDoItemsListViewController.swift
enum Section {
  case main
}</pre></li>
			</ol>
			<p>This is enough for now. We only need one section at the moment because later we will add another section to distinguish between to-do and done items.</p>
			<ol>
				<li value="3">Next, we need a property for the data source. Add the following property to <code>ToDoItemsListViewController</code>:<pre>// T<a id="_idTextAnchor289"/><a id="_idTextAnchor290"/>oDoItemsListViewController.swift
private var dataSource:
  UITableViewDiffableDataSource&lt;Section, ToDoItem&gt;?</pre></li>
				<li>In the <code>viewDidLoad()</code> method, replace the <code>tableView.dataSource = self</code> code with the following:<pre>// T<a id="_idTextAnchor291"/><a id="_idTextAnchor292"/>oDoItemsListViewController.swift
dataSource = 
UITableViewDiffableDataSource&lt;Section, ToDoItem&gt;(
  tableView: tableView,
  cellProvider: { [weak self] tableView, indexPath, item   in
    let cell = tableView.dequeueReusableCell(
      withIdentifier: "ToDoItemCell",
      for: indexPath
    ) as! ToDoItemCell
    cell.titleLabel.text = item.title
    if let timestamp = item.timestamp {
      let date = Date(timeIntervalSince1970: timestamp)
      cell.dateLabel.text = self?.dateFormatter
        .string(from: date)
    }
    return cell
})</pre></li>
			</ol>
			<p>With this code, we<a id="_idIndexMarker252"/> initialize a diffable data source for the table view. The second parameter of this initializer is a <code>cell</code> provider. This piece of code gets called when the table view needs to show a <code>cell</code> provider for a given index path. As you can see, the code within this closure looks similar to the code we had in <code>tableView(_:cellForRowAt:)</code> previously.</p>
			<ol>
				<li value="5">Now delete the extension that implemented the conformance to <code>UITableViewDataSource</code> within <code>ToDoItemsListViewController.swift</code>.</li>
				<li><code>UITableViewDiffableDataSource</code> manages table view updates via <code>NSDiffableDataSourceSnapshot</code>. To update the table view with new data, we need to create a snapshot and set it up with the new data. Add the following <a id="_idIndexMarker253"/>method to <code>ToDoItemsListViewController</code>:<pre>//<a id="_idTextAnchor293"/><a id="_idTextAnchor294"/> ToDoItemsListViewController.swift
private func update(with items: [ToDoItem]) {
  var snapshot =
  NSDiffableDataSourceSnapshot&lt;Section, ToDoItem&gt;()
  snapshot.appendSections([.main])
  snapshot.appendItems(items)
  dataSource?.apply(snapshot)
}</pre></li>
			</ol>
			<p>In this method, we create a snapshot and add one section and the items passed into that method.</p>
			<ol>
				<li value="7">The view controller receives updates from the publisher of <code>toDoItemStore</code>. Change the subscription code in <code>viewDidLoad</code> such that it looks like this:<pre>// ToDoItemsListViewController.swift
token = toDoItemStore?.itemPublisher
  .sink(receiveValue: { [weak self] items in
    self?.items = items
    self?.update(with: items)
})</pre></li>
			</ol>
			<p>In addition to assigning the received items to the <code>items</code> property of the view controller, we call here the new update method that applies a new snapshot to the data <a id="_idIndexMarker254"/>source.</p>
			<p>Run the tests. All the tests pass. We have now successfully refactored our table view code to use a diffable data source.</p>
			<p>Our list of to-do items should show two sections, one for the to-do items and one for the already done items. In the next section, we will change the snapshot creation to achieve this.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor295"/>Presenting two sections</h1>
			<p>As we have already <a id="_idIndexMarker255"/>refactored to a diffable data source, supporting two sections in the table view is quite easy. Follow these steps to implement two sections:</p>
			<ol>
				<li value="1">As always, we need to start with a failing test. Add the following test to <code>ToDoItemsListViewControllerTests</code>:<pre>// To<a id="_idTextAnchor296"/><a id="_idTextAnchor297"/>DoItemsListViewControllerTests.swift
func test_numberOfSections_shouldReturnTwo() {
  var doneItem = ToDoItem(title: "dummy 2")
  doneItem.done = true
  toDoItemStoreMock.itemPublisher
    .send([ToDoItem(title: "dummy 1"),
           doneItem])
  let result = sut.tableView.numberOfSections
  XCTAssertEqual(result, 2)
}</pre></li>
			</ol>
			<p>In this test, we set a to-do item and a done item to the table view using <code>toDoItemStoreMock</code>. The name of the test method should also include what the preconditions of the tests are. We use a shorter name in the book because otherwise, the code is harder to read. You should try to use a better name.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="2">To support<a id="_idIndexMarker256"/> two sections, <code>enum Section</code> needs two cases. Change the code of <code>enum Section</code> such that it looks like this:<pre>// ToDoItemsListViewController.swift
enum Section {
  case todo
  case done
}</pre></li>
				<li>Finally, we need to change the <code>update</code> method such that it looks like this:<pre>// ToDoItemsListViewController.swift
private func update(with items: [ToDoItem]) {
  var snapshot =
  NSDiffableDataSourceSnapshot&lt;Section, ToDoItem&gt;()
  snapshot.appendSections([.todo, .done])
  snapshot.appendItems(
    items.filter({ false == $0.done }),
    toSection: .todo)
  snapshot.appendItems(
    items.filter({ $0.done }),
    toSection: .done)
  dataSource?.apply(snapshot)
}</pre></li>
			</ol>
			<p>In this code, we add the two sections to the snapshot and use the <code>done</code> property of the to-do item to fill the two sections.</p>
			<p>Run the tests to <a id="_idIndexMarker257"/>confirm that this code makes the new test pass.</p>
			<p>The data source of the table view is now finished. The next step in implementing the list view of the to-do items is to add code that reacts to the user selecting the to-do item in the list.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor298"/>Implementing the delegate of a table view</h1>
			<p>When the user selects<a id="_idIndexMarker258"/> a to-do item in the list of items, the details of the to-do item should be shown in a dedicated view. We will implement the actual navigation between the different views of the app in <a href="B18127_11_ePub.xhtml#_idTextAnchor526"><em class="italic">Chapter 11</em></a>, <em class="italic">Easy Navigation with Coordinators</em>. In this section, we will implement the required code in <code>ToDoItemsListViewController</code>.</p>
			<p>Follow these steps to prepare <code>ToDoItemsListViewController</code> for navigation to the detail view:</p>
			<ol>
				<li value="1">Let's assume we already have a delegate that will provide a method the view controller can call. Add the following test method to <code>ToDoItemsListViewControllerTests</code>:<pre>//<a id="_idTextAnchor299"/><a id="_idTextAnchor300"/> ToDoItemsListViewControllerTests.swift
func test_didSelectCellAt_shouldCallDelegate() throws {
  let delegateMock = 
    ToDoItemsListViewControllerProtocolMock()
}</pre></li>
			</ol>
			<p>Xcode tells us that it cannot find the <code>ToDoItemsListViewControllerProtocolMock</code> type. This type is meant to be a mock object for the real delegate we will add in <a href="B18127_11_ePub.xhtml#_idTextAnchor526"><em class="italic">Chapter 11</em></a>, <em class="italic">Easy Navigation with Coordinators</em>. The view controller should tell the delegate that a to-do item was selected by the user. Let's add a mock object with a method for that task.</p>
			<ol>
				<li value="2">Select the <code>ToDoItemsListViewControllerProtocolMock</code> in the <strong class="bold">Save As</strong> field and then click <strong class="bold">Create</strong>. Replace the contents of the created file with the following:<pre>// ToDoItemsListViewControllerProtocolMock.sw<a id="_idTextAnchor303"/><a id="_idTextAnchor304"/>ift
import UIKit
@testable import ToDo
class ToDoItemsListViewControllerProtocolMock:
  ToDoItemsListViewControllerProtocol {    
  }</pre></li>
			</ol>
			<p>Again, Xcode<a id="_idIndexMarker259"/> tells us that a type is missing. This time, Xcode doesn't know anything about <code>ToDoItemsListViewControllerProtocol</code>.</p>
			<ol>
				<li value="3">Go to <code>ToDoItemsListViewController.swift</code> and add the following protocol below the import statemen<a id="_idTextAnchor305"/><a id="_idTextAnchor306"/>ts:<pre>// ToDoItemsListViewController.swift
protocol ToDoItemsListViewControllerProtocol {
  func selectToDoItem(
    _ viewController: UIViewController,
    item: ToDoItem)
}</pre></li>
				<li>Now we can <a id="_idIndexMarker260"/>finish the implementation of the protocol mock:<pre>// ToDo<a id="_idTextAnchor307"/><a id="_idTextAnchor308"/>ItemsListViewControllerProtocolMock.swift
class ToDoItemsListViewControllerProtocolMock:
  ToDoItemsListViewControllerProtocol {
 
  var selectToDoItemReceivedArguments:
  (viewController: UIViewController, 
   item: ToDoItem)?
 
  func selectToDoItem(
    _ viewController: UIViewController,
    item: ToDoItem) {
 
      selectToDoItemReceivedArguments =
      (viewController, item)
    }
}</pre></li>
			</ol>
			<p>This protocol mock stores the received argument to the call of the delegate method, <code>selectToDoItem(_:item:)</code>.</p>
			<ol>
				<li value="5">Now that we have this protocol mock, we can use it in our test:<pre>// ToDoItemsListViewControllerTest.swift
func test_didSelectCellAt_shouldCallDelegate() throws {
  let delegateMock =
    ToDoItemsListViewControllerProtocolMock()
  sut.delegate = delegateMock
}</pre></li>
			</ol>
			<p>We have to stop here because <code>sut</code> doesn't yet have a <code>delegate</code> property.</p>
			<ol>
				<li value="6">Add that property to <code>ToDoItemsListViewControl<a id="_idTextAnchor309"/><a id="_idTextAnchor310"/>ler</code>:<pre>// ToDoItemsListViewController.swift
var delegate: ToDoItemsListViewControllerProtocol?</pre></li>
				<li>Now we can<a id="_idIndexMarker261"/> finish the test method:<a id="_idTextAnchor311"/><a id="_idTextAnchor312"/><pre>// ToDoItemsListViewControllerTests.swift
func test_didSelectCellAt_shouldCallDelegate() throws {
  let delegateMock =
    ToDoItemsListViewControllerProtocolMock()
  sut.delegate = delegateMock
  let toDoItem = ToDoItem(title: "dummy 1")
  toDoItemStoreMock.itemPublisher
    .send([toDoItem])
  let tableView = try XCTUnwrap(sut.tableView)
  let indexPath = IndexPath(row: 0, section: 0)
  tableView.delegate?.tableView?(
    tableView,
    didSelectRowAt: indexPath)
  XCTAssertEqual(
    delegateMock.selectToDoItemReceivedArguments?.item,
    toDoItem)
}</pre></li>
			</ol>
			<p>After we have set the delegate of the system under test, we send one to-do item using <code>itemPublisher</code> of <code>toDoItemStoreMock</code>. Next, we call <code>tableView(_:didSelectRowAt:)</code> of the <code>tableViews</code> delegate. Finally, we assert that the protocol method, <code>selectToDoItem(_:item:)</code>, got called with the selected to-do item.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="8">To make the<a id="_idIndexMarker262"/> test pass, add the follow extension to <code>ToDoItemsListViewController.swift</code> outside of the class definition of <code>ToDoItemsListViewContr<a id="_idTextAnchor313"/><a id="_idTextAnchor314"/>oller</code>:<pre>// ToDoItemsListViewController.swift
extension ToDoItemsListViewController:
  UITableViewDelegate {
 
  func tableView(_ tableView: UITableView,
                 didSelectRowAt indexPath: IndexPath) {
 
    let item = items[indexPath.row]
    delegate?.selectToDoItem(self, item: item)
  }
}</pre></li>
			</ol>
			<p>In this implementation, we get the to-do item of the selected cell and call the delegate method with it.</p>
			<ol>
				<li value="9">To make <code>ToDoItemsListViewController</code> the delegate of the table view, add the<a id="_idIndexMarker263"/> following line to the end of <code>viewDidLoad()</code>:<pre>// ToDoItemsListViewController.swift
tableView.delegate = self</pre></li>
			</ol>
			<p>Now, run the tests to confirm that all the tests pass.</p>
			<p>For now, we are finished with implementing the list view of the to-do items.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor315"/>Summary</h1>
			<p>In this chapter, we have learned how to test table views and table view cells. We experienced the value of useful unit tests when refactoring a large part of the code. By switching from the traditional table view data source to the diffable data source, we improved the code and the behavior of the app while still keeping the existing tested functionality.</p>
			<p>In the next chapter, we will use the knowledge we gained to create a detailed view and its view controller.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor316"/>Exercises</h1>
			<ol>
				<li value="1">Implement the setting of the location label using test-driven development.</li>
				<li>Try to figure out in the documentation of Xcode how to add section headers when using a diffable data source. We will implement the section headers in <a href="B18127_11_ePub.xhtml#_idTextAnchor526"><em class="italic">Chapter 11</em></a>, <em class="italic">Easy Navigation with Coordinators</em>.</li>
			</ol>
		</div>
	</body></html>