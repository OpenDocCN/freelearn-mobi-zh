<html><head></head><body>
		<div id="_idContainer056">
			<h1 id="_idParaDest-108"><em class="italic"><a id="_idTextAnchor177"/>Chapter 7</em>: Building a Table View Controller for the To-Do Items</h1>
			<p>If you have talked to other iOS developers about unit testing and the test-driven development of iOS apps, you might have heard the opinion that the user interface of iOS apps is not testable and also shouldn't be tested. Many developers state that it is enough to check whether the user interface is correct by running the app during development and testing it manually.</p>
			<p>That might be true for the initial implementation of the user interface. During the development process, you run the app often on the iOS simulator or on your test devices and most bugs and errors in the user interface are quite obvious.</p>
			<p>However, the main benefit of a user interface that is backed by unit tests is the ability to fearlessly refactor code that is no longer perfect. As a developer, you gain experience every day, and each year, Apple releases new APIs that make our code easier to understand and sometimes easier to write. Long-living apps need to be refactored all the time to keep them manageable.</p>
			<p>This is the main argument for writing tests for user interfaces in iOS development. When you are confident that the user interface is backed by good tests, you can execute extreme refactoring without breaking tested features.</p>
			<p>In this chapter, we are going to build a table view controller that shows the information of the to-do items. This view controller is the main part of the app, so it is a good idea to start with it. The chapter is structured as follows:</p>
			<ul>
				<li>Adding the table view for the to-do items</li>
				<li>Testing the data source of a table view</li>
				<li>Refactoring to a diffable data source</li>
				<li>Presenting two sections</li>
				<li>Implementing the delegate of a table view </li>
			</ul>
			<p>After you have worked through this chapter, you will be able to write unit tests for table view controllers and table view cells.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor178"/>Technical requirements</h1>
			<p>The source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07</a>. </p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor179"/>Adding the table view for the to-do items</h1>
			<p>As always, we <a id="_idIndexMarker214"/>start with a test. But before we can write the test, we need a new test class. Follow these steps to add a test class for the view controller that shows the to-do items:</p>
			<ol>
				<li>Select the <strong class="bold">ToDoTests</strong> group in the Project navigator and add a new file from the <strong class="bold">File</strong> menu in Xcode. Select the template from <strong class="bold">iOS</strong> | <strong class="bold">Source</strong> | <strong class="bold">Unit Test Case Class</strong> and then click <strong class="bold">Next</strong>. Insert the name <strong class="source-inline">ToDoItemsListViewControllerTests</strong>.</li>
				<li>In the created file, add <strong class="source-inline">@testable import ToDo</strong> and remove the two template test methods.</li>
				<li>Add a property for the system under test (<strong class="source-inline">sut</strong>):<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">class ToDoItemsListViewControllerTests: XCTestCase {</p><p class="source-code"> </p><p class="source-code">  var sut: ToDoItemsListViewController!</p><p class="source-code"> </p><p class="source-code">  override func setUpWithError() throws {</p><p class="source-code">    // Put setup code here. This ...</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  override func tearDownWithError() throws {</p><p class="source-code">    // Put teardown code here. This ...</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Xcode complains that it <strong class="bold">Cannot find type 'ToDoItemsListViewController' in scope</strong>. This is expected as we haven't added this class yet.</p>
			<ol>
				<li value="4">Select the <strong class="bold">ToDo</strong> group <a id="_idIndexMarker215"/>in the Project navigator and add a new file through the <strong class="bold">File</strong> menu. Select the template from <strong class="bold">iOS</strong> | <strong class="bold">Source</strong> | <strong class="bold">Cocoa Touch Class</strong> and then click <strong class="bold">Next</strong>. Insert the name <strong class="source-inline">ToDoItemsListViewController</strong> in the <strong class="bold">Class</strong> field and make it a <strong class="bold">Subclass of</strong>: <strong class="bold">UIViewController</strong>. Make sure that <strong class="bold">Also create XIB file</strong> is not checked.</li>
			</ol>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_7.01_B18127.jpg" alt="Figure 7.1 – Options for ToDoItemsListViewController&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Options for ToDoItemsListViewController</p>
			<p>Remove all the template code within the <strong class="source-inline">ToDoItemsListViewController</strong> class.</p>
			<ol>
				<li value="5">We are going to <a id="_idIndexMarker216"/>switch between <strong class="source-inline">ToDoItemsListViewController</strong> and its test class several times. So, it might be a good idea to open both files side by side. In Xcode, you can do that by clicking the <strong class="source-inline">ToDoItemsListViewControllerTests.swift</strong> file in the Project navigator and then holding down the <em class="italic">Option</em> key and clicking the <strong class="source-inline">ToDoItemsListViewController.swift</strong> file. Xcode then opens the second file in the Assistant editor.</li>
			</ol>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_7.02_B18127.jpg" alt="Figure 7.2 – Test code and production code side by side in Xcode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Test code and production code side by side in Xcode</p>
			<ol>
				<li value="6">Before we can test anything in the view controller, we need to set up the system under test. Replace the <strong class="source-inline">setUpWithError()</strong> method with the following code:<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">override func setUpWithError() throws {</p><p class="source-code">  let storyboard = UIStoryboard(name: "Main", bundle: nil)</p><p class="source-code">  sut = try XCTUnwrap(</p><p class="source-code">    storyboard.instantiateInitialViewController()</p><p class="source-code">    as? ToDoItemsListViewController</p><p class="source-code">  )</p><p class="source-code">  sut.loadViewIfNeeded()</p><p class="source-code">}</p></li>
			</ol>
			<p>As the view <a id="_idIndexMarker217"/>controller will be set up in the <strong class="source-inline">Main</strong> storyboard, we need to load it from the storyboard in the setup code. Note that the call to <strong class="source-inline">loadViewIfNeeded()</strong> is the actual loading of the view. If we don't call that method, the view does not get loaded and all outlets are <strong class="source-inline">nil</strong>.</p>
			<ol>
				<li value="7">To be a good citizen, we also need to clean up after each test. Replace the <strong class="source-inline">tearDownWithError()</strong> method with the following:<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">override func tearDownWithError() throws {</p><p class="source-code">  sut = nil</p><p class="source-code">}</p></li>
			</ol>
			<p>Loading from a storyboard can go wrong. Let's add a test to make sure this works.</p>
			<ol>
				<li value="8">Add the following test to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">func test_shouldBeSetup() {</p><p class="source-code">  XCTAssertNotNil(sut)</p><p class="source-code">}</p></li>
			</ol>
			<p>This test asserts that the system under test is not nil after being loaded from the storyboard.</p>
			<p>Run the tests to make sure that setting up the system under tests works. This test fails in <strong class="source-inline">setupWithError</strong>.</p>
			<p>The setup method can't instantiate an instance of <strong class="source-inline">ToDoItemsListViewController</strong> from the storyboard because the initial view controller in the storyboard is of the <strong class="source-inline">ViewController</strong> type. Let's fix that.</p>
			<ol>
				<li value="9">Open <strong class="bold">Main.storyboard</strong> and <a id="_idIndexMarker218"/>change the <strong class="bold">Class</strong> field of the initial view controller to <strong class="source-inline">ToDoItemsListViewController</strong>. </li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_7.03_B18127.jpg" alt="Figure 7.3 – Changing the initial view controller in the Main storyboard &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Changing the initial view controller in the Main storyboard </p>
			<p>Run the tests again to confirm that all the tests now pass.</p>
			<p>Finally, we are ready to write the first test in this new test class. In the following steps, we add a test that asserts that the view controller has a <strong class="source-inline">tableView</strong> property for the to-do items. Let's go:</p>
			<ol>
				<li value="1">Add the<a id="_idIndexMarker219"/> following test method to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">func test_shouldHaveTableView() {</p><p class="source-code">  XCTAssertTrue(sut.tableView.isDescendant(of: sut.view))</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">isDescendant(of:)</strong> method is defined on <strong class="source-inline">UIView</strong> and it returns <strong class="source-inline">true</strong> if the view on which it is called is in the hierarchy of the view that is passed in as a parameter. This means that this test asserts that <strong class="source-inline">tableView</strong> is added to <strong class="source-inline">sut.view</strong> or one of its subviews.</p>
			<p>Xcode complains that a <strong class="bold">Value of type 'ToDoItemsListViewController' has no member 'tableView'</strong>. This is not a surprise because we haven't yet added a <strong class="source-inline">tableView</strong> property to <strong class="source-inline">ToDoItemsListViewController</strong>.</p>
			<ol>
				<li value="2">Open <strong class="bold">Main.storyboard</strong> in the interface builder and open the library by clicking the plus button in the toolbar and dragging a table view onto the view of the view controller.</li>
			</ol>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_7.04_B18127.jpg" alt="Figure 7.4 – Adding a table view to the view controller&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Adding a table view to the view controller</p>
			<ol>
				<li value="3">Open the Assistant <a id="_idIndexMarker220"/>editor using the <strong class="bold">Editor</strong> | <strong class="bold">Assistant menu item</strong>, hold down the <em class="italic">Ctrl</em> key, and drag a connection from the table view into the <strong class="source-inline">ToDoItemsListViewController</strong> class.</li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_7.05_B18127.jpg" alt="Figure 7.5 – Dragging a connection from the storyboard into the class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Dragging a connection from the storyboard into the class</p>
			<ol>
				<li value="4">Set the name of<a id="_idIndexMarker221"/> this property to <strong class="source-inline">tableView</strong> and click <strong class="bold">Connect</strong>.</li>
			</ol>
			<p>Run all the tests. All the tests pass. We have added a table view to the view of the view controller.</p>
			<p>A table view is managed by a data source and a delegate. In the next section, we will implement parts of the data source of the table view.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor180"/>Testing the data source of a table view</h1>
			<p>In this<a id="_idIndexMarker222"/> section, we will implement parts of the data source<a id="_idIndexMarker223"/> for the table view using test-driven development. We will use the traditional approach by using the view controller as the data source. In the next section, we will switch <a id="_idTextAnchor181"/><a id="_idTextAnchor182"/>to a diffable data source. Our challenge in this section is to write the tests so that they are independent of the actual implementation of the data source.</p>
			<p>But first, we need to talk about test doubles.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor183"/>Adding a test double</h2>
			<p>In the film industry, doubles<a id="_idIndexMarker224"/> are used in scenes that are too dangerous for the actor. The double must look and act like the actor. In software testing, we have something similar: test doubles. Test doubles look and act like a piece of code, but can be controlled completely from within the test. For example, to test the data source of our table view, we need to connect the view controller with a store of to-do items. We could use the store we already implemented. But this would make the tests for the table view depend on the implementation of <strong class="source-inline">ToDoItemStore</strong>. It would be better to have a test double for <strong class="source-inline">ToDoItemStore</strong> we could use in the tests for <strong class="source-inline">ToDoItemsListViewController</strong>.</p>
			<p>Follow these steps to add a test double for <strong class="source-inline">ToDoItemStore</strong>:</p>
			<ol>
				<li value="1">The first step in implementing a test double for <strong class="source-inline">ToDoItemStore</strong> is to create a protocol that defines the interface our view controller expects. Add the following protocol to <strong class="source-inline">ToDoItemStore.swift</strong>:<p class="source-code">// ToDoItemStore.<a id="_idTextAnchor184"/><a id="_idTextAnchor185"/>swift</p><p class="source-code">protocol ToDoItemStoreProtocol {</p><p class="source-code">  var itemPublisher:</p><p class="source-code">    CurrentValueSubject&lt;[ToDoItem], Never&gt;</p><p class="source-code">      { get set }</p><p class="source-code">  func check(_: ToDoItem)</p><p class="source-code">}</p></li>
			</ol>
			<p>The protocol defines the elements the view controller needs. It needs to subscribe to changes of the items and it also needs a way to check a to-do item.</p>
			<ol>
				<li value="2">Now that we have the protocol, we can add the conformance to the protocol to <strong class="source-inline">ToDoItemStore</strong>:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">class ToDoItemStore: ToDoItemStoreProtocol {</p><p class="source-code">  // …</p><p class="source-code">}</p></li>
				<li>Next, we need a test <a id="_idIndexMarker225"/>double conforming to that protocol. Select the <strong class="bold">ToDoTests</strong> group in the Project navigator and add a new Swift file with th<a id="_idTextAnchor186"/><a id="_idTextAnchor187"/>e name <strong class="source-inline">ToDoItemStoreProtocolMock</strong>. Replace the contents of that file with this<a id="_idTextAnchor188"/><a id="_idTextAnchor189"/> code:<p class="source-code">// ToDoItemStoreProtocolMock.swift</p><p class="source-code">import Foundation</p><p class="source-code">import Combine</p><p class="source-code">@testable import ToDo</p><p class="source-code"> </p><p class="source-code">class ToDoItemStoreProtocolMock: ToDoItemStoreProtocol {</p><p class="source-code">  var itemPublisher =</p><p class="source-code">    CurrentValueSubject&lt;[ToDoItem], Never&gt;([])</p><p class="source-code"> </p><p class="source-code">  var checkLastCallArgument: ToDoItem?</p><p class="source-code">  func check(_ item: ToDoItem) {</p><p class="source-code">    checkLastCallArgument = item</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>With this implementation of the test double, we can control how the store used in the view controller behaves. We will see next how we can use this test double in a test.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor190"/>Using test doubles to implement a number of rows</h2>
			<p>A table <a id="_idIndexMarker226"/>view data source needs to provide two kinds of information: first, the number of rows in a given section and second, the cell for a given item. Sure, there are other methods defined in the <strong class="source-inline">UITableViewDataSource</strong> protocol, but those are optional.</p>
			<p>Let's start with the number of rows in a given section. In the default case, the number of sections in a table view is one. This means we are interested in the number of rows in the first and only section. Follow these steps to implement the correct number of rows for the table<a id="_idIndexMarker227"/> view:</p>
			<ol>
				<li value="1">Add the following property to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// ToDoItemsListViewControllerTes<a id="_idTextAnchor191"/><a id="_idTextAnchor192"/><a id="_idTextAnchor193"/>ts.s<a id="_idTextAnchor194"/><a id="_idTextAnchor195"/><a id="_idTextAnchor196"/>wift</p><p class="source-code">var toDoItemSt<a id="_idTextAnchor197"/><a id="_idTextAnchor198"/>oreMock: ToDoItemStoreProtocolMock!</p></li>
				<li>Next, set it up in <strong class="source-inline">setUpWithError()</strong> and make the system under test use it:<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">override func setUpWithError() throws {</p><p class="source-code">  let storyboard = UIStoryboard(name: "Main", bundle: nil)</p><p class="source-code">  sut = try XCTUnwrap(</p><p class="source-code">    storyboard.instantiateInitialViewController()</p><p class="source-code">    as? ToDoItemsListViewController</p><p class="source-code">  )</p><p class="source-code">  toDoItemStoreMock = ToDoItemStoreProtocolMock()</p><p class="source-code">  sut.toDoItemStore = toDoItemStoreMock</p><p class="source-code">  sut.loadViewIfNeeded()</p><p class="source-code">}</p></li>
			</ol>
			<p>This code does not compile<a id="_idTextAnchor199"/><a id="_idTextAnchor200"/> because <strong class="source-inline">toDoItemStore</strong> is missing in <strong class="source-inline">ToDoItemsListViewController</strong>.</p>
			<ol>
				<li value="3">Open <strong class="source-inline">ToDoItemsListViewController</strong> in the editor and add the missing property: <p class="source-code">// ToDoItemsListViewController.swift </p><p class="source-code">class ToDoItemsListViewController: UIViewController { </p><p class="source-code">  </p><p class="source-code">  @IBOutlet weak var tableView: UITab<a id="_idTextAnchor201"/><a id="_idTextAnchor202"/>leView! </p><p class="source-code">  var toDoItemStore: ToDoItemStoreProtocol? </p><p class="source-code">}</p></li>
				<li>Next, add<a id="_idIndexMarker228"/> the following test to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// ToDoItemsListViewControllerTe<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/><a id="_idTextAnchor205"/>sts.swift</p><p class="source-code">func test_numberOfRows_whenOneItemIsSent_shouldReturnOne() {</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([ToDoItem(title: "dummy 1")])</p><p class="source-code">  let result = sut.tableView.numberOfRows(inSection: 0)</p><p class="source-code">  XCTAssertEqual(result, 1)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we send a <strong class="source-inline">ToDoItem</strong> instance using its <strong class="source-inline">itemPublisher</strong>. We expect that the table view should then have one row in section zero.</p>
			<p>Run all the tests to confirm that this new test fails.</p>
			<ol>
				<li value="5">At the moment, the table view has no data source set. The <strong class="source-inline">dataSource</strong> property is nil. To make this test pass, we first need to assign <strong class="source-inline">ToDoItemsListViewController</strong> to the <strong class="source-inline">dataSource</strong> property of the table view. Add the following method to <strong class="source-inline">ToDoItemsListViewController</strong>:<p class="source-code">// ToDoItemsListViewControl<a id="_idTextAnchor206"/><a id="_idTextAnchor207"/>ler.swift</p><p class="source-code">override func viewDidLoad() {</p><p class="source-code">  super.viewDid<a id="_idTextAnchor208"/><a id="_idTextAnchor209"/>Load()</p><p class="source-code">  tableView.dataSource = self</p><p class="source-code">}</p></li>
			</ol>
			<p>Xcode complains that it <strong class="bold">Cannot assign value of type 'ToDoItemsListViewController' to type 'UITableViewDataSource'</strong>. That is expected because <strong class="source-inline">ToDoItemsListViewController</strong> does not yet conform to the <strong class="source-inline">UITableViewDataSource</strong> protocol.</p>
			<ol>
				<li value="6">Add the<a id="_idIndexMarker229"/> following extension to <strong class="source-inline">ToDoItemsListViewController.swift</strong>:<p class="source-code">// ToDoItemsListViewContro<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/>ller.swift</p><p class="source-code">extension ToDoItemsListViewController: </p><p class="source-code">  UITableViewDataSource {</p><p class="source-code">  func tableView(</p><p class="source-code">    _ tableView: UITableView,</p><p class="source-code">    numberOfRowsInSection section: Int) -&gt; Int {</p><p class="source-code"> </p><p class="source-code">      return 1</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">  func tableView(</p><p class="source-code">    _ tableView: UITableView,</p><p class="source-code">    cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {</p><p class="source-code"> </p><p class="source-code">      return UITableViewCell()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This is the minimal code to make <strong class="source-inline">ToDoItemsListViewController</strong> conform to the <strong class="source-inline">UITableViewDataSource</strong> protocol and make the test pass.</p>
			<p>You might be wondering why we return a hardcoded fixed value from <strong class="source-inline">tableView(_:numberOfRowsInSection:)</strong>. This is clearly wrong and won't result in a working app. Patience. At the moment, our task is to make the test pass and this is what we have accomplished. Our feeling that this implementation is wrong just means we need another test to make sure the implementation is correct. </p>
			<ol>
				<li value="7">Add the <a id="_idIndexMarker230"/>following test method to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// ToDoItemsListViewController<a id="_idTextAnchor212"/><a id="_idTextAnchor213"/><a id="_idTextAnchor214"/>Tests.swift</p><p class="source-code">func test_numberOfRows_whenTwoItemsAreSent_shouldReturnTwo() </p><p class="source-code">{</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([</p><p class="source-code">      ToDoItem(title: "dummy 1"),</p><p class="source-code">      ToDoItem(title: "dummy <a id="_idTextAnchor215"/><a id="_idTextAnchor216"/>2")</p><p class="source-code">    ])</p><p class="source-code">  let result = sut.tableView.numberOfRows(inSection: 0)</p><p class="source-code">  XCTAssertEqual(result, 2)</p><p class="source-code">}</p></li>
			</ol>
			<p>To make this test pass without breaking any previous tests, we need to process the items that are sent by the item publisher in the view controller.</p>
			<ol>
				<li value="8">First, import Combine and add two properties, <strong class="source-inline">items</strong> and <strong class="source-inline">token</strong>, to <strong class="source-inline">ToDoItemsListViewController</strong>:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">class ToDoItemsListViewController: UIViewController {</p><p class="source-code"> </p><p class="source-code">  @IBOutlet weak var tableView: UITableView!</p><p class="source-code">  var toDoItemStore: ToDoItemSto<a id="_idTextAnchor217"/><a id="_idTextAnchor218"/>reProtocol?</p><p class="source-code">  private var items: [ToDoItem] = []</p><p class="source-code">  private var token: AnyCancellable?</p><p class="source-code"> </p><p class="source-code">  // …</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">items</strong> property will hold the items sent by the item publisher and the <strong class="source-inline">token</strong> property will hold a reference to the subscriber subscribed to that publisher. Without <a id="_idIndexMarker231"/>a reference to the subscriber, <strong class="source-inline">Combine</strong> would destroy the subscriber before we can use it.</p>
			<ol>
				<li value="9">Next, change <strong class="source-inline">viewDidLoad()</strong> in <strong class="source-inline">ToDoItemsListViewController</strong> so that it looks like this:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">override func viewDidLoad() {</p><p class="source-code">  super.vi<a id="_idTextAnchor219"/><a id="_idTextAnchor220"/>ewDidLoad()</p><p class="source-code">  tableView.dataSource = self</p><p class="source-code">  token = toDoItemStore?.itemPublisher</p><p class="source-code">    .sink(receiveValue: { [weak self] items in</p><p class="source-code">      self?.items = items</p><p class="source-code">  })</p><p class="source-code">}</p></li>
			</ol>
			<p>With this code, we subscribe to changes sent by the item publisher of <strong class="source-inline">toDoItemStore</strong>. We store the sent items in the <strong class="source-inline">items</strong> property we just added.</p>
			<ol>
				<li value="10">Finally, we can<a id="_idIndexMarker232"/> return the number of items in <strong class="source-inline">tableView(_:numberOfRowsInSection:)</strong>:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">func tableView(</p><p class="source-code">  _ tableView: UITableView,</p><p class="source-code">  numberOfRowsInSection section: Int) <a id="_idTextAnchor221"/><a id="_idTextAnchor222"/>-&gt; Int {</p><p class="source-code">    return items.count</p><p class="source-code">  }</p></li>
			</ol>
			<p>Run the tests. All the tests pass.</p>
			<p>Next, we are going to use our test double to implement the to-do item cell for the table view.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor223"/>Using test doubles to implement setting up the to-do item cell</h2>
			<p>As always, when <a id="_idIndexMarker233"/>implementing a new microfeature, we need a test. Follow these steps to add the failing test and the implementation that makes the test pass:</p>
			<ol>
				<li value="1">Add the following test method to <strong class="source-inline">ToDoItemsListViewControllerTests.swift</strong>:<p class="source-code">// ToDoItemsListViewControl<a id="_idTextAnchor224"/><a id="_idTextAnchor225"/>lerTests.swift</p><p class="source-code">func test_cellForRowAt_shouldReturnCellWithTitle() throws </p><p class="source-code">{</p><p class="source-code">  let titleUnderTest = "dummy 1"</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([ToDoItem(title: titleUnderTest)])</p><p class="source-code">  let tableView = try XCTUnwrap(sut.tableView)</p><p class="source-code">  let indexPath = IndexPath(row: 0, section: 0)</p><p class="source-code">  let cell = try XCTUnwrap(</p><p class="source-code">    tableView.dataSource?</p><p class="source-code">      .tableView(tableView,</p><p class="source-code">                 cellForRowAt: indexPath)</p><p class="source-code">    as? ToDoItemCell</p><p class="source-code">  )</p><p class="source-code">}</p></li>
			</ol>
			<p>This is not the complete test, but we need to pause here because the <strong class="source-inline">ToDoItemCell</strong> type is not yet defined. </p>
			<ol>
				<li value="2">Select the <strong class="bold">ToDo</strong> group in the Project navigator and add a new <strong class="bold">Cocoa Touch </strong>class via the <strong class="bold">File</strong> menu. In the <strong class="bold">Class</strong> field, i<a id="_idTextAnchor226"/><a id="_idTextAnchor227"/>nsert the name <strong class="source-inline">ToDoItemCell</strong> and make it a <strong class="bold">Subclass of</strong> <strong class="source-inline">UITableViewCell</strong>. Remove the template code within the class.</li>
				<li>Go back to <strong class="source-inline">ToDoItemsListViewControllerTests</strong> and add the test assertion, as<a id="_idIndexMarker234"/> shown in the following code block:<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">func test_cellForRowAt_shouldReturnCellWithTitle1() throws {</p><p class="source-code">  let titleUnderTest = "dummy 1"</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([ToDoItem(title: titleUnderTest)])</p><p class="source-code">  let tableView = try XCTUnwrap(sut.tableView)</p><p class="source-code">  let indexPath = IndexPath(row: 0, section: 0)</p><p class="source-code">  let cell = try XCTUnwrap(</p><p class="source-code">    tableView.dataSource?</p><p class="source-code">      .tableView(tableView,</p><p class="source-code">                 cellForRowAt: indexPath)</p><p class="source-code">    as? To<a id="_idTextAnchor228"/><a id="_idTextAnchor229"/>Do<a id="_idTextAnchor230"/><a id="_idTextAnchor231"/>ItemCell</p><p class="source-code">  )</p><p class="source-code">  XCTAssertEqual(cell.titleLabel.text, titleUnderTest)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we publish a list with one to-do item using our test double. Then we execute the <strong class="source-inline">tableView(_:cellForRowAt:)</strong> method defined in the data source of the table view. The returned table view cell should have a label showing the title of the to-do item sent by the publisher. This test does not compile at the moment because the cell doesn't have a property with the name <strong class="source-inline">titleLabel</strong>.</p>
			<ol>
				<li value="4">Add the<a id="_idIndexMarker235"/> property to <strong class="source-inline">ToDoItemCell</strong>:<p class="source-code">// ToDoItemCell.swift</p><p class="source-code">class ToDoItemCell: UIT<a id="_idTextAnchor232"/><a id="_idTextAnchor233"/>ableViewCell {</p><p class="source-code">  let titleLabel = UILabel()</p><p class="source-code">}</p></li>
			</ol>
			<p>Now the tests compile. Run the tests to confirm that the new test fails.</p>
			<p>If you are an experienced iOS developer, you might have realized that this code is not enough. The label is initialized, but it is not added to the cell. We will fix that later in this section.</p>
			<ol>
				<li value="5">The test we have just added fails because the data source of the table view does not return a cell of the <strong class="source-inline">ToDoItemCell</strong> type. Go to <strong class="source-inline">ToDoItemsListViewController</strong>  and replace the <strong class="source-inline">tableView(_:cellForRowAt:)</strong> method with the following code:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">func tableView(</p><p class="source-code">  _ tableView: UITableView,</p><p class="source-code">  cellForRowAt indexPath: IndexPath) -&gt; U<a id="_idTextAnchor234"/><a id="_idTextAnchor235"/>ITableViewCell {</p><p class="source-code">    let cell = ToDoItemCell()</p><p class="source-code">    cell.titleLabel.text = "dummy 1"</p><p class="source-code">    return cell</p><p class="source-code">  }</p></li>
			</ol>
			<p>Even though this code makes all the tests pass (run the tests to confirm), these few lines of code have several issues. One issue is that the text in <strong class="source-inline">titleLabel</strong> is hardcoded to the string expected by the test. It might seem stupid to write code like this, but this is kind of essential to TDD. Code that uses hardcoded values to make the tests pass tells us that we need more tests.</p>
			<ol>
				<li value="6">Add the<a id="_idIndexMarker236"/> following test to <strong class="source-inline">ToDoItemsListViewController</strong>:<p class="source-code">// ToDoItemsListViewCont<a id="_idTextAnchor236"/><a id="_idTextAnchor237"/>rollerTests.swift</p><p class="source-code">func test_cellForRowAt_shouldReturnCellWithTitle2() throws </p><p class="source-code">{</p><p class="source-code">  let titleUnderTest = "dummy 2"</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([</p><p class="source-code">      ToDoItem(title: "dummy 1"),</p><p class="source-code">      ToDoItem(title: titleUnderTest)</p><p class="source-code">    ])</p><p class="source-code">  let tableView = try XCTUnwrap(sut.tableView)</p><p class="source-code">  let indexPath = IndexPath(row: 1, section: 0)</p><p class="source-code">  let cell = try XCTUnwrap(</p><p class="source-code">    tableView.dataSource?</p><p class="source-code">      .tab<a id="_idTextAnchor238"/><a id="_idTextAnchor239"/>leView(tableView,</p><p class="source-code">                 cellForRowAt: indexPath)</p><p class="source-code">    as? ToDoItemCell</p><p class="source-code">  )</p><p class="source-code">  XCTAssertEqual(cell.titleLabel.text, titleUnderTest)</p><p class="source-code">}</p></li>
			</ol>
			<p>You should try to find a better name for this test. I use this name here to keep the method name kind of short. Long method names do not look good in printed books.</p>
			<p>In this test, we send two to-do items to the system under test and check the text in the second cell. Run the tests. This new test fails because the text in <strong class="source-inline">titleLabel</strong> is hardcoded.</p>
			<ol>
				<li value="7">Change the<a id="_idIndexMarker237"/> implementation of <strong class="source-inline">tableView(_:cellForRowAt:)</strong> such that it looks like this:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">func tableView(</p><p class="source-code">  _ tableView: UITableView,</p><p class="source-code">  cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {</p><p class="source-code">    let cell<a id="_idTextAnchor240"/><a id="_idTextAnchor241"/> = ToDoItemCell()</p><p class="source-code">    let item = items[indexPath.row]</p><p class="source-code">    cell.titleLabel.text = item.title</p><p class="source-code">    return cell</p><p class="source-code">  }</p></li>
			</ol>
			<p>In this code, we get the item for that row from the <strong class="source-inline">items</strong> property and assign its title to the text of the <strong class="source-inline">titleLabel</strong> property. Run the tests to confirm that all the tests pass.</p>
			<p>The implementation code still has an issue. The cells in a table view should be reused to improve the rendering performance of the table view. Let's refactor the code without breaking the tests.</p>
			<ol>
				<li value="8">To opt in to the cell reuse capability of <strong class="source-inline">UITableView</strong>, add the following lines of code to <strong class="source-inline">viewDidLoad()</strong> in <strong class="source-inline">ToDoItemsListViewController</strong>:<p class="source-code">// ToDoItemsListVi<a id="_idTextAnchor242"/><a id="_idTextAnchor243"/>ewController.swift</p><p class="source-code">tableView.register(</p><p class="source-code">  ToDoItemCell.self,</p><p class="source-code">  forCellReuseIdentifier: "ToDoItemCell"</p><p class="source-code">)</p></li>
			</ol>
			<p>With this call, we register <strong class="source-inline">ToDoItemCell</strong> for the reuse queue of the table view. </p>
			<ol>
				<li value="9">Now we<a id="_idIndexMarker238"/> can ask the table view to dequeue such a cell in <strong class="source-inline">tableView(_:cellForRowAt:)</strong>:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">func tableView(</p><p class="source-code">  _ tableView: UITableView,</p><p class="source-code">  cellForRowAt indexPath: IndexPath) -&gt;<a id="_idTextAnchor244"/><a id="_idTextAnchor245"/> UITableViewCell {</p><p class="source-code">    let cell = tableView.dequeueReusableCell(</p><p class="source-code">      withIdentifier: "ToDoItemCell",</p><p class="source-code">      for: indexPath</p><p class="source-code">    ) as! ToDoItemCell</p><p class="source-code">    let item = items[indexPath.row]</p><p class="source-code">    cell.titleLabel.text = item.title</p><p class="source-code">    return cell</p><p class="source-code">  }</p></li>
			</ol>
			<p>Run the tests to confirm that we didn't break anything.</p>
			<p>The implementation of <strong class="source-inline">ToDoItemCell</strong> is not enough to make the cell show the title in the user interface. We have initialized the label, but we haven't added it to any view yet. This is<a id="_idIndexMarker239"/> what we will do next.</p>
			<p>We could write tests that check whether the label is added to the table view cell in the tests for the view controller. But if we think about it, they belong to dedicated tests for the cell itself. Follow these steps to add the test and the implementation that make the test pass:</p>
			<ol>
				<li value="1">Select the <strong class="bold">ToDoTests</strong> group in the Project navigation and add a new <strong class="bold">Unit Test Case Class</strong> file from the <strong class="bold">File</strong> m<a id="_idTextAnchor246"/><a id="_idTextAnchor247"/>enu. Insert the name <strong class="source-inline">ToDoItemCellTests</strong> in the <strong class="bold">Text</strong> field next to <strong class="bold">Class</strong> and create the file. Remove the two template tests in the created file.</li>
				<li>Below the existing import statement, add the testable import of the <strong class="source-inline">ToDo</strong> module:<p class="source-code">// ToDoItemCellTests<a id="_idTextAnchor248"/><a id="_idTextAnchor249"/>.swift</p><p class="source-code">import XCTest</p><p class="source-code">@testable import ToDo</p></li>
				<li>Before we can test anything relating to the table view cell, we need to set it up. Replace the implementation of the <strong class="source-inline">ToDoItemCellTests</strong> class with the following code:<p class="source-code">// ToD<a id="_idTextAnchor250"/><a id="_idTextAnchor251"/>oItemCellTests.swift</p><p class="source-code">class ToDoItemCellT<a id="_idTextAnchor252"/><a id="_idTextAnchor253"/>ests: XCTestCase {</p><p class="source-code"> </p><p class="source-code">  var sut: ToDoItemCell!</p><p class="source-code"> </p><p class="source-code">  override func setUpWithError() throws {</p><p class="source-code">    sut = ToDoItemCell()</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  override func tearDownWithError() throws {</p><p class="source-code">    sut = nil</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Now we are<a id="_idIndexMarker240"/> ready to add the first test to this new test class. Add the following test method:<p class="source-code">// To<a id="_idTextAnchor254"/><a id="_idTextAnchor255"/>DoItemCellTests.swift</p><p class="source-code">func test_hasTitleLabelSubview() {</p><p class="source-code">  let subview = sut.titleLabel</p><p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.contentView))</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">isDescendant(of:)</strong> method is defined on <strong class="source-inline">UIView</strong>. We have already seen this call earlier in this chapter when we wrote a test that asserted that the table view was added to the view of the view controller.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="5">To make this test pass, change the code in <strong class="source-inline">ToDoItemCell</strong> such that it looks like this:<p class="source-code">// ToDoItemCell.swift</p><p class="source-code">class ToDoItemCell: UITableViewCell {</p><p class="source-code">  let ti<a id="_idTextAnchor256"/><a id="_idTextAnchor257"/>tleLabel = UILabel()</p><p class="source-code">  override init(style: UITableViewCell.CellStyle,</p><p class="source-code">                reuseIdentifier: String?) {</p><p class="source-code">    super.init(style: style, </p><p class="source-code">               reuseIdentifier: reuseIdentifier)</p><p class="source-code">    contentView.addSubview(titleLabel)</p><p class="source-code">  }</p><p class="source-code">  required init?(coder: NSCoder) { fatalError() }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that this code makes the test pass.</p>
			<ol>
				<li value="6">Now that the test <a id="_idIndexMarker241"/>passes, we move to the refactoring stage of the TDD workflow. Depending on your style of development, you may already be satisfied with this implementation. I like to structure the initialization of user interface elements differently. I would refactor that code to this:<p class="source-code">// ToDoItemCell.swift</p><p class="source-code">class ToDoItemCell:<a id="_idTextAnchor258"/><a id="_idTextAnchor259"/> UITableViewCell {</p><p class="source-code"> </p><p class="source-code">  let titleLabel: UILabel</p><p class="source-code"> </p><p class="source-code">  override init(style: UITableViewCell.CellStyle,</p><p class="source-code">                reuseIdent<a id="_idTextAnchor260"/><a id="_idTextAnchor261"/>ifier: String?) {</p><p class="source-code"> </p><p class="source-code">    titleLabel = UILabel()</p><p class="source-code"> </p><p class="source-code">    super.init(style: style,</p><p class="source-code">               reuseIdentifier: reuseIdentifier)</p><p class="source-code"> </p><p class="source-code">    contentView.addSubview(titleLabel)</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  required init?(coder: NSCoder) { fatalError() }</p><p class="source-code">}</p></li>
			</ol>
			<p>The difference is that I prefer to initialize the elements within the <strong class="source-inline">init</strong> method. Run the test to confirm that all the tests still pass.</p>
			<p>Note that we have <a id="_idIndexMarker242"/>intentionally not implemented any positioning of the label. In my opinion, this is something we shouldn't test with a unit test. The positioning and the size of user interface elements depend on the size of the screen and the version of iOS. We could write tests for these values, but most probably, those would often break even though the app still works for the user. With our tests, we want to catch the real bugs.</p>
			<p>OK, this test was easy. Let's now add the two other required labels – <strong class="source-inline">dateLabel</strong> and <strong class="source-inline">locationLabel</strong>:</p>
			<ol>
				<li value="1">Add this test method to <strong class="source-inline">ToDoItemCellTests</strong>:<p class="source-code">// <a id="_idTextAnchor262"/><a id="_idTextAnchor263"/>ToDoItemCellTests.swift</p><p class="source-code">func test_hasDateLabelSubview() {</p><p class="source-code">  let subview = sut.dateLabel</p><p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.contentView))</p><p class="source-code">}</p></li>
				<li>Run the tests to confirm that this new test fails. The test fails because the <strong class="source-inline">dateLabel</strong> property is missing.</li>
				<li>Go to <strong class="source-inline">ToDoItemCell</strong> and add <a id="_idIndexMarker243"/>this property:<p class="source-code">// ToDoItemCell.swift</p><p class="source-code">class ToDoItemCell: UITableViewCell {</p><p class="source-code"> </p><p class="source-code">  l<a id="_idTextAnchor264"/><a id="_idTextAnchor265"/>et titleLabel: UILabel</p><p class="source-code">  let dateLabel: UILabel</p><p class="source-code"> </p><p class="source-code">  override init(style: UITableViewCell.CellStyle,</p><p class="source-code">                reuseIdentifier: String?) {</p><p class="source-code"> </p><p class="source-code">    ti<a id="_idTextAnchor266"/><a id="_idTextAnchor267"/>tleLabel = UILabel()</p><p class="source-code">    dateLabel = UILabel()</p><p class="source-code"> </p><p class="source-code">    super.init(style: style,</p><p class="source-code">               reuseIdentifier: reuseIdentifier)</p><p class="source-code"> </p><p class="source-code">    contentView.addSubview(titleLabel)</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  required init?(coder: NSCoder) { fatalError() }</p><p class="source-code">}</p></li>
			</ol>
			<p>"Wait a minute, Dominik," I hear you say, "why didn't you add the label to the content view?" Good question! In TDD, you should only add code that makes the test pass. The test failed because the label was not defined. So, our task in this step is to add this <strong class="source-inline">dateLabel</strong> property. At the moment, we don't know whether this is enough to make the test pass. We have the feeling that this is not enough based on our previous experience with <strong class="source-inline">titleLabel</strong>, but it's better to confirm our feeling.</p>
			<p>Run the <a id="_idIndexMarker244"/>tests to confirm that the test is still failing. It still fails, but this time in the line of the assert function call. </p>
			<ol>
				<li value="4">To make it pass, add the following line below the existing <strong class="source-inline">addSubview</strong> ca<a id="_idTextAnchor268"/><a id="_idTextAnchor269"/>ll:<p class="source-code">// ToDoItemCell.swift</p><p class="source-code">contentView.addSubview(dateLabel)</p></li>
			</ol>
			<p>Run the tests again. Now, all the tests pass again.</p>
			<ol>
				<li value="5">When the <strong class="source-inline">location</strong> property of the to-do item is set, the cell should show the name of the <strong class="source-inline">location</strong> property. Add the following test to <strong class="source-inline">ToDoItemCellTests</strong>:<p class="source-code">/<a id="_idTextAnchor270"/><a id="_idTextAnchor271"/>/ ToDoItemCellTests.swift</p><p class="source-code">func test_hasLocationLabelSubview() {</p><p class="source-code">  let subview = sut.locationLabel</p><p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.  contentView))</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="6">Add the property for the <strong class="source-inline">location</strong> label to <strong class="source-inline">ToDoItemCell</strong>:<p class="source-code">// ToDoItemCell.swift</p><p class="source-code">class ToDoItemCell: UITableViewCell {</p><p class="source-code"> </p><p class="source-code">  let titleLabel: UILabel<a id="_idTextAnchor272"/><a id="_idTextAnchor273"/></p><p class="source-code">  let dateLabel: UILabel</p><p class="source-code">  let locationLabel: UILabel</p><p class="source-code"> </p><p class="source-code">  override init(style: UITableViewCell.CellStyle,</p><p class="source-code">                reuseIdentifier: String?) {</p><p class="source-code"> </p><p class="source-code">    titleLabel = UILabel()</p><p class="source-code">    <a id="_idTextAnchor274"/><a id="_idTextAnchor275"/>dateLabel = UILabel()</p><p class="source-code">    locationLabel = UILabel()</p><p class="source-code"> </p><p class="source-code">    super.init(style: style,</p><p class="source-code">               reuseIdentifier: reuseIdentifier)</p><p class="source-code"> </p><p class="source-code">    contentView.addSubview(titleLabel)</p><p class="source-code">    contentView.addSubview(dateLabel)</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  required init?(coder: NSCoder) { fatalError() }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests<a id="_idIndexMarker245"/> to see the last test still failing, but now in the line with the assert function call.</p>
			<ol>
				<li value="7">Add the line that adds <strong class="source-inline">locationLabel</strong> as a subview to <strong class="source-inline">contentView</strong> of the ce<a id="_idTextAnchor276"/><a id="_idTextAnchor277"/>ll:<p class="source-code">// ToDoItemCell.swift:</p><p class="source-code">contentView.addSubview(locationLabel)</p></li>
			</ol>
			<p>Run all the tests to make sure they all pass now.</p>
			<p>The next step is <a id="_idIndexMarker246"/>to fill the labels in the data source of the table view. Open <strong class="source-inline">ToDoItemsListViewControllerTests</strong> and follow these steps to add this feature to our app:</p>
			<ol>
				<li value="1">Add the following test to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// ToDoItemsLi<a id="_idTextAnchor278"/><a id="_idTextAnchor279"/>stViewControllerTests.swift</p><p class="source-code">func test_cellForRowAt_shouldReturnCellWithDate() throws {</p><p class="source-code">  let date = Date()</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([</p><p class="source-code">      ToDoItem(title: "dummy 1",</p><p class="source-code">               timestamp: date.timeIntervalSince1970)</p><p class="source-code">    ])</p><p class="source-code">  let tableView = try XCTUnwrap(sut.tableView)</p><p class="source-code">  let indexPath = IndexPath(row: 0, section: 0)</p><p class="source-code">  let cell = try XCTUnwrap(</p><p class="source-code">    tableView.dataSource?</p><p class="source-code">      .tableView(tableView,</p><p class="source-code">                 cellForRowAt: indexPath)</p><p class="source-code">    as? ToDoItemCell</p><p class="source-code">  )</p><p class="source-code">  XCTAssertEqual(cell.dateLabel.text,</p><p class="source-code">                 sut.dateFormatter.string(from: date))</p><p class="source-code">} </p></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker247"/>now use <strong class="source-inline">toDoItemStoreMock</strong> to send a to-do item with a timestamp. In the <strong class="source-inline">assert</strong> function, we use a <strong class="source-inline">dateFormatter</strong> property that is not defined yet. Let's add this property to make the test compile.</p>
			<ol>
				<li value="2">Go to <strong class="source-inline">ToDoItemsListViewController</strong> and add the following property:<p class="source-code">// ToDoI<a id="_idTextAnchor280"/><a id="_idTextAnchor281"/>temsListViewController.swift</p><p class="source-code">let dateFormatter = DateFormatter()</p></li>
			</ol>
			<p>Now the test compiles. Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="3">To make the test pass, we need to set the date label in <strong class="source-inline">tableView(_:cellForRowAt:)</strong>. Add the following code right below <strong class="source-inline">cell.textLabel.text = item.title</strong>:<p class="source-code">// ToDoI<a id="_idTextAnchor282"/><a id="_idTextAnchor283"/>temsListViewController.swift</p><p class="source-code">if let timestamp = item.timestamp {</p><p class="source-code">  let date = Date(timeIntervalSince1970: timestamp)</p><p class="source-code">  cell.dateLabel.text = dateFormatter.string(from: date)</p><p class="source-code">}</p></li>
			</ol>
			<p>We use the timestamp of the item to generate a date from it and ask the date formatter for a string representation of that date.</p>
			<p>Run all the tests to confirm that all the tests pass.</p>
			<p>The next step is to refactor the implementation. We could move the generation of the date string to the model object, but then the model object would need to know how the data is presented to the user. This is not a good idea. It would be better to move that code to a view model. That is a class connected to the view controller that converts the model data such that it can be presented in the user interface.</p>
			<p>We will leave it as it is because for our small app, it's OK to have this code in the view controller.</p>
			<p>You will implement <a id="_idIndexMarker248"/>the setting of the <strong class="source-inline">location</strong> label in the exercises later in this chapter.</p>
			<p>We have now implemented the presentation and the setup of the to-do item table view cells. With the tests in place, we can now look at the implementation and see whether we can improve it to better fit modern concepts in iOS development. The implementation we have built here is based on how table views have been implemented for many years. Over the last few years, better ways have emerged to set up a table view.</p>
			<p>In the following section, we will refactor our implementation to use a diffable data source.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor284"/>Refactoring to a diffable data source</h1>
			<p>In iOS 13, Apple introduced the <strong class="source-inline">UITableViewDiffableDataSource</strong> class. This class manages the update of a<a id="_idIndexMarker249"/> table view when the data changes and it can be used as the data source of any table view. It should be used, when possible, because implementing updates of a table view is a bit complicated and can lead to strange bugs and even crashes. In addition, the code needed to set up such a data source is often easier to read and reason about than the traditional implementation we used in the previous section.</p>
			<p>Follow these steps to<a id="_idIndexMarker250"/> transform our implementation to one that uses a diffable data source:</p>
			<ol>
				<li value="1">A diffable data source manages the data in the table view using a section and an item that both need to conform to the <strong class="source-inline">Hashable</strong> protocol. We already have an item we can use in the diffable data source, the <strong class="source-inline">ToDoItem</strong> structure. However, this structure does not yet conform to <strong class="source-inline">Hashable</strong>. To make it conform to that protocol, add the following code to <strong class="source-inline">ToDoItem.swift</strong> outside of the current <strong class="source-inline">ToDoItem</strong> im<a id="_idTextAnchor285"/><a id="_idTextAnchor286"/>plementation:<p class="source-code">// ToDoItem.swift</p><p class="source-code">extension ToDoItem: Hashable {</p><p class="source-code">  func hash(into hasher: inout Hasher) {</p><p class="source-code">    hasher.combine(id)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>With this code, we tell the hasher provided by Swift to use the ID of the to-do item to generate the hash value. The ID of the to-do item is unique and therefore a good basis for a hash value.</p>
			<ol>
				<li value="2">Next, we need a<a id="_idIndexMarker251"/> section type that also conforms to <strong class="source-inline">Hashable</strong>. Add the following <strong class="source-inline">enum</strong> type to <strong class="source-inline">ToDoItemsListViewController.swift</strong>:<p class="source-code">// T<a id="_idTextAnchor287"/><a id="_idTextAnchor288"/>oDoItemsListViewController.swift</p><p class="source-code">enum Section {</p><p class="source-code">  case main</p><p class="source-code">}</p></li>
			</ol>
			<p>This is enough for now. We only need one section at the moment because later we will add another section to distinguish between to-do and done items.</p>
			<ol>
				<li value="3">Next, we need a property for the data source. Add the following property to <strong class="source-inline">ToDoItemsListViewController</strong>:<p class="source-code">// T<a id="_idTextAnchor289"/><a id="_idTextAnchor290"/>oDoItemsListViewController.swift</p><p class="source-code">private var dataSource:</p><p class="source-code">  UITableViewDiffableDataSource&lt;Section, ToDoItem&gt;?</p></li>
				<li>In the <strong class="source-inline">viewDidLoad()</strong> method, replace the <strong class="source-inline">tableView.dataSource = self</strong> code with the following:<p class="source-code">// T<a id="_idTextAnchor291"/><a id="_idTextAnchor292"/>oDoItemsListViewController.swift</p><p class="source-code">dataSource = </p><p class="source-code">UITableViewDiffableDataSource&lt;Section, ToDoItem&gt;(</p><p class="source-code">  tableView: tableView,</p><p class="source-code">  cellProvider: { [weak self] tableView, indexPath, item   in</p><p class="source-code">    let cell = tableView.dequeueReusableCell(</p><p class="source-code">      withIdentifier: "ToDoItemCell",</p><p class="source-code">      for: indexPath</p><p class="source-code">    ) as! ToDoItemCell</p><p class="source-code">    cell.titleLabel.text = item.title</p><p class="source-code">    if let timestamp = item.timestamp {</p><p class="source-code">      let date = Date(timeIntervalSince1970: timestamp)</p><p class="source-code">      cell.dateLabel.text = self?.dateFormatter</p><p class="source-code">        .string(from: date)</p><p class="source-code">    }</p><p class="source-code">    return cell</p><p class="source-code">})</p></li>
			</ol>
			<p>With this code, we<a id="_idIndexMarker252"/> initialize a diffable data source for the table view. The second parameter of this initializer is a <strong class="source-inline">cell</strong> provider. This piece of code gets called when the table view needs to show a <strong class="source-inline">cell</strong> provider for a given index path. As you can see, the code within this closure looks similar to the code we had in <strong class="source-inline">tableView(_:cellForRowAt:)</strong> previously.</p>
			<ol>
				<li value="5">Now delete the extension that implemented the conformance to <strong class="source-inline">UITableViewDataSource</strong> within <strong class="source-inline">ToDoItemsListViewController.swift</strong>.</li>
				<li><strong class="source-inline">UITableViewDiffableDataSource</strong> manages table view updates via <strong class="source-inline">NSDiffableDataSourceSnapshot</strong>. To update the table view with new data, we need to create a snapshot and set it up with the new data. Add the following <a id="_idIndexMarker253"/>method to <strong class="source-inline">ToDoItemsListViewController</strong>:<p class="source-code">//<a id="_idTextAnchor293"/><a id="_idTextAnchor294"/> ToDoItemsListViewController.swift</p><p class="source-code">private func update(with items: [ToDoItem]) {</p><p class="source-code">  var snapshot =</p><p class="source-code">  NSDiffableDataSourceSnapshot&lt;Section, ToDoItem&gt;()</p><p class="source-code">  snapshot.appendSections([.main])</p><p class="source-code">  snapshot.appendItems(items)</p><p class="source-code">  dataSource?.apply(snapshot)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we create a snapshot and add one section and the items passed into that method.</p>
			<ol>
				<li value="7">The view controller receives updates from the publisher of <strong class="source-inline">toDoItemStore</strong>. Change the subscription code in <strong class="source-inline">viewDidLoad</strong> such that it looks like this:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">token = toDoItemStore?.itemPublisher</p><p class="source-code">  .sink(receiveValue: { [weak self] items in</p><p class="source-code">    self?.items = items</p><p class="source-code">    self?.update(with: items)</p><p class="source-code">})</p></li>
			</ol>
			<p>In addition to assigning the received items to the <strong class="source-inline">items</strong> property of the view controller, we call here the new update method that applies a new snapshot to the data <a id="_idIndexMarker254"/>source.</p>
			<p>Run the tests. All the tests pass. We have now successfully refactored our table view code to use a diffable data source.</p>
			<p>Our list of to-do items should show two sections, one for the to-do items and one for the already done items. In the next section, we will change the snapshot creation to achieve this.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor295"/>Presenting two sections</h1>
			<p>As we have already <a id="_idIndexMarker255"/>refactored to a diffable data source, supporting two sections in the table view is quite easy. Follow these steps to implement two sections:</p>
			<ol>
				<li value="1">As always, we need to start with a failing test. Add the following test to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// To<a id="_idTextAnchor296"/><a id="_idTextAnchor297"/>DoItemsListViewControllerTests.swift</p><p class="source-code">func test_numberOfSections_shouldReturnTwo() {</p><p class="source-code">  var doneItem = ToDoItem(title: "dummy 2")</p><p class="source-code">  doneItem.done = true</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([ToDoItem(title: "dummy 1"),</p><p class="source-code">           doneItem])</p><p class="source-code">  let result = sut.tableView.numberOfSections</p><p class="source-code">  XCTAssertEqual(result, 2)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we set a to-do item and a done item to the table view using <strong class="source-inline">toDoItemStoreMock</strong>. The name of the test method should also include what the preconditions of the tests are. We use a shorter name in the book because otherwise, the code is harder to read. You should try to use a better name.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="2">To support<a id="_idIndexMarker256"/> two sections, <strong class="source-inline">enum Section</strong> needs two cases. Change the code of <strong class="source-inline">enum Section</strong> such that it looks like this:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">enum Section {</p><p class="source-code">  case todo</p><p class="source-code">  case done</p><p class="source-code">}</p></li>
				<li>Finally, we need to change the <strong class="source-inline">update</strong> method such that it looks like this:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">private func update(with items: [ToDoItem]) {</p><p class="source-code">  var snapshot =</p><p class="source-code">  NSDiffableDataSourceSnapshot&lt;Section, ToDoItem&gt;()</p><p class="source-code">  snapshot.appendSections([.todo, .done])</p><p class="source-code">  snapshot.appendItems(</p><p class="source-code">    items.filter({ false == $0.done }),</p><p class="source-code">    toSection: .todo)</p><p class="source-code">  snapshot.appendItems(</p><p class="source-code">    items.filter({ $0.done }),</p><p class="source-code">    toSection: .done)</p><p class="source-code">  dataSource?.apply(snapshot)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this code, we add the two sections to the snapshot and use the <strong class="source-inline">done</strong> property of the to-do item to fill the two sections.</p>
			<p>Run the tests to <a id="_idIndexMarker257"/>confirm that this code makes the new test pass.</p>
			<p>The data source of the table view is now finished. The next step in implementing the list view of the to-do items is to add code that reacts to the user selecting the to-do item in the list.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor298"/>Implementing the delegate of a table view</h1>
			<p>When the user selects<a id="_idIndexMarker258"/> a to-do item in the list of items, the details of the to-do item should be shown in a dedicated view. We will implement the actual navigation between the different views of the app in <a href="B18127_11_ePub.xhtml#_idTextAnchor526"><em class="italic">Chapter 11</em></a>, <em class="italic">Easy Navigation with Coordinators</em>. In this section, we will implement the required code in <strong class="source-inline">ToDoItemsListViewController</strong>.</p>
			<p>Follow these steps to prepare <strong class="source-inline">ToDoItemsListViewController</strong> for navigation to the detail view:</p>
			<ol>
				<li value="1">Let's assume we already have a delegate that will provide a method the view controller can call. Add the following test method to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">//<a id="_idTextAnchor299"/><a id="_idTextAnchor300"/> ToDoItemsListViewControllerTests.swift</p><p class="source-code">func test_didSelectCellAt_shouldCallDelegate() throws {</p><p class="source-code">  let delegateMock = </p><p class="source-code">    ToDoItemsListViewControllerProtocolMock()</p><p class="source-code">}</p></li>
			</ol>
			<p>Xcode tells us that it cannot find the <strong class="source-inline">ToDoItemsListViewControllerProtocolMock</strong> type. This type is meant to be a mock object for the real delegate we will add in <a href="B18127_11_ePub.xhtml#_idTextAnchor526"><em class="italic">Chapter 11</em></a>, <em class="italic">Easy Navigation with Coordinators</em>. The view controller should tell the delegate that a to-do item was selected by the user. Let's add a mock object with a method for that task.</p>
			<ol>
				<li value="2">Select the <strong class="bold">ToDoTests</strong> group in the Project navigator an<a id="_idTextAnchor301"/><a id="_idTextAnchor302"/>d add a new Swift file. Insert the name <strong class="source-inline">ToDoItemsListViewControllerProtocolMock</strong> in the <strong class="bold">Save As</strong> field and then click <strong class="bold">Create</strong>. Replace the contents of the created file with the following:<p class="source-code">// ToDoItemsListViewControllerProtocolMock.sw<a id="_idTextAnchor303"/><a id="_idTextAnchor304"/>ift</p><p class="source-code">import UIKit</p><p class="source-code">@testable import ToDo</p><p class="source-code">class ToDoItemsListViewControllerProtocolMock:</p><p class="source-code">  ToDoItemsListViewControllerProtocol {    </p><p class="source-code">  }</p></li>
			</ol>
			<p>Again, Xcode<a id="_idIndexMarker259"/> tells us that a type is missing. This time, Xcode doesn't know anything about <strong class="source-inline">ToDoItemsListViewControllerProtocol</strong>.</p>
			<ol>
				<li value="3">Go to <strong class="source-inline">ToDoItemsListViewController.swift</strong> and add the following protocol below the import statemen<a id="_idTextAnchor305"/><a id="_idTextAnchor306"/>ts:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">protocol ToDoItemsListViewControllerProtocol {</p><p class="source-code">  func selectToDoItem(</p><p class="source-code">    _ viewController: UIViewController,</p><p class="source-code">    item: ToDoItem)</p><p class="source-code">}</p></li>
				<li>Now we can <a id="_idIndexMarker260"/>finish the implementation of the protocol mock:<p class="source-code">// ToDo<a id="_idTextAnchor307"/><a id="_idTextAnchor308"/>ItemsListViewControllerProtocolMock.swift</p><p class="source-code">class ToDoItemsListViewControllerProtocolMock:</p><p class="source-code">  ToDoItemsListViewControllerProtocol {</p><p class="source-code"> </p><p class="source-code">  var selectToDoItemReceivedArguments:</p><p class="source-code">  (viewController: UIViewController, </p><p class="source-code">   item: ToDoItem)?</p><p class="source-code"> </p><p class="source-code">  func selectToDoItem(</p><p class="source-code">    _ viewController: UIViewController,</p><p class="source-code">    item: ToDoItem) {</p><p class="source-code"> </p><p class="source-code">      selectToDoItemReceivedArguments =</p><p class="source-code">      (viewController, item)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This protocol mock stores the received argument to the call of the delegate method, <strong class="source-inline">selectToDoItem(_:item:)</strong>.</p>
			<ol>
				<li value="5">Now that we have this protocol mock, we can use it in our test:<p class="source-code">// ToDoItemsListViewControllerTest.swift</p><p class="source-code">func test_didSelectCellAt_shouldCallDelegate() throws {</p><p class="source-code">  let delegateMock =</p><p class="source-code">    ToDoItemsListViewControllerProtocolMock()</p><p class="source-code">  sut.delegate = delegateMock</p><p class="source-code">}</p></li>
			</ol>
			<p>We have to stop here because <strong class="source-inline">sut</strong> doesn't yet have a <strong class="source-inline">delegate</strong> property.</p>
			<ol>
				<li value="6">Add that property to <strong class="source-inline">ToDoItemsListViewControl<a id="_idTextAnchor309"/><a id="_idTextAnchor310"/>ler</strong>:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">var delegate: ToDoItemsListViewControllerProtocol?</p></li>
				<li>Now we can<a id="_idIndexMarker261"/> finish the test method:<a id="_idTextAnchor311"/><a id="_idTextAnchor312"/><p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">func test_didSelectCellAt_shouldCallDelegate() throws {</p><p class="source-code">  let delegateMock =</p><p class="source-code">    ToDoItemsListViewControllerProtocolMock()</p><p class="source-code">  sut.delegate = delegateMock</p><p class="source-code">  let toDoItem = ToDoItem(title: "dummy 1")</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([toDoItem])</p><p class="source-code">  let tableView = try XCTUnwrap(sut.tableView)</p><p class="source-code">  let indexPath = IndexPath(row: 0, section: 0)</p><p class="source-code">  tableView.delegate?.tableView?(</p><p class="source-code">    tableView,</p><p class="source-code">    didSelectRowAt: indexPath)</p><p class="source-code">  XCTAssertEqual(</p><p class="source-code">    delegateMock.selectToDoItemReceivedArguments?.item,</p><p class="source-code">    toDoItem)</p><p class="source-code">}</p></li>
			</ol>
			<p>After we have set the delegate of the system under test, we send one to-do item using <strong class="source-inline">itemPublisher</strong> of <strong class="source-inline">toDoItemStoreMock</strong>. Next, we call <strong class="source-inline">tableView(_:didSelectRowAt:)</strong> of the <strong class="source-inline">tableViews</strong> delegate. Finally, we assert that the protocol method, <strong class="source-inline">selectToDoItem(_:item:)</strong>, got called with the selected to-do item.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="8">To make the<a id="_idIndexMarker262"/> test pass, add the follow extension to <strong class="source-inline">ToDoItemsListViewController.swift</strong> outside of the class definition of <strong class="source-inline">ToDoItemsListViewContr<a id="_idTextAnchor313"/><a id="_idTextAnchor314"/>oller</strong>:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">extension ToDoItemsListViewController:</p><p class="source-code">  UITableViewDelegate {</p><p class="source-code"> </p><p class="source-code">  func tableView(_ tableView: UITableView,</p><p class="source-code">                 didSelectRowAt indexPath: IndexPath) {</p><p class="source-code"> </p><p class="source-code">    let item = items[indexPath.row]</p><p class="source-code">    delegate?.selectToDoItem(self, item: item)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this implementation, we get the to-do item of the selected cell and call the delegate method with it.</p>
			<ol>
				<li value="9">To make <strong class="source-inline">ToDoItemsListViewController</strong> the delegate of the table view, add the<a id="_idIndexMarker263"/> following line to the end of <strong class="source-inline">viewDidLoad()</strong>:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">tableView.delegate = self</p></li>
			</ol>
			<p>Now, run the tests to confirm that all the tests pass.</p>
			<p>For now, we are finished with implementing the list view of the to-do items.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor315"/>Summary</h1>
			<p>In this chapter, we have learned how to test table views and table view cells. We experienced the value of useful unit tests when refactoring a large part of the code. By switching from the traditional table view data source to the diffable data source, we improved the code and the behavior of the app while still keeping the existing tested functionality.</p>
			<p>In the next chapter, we will use the knowledge we gained to create a detailed view and its view controller.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor316"/>Exercises</h1>
			<ol>
				<li value="1">Implement the setting of the location label using test-driven development.</li>
				<li>Try to figure out in the documentation of Xcode how to add section headers when using a diffable data source. We will implement the section headers in <a href="B18127_11_ePub.xhtml#_idTextAnchor526"><em class="italic">Chapter 11</em></a>, <em class="italic">Easy Navigation with Coordinators</em>.</li>
			</ol>
		</div>
	</body></html>