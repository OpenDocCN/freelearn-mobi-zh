- en: '*Chapter 1*: Creating a Modern UI with Jetpack Compose'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：使用 Jetpack Compose 创建现代 UI'
- en: Jetpack libraries enable you to build and design high-quality, robust Android
    apps that have a reliable architecture and work consistently across different
    versions and devices. At the same time, the Jetpack suite allows you to eliminate
    boilerplate code and ultimately focus on what matters – building the necessary
    features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack 库使您能够构建和设计高质量、健壮的 Android 应用，这些应用具有可靠的架构，并在不同版本和设备上保持一致。同时，Jetpack 套件允许您消除样板代码，最终专注于真正重要的事情——构建必要的功能。
- en: In this chapter, we will tackle one of the most popular Jetpack libraries for
    building **user interfaces** (**UIs**), called **Compose**. Simply put, Jetpack
    Compose is a powerful modern toolkit that allows you to build a native UI in Android
    directly with Kotlin functions and APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨构建用户界面（**UIs**）最流行的 Jetpack 库之一，称为 **Compose**。简单来说，Jetpack Compose
    是一个强大的现代工具包，允许您使用 Kotlin 函数和 API 直接在 Android 上构建原生 UI。
- en: Compose accelerates and greatly simplifies UI development as it harnesses the
    power of declarative programming, combined with the ease of use of the Kotlin
    programming language. The new toolkit solely relies on Kotlin APIs when allowing
    you to construct UIs through declarative functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 通过利用声明式编程的力量，结合 Kotlin 编程语言的易用性，加速并极大地简化了 UI 开发。新的工具包在允许您通过声明式函数构建 UI
    时，仅依赖于 Kotlin API。
- en: By the end of this chapter, you will know how building UIs on Android can be
    done with less code, powerful tools, intuitive APIs, and without the need for
    additional languages such as XML.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何在 Android 上使用更少的代码、强大的工具、直观的 API 以及无需使用如 XML 等额外语言来构建 UI。
- en: In the first section, *Understanding the core concepts of Compose*, we will
    explore the fundamental concepts behind Compose and understand how they are beneficial
    in helping us write better and cleaner UIs. We will see how UIs can be described
    with composable functions while also understanding how the new declarative way
    of building UIs on Android works. We will also explore how composition is favored
    over inheritance and how the data flow works in Compose. Finally, we will cover
    what recomposition is and see how essential it is to our declarative UI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，“理解 Compose 的核心概念”，我们将探索 Compose 背后的基本概念，并了解它们如何帮助我们编写更好、更干净的 UI。我们将看到如何使用可组合函数来描述
    UI，同时理解在 Android 上构建 UI 的新声明式方法是如何工作的。我们还将探索为什么在 Compose 中组合优于继承，以及数据流是如何在 Compose
    中工作的。最后，我们将介绍重新组合是什么，并看到它对我们声明式 UI 的必要性。
- en: In the second section, *Exploring the building blocks of Compose UIs*, we will
    study the most important composable functions that Compose provides out of the
    box. Afterward, we will see how we can preview our Compose UI and how activities
    render it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，“探索 Compose UI 的构建块”，我们将研究 Compose 提供的最重要的一些可组合函数。之后，我们将看到如何预览我们的 Compose
    UI 以及活动如何渲染它。
- en: We will then put our knowledge to good use by creating our first Compose project
    about restaurants in the *Building a Compose-based screen* section. In the last
    section, entitled *Exploring lists with Compose*, we will learn how to correctly
    show more content in Compose with the help of lists.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“构建基于 Compose 的屏幕”部分创建我们的第一个关于餐厅的 Compose 项目。在最后一节，标题为“探索 Compose 列表”，我们将学习如何在
    Compose 的帮助下正确地显示更多内容。
- en: 'To summarize, in this chapter, we''re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下主要主题：
- en: Understanding the core concepts of Compose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Compose 的核心概念
- en: Exploring the building blocks of Compose UIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Compose UI 的构建块
- en: Building a Compose-based screen
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Compose-based 屏幕
- en: Exploring lists with Compose
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Compose 探索列表
- en: Note
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: As Compose is a dedicated native UI framework, we will only briefly cover the
    core concepts, common components, and usages of the toolkit without going into
    advanced topics.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Compose 是一个专门的本地 UI 框架，我们将简要介绍核心概念、常见组件和工具包的使用，而不深入探讨高级主题。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'When building Compose-based Android projects, you usually require your day-to-day
    tools for Android development. However, to follow along smoothly, make sure you
    have the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建基于 Compose 的 Android 项目时，您通常需要日常的 Android 开发工具。然而，为了顺利跟进，请确保您拥有以下工具：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that the IDE interface and
    other generated code files might differ from the ones used throughout this book.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio的Arctic Fox 2020.3.1版本。您也可以使用更新的Android Studio版本或甚至Canary构建，但请注意，IDE界面和其他生成的代码文件可能与本书中使用的不同。
- en: The Kotlin 1.6.10 or newer plugin must be installed in Android Studio.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在Android Studio中安装Kotlin 1.6.10或更高版本的插件。
- en: Jetpack Compose 1.1.1 or greater. You should follow this chapter and use the
    projects with this version. You can explore newer versions if you wish, though
    API differences might arise.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack Compose 1.1.1或更高版本。您应该遵循本章，并使用此版本的工程。如果您愿意，可以探索更新的版本，尽管可能会出现API差异。
- en: 'You can find the GitHub repository containing the source code for this book
    here: [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_01).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到包含本书源代码的GitHub仓库：[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_01)。
- en: To access the code presented in this chapter, navigate to the `Chapter_01` directory.
    The code snippets presented in the first two sections can be found in the `ExamplesActivity.kt`
    file, which is located in the root directory. The project coding solution for
    the Restaurants app, which we will develop in the last few sections of this chapter,
    can be found in the `chapter_1_restaurants_app` Android project directory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章中展示的代码，请导航到`Chapter_01`目录。前两节中展示的代码片段可以在位于根目录的`ExamplesActivity.kt`文件中找到。我们将在本章的最后几节中开发的餐厅应用程序的项目编码解决方案可以在`chapter_1_restaurants_app`
    Android项目目录中找到。
- en: Understanding the core concepts of Compose
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Compose的核心概念
- en: Jetpack Compose dramatically changes the way we write UIs on Android. UIs are
    now developed with Kotlin, which enables a new declarative paradigm of writing
    layouts with widgets called **composables**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose极大地改变了我们在Android上编写UI的方式。现在，UI是用Kotlin开发的，这使我们可以使用称为**可组合组件**的控件编写新的声明性布局范式。
- en: In this section, we will understand what composable functions are and how they
    are used to write UIs. We will learn how the programming paradigm has shifted
    and how composition is now enforced, thereby increasing flexibility in the way
    we define UIs. We will also discuss the flow of data within UIs and what recomposition
    is while trying to understand the benefits that are brought by these new concepts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解什么是可组合函数以及它们是如何用于编写UI的。我们将学习编程范式是如何转变的，以及现在如何强制执行组合，从而增加了我们定义UI的方式的灵活性。我们还将讨论UI内部的数据流以及尝试理解这些新概念带来的好处。
- en: 'To summarize, we will be covering the following topics:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将涵盖以下主题：
- en: Describing UIs with composable functions
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可组合函数描述UI
- en: The paradigm shift in creating UIs on Android
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上创建UI的范式转变
- en: Favoring composition over inheritance
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用组合而非继承
- en: Unidirectional flow of data
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的单向流动
- en: Recomposition
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重组
- en: So, let's get started.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧。
- en: Describing UIs with composable functions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可组合函数描述UI
- en: Compose allows you to build UIs by defining and calling `@Composable` annotation
    that represent widgets on the screen.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Compose允许您通过定义和调用表示屏幕上控件的`@Composable`注解来构建UI。
- en: Compose works with the help of a Kotlin compiler plugin in the type checking
    and code generation phase of Kotlin. The Compose compiler plugin makes sure that
    you can create composables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Compose在Kotlin的类型检查和代码生成阶段通过Kotlin编译器插件的帮助工作。Compose编译器插件确保您可以创建可组合组件。
- en: 'For example, a composable that displays a piece of text may look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个显示文本片段的可组合组件可能看起来像这样：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code block, we've defined the `FriendlyMessage` composable
    function by annotating it with the `@Composable` annotation. Looking at the function
    definition and body, we can easily deduce that it displays a greeting message.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们通过使用`@Composable`注解定义了`FriendlyMessage`可组合函数。通过查看函数定义和主体，我们可以轻松推断出它显示一个问候信息。
- en: It's important to note that any function annotated with `@Composable` can be
    rendered on the screen as it will produce a piece of UI hierarchy that displays
    content. In their true sense, composable functions emit UI widgets based on their
    definition.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，任何带有 `@Composable` 注解的函数都可以在屏幕上渲染，因为它将生成一个显示内容的UI层次结构。在真正意义上，可组合函数根据其定义发出UI小部件。
- en: 'In our case, the previous function should display a greeting message by concatenating
    the `String` value it receives as a parameter with a predefined message. As the
    function relies on its input parameters to show different messages on every usage,
    it''s correct to say that composable functions are functions of data (presented
    as **F(data)** in the following diagram) that are converted into pieces of UI
    or widgets:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，之前的函数应该通过将接收到的 `String` 参数值与预定义的消息连接起来来显示问候消息。由于该函数依赖于其输入参数以在每次使用时显示不同的消息，因此可以说可组合函数是数据（如下图中所示为
    **F(data**)）的函数，这些函数被转换为UI或小部件的片段：
- en: '![Figure 1.1 – In Compose, UI is a function of data'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.1 – 在Compose中，UI是数据的功能'
- en: '](img/B17788_01_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_01_01.jpg](img/B17788_01_01.jpg)'
- en: Figure 1.1 – In Compose, UI is a function of data
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.1 – 在Compose中，UI是数据的功能
- en: Later, in the *Unidirectional flow of data* subsection, we will understand why
    having functions to describe UI widgets is beneficial to our projects as it leads
    to a less bug-prone UI layer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的 *单向数据流* 小节中，我们将了解为什么拥有描述UI小部件的函数对我们项目有益，因为它导致UI层更少出现错误。
- en: Getting back to our example, you might be wondering what the `Text` functional
    call represents. As with every other framework, Compose provides composable functions
    such as `Text` out of the box that we can use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，你可能想知道 `Text` 函数调用代表什么。与每个其他框架一样，Compose提供了 `Text` 等可组合函数，我们可以直接使用。
- en: As its name suggests, the `Text` composable allows you to display some text
    on the screen. We will cover other composable functions provided by Compose in
    the *Exploring the building blocks of Compose UIs* section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`Text` 可组合函数允许你在屏幕上显示一些文本。我们将在 *探索Compose UI构建块* 部分中介绍Compose提供的其他可组合函数。
- en: 'Until then, let''s have another look at the previous code example and highlight
    the most important rules when it comes to defining a composable function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，让我们再次查看之前的代码示例，并突出定义可组合函数时最重要的规则：
- en: It should be a regular function marked with the `@Composable` annotation.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是一个带有 `@Composable` 注解的常规函数。
- en: Its UI output is defined by the data that's received through its input parameters.
    Composable functions should return `Unit` as they emit UI elements and do not
    return data as regular functions do. Most of the time, we omit defining the `Unit`
    return type or even returning `Unit` – as Kotlin marks it as redundant – just
    like in the previous example.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其UI输出由通过其输入参数接收到的数据定义。由于可组合函数发出UI元素而不像常规函数那样返回数据，因此它们应该返回 `Unit`。大多数时候，我们省略定义
    `Unit` 返回类型或甚至返回 `Unit` – 因为Kotlin将其标记为冗余 – 就像在之前的例子中那样。
- en: It can contain other composable functions or regular Kotlin code. In the previous
    example, the `FriendlyMessage` composable function makes use of another composable,
    called `Text`, but it could also call regular Kotlin code (we will tackle that
    in the upcoming sections).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以包含其他可组合函数或常规Kotlin代码。在之前的例子中，`FriendlyMessage` 可组合函数使用了另一个名为 `Text` 的可组合函数，但它也可以调用常规Kotlin代码（我们将在接下来的章节中讨论这一点）。
- en: It should be named as a noun or a noun preceded by a suggestive adjective (but
    never a verb). This way, composable functions envision widgets and not actions.
    Additionally, its name should respect the PascalCase naming convention, meaning
    that the first letter of each compound word in a variable is capitalized.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该以名词或以暗示形容词开头的名词（但永远不是动词）命名。这样，可组合函数设想的是小部件而不是动作。此外，其名称应遵守PascalCase命名约定，这意味着变量中每个复合词的第一个字母都应大写。
- en: It's recommended that the function is public and not defined within a class
    but directly within a Kotlin file. This way, Compose promotes the reuse of composable
    functions.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议该函数是公开的，而不是在类中定义，而是在Kotlin文件中直接定义。这样，Compose促进可组合函数的重用。
- en: Now that we understand what a composable function is and how one is defined,
    let's move on and explore the paradigm shift that Compose brings to Android UI
    development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是可组合函数以及如何定义它，让我们继续探索Compose为Android UI开发带来的范式转变。
- en: The paradigm shift in creating UIs on Android
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android上创建UI的范式转变
- en: Compose brings a new approach to Android UI development and that is providing
    a declarative way of describing your UI. Before trying to understand how the declarative
    approach works, we will learn how the traditional View System relies on a different
    paradigm – the imperative one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Compose为Android UI开发带来了一种新的方法，那就是提供一种声明式的方式来描述你的UI。在尝试理解声明式方法是如何工作之前，我们将学习传统的视图系统如何依赖于不同的范式——命令式范式。
- en: The imperative paradigm
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式范式
- en: When describing your UI with XML, you represent the view hierarchy as a tree
    of widgets that are commonly known as views. Views, in the context of the traditional
    View System, are all the components that inherit from the `android.view.View`
    class, from `TextView`, `Button`, or `ImageView` to `LinearLayout`, `RelativeLayout`,
    and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当用XML描述你的UI时，你将视图层次结构表示为称为视图的组件树，这些组件通常被称为视图。在传统的视图系统中，视图是指从`android.view.View`类继承的所有组件，从`TextView`、`Button`或`ImageView`到`LinearLayout`、`RelativeLayout`等等。
- en: Yet what's essential for the View System is the *imperative paradigm* that it
    relies on. Because your application must know how to react to user interactions
    and change the state of the UI accordingly, you can mutate the state of your views
    by referencing them through `findViewById` calls and then update their values
    through calls such as `setText()`, `setBackgroundResource()`, and so on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于视图系统来说，它所依赖的*命令式范式*是至关重要的。因为你的应用程序必须知道如何对用户交互做出反应，并相应地改变UI的状态，所以你可以通过`findViewById`调用引用你的视图，然后通过`setText()`、`setBackgroundResource()`等调用更新它们的值。
- en: 'Since views maintain their internal state and expose setters and getters, you
    must imperatively set new states for each component, as the following diagram
    suggests:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图保持其内部状态并公开设置器和获取器，你必须通过 imperative 方式为每个组件设置新的状态，如下面的图所示：
- en: '![Figure 1.2 – The Android View System features in the imperative paradigm'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – 命令式范式下的Android视图系统特性]'
- en: '](img/B17788_01_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_01_02.jpg]'
- en: Figure 1.2 – The Android View System features in the imperative paradigm
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 命令式范式下的Android视图系统特性
- en: Manually manipulating views' states increases the chance of bugs and errors
    in your UI. Because you end up treating multiple possible states and because chunks
    of data are displayed in several such states, it's relatively easy to mess up
    the outcome of your UI. Illegal states or conflicts between states can also arise
    relatively easily when your UI grows in complexity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 手动操作视图的状态会增加你UI中出错和出现bug的机会。因为你需要处理多个可能的状态，并且数据块在几个这样的状态下显示，所以很容易搞乱你UI的结果。当你的UI变得复杂时，非法状态或状态之间的冲突也相对容易出现。
- en: 'Moreover, since the layouts are defined in an additional component – that is,
    an XML file – the coupling between `Activity`, `Fragment`, or `ViewModel` and
    the XML-based UI increases. This means that changing something on the UI in the
    XML file will often lead to changes in `Activity`, `Fragment`, or `ViewModel`
    classes, which is where state handling happens. Not only that but cohesion is
    reduced because of language differences: one component is in Java/Kotlin, while
    the other one is in XML. This means that for the UI to function, it needs not
    only an `Activity` or `Fragment` but also XML.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于布局定义在额外的组件中——即XML文件——`Activity`、`Fragment`或`ViewModel`与基于XML的UI之间的耦合增加。这意味着在XML文件中更改UI将经常导致`Activity`、`Fragment`或`ViewModel`类中的更改，这是状态处理发生的地方。不仅如此，由于语言差异，内聚性也降低了：一个组件在Java/Kotlin中，而另一个在XML中。这意味着为了UI能够工作，它不仅需要一个`Activity`或`Fragment`，还需要XML。
- en: The declarative paradigm
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明式范式
- en: To address some of the issues within the standard View System, Compose relies
    on a modern declarative UI model, which drastically simplifies the process of
    building, updating, and maintaining UIs on Android.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决标准视图系统中的某些问题，Compose依赖于一个现代的声明式UI模型，这极大地简化了在Android上构建、更新和维护UI的过程。
- en: If, in the traditional View System, the imperative paradigm described *how*
    the UI should change, in Compose, the declarative paradigm describes *what* the
    UI should render at a certain point in time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在传统的视图系统中，命令式范式描述了UI应该如何改变，那么在Compose中，声明式范式描述了UI在某个特定时间点应该渲染的内容。
- en: 'Compose does that by defining the screen as a tree of composables. As in the
    following examples, each composable passes data to its nested composables, just
    like the `FriendlyMessage` composable passed a name to the `Text` composable in
    our code example from the previous section:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 通过将屏幕定义为可组合物的树状结构来实现这一点。如下面的示例所示，每个可组合物都会将其数据传递给嵌套的可组合物，就像我们在上一节代码示例中的
    `FriendlyMessage` 可组合物将一个名字传递给 `Text` 可组合物一样：
- en: '![Figure 1.3 – Visualizing a tree of composable widgets and how data is passed
    downwards'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 可组合小部件树的可视化以及数据如何向下传递'
- en: '](img/B17788_01_03.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_01_03.jpg)'
- en: Figure 1.3 – Visualizing a tree of composable widgets and how data is passed
    downwards
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 可组合小部件树的可视化以及数据如何向下传递
- en: When the input arguments change, Compose regenerates the entire widget tree
    from scratch. It applies the necessary changes and eliminates the need and the
    associated complexity of manually updating each widget.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入参数发生变化时，Compose 会从头开始重新生成整个小部件树。它应用必要的更改，并消除了手动更新每个小部件的需要和关联的复杂性。
- en: This means that in Compose, composables are relatively stateless and because
    of that, they don't expose getter and setter methods. This allows the caller to
    react to interactions and handle the process of creating new states separately.
    It does that by calling the same composables but with different argument values.
    As we discussed in the *Describing UIs with composable functions* section, the
    UI in Compose is a function of data. From this, we can conclude that if new data
    is passed to composables, new UI states can be produced.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 Compose 中，可组合物相对无状态，因此它们不暴露 getter 和 setter 方法。这允许调用者对交互做出反应，并单独处理创建新状态的过程。它是通过调用相同的可组合物但使用不同的参数值来实现的。正如我们在
    *使用可组合函数描述 UI* 部分中讨论的那样，Compose 中的 UI 是数据的函数。由此我们可以得出结论，如果向可组合物传递新数据，就可以产生新的 UI
    状态。
- en: Lastly, compared to the View System, Compose only relies on Kotlin APIs, which
    means that UIs can now be defined with a single technology, in a single component,
    thereby increasing cohesion and reducing coupling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与视图系统相比，Compose 只依赖于 Kotlin API，这意味着 UI 现在可以用单一技术、单一组件来定义，从而增加了内聚性并减少了耦合性。
- en: Now, let's look at another shift in design brought by Compose and discuss how
    composition yields more flexible ways of defining UIs than inheritance does.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Compose 带来的另一个设计上的转变，并讨论组合如何比继承提供更灵活的 UI 定义方式。
- en: Favoring composition over inheritance
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先使用组合而非继承
- en: In the Android View System, every view inherits functionality from the parent
    `View` class. As the system relies solely on inheritance, the task of creating
    custom views can only be done through defining elaborate hierarchies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 视图系统中，每个视图都从父 `View` 类继承功能。由于系统完全依赖于继承，因此创建自定义视图的任务只能通过定义复杂的层次结构来完成。
- en: 'Let''s take the `Button` view as an example. It inherits functionality from
    `TextView`, which, in turn, inherits from `View`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `Button` 视图为例。它从 `TextView` 继承功能，而 `TextView` 又从 `View` 继承：
- en: '![Figure 1.4 – The class inheritance hierarchy for the Button view'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – `Button` 视图的类继承层次结构'
- en: '](img/B17788_01_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_01_04.jpg)'
- en: Figure 1.4 – The class inheritance hierarchy for the Button view
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – `Button` 视图的类继承层次结构
- en: This strategy is great for reusing functionality, but inheritance becomes difficult
    to scale and has little flexibility when trying to have multiple variations of
    one view.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略对于重用功能来说很棒，但当试图创建一个视图的多个变体时，继承变得难以扩展，并且灵活性很小。
- en: 'Say you want the `Button` view to render an image instead of text. In the View
    System, you would have to create an entirely new inheritance hierarchy, as shown
    in the following hierarchy diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要 `Button` 视图渲染图像而不是文本。在视图系统中，你必须创建一个全新的继承层次结构，如下面的层次结构图所示：
- en: '![Figure 1.5 – The class inheritance hierarchy for the ImageButton view'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – `ImageButton` 视图的类继承层次结构'
- en: '](img/B17788_01_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_01_05.jpg)'
- en: Figure 1.5 – The class inheritance hierarchy for the ImageButton view
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – `ImageButton` 视图的类继承层次结构
- en: But what if you need a button that accommodates both a `TextView` and an `ImageView`?
    This task would be extremely challenging, so it's easy to conclude that having
    separate inheritance hierarchies for each custom view is neither flexible nor
    scalable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你需要一个同时容纳 `TextView` 和 `ImageView` 的按钮呢？这个任务将极具挑战性，因此很容易得出结论，为每个自定义视图拥有独立的继承层次结构既不灵活也不可扩展。
- en: These examples are real, and they show the limitations of the View System. As
    we've previously seen, one of the biggest reasons for the lack of flexibility
    is the inheritance model of the View System.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子是真实的，它们展示了视图系统的局限性。正如我们之前看到的，缺乏灵活性的最大原因之一是视图系统的继承模型。
- en: 'To address this issue, *Compose favors composition over inheritance*. As shown
    in the following diagram, this means that Compose builds more complex UIs by using
    smaller pieces and not by inheriting functionality from one single parent:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，*组合更倾向于组合而非继承*。如图下所示，这意味着组合通过使用更小的组件来构建更复杂的UI，而不是通过从一个单一父组件继承功能：
- en: '![Figure 1.6 – Inheritance versus composition'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 – 继承与组合'
- en: '](img/B17788_01_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_01_06.jpg)'
- en: Figure 1.6 – Inheritance versus composition
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 继承与组合
- en: 'Let''s try to briefly explain our previous comparison between inheritance and
    composition:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地解释一下我们之前关于继承和组合的比较：
- en: With inheritance, you are limited to inheriting your parent, just like `Button`
    inherits only from `TextView`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承，你只能继承你的父组件，就像`Button`只从`TextView`继承一样。
- en: With composition, you can compose multiple other components, just like the `Button`
    composable contains both an `Image` composable and a `Text` composable, thereby
    giving you much more flexibility in building UIs.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合，你可以组合多个其他组件，就像`Button`可组合组件包含了一个`Image`和`Text`可组合组件一样，这为你构建UI提供了更大的灵活性。
- en: 'Let''s try to build a composable that features a button with an image and text.
    This was a huge challenge with inheritance, but Compose simplifies this by allowing
    you to compose an `Image` composable and a `Text` composable inside a `Button`
    composable:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建一个具有图像和文本的按钮的可组合组件。使用继承时，这是一个巨大的挑战，但Compose通过允许你在`Button`可组合组件内部组合`Image`和`Text`可组合组件来简化了这一点：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, our `SuggestiveButton` composable contains both `Image` and `Text` composables.
    The beauty of this is that it could contain anything else. A `Button` composable
    can accept other composables that it renders as part of its button's body. Don't
    worry about this aspect or about that weird composable called `Row` for now. The
    *Exploring the building blocks of Compose UIs* section will cover both of these
    aspects in more detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`SuggestiveButton`可组合组件包含了`Image`和`Text`可组合组件。这种美在于它可以包含任何其他内容。一个`Button`可组合组件可以接受其他可组合组件，并将其作为其按钮主体的部分进行渲染。现在不必担心这个方面，也不必担心那个奇怪的名为`Row`的可组合组件。*探索Compose
    UI构建块*部分将更详细地介绍这两个方面。
- en: What's important to remember from this example is that Compose gives us the
    flexibility of building a custom UI with ease. Next, let's cover how data and
    events flow in Compose.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们需要记住的是，Compose为我们提供了轻松构建自定义UI的灵活性。接下来，让我们来探讨在Compose中数据和事件是如何流动的。
- en: Unidirectional flow of data
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据的单向流动
- en: 'Knowing that each composable passes data down to its children composables,
    we can deduct that the internal state is no longer needed. This also translates
    into a unidirectional flow of data because composables only expect data as input
    and never care about their state:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 知道每个可组合组件都会将数据传递给其子可组合组件，我们可以推断出内部状态不再需要。这也转化为数据单向流动，因为可组合组件只期望作为输入的数据，而从不关心它们的状态：
- en: '![Figure 1.7 – Visualizing the unidirectional flow of data and events'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 – 可视化数据与事件的单向流动'
- en: '](img/B17788_01_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_01_07.jpg)'
- en: Figure 1.7 – Visualizing the unidirectional flow of data and events
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 可视化数据与事件的单向流动
- en: Similarly, with data, each composable passes down callback functions to its
    children composables. Yet this time, the callback functions are caused by user
    interactions, and they create an upstream of callbacks that goes from each nested
    composable to its parent and so on. This means that not only the data is unidirectional
    but also events, just in opposite ways.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在数据方面，每个可组合组件都会向下传递回调函数给其子可组合组件。但这次，回调函数是由用户交互引起的，它们创建了一个从每个嵌套可组合组件到其父组件以及更上层的回调函数的上游。这意味着不仅数据是单向的，事件也是如此，只是方向相反。
- en: From this, it's clear that data and events travel only in one direction, and
    that's a good thing because only one source of truth – ideally, `ViewModel` –
    is in charge of handling them, resulting in fewer bugs and easier maintenance
    as the UI scales.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，很明显，数据和事件只在一个方向上流动，这是好事，因为只有一个真相来源——理想情况下是`ViewModel`——负责处理它们，这导致在UI扩展时出现更少的错误和更易于维护。
- en: Let's consider a case with another composable provided by Jetpack Compose called
    `Button`. As its name suggests, it emits a button widget on the screen, and it
    exposes a callback function called `onClick` that notifies us whenever the user
    clicks the button.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个使用Jetpack Compose提供的另一个可组合组件`Button`的例子。正如其名所示，它在屏幕上发出一个按钮小部件，并且它公开一个名为`onClick`的回调函数，该函数在用户点击按钮时通知我们。
- en: 'In the following example, our `MailButton` composable receives data as an email
    identifier, `mailId`, and an event callback as a `mailPressedCallback` function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们的`MailButton`可组合组件接收一个电子邮件标识符`mailId`和一个事件回调函数`mailPressedCallback`：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While it consumes the data it receives via `mailId`, it also sets the `mailPressedCallback`
    function to be called every time its button is clicked, thereby sending the event
    back up to its parent. This way, data flows downwards and the callback flows upwards.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当它通过`mailId`接收数据时，它还会将`mailPressedCallback`函数设置为每次按钮被点击时调用，从而将事件发送回其父级。这样，数据向下流动，回调向上流动。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is ideal to construct your Compose UI in such a way that data provided by
    the `ViewModel` flows from parent composables to children composables and events
    flow from each composable back up to the `ViewModel`. If you're not familiar with
    the `ViewModel` component, don't worry as will cover it in the upcoming [*Chapter
    2*](B17788_02_ePub.xhtml#_idTextAnchor069), *Handling UI State with Jetpack ViewModel*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 构建您的Compose UI的理想方式是，由`ViewModel`提供的数据从父级可组合组件流向子级可组合组件，事件从每个可组合组件流向`ViewModel`。如果您不熟悉`ViewModel`组件，请不要担心，我们将在即将到来的[*第2章*](B17788_02_ePub.xhtml#_idTextAnchor069)，*使用Jetpack
    ViewModel处理UI状态*中介绍它。
- en: Recomposition
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重组合
- en: We have already covered how composable functions are defined by their input
    data and stated that whenever the data changes, composables are rebuilt as they
    render a new UI state corresponding to the newly received data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何通过输入数据定义可组合函数，并指出每当数据发生变化时，可组合组件都会重建，以渲染与新接收到的数据相对应的新UI状态。
- en: The process of calling your composable functions again when inputs change is
    called **recomposition**. When inputs change, Compose automatically triggers the
    recomposition process for us and rebuilds the UI widget tree, redrawing the widgets
    emitted by the composables so that they display the newly received data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入改变时再次调用您的可组合函数的过程称为**重组合**。当输入改变时，Compose会自动为我们触发重组合过程并重建UI小部件树，重新绘制由可组合组件发出的小部件，以便它们显示新接收到的数据。
- en: Yet recomposing the entire UI hierarchy is computationally expensive, which
    is why Compose only calls the functions that have new input while skipping the
    ones whose input hasn't changed. Optimizing the process of rebuilding the composable
    tree is a complex job and is usually referred to as *intelligent recomposition*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重新组合整个UI层次结构是计算密集型的，这就是为什么Compose只调用具有新输入的函数，而跳过那些输入未改变的函数。优化重建可组合树的过程是一项复杂的工作，通常被称为*智能重组合*。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the traditional View System, we would manually call the setters and getters
    of views, but with Compose, it's enough to provide new arguments to our composables.
    This will allow Compose to initiate the recomposition process for parts of the
    UI so that the updated values are displayed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的视图系统中，我们会手动调用视图的设置器和获取器，但使用Compose，只需为我们提供的可组合组件提供新参数即可。这将允许Compose为UI的部分启动重组合过程，以便显示更新的值。
- en: 'Before jumping into an actual example of recomposition, let''s have a quick
    look at the lifecycle of a composable function. Its lifecycle is defined by the
    composition lifecycle, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实际的重组合示例之前，让我们快速看一下可组合函数的生命周期。其生命周期由组合生命周期定义，如下所示：
- en: '![Figure 1.8 – The composition lifecycle of a composable function'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 – 可组合函数的组合生命周期]'
- en: '](img/B17788_01_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_01_08.jpg]'
- en: Figure 1.8 – The composition lifecycle of a composable function
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 可组合函数的组合生命周期
- en: This means that a composable first enters composition, and before leaving this
    process, it can recompose as many times as needed – that is, before it disappears
    from the screen, it can be recomposed and rebuilt many times, each time possibly
    displaying a different value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个可组合组件首先进入组合状态，在离开此过程之前，它可以按需重新组合多次——也就是说，在它从屏幕消失之前，它可以被重新组合和重建多次，每次可能显示不同的值。
- en: 'Recomposition is often triggered by changes within `State` objects, so let''s
    look at an example to explore how seamlessly this happens with little intervention
    from our side. Say you have a `TimerText` composable that expects a certain number
    of elapsed `seconds` that it displays in a `Text` composable. The timer starts
    from 0 and updates every 1 second (or 1,000 ms), displaying the number of seconds
    that have elapsed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重组通常是由`State`对象内部的变化触发的，因此让我们通过一个例子来探讨这一过程是如何在我们几乎没有干预的情况下无缝发生的。假设你有一个`TimerText`可组合组件，它期望显示一个特定的已过`seconds`数，这个数在一个`Text`可组合组件中显示。计时器从0开始，每秒更新一次（或1,000毫秒），显示已过的秒数：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the *Defining and handling state with Compose* section of [*Chapter 2*](B17788_02_ePub.xhtml#_idTextAnchor069),
    *Handling UI State with Jetpack ViewModel*, we will define the state in Compose
    in more detail, but until then, let's think of `seconds` as a simple state object
    (instantiated with `mutableStateOf()`) that has an initial value of `0` and that
    its value changes over time, triggering a recomposition each time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B17788_02_ePub.xhtml#_idTextAnchor069)的*定义和处理Compose状态*部分，我们将更详细地定义Compose中的状态，但在此之前，让我们将`seconds`视为一个简单的状态对象（使用`mutableStateOf()`实例化），其初始值为`0`，并且其值会随时间变化，每次变化都会触发一次重组。
- en: Every time `stopWatchTimer` increases the value of the `seconds` state object,
    Compose triggers a recomposition that rebuilds the widget tree and redraws the
    composables with new arguments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`stopWatchTimer`增加`seconds`状态对象的值时，Compose都会触发一次重组，重建组件树并使用新的参数重新绘制可组合组件。
- en: In our case, `TimerText` will be recomposed or rebuilt because it receives different
    arguments – the first time, it will receive `0`, then `1`, `2`, and so on. This,
    in turn, triggers the `Text` composable to also recompose and that's why Compose
    redraws it on the screen to display the updated message.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`TimerText`将因为接收不同的参数而进行重组或重建——第一次，它将接收`0`，然后是`1`、`2`，依此类推。这反过来又触发了`Text`可组合组件也进行重组，这就是为什么Compose会在屏幕上重新绘制它以显示更新的消息。
- en: 'Recomposition is a complex topic. As we will not be able to go into too much
    depth on it now, it''s important to also cover more advanced concepts, as described
    in the documentation: [https://developer.android.com/jetpack/compose/mental-model#any-order](https://developer.android.com/jetpack/compose/mental-model#any-order).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重组是一个复杂的话题。由于我们现在无法深入探讨，因此也很重要地介绍一些更高级的概念，如文档中所述：[https://developer.android.com/jetpack/compose/mental-model#any-order](https://developer.android.com/jetpack/compose/mental-model#any-order)。
- en: Now that we've covered what recomposition is and the core concepts behind Compose,
    it's time to have a better look at the composables that are used to build a Compose
    UI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了重组是什么以及Compose背后的核心概念，是时候更深入地了解用于构建Compose UI的可组合组件了。
- en: Exploring the building blocks of Compose UIs
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Compose UI的构建块
- en: 'We''ve only had a brief look at the `Text` and `Button` composables so far.
    That''s why, in this section, we will not only understand how activities can render
    composables instead of XML and how we can preview them, but we will also have
    a better look at the most important and commonly used composable functions: from
    the ones we''ve seen, such as `Text` and `Button`, to new ones such as `TextField`,
    `Image`, `Row`, `Column`, and `Box`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止只简要地看了`Text`和`Button`可组合组件。这就是为什么在本节中，我们不仅将了解活动如何渲染可组合组件而不是XML，以及如何预览它们，而且还将更深入地了解最重要和最常用的可组合函数：从我们看到的，如`Text`和`Button`，到新的如`TextField`、`Image`、`Row`、`Column`和`Box`。
- en: 'To summarize, this section will cover the following topics:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本节将涵盖以下主题：
- en: Setting content and previewing composables
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置内容和预览可组合组件
- en: Exploring core composables
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索核心可组合组件
- en: Customizing composables with modifiers
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用修饰符自定义可组合组件
- en: Layouts in Compose
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compose中的布局
- en: Let's jump in and understand how to render composable functions on the screen.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始了解如何在屏幕上渲染可组合函数。
- en: Setting content and previewing composables
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置内容和预览可组合组件
- en: We had a quick look at some composable functions, but we didn't quite touch
    on the aspect of making the application display Compose UIs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速浏览了一些可组合函数，但并没有涉及到使应用程序显示Compose UI的方面。
- en: 'Setting the composable content can easily be achieved and is encouraged to
    be done in your `Activity` class by simply replacing the traditional `setContentView(R.layout.XML)`
    call with `setContent()` and passing a composable function to it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地替换传统的`setContentView(R.layout.XML)`调用为`setContent()`并将一个composable函数传递给它，就可以轻松设置composable内容，并鼓励你在`Activity`类中这样做：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because Compose no longer needs the `AppCompat` API for backward compatibility,
    we made our `MainActivity` inherit the base `ComponentActivity` class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Compose不再需要`AppCompat` API进行向后兼容，我们让我们的`MainActivity`继承自基础`ComponentActivity`类。
- en: In the previous example, we called the `setContent` method in the `onCreate`
    callback of `MainActivity` and passed a `Text` composable function to it. If we
    run the app, we will see the `"Hello world"` message.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在`MainActivity`的`onCreate`回调中调用了`setContent`方法，并将一个`Text` composable函数传递给它。如果我们运行这个应用，我们将看到`"Hello
    world"`消息。
- en: The `setContent` method is an extension function for `ComponentActivity` that
    composes the given composable into the given activity. It only accepts a `@Composable`
    function as a trailing lambda. The input composable function will become the root
    view of the activity and act as a container for your Compose hierarchy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`setContent`方法是为`ComponentActivity`提供的扩展函数，它将给定的composable组合到给定的活动中。它只接受一个`@Composable`函数作为尾随lambda。输入的composable函数将成为活动的根视图，并作为你的Compose层次结构的容器。'
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can add composable functions into fragments or activities that have an XML
    UI already defined with the help of the `ComposeView` class, but we will not go
    into too much detail as far as interoperability goes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ComposeView`类将composable函数添加到已经定义了XML UI的片段或活动中，但关于互操作性的细节我们将不会过多介绍。
- en: As XML provided us with a preview tool, a good question would be whether Compose
    also has one. Compose brings an even more powerful preview tool that allows us
    to skip running the application on the emulator or real devices every time we
    want to see how our UI evolves.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于XML为我们提供了一个预览工具，一个很好的问题是Compose是否也有一个。Compose带来的是一个更强大的预览工具，它允许我们在每次想要查看UI如何演变时，无需在模拟器或真实设备上运行应用程序。
- en: 'Previewing your composable is easy; just add the `@Preview` annotation to it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 预览你的composable非常简单；只需将其添加到`@Preview`注解中：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The IDE will automatically pick up that you want to preview this composable
    and show it on the right-hand side of the screen. Make sure that you *rebuild*
    your project and have the **Split** option enabled:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: IDE会自动检测你想要预览这个composable，并将其显示在屏幕的右侧。请确保你*重新构建*你的项目并启用**分割**选项：
- en: '![Figure 1.9 – Previewing composable functions in Android Studio'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.9 – Previewing composable functions in Android Studio'
- en: '](img/B17788_01_09.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_01_09.jpg]'
- en: Figure 1.9 – Previewing composable functions in Android Studio
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 在Android Studio中预览composable函数
- en: Optionally, you can specify for the preview to show a background for better
    visibility by passing the `showBackground` parameter with a value of `true`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以通过传递值为`true`的`showBackground`参数来指定预览显示背景以获得更好的可见性。
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that the composable function you are trying to preview has no input
    parameters. If it has, supply the default values for them so that the preview
    tools can work.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你想要预览的composable函数没有输入参数。如果有，请为它们提供默认值，以便预览工具可以工作。
- en: 'Yet this preview tool is much more powerful than this as it supports **Interactive
    mode**, which allows you to interact with the UI, and **Live Edit of literals**,
    which, if enabled, causes the preview to reload every time you change widths,
    heights, or others, just like a real UI would. You can see these two options in
    the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个预览工具比这更强大，因为它支持**交互模式**，允许你与UI交互，以及**实时编辑文本**，如果启用，每次你更改宽度、高度或其他设置时，预览都会重新加载，就像真实的UI一样。你可以在下面的屏幕截图中看到这两个选项：
- en: '![Figure 1.10 – Using the Preview feature in Compose'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.10 – Using the Preview feature in Compose'
- en: '](img/B17788_01_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_01_10.jpg]'
- en: Figure 1.10 – Using the Preview feature in Compose
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 在Compose中使用预览功能
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To enable **Interactive mode** on Android Studio Arctic Fox, go to **File**
    | **Settings** | **Experimental** (Windows) or **Android Studio** | **Preferences**
    | **Experimental** (macOS).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android Studio Arctic Fox上启用**交互模式**，请转到**文件** | **设置** | **实验性**（Windows）或**Android
    Studio** | **首选项** | **实验性**（macOS）。
- en: 'Additionally, you can have multiple previews simultaneously if you annotate
    each function with the `@Preview` annotation. You can add names for each preview
    through the `name` parameter and even tell the preview tool which device it should
    display it on through the `device` argument:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你在每个函数上使用 `@Preview` 注解，你可以同时拥有多个预览。你可以通过 `name` 参数为每个预览添加名称，甚至可以通过 `device`
    参数告诉预览工具它应该在哪个设备上显示：
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Make sure that you also set `showSystemUi` to `true` to see the entire device.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你也设置 `showSystemUi` 为 `true` 以查看整个设备。
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: '`@Preview` functions should have different names to avoid preview conflicts.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Preview` 函数应该有不同的名称，以避免预览冲突。'
- en: Now that we have learned how to set and preview Compose UI, it's time to explore
    new composables.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何设置和预览 Compose UI，是时候探索新的可组合组件了。
- en: Exploring core composables
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索核心可组合组件
- en: 'We''ve already had a quick look at some of the most basic composable functions:
    `Text`, `Button`, and `Image`. In this subsection, we will spend a bit more time
    exploring not only those composables but also new ones such as `TextField`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经快速浏览了一些最基本的可组合函数：`Text`、`Button` 和 `Image`。在本小节中，我们将花更多的时间探索这些可组合组件，以及新的组件，如
    `TextField`。
- en: Text
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本
- en: '`Text` is the Compose version of our old and beloved `TextView`. `Text` is
    provided by Compose and achieves the most basic and yet important functionality
    in any application: the ability to display a piece of text. We''ve already used
    this composable in several examples:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text` 是我们旧的和喜爱的 `TextView` 的 Compose 版本。`Text` 由 Compose 提供，实现了任何应用程序中最基本但最重要的功能：显示文本的能力。我们已经在几个示例中使用了这个可组合组件：'
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might be wondering how we can customize it. Let''s check out the source
    code or the documentation for `Text` to find the most basic and commonly used
    arguments for it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们如何自定义它。让我们查看 `Text` 的源代码或文档，以找到它最基本的和最常用的参数：
- en: '`text` is the only required argument. It expects a `String` and sets the output
    text.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text` 是唯一的必填参数。它期望一个 `String` 并设置输出文本。'
- en: '`color` specifies the color of the output text and expects a `Color` object.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color` 指定输出文本的颜色，并期望一个 `Color` 对象。'
- en: '`fontSize` of type `TextUnit`, `fontStyle` of type `FontStyle`, `fontFamily`
    of type `FontFamily`, and `fontWeight` of type `FontWeight` all allow you to customize
    the look and appearance of your text.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fontSize` 类型为 `TextUnit`、`fontStyle` 类型为 `FontStyle`、`fontFamily` 类型为 `FontFamily`
    和 `fontWeight` 类型为 `FontWeight` 都允许你自定义文本的外观和样式。'
- en: '`textAlign` specifies the horizontal alignment of the text. It expects a `TextAlign`
    object.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textAlign` 指定文本的水平对齐方式。它期望一个 `TextAlign` 对象。'
- en: '`maxLines` expects an `Int` value that sets the maximum number of lines in
    the output text.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxLines` 期望一个 `Int` 值，用于设置输出文本的最大行数。'
- en: '`style` expects a `TextStyle` object and allows you to define and reuse styles
    through themes.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style` 期望一个 `TextStyle` 对象，并允许你通过主题定义和重用样式。'
- en: 'Instead of going through all the arguments for `Text`, let''s check out an
    example where we can customize the look of our `Text` composable function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是逐个检查 `Text` 的所有参数，而是看看一个我们可以自定义 `Text` 可组合函数外观的例子：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead of passing some hardcoded text, we passed a string resource with the
    help of the built-in `stringResource` function and obtained the following result:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是传递一些硬编码的文本，我们通过内置的 `stringResource` 函数传递了一个字符串资源，并得到了以下结果：
- en: '![Figure 1.11 – Exploring a customized Text composable'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11 – 探索自定义的 Text 可组合组件'
- en: '](img/B17788_01_11.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_01_11.jpg)'
- en: Figure 1.11 – Exploring a customized Text composable
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 探索自定义的 Text 可组合组件
- en: Now that we've learned how to display text with the `Text` composable, let's
    move on to buttons.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用 `Text` 可组合组件显示文本，接下来让我们转向按钮。
- en: Button
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮
- en: Displaying text is essential in any application, yet having clickable buttons
    allows it to be interactive. We've used the `Button` composable (previously known
    in the View System as `Button` too) before and its main characteristic was the
    `onClick` callback function, which notified us when the user pressed the button.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，显示文本都是至关重要的，但拥有可点击的按钮可以让应用程序变得交互式。我们之前已经使用过 `Button` 可组合组件（在视图系统中也称为
    `Button`），其主要特点是 `onClick` 回调函数，它会通知我们用户何时按下按钮。
- en: 'While `Button` features plenty of customizing arguments, let''s check out the
    most used parameters:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Button` 有很多自定义参数，但让我们看看最常用的参数：
- en: '`onClick` is a mandatory parameter and it expects a function that will be called
    whenever the user presses the button.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick` 是一个必填参数，它期望一个函数，当用户按下按钮时将被调用。'
- en: '`colors` expects a `ButtonColors` object that defines the content/background
    colors.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colors`期望一个定义内容/背景颜色的`ButtonColors`对象。'
- en: '`shape` expects a custom/Material theme `Shape` object that sets the shape
    of the button.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape`期望一个自定义/材料主题`Shape`对象，用于设置按钮的形状。'
- en: '`content` is a mandatory parameter that expects a composable function that
    displays the content inside this `Button`. We can add any composables here, including
    `Text`, `Image`, and more.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`是一个强制参数，它期望一个显示此`Button`内部内容的可组合函数。我们可以在其中添加任何可组合函数，包括`Text`、`Image`等。'
- en: 'Let''s try to build a `Button` function that makes use of these core arguments:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建一个`Button`函数，使其利用这些核心参数：
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ve also passed a predefined `MaterialTheme` shape. Let''s preview the resulting
    composable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递了一个预定义的`MaterialTheme`形状。让我们预览生成的可组合函数：
- en: '![Figure 1.12 – Exploring a customized Button composable'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12 – 探索自定义按钮可组合函数'
- en: '](img/B17788_01_12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12 – 探索自定义按钮可组合函数'
- en: Figure 1.12 – Exploring a customized Button composable
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 – 探索自定义按钮可组合函数
- en: With that, we've seen how easy it is to create a custom button with the `Button`
    composable. Next up, let's try to play around with another composable function
    – `TextField`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经看到了如何轻松地使用`Button`可组合函数创建自定义按钮。接下来，让我们尝试玩转另一个可组合函数——`TextField`。
- en: TextField
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TextField
- en: Adding buttons is the first step toward having an interactive UI, but the most
    important element in this area is the `TextField` composable, previously known
    in the View System as `EditText`. Just like `EditText` did, the `TextField` composable
    allows the user to enter and modify text.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 添加按钮是拥有交互式UI的第一步，但这个领域最重要的元素是`TextField`可组合函数，在视图系统中之前被称为`EditText`。就像`EditText`所做的那样，`TextField`可组合函数允许用户输入和修改文本。
- en: 'While `TextField` has many arguments, the most important ones that it features
    are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`TextField`有很多参数，但它最重要的参数如下：
- en: '`value` is a mandatory `String` argument as it''s the displayed text. This
    value should change as we type inside it by holding it in a `State` object; more
    on that soon.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`是一个强制`String`参数，因为它是显示的文本。这个值应该在我们输入时改变，通过将其保持在`State`对象中；关于这一点，我们很快就会详细介绍。'
- en: '`onValueChange` is a mandatory function that triggers every time the user inputs
    new characters or deletes existing ones.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onValueChange`是一个强制函数，每次用户输入新字符或删除现有字符时都会触发。'
- en: '`label` expects a composable function that allows us to add a descriptive label.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`期望一个可组合的函数，允许我们添加一个描述性标签。'
- en: 'Let''s have a look at a simple usage of a `TextField` that also handles its
    own state:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的`TextField`用法，它也处理自己的状态：
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It achieves this by defining a `MutableState` that holds the text displayed
    by `TextField`. This means that `textState` doesn't change across recompositions,
    so every time the UI updates because of other composables, `textState` should
    be retained. Moreover, we've wrapped the `MutableState` object in a `remember`
    block, which tells Compose that across recompositions, it should not revert the
    value to its initial value; that is, `""`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过定义一个`MutableState`来持有`TextField`显示的文本来实现这一点。这意味着`textState`在重新组合过程中不会改变，所以每次UI因为其他可组合函数而更新时，`textState`都应该被保留。此外，我们还在`MutableState`对象上包裹了一个`remember`块，这告诉Compose在重新组合过程中，它不应该将值重置为其初始值；即`""`。
- en: To get or set the value of a `State` or `MutableState` object, our `NameInput`
    composable uses the `value` accessor. Because `TextField` accesses a `MutableState`
    object through the `value` accessor, Compose knows to retrigger a *recomposition*
    every time the `textState` value changes – in our case, in the `onValueChange`
    callback. By doing so, we ensure that as we input text in our `TextField`, the
    UI also updates with the new characters that have been added or removed from the
    keyboard.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取或设置`State`或`MutableState`对象的值，我们的`NameInput`可组合函数使用`value`访问器。因为`TextField`通过`value`访问器访问`MutableState`对象，所以Compose知道每次`textState`值改变时——在我们的案例中，在`onValueChange`回调中——重新触发*重新组合*。通过这样做，我们确保当我们输入`TextField`中的文本时，UI也会更新，以显示已添加或从键盘删除的新字符。
- en: Don't worry if these concepts about state in Compose don't make too much sense
    right now – we will cover how state is defined in Compose in more detail in [*Chapter
    2*](B17788_02_ePub.xhtml#_idTextAnchor069), *Handling UI State with Jetpack ViewModel*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Compose中的状态概念现在不太容易理解，请不要担心——我们将在[*第2章*](B17788_02_ePub.xhtml#_idTextAnchor069)中更详细地介绍如何在Compose中定义状态，即使用Jetpack
    ViewModel处理UI状态。
- en: 'Note:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: Unlike `EditText`, `TextField` has no internal state. That's why we've created
    and handled it; otherwise, as we would type in, the UI would not update accordingly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `EditText` 不同，`TextField` 没有内部状态。这就是为什么我们创建并处理了它；否则，当我们输入时，UI 不会相应地更新。
- en: 'The resulting `NameInput` composable updates the UI correctly and looks like
    this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 `NameInput` 可组合项正确更新了 UI，看起来像这样：
- en: '![Figure 1.13 – Exploring a TextField composable'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.13 – 探索 TextField 可组合项'
- en: '](img/B17788_01_13.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_01_13.jpg)'
- en: Figure 1.13 – Exploring a TextField composable
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – 探索 TextField 可组合项
- en: Now that we've learned how to add input fields within a Compose-based app, it's
    time to explore one of the most common elements in any UI.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在基于 Compose 的应用程序中添加输入字段，是时候探索任何 UI 中最常见的元素之一了。
- en: Image
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像
- en: Displaying graphical information in our application is essential and Compose
    provides us with a handy composable called `Image`, which is the composable version
    of the `ImageView` from the View System.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中显示图形信息是至关重要的，Compose 提供了一个方便的可组合项，称为 `Image`，它是 View 系统中 `ImageView`
    的可组合版本。
- en: 'While `Image` features plenty of customizing arguments, let''s check out the
    most used parameters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Image` 具有许多自定义参数，但让我们检查一下最常用的参数：
- en: '`painter` expects a `Painter` object. This argument is mandatory as it sets
    the image resource. Alternatively, you can use the overloaded version of `Image`
    to directly pass an `ImageBitmap` object to its `bitmap` parameter.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`painter` 期望一个 `Painter` 对象。此参数是必需的，因为它设置了图像资源。作为替代，你可以使用 `Image` 的重载版本，直接将
    `ImageBitmap` 对象传递给其 `bitmap` 参数。'
- en: '`contentDescription` is a mandatory `String` that''s used by accessibility
    services.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentDescription` 是一个必需的 `String`，它被辅助功能服务使用。'
- en: '`contentScale` expects a `ContentScale` object that specifies the scaling of
    the picture.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentScale` 期望一个 `ContentScale` 对象，该对象指定了图片的缩放。'
- en: 'Let''s add an `Image` composable that displays the application icon using `painterResource`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个显示应用程序图标的 `Image` 可组合项，使用 `painterResource`：
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let''s preview the `BeautifulImage` function and then move on to the
    next section:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们预览 `BeautifulImage` 函数，然后继续下一节：
- en: '![Figure 1.14 – Exploring the Image composable'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.14 – 探索 Image 可组合项'
- en: '](img/B17788_01_14.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_01_14.jpg)'
- en: Figure 1.14 – Exploring the Image composable
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – 探索 Image 可组合项
- en: We've also tried displaying images with Compose, yet you may still be wondering,
    how can we customize all these composable functions?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也尝试过使用 Compose 显示图片，但你可能仍在 wondering，我们如何自定义所有这些可组合函数？
- en: Customizing composables with modifiers
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用修饰符自定义可组合项
- en: 'All the composables we''ve covered so far feature an argument that we haven''t
    covered yet: `modifier`. This expects a `Modifier` object. In simple terms, *modifiers
    tell a composable how to display, arrange, or behave within its parent composable.*
    By passing a modifier, we can specify many configurations for a composable: from
    size, padding, or shape to background color or border.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所涵盖的所有可组合项都包含一个我们尚未涵盖的参数：`modifier`。它期望一个 `Modifier` 对象。简单来说，*修饰符告诉一个可组合项如何在父可组合项中显示、排列或表现。通过传递修饰符，我们可以为可组合项指定许多配置：从大小、填充或形状到背景颜色或边框。*
- en: 'Let''s start with an example by using a `Box` composable and specifying a `size`
    modifier for it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始，使用 `Box` 可组合项并为其指定一个 `size` 修饰符：
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will cover the `Box` composable later but until then, you can think of it
    like a container that we will use to draw several shapes on the screen. What's
    important here is that we passed the `Modifier.size()` modifier, which sets the
    size of the box. It accepts a `dp` value that represents both the width and the
    height of the composable. You can also pass the width and height as parameters
    within the `size()` modifier or separately with the help of the `height()` and
    `width()` modifiers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后介绍 `Box` 可组合项，但在此之前，你可以将其视为一个容器，我们将使用它来在屏幕上绘制几个形状。这里重要的是我们传递了 `Modifier.size()`
    修饰符，它设置了盒子的大小。它接受一个 `dp` 值，代表可组合项的宽度和高度。你还可以在 `size()` 修饰符内部或使用 `height()` 和 `width()`
    修饰符单独传递宽度和高度作为参数。
- en: 'Specifying only one modifier for composables is usually not enough. That''s
    why *modifiers can be chained*. Let''s chain multiple modifiers by adding several
    other configurations to our `Box`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只为可组合项指定一个修饰符是不够的。这就是为什么 *修饰符可以被链式调用。让我们通过向我们的 `Box` 添加几个其他配置来链式调用多个修饰符：*
- en: '[PRE13]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we mentioned previously, chaining modifiers is simple: start with an empty
    `Modifier` object and then chain new modifiers one after the other. We''ve chained
    several new modifiers, starting with `background`, then `padding`, `clip`, and
    finally another `background`. The modifiers, when combined, produce an output
    consisting of a green rectangle that contains a nested rounded corner rectangle
    that''s red:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，链式修饰符很简单：从一个空的`Modifier`对象开始，然后依次链接着新的修饰符。我们已经链接着几个新的修饰符，从`background`开始，然后是`padding`、`clip`，最后是另一个`background`。当这些修饰符组合在一起时，产生了一个输出，它是一个绿色的矩形，其中包含一个嵌套的红色圆角矩形：
- en: '![Figure 1.15 – Exploring chained modifiers'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15 – 探索链式修饰符'
- en: '](img/B17788_01_15.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_01_15.jpg)'
- en: Figure 1.15 – Exploring chained modifiers
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 – 探索链式修饰符
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The order of the modifiers in the chain matters because modifiers are applied
    from the outer layer to the inner layer. Each modifier modifies the composable
    and then prepares it for the upcoming modifier in the chain. Different modifier
    orders yield different results.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 链中修饰符的顺序很重要，因为修饰符是从外层应用到内层的。每个修饰符都会修改可组合组件，并为链中的下一个修饰符准备它。不同的修饰符顺序会产生不同的结果。
- en: In the previous example, because modifiers are applied from the outermost layer
    to the innermost layer, the entire rectangular box is green because green is the
    first color modifier that's applied. Going inner, we applied a padding of 16 `dp`.
    Afterward, still going inner, the `RoundedCornerShape` modifier is applied. Finally,
    in the innermost layer, we applied another color modifier – this time, of the
    color red – and we got our final result.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，因为修饰符是从最外层应用到最内层的，所以整个矩形框是绿色的，因为绿色是第一个应用的颜色修饰符。向内移动，我们应用了16 `dp`的内边距。之后，仍然向内移动，应用了`RoundedCornerShape`修饰符。最后，在最内层，我们应用了另一个颜色修饰符——这次是红色——我们得到了最终的结果。
- en: Now that we've played around with the most common composables, it's time to
    start building actual layouts that make use of multiple composable functions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经玩转了最常见的可组合组件，是时候开始构建实际布局了，这些布局使用了多个可组合函数。
- en: Layouts in Compose
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Compose中的布局
- en: Often, building even a simple screen cannot be achieved by following the previous
    examples since most of them feature only one composable. For simple use cases,
    composable functions contain only one composable child.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，即使按照前面的例子，也无法仅通过构建一个简单的屏幕，因为其中大多数例子只包含一个可组合组件。对于简单的用例，可组合函数只包含一个子可组合组件。
- en: To build more complex pieces of UI, layout components in Compose give you the
    option to add as many children composables as you need.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建更复杂的UI组件，Compose中的布局组件允许您添加所需数量的子可组合组件。
- en: 'In this section, we will cover those composable functions that allow you to
    place children composables in a linear or overlayed fashion, such as the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍那些允许您以线性或叠加方式放置子可组合组件的可组合函数，例如以下内容：
- en: '`Row` for arranging children composables in a horizontal fashion'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Row`用于水平排列子可组合组件'
- en: '`Column` for arranging children composables vertically'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column`用于垂直排列子可组合组件'
- en: '`Box` for arranging children composables on top of each other'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Box`用于将子可组合组件堆叠在一起'
- en: 'Following these definitions, let''s envision the layout composables with the
    following diagram:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些定义，让我们通过以下图表来设想布局可组合组件：
- en: '![Figure 1.16 – Exploring Column, Row, and Box'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.16 – 探索Column、Row和Box'
- en: '](img/B17788_01_16.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_01_16.jpg)'
- en: Figure 1.16 – Exploring Column, Row, and Box
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16 – 探索Column、Row和Box
- en: It's clear now that arranging children composables in different ways can easily
    be achieved with `Column`, `Row`, and `Box`, so it's time to look at them in more
    detail.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很清楚，通过`Column`、`Row`和`Box`以不同的方式排列子可组合组件可以很容易地实现，所以现在是时候更详细地研究它们了。
- en: Row
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行
- en: 'Displaying multiple widgets on the screen is achieved by using a `Row` composable
    that arranges its children composables horizontally, just like the old `LinearLayout`
    with horizontal orientation did:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示多个小部件是通过使用一个`Row`可组合组件来水平排列其子可组合组件来实现的，就像旧的具有水平方向的`LinearLayout`一样：
- en: '[PRE14]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ve set `Row` to only take the available width and added several `Text`
    functions as children composables. We specified a `horizontalArrangement` of `Start`
    so that they start from the left of the parent but also made sure that they are
    centered vertically by passing a `CenterVertically` alignment for the `verticalAlignment`
    argument. The result is straightforward:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `Row` 设置为仅占用可用宽度，并添加了多个 `Text` 函数作为子元素可组合。这次，我们指定了 `horizontalArrangement`
    为 `Start`，这样它们就从父元素的左侧开始，同时也确保它们通过传递 `verticalAlignment` 参数的 `CenterVertically`
    对齐来垂直居中。结果是直接的：
- en: '![Figure 1.17 – Exploring the Row composable'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.17 – 探索 Row 可组合元素'
- en: '](img/B17788_01_17.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_01_17.jpg](img/B17788_01_17.jpg)'
- en: Figure 1.17 – Exploring the Row composable
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 探索 Row 可组合元素
- en: 'Largely, the essential arguments for a `Row` composable are related to how
    children are arranged or aligned:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，`Row` 可组合元素的基本参数与子元素的排列或对齐方式相关：
- en: '`horizontalArrangement` defines how the children are positioned horizontally
    both relative to each other and within the parent `Row`. Apart from `Arragement.Start`,
    you can also pass `Center` or `End` or `SpaceBetween`, `SpaceEvenly`, or `SpaceAround`.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horizontalArrangement` 定义了子元素相对于彼此以及相对于父元素 `Row` 的水平位置。除了 `Arrangement.Start`，还可以传递
    `Center`、`End`、`SpaceBetween`、`SpaceEvenly` 或 `SpaceAround`。'
- en: '`verticalAlignment` sets how the children are positioned vertically within
    the parent `Row`. Apart from `Alignment.CenterVertically`, you can pass `Top`
    or `Bottom`.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verticalAlignment` 设置了子元素在父元素 `Row` 中的垂直位置。除了 `Alignment.CenterVertically`，还可以传递
    `Top` 或 `Bottom`。'
- en: Now that we've arranged the children composables horizontally, let's try to
    arrange them vertically.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经水平排列了子元素可组合，让我们尝试垂直排列它们。
- en: Column
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Column
- en: 'Displaying a vertical list on the screen can be achieved by using a `Column`
    composable that arranges its children composables vertically, just like the old
    `LinearLayout` with vertical orientation did:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示垂直列表可以通过使用排列其子元素可组合元素的垂直 `Column` 可组合元素来实现，就像旧的具有垂直方向的 `LinearLayout`
    一样：
- en: '[PRE15]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ve set `Column` to take all the available space and added several `Text`
    functions as children composables. This time, we specified a `verticalArrangement`
    of `SpaceEvenly` so that children are spread out equally within the parent, but
    we also made sure they are centered horizontally by passing a `CenterHorizontally`
    alignment as `horizontalAlignment`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `Column` 设置为占用所有可用空间，并添加了多个 `Text` 函数作为子元素可组合。这次，我们指定了 `verticalArrangement`
    为 `SpaceEvenly`，这样子元素在父元素内部均匀分布，但我们还确保它们通过传递 `horizontalAlignment` 参数的 `CenterHorizontally`
    对齐来水平居中：
- en: '![Figure 1.18 – Exploring the Column composable'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.18 – 探索 Column 可组合元素'
- en: '](img/B17788_01_18.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_01_18.jpg](img/B17788_01_18.jpg)'
- en: Figure 1.18 – Exploring the Column composable
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 探索 Column 可组合元素
- en: 'Similar to `Row`, the essential arguments for a `Column` are also related to
    how children are arranged or aligned. This time, though, the arrangement is vertical
    instead of horizontal, and the alignment is horizontal instead of vertical:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Row` 类似，`Column` 的基本参数也与子元素的排列或对齐方式相关。不过，这次排列是垂直的，而对齐是水平的：
- en: '`verticalArrangement` defines how the children are vertically positioned within
    the parent `Column`. The values are the same as the row''s `horizontalArrangement`.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verticalArrangement` 定义了子元素在父元素 `Column` 中的垂直位置。这些值与行的 `horizontalArrangement`
    相同。'
- en: '`horizontalAlignment` defines how the children are aligned within the parent
    `Column`. Apart from `Alignment.CenterHorizontally`, you can pass `Start` or `End`.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horizontalAlignment` 定义了子元素在父元素 `Column` 中的对齐方式。除了 `Alignment.CenterHorizontally`，还可以传递
    `Start` 或 `End`。'
- en: Note
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If you're feeling brave, this is a great time for you to explore different alignments
    and arrangements and see how the UI changes. Make sure that you preview your composable
    functions with the `@Preview` annotation.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你感到勇敢，现在是探索不同对齐和排列方式的好时机，看看 UI 如何变化。确保使用 `@Preview` 注解预览你的可组合函数。
- en: Box
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Box
- en: So far, we've learned how to arrange children horizontally and vertically, but
    what if we want to place them on top of each other? The `Box` composable comes
    to our rescue as it allows us to stack children composables. `Box` also allows
    us to position the children relatively to it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何水平垂直排列子元素，但如果我们想将它们堆叠在一起呢？`Box` 可组合元素就派上用场了，因为它允许我们堆叠子元素可组合。`Box`
    还允许我们将子元素相对于它进行定位。
- en: 'Let''s try to build our own `Box`. We will stack two composables inside `Box`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建自己的 `Box`。我们将在 `Box` 内部堆叠两个可组合元素：
- en: One green circle, which will be created with the help of `Surface`. The `Surface`
    composable allows you to easily define a material surface with a certain shape,
    background, or elevation.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绿色圆圈，将使用 `Surface` 的帮助创建。`Surface` 可组合项允许您轻松定义具有特定形状、背景或高度的材质表面。
- en: One plus sign (`+`) added as text inside the `Text` composable, which is aligned
    in the center of its parent `Box`.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Text` 可组合项内部添加的一个加号（`+`），该可组合项与其父 `Box` 的中心对齐。
- en: 'This is what the code will look like:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的样子：
- en: '[PRE16]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Surface` composable is defined with a mandatory `content` parameter that
    accepts another composable as its inner content. We don't want to add a composable
    inside of it. Instead, we want to stack a `Text` composable on top of it, so we
    passed an empty function to the `content` parameter.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Surface` 可组合项使用一个强制性的 `content` 参数定义，该参数接受另一个可组合项作为其内部内容。我们不想在其中添加可组合项。相反，我们想在它上面堆叠一个
    `Text` 可组合项，因此我们将一个空函数传递给 `content` 参数。'
- en: 'The result is similar to the FAB we are all used to:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 结果类似于我们所有人都习惯的 FAB：
- en: '![Figure 1.19 – Exploring the Box composable'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19 – 探索 Box 可组合项'
- en: '](img/B17788_01_19.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_01_19.jpg)'
- en: Figure 1.19 – Exploring the Box composable
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 探索 Box 可组合项
- en: 'To take advantage of `Box`, you must keep the following in mind:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用 `Box`，您必须注意以下几点：
- en: The order in which composables are added within `Box` defines the order in which
    they are painted and stacked on top of each other. If you switch the order of
    `Surface` and `Text`, the `+` icon will be painted beneath the green circle making
    it invisible.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Box` 内部添加可组合项的顺序定义了它们被绘制和堆叠的顺序。如果您交换 `Surface` 和 `Text` 的顺序，`+` 图标将被绘制在绿色圆圈下方，使其变得不可见。
- en: You can align the children composables relative to the `Box` parent by passing
    different values for each of the child's alignment modifiers. That's why, apart
    from `Alignment.Center`, you can also position children composables with `CenterStart`,
    `CenterEnd`, `TopStart`, `TopCenter`, `TopEnd`, `BottomStart`, `BottomEnd`, or
    `BottomCenter`.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过为每个子项的对齐修饰符传递不同的值来相对于 `Box` 父项对齐子项可组合项。这就是为什么，除了 `Alignment.Center` 之外，您还可以使用
    `CenterStart`、`CenterEnd`、`TopStart`、`TopCenter`、`TopEnd`、`BottomStart`、`BottomEnd`
    或 `BottomCenter` 来定位子项可组合项。
- en: Now that we covered the basics, it's time to roll up our sleeves and create
    our first Compose project!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了基础知识，是时候卷起袖子创建我们的第一个 Compose 项目了！
- en: Building a Compose-based screen
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于 Compose 的屏幕
- en: Let's say we want to build an application that showcases some restaurants. We
    will build the UI with Compose and go through the steps of creating a new Compose
    project. We will then build a list item for such a restaurant and finally display
    a dummy list of such items.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要构建一个展示一些餐厅的应用程序。我们将使用 Compose 构建 UI，并逐步创建一个新的 Compose 项目。然后我们将为这样的餐厅构建一个列表项，并最终显示一个此类项目的示例列表。
- en: 'To summarize, in this section, we will build our first Compose-based application:
    a restaurant explorer app! To achieve that, we must display some restaurants,
    which we will do by covering the following topics:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们将构建我们的第一个基于 Compose 的应用程序：一个餐厅探索应用程序！为了实现这一点，我们必须显示一些餐厅，我们将通过以下主题来完成：
- en: Creating your first Compose project
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个 Compose 项目
- en: Building a restaurant element layout
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建餐厅元素布局
- en: Displaying a list of restaurants with Compose
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Compose 显示餐厅列表
- en: Now that we have a clear path, let's get started.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经明确了路径，让我们开始吧。
- en: Creating your first Compose project
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的第一个 Compose 项目
- en: 'To build a restaurant app, we have to create a new Compose-based project:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建餐厅应用程序，我们必须创建一个新的基于 Compose 的项目：
- en: 'Open Android Studio and select the **New Project** option:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Android Studio 并选择 **新建项目** 选项：
- en: '![Figure 1.20 – Starting a new project with Android Studio'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.20 – 使用 Android Studio 开始新项目'
- en: '](img/B17788_01_20.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_01_20.jpg)'
- en: Figure 1.20 – Starting a new project with Android Studio
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 使用 Android Studio 开始新项目
- en: If you already have Android Studio open, go to **File**, then **New**, and finally
    **New Project**.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经打开了 Android Studio，请转到 **文件**，然后是 **新建**，最后是 **新建项目**。
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that you have Android Studio version Arctic Fox 2020.3.1 or newer.
    If you're using a newer version though, some files might have differences in the
    generated code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您拥有 Arctic Fox 2020.3.1 或更高版本的 Android Studio。如果您使用的是较新版本，则某些文件可能生成的代码存在差异。
- en: 'In the **Phone and tablet** template section, select **Empty Compose Activity**
    and then choose **Next**:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **手机和平板** 模板部分，选择 **空 Compose 活动**，然后选择 **下一步**：
- en: '![](img/B17788_01_21.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_01_21.jpg)'
- en: Figure 1.21 – Starting a new project with Android Studio
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21 – 使用Android Studio开始新项目
- en: Next, enter some details about your application. In the `Restaurants app`. Leave
    **Kotlin** as-is for **Language** and set **Minimum SDK** to **API 21**. Then,
    click **Finish**.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入一些关于您应用程序的详细信息。在`Restaurants app`中。将**语言**保留为**Kotlin**，并将**最小SDK**设置为**API
    21**。然后，单击**完成**。
- en: Important note
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The upcoming step is an essential configuration step. It makes sure that the
    project Android Studio has configured for you the same versions of dependencies
    (from Compose, to Kotlin and other dependencies) that we use throughout the book.
    By doing so, you will be able to follow the code snippets and inspect the code
    source without any API differences.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即将进行的步骤是一个重要的配置步骤。它确保项目Android Studio为您配置的依赖项版本（从Compose到Kotlin和其他依赖项）与我们全书所使用的版本相同。通过这样做，您将能够跟随代码片段并检查代码源，而无需担心任何API差异。
- en: Inside the newly generated project, before inspecting the code, make sure that
    the generated project uses the versions of dependencies that are used throughout
    the book.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的项目中，在检查代码之前，请确保生成的项目使用了全书所使用的依赖项版本。
- en: 'To do so, first go to the project-level `build.gradle` file and inside the
    `dependencies` block, make sure that the Kotlin version is set to `1.6.10`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，首先转到项目级别的`build.gradle`文件，并在`dependencies`块内确保Kotlin版本设置为`1.6.10`：
- en: '[PRE17]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, if you''re using a newer version of Android Studio, you might
    find the Kotlin version used in this project inside the `plugins` block, like
    so:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您使用的是较新版本的Android Studio，您可能会在`plugins`块中找到本项目中使用的Kotlin版本，如下所示：
- en: '[PRE18]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you haven't already, you might need to install the 1.6.10 plugin version
    of Kotlin in Android Studio. To do that, click on the `1.6.10`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装，可能需要安装Android Studio中1.6.10插件的版本。要做到这一点，请单击`1.6.10`。
- en: 'Still in the project-level `build.gradle` file, because Compose is tied to
    the Kotlin version used in our project, make sure that the Compose version is
    set to `1.1.1` inside the `ext { }` block:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在项目级别的`build.gradle`文件中，因为Compose与我们在项目中使用的Kotlin版本相关联，请确保在`ext { }`块内将Compose版本设置为`1.1.1`：
- en: '[PRE19]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, move into the app-level `build.gradle` file. First check that the `composeOptions
    { }` block looks like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入应用级别的`build.gradle`文件。首先检查`composeOptions { }`块看起来是否如下：
- en: '[PRE20]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In some versions of Android Studio, the `composeOptions { }` block would add
    an outdated `kotlinCompilerVersion '1.x.xx'` line that should be removed.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些版本的Android Studio中，`composeOptions { }`块可能会添加一个过时的`kotlinCompilerVersion
    '1.x.xx'`行，应该将其删除。
- en: 'Finally, make sure that the `dependencies` block of the app-level `build.gradle`
    file includes the following versions for its dependencies:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保应用级别的`build.gradle`文件的`dependencies`块包含以下版本的依赖项：
- en: '[PRE21]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you had to make any changes, synchronize your project with its Gradle files
    by clicking on the **Sync your project with Gradle files** button in Android Studio
    or by pressing on the **File** menu option and then by selecting **Sync Project
    with Gradle Files**.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须进行任何更改，通过在Android Studio中单击**同步项目与Gradle文件**按钮或通过按**文件**菜单选项然后选择**同步项目与Gradle文件**来同步您的项目与Gradle文件。
- en: Now we're set. Let's return to the source code generated by Android Studio.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了。让我们回到Android Studio生成的源代码。
- en: 'And here we are – our first Compose project has been set up! Let''s check out
    the source code by navigating to the `MainActivity.kt` file. We can conclude that
    it consists of three main parts:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达了这里——我们的第一个Compose项目已经设置好了！让我们通过导航到`MainActivity.kt`文件来查看源代码。我们可以得出结论，它由三个主要部分组成：
- en: The `MainActivity` class
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainActivity`类'
- en: The `Greeting` composable function
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Greeting`可组合函数'
- en: The `DefaultPreview` composable function
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultPreview`可组合函数'
- en: 'The `MainActivity` class is where content is passed to the `setContent` method
    in the `onCreate` callback. As we know by now, we need to call `setContent` to
    set up a Compose UI and pass composable functions as our UI:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`类是将内容传递到`onCreate`回调中的`setContent`方法的地点。正如我们所知，我们需要调用`setContent`来设置Compose
    UI并传递可组合函数作为我们的UI：'
- en: '[PRE22]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The IDE template has already implemented a `Greeting` composable that is wrapped
    into a `Surface` that uses the theme's background color. But what is that `RestaurantsAppTheme`
    function that was passed as the parent composable to the `setContent` method?
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: IDE模板已经实现了一个`Greeting`可组合函数，它被包裹在一个使用主题背景色的`Surface`中。但那个作为`setContent`方法父可组合函数传递的`RestaurantsAppTheme`函数是什么？
- en: 'If you press *Ctrl* + *B* or *Command* + *B* on the function name, you will
    be taken to the `Theme.kt` file, which is where our theme is generated. `RestaurantsAppTheme`
    is a composable function that was auto-generated by the IDE as it holds the app''s
    name:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按*Ctrl* + *B*或*Command* + *B*在函数名上，你将被带到生成主题的`Theme.kt`文件，这是我们的主题生成的地方。`RestaurantsAppTheme`是一个由IDE自动生成的可组合函数，因为它包含了应用的名字：
- en: '[PRE23]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The app's theme is a wrapper over `MaterialTheme` and if we pass it to the `setContent`
    call, it allows us to reuse custom styles and color schemes defined within the
    app's theme. For it to take effect and reuse custom styles, we must pass our composables
    functions to the `content` parameter of our theme composable – in our case, in
    `MainActivity`, the `Greeting` composable wrapped in the `Surface` composable
    is passed to the `RestaurantsAppTheme` composable.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的主题是`MaterialTheme`的包装，如果我们将其传递给`setContent`调用，它允许我们在应用主题内部重用自定义样式和配色方案。为了使其生效并重用自定义样式，我们必须将我们的可组合函数传递给主题可组合的`content`参数——在我们的案例中，在`MainActivity`中，将包裹在`Surface`可组合中的`Greeting`可组合传递给`RestaurantsAppTheme`可组合。
- en: Let's go back inside the `MainActivity.kt` file to have a look at the other
    parts generated by Android studio. We can see that the `Greeting` composable displays
    text through `Text`, similar to our composable functions from the previous examples.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`MainActivity.kt`文件中，看看Android Studio生成的其他部分。我们可以看到，`Greeting`可组合通过`Text`显示文本，类似于我们之前的示例中的可组合函数。
- en: To preview the `Greeting` composable, the IDE also generated a preview composable
    for us called `DefaultPreview`, which allows us to preview the content that `MainActivity`
    displays; that is, `Greeting`. It also makes use of the theme composable to get
    the consistently themed UI.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预览`Greeting`可组合，IDE还为我们生成了一个名为`DefaultPreview`的预览可组合，它允许我们预览`MainActivity`显示的内容；即`Greeting`。它还使用了主题可组合来获取一致的主题UI。
- en: Now that we've achieved a big milestone in that we've created a Compose-based
    application, it's time to start working on our Restaurants App!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一个大里程碑，即创建了一个基于Compose的应用程序，现在是时候开始着手我们的餐厅应用了！
- en: Building a restaurant element layout
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建餐厅元素布局
- en: 'It''s time to get our hands dirty and start building the layout for a restaurant
    within the app:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手构建应用中餐厅的布局了：
- en: Create a new file by left-clicking the application package and selecting `RestaurantsScreen`
    for the name and select the type as **File**.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过左键单击应用程序包并选择`RestaurantsScreen`作为名称，然后选择类型为**文件**来创建一个新文件。
- en: 'Inside this file, let''s create a `RestaurantsScreen` composable function for
    our first Compose screen:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，让我们为我们的第一个Compose屏幕创建一个`RestaurantsScreen`可组合函数：
- en: '[PRE24]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, inside the `RestaurantsScreen.kt` file, let''s define the `RestaurantItem`
    composable, which features a `Card` composable with elevation and padding:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`RestaurantsScreen.kt`文件内部，让我们定义`RestaurantItem`可组合，它具有带有提升和填充的`Card`可组合：
- en: '[PRE25]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make sure that every import you include is part of the `androidx.compose.*`
    package. If you''re unsure what imports to include, check out the source code
    for the `RestaurantsScreen.kt` file at the following URL:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你包含的每个导入都是`androidx.compose.*`包的一部分。如果你不确定要包含哪些导入，请查看以下URL中`RestaurantsScreen.kt`文件的源代码：
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/RestaurantsScreen.kt](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/RestaurantsScreen.kt)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/RestaurantsScreen.kt](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/RestaurantsScreen.kt)'
- en: Getting back to the previous code snippet, we could say that the `Card` composable
    is similar to `Cardview` from the old View System as it allows us to beautify
    the UI piece that represents a restaurant with border or elevation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前的代码片段，我们可以这样说，`Card`可组合类似于旧视图系统中的`Cardview`，因为它允许我们通过边框或提升美化代表餐厅的UI组件。
- en: 'In our case, `Card` contains a `Row` composable whose children composables
    are centered vertically and are surrounded by some padding. We used `Row` since
    we will show some details about the restaurant in a horizontal fashion: an icon
    and some text details.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`Card` 包含一个 `Row` 组合器，其子组合器在垂直方向上居中，并且周围有一些填充。我们使用 `Row` 是因为我们将以水平方式显示一些关于餐厅的详细信息：一个图标和一些文本细节。
- en: We passed the `RestaurantIcon` and `RestaurantDetails` composables as children
    of the `Row` composable but these functions are not defined so we have compilation
    errors. For now, don't worry about the weight modifiers. Let's define the `RestaurantIcon`
    composable first!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `RestaurantIcon` 和 `RestaurantDetails` 组合器作为 `Row` 组合器的子项传递，但这些函数尚未定义，因此我们遇到了编译错误。现在，不要担心权重修饰符。让我们首先定义
    `RestaurantIcon` 组合器！
- en: 'Still inside the `RestaurantsScreen.kt` file, create another composable function
    entitled `RestaurantIcon` with the following code:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `RestaurantsScreen.kt` 文件中，创建另一个名为 `RestaurantIcon` 的组合器函数，其代码如下：
- en: '[PRE26]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `RestaurantIcon` composable sets an `ImageVector` icon to an `Image` composable
    – in our case, a predefined Material Theme icon called `Icons.Filled.Place`. It
    also sets a `contentDescription` value and adds padding on top of the modifier
    it receives.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestaurantIcon` 组合器将 `ImageVector` 图标设置到 `Image` 组合器中 - 在我们的案例中，是一个预定义的 Material
    Theme 图标，称为 `Icons.Filled.Place`。它还设置了一个 `contentDescription` 值，并在它接收到的修饰符上添加了填充。'
- en: However, the most interesting part is the fact that `RestaurantIcon` receives
    a `Modifier` as an argument from its parent `Row`. The argument it receives is
    `Modifier.weight(0.15f)`, which means that our `Row` assigns weights to each of
    its horizontally positioned children. The value – in this case, `0.15f` – means
    that this child `RestaurantIcon` will take 15% of the horizontal space from its
    parent `Row`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最有趣的部分是 `RestaurantIcon` 接收来自其父 `Row` 的 `Modifier` 作为参数。它接收到的参数是 `Modifier.weight(0.15f)`，这意味着我们的
    `Row` 为其水平定位的每个子项分配了权重。这个值 - 在这种情况下，`0.15f` - 意味着这个子 `RestaurantIcon` 将从其父 `Row`
    中占用 15% 的水平空间。
- en: 'Now, still inside the `RestaurantsScreen.kt` file, create a `RestaurantDetails`
    function that displays the restaurant''s details:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，仍然在 `RestaurantsScreen.kt` 文件中，创建一个显示餐厅详细信息的 `RestaurantDetails` 函数：
- en: '[PRE27]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similarly, `RestaurantDetails` receives a `Modifier.weight(0.85f)` modifier
    as an argument from `Row`, which will make it occupy the remaining 85% of the
    horizontal space.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`RestaurantDetails` 接收来自 `Row` 的 `Modifier.weight(0.85f)` 修饰符作为参数，这将使其占据剩余的
    85% 水平空间。
- en: The `RestaurantDetails` composable is a simple `Column` that arranges two `Text`
    composables vertically, with one being the title of the restaurant, and the other
    being its description.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestaurantDetails` 组合器是一个简单的 `Column`，垂直排列了两个 `Text` 组合器，一个是餐厅的标题，另一个是它的描述。'
- en: But what's up with `CompositionLocalProvider`? To display the description that's
    faded out in contrast to the title, we applied a `LocalContentAlpha` of `ContentAlpha.medium`.
    This way, the child `Text` with the restaurant description will be faded or grayed
    out.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `CompositionLocalProvider` 是怎么回事？为了显示与标题相比变暗的描述，我们应用了一个 `LocalContentAlpha`
    的 `ContentAlpha.medium`。这样，带有餐厅描述的子 `Text` 将被淡化或灰色显示。
- en: '`CompositionLocalProvider` allows us to pass data down to the composable hierarchy.
    In this case, we want the child `Text` to be grayed out, so we passed a `LocalContentAlpha`
    object with a `ContentAlpha.medium` value using the infix `provides` method.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompositionLocalProvider` 允许我们将数据传递到组合器层次结构中。在这种情况下，我们希望子 `Text` 被灰色显示，因此我们使用后缀
    `provides` 方法传递了一个具有 `ContentAlpha.medium` 值的 `LocalContentAlpha` 对象。'
- en: For a moment, go to `MainActivity.kt` and remove the `DefaultPreview` composable
    function as we will define our own a `@Preview` composable up next.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时转到 `MainActivity.kt` 并删除 `DefaultPreview` 组合器函数，因为我们将在下一个步骤中定义自己的 `@Preview`
    组合器。
- en: 'Go back inside the `RestaurantsScreen.kt` file, define a `@Preview` composable:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 `RestaurantsScreen.kt` 文件内部，定义一个 `@Preview` 组合器：
- en: '[PRE28]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you have chosen a different name for your app, you might need to update the
    previous snippet with the theme composable defined in the `Theme.kt` file.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为你的应用程序选择了不同的名称，你可能需要更新之前在 `Theme.kt` 文件中定义的主题组合器代码片段。
- en: 'Rebuild the project and let''s inspect the `RestaurantsScreen()` composable
    by previewing the newly created `DefaultPreview` composable, which should display
    a restaurant item:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建项目，并通过预览新创建的 `DefaultPreview` 组合器来检查 `RestaurantsScreen()` 组合器，该组合器应显示一个餐厅项目：
- en: '![](img/B17788_01_22.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_01_22.jpg)'
- en: Figure 1.22 – Previewing a restaurant item
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 – 预览餐厅项目
- en: 'Finally, go back to `MainActivity.kt` and remove the `Greeting` composable.
    Also, remove the `Surface` and `Greeting` function calls in the `setContent` method
    and replace them with `RestaurantScreen`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到 `MainActivity.kt` 文件，移除 `Greeting` 可组合组件。同时，在 `setContent` 方法中移除 `Surface`
    和 `Greeting` 函数调用，并用 `RestaurantScreen` 替换：
- en: '[PRE29]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By passing `RestaurantScreen` to our `MainActivity`'s `setContent` method, we
    ensure that the application will render the desired UI when built and run.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `RestaurantScreen` 传递给 `MainActivity` 的 `setContent` 方法，我们确保在构建和运行时应用程序将渲染所需的
    UI。
- en: Optionally, you can now **Run** the app to see the restaurant directly on your
    device or emulator.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，你现在可以**运行**应用程序，直接在你的设备或模拟器上查看餐厅。
- en: Now that we have built a layout for a restaurant, it's time to learn how to
    display more of them!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为餐厅构建了一个布局，是时候学习如何显示更多餐厅了！
- en: Displaying a list of restaurants with Compose
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Compose 显示餐厅列表
- en: 'So far, we''ve displayed a restaurant item, so it''s time to display an entire
    list of them:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经显示了一个餐厅项，现在是时候显示整个列表了：
- en: 'First, create a new class in the root package, next to `MainActivity.kt`, called
    `Restaurant.kt`. Here, we will add a `data class` called `Restaurant` and add
    the fields that we expect a restaurant to have:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在根包中创建一个新类，在 `MainActivity.kt` 旁边，命名为 `Restaurant.kt`。在这里，我们将添加一个名为 `Restaurant`
    的 `data class` 并添加我们期望餐厅拥有的字段：
- en: '[PRE30]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the same `Restaurant.kt` file, create a dummy list of `Restaurant` items,
    preferably at least 10 to fill up the entire screen:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `Restaurant.kt` 文件中，创建一个 `Restaurant` 项目的示例列表，最好至少有 10 个以填充整个屏幕：
- en: '[PRE31]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can find the pre-populated list in this book''s GitHub repository, inside
    the `Restaurant.kt` file:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到预填充的列表，位于 `Restaurant.kt` 文件中：
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/Restaurant.kt](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/Restaurant.kt).'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/Restaurant.kt](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/Restaurant.kt).'
- en: 'Go back inside the `RestaurantsScreen.kt` file and update your `RestaurantItem`
    so that it receives a `Restaurant` object as an argument, while also passing the
    restaurant''s `title` and `description` to the `RestaurantDetails` composable
    as parameters:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `RestaurantsScreen.kt` 文件，并更新你的 `RestaurantItem`，使其接收一个 `Restaurant` 对象作为参数，同时将餐厅的
    `title` 和 `description` 作为参数传递给 `RestaurantDetails` 可组合组件：
- en: '[PRE32]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have passed the restaurant''s `title` and `description` to the `RestaurantDetails`
    composable as parameters. Propagate these changes in the `RestaurantDetails` composable
    and pass the `title` into the first `Text` composable and the `description` into
    the second `Text` composable:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将餐厅的 `title` 和 `description` 作为参数传递给了 `RestaurantDetails` 可组合组件。在 `RestaurantDetails`
    可组合组件中传播这些更改，并将 `title` 传递给第一个 `Text` 可组合组件，将 `description` 传递给第二个 `Text` 可组合组件：
- en: '[PRE33]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Go back to the `RestaurantsScreen` composable and update it to display a vertical
    list of `Restaurant` objects. We already know that we can use a `Column` to achieve
    this. Then, iterate over each restaurant in `dummyRestaurants` and bind it to
    a `RestaurantItem`:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `RestaurantsScreen` 可组合组件，并更新它以显示 `Restaurant` 对象的垂直列表。我们已经知道我们可以使用 `Column`
    来实现这一点。然后，遍历 `dummyRestaurants` 中的每个餐厅并将其绑定到 `RestaurantItem`：
- en: '[PRE34]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will create a beautiful vertical list that we can preview through our `DefaultPreview`
    composable.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这样将创建一个漂亮的垂直列表，我们可以通过 `DefaultPreview` 可组合组件来预览。
- en: 'Rebuild the project to see the updated preview generated by the `DefaultPreview`
    composable:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重建项目以查看由 `DefaultPreview` 可组合组件生成的更新预览：
- en: '![Figure 1.23 – Previewing RestaurantsScreen with the Column composable'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.23 – 使用 Column 可组合组件预览 RestaurantsScreen'
- en: '](img/B17788_01_23.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_01_23.jpg]'
- en: Figure 1.23 – Previewing RestaurantsScreen with the Column composable
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23 – 使用 Column 可组合组件预览 RestaurantsScreen
- en: Alternatively, you can **Run** the app to see the restaurants directly on your
    device or emulator.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以**运行**应用程序，直接在你的设备或模拟器上查看餐厅。
- en: We've finally created our first list with Compose! It looks very nice and beautiful,
    yet it has one huge issue – it doesn't scroll! We'll address this together in
    the next section.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于用 Compose 创建了第一个列表！它看起来非常漂亮，但有一个巨大的问题 – 它不能滚动！我们将在下一节中一起解决这个问题。
- en: Exploring lists with Compose
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Compose 中的列表
- en: In the previous section, we built a Compose-based screen that features a list
    of restaurants. However, if you run the application or preview the screen in interactive
    mode, you will notice that the list doesn't scroll. This is a huge inconvenience
    that we will address in this section by adding scroll capabilities to our `Column`
    composable.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了一个基于 Compose 的屏幕，其中包含餐厅列表。然而，如果你在交互模式下运行应用程序或预览屏幕，你会注意到列表无法滚动。这是一个巨大的不便，我们将在本节中通过向我们的
    `Column` 可组合组件添加滚动功能来解决它。
- en: Next, we will specify why `Column` is suited for static content, whereas if
    the list is large and its size is dynamic or dictated by the server's response,
    we should use *lazy composables*. We will explore a variety of lazy composables
    and understand why they are better suited for large lists.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将说明为什么 `Column` 适合静态内容，而如果列表很大且其大小是动态的或由服务器响应决定的，我们应该使用 *懒加载可组合组件*。我们将探索各种懒加载可组合组件，并了解为什么它们更适合大型列表。
- en: 'To summarize, this section will cover the following topics:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本节将涵盖以下主题：
- en: Adding scrolling to the `Column` composable
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `Column` 可组合组件添加滚动
- en: Introducing lazy composables
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍懒加载可组合组件
- en: Using `LazyColumn` to display restaurants
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LazyColumn` 显示餐厅
- en: Let's start by adding scrolling capabilities to our `RestaurantsScreen` composable.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的 `RestaurantsScreen` 可组合组件添加滚动功能开始。
- en: Adding scrolling to the Column composable
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 Column 可组合组件添加滚动
- en: Our list of restaurants is long, and it can't scroll. This is a bad user experience,
    so let's fix it.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的餐厅列表很长，无法滚动。这是一个糟糕的用户体验，所以让我们来修复它。
- en: 'Let''s make the `Column` scrollable by passing a `Modifier.verticalScroll`
    modifier that receives a `ScrollState`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过传递一个接收 `ScrollState` 的 `Modifier.verticalScroll` 修饰符来使 `Column` 可滚动：
- en: '[PRE35]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We want the scrolling position to be retained across recompositions. That's
    why, by passing `rememberScrollState` to the `verticalScroll` modifier, we ensure
    that every time the UI recomposes, the scroll state is remembered and retained.
    The `rememberScrollState` persistence mechanism is similar to the `remember {
    }` block, which we used previously to retain the `TextField`'s state across recompositions.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望滚动位置在重新组合时保持不变。这就是为什么，通过将 `rememberScrollState` 传递给 `verticalScroll` 修饰符，我们确保每次
    UI 重新组合时，滚动状态都会被记住并保留。`rememberScrollState` 持久化机制类似于我们之前使用的 `remember { }` 块，用于在重新组合之间保留
    `TextField` 的状态。
- en: Now, you can **Run** the app or preview it in **Interactive mode** and check
    out the scrolling effect.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以 **运行** 应用或以 **交互模式** 预览它，并检查滚动效果。
- en: However, we have one final issue with our `Column` that is related to how `Column`
    lays and composes its elements. Let's dive into that now and try to find a better
    alternative.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有一个与 `Column` 如何布局和组合其元素相关的问题。现在让我们深入探讨这个问题，并尝试找到一个更好的替代方案。
- en: Introducing lazy composables
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍懒加载可组合组件
- en: Let's take a short break from our restaurant app and try to think of a better
    way of handling large lists. Using `Row` or `Column` for displaying long lists
    of items, or maybe a list of unknown size, can prove detrimental to your UI and
    impact your app's performance. This happens because `Row` and `Column` render
    or lay all their children out, whether they are visible or not. They are good
    for displaying static content, yet passing a large list can cause your UI to become
    laggy or even unusable.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的餐厅应用中短暂休息一下，并尝试思考处理大型列表的更好方法。使用 `Row` 或 `Column` 来显示长列表的项目，或者可能是一个未知大小的列表，可能会对你的
    UI 和应用性能产生负面影响。这是因为 `Row` 和 `Column` 会渲染或布局所有子元素，无论它们是否可见。它们适合显示静态内容，但传递一个大型列表可能会导致你的
    UI 变得卡顿，甚至无法使用。
- en: Two lazy composables called `LazyColumn` and `LazyRow` come to your rescue since
    they only compose or output those items that are currently visible on the screen,
    hence the term *lazy*. So, as you can see, they are somehow similar to the old
    `RecyclerView`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 两个名为 `LazyColumn` 和 `LazyRow` 的懒加载可组合组件将帮助你解决问题，因为它们只组合或输出屏幕上当前可见的项目，因此得名 *lazy*。所以，正如你所见，它们在某种程度上类似于旧的
    `RecyclerView`。
- en: As the only difference between `Row` and `Column` was the way children were
    laid out on the screen – horizontally or vertically – the same thing applies with
    `LazyRow` and `LazyColumn`. These lazy composables lay their children out horizontally
    or vertically and provide scrolling capabilities out of the box. As they only
    render the visible items, lazy composables are a much better fit for large lists.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“行”和“列”之间唯一的区别是儿童在屏幕上的排列方式——水平或垂直——同样的情况也适用于“LazyRow”和“LazyColumn”。这些懒加载的可组合组件会水平或垂直排列其子组件，并自带滚动功能。由于它们只渲染可见项，懒加载的可组合组件非常适合大型列表。
- en: 'Yet, lazy composables are different than the regular composables that we''ve
    used so far. That''s mainly because instead of accepting `@Composable` content,
    they expose a `LazyListScope` block:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，懒加载的可组合组件与我们迄今为止使用的常规可组合组件不同。这主要是因为它们不是接受`@Composable`内容，而是暴露一个`LazyListScope`块：
- en: '[PRE36]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `LazyListScope` DSL allows us to describe the *item* contents that we want
    to be displayed as part of the list. The most commonly used ones are `item()`
    and `items()`. Such example usage of `LazyColumn` that makes use of DSL is as
    follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyListScope` DSL允许我们描述我们想要作为列表一部分显示的*项*内容。最常用的有`item()`和`items()`。以下是一个使用DSL的`LazyColumn`示例用法：'
- en: '[PRE37]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`item()` adds a single composable element to the list, while `items()` can
    receive not only a standalone list of content such as `myLongList` but also an
    `Int`, which will add the same item multiple times.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`item()`向列表添加单个可组合元素，而`items()`不仅可以接收如`myLongList`这样的独立内容列表，还可以接收一个`Int`，这将多次添加相同的项。'
- en: 'The code that we featured previously should render a vertical list that contains
    the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示的代码应该渲染一个包含以下内容的垂直列表：
- en: A header `Text` composable
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题`Text`可组合组件
- en: A list of `MyComposable` composables that are the same size as `myLongList`
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与`myLongList`大小相同的`MyComposable`可组合组件列表
- en: Two `Text` footer composables
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个`Text`页脚可组合组件
- en: Returning from the DSL world, a noteworthy argument for the lazy composables
    is `contentPadding`, which allows you to define horizontal/vertical padding surrounding
    your list. This argument expects a `PaddingValues` object – we will use it soon;
    don't worry!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到DSL世界，懒加载的可组合组件的一个值得注意的论点是`contentPadding`，它允许你定义围绕你的列表的水平/垂直填充。这个参数期望一个`PaddingValues`对象——我们很快就会使用它；不要担心！
- en: Now, we will soon receive the restaurants from a remote server, which means
    we don't know the size of the list, so it's time to implement such a lazy composable
    in our Restaurants application as well.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们很快就会从远程服务器接收餐厅，这意味着我们不知道列表的大小，因此是时候在我们的餐厅应用程序中实现这样的懒加载可组合组件了。
- en: Using LazyColumn to display restaurants
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`LazyColumn`显示餐厅
- en: We are currently using `Column` to display our `dummyRestaurants` list. We know
    why that's not the best practice, so to optimize our UI for dynamic content, we
    will replace it with `LazyColumn` so that we can continue displaying the restaurants
    vertically.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前使用`Column`来显示我们的`dummyRestaurants`列表。我们知道这不是最佳实践，因此为了优化我们的UI以适应动态内容，我们将用`LazyColumn`替换它，这样我们就可以继续垂直显示餐厅。
- en: 'Go back to the `RestaurantsScreen.kt` file and, inside of the `RestaurantScreen`
    composable, replace the `Column` composable with `LazyColumn`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`RestaurantsScreen.kt`文件，并在`RestaurantScreen`可组合组件内部，将`Column`可组合组件替换为`LazyColumn`：
- en: '[PRE38]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We've used its DSL and specified the `items` properties that should populate
    our `LazyColumn` by passing the `dummyRestaurants` list. We obtained access to
    each item as a restaurant of type `Restaurant` and rendered it through a `RestaurantItem`
    composable.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了它的DSL，并指定了`items`属性，通过传递`dummyRestaurants`列表来填充我们的`LazyColumn`。我们获得了对每个项目的访问权限，它是一个类型为`Restaurant`的餐厅，并通过`RestaurantItem`可组合组件进行渲染。
- en: We also added additional padding through the `contentPadding` argument to our
    `LazyColumn` by passing a `PaddingValues` object where we configured the vertical
    and horizontal padding.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过`contentPadding`参数向我们的`LazyColumn`添加了额外的填充，通过传递一个配置了垂直和水平填充的`PaddingValues`对象。
- en: You can now `LazyColumn` than with `Column`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`LazyColumn`而不是`Column`。
- en: We've done it! We've built our first Compose-based app from scratch while exploring
    tons of composable functions. We've added a list that scrolls beautifully, and
    we can now be proud of the result!
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！我们在探索大量可组合函数的同时，从头开始构建了我们的第一个基于Compose的应用程序。我们添加了一个滚动优美的列表，现在我们可以为这个结果感到自豪了！
- en: Summary
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to build modern UIs on Android directly in Kotlin
    by using the Jetpack Compose toolkit. You learned how, in Compose, everything
    is a composable function and how this new declarative way of defining UIs improves
    and makes the way we build UIs much easier and less prone to bugs.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过使用Jetpack Compose工具包直接在Kotlin中构建现代Android UI。你了解到在Compose中，一切都是可组合函数，以及这种新的声明性定义UI的方式如何使构建UI的方式变得更加容易和更少出错。
- en: We learned that Compose accelerates and greatly simplifies UI development with
    the help of concise Kotlin APIs and without the need for XML or other additional
    languages. We then covered the basic concepts behind Compose and the core components
    that allow you to build UIs.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到Compose通过简洁的Kotlin API和无需XML或其他额外语言的需求，加速并极大地简化了UI开发。然后我们介绍了Compose背后的基本概念和允许你构建UI的核心组件。
- en: Finally, we saw how easy it is to build UI with Compose by creating a Compose-based
    screen that displays a list of restaurants.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何通过创建一个显示餐厅列表的基于Compose的屏幕来轻松构建UI。
- en: 'In [*Chapter 2*](B17788_02_ePub.xhtml#_idTextAnchor069), *Handling UI State
    with Jetpack ViewModel*, we will use the fundamentals we''ve learned in this chapter
    to revisit the concept of state in Compose and learn how it is represented, as
    well as how we can correctly manage it with the help of another Jetpack component:
    `ViewModel`.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B17788_02_ePub.xhtml#_idTextAnchor069) *使用Jetpack ViewModel处理UI状态*中，我们将利用本章学到的基本原理来回顾Compose中的状态概念，并学习它是如何表示的，以及我们如何借助另一个Jetpack组件：`ViewModel`来正确管理它。
- en: First, we will understand what `ViewModel` is and why such a component is needed.
    Then, by continuing working on the Restaurants application that we started in
    this chapter, we will learn how to define and lift the UI's state in our own `ViewModel`
    class.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将了解`ViewModel`是什么以及为什么需要这样的组件。然后，通过继续我们在本章开始时启动的餐厅应用程序的工作，我们将学习如何在我们的`ViewModel`类中定义和提升UI的状态。
- en: Further reading
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Exploring a library with the magnitude of Compose is nearly impossible in a
    single chapter. That''s why you should also explore other topics that are of great
    importance when building your UI with Compose:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个章节中探索Compose这样规模的库几乎是不可能的。这就是为什么你也应该探索其他在用Compose构建UI时非常重要的主题：
- en: 'We''ve briefly mentioned how Compose works with the help of a Kotlin compiler
    plugin. To better how this compiler plugin helps us define composable functions,
    check out this great article written by the official Android developer team: [https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd](https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd).'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要介绍了Compose如何与Kotlin编译器插件协同工作。为了更好地了解这个编译器插件如何帮助我们定义可组合函数，请查看由官方Android开发者团队撰写的这篇精彩文章：[https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd](https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd)。
- en: This article also covers the internals of Compose, so if you are curious about
    the execution model of Compose or what the compiler plugin does behind the scenes,
    make sure to check it out.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章还涵盖了Compose的内部机制，所以如果你对Compose的执行模型或编译器插件在幕后做了什么感到好奇，确保查看这篇文章。
- en: 'Building UIs with Compose is simple, yet Compose is a very powerful framework
    that enables you to write highly reusable UIs. To take advantage of that, every
    Composable should receive a `Modifier` object that defines how it is arranged
    inside its caller parent. See what this means by checking out this great article,
    and then try to practice a bit: [https://chris.banes.dev/always-provide-a-modifier/](https://chris.banes.dev/always-provide-a-modifier/).'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Compose构建UI简单易行，但Compose是一个非常强大的框架，它允许你编写高度可重用的UI。为了利用这一点，每个Composable都应该接收一个定义其在调用父元素内部如何排列的`Modifier`对象。通过查看这篇精彩文章了解这意味着什么，然后尝试练习一下：[https://chris.banes.dev/always-provide-a-modifier/](https://chris.banes.dev/always-provide-a-modifier/)。
- en: 'Your layout should be adaptive and flexible for devices with different screen
    sizes or forms. You can learn more about this and try experimenting a bit by looking
    at the official documentation: [https://developer.android.com/jetpack/compose/layouts/adaptive](https://developer.android.com/jetpack/compose/layouts/adaptive).'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的布局应该能够适应不同屏幕尺寸或形式的设备。你可以通过查看官方文档了解更多信息，并尝试进行一些实验：[https://developer.android.com/jetpack/compose/layouts/adaptive](https://developer.android.com/jetpack/compose/layouts/adaptive)。
