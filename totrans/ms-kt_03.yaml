- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Jetpack Compose Layout Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetpack Compose 布局基础
- en: A good UI and user experience are core to our apps. As Android developers, we
    must be keenly aware of these two areas and learn how to use the different tools
    provided for us to create UIs. Google introduced **Jetpack Compose**, a modern
    UI toolkit to help developers create intuitive UIs with ease.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的 UI 和用户体验是我们应用的核心。作为 Android 开发者，我们必须敏锐地意识到这两个领域，并学习如何使用为我们提供的不同工具来创建 UI。Google
    引入了 **Jetpack Compose**，这是一种现代的 UI 工具包，可以帮助开发者轻松地创建直观的 UI。
- en: In this chapter, we’ll look at Jetpack Compose, a declarative way of creating
    UIs for our apps. We will learn the basics of Jetpack Compose and layouts in Jetpack
    Compose.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Jetpack Compose，这是一种为我们的应用创建 UI 的声明式方法。我们将学习 Jetpack Compose 和 Jetpack
    Compose 中的布局的基础知识。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to Jetpack Compose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack Compose 简介
- en: Jetpack Compose layouts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack Compose 布局
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要下载 Android Studio Hedgehog 或更高版本（[https://developer.android.com/studio](https://developer.android.com/studio)）。
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此章节的代码在 [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree)
    找到。
- en: Introduction to Jetpack Compose
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetpack Compose 简介
- en: Over the years, Android UI development has undergone significant transformations
    with various frameworks and libraries emerging to simplify the process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，Android UI 开发经历了重大的转变，出现了各种框架和库来简化这个过程。
- en: 'Before Jetpack Compose, this is how we used to write UIs for our apps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 之前，我们通常是这样为我们的应用编写 UI 的：
- en: Views were inflated from XML layout files. XML-based views are still supported
    alongside Jetpack Compose for backward compatibility and mixed use cases where
    apps have both XML layouts and Jetpack Compose.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图是从 XML 布局文件中填充的。基于 XML 的视图仍然与 Jetpack Compose 一起支持，以实现向后兼容性和混合用例，其中应用既有 XML
    布局也有 Jetpack Compose。
- en: Themes, styles, and value resources were also defined in XML files.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题、样式和值资源也定义在 XML 文件中。
- en: For us to be able to access the views from XML files, we used view binding or
    data binding.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了能够从 XML 文件中访问视图，我们使用了视图绑定或数据绑定。
- en: This method of writing a UI required huge effort, requiring more boilerplate
    code and being error prone.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种编写 UI 的方法需要巨大的努力，需要更多的样板代码，并且容易出错。
- en: Google developed Jetpack Compose as a modern **declarative** UI toolkit. It
    allows us to create UIs with less code. Layouts created in Jetpack Compose are
    responsive to different screen sizes and orientations. It is also easier and more
    productive to write UIs in Compose. With Jetpack Compose, we can reuse components
    across our code bases. Jetpack Compose also allows us to use code from XML components
    in our composables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Google 开发了 Jetpack Compose 作为一种现代的 **声明式** UI 工具包。它允许我们用更少的代码创建 UI。在 Jetpack
    Compose 中创建的布局对不同的屏幕尺寸和方向做出响应。在 Compose 中编写 UI 也更容易、更高效。使用 Jetpack Compose，我们可以在代码库中重用组件。Jetpack
    Compose 还允许我们在 composables 中使用来自 XML 组件的代码。
- en: Jetpack Compose is entirely in Kotlin, meaning it takes advantage of the powerful
    language features that Kotlin offers. The **view system**, which was used to create
    UIs before Compose, was more procedural. We had to manage complex life cycles
    and handle any changes in state manually. Jetpack Compose is a whole other paradigm
    that uses declarative programming. We describe what the UI should be like based
    on a state. This enables us to have dynamic content and less boilerplate code
    and develop our UIs faster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 完全使用 Kotlin 编写，这意味着它利用了 Kotlin 提供的强大语言功能。在 Compose 之前，用于创建 UI
    的 **视图系统**更为过程化。我们必须管理复杂的生命周期并手动处理任何状态变化。Jetpack Compose 是一种全新的范式，它使用声明式编程。我们根据状态描述
    UI 应该是什么样的。这使得我们能够拥有动态内容，更少的样板代码，并更快地开发我们的 UI。
- en: To understand Jetpack Compose, let us first dive deep into the differences between
    the declarative and imperative approaches to writing UIs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Jetpack Compose，让我们首先深入了解声明式和命令式方法在编写 UI 之间的区别。
- en: Declarative versus imperative UIs
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式与命令式 UI
- en: In imperative UIs, we specify step by step the instructions describing how the
    UI should be built and updated. We explicitly define the sequence of operations
    to create and modify UI elements. We rely on mutable state variables to represent
    the current state of the UI. We manually update these state variables as the UI
    changes and respond to user interactions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式 UI 中，我们逐步指定描述 UI 应如何构建和更新的指令。我们明确地定义创建和修改 UI 元素的操作序列。我们依赖于可变状态变量来表示 UI
    的当前状态。我们手动更新这些状态变量，以响应 UI 的变化和用户交互。
- en: In declarative UIs, we focus on describing the desired outcome rather than specifying
    the step-by-step instructions. We define what the UI should look like based on
    the current state, and the framework handles the rest. We define the UI using
    declarative markup or code. We express the desired UI structure, layout, and behavior
    by describing the relationships between UI elements and their properties.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式 UI 中，我们专注于描述期望的结果，而不是指定逐步的指令。我们根据当前状态定义 UI 应该看起来是什么样子，框架处理其余部分。我们使用声明性标记或代码定义
    UI。我们通过描述 UI 元素及其属性之间的关系来表达期望的 UI 结构、布局和行为。
- en: The declarative approach puts more emphasis on the immutable state, where the
    UI state is represented by immutable data objects. Instead of directly mutating
    the state, we create new instances of the data objects to reflect the desired
    changes in the UI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式方法更强调不可变状态，其中 UI 状态由不可变数据对象表示。我们不是直接修改状态，而是创建数据对象的新实例来反映 UI 中期望的变化。
- en: In a declarative UI, the framework takes care of updating the UI based on changes
    in the application state. We specify the relationships between the UI and the
    underlying state, and the framework automatically updates the UI to reflect those
    changes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式 UI 中，框架负责根据应用程序状态的变化更新 UI。我们指定 UI 和底层状态之间的关系，框架自动更新 UI 以反映这些变化。
- en: 'Now that we understand both imperative and declarative approaches, let’s look
    at an example of each. Let’s create a simple UI for a counter using both the declarative
    UI in Jetpack Compose (Kotlin) and the imperative UI in XML (Android XML layout).
    The example will showcase the differences in syntax and the approach between the
    two. The Jetpack Compose version looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了命令式和声明式方法，让我们看看每个方法的示例。让我们创建一个简单的 UI，用于计数器，使用 Jetpack Compose（Kotlin）中的声明式
    UI 和 XML（Android XML 布局）中的命令式 UI。示例将展示两种方法在语法和方法上的差异。Jetpack Compose 版本如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we have a `MyApp` composable function that defines
    the UI for the app. The UI is defined in a declarative manner, by using composables
    to define the UI and handling state changes using the remember composable. The
    UI is defined using a functional approach. Also, we can see that the UI is defined
    in a more concise manner.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个 `MyApp` 可组合函数，它定义了应用程序的 UI。UI 是通过使用可组合项来定义的，并通过 `remember` 可组合项处理状态变化。UI
    是使用函数式方法定义的。我们还可以看到 UI 是以更简洁的方式定义的。
- en: 'With the imperative approach, we must first create the XML UI, as shown in
    the following code block:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令式方法，我们必须首先创建 XML UI，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the layout file created, we can now create the activity class, which will
    inflate the layout file and handle the button click:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建布局文件后，我们现在可以创建活动类，该类将填充布局文件并处理按钮点击：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the XML layout is inflated in the `onCreate` method of the
    `MainActivity` class, and UI elements are accessed and manipulated programmatically.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，XML 布局是在 `MainActivity` 类的 `onCreate` 方法中填充的，UI 元素是通过程序方式访问和操作的。
- en: In the preceding examples, the Jetpack Compose code is written in Kotlin and
    provides a more declarative approach, defining the UI in a functional manner.
    The XML layout, on the other hand, is written imperatively in XML, specifying
    the UI structure and properties in a more step-by-step manner using XML and interacting
    with them imperatively in Kotlin code. Jetpack Compose allows for a more concise
    and expressive representation of the UI using a declarative syntax.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，Jetpack Compose 代码是用 Kotlin 编写的，提供了一种更声明式的方法，通过函数式方式定义 UI。另一方面，XML 布局则是用
    XML 命令式编写的，以更逐步的方式指定 UI 结构和属性，并在 Kotlin 代码中命令式地与之交互。Jetpack Compose 允许使用声明式语法更简洁、更富有表现力地表示
    UI。
- en: Now that we have a clear understanding of the imperative and declarative ways
    of writing UIs, in the next section, we will be diving deep into the building
    blocks of Jetpack Compose.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地理解了命令式和声明式编写UI的方式，在下一节中，我们将深入探讨Jetpack Compose的构建块。
- en: Composable functions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合函数
- en: 'As shown in *Figure 3**.1*, composable functions are the main building blocks
    of Jetpack Compose:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.1*所示，组合函数是Jetpack Compose的主要构建块：
- en: '![Figure 3.1 – Compose UI](img/B19779_03_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Compose UI](img/B19779_03_01.jpg)'
- en: Figure 3.1 – Compose UI
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Compose UI
- en: A composable function describes how to render a UI. This function must be annotated
    with the `@Composable` function. When you annotate a function with this annotation,
    it means that the function describes how to compose a specific part of the UI.
    Composable functions are meant to be **reusable**. They can be called multiple
    times while the UI is active. Whenever the state of the composable changes, it
    goes through a process of recomposition, which enables the UI to display the latest
    state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数描述了如何渲染UI。这个函数必须使用`@Composable`注解。当你用这个注解标记一个函数时，这意味着该函数描述了如何组合UI的特定部分。组合函数旨在**可重用**。它们可以在UI活动时多次调用。每当组合函数的状态发生变化时，它都会经历一个重新组合的过程，这使得UI能够显示最新的状态。
- en: Composable functions are **pure functions**, meaning they don’t have any side
    effects. They produce the same output when called several times with the same
    input. This ensures the functions are predictable and efficient in dispatching
    updates to the UI. However, there are exceptions, for example, launching a coroutine
    within a composable of calling external methods that do have side-effects, which
    should be avoided or handled carefully.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数是**纯函数**，这意味着它们没有任何副作用。它们在多次以相同输入调用时会产生相同的输出。这确保了函数的可预测性和在派发更新到UI时的效率。然而，也有一些例外，例如，在组合函数中启动协程或调用具有副作用的第三方方法，这些应该避免或谨慎处理。
- en: Smaller composable functions can be combined to build complex UIs. You can reuse
    and nest composables inside other composables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 较小的组合函数可以组合起来构建复杂的UI。你可以在其他组合函数内部重用和嵌套组合函数。
- en: 'Let’s look at an example of a composable function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个组合函数的例子：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, the `PacktPublishing` function is annotated with
    the `@Composable` annotation. The function takes a parameter, `bookName`, which
    is a `String`. Inside the function, we have another composable from the Material
    Design library. The composable renders some text to our UI.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`PacktPublishing`函数被`@Composable`注解标记。该函数接受一个参数`bookName`，它是一个`String`。在函数内部，我们使用了来自Material
    Design库的另一个组合函数。这个组合函数将一些文本渲染到我们的UI上。
- en: When designing our UIs, we usually want to see how the UIs look without running
    our app. Luckily, we have **previews**, which visualize our composable functions.
    We will be learning about them in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计我们的UI时，我们通常想要在不运行我们的应用的情况下查看UI的外观。幸运的是，我们有**预览**，它可视化我们的组合函数。我们将在下一节中学习它们。
- en: Previews
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预览
- en: In Jetpack Compose, we have the `@Preview` annotation, which generates a preview
    of our composable function or a group of Compose components inside Android Studio.
    It has an interactive mode to allow us to interact with our Compose functions.
    This gives us a way to quickly visualize our designs and easily make changes when
    needed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中，我们有`@Preview`注解，它可以在Android Studio中生成组合函数或一组Compose组件的预览。它有一个交互模式，允许我们与Compose函数交互。这为我们提供了一个快速可视化设计并在需要时轻松修改设计的方法。
- en: 'This is how our `PacktPublishing` composable function would look like with
    a preview:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`PacktPublishing`组合函数预览的样子：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have used the `@Preview` annotation to indicate that we want to build a preview
    for this function. Additionally, we have set the `showBackground` parameter to
    `true`, which adds a white background to our preview. We have named the function
    with the `Preview` suffix. The preview is also a composable function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`@Preview`注解来表示我们想要为这个函数构建一个预览。此外，我们将`showBackground`参数设置为`true`，这为我们的预览添加了一个白色背景。我们使用`Preview`后缀命名了函数。预览也是一个组合函数。
- en: 'To be able to see the preview, you need to be in the **split or design mode**
    in your editor. These options are normally at the top right of Android Studio.
    We also need to do a build for Android Studio to generate a preview, which will
    look as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看预览，您需要在您的编辑器中的**拆分或设计模式**下。这些选项通常位于Android Studio的右上角。我们还需要为Android Studio构建一次，以生成预览，其外观如下：
- en: '![Figure 3.2 – Text preview](img/B19779_03_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 文本预览](img/B19779_03_02.jpg)'
- en: Figure 3.2 – Text preview
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 文本预览
- en: As seen in *Figure 3**.2*, we have a text that displays the string that we passed
    to the function. The preview also has a white background and its name at the top
    left.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 3**.2* 所示，我们有一个显示我们传递给函数的字符串的文本。预览还有一个白色背景，其名称位于左上角。
- en: We can show previews for both dark and light color schemes. We can also configure
    properties such as the devices and preview windows to be applied.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为深色和浅色主题方案提供预览。我们还可以配置要应用的设备预览窗口等属性。
- en: Previews are great for quick iterations while designing UIs. However, they are
    not a replacement for actual device/emulator testing, particularly for things
    such as animations, interactions, or dynamic data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 预览对于在设计 UI 时进行快速迭代非常有用。然而，它们不能替代实际的设备/模拟器测试，尤其是对于动画、交互或动态数据等事物。
- en: With an understanding of what previews are and how to create them, let us look
    into one more Compose feature, **modifiers**, in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了预览是什么以及如何创建它们之后，让我们在下一节中探讨 Compose 的另一个功能，**修饰符**。
- en: Modifiers
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修饰符
- en: 'Modifiers allow us to decorate our composable functions by enabling the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符允许我们通过启用以下功能来装饰我们的可组合函数：
- en: Change composables’ size, behavior, and appearance
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变可组合组件的大小、行为和外观
- en: Add more information
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多信息
- en: Process user input
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: Add interactions such as clicks and ripple effects
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加交互，如点击和涟漪效果
- en: 'With modifiers, we can change various aspects of our composable, such as size,
    padding, color, and shape. Most Jetpack Compose components from the library allow
    us to provide a modifier as a parameter. For example, if we need to provide padding
    to our preview text, we will have the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修饰符，我们可以改变我们可组合组件的各个方面，如大小、填充、颜色和形状。大多数来自库的 Jetpack Compose 组件都允许我们将修饰符作为参数提供。例如，如果我们需要向我们的预览文本提供填充，我们将有以下内容：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have added the padding modifier to the `Text` composable. This will add `16.dp``Text`
    composable. `16.dp` is a **density-independent** pixel unit in Jetpack Compose.
    This means it will remain consistent and adjust properly to different screen densities.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将填充修饰符添加到 `Text` 可组合组件中。这将向 `Text` 可组合组件添加 `16.dp` 的填充。`16.dp` 是 Jetpack
    Compose 中的 **密度无关** 像素单位。这意味着它将保持一致，并适当地调整到不同的屏幕密度。
- en: 'We can chain the different modifier functions in one composable. When chaining
    modifiers, the order of application is crucial. If we don’t achieve the desired
    result, we need to double-check the order. Let’s observe this concept in practice:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个可组合组件中链式调用不同的修饰符函数。当链式调用修饰符时，应用顺序至关重要。如果我们没有达到预期的结果，我们需要仔细检查顺序。让我们通过实际操作来观察这个概念：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have added two more modifiers. The first is the `fillMaxWidth` modifier,
    which is added to the text composable. This will make the text composable take
    the full width of the parent. The other one is the background modifier to the
    `Text` composable. This will add a background color to the text composable. The
    preview for our text will look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加了两个新的修饰符。第一个是 `fillMaxWidth` 修饰符，它被添加到文本可组合组件中。这将使文本可组合组件占据父组件的全部宽度。另一个是添加到
    `Text` 可组合组件的背景修饰符。这将向文本可组合组件添加背景颜色。我们的文本预览将如下所示：
- en: '![Figure 3.3 – Text modifier preview](img/B19779_03_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 文本修饰符预览](img/B19779_03_03.jpg)'
- en: Figure 3.3 – Text modifier preview
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 文本修饰符预览
- en: As seen in the preceding screenshot, the text now occupies the whole width of
    the device and has a green background. It also has a padding of `16dp` all around.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，文本现在占据了设备的整个宽度，并具有绿色背景。它周围还有 `16dp` 的填充。
- en: Modifiers do not modify the original composable. They return a new, modified
    instance. This ensures our composable remains unchanged and immutable. Immutability,
    a fundamental principle in functional programming, ensures that the state remains
    unchanged, simplifying state management and reducing side effects. This approach
    enhances predictability and readability by adhering to the principles of referential
    transparency. The ability to compose functions, exemplified by chaining modifier
    functions, facilitates a concise and readable expression of complex UI behavior
    without altering the original composable. In addition to using the existing modifiers,
    we can also create our own modifiers when needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符不会修改原始的可组合元素。它们返回一个新的、修改后的实例。这确保我们的可组合元素保持不变和不可变。不可变性是函数式编程的一个基本原则，它确保状态保持不变，简化了状态管理并减少了副作用。这种方法通过遵循引用透明性的原则，增强了可预测性和可读性。通过链式修饰符函数来组合函数的能力，使得复杂
    UI 行为的简洁和可读表达成为可能，而不会改变原始的可组合元素。除了使用现有的修饰符之外，我们还可以在需要时创建自己的修饰符。
- en: Now that you have an understanding of what modifiers are, we are going to build
    on that knowledge by learning about Jetpack Compose layouts in the next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了修饰符是什么，我们将在此基础上学习下一节中关于 Jetpack Compose 布局的内容。
- en: Jetpack Compose layouts
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetpack Compose 布局
- en: Jetpack Compose has a variety of pre-built layouts for us to use. Before looking
    at the different layouts present, let us first understand how Jetpack Compose
    transforms state into UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 提供了多种预构建的布局供我们使用。在查看不同的布局之前，让我们首先了解 Jetpack Compose 如何将状态转换为
    UI。
- en: '![Figure 3.4 – How Compose transforms state into UI](img/B19779_03_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Compose 如何将状态转换为 UI](img/B19779_03_04.jpg)'
- en: Figure 3.4 – How Compose transforms state into UI
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Compose 如何将状态转换为 UI
- en: 'From the preceding diagram, we can see that our state is transformed into a
    UI in the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以看到我们的状态在以下步骤中转换为 UI：
- en: '**Composition**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组合**'
- en: This is the initial phase. The Compose compiler creates a tree of UI elements.
    Each element is a function that represents a UI element. Compose then calls the
    functions to create the UI tree. The composition step is responsible for determining
    which composables need updates and which ones can be reused. This happens by comparing
    a previous tree of composables with the new tree and only updating the ones that
    have changed. This makes this step very efficient as only elements with updates
    are updated.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是初始阶段。Compose 编译器创建一个 UI 元素树。每个元素都是一个表示 UI 元素的函数。然后 Compose 调用这些函数来创建 UI 树。组合步骤负责确定哪些可组合元素需要更新以及哪些可以被重用。这是通过比较先前可组合元素的树和新的树，并且只更新那些已更改的元素来实现的。这使得这一步骤非常高效，因为只有带有更新的元素才会被更新。
- en: '**Layout**'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**布局**'
- en: This step happens after the composition phase. Here, the Compose compiler takes
    the tree generated in the composition phase and determines its size, position,
    and layout. Each composable is measured and positioned within the layout based
    on its parent and any constraints set. This phase is responsible for determining
    the final position and size of each UI element on the screen. It is also responsible
    for creating the final layout tree used in the drawing phase.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个步骤发生在组合阶段之后。在这里，Compose 编译器将组合阶段生成的树确定其大小、位置和布局。每个可组合元素根据其父元素和任何设置的约束在布局中进行测量和定位。这个阶段负责确定屏幕上每个
    UI 元素的最终位置和大小。它还负责创建绘图阶段使用的最终布局树。
- en: '**Drawing**'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绘图**'
- en: This is the last phase of transforming our UI to state. In this phase, the Compose
    compiler takes the final layout tree created in the layout phase and uses it to
    draw the elements on the screen. This is done by walking through the tree and
    issuing draw commands to the underlying graphics system. This phase is responsible
    for rendering the final UI on the screen.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是将我们的 UI 转换为状态的最后阶段。在这个阶段，Compose 编译器将布局阶段创建的最终布局树用于在屏幕上绘制元素。这是通过遍历树并向底层图形系统发出绘制命令来完成的。这个阶段负责在屏幕上渲染最终的
    UI。
- en: These three phases work together to create our UI in Jetpack Compose. The composition
    phase builds a tree of composables, the layout phase positions and sizes them,
    and the drawing phase renders them on the screen. This entire process is optimized,
    performant, and efficient, allowing for fast and smooth UI rendering in even complex
    UIs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个阶段共同作用，在 Jetpack Compose 中创建我们的 UI。组合阶段构建一个可组合组件树，布局阶段定位和调整它们的大小，绘制阶段在屏幕上渲染它们。整个过程经过优化，性能良好，效率高，即使在复杂的
    UI 中也能实现快速和流畅的 UI 渲染。
- en: Now that we understand how the Compose compiler renders our UI, let us see the
    layouts that are in Compose.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Compose 编译器如何渲染我们的 UI，让我们看看 Compose 中的布局。
- en: 'Jetpack Compose offers the following layouts out of the box:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 默认提供以下布局：
- en: '`Column`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column`'
- en: '`Row`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Row`'
- en: '`Box`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Box`'
- en: Lists
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: We are going to look at each of these layouts in detail in the next subsections.
    To begin with, let us look the `Column` layout.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中详细查看这些布局。首先，让我们看看 `Column` 布局。
- en: Column
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列
- en: 'We use `Column` when we want to organize items vertically. An example of the
    use of `Column` is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Column` 来垂直组织项目。`Column` 的一个使用示例如下：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we have created `Column` with three text elements. Adding
    a preview for this generates the following UI for us:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了包含三个文本元素的 `Column`。为这个添加预览为我们生成了以下 UI：
- en: '![Figure 3.5 – Column preview](img/B19779_03_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 列预览](img/B19779_03_05.jpg)'
- en: Figure 3.5 – Column preview
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 列预览
- en: 'As seen from the preceding screenshot, the design is basic. We are going to
    polish it up a bit by using modifiers since Jetpack Compose also provides support
    for modifiers in these layouts. Let us add these changes to our column:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，设计是基本的。我们将通过使用修饰符来对其进行一些润色，因为 Jetpack Compose 也为这些布局提供了对修饰符的支持。让我们将这些更改添加到我们的
    `Column` 中：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have added a `Modifier` to our `Column`. In the modifier parameter,
    we specify the `fillMaxSize` modifier, which makes our column fill the available
    space within the parent. This is helpful for building full-view screens for our
    UIs. We have also added padding of `16.dp` to our column.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向我们的 `Column` 添加了一个 `Modifier`。在修饰符参数中，我们指定了 `fillMaxSize` 修饰符，这使得我们的列填充父元素内的可用空间。这对于构建全屏
    UI 非常有帮助。我们还为我们的列添加了 `16.dp` 的填充。
- en: 'Additionally, we have specified two more parameters for our column. One is
    `verticalArrangement`, which we use to specify the vertical arrangement of the
    children of this view. In this case, we specify `Arrangement.Center`, which places
    all the children of our `Column` vertically at the center. The other parameter
    is `horizontalAlignment`, which is the horizontal alignment of the children of
    the layout. In this case, we specify the value to be `Alignment.CenterHorizontally`,
    which will align all the children at the center horizontally. Our preview with
    the preceding changes will look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还为我们的 `Column` 指定了两个额外的参数。一个是 `verticalArrangement`，我们用它来指定此视图子项的垂直排列。在这种情况下，我们指定
    `Arrangement.Center`，它将我们的 `Column` 的所有子项垂直居中。另一个参数是 `horizontalAlignment`，它是布局子项的水平对齐方式。在这种情况下，我们指定值为
    `Alignment.CenterHorizontally`，这将使所有子项水平居中。我们的预览经过前面的更改将看起来如下：
- en: '![Figure 3.6 – Column modifiers preview](img/B19779_03_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 列修饰符预览](img/B19779_03_06.jpg)'
- en: Figure 3.6 – Column modifiers preview
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 列修饰符预览
- en: From the preceding screenshot, we can now see our column occupies the whole
    screen and all the text elements are centered vertically and horizontally within
    the parent.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个截图，我们现在可以看到我们的列占据了整个屏幕，并且所有文本元素都在父元素内水平和垂直居中。
- en: Let us now learn about the `Row` composable in the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在学习下一节中的 `Row` 可组合组件。
- en: Row
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行
- en: 'We use `Row` when we want to organize items horizontally. An example of the
    use of `Row` is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要水平组织项目时，我们使用 `Row`。`Row` 的一个使用示例如下：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, the `Row` composable is used to display three text elements
    horizontally in a row. The preview for this will look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Row` 可组合组件被用来在一行中水平显示三个文本元素。这个预览看起来如下：
- en: '![Figure 3.7 – Row preview](img/B19779_03_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 行预览](img/B19779_03_07.jpg)'
- en: Figure 3.7 – Row preview
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 行预览
- en: 'The text elements are all arranged next to each other in a horizontal row.
    `Row`, like the composable, supports the addition of modifiers. Let us modify
    our `Row` to look as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 文本元素都排列在水平行中相邻。`Row`，就像可组合组件一样，支持添加修饰符。让我们将我们的 `Row` 修改如下：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we have added modifiers to the `Row` composable. The
    `fillMaxSize` modifier makes the row fill the entire available space. The padding
    modifier adds padding to the `Row`. The `verticalAlignment` and `horizontalArrangement`
    modifiers are used to align the children of the `Row` vertically and horizontally,
    respectively. Notice that for the `horizontalArrangement` modifier, we use the
    `Arrangement.SpaceEvenly` option. This makes sure each of the children occupies
    equal space in the parent. The preview for this looks as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为 `Row` 组合器添加了修饰符。`fillMaxSize` 修饰符使行填充整个可用空间。`padding` 修饰符为 `Row`
    添加填充。`verticalAlignment` 和 `horizontalArrangement` 修饰符分别用于垂直和水平对齐 `Row` 的子元素。注意，对于
    `horizontalArrangement` 修饰符，我们使用了 `Arrangement.SpaceEvenly` 选项。这确保每个子元素在父元素中占据相等的空间。这个预览看起来如下：
- en: '![Figure 3.8 – Row modifiers preview](img/B19779_03_08.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 行修饰符预览](img/B19779_03_08.jpg)'
- en: Figure 3.8 – Row modifiers preview
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 行修饰符预览
- en: As seen in *Figure 3**.8*, the row occupies the whole screen, and the text elements
    are evenly spaced within the screen width.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 3**.8* 所见，行占据了整个屏幕，文本元素在屏幕宽度内均匀分布。
- en: In the next section, we will be learning about the `Box` layout.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于 `Box` 布局的内容。
- en: Box
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 盒子
- en: 'The `Box` layout allows us to position child elements in a flexible way using
    the X and Y coordinates. Let us see a code example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box` 布局允许我们使用 X 和 Y 坐标以灵活的方式定位子元素。让我们看看一个代码示例：'
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we have a `Box` composable that has an `Icon` and `Text`
    composable as its children. We have set the size of the `Box` composable to `100.dp`
    and the `Icon` composable to `80.dp`. The text and icon composables are placed
    in the center of the `Box` composable using the `contentAlignment` parameter.
    They are placed in the center of the `Box` composable because we have specified
    the `contentAlignment` parameter as `Alignment.Center`. They are also stacked
    on top of each other because the `Box` composable is a layout composable that
    stacks its children on top of each other. The preview for our `Box` composable
    looks as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个 `Box` 组合器，它有一个 `Icon` 和 `Text` 组合器作为其子元素。我们将 `Box` 组合器的大小设置为 `100.dp`，将
    `Icon` 组合器的大小设置为 `80.dp`。使用 `contentAlignment` 参数将文本和图标组合器放置在 `Box` 组合器的中心。它们被放置在
    `Box` 组合器的中心，因为我们已将 `contentAlignment` 参数指定为 `Alignment.Center`。它们也堆叠在一起，因为 `Box`
    组合器是一个布局组合器，它将子元素堆叠在其上方。我们的 `Box` 组合器的预览如下：
- en: '![Figure 3.9 – Box preview](img/B19779_03_09.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 盒子预览](img/B19779_03_09.jpg)'
- en: Figure 3.9 – Box preview
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 盒子预览
- en: As we can see from *Figure 3**.9*, the notification icon and the text are stacked
    together. The `Box` composable enables us to achieve this and much more.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从 *图 3**.9* 中所见，通知图标和文本是堆叠在一起的。`Box` 组合器使我们能够实现这一点以及更多功能。
- en: Now let us look at how to display lists in Jetpack Compose in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中看看如何在 Jetpack Compose 中显示列表。
- en: Lists
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: As Android developers, we need to make apps that display lists of items. It
    can be a list of movies, orders, songs, or books. So, how do we do that in Compose?
    The good news for us is that Jetpack Compose makes it easier for us to do so.
    Compose provides the `LazyColumn` and `LazyRow` components, which can be used
    to display a list of items. These components are very efficient and performant.
    They only render the items that are visible on the screen, rather than rendering
    all the items at once. `LazyColumn` displays items vertically, while `LazyRow`
    displays items horizontally. `LazyColumn` and `LazyRow` are normally optimized
    for large datasets and at times are not suitable for all use cases. These composable
    functions allow you to define the contents of the list as a function that returns
    a single item, and then Compose will automatically generate and render the UI
    elements for each item in the list as they become visible on the screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Android 开发者，我们需要制作显示项目列表的应用程序。这可能是一份电影列表、订单、歌曲或书籍列表。那么，我们在 Compose 中如何做到这一点呢？对我们来说，好消息是
    Jetpack Compose 使我们更容易做到这一点。Compose 提供了 `LazyColumn` 和 `LazyRow` 组件，可以用来显示项目列表。这些组件非常高效和性能良好。它们只渲染屏幕上可见的项目，而不是一次性渲染所有项目。`LazyColumn`
    垂直显示项目，而 `LazyRow` 水平显示项目。`LazyColumn` 和 `LazyRow` 通常针对大型数据集进行优化，有时并不适用于所有用例。这些组合器函数允许您定义列表的内容为一个返回单个项目的函数，然后
    Compose 将自动生成并渲染屏幕上可见的每个项目的 UI 元素。
- en: 'Let’s see an example of `LazyColumn`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `LazyColumn` 的一个示例：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have `LazyColumn` with 100 items. Each item is a `Text` composable. The
    preview for this looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有包含100个项目的`LazyColumn`。每个项目都是一个`Text`可组合元素。这个预览看起来如下：
- en: '![Figure 3.10 – LazyColumn preview](img/B19779_03_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – LazyColumn预览](img/B19779_03_10.jpg)'
- en: Figure 3.10 – LazyColumn preview
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – LazyColumn预览
- en: We can see from *Figure 3**.10* that we now have a list of items that scroll
    vertically. As mentioned, it only shows the items that can fit on the screen.
    If we use interactive mode on our preview, we will be able to scroll through to
    the bottom of the list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图3.10*中我们可以看到，我们现在有一个垂直滚动的项目列表。如前所述，它只显示可以适应屏幕的项目。如果我们使用预览的交互模式，我们将能够滚动到列表的底部。
- en: 'Let us see the `LazyRow` equivalent as well:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`LazyRow`的等效代码：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have `LazyRow` with 100 items. Each item is a `Text` composable. The preview
    for this looks as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有包含100个项目的`LazyRow`。每个项目都是一个`Text`可组合元素。这个预览看起来如下：
- en: '![Figure 3.11 – LazyRow preview](img/B19779_03_11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – LazyRow预览](img/B19779_03_11.jpg)'
- en: Figure 3.11 – LazyRow preview
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – LazyRow预览
- en: We can see from *Figure 3**.11* that we now have a list of items that scroll
    horizontally. Similar to `LazyColumn`, it only shows the items that can fit on
    the screen. If we use interactive mode on our preview, we can scroll through to
    the end of the list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图3.11*中我们可以看到，我们现在有一个水平滚动的项目列表。与`LazyColumn`类似，它只显示可以适应屏幕的项目。如果我们使用预览的交互模式，我们可以滚动到列表的末尾。
- en: 'We also have two more types of list layouts, `LazyVerticalGrid` and `LazyHorizontalGrid`.
    The two layouts are part of the lazy grids and help us to arrange our content
    in grids. They’re commonly used in applications such as galleries, movies, and
    spreadsheets. `LazyVerticalGrid` creates a vertical list of items in a grid. Let
    us look at the sample code for `LazyVerticalGrid`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两种更多的列表布局类型，`LazyVerticalGrid`和`LazyHorizontalGrid`。这两种布局是懒加载网格的一部分，帮助我们以网格的形式排列内容。它们通常用于如画廊、电影和电子表格等应用程序。`LazyVerticalGrid`在网格中创建一个垂直的项目列表。让我们看看`LazyVerticalGrid`的示例代码：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have used the `LazyVerticalGrid` composable. We pass our modifiers as before.
    Notice we also have the `columns` parameter. This parameter allows us to specify
    the number of columns and how items are arranged within the columns. In this case,
    we specified `GridCells` to be `Fixed`. This means the grid will have a fixed
    number of columns or rows in it is a `LazyHorizontalGrid`. We also have the `Adaptive`
    type, which defines a grid with as many rows or columns as possible with the condition
    that every cell has a minimum size and all extra space is distributed evenly.
    Our preview will look as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`LazyVerticalGrid`可组合元素。我们像之前一样传递我们的修饰符。注意我们还有一个`columns`参数。此参数允许我们指定列数以及项目如何在列中排列。在这种情况下，我们指定`GridCells`为`Fixed`。这意味着网格将具有固定数量的列或行，如果是`LazyHorizontalGrid`。我们还有`Adaptive`类型，它定义了一个网格，具有尽可能多的行或列，条件是每个单元格都有最小尺寸，所有额外空间都均匀分布。我们的预览将如下所示：
- en: '![Figure 3.12 – LazyVerticalGrid preview](img/B19779_03_12.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – LazyVerticalGrid预览](img/B19779_03_12.jpg)'
- en: Figure 3.12 – LazyVerticalGrid preview
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – LazyVerticalGrid预览
- en: 'We have our text elements in a grid of three columns. We are now able to scroll
    through the items vertically. Let us now look at the code for `LazyHorizontalGrid`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文本元素放置在三个列的网格中。我们现在可以垂直滚动这些项目。现在让我们看看`LazyHorizontalGrid`的代码：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code is similar to that for `LazyVerticalGrid`. The only difference is
    that we are using `LazyHorizontalGrid` and instead of columns, we are now passing
    `rows` to describe how the cells will form the rows. The preview will look like
    this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与`LazyVerticalGrid`的代码类似。唯一的区别是我们现在使用`LazyHorizontalGrid`，而不是列，我们现在传递`rows`来描述单元格将如何形成行。预览将如下所示：
- en: '![Figure 3.13 – LazyHorizontalGrid preview](img/B19779_03_13.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – LazyHorizontalGrid预览](img/B19779_03_13.jpg)'
- en: Figure 3.13 – LazyHorizontalGrid preview
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – LazyHorizontalGrid预览
- en: As seen in *Figure 3**.13*, we now have three rows on the entire screen, and
    we can also scroll through them horizontally.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.13*所示，我们现在在整个屏幕上有三行，我们也可以水平滚动它们。
- en: In addition to `LazyVerticalGrid` and `LazyHorizontalGrid`, we also have `LazyVerticalStaggeredGrid`
    and `LazyHorizontalStaggeredGrid`, which are remarkably similar; the only difference
    is that they adapt to the children’s height and width, respectively, meaning they
    all do not have uniform height or width.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`LazyVerticalGrid`和`LazyHorizontalGrid`，我们还有`LazyVerticalStaggeredGrid`和`LazyHorizontalStaggeredGrid`，它们非常相似；唯一的区别是它们分别适应子元素的高度和宽度，这意味着它们都没有统一的高度或宽度。
- en: Let us now have a look at `ConstraintLayout` in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看下一节中的`ConstraintLayout`。
- en: ConstraintLayout
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConstraintLayout
- en: This layout enables us to create responsive layouts. We can create complex layouts
    with relative positioning. `ConstraintLayout` uses chains, barriers, and guidelines
    to position child elements relative to each other.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此布局使我们能够创建响应式布局。我们可以使用相对定位创建复杂布局。`ConstraintLayout`使用链、屏障和指南来定位子元素相对于彼此的位置。
- en: 'It comes as a separate dependency, and we need to add it to our project. To
    add it, let us add this dependency to our app `build.gradle` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为一个单独的依赖项提供，我们需要将其添加到我们的项目中。为了添加它，让我们将此依赖项添加到我们的应用程序`build.gradle`文件中：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This adds the Jetpack Compose dependency to our project. The layout code for
    the constraint layout is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将Jetpack Compose依赖项添加到我们的项目中。约束布局的布局代码如下：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we used the `ConstraintLayout` composable function to
    create `ConstraintLayout`. Inside `ConstraintLayout`, we used the `createRefs()`
    function to create two references, one for the icon and one for the text. We then
    used the `constrainAs()` function to constrain the icon and the text to the parent.
    We used the `linkTo()` function to link the icon and the text to the parent. In
    this case, we have linked the icon to the start, top, and bottom of the parent.
    For the text, we have linked it to the top and bottom of the parent. We have additionally
    linked the start of the text to the end of the icon. Our preview will look as
    follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`ConstraintLayout`可组合函数来创建`ConstraintLayout`。在`ConstraintLayout`内部，我们使用了`createRefs()`函数创建了两个引用，一个用于图标，一个用于文本。然后我们使用了`constrainAs()`函数将图标和文本约束到父元素上。我们使用了`linkTo()`函数将图标和文本链接到父元素。在这种情况下，我们将图标链接到父元素的起始、顶部和底部。对于文本，我们将其链接到父元素的顶部和底部。我们还额外将文本的起始链接到图标的结束。我们的预览将如下所示：
- en: '![Figure 3.14 – ConstraintLayout preview](img/B19779_03_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – ConstraintLayout预览](img/B19779_03_14.jpg)'
- en: Figure 3.14 – ConstraintLayout preview
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – ConstraintLayout预览
- en: From the preceding screenshot, we can see that we have an icon and text to the
    right of the icon. `ConstraintLayout` helps in positioning items relative to the
    parent or each other.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，我们可以看到图标右侧有一个图标和文本。`ConstraintLayout`有助于定位元素相对于父元素或彼此的位置。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have introduced ourselves to Jetpack Compose, a declarative
    way of creating UIs for apps. We have also learned about the different layouts
    that are in Compose and how the Jetpack Compose compiler renders state into a
    UI.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Jetpack Compose，这是一种声明性方式创建应用程序UI。我们还学习了Compose中的不同布局以及Jetpack Compose编译器如何将状态渲染到UI中。
- en: In the next chapter, we will be building on top of what we have learned and
    look at how to design beautiful and intuitive apps with **Material Design 3**.
    We’re going to learn about Material Design 3, its features, and how to add dynamic
    color to our app.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于我们已经学到的内容，探讨如何使用**Material Design 3**设计美观且直观的应用程序。我们将学习Material Design
    3，其功能以及如何将动态颜色添加到我们的应用程序中。
