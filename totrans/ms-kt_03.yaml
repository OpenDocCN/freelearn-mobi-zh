- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jetpack Compose Layout Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good UI and user experience are core to our apps. As Android developers, we
    must be keenly aware of these two areas and learn how to use the different tools
    provided for us to create UIs. Google introduced **Jetpack Compose**, a modern
    UI toolkit to help developers create intuitive UIs with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at Jetpack Compose, a declarative way of creating
    UIs for our apps. We will learn the basics of Jetpack Compose and layouts in Jetpack
    Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Jetpack Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetpack Compose layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterthree).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, Android UI development has undergone significant transformations
    with various frameworks and libraries emerging to simplify the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Jetpack Compose, this is how we used to write UIs for our apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Views were inflated from XML layout files. XML-based views are still supported
    alongside Jetpack Compose for backward compatibility and mixed use cases where
    apps have both XML layouts and Jetpack Compose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Themes, styles, and value resources were also defined in XML files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For us to be able to access the views from XML files, we used view binding or
    data binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method of writing a UI required huge effort, requiring more boilerplate
    code and being error prone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google developed Jetpack Compose as a modern **declarative** UI toolkit. It
    allows us to create UIs with less code. Layouts created in Jetpack Compose are
    responsive to different screen sizes and orientations. It is also easier and more
    productive to write UIs in Compose. With Jetpack Compose, we can reuse components
    across our code bases. Jetpack Compose also allows us to use code from XML components
    in our composables.
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Compose is entirely in Kotlin, meaning it takes advantage of the powerful
    language features that Kotlin offers. The **view system**, which was used to create
    UIs before Compose, was more procedural. We had to manage complex life cycles
    and handle any changes in state manually. Jetpack Compose is a whole other paradigm
    that uses declarative programming. We describe what the UI should be like based
    on a state. This enables us to have dynamic content and less boilerplate code
    and develop our UIs faster.
  prefs: []
  type: TYPE_NORMAL
- en: To understand Jetpack Compose, let us first dive deep into the differences between
    the declarative and imperative approaches to writing UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative versus imperative UIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In imperative UIs, we specify step by step the instructions describing how the
    UI should be built and updated. We explicitly define the sequence of operations
    to create and modify UI elements. We rely on mutable state variables to represent
    the current state of the UI. We manually update these state variables as the UI
    changes and respond to user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In declarative UIs, we focus on describing the desired outcome rather than specifying
    the step-by-step instructions. We define what the UI should look like based on
    the current state, and the framework handles the rest. We define the UI using
    declarative markup or code. We express the desired UI structure, layout, and behavior
    by describing the relationships between UI elements and their properties.
  prefs: []
  type: TYPE_NORMAL
- en: The declarative approach puts more emphasis on the immutable state, where the
    UI state is represented by immutable data objects. Instead of directly mutating
    the state, we create new instances of the data objects to reflect the desired
    changes in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In a declarative UI, the framework takes care of updating the UI based on changes
    in the application state. We specify the relationships between the UI and the
    underlying state, and the framework automatically updates the UI to reflect those
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand both imperative and declarative approaches, let’s look
    at an example of each. Let’s create a simple UI for a counter using both the declarative
    UI in Jetpack Compose (Kotlin) and the imperative UI in XML (Android XML layout).
    The example will showcase the differences in syntax and the approach between the
    two. The Jetpack Compose version looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a `MyApp` composable function that defines
    the UI for the app. The UI is defined in a declarative manner, by using composables
    to define the UI and handling state changes using the remember composable. The
    UI is defined using a functional approach. Also, we can see that the UI is defined
    in a more concise manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the imperative approach, we must first create the XML UI, as shown in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the layout file created, we can now create the activity class, which will
    inflate the layout file and handle the button click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the XML layout is inflated in the `onCreate` method of the
    `MainActivity` class, and UI elements are accessed and manipulated programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, the Jetpack Compose code is written in Kotlin and
    provides a more declarative approach, defining the UI in a functional manner.
    The XML layout, on the other hand, is written imperatively in XML, specifying
    the UI structure and properties in a more step-by-step manner using XML and interacting
    with them imperatively in Kotlin code. Jetpack Compose allows for a more concise
    and expressive representation of the UI using a declarative syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clear understanding of the imperative and declarative ways
    of writing UIs, in the next section, we will be diving deep into the building
    blocks of Jetpack Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Composable functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As shown in *Figure 3**.1*, composable functions are the main building blocks
    of Jetpack Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Compose UI](img/B19779_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Compose UI
  prefs: []
  type: TYPE_NORMAL
- en: A composable function describes how to render a UI. This function must be annotated
    with the `@Composable` function. When you annotate a function with this annotation,
    it means that the function describes how to compose a specific part of the UI.
    Composable functions are meant to be **reusable**. They can be called multiple
    times while the UI is active. Whenever the state of the composable changes, it
    goes through a process of recomposition, which enables the UI to display the latest
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Composable functions are **pure functions**, meaning they don’t have any side
    effects. They produce the same output when called several times with the same
    input. This ensures the functions are predictable and efficient in dispatching
    updates to the UI. However, there are exceptions, for example, launching a coroutine
    within a composable of calling external methods that do have side-effects, which
    should be avoided or handled carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Smaller composable functions can be combined to build complex UIs. You can reuse
    and nest composables inside other composables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a composable function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `PacktPublishing` function is annotated with
    the `@Composable` annotation. The function takes a parameter, `bookName`, which
    is a `String`. Inside the function, we have another composable from the Material
    Design library. The composable renders some text to our UI.
  prefs: []
  type: TYPE_NORMAL
- en: When designing our UIs, we usually want to see how the UIs look without running
    our app. Luckily, we have **previews**, which visualize our composable functions.
    We will be learning about them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Previews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Jetpack Compose, we have the `@Preview` annotation, which generates a preview
    of our composable function or a group of Compose components inside Android Studio.
    It has an interactive mode to allow us to interact with our Compose functions.
    This gives us a way to quickly visualize our designs and easily make changes when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our `PacktPublishing` composable function would look like with
    a preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `@Preview` annotation to indicate that we want to build a preview
    for this function. Additionally, we have set the `showBackground` parameter to
    `true`, which adds a white background to our preview. We have named the function
    with the `Preview` suffix. The preview is also a composable function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to see the preview, you need to be in the **split or design mode**
    in your editor. These options are normally at the top right of Android Studio.
    We also need to do a build for Android Studio to generate a preview, which will
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Text preview](img/B19779_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Text preview
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 3**.2*, we have a text that displays the string that we passed
    to the function. The preview also has a white background and its name at the top
    left.
  prefs: []
  type: TYPE_NORMAL
- en: We can show previews for both dark and light color schemes. We can also configure
    properties such as the devices and preview windows to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Previews are great for quick iterations while designing UIs. However, they are
    not a replacement for actual device/emulator testing, particularly for things
    such as animations, interactions, or dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of what previews are and how to create them, let us look
    into one more Compose feature, **modifiers**, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modifiers allow us to decorate our composable functions by enabling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Change composables’ size, behavior, and appearance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add more information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add interactions such as clicks and ripple effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With modifiers, we can change various aspects of our composable, such as size,
    padding, color, and shape. Most Jetpack Compose components from the library allow
    us to provide a modifier as a parameter. For example, if we need to provide padding
    to our preview text, we will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have added the padding modifier to the `Text` composable. This will add `16.dp``Text`
    composable. `16.dp` is a **density-independent** pixel unit in Jetpack Compose.
    This means it will remain consistent and adjust properly to different screen densities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can chain the different modifier functions in one composable. When chaining
    modifiers, the order of application is crucial. If we don’t achieve the desired
    result, we need to double-check the order. Let’s observe this concept in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added two more modifiers. The first is the `fillMaxWidth` modifier,
    which is added to the text composable. This will make the text composable take
    the full width of the parent. The other one is the background modifier to the
    `Text` composable. This will add a background color to the text composable. The
    preview for our text will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Text modifier preview](img/B19779_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Text modifier preview
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding screenshot, the text now occupies the whole width of
    the device and has a green background. It also has a padding of `16dp` all around.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers do not modify the original composable. They return a new, modified
    instance. This ensures our composable remains unchanged and immutable. Immutability,
    a fundamental principle in functional programming, ensures that the state remains
    unchanged, simplifying state management and reducing side effects. This approach
    enhances predictability and readability by adhering to the principles of referential
    transparency. The ability to compose functions, exemplified by chaining modifier
    functions, facilitates a concise and readable expression of complex UI behavior
    without altering the original composable. In addition to using the existing modifiers,
    we can also create our own modifiers when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of what modifiers are, we are going to build
    on that knowledge by learning about Jetpack Compose layouts in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Compose layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jetpack Compose has a variety of pre-built layouts for us to use. Before looking
    at the different layouts present, let us first understand how Jetpack Compose
    transforms state into UI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – How Compose transforms state into UI](img/B19779_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – How Compose transforms state into UI
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can see that our state is transformed into a
    UI in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composition**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the initial phase. The Compose compiler creates a tree of UI elements.
    Each element is a function that represents a UI element. Compose then calls the
    functions to create the UI tree. The composition step is responsible for determining
    which composables need updates and which ones can be reused. This happens by comparing
    a previous tree of composables with the new tree and only updating the ones that
    have changed. This makes this step very efficient as only elements with updates
    are updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Layout**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This step happens after the composition phase. Here, the Compose compiler takes
    the tree generated in the composition phase and determines its size, position,
    and layout. Each composable is measured and positioned within the layout based
    on its parent and any constraints set. This phase is responsible for determining
    the final position and size of each UI element on the screen. It is also responsible
    for creating the final layout tree used in the drawing phase.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Drawing**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the last phase of transforming our UI to state. In this phase, the Compose
    compiler takes the final layout tree created in the layout phase and uses it to
    draw the elements on the screen. This is done by walking through the tree and
    issuing draw commands to the underlying graphics system. This phase is responsible
    for rendering the final UI on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These three phases work together to create our UI in Jetpack Compose. The composition
    phase builds a tree of composables, the layout phase positions and sizes them,
    and the drawing phase renders them on the screen. This entire process is optimized,
    performant, and efficient, allowing for fast and smooth UI rendering in even complex
    UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how the Compose compiler renders our UI, let us see the
    layouts that are in Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jetpack Compose offers the following layouts out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Column`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Row`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Box`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to look at each of these layouts in detail in the next subsections.
    To begin with, let us look the `Column` layout.
  prefs: []
  type: TYPE_NORMAL
- en: Column
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use `Column` when we want to organize items vertically. An example of the
    use of `Column` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created `Column` with three text elements. Adding
    a preview for this generates the following UI for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Column preview](img/B19779_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Column preview
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen from the preceding screenshot, the design is basic. We are going to
    polish it up a bit by using modifiers since Jetpack Compose also provides support
    for modifiers in these layouts. Let us add these changes to our column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added a `Modifier` to our `Column`. In the modifier parameter,
    we specify the `fillMaxSize` modifier, which makes our column fill the available
    space within the parent. This is helpful for building full-view screens for our
    UIs. We have also added padding of `16.dp` to our column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we have specified two more parameters for our column. One is
    `verticalArrangement`, which we use to specify the vertical arrangement of the
    children of this view. In this case, we specify `Arrangement.Center`, which places
    all the children of our `Column` vertically at the center. The other parameter
    is `horizontalAlignment`, which is the horizontal alignment of the children of
    the layout. In this case, we specify the value to be `Alignment.CenterHorizontally`,
    which will align all the children at the center horizontally. Our preview with
    the preceding changes will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Column modifiers preview](img/B19779_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Column modifiers preview
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can now see our column occupies the whole
    screen and all the text elements are centered vertically and horizontally within
    the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now learn about the `Row` composable in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Row
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use `Row` when we want to organize items horizontally. An example of the
    use of `Row` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `Row` composable is used to display three text elements
    horizontally in a row. The preview for this will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Row preview](img/B19779_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Row preview
  prefs: []
  type: TYPE_NORMAL
- en: 'The text elements are all arranged next to each other in a horizontal row.
    `Row`, like the composable, supports the addition of modifiers. Let us modify
    our `Row` to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added modifiers to the `Row` composable. The
    `fillMaxSize` modifier makes the row fill the entire available space. The padding
    modifier adds padding to the `Row`. The `verticalAlignment` and `horizontalArrangement`
    modifiers are used to align the children of the `Row` vertically and horizontally,
    respectively. Notice that for the `horizontalArrangement` modifier, we use the
    `Arrangement.SpaceEvenly` option. This makes sure each of the children occupies
    equal space in the parent. The preview for this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Row modifiers preview](img/B19779_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Row modifiers preview
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 3**.8*, the row occupies the whole screen, and the text elements
    are evenly spaced within the screen width.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be learning about the `Box` layout.
  prefs: []
  type: TYPE_NORMAL
- en: Box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Box` layout allows us to position child elements in a flexible way using
    the X and Y coordinates. Let us see a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have a `Box` composable that has an `Icon` and `Text`
    composable as its children. We have set the size of the `Box` composable to `100.dp`
    and the `Icon` composable to `80.dp`. The text and icon composables are placed
    in the center of the `Box` composable using the `contentAlignment` parameter.
    They are placed in the center of the `Box` composable because we have specified
    the `contentAlignment` parameter as `Alignment.Center`. They are also stacked
    on top of each other because the `Box` composable is a layout composable that
    stacks its children on top of each other. The preview for our `Box` composable
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Box preview](img/B19779_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Box preview
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from *Figure 3**.9*, the notification icon and the text are stacked
    together. The `Box` composable enables us to achieve this and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us look at how to display lists in Jetpack Compose in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Android developers, we need to make apps that display lists of items. It
    can be a list of movies, orders, songs, or books. So, how do we do that in Compose?
    The good news for us is that Jetpack Compose makes it easier for us to do so.
    Compose provides the `LazyColumn` and `LazyRow` components, which can be used
    to display a list of items. These components are very efficient and performant.
    They only render the items that are visible on the screen, rather than rendering
    all the items at once. `LazyColumn` displays items vertically, while `LazyRow`
    displays items horizontally. `LazyColumn` and `LazyRow` are normally optimized
    for large datasets and at times are not suitable for all use cases. These composable
    functions allow you to define the contents of the list as a function that returns
    a single item, and then Compose will automatically generate and render the UI
    elements for each item in the list as they become visible on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of `LazyColumn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have `LazyColumn` with 100 items. Each item is a `Text` composable. The
    preview for this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – LazyColumn preview](img/B19779_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – LazyColumn preview
  prefs: []
  type: TYPE_NORMAL
- en: We can see from *Figure 3**.10* that we now have a list of items that scroll
    vertically. As mentioned, it only shows the items that can fit on the screen.
    If we use interactive mode on our preview, we will be able to scroll through to
    the bottom of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the `LazyRow` equivalent as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have `LazyRow` with 100 items. Each item is a `Text` composable. The preview
    for this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – LazyRow preview](img/B19779_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – LazyRow preview
  prefs: []
  type: TYPE_NORMAL
- en: We can see from *Figure 3**.11* that we now have a list of items that scroll
    horizontally. Similar to `LazyColumn`, it only shows the items that can fit on
    the screen. If we use interactive mode on our preview, we can scroll through to
    the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have two more types of list layouts, `LazyVerticalGrid` and `LazyHorizontalGrid`.
    The two layouts are part of the lazy grids and help us to arrange our content
    in grids. They’re commonly used in applications such as galleries, movies, and
    spreadsheets. `LazyVerticalGrid` creates a vertical list of items in a grid. Let
    us look at the sample code for `LazyVerticalGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the `LazyVerticalGrid` composable. We pass our modifiers as before.
    Notice we also have the `columns` parameter. This parameter allows us to specify
    the number of columns and how items are arranged within the columns. In this case,
    we specified `GridCells` to be `Fixed`. This means the grid will have a fixed
    number of columns or rows in it is a `LazyHorizontalGrid`. We also have the `Adaptive`
    type, which defines a grid with as many rows or columns as possible with the condition
    that every cell has a minimum size and all extra space is distributed evenly.
    Our preview will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – LazyVerticalGrid preview](img/B19779_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – LazyVerticalGrid preview
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our text elements in a grid of three columns. We are now able to scroll
    through the items vertically. Let us now look at the code for `LazyHorizontalGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is similar to that for `LazyVerticalGrid`. The only difference is
    that we are using `LazyHorizontalGrid` and instead of columns, we are now passing
    `rows` to describe how the cells will form the rows. The preview will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – LazyHorizontalGrid preview](img/B19779_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – LazyHorizontalGrid preview
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 3**.13*, we now have three rows on the entire screen, and
    we can also scroll through them horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `LazyVerticalGrid` and `LazyHorizontalGrid`, we also have `LazyVerticalStaggeredGrid`
    and `LazyHorizontalStaggeredGrid`, which are remarkably similar; the only difference
    is that they adapt to the children’s height and width, respectively, meaning they
    all do not have uniform height or width.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now have a look at `ConstraintLayout` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: ConstraintLayout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This layout enables us to create responsive layouts. We can create complex layouts
    with relative positioning. `ConstraintLayout` uses chains, barriers, and guidelines
    to position child elements relative to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'It comes as a separate dependency, and we need to add it to our project. To
    add it, let us add this dependency to our app `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds the Jetpack Compose dependency to our project. The layout code for
    the constraint layout is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we used the `ConstraintLayout` composable function to
    create `ConstraintLayout`. Inside `ConstraintLayout`, we used the `createRefs()`
    function to create two references, one for the icon and one for the text. We then
    used the `constrainAs()` function to constrain the icon and the text to the parent.
    We used the `linkTo()` function to link the icon and the text to the parent. In
    this case, we have linked the icon to the start, top, and bottom of the parent.
    For the text, we have linked it to the top and bottom of the parent. We have additionally
    linked the start of the text to the end of the icon. Our preview will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – ConstraintLayout preview](img/B19779_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – ConstraintLayout preview
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can see that we have an icon and text to the
    right of the icon. `ConstraintLayout` helps in positioning items relative to the
    parent or each other.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced ourselves to Jetpack Compose, a declarative
    way of creating UIs for apps. We have also learned about the different layouts
    that are in Compose and how the Jetpack Compose compiler renders state into a
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be building on top of what we have learned and
    look at how to design beautiful and intuitive apps with **Material Design 3**.
    We’re going to learn about Material Design 3, its features, and how to add dynamic
    color to our app.
  prefs: []
  type: TYPE_NORMAL
