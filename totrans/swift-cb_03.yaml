- en: Data Wrangling with Swift Control Flow
  prefs: []
  type: TYPE_NORMAL
- en: Programming is all about making decisions. The purpose of most code involves
    taking information, inspecting it, making decisions, and producing an output.
    So far, we have seen a lot of ways to represent information, but in this chapter,
    we will explore how to make decisions based on that information using a number
    of Swift's control flow statements. We will find out how they differ and the situations
    where each is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions with `if`/`else`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling all the cases with `switch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping with `for` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping with `while` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors with `try`, `throw`, `do`, and `catch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking upfront with `guard`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing it later with `defer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bailing out with `fatalError` and `precondition`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3aq66Us](https://bit.ly/3aq66Us)'
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions with if/else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The if/else statement is a cornerstone of almost every programming language.
    It enables code to be executed conditionally, based on the outcome of a Boolean
    statement. In this recipe, we will see how if/else can be used, including some
    ways that are unique to Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have ever played pool, you''ll know that the aim of the game (when playing
    standard 8-ball pool) is to pot all the balls of one type and then to pot the
    black ball. When using American pool balls, they are numbered 1-15, and have a
    different pattern depending on their type. Balls 1-7 have a solid color, balls
    9-15 are white with a colored stripe around them, and ball 8 is black:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e68de254-2938-478c-bf86-aaa825b2a4ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 â€“ American pool balls
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will write a function that will take the number on a pool
    ball and return the type of ball it is.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use an if/else control flow statement to write a function to return
    the right pool ball type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `enum` to describe the possible ball types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the method that will take an `Int` and return `PoolBallType`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this function and test that we get the expected results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the function, we define three code paths: `if`, `else if`, and `else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we want to determine whether the ball is solid. Since we know that the
    balls numbered 1-7 are solid, we can test whether the ball number is less than
    8, with `number < 8`. If this is `true`, we return the `.solid` case of our `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: If it is `false`, the `else if` Boolean expression is evaluated. As balls 9-15
    are striped, we can test whether the ball number is more than 8, with `number
    > 8`. If this is `true`, we return the `.stripe` case of our `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if both the preceding Boolean expressions are `false`, we return the
    `.black` case of our `enum`, since that can only happen if the number is exactly
    8\.
  prefs: []
  type: TYPE_NORMAL
- en: The `else if` and `else` blocks are optional, and you can declare multiple `else
    if` to cover additional conditions. Let's expand our preceding example with an
    extra `else if` to better decide the pool ball type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we stated previously, pool balls are numbered between 1 and 15, but we don''t
    take into account those upper and lower bounds in our implementation. So if we
    were to provide the function with ball number 0, it would return `.solid`, and
    if we were to provide ball number 16, it would return `.stripe`, which doesn''t
    accurately reflect our intention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify our function to only return a pool ball type if the number is
    between 1 and 15, and return `nil` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we have four code branches in our `if` statement, and we can use the AND
    operator, `&&`, to combine Boolean statements (the OR operator, `||`, is also
    available).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call our function for both numbers within the expected 1-15 range
    and outside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our improved function will produce `nil` for numbers outside of the expected
    range.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some other ways we can use if/else statements.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding conditional unwrapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function we created earlier returns an optional value, so if we want to
    do anything useful with the resulting value, we need to `unwrap` the optional.
    So far, the only way we have seen how to do this is by force unwrapping, which
    will cause a crash if the value is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use an `if` statement to *conditionally unwrap* the optional,
    turning it into a more useful, non-optional value.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a function that will print information about a pool ball of a given
    number. If the provided number is valid for a pool ball, it will print the ball's
    number and type; otherwise, it will print a message explaining that it is not
    a valid number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will want to print the value of the `PoolBallType` enum, let''s make
    it `String` backed, which will make printing its value easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write the function to print the pool ball details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do in our `printBallDetails` function is to get the ball
    type for the given number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In our improved version of this function, this returns an optional version
    of the `PoolBallType` enum. We want to include the `rawValue` of the returned
    `enum` as part of printing the ball details. Since the returned value is optional,
    we need to unwrap it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this `if` statement, instead of defining a Boolean expression, we are assigning
    our optional value to a constant; the `if` statement uses this to *conditionally
    unwrap* the optional. The optional value is checked to see whether it is `nil`;
    if it is not `nil`, then the value is unwrapped and assigned to the constant as
    a non-optional value. That constant becomes available within the scope of the
    curly brackets following the `if` statement. We use that `ballType` non-optional
    value to obtain the raw value for the `print` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `if` branch of the `if-else` statement is followed when the optional
    value has a value, then the `else` branch is followed when the optional value
    is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this means that the given number is not valid for a pool ball, we print
    a relevant message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call our new function with the same values as before to print out
    the pool ball type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We've used conditional unwrapping to print the pool ball type, if valid, or
    explain it's not valid.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining optional unwrapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ability of `if` statements to conditionally unwrap optionals can be chained
    together to produce some useful and concise code. The following example is a bit
    contrived, but it illustrates how we can use a single `if` statement to unwrap
    a chain of optional values.
  prefs: []
  type: TYPE_NORMAL
- en: When you play a game of pool, called a *frame*, the type of the first ball you
    pot becomes the type you need to pot for the rest of the frame, and your opponent
    has to pot the opposite type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a frame of pool and say that we want to track what type of ball
    each player will be potting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create a `PoolTable` object that has an optional `currentFrame`
    property, which will contain information about the current frame if one is in
    progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We now have a pool table that has an optional frame and a frame that has an
    optional ball type for each player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a function that prints the ball type for player 1 in the
    current frame. It is possible that the current frame is `nil` because there is
    no frame currently being played, or that player 1''s ball type is `nil` because
    a ball hasn''t yet been potted. Therefore, we need to account for either of those
    being `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our function is given a `PoolTable`, and to print player 1's ball type, we first
    need to check and unwrap the `currentFrame` property, and then we need to check
    and unwrap the current frame's `player1BallType` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do this by nesting our `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can handle this chained unwrapping in one `if` statement by performing
    the unwrapping statement sequentially, separated by commas, and each statement
    can access the unwrapped values from the previous statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first statement unwraps the `currentFrame` property, and the second statement
    uses that unwrapped frame to unwrap player 1's ball type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the function we''ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a table, and without a current frame print player 1''s
    ball type, which won''t be available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create a current frame, but as player 1''s ball type is still
    `nil`, the function prints the same output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we set player 1''s ball type, now our function prints the type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've created a method that can chain conditional unwrappings, only printing
    a value when all the values in the chain are non-nil.
  prefs: []
  type: TYPE_NORMAL
- en: Using enums with associated values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in the *Enumerating values with enums* recipe from [Chapter 1](f9d48715-ffca-464f-95bf-722958f02e72.xhtml),
    *Swift Building Blocks*, enums can have associated values, and we can use an `if`
    statement to both check an enum's case and extract the associated value in one
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an enum to represent the result of the pool game, with each case
    having an associated message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a function that takes a `Result` and prints either the
    congratulatory message or the commiseration message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this function will print the result, followed by the relevant message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if case` block will be executed if the value on the right-hand side of
    the `=` matches the case on the left-hand side. In addition, you can specify a
    local constant for the associated value (`winMessage` in the following example),
    which is then available within the subsequent block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `if case` statement to both check the case of an enum value and
    access its associated value in one go.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about if/else can be found in Apple's documentation on the
    Swift language at [http://swiftbook.link/docs/statements.](http://swiftbook.link/docs/statements)
  prefs: []
  type: TYPE_NORMAL
- en: Handling all cases with switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`switch` statements allow you to control the flow of execution by testing one
    specific value in multiple ways. In Objective-C and other languages, `switch`
    statements can only be used on values that can be represented by an integer, and
    are most commonly used to make decisions based on enumeration cases.'
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, **enumerations** have become a lot more powerful in Swift,
    as they can be based on more than just integers, and so too can `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '`switch` statements in Swift can be used on any type and have advanced pattern-matching
    functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore both simple and advanced usage of `switch` control
    flow statements to control logic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are old enough to remember the early days of the home computer, you may
    also remember text-based adventures. These were simple games that usually described
    a scene and then let you move around by typing a command to move north, south,
    east, or west. You would find and pick up items, and could often combine them
    to solve puzzles.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `switch` statements to control the logic of a simple text adventure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create parts of a text-based adventure, and use `switch` statements
    to make the decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an `enum` to represent the directions we can travel in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function that describes what the player of the text adventure will
    see when they look in that direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In our text adventure, users can pick up items and attempt to combine them to
    produce new items and solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define our available items as an `enum`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Write a function that takes two items and tries to combine them into a new item.
    If the items cannot be combined, it will return `nil:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In our text adventure, the player will meet different characters and can interact
    with them. Define the characters that the player can meet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a function that allows the player to say something, and optionally provide
    a character to whom it will be said. The interaction that will occur will depend
    on what is said and the character it is said to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the `lookTowards` function, we want to print a different message for
    each possible `CompassPoint` case; to do this, we use a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the `switch` statement, we define the value that we want to switch
    on; then we define what we want to be done when that value matches each of the
    defined cases using the `case` keyword and then the matching pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Each `case` statement is evaluated in turn, and if the pattern matches the value,
    the subsequent code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with `switch` statements from Objective-C, you may remember
    that you needed to add `break;` at the end of each `case` statement to stop the
    execution from falling through to the next `case` statement. This is not needed
    in Swift; the break in execution is implied by the beginning of the next `case`
    statement. The only time this isn't the case, it is because your `case` statement
    is intentionally empty; in these cases, you need to add `break` to tell the compiler
    that it is intentionally blank for this case. If you do want execution to fall
    through to the next `case` statement, you can add `fallthrough` at the end of
    the `case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `combine` function, we have two values that we want to switch based
    on their values. We can provide multiple values to the `switch` statement in the
    form of a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For each `case` statement, we define the valid value for each part of the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A `switch` statement in Swift requires that every possible case is covered;
    however, you can cover all the remaining possibilities in one go using the `default`
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For our preceding `combine` function, you will notice that the player will
    only be able to combine the items if they provide them in the right order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not the desired behavior, as there is no way for the player to know
    the correct order. To solve this, we can add multiple patterns to each `case`
    statement. So, when the player provides the `key` and `lockedDoor` items, we can
    handle the order `key`, `lockedDoor`, and the order `lockedDoor`, `key` with the
    same `case` statement, using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can add the opposite item order as another pattern to each case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the items can be combined in any order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For our `say` method, we again have two values that we want to switch on: the
    text that the player says, and the character to whom it is said. Since the `character`
    value is optional, we will need to unwrap the value to compare it with non-optional
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In a `switch` statement, when the value is optional, you can compare it to a
    non-optional value by adding a `?` to wrap it as an optional, making the comparison
    valid. In the preceding instance, we are comparing the optional `character` value
    to `.wizard?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where we have two values for a certain set of options, we may only care about
    one of the values, and the other value could be anything and the case would still
    be valid. In our example, once all the specific `textToSay` and character pairings
    have been handled, and the case where there is no character is handled, we want
    to unwrap and retrieve the character, but we don''t care about the `textToSay`
    value, so we can use `_` to indicate that any value is acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve the value of the character entered as part of this `case` statement
    rather than declaring a value to be matched, we define a constant that will receive
    the value, and since the value we are switching on is optional, we also add `?`,
    which will unwrap the value if not `nil`, and assign it to the constant.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about `switch` can be found in Apple's documentation on
    the Swift language at [http://swiftbook.link/docs/switch](http://swiftbook.link/docs/switch).
  prefs: []
  type: TYPE_NORMAL
- en: Looping with for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`for` loops allow you to execute code for each element in a collection or range.
    In this recipe, we will explore how to use `for` loops to perform actions on every
    element in a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create some collections and then use `for` loops to act on each element
    in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array of elements, so we can do something with every item in the
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a loop to go through our `theBeatles` array and print each string element
    that the `for` loop provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `for` loop that executes some code a set number of times, instead
    of looping through an array. We can do this by providing a range instead of a
    collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `for` loop to print the keys and values of a dictionary. Dictionaries
    contain pairings between a key and a value, so when looping through a dictionary,
    we will be provided with both the key and the value in the form of a tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at how we looped through our `theBeatles` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify the `for` keyword and then we provide a name for the local variable
    that will be used for each element in the collection or range. Then, the `in`
    keyword is provided, followed by the collection or range that will be looped through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For range-based loops, the value provided for each loop is the next integer
    in the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A range can be a *closed range,* where the range includes the start value and
    the end value, like the one specified above. Or it can be a *half-open range*,
    which goes up to, but doesn''t include, the last value, like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When looping through a dictionary, we need to be provided with both the key
    and value; to do this, we provide a tuple that will receive each key and value
    in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define the tuple and name each of the values. This name can then be
    used in an execution block. Let''s change the tuple labels to better describe
    the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Giving the tuple meaningful names in the preceding example makes the code easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about `for-in` loops can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/for-in](http://swiftbook.link/docs/for-in).
  prefs: []
  type: TYPE_NORMAL
- en: Looping with while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`for` loops are great when you know how many times you intend to loop, but
    if you want to loop until a certain condition is met, you need a `while` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `while` loop has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The code block will execute over and over until the Boolean expression returns
    `false`. Therefore, it's a common pattern to change some value in the code block
    that may cause the Boolean expression to change to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no chance of the Boolean expression becoming `true`, the code will
    loop forever, which can lock up your app.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at situations where a `while` loop can be useful
    for repeating actions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will involve simulating the random flip of a coin. To flip our
    coin, we will need to randomly pick either heads or tails, so we will need to
    use a random number generator from the Foundation framework. We will discuss Foundation
    further in [Chapter 5](a632f18a-5826-4757-90bc-7701c78edaaf.xhtml), *Beyond the
    Standard Library*, but for now, we just need to import the Foundation framework
    at the top of our playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This will give us the ability to generate a random number, which we will use
    now.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s work out how many times in a row we can flip a coin and get heads:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `enum` to represent a coin flip, and use the random number generator
    to randomly choose heads or tails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function that will return the number of heads in a row from coin flips.
    The function will flip the coin within a `while` loop and continue to loop while
    the coin flip results in heads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our function, we start by keeping track of how many coin flips in a row
    are heads and keep a reference to the current coin flip, which will form the condition
    for the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `while` loop, we will continue to loop and execute the code in the following
    block while the current coin flip is heads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Within the code block, we add one to our running total and we re-flip the coin.
    We are flipping the coin and assigning it to `currentCoinFlip`, which will get
    rechecked on the next loop and if it is still heads, the next loop will be executed.
    Since we are changing something that affects the `while` condition, such that
    it could eventually be `false`, we can be sure that we won't be stuck in the loop
    forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as the coin flip is tails, the `while` loop condition will be `false`,
    and so the execution will move on and return the running total we have been keeping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time you call the function, the coin will be randomly flipped and
    the number of heads in a row will be returned, so each time it''s called, you
    may get a different value returned. Try it out a few times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can actually simplify our `while` loop by doing the coin flip as part of
    the loop continuation checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Each time through the loop, the `while` condition is evaluated, which involves
    re-flipping the coin and checking the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: This is more concise and removes the need to track `currentCoinFlip`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about `while` loops can be found in Apple's documentation
    of the Swift language at [http://swiftbook.link/docs/while](http://swiftbook.link/docs/while).
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors with try, throw, do, and catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Errors happen during programming. These errors may be due to your own code behaving
    in unexpected ways, or due to unexpected information or behavior from external
    systems. When these errors happen, it's important to handle them appropriately.
    Good error handling can separate a good app from a great app.
  prefs: []
  type: TYPE_NORMAL
- en: Swift provides a deliberate and flexible pattern for handling errors, allowing
    specific errors to be cascaded through a complex system.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discover how to define errors, and throw them when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To examine error handling, we will model a process that can go wrong, and for
    me, that is cooking a meal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define the steps involved in cooking a meal as states that the
    meal will transition through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an object to represent the meal we will be cooking. This object will
    hold the state of the meal as it moves through the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We want to allow the meal to transition between states, but not all state transitions
    should be possible. For instance, you can't move from buying ingredients to serving
    the meal. The meal should move sequentially from one state to the next. We can
    provide these restrictions by only allowing the state to be set from within the
    object itself, using access controls that we explored in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `state` property as only being privately settable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow the state to be changed from outside the object, create a function
    that will throw an error if the state transition isn''t possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In keeping with Swift's protocol-orientated approach, errors in Swift are defined
    as a protocol, `Error`. This approach allows you to construct your own type to
    represent errors within your code, and just have it conform to the `Error` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A common approach is to define errors as enums, with the enum cases representing
    the different types of errors that can occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the error thrown in the preceding `Meal` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to execute our error throwing method within a `do` block and catch any
    errors that may occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The metaphor used in Swift error handling (as well as other languages) is *throwing*
    and *catching*. A method can *throw* an error if a problem occurs during its execution,
    at which point nothing further in the method will be executed, and the error is
    passed back to where the method was called from.
  prefs: []
  type: TYPE_NORMAL
- en: In order to receive this error (perhaps to provide the details of the error
    to the user), you must *catch* the error at the place the method is called.
  prefs: []
  type: TYPE_NORMAL
- en: To throw an error, you have to declare that the method has the potential to
    throw an error. Declaring that a method `throws` allows the compiler to expect
    potential errors from the method and ensure that you don't forget to catch these
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods can be declared as potentially throwing an error using the `throws`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our change state method, we only change the state if we are moving to
    the next sequential state. Anything else isn''t allowed and should throw an error.
    We can do this using the `throw` keyword, followed by a value that conforms to
    the `Error` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create the `Meal` object and move through the states of preparing the
    meal, each change of state can throw an error. When we call a method that is marked
    as possibly throwing an error, we have to do it a certain way. We define a `do`
    block, within which we may call methods that can throw, and we then define a `catch`
    block that will be executed if any of these methods do throw an error. Each call
    to a throwing method must be prefixed with the `try` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If any of these methods does throw an error, execution will immediately move
    to the `catch` block. Therefore, by placing code after the `try` methods are called,
    we are guaranteeing that it will only be executed if the methods do not throw
    an error. By printing `Dinner is served!` after all the state transitions are
    called, we know this will only print if we have successfully moved through all
    the states. Try changing the order of these state change calls, and you'll see
    that the error is printed, and `Dinner is served!` is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `catch` block, after the `catch` keyword, we can define the local constant
    that we want the caught error to be assigned to. However, if we don''t specify
    a local constant here, Swift will implicitly create one for us called `error`,
    so we can actually omit the constant declaration in the `catch` block and still
    print the value of the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Swift has defined the error for us, so we can still print the value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how we can throw and catch errors, but we mentioned in the introduction
    that we can cascade errors through a system, so let's look at how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our meal preparation example, we allow the meal state to be changed externally
    through a `change` method that can throw an error. Instead, let''s change it to
    a private method, so we can only call it from within the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create some specific methods for moving to each state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that when we call the `change` method from within each of the
    new methods, we don't need to use a `do` and `catch` block to catch the error;
    this is because we have defined each of the new methods as potentially throwing
    an error, so if the call to the `change` method throws an error, this error will
    be passed to the caller of our new method as though it were throwing an error.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism allows errors that may occur many levels deep in your code to
    surface and be handled appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to amend our meal preparation code to use these new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the ability to actually affect our meal. We''ll add a method to
    add salt to the meal and a property to allow us to track how much salt is added.
    Add these to the end of the `Meal` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways in which adding salt can throw an error, either because
    we are in the wrong state to add salt (we can''t add salt until after we have
    bought the ingredients), or because we have added too much salt. Let''s add these
    two new errors to our `MealError` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have three possible errors that can occur during the preparation of
    a meal, and we may want to handle those errors differently. We can use multiple
    `catch` blocks to filter just specific errors that we want to catch, allowing
    us to handle each error separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: It is important to ensure that all possible errors are handled by the `catch`
    blocks, as an unhandled error will result in a crash. It is, therefore, safest
    to add an unfiltered `catch` block at the end to catch any errors not caught by
    the previous blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Since functions can throw an error, and closures are a type of function that
    can be passed as a parameter, we can have a function that takes a throwing closure
    where it can also throw an error. It may be that the only errors our function
    will throw are errors produced by the throwing closure that was passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When that is true, a function can be defined as re-throwing, using the `rethrows`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'This situation is quite confusing, so let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This `makeMeal` function takes a closure as a parameter; that closure takes
    a `Meal` object as a parameter and doesn't return anything, but may throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this function is to handle the creation of the `meal` object
    for you, just leaving you to do any meal preparation within the block; it then
    returns the meal that was created and prepared. Let''s see it in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `makeMeal` function only throws errors thrown by the closure parameter,
    so it can be declared as re-throwing. Declaring a function of this type with the
    `rethrows` keyword isn't required, it can be declared with `throws` instead. However,
    the compiler can make additional optimizations for a re-throwing function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about error handling can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/error-handling](http://swiftbook.link/docs/error-handling).
  prefs: []
  type: TYPE_NORMAL
- en: Checking upfront with guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen in previous recipes how we can use `if` statements to check Boolean
    expressions and unwrap optional values. It''s a common use case to want to do
    some checks and conditional unwrapping at the beginning of a block of code, and
    then only execute the subsequent code if everything is as expected. This usually
    results in wrapping the whole block of code in an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Swift has a better solution expressly for this purpose; the `guard` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `guard` statement to return early
    from a method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine that we have some data that came from an external source, and
    we want to turn it into model objects that our code can understand, with the intention
    of displaying it to the user. We can use `guard` statements to ensure the data
    is correctly formatted, bailing early if it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will take some information about the planets of the solar system, which
    could have come from an external source, and turn it into a model we can understand:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the planet data in the form of an array of dictionaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a `Planet` struct that will be created from the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking this one step at a time, create a function that will take one-planet
    dictionaries and make a `Planet` struct, if it can. We''ll use a `guard` statement
    to ensure that the dictionary has all the values we expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can handle individual planet data, create a function that will
    take an array of planet dictionaries and make an array of `Planet` structs, using
    a `guard` statement to ensure that we successfully create a `Planet` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `guard` statement works in a very similar way to an `if` statement, as
    optional values can be unwrapped and chained together in the same way. Since our
    planet data contains strings, ints, floats, and Booleans, the dictionary is of
    the `[String: Any]` type. So, to create our `Planet` struct, we will need to check
    if the expected values exist for given keys and cast them to the correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `makePlanet` function, we use the `guard` keyword and then access and
    conditionally cast all the values we require from the planet data dictionary.
    If any of these conditional casts fail, the `else` block, which is defined after
    the `guard` statement, is executed. We have defined our function to return an
    optional `Planet`, so if we don''t have the information expected, the `guard`
    will fail, and return `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Any value unwrapped by the `guard` statement is made available to any code below
    the `guard` statement in the same scope; this makes the `guard` statement perfect
    for ensuring that input values are as expected before continuing. This removes
    the need to nest our code within an `if` block. The unwrapped values are then
    used to initialize the `Planet` struct.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, a `guard` statement is for breaking execution when the `guard`
    condition fails, and therefore, the compiler ensures that an execution breaking
    statement is placed in the `else` block; this could be, for example, `return`,
    `break`, or `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `makePlanets` function, we use a `for` loop to iterate through the dictionaries
    and try to create a `Planet` struct from each one. If our `makePlanet` call returns
    `nil`, we call `continue` to skip this iteration of the `for` loop and jump to
    the next iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `makePlanets` function accepts an array of planet data dictionaries and
    returns an array of `Planet` structs. If the array provided is empty, we may decide
    that this is not a valid input to our function and we want to throw an error;
    `guard` can help with this too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check that any conditional statement is true with `guard` and if it
    isn''t, we can throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about `guard` statements can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/guard](http://swiftbook.link/docs/guard).
  prefs: []
  type: TYPE_NORMAL
- en: Doing it later with defer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, when we call a function, control passes from the call site to the
    function, then the statements within the function are executed sequentially until
    either the end of the function or until a `return` statement. Control then returns
    to the call site. In the following diagram, the `print` statements are executed
    in the order 1, 2, then 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53322170-0383-4db5-8c1b-b5714aba0dd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 â€“ print statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it can be useful to execute some code after the function has returned,
    but before control has been returned to the call site. This is the purpose of
    Swift''s `defer` statement. In the following example, step 3 is executed after
    step 2, even though it is defined above it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54fba059-3c39-42fb-b646-f9114dbeaee3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 â€“ defer statement
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how to use `defer`, and when it can be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `defer` statement can be useful to change the state once a function's execution
    is complete or to clean up values that are no longer needed. Let's look at an
    example of updating the state with a `defer` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that we have movie reviews with star ratings, and we want to classify
    them based on their star rating:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the options that a movie review may be classified into:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an object to do the classification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the classifier to classify the review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This works great, but for the purpose of this example, let's imagine that this
    classification was a long-running process, and we wanted to keep track of the
    state of the classifier, so we can externally check if the classifier was in the
    middle of classifying or was completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the possible classification states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Update our classifier class to hold and update the state, using a `defer` statement
    to move to the complete state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the classifier to classify the review and check the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `classify` method we defined above takes an input rating and then returns
    `MovieReviewClass` based on this rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'While doing that, it also updates a `state` value to indicate where the method
    is in the classification process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The `defer` statement allows the state to be updated once the method has returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to write this method without the `defer` statement, we would have
    to transition to the `complete` state within each branch of the `if` statement
    before returning a value, as nothing after this will be executed. The end of that
    method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This repetition of updating the state can be avoided when we use the `defer`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: To defer code, simply use the `defer` keyword, with the code to be deferred
    defined in curly brackets; this code will be run after the method has returned,
    but before the control flow is returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can define multiple `defer` statements within a method, and they are executed
    in the reverse order that they were defined, so the last `defer` statement defined
    is the first one executed after the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, add a new state that we''ll switch to when completing classifications
    subsequent to the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s amend our classifier to keep track of the number of classifications
    it makes and changes to the `completeAgain` state if more than one classification
    has been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change how we use the classifier; the second time we use it, it will complete
    with a different state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have now defined two `defer` statements, let''s take another look
    to understand the order in which they are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: As discussed earlier, the last defined `defer` statement is executed first.
    So on the first classification, once the method returns, the last `defer` statement
    is executed and the state is changed to `complete`, because `numberOfClassifications`
    will be `0`. Next, the first `defer` statement is executed, which adds `1` to
    the `numberOfClassifications` variable, which will now be `1`.
  prefs: []
  type: TYPE_NORMAL
- en: On the second classification, once the method returns, the last `defer` statement
    will execute and change the state to `completeAgain` since `numberOfClassifications`
    is greater than `0`. Finally, the first `defer` statement will execute, incrementing
    `numberOfClassifications` and making it `2`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `defer` statements had been the other way around, the state would always
    change to `completeAgain`, as `numberOfClassifications` would have incremented
    to `1` before the check was made.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about `defer` statements can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/defer](http://swiftbook.link/docs/defer).
  prefs: []
  type: TYPE_NORMAL
- en: Bailing out with fatalError and precondition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s comforting to think that in the code you write, everything will always
    happen as expected, and your program can handle any eventuality. However, sometimes
    things can go wrong â€“ really wrong. A situation could arise that you know is possible
    but don''t expect to ever happen, and the program should terminate if it does.
    In this recipe, we will look at two issues like this: `fatalError` and `precondition`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's reuse our example from the previous recipe; we have an object that can
    be used to classify movie reviews based on how many stars out of 10 the review
    gave the movie. However, let's simplify its use, and say that we only intend for
    a classifier object to classify one, and only one, movie review.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s set up our movie classifier to only be used once, and only accept ratings
    out of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the classification state and the movie review class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Redefine our classifier object, using `precondition` and `fatalError` to indicate
    situations that are not expected to occur and would cause a problem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We only want to use the classifier once; therefore, when we begin to classify
    a movie review, the current state should be `initial` as this object has never
    classified before and shouldn''t be in the middle of classifying. If that is not
    the case, the classifier is being used incorrectly, and we should terminate the
    execution of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We state a precondition using the `precondition` keyword, provide a Boolean
    statement that we expect to be true, and an optional message. If this Boolean
    statement is not true, the execution of the code will terminate and the message
    will be displayed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are making it a precondition that the state must be `initial`
    when calling this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When our classifier performs the classification, it expects a number of stars
    between 1 and 10\. However, the method accepts an `Int` as a parameter; so, any
    integer value can be provided, positive or negative. If the value provided is
    not between 1 and 10 and the classifier cannot provide a valid `MovieReviewClass`,
    then the classifier is being used incorrectly, and we should terminate the execution
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The if-else statement covers all the valid `MovieReviewClass` options for the
    provided stars, so if none of these are triggered, we use a fatal error to indicate
    incorrect usage. This is done using the `fatalError` keyword, providing an optional
    message.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about `fatalError` can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/fatalerror](http://swiftbook.link/docs/fatalerror).
  prefs: []
  type: TYPE_NORMAL
