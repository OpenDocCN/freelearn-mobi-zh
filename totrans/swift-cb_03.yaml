- en: Data Wrangling with Swift Control Flow
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swift控制流进行数据处理
- en: Programming is all about making decisions. The purpose of most code involves
    taking information, inspecting it, making decisions, and producing an output.
    So far, we have seen a lot of ways to represent information, but in this chapter,
    we will explore how to make decisions based on that information using a number
    of Swift's control flow statements. We will find out how they differ and the situations
    where each is appropriate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程全部关于做决定。大多数代码的目的涉及获取信息，检查它，做出决定，并产生输出。到目前为止，我们已经看到了许多表示信息的方法，但在这个章节中，我们将探索如何使用Swift的多个控制流语句根据这些信息做出决定。我们将了解它们的区别以及每种情况适用的场景。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Making decisions with `if`/`else`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`/`else`做出决定
- en: Handling all the cases with `switch`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`switch`处理所有情况
- en: Looping with `for` loops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`循环进行循环
- en: Looping with `while` loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`while`循环进行循环
- en: Handling errors with `try`, `throw`, `do`, and `catch`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`try`、`throw`、`do`和`catch`处理错误
- en: Checking upfront with `guard`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`guard`提前检查
- en: Doing it later with `defer`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`defer`稍后处理
- en: Bailing out with `fatalError` and `precondition`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fatalError`和`precondition`退出
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在这个书的GitHub仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3aq66Us](https://bit.ly/3aq66Us)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[https://bit.ly/3aq66Us](https://bit.ly/3aq66Us)
- en: Making decisions with if/else
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if/else做出决定
- en: The if/else statement is a cornerstone of almost every programming language.
    It enables code to be executed conditionally, based on the outcome of a Boolean
    statement. In this recipe, we will see how if/else can be used, including some
    ways that are unique to Swift.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: if/else语句是几乎所有编程语言的基础。它使代码能够根据布尔语句的结果有条件地执行。在这个食谱中，我们将看到if/else如何使用，包括一些Swift特有的方法。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If you have ever played pool, you''ll know that the aim of the game (when playing
    standard 8-ball pool) is to pot all the balls of one type and then to pot the
    black ball. When using American pool balls, they are numbered 1-15, and have a
    different pattern depending on their type. Balls 1-7 have a solid color, balls
    9-15 are white with a colored stripe around them, and ball 8 is black:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过台球，你会知道游戏的目标（当玩标准8球台球时）是将一种类型的所有球都入袋，然后入袋黑球。当使用美国台球球时，它们编号为1-15，并且根据它们的类型有不同的图案。1-7号球是实心颜色，9-15号球是带有彩色条纹的白色球，8号球是黑色的：
- en: '![](img/e68de254-2938-478c-bf86-aaa825b2a4ca.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e68de254-2938-478c-bf86-aaa825b2a4ca.png)'
- en: Figure 3.1 – American pool balls
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 美国台球球
- en: In this recipe, we will write a function that will take the number on a pool
    ball and return the type of ball it is.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将编写一个函数，该函数将接受台球上的数字并返回球的类型。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s use an if/else control flow statement to write a function to return
    the right pool ball type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用if/else控制流语句编写一个函数来返回正确的台球类型：
- en: 'Create an `enum` to describe the possible ball types:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`enum`来描述可能的球类型：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the method that will take an `Int` and return `PoolBallType`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法，该方法将接受一个`Int`并返回`PoolBallType`：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use this function and test that we get the expected results:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此函数并测试我们是否得到预期的结果：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Within the function, we define three code paths: `if`, `else if`, and `else`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们定义了三个代码路径：`if`、`else if`和`else`：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we want to determine whether the ball is solid. Since we know that the
    balls numbered 1-7 are solid, we can test whether the ball number is less than
    8, with `number < 8`. If this is `true`, we return the `.solid` case of our `enum`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要确定球是否是实心。由于我们知道1-7号球是实心的，我们可以测试球号是否小于8，使用`number < 8`。如果是`true`，我们返回`enum`的`.solid`情况。
- en: If it is `false`, the `else if` Boolean expression is evaluated. As balls 9-15
    are striped, we can test whether the ball number is more than 8, with `number
    > 8`. If this is `true`, we return the `.stripe` case of our `enum`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是`false`，则评估`else if`布尔表达式。由于9-15号球是条纹球，我们可以测试球号是否大于8，使用`number > 8`。如果是`true`，我们返回`enum`的`.stripe`情况。
- en: Lastly, if both the preceding Boolean expressions are `false`, we return the
    `.black` case of our `enum`, since that can only happen if the number is exactly
    8\.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果前面的布尔表达式都是`false`，我们返回枚举的`.black`情况，因为那只能发生在数字正好是8的情况下。
- en: The `else if` and `else` blocks are optional, and you can declare multiple `else
    if` to cover additional conditions. Let's expand our preceding example with an
    extra `else if` to better decide the pool ball type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if`和`else`块是可选的，并且你可以声明多个`else if`来覆盖额外的条件。让我们通过添加一个额外的`else if`来扩展前面的示例，以更好地确定台球类型。'
- en: 'As we stated previously, pool balls are numbered between 1 and 15, but we don''t
    take into account those upper and lower bounds in our implementation. So if we
    were to provide the function with ball number 0, it would return `.solid`, and
    if we were to provide ball number 16, it would return `.stripe`, which doesn''t
    accurately reflect our intention:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，台球编号介于1到15之间，但我们在实现中并没有考虑这些上下限。所以如果我们向函数提供球号0，它将返回`.solid`，如果我们提供球号16，它将返回`.stripe`，这并不准确地反映我们的意图：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s modify our function to only return a pool ball type if the number is
    between 1 and 15, and return `nil` otherwise:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的函数，使其仅在数字介于1到15之间时返回台球类型，否则返回`nil`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we have four code branches in our `if` statement, and we can use the AND
    operator, `&&`, to combine Boolean statements (the OR operator, `||`, is also
    available).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有四个代码分支在我们的`if`语句中，我们可以使用AND运算符`&&`来组合布尔语句（也有可用的OR运算符`||`）。
- en: 'We can now call our function for both numbers within the expected 1-15 range
    and outside it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为预期范围内的数字以及范围外的数字调用我们的函数：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our improved function will produce `nil` for numbers outside of the expected
    range.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改进的函数将为预期范围之外的数字产生`nil`。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some other ways we can use if/else statements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他一些方式来使用if/else语句。
- en: Understanding conditional unwrapping
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解条件展开
- en: The function we created earlier returns an optional value, so if we want to
    do anything useful with the resulting value, we need to `unwrap` the optional.
    So far, the only way we have seen how to do this is by force unwrapping, which
    will cause a crash if the value is `nil`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的函数返回一个可选值，所以如果我们想对结果值做些有用的事情，我们需要`unwrap`可选值。到目前为止，我们看到的唯一方法是通过强制展开，如果值是`nil`，这将导致崩溃。
- en: Instead, we can use an `if` statement to *conditionally unwrap* the optional,
    turning it into a more useful, non-optional value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用一个`if`语句来**条件性地展开**可选值，将其转换为更有用的非可选值。
- en: Let's create a function that will print information about a pool ball of a given
    number. If the provided number is valid for a pool ball, it will print the ball's
    number and type; otherwise, it will print a message explaining that it is not
    a valid number.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，用于打印给定数字的台球信息。如果提供的数字适用于台球，它将打印球号和类型；否则，它将打印一条消息说明这不是一个有效的数字。
- en: 'Since we will want to print the value of the `PoolBallType` enum, let''s make
    it `String` backed, which will make printing its value easier:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望打印`PoolBallType`枚举的值，让我们将其改为`String`支持的，这将使打印其值更容易：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s write the function to print the pool ball details:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数来打印台球详细信息：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first thing we do in our `printBallDetails` function is to get the ball
    type for the given number:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`printBallDetails`函数中，我们首先获取给定数字的球类型：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our improved version of this function, this returns an optional version
    of the `PoolBallType` enum. We want to include the `rawValue` of the returned
    `enum` as part of printing the ball details. Since the returned value is optional,
    we need to unwrap it first:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们改进的函数版本中，这返回了`PoolBallType`枚举的可选版本。我们希望在打印球详细信息时包括返回的`enum`的`rawValue`。由于返回值是可选的，我们需要首先展开它：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this `if` statement, instead of defining a Boolean expression, we are assigning
    our optional value to a constant; the `if` statement uses this to *conditionally
    unwrap* the optional. The optional value is checked to see whether it is `nil`;
    if it is not `nil`, then the value is unwrapped and assigned to the constant as
    a non-optional value. That constant becomes available within the scope of the
    curly brackets following the `if` statement. We use that `ballType` non-optional
    value to obtain the raw value for the `print` statement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `if` 语句中，我们不是定义一个布尔表达式，而是将我们的可选值赋给一个常量；`if` 语句使用这个常量来 *条件性地解包* 可选值。可选值被检查以确定它是否为
    `nil`；如果不是 `nil`，则值被解包并赋给常量作为非可选值。这个常量在 `if` 语句后面的花括号作用域内可用。我们使用这个 `ballType`
    非可选值来获取 `print` 语句的原始值。
- en: Since the `if` branch of the `if-else` statement is followed when the optional
    value has a value, then the `else` branch is followed when the optional value
    is `nil`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当可选值有值时跟随 `if-else` 语句的 `if` 分支，那么当可选值为 `nil` 时，就跟随 `else` 分支。
- en: 'As this means that the given number is not valid for a pool ball, we print
    a relevant message:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这意味着给定的数字对于球桌球来说不是有效的，我们打印一条相关的消息：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now call our new function with the same values as before to print out
    the pool ball type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用之前相同的值来调用我们的新函数，以打印出球桌球类型：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've used conditional unwrapping to print the pool ball type, if valid, or
    explain it's not valid.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用条件解包来打印球桌球类型，如果有效，或者解释它为什么无效。
- en: Chaining optional unwrapping
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链式可选解包
- en: The ability of `if` statements to conditionally unwrap optionals can be chained
    together to produce some useful and concise code. The following example is a bit
    contrived, but it illustrates how we can use a single `if` statement to unwrap
    a chain of optional values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句能够条件性地解包可选值的能力可以链式组合起来，生成一些有用且简洁的代码。以下示例可能有些牵强，但它说明了我们如何使用单个 `if` 语句来解包一系列可选值。'
- en: When you play a game of pool, called a *frame*, the type of the first ball you
    pot becomes the type you need to pot for the rest of the frame, and your opponent
    has to pot the opposite type.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩一局斯诺克，称为 *frame*，你第一个入袋的球类型将成为整个帧中你需要入袋的类型，而你的对手则需要入袋相反类型的球。
- en: 'Let''s define a frame of pool and say that we want to track what type of ball
    each player will be potting:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个斯诺克帧，并说我们想要跟踪每个玩家将要入袋的球类型：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will also create a `PoolTable` object that has an optional `currentFrame`
    property, which will contain information about the current frame if one is in
    progress:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个具有可选的 `currentFrame` 属性的 `PoolTable` 对象，该属性将包含有关当前帧的信息，如果正在进行的话：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a pool table that has an optional frame and a frame that has an
    optional ball type for each player.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个球桌，它有一个可选的帧，每个玩家都有一个可选的球类型。
- en: 'Now, let''s write a function that prints the ball type for player 1 in the
    current frame. It is possible that the current frame is `nil` because there is
    no frame currently being played, or that player 1''s ball type is `nil` because
    a ball hasn''t yet been potted. Therefore, we need to account for either of those
    being `nil`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数来打印当前帧中玩家 1 的球类型。当前帧可能是 `nil`，因为没有正在进行的帧，或者玩家 1 的球类型是 `nil`，因为还没有入袋的球。因此，我们需要考虑这两种情况中的任何一种：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our function is given a `PoolTable`, and to print player 1's ball type, we first
    need to check and unwrap the `currentFrame` property, and then we need to check
    and unwrap the current frame's `player1BallType` property.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数接收一个 `PoolTable`，要打印玩家 1 的球类型，我们首先需要检查并解包 `currentFrame` 属性，然后我们需要检查并解包当前帧的
    `player1BallType` 属性。
- en: 'We could do this by nesting our `if` statements:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过嵌套我们的 `if` 语句来实现这一点：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead, we can handle this chained unwrapping in one `if` statement by performing
    the unwrapping statement sequentially, separated by commas, and each statement
    can access the unwrapped values from the previous statements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以通过按顺序执行解包语句（用逗号分隔）来在一个 `if` 语句中处理这种链式解包，每个语句都可以访问前一个语句解包的值：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first statement unwraps the `currentFrame` property, and the second statement
    uses that unwrapped frame to unwrap player 1's ball type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句解包了 `currentFrame` 属性，第二个语句使用这个解包的帧来解包玩家 1 的球类型。
- en: 'Let''s use the function we''ve just created:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们刚刚创建的函数：
- en: 'First, we''ll create a table, and without a current frame print player 1''s
    ball type, which won''t be available:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个表格，并且在没有当前帧的情况下打印玩家 1 的球类型，这将不可用：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we can create a current frame, but as player 1''s ball type is still
    `nil`, the function prints the same output:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个当前帧，但由于玩家1的球类型仍然是`nil`，函数会打印出相同的输出：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we set player 1''s ball type, now our function prints the type:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们设置玩家1的球类型，现在我们的函数会打印出类型：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've created a method that can chain conditional unwrappings, only printing
    a value when all the values in the chain are non-nil.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一种方法，可以链式调用条件展开，只有当链中的所有值都不是nil时才打印一个值。
- en: Using enums with associated values
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用具有关联值的枚举
- en: As we saw in the *Enumerating values with enums* recipe from [Chapter 1](f9d48715-ffca-464f-95bf-722958f02e72.xhtml),
    *Swift Building Blocks*, enums can have associated values, and we can use an `if`
    statement to both check an enum's case and extract the associated value in one
    expression.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](f9d48715-ffca-464f-95bf-722958f02e72.xhtml)的*使用枚举枚举值*菜谱中看到的，*Swift
    Building Blocks*，枚举可以有关联值，我们可以使用`if`语句在一个表达式中同时检查枚举的case并提取关联值。
- en: 'Let''s create an enum to represent the result of the pool game, with each case
    having an associated message:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个枚举来表示台球游戏的结果，每个case都有一个关联的消息：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we''ll create a function that takes a `Result` and prints either the
    congratulatory message or the commiseration message:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数，它接受一个`Result`并打印祝贺消息或慰问消息：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Calling this function will print the result, followed by the relevant message:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数将打印结果，然后是相关的消息：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `if case` block will be executed if the value on the right-hand side of
    the `=` matches the case on the left-hand side. In addition, you can specify a
    local constant for the associated value (`winMessage` in the following example),
    which is then available within the subsequent block:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`=`右侧的值与左侧的case匹配，则将执行`if case`块。此外，你可以指定一个局部常量来表示关联值（以下示例中的`winMessage`），然后在后续块中可用：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've used the `if case` statement to both check the case of an enum value and
    access its associated value in one go.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`if case`语句一次性检查枚举值的case并访问其关联值。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Further information about if/else can be found in Apple's documentation on the
    Swift language at [http://swiftbook.link/docs/statements.](http://swiftbook.link/docs/statements)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于if/else的更多信息可以在苹果关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/statements](http://swiftbook.link/docs/statements)。
- en: Handling all cases with switch
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用switch处理所有情况
- en: '`switch` statements allow you to control the flow of execution by testing one
    specific value in multiple ways. In Objective-C and other languages, `switch`
    statements can only be used on values that can be represented by an integer, and
    are most commonly used to make decisions based on enumeration cases.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句允许你通过多种方式测试一个特定的值来控制执行流程。在Objective-C和其他语言中，`switch`语句只能用于可以表示为整数的值，并且最常用于基于枚举案例做出决策。'
- en: As we have seen, **enumerations** have become a lot more powerful in Swift,
    as they can be based on more than just integers, and so too can `switch` statements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**枚举**在Swift中变得更加强大，因为它们可以基于不仅仅是整数，同样`switch`语句也是如此。
- en: '`switch` statements in Swift can be used on any type and have advanced pattern-matching
    functionality.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的`switch`语句可以用于任何类型，并具有高级的模式匹配功能。
- en: In this recipe, we will explore both simple and advanced usage of `switch` control
    flow statements to control logic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索`switch`控制流语句的简单和高级用法来控制逻辑。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you are old enough to remember the early days of the home computer, you may
    also remember text-based adventures. These were simple games that usually described
    a scene and then let you move around by typing a command to move north, south,
    east, or west. You would find and pick up items, and could often combine them
    to solve puzzles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够老，记得家用电脑的早期日子，你可能也会记得基于文本的冒险游戏。这些游戏通常描述一个场景，然后让你通过输入命令来移动北、南、东或西。你可以找到并捡起物品，并且通常可以将它们组合起来解决问题。
- en: We can use `switch` statements to control the logic of a simple text adventure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`switch`语句来控制简单文本冒险的逻辑。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create parts of a text-based adventure, and use `switch` statements
    to make the decisions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基于文本的冒险游戏的部分，并使用`switch`语句来做出决定：
- en: 'Define an `enum` to represent the directions we can travel in:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`enum`来表示我们可以旅行的方向：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a function that describes what the player of the text adventure will
    see when they look in that direction:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，描述玩家在朝某个方向看时将看到的内容：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In our text adventure, users can pick up items and attempt to combine them to
    produce new items and solve problems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文字冒险游戏中，用户可以捡起物品并尝试将它们组合起来以产生新的物品并解决问题。
- en: 'Define our available items as an `enum`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的可用物品定义为 `enum`：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Write a function that takes two items and tries to combine them into a new item.
    If the items cannot be combined, it will return `nil:`
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，它接受两个物品并尝试将它们组合成一个新的物品。如果物品无法组合，它将返回 `nil`：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In our text adventure, the player will meet different characters and can interact
    with them. Define the characters that the player can meet:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的文字冒险游戏中，玩家会遇到不同的角色，并且可以与他们互动。定义玩家可以遇到的角色：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Write a function that allows the player to say something, and optionally provide
    a character to whom it will be said. The interaction that will occur will depend
    on what is said and the character it is said to:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，允许玩家说些什么，并且可以选择性地提供一个角色，对他说。互动将取决于所说的内容以及所说的角色：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Within the `lookTowards` function, we want to print a different message for
    each possible `CompassPoint` case; to do this, we use a `switch` statement:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `lookTowards` 函数中，我们希望为每个可能的 `CompassPoint` 案例打印不同的消息；为此，我们使用 `switch` 语句：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At the top of the `switch` statement, we define the value that we want to switch
    on; then we define what we want to be done when that value matches each of the
    defined cases using the `case` keyword and then the matching pattern:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `switch` 语句的顶部，我们定义想要切换的值；然后我们定义当该值与定义的每个案例匹配时想要执行的操作，使用 `case` 关键字和匹配的模式：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each `case` statement is evaluated in turn, and if the pattern matches the value,
    the subsequent code is executed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `case` 语句依次评估，如果模式与值匹配，则执行后续代码。
- en: If you are familiar with `switch` statements from Objective-C, you may remember
    that you needed to add `break;` at the end of each `case` statement to stop the
    execution from falling through to the next `case` statement. This is not needed
    in Swift; the break in execution is implied by the beginning of the next `case`
    statement. The only time this isn't the case, it is because your `case` statement
    is intentionally empty; in these cases, you need to add `break` to tell the compiler
    that it is intentionally blank for this case. If you do want execution to fall
    through to the next `case` statement, you can add `fallthrough` at the end of
    the `case` statement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Objective-C 中的 `switch` 语句，你可能记得你需要在每个 `case` 语句的末尾添加 `break;` 来停止执行从下一个
    `case` 语句中掉落。在 Swift 中不需要这样做；执行的断开是由下一个 `case` 语句的开始隐含的。唯一不是这种情况的时候，是因为你的 `case`
    语句是故意为空的；在这些情况下，你需要添加 `break` 来告诉编译器它故意为这个案例留空。如果你确实想让执行掉落到下一个 `case` 语句，你可以在
    `case` 语句的末尾添加 `fallthrough`。
- en: 'In our `combine` function, we have two values that we want to switch based
    on their values. We can provide multiple values to the `switch` statement in the
    form of a tuple:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `combine` 函数中，我们有两个基于其值需要切换的值。我们可以将多个值以元组的形式提供给 `switch` 语句：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For each `case` statement, we define the valid value for each part of the tuple:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 `case` 语句，我们定义元组每个部分的合法值：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A `switch` statement in Swift requires that every possible case is covered;
    however, you can cover all the remaining possibilities in one go using the `default`
    case:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的 `switch` 语句要求覆盖所有可能的案例；然而，你可以使用 `default` 案例一次性覆盖所有剩余的可能性：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For our preceding `combine` function, you will notice that the player will
    only be able to combine the items if they provide them in the right order:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们之前的 `combine` 函数，你会注意到，玩家只有在提供正确的顺序时才能组合物品：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is not the desired behavior, as there is no way for the player to know
    the correct order. To solve this, we can add multiple patterns to each `case`
    statement. So, when the player provides the `key` and `lockedDoor` items, we can
    handle the order `key`, `lockedDoor`, and the order `lockedDoor`, `key` with the
    same `case` statement, using the following format:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是期望的行为，因为玩家无法知道正确的顺序。为了解决这个问题，我们可以在每个 `case` 语句中添加多个模式。因此，当玩家提供 `key` 和 `lockedDoor`
    物品时，我们可以使用相同的 `case` 语句处理 `key`，`lockedDoor` 的顺序和 `lockedDoor`，`key` 的顺序，格式如下：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, we can add the opposite item order as another pattern to each case:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将相反的物品顺序作为另一个模式添加到每个案例中：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now the items can be combined in any order:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在物品可以以任何顺序组合：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For our `say` method, we again have two values that we want to switch on: the
    text that the player says, and the character to whom it is said. Since the `character`
    value is optional, we will need to unwrap the value to compare it with non-optional
    values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`say`方法，我们再次有两个值想要切换：玩家说的文本和所说的角色。由于`character`值是可选的，我们需要展开值以与非可选值进行比较：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In a `switch` statement, when the value is optional, you can compare it to a
    non-optional value by adding a `?` to wrap it as an optional, making the comparison
    valid. In the preceding instance, we are comparing the optional `character` value
    to `.wizard?`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`语句中，当值是可选的，你可以通过添加`?`将其包装为可选值来将其与非可选值进行比较，使比较有效。在上一个例子中，我们正在将可选的`character`值与`.wizard?`进行比较。
- en: 'Where we have two values for a certain set of options, we may only care about
    one of the values, and the other value could be anything and the case would still
    be valid. In our example, once all the specific `textToSay` and character pairings
    have been handled, and the case where there is no character is handled, we want
    to unwrap and retrieve the character, but we don''t care about the `textToSay`
    value, so we can use `_` to indicate that any value is acceptable:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当对于一组特定选项有两个值时，我们可能只关心其中一个值，另一个值可以是任何值，并且情况仍然有效。在我们的例子中，一旦处理了所有特定的`textToSay`和字符配对，以及处理了没有字符的情况，我们想要展开并检索字符，但我们不关心`textToSay`的值，因此我们可以使用`_`来表示任何值都是可接受的：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To retrieve the value of the character entered as part of this `case` statement
    rather than declaring a value to be matched, we define a constant that will receive
    the value, and since the value we are switching on is optional, we also add `?`,
    which will unwrap the value if not `nil`, and assign it to the constant.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索作为此`case`语句一部分输入的字符值，而不是声明一个要匹配的值，我们定义一个将接收值的常量，并且由于我们正在切换的值是可选的，我们也添加了`?`，如果值不是`nil`，它将展开值并将其分配给常量。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about `switch` can be found in Apple's documentation on
    the Swift language at [http://swiftbook.link/docs/switch](http://swiftbook.link/docs/switch).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`switch`的信息可以在苹果关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/switch](http://swiftbook.link/docs/switch)。
- en: Looping with for loops
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`for`循环进行循环
- en: '`for` loops allow you to execute code for each element in a collection or range.
    In this recipe, we will explore how to use `for` loops to perform actions on every
    element in a collection.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环允许你对集合或范围中的每个元素执行代码。在本食谱中，我们将探讨如何使用`for`循环对集合中的每个元素执行操作。'
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create some collections and then use `for` loops to act on each element
    in the collection:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些集合，然后使用`for`循环对集合中的每个元素进行操作：
- en: 'Create an array of elements, so we can do something with every item in the
    array:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个元素数组，这样我们就可以对数组中的每个元素进行操作：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a loop to go through our `theBeatles` array and print each string element
    that the `for` loop provides:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环来遍历我们的`theBeatles`数组，并打印出`for`循环提供的每个字符串元素：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a `for` loop that executes some code a set number of times, instead
    of looping through an array. We can do this by providing a range instead of a
    collection:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个执行固定次数代码的`for`循环，而不是遍历数组。我们可以通过提供一个范围而不是集合来实现这一点：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a `for` loop to print the keys and values of a dictionary. Dictionaries
    contain pairings between a key and a value, so when looping through a dictionary,
    we will be provided with both the key and the value in the form of a tuple:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`for`循环来打印字典的键和值。字典包含键和值的配对，因此当遍历字典时，我们将以元组的形式提供键和值：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s look at how we looped through our `theBeatles` array:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何遍历我们的`theBeatles`数组的：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We specify the `for` keyword and then we provide a name for the local variable
    that will be used for each element in the collection or range. Then, the `in`
    keyword is provided, followed by the collection or range that will be looped through:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`for`关键字，然后为将用于集合或范围中每个元素的局部变量提供一个名称。然后，提供`in`关键字，后面跟着将要遍历的集合或范围：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For range-based loops, the value provided for each loop is the next integer
    in the range:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于范围的循环，每个循环提供的值是范围内的下一个整数：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A range can be a *closed range,* where the range includes the start value and
    the end value, like the one specified above. Or it can be a *half-open range*,
    which goes up to, but doesn''t include, the last value, like the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 范围可以是一个**闭区间**，其中范围包括起始值和结束值，就像上面指定的那样。或者它可以是**半开区间**，它向上到但不包括最后一个值，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When looping through a dictionary, we need to be provided with both the key
    and value; to do this, we provide a tuple that will receive each key and value
    in the dictionary:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当遍历字典时，我们需要同时提供键和值；为此，我们提供一个元组，它将接收字典中的每个键和值：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can define the tuple and name each of the values. This name can then be
    used in an execution block. Let''s change the tuple labels to better describe
    the values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个元组并为每个值命名。这个名称随后可以在执行块中使用。让我们将元组的标签改为更好地描述这些值：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Giving the tuple meaningful names in the preceding example makes the code easier
    to read.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中给元组赋予有意义的名称使代码更容易阅读。
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料还有
- en: Further information about `for-in` loops can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/for-in](http://swiftbook.link/docs/for-in).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`for-in`循环的信息可以在Apple关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/for-in](http://swiftbook.link/docs/for-in)。
- en: Looping with while loops
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用while循环进行循环
- en: '`for` loops are great when you know how many times you intend to loop, but
    if you want to loop until a certain condition is met, you need a `while` loop.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在您知道要循环多少次时很棒，但如果您想循环直到满足某个条件，则需要使用`while`循环。'
- en: 'A `while` loop has the following syntax:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的语法如下：'
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The code block will execute over and over until the Boolean expression returns
    `false`. Therefore, it's a common pattern to change some value in the code block
    that may cause the Boolean expression to change to `false`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块将反复执行，直到布尔表达式返回`false`。因此，在代码块中更改某些值以使布尔表达式变为`false`是一种常见的模式。
- en: If there is no chance of the Boolean expression becoming `true`, the code will
    loop forever, which can lock up your app.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔表达式没有变为`true`的机会，代码将无限循环，这可能会锁定您的应用程序。
- en: In this recipe, we will look at situations where a `while` loop can be useful
    for repeating actions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨`while`循环可以用于重复操作的情况。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe will involve simulating the random flip of a coin. To flip our
    coin, we will need to randomly pick either heads or tails, so we will need to
    use a random number generator from the Foundation framework. We will discuss Foundation
    further in [Chapter 5](a632f18a-5826-4757-90bc-7701c78edaaf.xhtml), *Beyond the
    Standard Library*, but for now, we just need to import the Foundation framework
    at the top of our playground:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将涉及模拟随机抛硬币。为了抛硬币，我们需要随机选择正面或反面，因此我们需要使用来自Foundation框架的随机数生成器。我们将在[第5章](a632f18a-5826-4757-90bc-7701c78edaaf.xhtml)，*超越标准库*中进一步讨论Foundation，但到目前为止，我们只需要在playground的顶部导入Foundation框架：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This will give us the ability to generate a random number, which we will use
    now.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够生成一个随机数，我们现在将使用它。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s work out how many times in a row we can flip a coin and get heads:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来计算一下连续抛硬币得到正面的次数：
- en: 'Create an `enum` to represent a coin flip, and use the random number generator
    to randomly choose heads or tails:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示硬币抛掷的`enum`，并使用随机数生成器随机选择正面或反面：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a function that will return the number of heads in a row from coin flips.
    The function will flip the coin within a `while` loop and continue to loop while
    the coin flip results in heads:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数将返回连续抛硬币得到正面的次数。该函数将在`while`循环中抛硬币，并在硬币抛掷结果为正面时继续循环：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In our function, we start by keeping track of how many coin flips in a row
    are heads and keep a reference to the current coin flip, which will form the condition
    for the `while` loop:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数中，我们首先跟踪连续抛硬币得到正面的次数，并保留对当前硬币抛掷的引用，这将形成`while`循环的条件：
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In our `while` loop, we will continue to loop and execute the code in the following
    block while the current coin flip is heads:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`while`循环中，我们将继续循环并执行以下代码块中的代码，只要当前的硬币抛掷结果是正面：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Within the code block, we add one to our running total and we re-flip the coin.
    We are flipping the coin and assigning it to `currentCoinFlip`, which will get
    rechecked on the next loop and if it is still heads, the next loop will be executed.
    Since we are changing something that affects the `while` condition, such that
    it could eventually be `false`, we can be sure that we won't be stuck in the loop
    forever.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块中，我们将运行总金额加一，并重新翻转硬币。我们正在翻转硬币并将其分配给`currentCoinFlip`，这将在下一次循环中重新检查，如果它仍然是正面，则下一次循环将被执行。由于我们正在更改影响`while`条件的东西，这样它最终可能是`false`，我们可以确信我们不会永远卡在循环中。
- en: 'As soon as the coin flip is tails, the `while` loop condition will be `false`,
    and so the execution will move on and return the running total we have been keeping:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦硬币翻转结果为反面，`while`循环条件将为`false`，因此执行将继续并返回我们一直在保持的运行总金额：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, every time you call the function, the coin will be randomly flipped and
    the number of heads in a row will be returned, so each time it''s called, you
    may get a different value returned. Try it out a few times:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你调用该函数时，硬币都会随机翻转，并返回连续出现正面次数，所以每次调用时，你可能会得到不同的返回值。试几次看看：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There's more...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can actually simplify our `while` loop by doing the coin flip as part of
    the loop continuation checking:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以通过将硬币翻转作为循环延续检查的一部分来简化我们的`while`循环：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Each time through the loop, the `while` condition is evaluated, which involves
    re-flipping the coin and checking the outcome.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过循环时，都会评估`while`条件，这涉及到重新翻转硬币并检查结果。
- en: This is more concise and removes the need to track `currentCoinFlip`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这更简洁，并且消除了跟踪`currentCoinFlip`的需要。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about `while` loops can be found in Apple's documentation
    of the Swift language at [http://swiftbook.link/docs/while](http://swiftbook.link/docs/while).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`while`循环的信息可以在苹果公司关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/while](http://swiftbook.link/docs/while)。
- en: Handling errors with try, throw, do, and catch
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try、throw、do和catch处理错误
- en: Errors happen during programming. These errors may be due to your own code behaving
    in unexpected ways, or due to unexpected information or behavior from external
    systems. When these errors happen, it's important to handle them appropriately.
    Good error handling can separate a good app from a great app.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 编程过程中会发生错误。这些错误可能是由于你自己的代码以意想不到的方式运行，或者由于来自外部系统的意外信息或行为。当这些错误发生时，正确处理它们非常重要。良好的错误处理可以将一个优秀的应用程序与一个伟大的应用程序区分开来。
- en: Swift provides a deliberate and flexible pattern for handling errors, allowing
    specific errors to be cascaded through a complex system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Swift提供了一种故意且灵活的错误处理模式，允许特定的错误通过复杂系统级联。
- en: In this recipe, we will discover how to define errors, and throw them when necessary.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何定义错误，并在必要时抛出它们。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To examine error handling, we will model a process that can go wrong, and for
    me, that is cooking a meal:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查错误处理，我们将模拟一个可能会出错的过程，对我来说，那就是烹饪餐点：
- en: 'First, let''s define the steps involved in cooking a meal as states that the
    meal will transition through:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义烹饪餐点涉及的步骤，作为餐点将经历的状态：
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create an object to represent the meal we will be cooking. This object will
    hold the state of the meal as it moves through the process:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象来表示我们将要烹饪的餐点。该对象将持有餐点在过程中移动的状态：
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We want to allow the meal to transition between states, but not all state transitions
    should be possible. For instance, you can't move from buying ingredients to serving
    the meal. The meal should move sequentially from one state to the next. We can
    provide these restrictions by only allowing the state to be set from within the
    object itself, using access controls that we explored in the previous chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望允许餐点在状态之间转换，但并非所有状态转换都是可能的。例如，你不能从购买食材直接过渡到上菜。餐点应该按顺序从一个状态转换到下一个状态。我们可以通过只允许在对象内部设置状态来提供这些限制，使用我们在上一章中探讨的访问控制。
- en: 'Define the `state` property as only being privately settable:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`state`属性定义为只能私有设置：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To allow the state to be changed from outside the object, create a function
    that will throw an error if the state transition isn''t possible:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许从对象外部更改状态，创建一个函数，如果状态转换不可行，则抛出错误：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In keeping with Swift's protocol-orientated approach, errors in Swift are defined
    as a protocol, `Error`. This approach allows you to construct your own type to
    represent errors within your code, and just have it conform to the `Error` protocol.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 Swift 的协议导向方法，Swift 中的错误被定义为协议，即 `Error` 协议。这种方法允许你创建自己的类型来表示代码中的错误，并且只需让它符合
    `Error` 协议即可。
- en: A common approach is to define errors as enums, with the enum cases representing
    the different types of errors that can occur.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的做法是将错误定义为枚举，枚举的案例代表可能发生的不同类型的错误。
- en: 'Define the error thrown in the preceding `Meal` class:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义前面 `Meal` 类中抛出的错误：
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Try to execute our error throwing method within a `do` block and catch any
    errors that may occur:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在一个 `do` 块中执行我们的错误抛出方法并捕获可能发生的任何错误：
- en: '[PRE66]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The metaphor used in Swift error handling (as well as other languages) is *throwing*
    and *catching*. A method can *throw* an error if a problem occurs during its execution,
    at which point nothing further in the method will be executed, and the error is
    passed back to where the method was called from.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 错误处理中使用的隐喻（以及其他语言）是 *抛出* 和 *捕获*。如果一个方法在执行过程中遇到问题，它可以 *抛出* 一个错误，此时方法中的其他代码将不会执行，错误将被传递回方法被调用的地方。
- en: In order to receive this error (perhaps to provide the details of the error
    to the user), you must *catch* the error at the place the method is called.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收这个错误（可能为了向用户提供错误的详细信息），你必须在方法被调用的地方 *捕获* 这个错误。
- en: To throw an error, you have to declare that the method has the potential to
    throw an error. Declaring that a method `throws` allows the compiler to expect
    potential errors from the method and ensure that you don't forget to catch these
    errors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要抛出一个错误，你必须声明该方法有抛出错误的可能性。声明一个方法 `throws` 允许编译器期望方法中可能出现的错误，并确保你不会忘记捕获这些错误。
- en: 'Methods can be declared as potentially throwing an error using the `throws`
    keyword:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `throws` 关键字声明方法可能抛出错误：
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Within our change state method, we only change the state if we are moving to
    the next sequential state. Anything else isn''t allowed and should throw an error.
    We can do this using the `throw` keyword, followed by a value that conforms to
    the `Error` protocol:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的状态转换方法中，我们只有在移动到下一个顺序状态时才会改变状态。其他任何操作都是不允许的，应该抛出一个错误。我们可以使用 `throw` 关键字，后跟一个符合
    `Error` 协议的值来完成这个操作：
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When we create the `Meal` object and move through the states of preparing the
    meal, each change of state can throw an error. When we call a method that is marked
    as possibly throwing an error, we have to do it a certain way. We define a `do`
    block, within which we may call methods that can throw, and we then define a `catch`
    block that will be executed if any of these methods do throw an error. Each call
    to a throwing method must be prefixed with the `try` keyword:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `Meal` 对象并遍历准备餐点的状态时，每个状态的变化都可能抛出一个错误。当我们调用标记为可能抛出错误的函数时，我们必须以某种方式执行。我们定义一个
    `do` 块，在其中我们可以调用可能抛出的方法，然后定义一个 `catch` 块，如果这些方法中的任何一个抛出错误，它将被执行。每个抛出方法的调用都必须以
    `try` 关键字为前缀：
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If any of these methods does throw an error, execution will immediately move
    to the `catch` block. Therefore, by placing code after the `try` methods are called,
    we are guaranteeing that it will only be executed if the methods do not throw
    an error. By printing `Dinner is served!` after all the state transitions are
    called, we know this will only print if we have successfully moved through all
    the states. Try changing the order of these state change calls, and you'll see
    that the error is printed, and `Dinner is served!` is not.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些方法中的任何一个抛出错误，执行将立即转移到 `catch` 块。因此，通过在 `try` 方法调用之后放置代码，我们确保只有在方法没有抛出错误的情况下才会执行这些代码。在所有状态转换调用之后打印
    `Dinner is served!`，我们知道这只会打印出来，如果我们已经成功通过了所有状态。尝试改变这些状态转换调用的顺序，你会看到错误会被打印出来，而
    `Dinner is served!` 不会。
- en: 'In our `catch` block, after the `catch` keyword, we can define the local constant
    that we want the caught error to be assigned to. However, if we don''t specify
    a local constant here, Swift will implicitly create one for us called `error`,
    so we can actually omit the constant declaration in the `catch` block and still
    print the value of the error:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `catch` 块中，在 `catch` 关键字之后，我们可以定义想要将捕获的错误分配到的局部常量。然而，如果我们在这里没有指定局部常量，Swift
    会隐式地为我们创建一个名为 `error` 的常量，因此我们实际上可以在 `catch` 块中省略常量声明并仍然打印错误的值：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Swift has defined the error for us, so we can still print the value.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 已经为我们定义了错误，所以我们仍然可以打印其值。
- en: There's more...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have seen how we can throw and catch errors, but we mentioned in the introduction
    that we can cascade errors through a system, so let's look at how we can do this.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何抛出和捕获错误，但在介绍中我们提到我们可以通过系统级联错误，所以让我们看看我们如何做到这一点。
- en: 'In our meal preparation example, we allow the meal state to be changed externally
    through a `change` method that can throw an error. Instead, let''s change it to
    a private method, so we can only call it from within the class:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的餐点准备示例中，我们允许通过可以抛出错误的 `change` 方法从外部更改餐点状态。相反，让我们将其更改为私有方法，这样我们就只能从类内部调用它：
- en: '[PRE71]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, let''s create some specific methods for moving to each state:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些具体的方法来移动到每个状态：
- en: '[PRE72]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You'll notice that when we call the `change` method from within each of the
    new methods, we don't need to use a `do` and `catch` block to catch the error;
    this is because we have defined each of the new methods as potentially throwing
    an error, so if the call to the `change` method throws an error, this error will
    be passed to the caller of our new method as though it were throwing an error.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当我们从每个新方法内部调用 `change` 方法时，我们不需要使用 `do` 和 `catch` 块来捕获错误；这是因为我们已经将每个新方法定义为可能抛出错误的，所以如果
    `change` 方法的调用抛出错误，这个错误将作为抛出错误传递给我们的新方法的调用者。
- en: This mechanism allows errors that may occur many levels deep in your code to
    surface and be handled appropriately.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制允许在代码的多个层级中可能发生的错误暴露出来并得到适当的处理。
- en: 'We now need to amend our meal preparation code to use these new methods:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改我们的餐点准备代码以使用这些新方法：
- en: '[PRE73]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s add the ability to actually affect our meal. We''ll add a method to
    add salt to the meal and a property to allow us to track how much salt is added.
    Add these to the end of the `Meal` class:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加实际影响我们的餐点的功能。我们将添加一个向餐点中加盐的方法和一个属性，以便我们可以跟踪添加了多少盐。将这些添加到 `Meal` 类的末尾：
- en: '[PRE74]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'There are two ways in which adding salt can throw an error, either because
    we are in the wrong state to add salt (we can''t add salt until after we have
    bought the ingredients), or because we have added too much salt. Let''s add these
    two new errors to our `MealError` enum:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 添加盐分可能导致两种错误，要么是因为我们处于不适合添加盐的状态（我们只能在购买食材之后才能添加盐），要么是因为我们添加了过多的盐。让我们将这些两个新的错误添加到我们的
    `MealError` 枚举中：
- en: '[PRE75]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We now have three possible errors that can occur during the preparation of
    a meal, and we may want to handle those errors differently. We can use multiple
    `catch` blocks to filter just specific errors that we want to catch, allowing
    us to handle each error separately:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三种可能发生在准备餐点过程中的错误，我们可能希望以不同的方式处理这些错误。我们可以使用多个 `catch` 块来过滤仅特定的错误，这样我们就可以单独处理每个错误：
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It is important to ensure that all possible errors are handled by the `catch`
    blocks, as an unhandled error will result in a crash. It is, therefore, safest
    to add an unfiltered `catch` block at the end to catch any errors not caught by
    the previous blocks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有可能的错误都被 `catch` 块处理非常重要，因为未处理的错误会导致程序崩溃。因此，最安全的方法是在最后添加一个未过滤的 `catch` 块来捕获之前块未捕获的任何错误。
- en: Since functions can throw an error, and closures are a type of function that
    can be passed as a parameter, we can have a function that takes a throwing closure
    where it can also throw an error. It may be that the only errors our function
    will throw are errors produced by the throwing closure that was passed as a parameter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以抛出错误，而闭包是一种可以作为参数传递的函数类型，因此我们可以有一个接受抛出闭包的函数，其中它也可以抛出错误。可能的情况是，我们的函数将抛出的唯一错误是由作为参数传递的抛出闭包产生的错误。
- en: When that is true, a function can be defined as re-throwing, using the `rethrows`
    keyword.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当这是真的时，可以使用 `rethrows` 关键字定义一个函数作为重新抛出。
- en: 'This situation is quite confusing, so let''s look at an example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况相当令人困惑，所以让我们看看一个例子：
- en: '[PRE77]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This `makeMeal` function takes a closure as a parameter; that closure takes
    a `Meal` object as a parameter and doesn't return anything, but may throw an error.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `makeMeal` 函数接受一个闭包作为参数；这个闭包接受一个 `Meal` 对象作为参数，并且不返回任何内容，但可能会抛出错误。
- en: 'The purpose of this function is to handle the creation of the `meal` object
    for you, just leaving you to do any meal preparation within the block; it then
    returns the meal that was created and prepared. Let''s see it in use:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的目的是为你处理 `meal` 对象的创建，只让你在块内进行任何餐点准备；然后它返回创建并准备好的餐点。让我们看看它是如何使用的：
- en: '[PRE78]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `makeMeal` function only throws errors thrown by the closure parameter,
    so it can be declared as re-throwing. Declaring a function of this type with the
    `rethrows` keyword isn't required, it can be declared with `throws` instead. However,
    the compiler can make additional optimizations for a re-throwing function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeMeal`函数只抛出闭包参数抛出的错误，因此它可以声明为重新抛出。使用`rethrows`关键字声明这种类型的函数不是必需的，可以用`throws`来声明。然而，编译器可以为重新抛出函数进行额外的优化。'
- en: See also
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about error handling can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/error-handling](http://swiftbook.link/docs/error-handling).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于错误处理的信息可以在Apple关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/error-handling](http://swiftbook.link/docs/error-handling)。
- en: Checking upfront with guard
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`guard`语句提前检查
- en: 'We have seen in previous recipes how we can use `if` statements to check Boolean
    expressions and unwrap optional values. It''s a common use case to want to do
    some checks and conditional unwrapping at the beginning of a block of code, and
    then only execute the subsequent code if everything is as expected. This usually
    results in wrapping the whole block of code in an `if` statement:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看到了如何使用`if`语句来检查布尔表达式和展开可选值。在代码块的开头进行一些检查和条件展开是一个常见的用例，然后只有在一切如预期的情况下才执行后续代码。这通常会导致将整个代码块包裹在一个`if`语句中：
- en: '[PRE79]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Swift has a better solution expressly for this purpose; the `guard` statement.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Swift有一个专门为此目的的更好解决方案；`guard`语句。
- en: In this recipe, we will learn how to use the `guard` statement to return early
    from a method.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用`guard`语句从方法中提前返回。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's imagine that we have some data that came from an external source, and
    we want to turn it into model objects that our code can understand, with the intention
    of displaying it to the user. We can use `guard` statements to ensure the data
    is correctly formatted, bailing early if it isn't.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一些来自外部来源的数据，我们希望将其转换为我们的代码可以理解的模型对象，目的是将其显示给用户。我们可以使用`guard`语句来确保数据格式正确，如果不正确则提前退出。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will take some information about the planets of the solar system, which
    could have come from an external source, and turn it into a model we can understand:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将取一些关于太阳系行星的信息，这些信息可能来自外部来源，并将其转换为我们可以理解的模型：
- en: 'Create the planet data in the form of an array of dictionaries:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以字典数组的形式创建行星数据：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Define a `Planet` struct that will be created from the data:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`Planet`结构体，它将根据数据创建：
- en: '[PRE81]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Taking this one step at a time, create a function that will take one-planet
    dictionaries and make a `Planet` struct, if it can. We''ll use a `guard` statement
    to ensure that the dictionary has all the values we expect:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一步一步来，创建一个函数，该函数将接受单个行星字典并创建一个`Planet`结构体，如果可能的话。我们将使用`guard`语句来确保字典包含我们期望的所有值：
- en: '[PRE82]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now that we can handle individual planet data, create a function that will
    take an array of planet dictionaries and make an array of `Planet` structs, using
    a `guard` statement to ensure that we successfully create a `Planet` struct:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们能够处理单个行星数据，创建一个函数，该函数将接受一个行星字典数组并生成一个`Planet`结构体的数组，使用`guard`语句来确保我们成功创建一个`Planet`结构体：
- en: '[PRE83]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `guard` statement works in a very similar way to an `if` statement, as
    optional values can be unwrapped and chained together in the same way. Since our
    planet data contains strings, ints, floats, and Booleans, the dictionary is of
    the `[String: Any]` type. So, to create our `Planet` struct, we will need to check
    if the expected values exist for given keys and cast them to the correct type.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard`语句的工作方式与`if`语句非常相似，因为可选值可以以相同的方式展开和链接。由于我们的行星数据包含字符串、整数、浮点数和布尔值，字典的类型是`[String:
    Any]`。因此，为了创建我们的`Planet`结构体，我们需要检查给定键的预期值是否存在，并将它们转换为正确的类型。'
- en: 'In our `makePlanet` function, we use the `guard` keyword and then access and
    conditionally cast all the values we require from the planet data dictionary.
    If any of these conditional casts fail, the `else` block, which is defined after
    the `guard` statement, is executed. We have defined our function to return an
    optional `Planet`, so if we don''t have the information expected, the `guard`
    will fail, and return `nil`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`makePlanet`函数中，我们使用`guard`关键字，然后从行星数据字典中访问和条件地转换我们所需的所有值。如果这些条件转换中的任何一个失败，那么在`guard`语句之后定义的`else`块将被执行。我们定义我们的函数返回一个可选的`Planet`，所以如果我们没有预期的信息，`guard`将失败，并返回`nil`：
- en: '[PRE84]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Any value unwrapped by the `guard` statement is made available to any code below
    the `guard` statement in the same scope; this makes the `guard` statement perfect
    for ensuring that input values are as expected before continuing. This removes
    the need to nest our code within an `if` block. The unwrapped values are then
    used to initialize the `Planet` struct.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard`语句解包的任何值都可在同一作用域内`guard`语句下面的任何代码中使用；这使得`guard`语句非常适合在继续之前确保输入值符合预期。这消除了在`if`块内嵌套代码的需要。解包的值随后用于初始化`Planet`结构体。'
- en: As we have seen, a `guard` statement is for breaking execution when the `guard`
    condition fails, and therefore, the compiler ensures that an execution breaking
    statement is placed in the `else` block; this could be, for example, `return`,
    `break`, or `continue`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`guard`语句用于在`guard`条件失败时中断执行，因此编译器确保在`else`块中放置一个中断执行的语句；这可以是，例如，`return`、`break`或`continue`。
- en: 'In the `makePlanets` function, we use a `for` loop to iterate through the dictionaries
    and try to create a `Planet` struct from each one. If our `makePlanet` call returns
    `nil`, we call `continue` to skip this iteration of the `for` loop and jump to
    the next iteration:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在`makePlanets`函数中，我们使用`for`循环遍历字典，并尝试从每个字典中创建一个`Planet`结构体。如果我们的`makePlanet`调用返回`nil`，我们调用`continue`来跳过这个`for`循环的迭代，并跳到下一个迭代：
- en: '[PRE85]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: There's more...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `makePlanets` function accepts an array of planet data dictionaries and
    returns an array of `Planet` structs. If the array provided is empty, we may decide
    that this is not a valid input to our function and we want to throw an error;
    `guard` can help with this too.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`makePlanets`函数接受一个包含行星数据字典的数组，并返回一个`Planet`结构体的数组。如果提供的数组为空，我们可能决定这不是我们函数的有效输入，并且我们想要抛出一个错误；`guard`也可以帮助做到这一点。'
- en: 'We can check that any conditional statement is true with `guard` and if it
    isn''t, we can throw an error:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`guard`检查任何条件语句是否为真，如果不是，我们可以抛出一个错误：
- en: '[PRE86]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: See also
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about `guard` statements can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/guard](http://swiftbook.link/docs/guard).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`guard`语句的更多信息可以在Apple关于Swift语言的文档中找到，链接为[http://swiftbook.link/docs/guard](http://swiftbook.link/docs/guard)。
- en: Doing it later with defer
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用defer延迟执行
- en: 'Typically, when we call a function, control passes from the call site to the
    function, then the statements within the function are executed sequentially until
    either the end of the function or until a `return` statement. Control then returns
    to the call site. In the following diagram, the `print` statements are executed
    in the order 1, 2, then 3:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们调用一个函数时，控制从调用站点传递到函数，然后函数内的语句按顺序执行，直到函数的末尾或直到出现`return`语句。然后控制返回到调用站点。在以下图中，`print`语句按顺序1、2、然后3执行：
- en: '![](img/53322170-0383-4db5-8c1b-b5714aba0dd4.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53322170-0383-4db5-8c1b-b5714aba0dd4.png)'
- en: Figure 3.2 – print statement
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – print语句
- en: 'Sometimes, it can be useful to execute some code after the function has returned,
    but before control has been returned to the call site. This is the purpose of
    Swift''s `defer` statement. In the following example, step 3 is executed after
    step 2, even though it is defined above it:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在函数返回后但在控制返回到调用站点之前执行一些代码可能很有用。这是Swift的`defer`语句的目的。在以下示例中，步骤3在步骤2之后执行，即使它定义在步骤2之上：
- en: '![](img/54fba059-3c39-42fb-b646-f9114dbeaee3.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54fba059-3c39-42fb-b646-f9114dbeaee3.png)'
- en: Figure 3.3 – defer statement
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – defer语句
- en: In this recipe, we will explore how to use `defer`, and when it can be helpful.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何使用`defer`，以及它在什么情况下可能有用。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A `defer` statement can be useful to change the state once a function's execution
    is complete or to clean up values that are no longer needed. Let's look at an
    example of updating the state with a `defer` statement.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`语句在函数执行完成后更改状态或清理不再需要的值时非常有用。让我们看看使用`defer`语句更新状态的例子。'
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Imagine that we have movie reviews with star ratings, and we want to classify
    them based on their star rating:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一些带有星级评分的电影评论，我们想要根据它们的星级评分对它们进行分类：
- en: 'Define the options that a movie review may be classified into:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义电影评论可能被分类为的选项：
- en: '[PRE87]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Create an object to do the classification:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于分类的对象：
- en: '[PRE88]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Use the classifier to classify the review:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分类器对评论进行分类：
- en: '[PRE89]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This works great, but for the purpose of this example, let's imagine that this
    classification was a long-running process, and we wanted to keep track of the
    state of the classifier, so we can externally check if the classifier was in the
    middle of classifying or was completed.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但为了本例的目的，让我们假设这个分类是一个长时间运行的过程，我们想要跟踪分类器的状态，以便我们可以外部检查分类器是否正在分类过程中或已完成。
- en: 'Define the possible classification states:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义可能的分类状态：
- en: '[PRE90]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Update our classifier class to hold and update the state, using a `defer` statement
    to move to the complete state:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的分类器类以保存和更新状态，使用 `defer` 语句将状态移动到完成状态：
- en: '[PRE91]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Use the classifier to classify the review and check the state:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分类器对评论进行分类并检查状态：
- en: '[PRE92]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: How it works...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `classify` method we defined above takes an input rating and then returns
    `MovieReviewClass` based on this rating:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面定义的 `classify` 方法接受一个输入评分，然后根据这个评分返回 `MovieReviewClass`：
- en: '[PRE93]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'While doing that, it also updates a `state` value to indicate where the method
    is in the classification process:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作的同时，它还会更新一个 `state` 值，以指示方法在分类过程中的位置：
- en: '[PRE94]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `defer` statement allows the state to be updated once the method has returned.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 语句允许在方法返回后更新状态。'
- en: 'If we were to write this method without the `defer` statement, we would have
    to transition to the `complete` state within each branch of the `if` statement
    before returning a value, as nothing after this will be executed. The end of that
    method will look as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用 `defer` 语句来编写这个方法，我们必须在返回值之前的每个 `if` 语句分支中转换到 `complete` 状态，因为在此之后将不会执行任何操作。该方法的结尾将如下所示：
- en: '[PRE95]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This repetition of updating the state can be avoided when we use the `defer`
    statement:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `defer` 语句时，可以避免这种更新状态的重复：
- en: '[PRE96]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: To defer code, simply use the `defer` keyword, with the code to be deferred
    defined in curly brackets; this code will be run after the method has returned,
    but before the control flow is returned to the caller.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要延迟代码，只需使用 `defer` 关键字，并将要延迟的代码定义在大括号内；这段代码将在方法返回后、控制流返回给调用者之前运行。
- en: There's more...
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can define multiple `defer` statements within a method, and they are executed
    in the reverse order that they were defined, so the last `defer` statement defined
    is the first one executed after the method returns.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在方法中定义多个 `defer` 语句，并且它们将按照它们定义的相反顺序执行，所以最后定义的 `defer` 语句是在方法返回后首先执行的一个。
- en: 'To demonstrate, add a new state that we''ll switch to when completing classifications
    subsequent to the first:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，添加一个新的状态，当完成第一次分类之后的分类时，我们将切换到该状态：
- en: '[PRE97]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, let''s amend our classifier to keep track of the number of classifications
    it makes and changes to the `completeAgain` state if more than one classification
    has been completed:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们的分类器以跟踪其进行的分类数量，并在完成超过一个分类时将其更改为 `completeAgain` 状态：
- en: '[PRE98]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now change how we use the classifier; the second time we use it, it will complete
    with a different state:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更改我们使用分类器的方式；第二次使用它时，它将以不同的状态完成：
- en: '[PRE99]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Since we have now defined two `defer` statements, let''s take another look
    to understand the order in which they are executed:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经定义了两个 `defer` 语句，让我们再次查看它们的执行顺序：
- en: '[PRE100]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: As discussed earlier, the last defined `defer` statement is executed first.
    So on the first classification, once the method returns, the last `defer` statement
    is executed and the state is changed to `complete`, because `numberOfClassifications`
    will be `0`. Next, the first `defer` statement is executed, which adds `1` to
    the `numberOfClassifications` variable, which will now be `1`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，最后定义的 `defer` 语句首先执行。因此，在第一次分类中，一旦方法返回，最后一个 `defer` 语句将执行，状态将更改为 `complete`，因为
    `numberOfClassifications` 将为 `0`。接下来，第一个 `defer` 语句执行，将 `1` 添加到 `numberOfClassifications`
    变量中，这将现在是 `1`。
- en: On the second classification, once the method returns, the last `defer` statement
    will execute and change the state to `completeAgain` since `numberOfClassifications`
    is greater than `0`. Finally, the first `defer` statement will execute, incrementing
    `numberOfClassifications` and making it `2`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次分类中，一旦方法返回，最后一个 `defer` 语句将执行并将状态更改为 `completeAgain`，因为 `numberOfClassifications`
    大于 `0`。最后，第一个 `defer` 语句将执行，增加 `numberOfClassifications` 的值，使其变为 `2`。
- en: If the `defer` statements had been the other way around, the state would always
    change to `completeAgain`, as `numberOfClassifications` would have incremented
    to `1` before the check was made.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`defer`语句的顺序相反，状态将始终变为`completeAgain`，因为`numberOfClassifications`会在检查之前增加到`1`。
- en: See also
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about `defer` statements can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/defer](http://swiftbook.link/docs/defer).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`defer`语句的更多信息可以在苹果关于Swift语言的文档中找到，请访问[http://swiftbook.link/docs/defer](http://swiftbook.link/docs/defer)。
- en: Bailing out with fatalError and precondition
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fatalError和precondition退出
- en: 'It''s comforting to think that in the code you write, everything will always
    happen as expected, and your program can handle any eventuality. However, sometimes
    things can go wrong – really wrong. A situation could arise that you know is possible
    but don''t expect to ever happen, and the program should terminate if it does.
    In this recipe, we will look at two issues like this: `fatalError` and `precondition`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 想到你写的代码中，一切都会如预期发生，并且你的程序可以处理任何事件，这是令人欣慰的。然而，有时事情可能会出错——真的会出错。可能会出现一种你知道是可能的但从未期望发生的情况，如果发生，程序应该终止。在这个菜谱中，我们将探讨这类问题：`fatalError`和`precondition`。
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's reuse our example from the previous recipe; we have an object that can
    be used to classify movie reviews based on how many stars out of 10 the review
    gave the movie. However, let's simplify its use, and say that we only intend for
    a classifier object to classify one, and only one, movie review.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重用之前的示例；我们有一个可以根据评论中给出的10颗星中的多少颗来对电影评论进行分类的对象。然而，让我们简化它的使用，并说我们只打算让分类器对象对一部电影评论进行一次分类。
- en: How to do it...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s set up our movie classifier to only be used once, and only accept ratings
    out of 10:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置我们的电影分类器，使其只能使用一次，并且只能接受10分制的评分：
- en: 'Define the classification state and the movie review class:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义分类状态和电影评论类：
- en: '[PRE101]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Redefine our classifier object, using `precondition` and `fatalError` to indicate
    situations that are not expected to occur and would cause a problem:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`precondition`和`fatalError`重新定义我们的分类器对象，以指示那些不应该发生且会导致问题的情形：
- en: '[PRE102]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How it works...
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We only want to use the classifier once; therefore, when we begin to classify
    a movie review, the current state should be `initial` as this object has never
    classified before and shouldn''t be in the middle of classifying. If that is not
    the case, the classifier is being used incorrectly, and we should terminate the
    execution of the code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想使用分类器一次；因此，当我们开始对电影评论进行分类时，当前状态应该是`initial`，因为这个对象之前从未进行过分类，不应该处于分类的中间状态。如果不是这种情况，分类器正在被错误地使用，我们应该终止代码的执行：
- en: '[PRE103]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We state a precondition using the `precondition` keyword, provide a Boolean
    statement that we expect to be true, and an optional message. If this Boolean
    statement is not true, the execution of the code will terminate and the message
    will be displayed in the console.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`precondition`关键字声明一个前置条件，提供一个我们期望为真的布尔语句和一个可选的消息。如果这个布尔语句不为真，代码的执行将终止，并且消息将在控制台显示。
- en: In our example, we are making it a precondition that the state must be `initial`
    when calling this method.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使状态必须为`initial`，当调用此方法时。
- en: 'When our classifier performs the classification, it expects a number of stars
    between 1 and 10\. However, the method accepts an `Int` as a parameter; so, any
    integer value can be provided, positive or negative. If the value provided is
    not between 1 and 10 and the classifier cannot provide a valid `MovieReviewClass`,
    then the classifier is being used incorrectly, and we should terminate the execution
    of the code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的分类器执行分类时，它期望在1到10之间有一个星号的数量。然而，该方法接受一个`Int`作为参数；因此，可以提供任何整数值，无论是正数还是负数。如果提供的值不在1到10之间，并且分类器无法提供有效的`MovieReviewClass`，那么分类器正在被错误地使用，我们应该终止代码的执行：
- en: '[PRE104]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The if-else statement covers all the valid `MovieReviewClass` options for the
    provided stars, so if none of these are triggered, we use a fatal error to indicate
    incorrect usage. This is done using the `fatalError` keyword, providing an optional
    message.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果-否则语句涵盖了提供的星星对应的所有有效的`MovieReviewClass`选项，所以如果没有触发这些选项之一，我们使用致命错误来指示错误的使用。这是通过使用`fatalError`关键字，并提供一个可选的消息来完成的。
- en: See also
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about `fatalError` can be found in Apple's documentation
    on the Swift language at [http://swiftbook.link/docs/fatalerror](http://swiftbook.link/docs/fatalerror).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`fatalError`的更多信息可以在苹果公司关于Swift语言的文档中找到，请参阅[http://swiftbook.link/docs/fatalerror](http://swiftbook.link/docs/fatalerror)。
