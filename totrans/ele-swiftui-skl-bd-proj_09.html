<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-130"><a id="_idTextAnchor422"/>9</h1>
<h1 id="_idParaDest-131"><a id="_idTextAnchor423"/>Watch Project – Fitness Companion UI</h1>
<p>In this chapter, we will implement the activity button screen for the Fitness Companion project. In the previous chapter, we looked at the design of Fitness Companion and, more specifically, the <strong class="bold">Current Activity</strong> screen design. Then we broke the screen down into all the components required. We then implemented all the components using SwiftUI. At the end of the previous chapter, we only had a single screen that couldn’t be swiped. The main section will be swipeable and present the user with a list of buttons for controlling the current activity. Then, we will analyze the activity button screen, break it down into all the components it is composed of, and implement all the components to provide a fitness app-like feel.</p>
<p>This chapter will be split into the following sections:</p>
<ul>
<li>Activity button screen overview</li>
<li>Implementing the activity button screen</li>
<li>Extra tasks</li>
</ul>
<p>By the end of this chapter, you will have created a fitness companion application for WatchOS. This will serve as a template with a swipeable screen to show the user information about an activity. It will serve as a solid foundation for further expanding the fitness application or pivoting the project to something different while using the core structure we have implemented. As we reach the end of the chapter, I will provide exercises to implement more advanced functionality in the fitness companion app. This will be the fourth and last project in this book, providing you with a 360-degree view of iOS UI development using Swift.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor424"/>Technical Requirements</h1>
<p>This chapter requires you to download Xcode version 14 or above from Apple’s App Store.</p>
<p>To install Xcode, just search for Xcode in the App Store and select and download the latest version. Open Xcode and follow any additional installation instructions. Once Xcode has opened and launched, you’re ready to go.</p>
<p>Version 14 of Xcode has the following features/requirements:</p>
<ul>
<li>It includes SDKs for iOS 16, iPadOS 16, macOS 12.3, tvOS 16, and watchOS 9</li>
<li>It supports on-device debugging in iOS 11 or later, tvOS 11 or later, and watchOS 4 or later</li>
<li>You will require a Mac running macOS Monterey 12.5 or later</li>
</ul>
<p>Download the sample code from the following GitHub link:</p>
<p><a href="https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects">https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects</a></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor425"/>Activity button screen overview</h1>
<p>In this<a id="_idIndexMarker347"/> section, we will take another look at the wireframe from <a href="B18783_08.xhtml#_idTextAnchor402"><em class="italic">Chapter 8</em></a> and break it down into its components. The following figure showcases the activity button screen:</p>
<div><div><img alt="Figure 9.1 – Activity button screen" src="img/B18783_09_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Activity button screen</p>
<p>Before we <a id="_idIndexMarker348"/>code our application, we will break down the activity button screen into the elements that comprise it. As a little task, see whether you can figure out what these are. Don’t worry if you don’t know the exact UI component names; we will look at the components in the following section.<a id="_idTextAnchor426"/></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor427"/>Image components</h2>
<p>An Image component<a id="_idIndexMarker349"/> is one of the core components offered by SwiftUI. It allows you to display an image, which can be used to provide a visual representation or to aid a body of text. We will use it to display icons for buttons to control the current activity. The following figures show the icons from the application:</p>
<div><div><img alt="Figure 9.2 – Lock image" src="img/B18783_09_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Lock image</p>
<div><div><img alt="Figure 9.3 – New image" src="img/B18783_09_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – New image</p>
<div><div><img alt="Figure 9.4 – End image" src="img/B18783_09_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – End image</p>
<div><div><img alt="Figure 9.5 – Pause image" src="img/B18783_09_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Pause image</p>
<p>Th<a id="_idTextAnchor428"/>ese images<a id="_idIndexMarker350"/> contain not only an icon but also a background. This is something that will be further explored later in this chapter.</p>
<h2 id="_idParaDest-135">T<a id="_idTextAnchor429"/>ext components</h2>
<p>We will be using text components to <a id="_idIndexMarker351"/>display button titles. Refer to <a href="B18783_02.xhtml#_idTextAnchor246"><em class="italic">Chapter 2</em></a> for more information.</p>
<p><a id="_idTextAnchor430"/>In the next section, we will implement the code for the activity button screen using the components we discussed in the previous sections.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor431"/>Implementing the Activity Button Screen</h1>
<p>In this section, we <a id="_idIndexMarker352"/>will implement our application’s activity button screen and thus complete the fourth and final project in this book. Before we do this, we must implement a swipeable page system. The first page will contain the implementation from the previous chapter, and the second page will be the activity buttons. Naturally, you can use this to expand to as many pages as you require.<a id="_idTextAnchor432"/></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor433"/>Swipeable Pages</h2>
<p>In this section, we will implement our <a id="_idIndexMarker353"/>swipeable pages. Luckily for us, it is super simple to implement as many things as possible in SwiftUI. Simply enclose our current <code>VStack</code> in the <code>MainView</code> inside a <code>TabView</code> as demonstrated here:</p>
<pre class="source-code">
TabView{
    VStack( alignment: .leading )
    {
        Text( timerString )
            .font( .title2 )
            .foregroundColor( Color.yellow )
            .padding( .bottom )
            .onReceive( timer )
        { time in
            counter += 1
            let hours = counter / 3600
            let minutes = ( counter % 3600 ) / 60
            let seconds = counter % 3600 % 60
            timerString = String( format: "%02d", hours ) + ":"
+ String( format: "%02d", minutes ) + ":" +
String( format: "%02d", seconds )
        }
        Text( String( bpm ) + " BPM" )
        Text( String( calories ) + " Calories" )
        Text( activity )
    }
    .padding( )
}</pre>
<p>In the preceding <a id="_idIndexMarker354"/>code, we implemented a <code>TabView</code>, which is used to create multiple pages in our fitness companion app.</p>
<p>Now, if you run it, it will look the same. However, if you try and swipe the screen, you will notice a bit of bounce. This is because there is only a single page. Now, let’s add a dummy second page to help us test our new <code>TabView</code>. After the <code>VStack</code>, add a <code>Text</code> component, like so:</p>
<pre class="source-code">
TabView{
    VStack( alignment: .leading )
    {
        …
    }
    .padding( )
    Text( "Second Page" )
}</pre>
<p>Now we<a id="_idIndexMarker355"/> have implemented the second page in our <code>TabView</code>. If you try and swipe on the page, it will go to the next page.</p>
<p>Each view within the <code>TabView</code> is treated as an individual page. Honestly, it’s as simple as that. Running our application will result in the following, which shows two dots at the bottom that indicate that there are two pages:</p>
<div><div><img alt="Figure 9.6 – First page" src="img/B18783_09_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – First page</p>
<p>Swiping from right to left will show the second page, as follows:</p>
<div><div><img alt="Figure 9.7 – Second page" src="img/B18783_09_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Second page</p>
<p>In this section, we <a id="_idIndexMarker356"/>added an extra page using the <code>TabView</code> component. This allowed us to add another page that the user was able to traverse with a swipe gesture. In the next section, we will add the activity button<a id="_idTextAnchor434"/>s.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor435"/>Activity Buttons</h2>
<p>In this section, we will implement the activity buttons<a id="_idIndexMarker357"/> on the second page of our <code>TabView</code>. We will be using custom colors for the background of each button and the icon itself.</p>
<p>Let’s go ahead and create these custom colors:</p>
<ol>
<li>Navigate to the <strong class="bold">Assets</strong> section within the <strong class="bold">Project Navigator</strong>:</li>
</ol>
<div><div><img alt="Figure 9.8 – Assets folder" src="img/B18783_09_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Assets folder</p>
<ol>
<li value="2">In the <strong class="bold">Assets</strong> section, right-click on the <a id="_idIndexMarker358"/>empty space and select <strong class="bold">New </strong><strong class="bold">Color Set</strong>:</li>
</ol>
<div><div><img alt="Figure 9.9 – New Color Set button" src="img/B18783_09_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – New Color Set button</p>
<ol>
<li value="3">In <strong class="bold">Attributes inspector</strong>, set the<a id="_idIndexMarker359"/> name of the color:</li>
</ol>
<div><div><img alt="Figure 9.10 – New Color Set button" src="img/B18783_09_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – New Color Set button</p>
<ol>
<li value="4">Select <strong class="bold">Any Appearance</strong> or <strong class="bold">Dark</strong> to <a id="_idIndexMarker360"/>set the color. This ensures that in all color modes, the desired color will be used:</li>
</ol>
<div><div><img alt="Figure 9.11 – Any Appearance" src="img/B18783_09_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Any Appearance</p>
<ol>
<li value="5">Now make sure <strong class="bold">Content</strong> is set to <strong class="bold">sRGB</strong> and <strong class="bold">Input Method</strong> is set to <strong class="bold">8-bit Hexadecimal</strong>. Then set the <strong class="bold">Hex</strong> value:</li>
</ol>
<div><div><img alt="Figure 9.12 – Setting the color" src="img/B18783_09_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Setting the color</p>
<ol>
<li value="6">Repeat these<a id="_idIndexMarker361"/> steps for all the colors listed:<ul><li><code>endColour</code></li><li>Hex color value: <code>#FF161C</code></li></ul></li><li><code>endColourBackground</code></li><li>Hex color value: <code>#390B0C</code></li></ul></li><li><code>lockColour</code></li><li>Hex color value: <code>#06F5E7</code></li></ul></li><li><code>lockColourBackground</code></li><li>Hex color value: <code>#113330</code></li></ul></li><li><code>newColour</code></li><li>Hex color value: <code>#86FE01</code></li></ul></li><li><code>newColourBackground</code></li><li>Hex <a id="_idIndexMarker362"/>color value: <code>#1E3400</code></li></ul></li><li><code>pauseColour</code></li><li>Hex color value: <code>#BBA700</code></li></ul></li><li><code>pauseColourBackground</code></li><li>Hex color value: <code>#342F00</code></li></ul></li></ul></li>
<li>Once completed, the <strong class="bold">Assets</strong> screen should look as follows:</li>
</ol>
<div><div><img alt="Figure 9.13 – Colors added" src="img/B18783_09_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Colors added</p>
<p>Even though the colors <a id="_idIndexMarker363"/>have been created, we cannot use them directly in our code. Let’s fix this. Doing so is rather simple. In the <code>MainView</code>, we will extend the <code>Color</code> functionality to support our colors. Before doing so, I thought it is prudent to mention why I spelled color like so when referring to the functionality. This is the American spelling and is the one used within Swift. To extend the functionality, we must spell it this way, but as I am British, the spelling I personally use is <em class="italic">Colour</em>. Now that is cleared up. Let’s extend the Swift color. Add the following code above the <code>MainView</code> struct:</p>
<pre class="source-code">
extension Color{
    static let lockColour = Color( "lockColour" )
    static let lockColourBackground = Color( "lockColourBackground" )
    static let newColour = Color( "newColour" )
    static let newColourBackground = Color( "newColourBackground" )
    static let endColour = Color( "endColour" )
    static let endColourBackground = Color( "endColourBackground" )
    static let pauseColour = Color( "pauseColour" )
    static let pauseColourBackground = Color( "pauseColourBackground" )
}</pre>
<p>Though we<a id="_idIndexMarker364"/> have added it to the <code>MainView</code>, extending the Swift color allows us to use it anywhere in our project. It’s also worth mentioning that this means only in our project and doesn’t extend beyond the scope of our project into other projects. Our project is small, so it’s perfectly fine putting it inside the <code>MainView</code>. However, it is common practice to put extensions like this in a specific file. If there are a lot of color extensions, then they could have their own Color file. This is beyond the scope of this project.</p>
<p>Here’s a quick overview of the preceding code: we extended the Color using static variables of the names we set previously in the asset.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The variable names do not need to be the same as the color name. But it is good practice to keep them the same. It makes them easier to maintain.</p>
<p>Each of the buttons is made up of three components:</p>
<ul>
<li>Background</li>
<li>Icon</li>
<li>Text</li>
</ul>
<p>For the background, we will use a <code>Rectangle</code> component. More specifically, we will use the <code>RoundedRectangle</code> component as it allows us to set a corner radius. Feel free to change the design and use a <code>Rectangle</code> or any other shape. For the icon, we will use the <code>Image</code> component and use a built-in icon. Feel free to use your own image or look at SF Symbols, as discussed earlier, in <a href="B18783_06.xhtml#_idTextAnchor354"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing the Sidebar</em>, to see all built-in icons. The text is the simplest of all the components and will use a basic <code>Text</code> component.</p>
<p>The most difficult <a id="_idIndexMarker365"/>part of the buttons is the background and icon. This is because they are on top of each other. The text is placed below the image, making it easy to add. We will initially concentrate on getting the background and icon coded. We will use a <code>ZStack</code> to place the icon on top of the background. Replace the second-page dummy <code>Text</code> component with the following code:</p>
<pre class="source-code">
ZStack{
    RoundedRectangle( cornerRadius: 18, style:
.continuous )
}</pre>
<p>We have created a <code>RoundedRectangle</code> with a corner radius of 18. Feel free to increase the number to get more rounded corners, or to lower it. Setting the style to <code>.continuous</code> makes the corners appear smoother, which is always a good thing. Let’s see what this produced:</p>
<div><div><img alt="Figure 9.14 – Simple rounded rectangle" src="img/B18783_09_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Simple rounded rectangle</p>
<p>Right now, it’s not<a id="_idIndexMarker366"/> looking anything like the button in the figures shown at the start of this chapter. There are just two things missing – the background color and making the size smaller. We will use the <code>lockColourBackground</code> color we created previously and set the size to a width of <code>70</code> and a height of <code>64</code>:</p>
<pre class="source-code">
ZStack{
    RoundedRectangle( cornerRadius: 18, style:
.continuous )
        .foregroundColor( .lockColourBackground )
        .frame( width: 70, height: 64 )
}</pre>
<p>The following figure shows the image background:</p>
<div><div><img alt="Figure 9.15 – Rounded color styled" src="img/B18783_09_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Rounded color styled</p>
<p>The background<a id="_idIndexMarker367"/> is finally looking more like our design. The next step is to add the icon inside of the rectangle. Doing so is simple. Add an image with the icon after the <code>RoundedRectangle</code> component:</p>
<pre class="source-code">
ZStack{
    RoundedRectangle( cornerRadius: 18, style:
.continuous )
        .foregroundColor( .lockColourBackground )
        .frame( width: 70, height: 64 )
    Image( systemName: "drop.fill" )
}</pre>
<p>Running the application now will produce the following:</p>
<div><div><img alt="Figure 9.16 – Teardrop icon in background" src="img/B18783_09_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Teardrop icon in background</p>
<p>We<a id="_idIndexMarker368"/> used <strong class="bold">SF Symbols</strong> to obtain the<a id="_idIndexMarker369"/> teardrop icon. Feel free to use any icon as you see fit, or even your own image. We need to change the icon style. There are two main aspects to update, the color and size. Update the image as follows:</p>
<pre class="source-code">
Image( systemName: "drop.fill" )    .resizable( )
    .foregroundColor( .lockColour )
    .aspectRatio( contentMode: .fit )
    .frame( width: 16 )</pre>
<p>We first set it to <code>resizable</code>, which allows us to change the size. Next, we set the color using one of the colors we created earlier. Next, we ensure the aspect ratio is set to fit, which allows us to resize the image without distorting it. Finally, we set the size because we have a locked aspect ratio. Setting the width automatically sets the height accordingly. Running the application produces the result that follows:</p>
<div><div><img alt="Figure 9.17 – Lock button" src="img/B18783_09_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Lock button</p>
<p>Next, we will <a id="_idIndexMarker370"/>add text to our button. The text isn’t inside of the icon or even the rectangle but sits beneath it. But we still want it to be clickable, so we will wrap all of the button contents inside a <code>VStack</code> and also add the <code>Text</code> component, like so:</p>
<pre class="source-code">
VStack{
    ZStack
    {
        RoundedRectangle( cornerRadius: 18, style:
.continuous )
            .foregroundColor( .lockColourBackground )
            .frame( width: 70, height: 64 )
        Image( systemName: "drop.fill" )
            .resizable( )
            .foregroundColor( .lockColour )
            .aspectRatio( contentMode: .fit )
            .frame( width: 16 )
    }
    Text( "Lock" )
}</pre>
<p>The reason for wrapping the button in a <code>VStack</code> is two-fold:</p>
<ul>
<li>We want all of it to be clickable (to be implemented next).</li>
<li>As there will be multiple buttons, the <code>VStack</code> is technically the button without the icon, rectangle, or text components. Pretty cool!</li>
</ul>
<p>Let’s make<a id="_idIndexMarker371"/> the <code>VStack</code> clickable, and then we will take a look at the result. First, we need a function for it to call. We could use an inline function, but we will create a dedicated function. This provides a nice abstraction in our code base. Before the body, add the following code:</p>
<pre class="source-code">
func Lock( ){ print( "Lock button is pressed" ); }
var body: some View
{
     ...
}</pre>
<p>The function is a simple one. When clicked, a message is logged to the terminal. Now update the <code>VStack</code> with an <code>onTapGesture</code> function:</p>
<pre class="source-code">
VStack{
    ZStack
    {
        RoundedRectangle( cornerRadius: 18, style:
.continuous )
            .foregroundColor( .lockColourBackground )
            .frame( width: 70, height: 64 )
        Image( systemName: "drop.fill" )
            .resizable( )
            .foregroundColor( .lockColour )
            .aspectRatio( contentMode: .fit )
            .frame( width: 16 )
    }
    Text( "Lock" )
}.onTapGesture { Lock( ) }</pre>
<p>That was a<a id="_idIndexMarker372"/> lot. Let’s run our application and see the result:</p>
<div><div><img alt="Figure 9.18 – Finished lock button" src="img/B18783_09_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Finished lock button</p>
<p>Feel free to<a id="_idIndexMarker373"/> click the button. It will log a message. Before wrapping up this project and implementing the remaining buttons, here is the code so far:</p>
<pre class="source-code">
////  ContentView.swift
//  Fitness Companion Watch App
//
//  Created by Frahaan on 03/04/2023.
//
import SwiftUI
extension Color
{
    static let lockColour = Color( "lockColour" )
    static let lockColourBackground = Color( "lockColourBackground" )
    static let newColour = Color( "newColour" )
    static let newColourBackground = Color( "newColourBackground" )
    static let endColour = Color( "endColour" )
    static let endColourBackground = Color( "endColourBackground" )
    static let pauseColour = Color( "pauseColour" )
    static let pauseColourBackground = Color( "pauseColourBackground" )
}
struct MainView: View
{
    @State private var counter = 0
    @State private var timerString = "00:00:00"
    @State private var bpm = 120
    @State private var calories = 110
    @State private var activity = "Running"
    let timer = Timer.publish( every: 1, on: .main, in: .common ).autoconnect( )
    func Lock( )
    { print( "Lock button is pressed" ); }
    var body: some View
    {
        TabView
        {
            VStack( alignment: .leading )
            {
                Text( timerString )
                    .font( .title2 )
                    .foregroundColor( Color.yellow )
                    .padding( .bottom )
                    .onReceive( timer )
                { time in
                    counter += 1
                    let hours = counter / 3600
                    let minutes = ( counter % 3600 ) / 60
                    let seconds = counter % 3600 % 60
                    timerString = String( format: "%02d", hours ) + ":" + String( format: "%02d", minutes ) + ":" + String( format: "%02d", seconds )
                }
                Text( String( bpm ) + " BPM" )
                Text( String( calories ) + " Calories" )
                Text( activity )
            }
            .padding( )
            VStack
            {
                ZStack
                {
                    RoundedRectangle( cornerRadius: 18, style: .continuous )
                        .foregroundColor( .lockColourBackground )
                        .frame( width: 70, height: 64 )
                    Image( systemName: "drop.fill" )
                        .resizable( )
                        .foregroundColor( .lockColour )
                        .aspectRatio( contentMode: .fit )
                        .frame( width: 16 )
                }
                Text( "Lock" )
            }.onTapGesture { Lock( ) }
        }
    }
}
struct MainView_Previews: PreviewProvider
{
    static var previews: some View
    {
        MainView( )
    }
}</pre>
<p>We have <a id="_idIndexMarker374"/>almost completed the chapter; the only thing left is to add the remaining buttons. First, let’s add the remaining function callbacks above the body, like so:</p>
<pre class="source-code">
func Lock( ){ print( "Lock button is pressed" ); }
func New( )
{ print( "New button is pressed" ); }
func End( )
{ print( "End button is pressed" ); }
func Pause( )
{ print( "Pause button is pressed" ); }
var body: some View
{
    ...
}</pre>
<p>Now that we have implemented the callbacks, we are going to implement the buttons. Each button itself is actually simple, as it is the same as the lock button but with the following changes:</p>
<ul>
<li><code>RoundedRectangle</code>’s <code>foregroundColor</code></li>
<li>Image’s icon</li>
<li>Image’s <code>foregroundColor</code></li>
<li>Text</li>
<li>The <code>onTapGesture</code> callback</li>
</ul>
<p>Merely <a id="_idIndexMarker375"/>duplicating the <code>VStack</code> code would effectively be duplicating the button. We would have the following results:</p>
<div><div><img alt="Figure 9.19 – Extra buttons added" src="img/B18783_09_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Extra buttons added</p>
<p>If you can’t see a difference, I don’t blame you. It’s hard to see what’s actually happened, but if you look at the bottom of the screen, there are five dots, indicating that there are five pages now. Remember, when implementing the second page, we stated that each component in the root would be its own page. So, we want to group all these buttons together by putting them in a 2x2 grid. To organize components on the same line, we can use an <code>HStack</code>. We only need two on a single line, so first, we will enclose the first two buttons, the <code>VStacks</code> in an <code>HStack</code>. This will result in three pages, the first being the one implemented in the previous chapter and two for each <code>HStack</code>, which isn’t what we want. One small change and it will be fixed. Can you guess what it is? Just enclose both <code>HStacks</code> in a single <code>VStack</code>. This will put them on top of each other, thus <a id="_idIndexMarker376"/>rendering a grid. The code for this is as follows:</p>
<pre class="source-code">
VStack{
    HStack
    {
        VStack
        {
            ZStack
            {
                RoundedRectangle( cornerRadius: 18, style: .continuous )
                    .foregroundColor( .lockColourBackground )
                    .frame( width: 70, height: 64 )
                Image( systemName: "drop.fill" )
                    .resizable( )
                    .foregroundColor( .lockColour )
                    .aspectRatio( 1.0, contentMode: .fit )
                    .frame( width: 32 )
            }
            Text( "Lock" )
        }.onTapGesture { Lock( ) }
        VStack
        {
            ZStack
            {
                RoundedRectangle( cornerRadius: 18, style: .continuous )
                    .foregroundColor( .newColourBackground )
                    .frame( width: 70, height: 64 )
                Image( systemName: "plus" )
                    .resizable( )
                    .foregroundColor( .newColour )
                    .aspectRatio( 1.0, contentMode: .fit )
                    .frame( width: 32 )
            }
            Text( "New" )
        }.onTapGesture { New( ) }
    }
    HStack
    {
        VStack
        {
            ZStack
            {
                RoundedRectangle( cornerRadius: 18, style: .continuous )
                    .foregroundColor( .endColourBackground )
                    .frame( width: 70, height: 64 )
                Image( systemName: "xmark" )
                    .resizable( )
                    .foregroundColor( .endColour )
                    .aspectRatio( 1.0, contentMode: .fit )
                    .frame( width: 32 )
            }
            Text( "End" )
        }.onTapGesture { End( ) }
        VStack
        {
            ZStack
            {
                RoundedRectangle( cornerRadius: 18, style: .continuous )
                    .foregroundColor( .pauseColourBackground )
                    .frame( width: 70, height: 64 )
                Image( systemName: "pause" )
                    .resizable( )
                    .foregroundColor( .pauseColour )
                    .aspectRatio( 1.0, contentMode: .fit )
                    .frame( width: 32 )
            }
            Text( "Pause" )
        }.onTapGesture { Pause( ) }
    }
}</pre>
<p>It’s <a id="_idIndexMarker377"/>time to run our app:</p>
<div><div><img alt="Figure 9.20 – Button grid system" src="img/B18783_09_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – Button grid system</p>
<p>You might<a id="_idIndexMarker378"/> be ready to finish this chapter and call it a day. Please bear with me – the top row of the grid is too close to the time for my liking. Let’s add top <code>VStack</code> we just implemented:</p>
<pre class="source-code">
.padding( .top, 20.0 )</pre> <p>This is it, the final build and run of our application – drum roll, please!</p>
<div><div><img alt="Figure 9.21 – Button grid system" src="img/B18783_09_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Button grid system</p>
<p>We are now at the end of our project, and our application looks amazing. Before we summarize, feel free to visit the GitHub repository to double-check your code base: <a href="https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects">https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects</a>.</p>
<p>In this section, we added the activity buttons. We did this by implementing another page in our fitness app. We leveraged a grid-based system for laying out our buttons. We used a variety of core components combined with stacks to organize them. In the following section, we<a id="_idIndexMarker379"/> will summarize this chapter, and ultimately this book. But first, we will look at some code to help you with the e<a id="_idTextAnchor436"/>xtra tasks.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor437"/>Different Exercises</h2>
<p>To add different exercises<a id="_idIndexMarker380"/> to the fitness companion app, you can modify the <code>MainView</code> by introducing a new data structure to store exercise information and update the UI accordingly. Here’s an example of how you can make these changes:</p>
<pre class="source-code">
import SwiftUIextension Color {
    static let lockColour = Color("lockColour")
    static let lockColourBackground = Color("lockColourBackground")
    static let newColour = Color("newColour")
    static let newColourBackground = Color("newColourBackground")
    static let endColour = Color("endColour")
    static let endColourBackground = Color("endColourBackground")
    static let pauseColour = Color("pauseColour")
    static let pauseColourBackground = Color("pauseColourBackground")
}
struct Exercise {
    let name: String
    let image: String
}
struct MainView: View {
    @State private var counter = 0
    @State private var timerString = "00:00:00"
    @State private var bpm = 120
    @State private var calories = 110
    @State private var activity = "Running"
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    let exercises = [
        Exercise(name: "Running", image: "person.running"),
        Exercise(name: "Cycling", image: "bicycle"),
        Exercise(name: "Swimming", image: "figure.walk"),
        // Add more exercises here
    ]
    func Lock() {
        print("Lock button is pressed")
    }
    func New() {
        print("New button is pressed")
    }
    func End() {
        print("End button is pressed")
    }
    func Pause() {
        print("Pause button is pressed")
    }
    var body: some View {
        TabView {
            VStack(alignment: .leading) {
                Text(timerString)
                    .font(.title2)
                    .foregroundColor(Color.yellow)
                    .padding(.bottom)
                    .onReceive(timer) { time in
                        counter += 1
                        let hours = counter / 3600
                        let minutes = (counter % 3600) / 60
                        let seconds = counter % 3600 % 60
                        timerString = String(format: "%02d", hours) + ":" + String(format: "%02d", minutes) + ":" + String(format: "%02d", seconds)
                    }
                Text(String(bpm) + " BPM")
                Text(String(calories) + " Calories")
                Text(activity)
            }
            .padding()
            VStack {
                HStack {
                    ForEach(exercises, id: \.name) { exercise in
                        VStack {
                            ZStack {
                                RoundedRectangle(cornerRadius: 18, style: .continuous)
                                    .foregroundColor(.newColourBackground)
                                    .frame(width: 70, height: 64)
                                Image(systemName: exercise.image)
                                    .resizable()
                                    .foregroundColor(.newColour)
                                    .aspectRatio(contentMode: .fit)
                                    .frame(width: 32)
                            }
                            Text(exercise.name)
                        }
                        .onTapGesture {
                            activity = exercise.name
                        }
                    }
                }
                HStack {
                    VStack {
                        ZStack {
                            RoundedRectangle(cornerRadius: 18, style: .continuous)
                                .foregroundColor(.lockColourBackground)
                                .frame(width: 70, height: 64)
                            Image(systemName: "lock.fill")
                                .resizable()
                                .foregroundColor(.lockColour)
                                .aspectRatio(contentMode: .fit)
                                .frame(width: 32
)
                        }
                        Text("Lock")
                    }.onTapGesture { Lock() }
                    VStack {
                        ZStack {
                            RoundedRectangle(cornerRadius: 18, style: .continuous)
                                .foregroundColor(.endColourBackground)
                                .frame(width: 70, height: 64)
                            Image(systemName: "xmark")
                                .resizable()
                                .foregroundColor(.endColour)
                                .aspectRatio(contentMode: .fit)
                                .frame(width: 32)
                        }
                        Text("End")
                    }.onTapGesture { End() }
                    VStack {
                        ZStack {
                            RoundedRectangle(cornerRadius: 18, style: .continuous)
                                .foregroundColor(.pauseColourBackground)
                                .frame(width: 70, height: 64)
                            Image(systemName: "pause")
                                .resizable()
                                .foregroundColor(.pauseColour)
                                .aspectRatio(contentMode: .fit)
                                .frame(width: 32)
                        }
                        Text("Pause")
                    }.onTapGesture { Pause() }
                }
            }
            .padding(.top, 20.0)
        }
    }
}
struct MainView_Previews: PreviewProvider {
    static var previews: some View {
        MainView()
    }
}</pre>
<p>In this <a id="_idIndexMarker381"/>modified code, we have introduced a new <code>Exercise</code> struct that stores the name and image name of each exercise. You can add more exercises to the <code>exercises</code> array by creating new <code>Exercise</code> instances.</p>
<p>In the view, we have used a <code>ForEach</code> loop to iterate over the exercises and display them dynamically. Each exercise is represented by a <code>VStack</code> containing an image and a text label. When an exercise is tapped, the activity state is updated with the selected exercise’s name.</p>
<p>You can <a id="_idIndexMarker382"/>customize the exercise images and add more properties to the <code>Exercise</code> struct based on your specific<a id="_idTextAnchor438"/> requirements.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor439"/>Active timer</h2>
<p>To add functionality for an active<a id="_idIndexMarker383"/> timer that can be started, stopped, and paused, you can modify the <code>MainView</code> by introducing additional state variables and actions. Here’s an example of how you can make these changes:</p>
<pre class="source-code">
import SwiftUIstruct Exercise {
    let name: String
    let image: String
}
struct MainView: View {
    @State private var counter = 0
    @State private var isTimerRunning = false
    @State private var isTimerPaused = false
    @State private var timerString = "00:00:00"
    @State private var bpm = 120
    @State private var calories = 110
    @State private var activity = "Running"
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    let exercises = [
        Exercise(name: "Running", image: "person.running"),
        Exercise(name: "Cycling", image: "bicycle"),
        Exercise(name: "Swimming", image: "figure.walk"),
        // Add more exercises here
    ]
    func lock() {
        print("Lock button is pressed")
    }
    func startTimer() {
        isTimerRunning = true
        isTimerPaused = false
    }
    func pauseTimer() {
        isTimerRunning = false
        isTimerPaused = true
    }
    func stopTimer() {
        isTimerRunning = false
        isTimerPaused = false
        counter = 0
        timerString = "00:00:00"
    }
    var body: some View {
        TabView {
            VStack(alignment: .leading) {
                Text(timerString)
                    .font(.title2)
                    .foregroundColor(Color.yellow)
                    .padding(.bottom)
                    .onReceive(timer) { time in
                        if isTimerRunning &amp;&amp; !isTimerPaused {
                            counter += 1
                            let hours = counter / 3600
                            let minutes = (counter % 3600) / 60
                            let seconds = counter % 3600 % 60
                            timerString = String(format: "%02d", hours) + ":" + String(format: "%02d", minutes) + ":" + String(format: "%02d", seconds)
                        }
                    }
                Text(String(bpm) + " BPM")
                Text(String(calories) + " Calories")
                Text(activity)
            }
            .padding()
            VStack {
                HStack {
                    ForEach(exercises, id: \.name) { exercise in
                        VStack {
                            ZStack {
                                RoundedRectangle(cornerRadius: 18, style: .continuous)
                                    .foregroundColor(.newColourBackground)
                                    .frame(width: 70, height: 64)
                                Image(systemName: exercise.image)
                                    .resizable()
                                    .foregroundColor(.newColour)
                                    .aspectRatio(contentMode: .fit)
                                    .frame(width: 32)
                            }
                            Text(exercise.name)
                        }
                        .onTapGesture {
                            activity = exercise.name
                        }
                    }
                }
                HStack {
                    VStack {
                        ZStack {
                            RoundedRectangle(cornerRadius: 18, style: .continuous)
                                .foregroundColor(.lockColourBackground)
                                .frame(width: 70, height: 64)
                            Image(systemName: "lock.fill")
                                .resizable()
                                .foregroundColor(.lockColour)
                                .aspectRatio(contentMode: .fit)
                                .frame(width: 32)
                        }
                        Text("Lock")
                    }
                    .onTapGesture { lock() }
                    VStack {
                        if isTimerRunning
 {
                            Button(action: pauseTimer) {
                                ZStack {
                                    RoundedRectangle(cornerRadius: 18, style: .continuous)
                                        .foregroundColor(.pauseColourBackground)
                                        .frame(width: 70, height: 64)
                                    Image(systemName: "pause")
                                        .resizable()
                                        .foregroundColor(.pauseColour)
                                        .aspectRatio(contentMode: .fit)
                                        .frame(width: 32)
                                }
                            }
                            .buttonStyle(PlainButtonStyle())
                        } else {
                            Button(action: startTimer) {
                                ZStack {
                                    RoundedRectangle(cornerRadius: 18, style: .continuous)
                                        .foregroundColor(.pauseColourBackground)
                                        .frame(width: 70, height: 64)
                                    Image(systemName: "play.fill")
                                        .resizable()
                                        .foregroundColor(.pauseColour)
                                        .aspectRatio(contentMode: .fit)
                                        .frame(width: 32)
                                }
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                        Text(isTimerRunning ? "Pause" : "Start")
                    }
                    VStack {
                        ZStack {
                            RoundedRectangle(cornerRadius: 18, style: .continuous)
                                .foregroundColor(.endColourBackground)
                                .frame(width: 70, height: 64)
                            Image(systemName: "xmark")
                                .resizable()
                                .foregroundColor(.endColour)
                                .aspectRatio(contentMode: .fit)
                                .frame(width: 32)
                        }
                        Text("End")
                    }
                    .onTapGesture { stopTimer() }
                }
            }
            .padding(.top, 20.0)
        }
    }
}
struct MainView_Previews: PreviewProvider {
    static var previews: some View {
        MainView()
    }
}</pre>
<p>In this <a id="_idIndexMarker384"/>modified code, we have made the following changes:</p>
<ul>
<li>We introduced <code>isTimerRunning</code> and <code>isTimerPaused</code> state variables to track the timer’s state.</li>
<li>We added <code>startTimer()</code>,  <code>pauseTimer()</code>, and <code>stopTimer()</code> actions to handle starting, pausing, and stopping the timer, respectively.</li>
<li>We modified the “Start/Pause” button to toggle between the <code>isTimerRunning</code> state.</li>
<li>We updated the timer’s <code>onReceive</code> closure to only increment the counter and update the timer string when the timer is running and not paused.</li>
<li>We added <a id="_idIndexMarker385"/>functionality to reset the counter and timer string when the <strong class="bold">End</strong> button is pressed.</li>
</ul>
<p>With these changes, you can now start, pause, and stop the timer in your fitness companion app.</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor440"/>Summary</h1>
<p>In this chapter, we successfully added the activity button screen to our Fitness Companion application. We began by analyzing the wireframe and breaking down each element into SwiftUI components. From there, we implemented the components to match the design from the wireframes. Through this process, we gained a deeper understanding of how to combine core SwiftUI components using stacks to create complex buttons. We finally looked at a few implementations for the extra tasks as well.</p>
<p>I want to express my gratitude for taking the time to read this book. There were moments when I questioned the purpose of writing yet another programming book, but ultimately, it was a worthwhile endeavor. I sincerely hope that you were able to gain something from it. If you have any questions or would like to contact me directly, please feel free to use any of the platforms listed here:</p>
<ul>
<li>Twitter: <a href="https://twitter.com/SonarSystems">https://twitter.com/SonarSystems</a></li>
<li>Email: <a href="mailto:support@sonarsystems.co.uk">support@sonarsystems.co.uk</a></li>
<li>Discord: <a href="https://discord.gg/7e78FxrgqH">https://discord.gg/7e78FxrgqH</a></li>
<li>FireDEV Podcast: <a href="https://open.spotify.com/show/387RiHksQE33KYHTitFXhg">https://open.spotify.com/show/387RiHksQE33KYHTitFXhg</a></li>
</ul>
</div>
</body></html>