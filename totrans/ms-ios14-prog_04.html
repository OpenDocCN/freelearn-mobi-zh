<html><head></head><body>
		<div><h1 id="_idParaDest-92"><em class="italic"><a id="_idTextAnchor122"/>Chapter 4</em>: Creating a Detail Page</h1>
			<p>So far, you have managed to build an app that shows a set of contacts on a custom grid in a collection view. This is pretty impressive but not very useful. Typically, a user will expect to be able to see more information when tapping on an item in an overview. </p>
			<p>In this case, they would likely expect to see more details about the tapped contact, for instance, their email address and phone number. In this chapter, you will see how to do just that.</p>
			<p>We'll also be introduced to <code>UIStackView</code> for the first time too, a comprehensive and powerful way to lay out a display without the need for over-complex autolayout solutions.</p>
			<p>Finally, we'll touch on the best practices when it comes to passing data from one view controller to another.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Implementing navigation with segues</li>
				<li>Creating our layout with <code>UIStackView</code></li>
				<li>Passing data between view controllers</li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor123"/>Technical requirements </h1>
			<p>For this chapter, you'll need to download Xcode version 11.4 or above from Apple's App Store. </p>
			<p>You'll also need to be running the latest version of macOS (Catalina or above). Simply search for Xcode in the App Store and select and download the latest version. Launch Xcode and follow any additional installation instructions that your system may prompt you with. Once Xcode has fully launched, you're ready to go.</p>
			<p>Download the sample code from the following GitHub link: <a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor124"/>Implementing navigation with segues</h1>
			<p>Most good applications have more than a single screen. I bet that most app ideas you have in your <a id="_idIndexMarker181"/>head involve at least a couple of different <a id="_idIndexMarker182"/>screens. Maybe you would like to display a table view or a collection view that links to a detail page. Or perhaps you want your user to drill down into your app's contents in a different way. Maybe you don't have any detail views but you would like to display a couple of modal screens for data input instead.</p>
			<p>Every time your user moves from one screen in your app to another, they are navigating. Navigation is an essential aspect of building an app, and you must understand the possibilities and patterns for building good navigation on the iOS platform. The easiest way to gain insight into navigation is by using a storyboard to explore the available options.</p>
			<p>Up until now, and with the exception of SwiftUI you have used your storyboard to create the layout for a single screen. </p>
			<p>However, the name storyboard implies that you can do a lot more than laying out a single screen. The purpose of using a storyboard is the ability to lay out all screens of your application in a single place so you can easily see how screens and sections of your app are related and how users navigate between them. </p>
			<p>In this section, we'll cover the following:</p>
			<ul>
				<li>Creating our new details view</li>
				<li>Implementing and understanding segues</li>
				<li>Creating a manual segue</li>
			</ul>
			<p>Let's get started.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor125"/>Creating our new details view</h2>
			<p>In this section, you <a id="_idIndexMarker183"/>will add a second view controller to your storyboard that functions as a detail page when a user taps on a contact – we'll continue working on our collection view project from <a href="B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Using Lists and Tables</em>.</p>
			<p>Let's start by doing the following:</p>
			<ol>
				<li>Open the <code>Main.storyboard</code> file.</li>
				<li>Search and drag out a view controller from the <strong class="bold">Object Library</strong> (just like we did with our collection view objects).</li>
				<li>Drop it next to the existing view controller.</li>
				<li>Look for a label in the <strong class="bold">Object Library</strong> and add it to the new view controller you just <a id="_idIndexMarker184"/>added to the storyboard. </li>
			</ol>
			<p>All going well, it should look something like the following figure:</p>
			<div><div><img src="img/Figure_4.01_B14717.jpg" alt="Figure 4.1 – Storyboard with new detail view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Storyboard with new detail view</p>
			<p>Before you add all the content for the contact detail page to the second view controller, it's a good idea to configure the navigation from the overview page to the detail page. To do this, you're going to create a selection segue.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor126"/>Implementing and understanding segues</h2>
			<p>A <strong class="bold">segue</strong> is a transition <a id="_idIndexMarker185"/>from one screen to the next. Not all segues are animated; sometimes you might need to <a id="_idIndexMarker186"/>present the next screen without performing a smooth animation. Both animated and static transitions can be set up with segues.</p>
			<p>Any time you connect one screen to the next to perform navigation, you are creating a segue. Some segues are performed when the user taps a button; these <a id="_idIndexMarker187"/>are called <strong class="bold">action segues</strong>. Segues that are only triggered through <a id="_idIndexMarker188"/>code are called <strong class="bold">manual segues</strong>. </p>
			<p>The selection segue you're going to use in this sample is a segue that is set up by connecting a table view cell or collection view cell to the next screen. The segue is performed when the user taps on a cell.</p>
			<p>To set up your selection segue, follow these steps: </p>
			<ol>
				<li value="1">Select the prototype collection view cell you have created for the contacts overview page.</li>
				<li>Next, press and hold the <em class="italic">Ctrl</em> key while you drag from the cell to the second view controller.</li>
			</ol>
			<p>When you release the mouse over the second view controller, a list of options is shown:</p>
			<div><div><img src="img/Figure_4.02_B14717.jpg" alt="Figure 4.2 – Segue Connector for new Detail View&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Segue Connector for new Detail View</p>
			<p>This list of possibilities describes how the detail view will be presented to the user. </p>
			<p>For example, select the modal presentation style from the generated list. This will display the <a id="_idIndexMarker189"/>detail page with an upward animation from the bottom of the screen (a model), this is not quite <a id="_idIndexMarker190"/>the route we are going to take. However, if you now launch the iOS simulator and select one of the cells, you'll see the effect it has.</p>
			<p>A better way to show the contact is by adding it to the navigation stack. Doing this will make a back button appear in the navigation bar, and the user will immediately understand that they are looking at a detail page due to the animation that moves the new view controller in from the right-hand side of the screen. </p>
			<p>To set this up, you need to select the <strong class="bold">Show</strong> segue – highlight the previously created segue and hit <em class="italic">Delete</em> on your keyboard. </p>
			<p>This segue pushes the newly presented view controller onto the existing navigation controller's navigation stack, but until we tell our app that we require navigation in this way, it will still be treated as a model.</p>
			<p>To fix this, add a new object via the Object Library called <strong class="bold">Navigation Controller</strong>, and drag this into your storyboard. You'll notice this will have brought across what appears to be two view controllers. </p>
			<p>The first is the navigation view controller itself (the one we care about) and the other is a template or a pre-defined <code>rootViewController</code>, which is already hooked into the navigation view controller.</p>
			<p>In order to modify this, do the following: </p>
			<ol>
				<li value="1">Simply delete this <code>rootViewController</code>, leaving the navigation controller where it is. </li>
				<li>Then, press <em class="italic">Ctrl</em> and primary click from the navigation controller and drag to our exiting <code>ViewController</code>. </li>
				<li>When <a id="_idIndexMarker191"/>released, you'll be <a id="_idIndexMarker192"/>offered the option to make this the <code>rootViewController</code>. Select this option.</li>
			</ol>
			<p>One final change to make is you'll notice an arrow going into the side of our existing <strong class="bold">View Controller</strong>; drag this from here to the <strong class="bold">Navigation Controller</strong> – all this is doing is setting this as our <strong class="bold">Initial View Controller</strong> so when the app is launched, it knows where to start.</p>
			<p>Go ahead now and run the app. You should be able to successfully navigate back and forth whilst clicking on cells. Let's take a look now at how we would create a manual segue. </p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor127"/>Creating a manual segue</h2>
			<p>We'll start by deleting the segue we just created. Now drag from the yellow circle at the top of the first view <a id="_idIndexMarker193"/>controller window to the second view controller – you've now just created a manual segue. </p>
			<p>When the dialog to determine how the segue is performed appears, select <strong class="bold">show</strong> again because you don't want to use a different animation. </p>
			<p>Click on the connecting line to inspect the segue and set the value for the <code>detailViewSegue</code> in <strong class="bold">Attributes Inspector</strong>. Similar to how you set a reuse identifier on table view cells and collection view cells, segues also use a string as their identifier.</p>
			<p>To trigger the segue after the animation, you must manually do so from your code. Open <code>ViewController.swift</code> and update the contents of <code>collectionView(_:didSelectItemAt:)</code> as shown in the following snippet:</p>
			<pre>    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        self.performSegue(withIdentifier: "detailViewSegue", sender: self)
    }</pre>
			<p>With one line of code, we can hook into our segue via its identifier and away we go. Run the app now and see how easy that was.</p>
			<p>In this section, we've started to create and build our very own details view page, learning all about how <a id="_idIndexMarker194"/>we can configure and control segues to push from one View Controller to the next.</p>
			<p>In the next section, we'll take a look at creating adaptive layouts without the need for <code>Autolayout</code>.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor130"/>Creating our layouts with UIStackView</h1>
			<p>Now we've <a id="_idIndexMarker195"/>got the foundations all set up, let's look at <a id="_idIndexMarker196"/>how we are going to build our details page.</p>
			<p>We have several options. One way is <code>UIStackView</code>. </p>
			<p>Stack views can lay out views that are added next to each other or on top of each other all by itself. This saves you adding constraints for the vertical spacing between labels like we did for the contact detail information.</p>
			<p>Since stack views can also lay out objects that are next to each other and stack views can be nested, it could also take care of the two-column layout that you implemented for screens with a regular width size class. And to top it all off, you can swap the direction in which a stack view lays out its items at runtime, meaning you can change it from horizontal to vertical depending on the available space.</p>
			<p>This will simplify a lot of the work that needs to be done and it makes your layout a lot more maintainable as well. To use a stack view, all you need to do<a id="_idTextAnchor131"/> is add one to your new view controller in Interface Builder via <code>Stack View</code>).</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor132"/>Containing labels in a stack view</h2>
			<p>Let's start to <a id="_idIndexMarker197"/>create our page layout: </p>
			<ol>
				<li value="1">Adding in six UILabel's, three will be titles, and the others will be variable data (make sure you set your colors correctly: see <a href="B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Dark Mode</em>). Something like this will work nicely:<div><img src="img/Figure_4.03_B14717.jpg" alt="Figure 4.3 – Updated storyboard with labels&#13;&#10;"/></div><p class="figure-caption">Figure 4.3 – Updated storyboard with labels</p></li>
				<li>Now, select the six labels in the contact info view and embed them in a stack view by using the <strong class="bold">Embed In</strong> menu as shown in the following screenshot:<div><img src="img/Figure_4.04_B14717.jpg" alt="Figure 4.4 – Embed In Stack View&#13;&#10;"/></div><p class="figure-caption">Figure 4.4 – Embed In Stack View</p></li>
				<li>Add in two other elements, such as image view or contact name, and group those together (separately from the labels you've just embedded).</li>
				<li>Now, for the clever part, highlight both stack views and click on <strong class="bold">Embed In</strong> to embed them into a single Stack View.</li>
			</ol>
			<p>Looking good. Well, almost – we'll still need to make a few minor tweaks. First, we'll add an <code>Autolayout</code> constraint to our main stack view of <code>0,16,16,0</code> (basically, hugging this to our bounds apart from the trailing and leading).</p>
			<p>Next, you'll <a id="_idIndexMarker198"/>need to set a height in <strong class="bold">Autolayout</strong> for each label (and image) inside your stack view: </p>
			<ol>
				<li value="1">Set your constraint values to <code>250</code> and all labels to <code>25</code>.</li>
				<li>Once done, select the parent stack view and within <strong class="bold">Attributes Inspector</strong>, make sure that <strong class="bold">Alignment</strong> is set to <strong class="bold">Fill</strong> and <strong class="bold">Distribution</strong> is set to <strong class="bold">Fill Proportionally</strong>. </li>
			</ol>
			<p>These settings make sure that items are positioned a certain way within the stack view. In this case, <strong class="bold">Leading</strong> makes the items stick to the left side of the stack view. Setting this value to <strong class="bold">Center</strong> would align them in the middle, and <strong class="bold">Fill</strong> ensures that the stack's children are all stretched out to fill the entire width.</p>
			<p>Once you've done that, you should have something that looks like the following:</p>
			<div><div><img src="img/Figure_4.05_B14717.jpg" alt="Figure 4.5 – Detail View in Stack View&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Detail View in Stack View</p>
			<p>Now our <a id="_idIndexMarker199"/>detail view is all ready for some data, so let's see how we go about doing that in the next part, but first, we'll need to create a new <strong class="bold">View Controller</strong> file.</p>
			<p>In the navigation tree, highlight the root level group (folder) and do the following:</p>
			<ol>
				<li value="1">Secondary-click to bring up the menu.</li>
				<li>Click on <strong class="bold">New File</strong>.</li>
				<li>Select <strong class="bold">Cocoa Touch Class</strong> from the list of options (click <strong class="bold">Next</strong>).</li>
				<li>Name the new file <code>DetailsViewController</code> with a subclass of <code>UIViewController</code>.</li>
				<li>Click <strong class="bold">Next</strong> and then <strong class="bold">Create</strong>.</li>
			</ol>
			<p>Once you've done this, add in all the required outlets and hook them up. But before Interface Builder will let you hook these up, you'll need to set the class of your <code>DetailsViewController</code> – just as we did with the custom cells back in <a href="B14717_03_Final_ASB_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Using Lists and Tables</em>.</p>
			<p>We'll also need to <a id="_idIndexMarker200"/>add in the following variable, as we'll be passing this model across to our new View Controller very soon:</p>
			<pre>var contact = CNContact()</pre>
			<p>With all that done, we can now look to update our <code>retrieveContacts()</code> logic to fetch the new data we require.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor133"/>Passing data between view controllers</h1>
			<p>So, the next part <a id="_idIndexMarker201"/>of our app is to pass some data over to our new details view but to do this, we need to create a new View Controller and hook up our labels and images to some outlets. </p>
			<p>The code that fetches contact information also needs to be updated too, so a contact's phone number, email address, and postal address are fetched.</p>
			<p>Finally, the contact data needs to be passed from the overview to the details page so the details page can display the data. The steps involved in this process are the following:</p>
			<ol>
				<li value="1">Updating the data loading</li>
				<li>Passing the model to t<a id="_idTextAnchor134"/>he details page</li>
				<li>Updating our outlets</li>
				<li>Best practices (creating a view model)</li>
			</ol>
			<p>Let's now go through each step.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor135"/>Updating the data loading</h2>
			<p>Currently, the code in <code>ViewController.swift</code> specifies that just the given name, family name, image <a id="_idIndexMarker202"/>data, and image availability for a contact should be fetched. </p>
			<p>This needs to be expanded so the email address, postal address, and phone number are fetched as well. </p>
			<p>Update the <code>retrieveContacts(store:)</code> method with the following code for <code>keysToFetch</code>:</p>
			<pre>let keysToFetch = [CNContactGivenNameKey as CNKeyDescriptor,
  CNContactFamilyNameKey as CNKeyDescriptor, CNContactImageDataAvailableKey as CNKeyDescriptor, CNContactImageDataKey as CNKeyDescriptor, 
     CNContactEmailAddressesKey as CNKeyDescriptor, CNContactPhoneNumbersKey as CNKeyDescriptor, CNContactPostalAddressesKey as CNKeyDescriptor]</pre>
			<p>Here, we are just explicitly setting the desired data we would like to retrieve from our contacts. Once we've done this, we're ready to pass the data across to our details view controller.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor136"/>Passing the model to the details page</h2>
			<p>The transition from the overview page to the details page is implemented with a segue. The segue is <a id="_idIndexMarker203"/>triggered when the user taps a contact, putting the details page on the screen. </p>
			<p>Because this transition uses a segue, there is a special method that can be implemented to pass data from the first view controller to the second view controller. This special method is called <code>prepare(for:sender:)</code>.</p>
			<p>This method is called on the source view controller right before a segue is performed and it provides access to the destination view controller. </p>
			<p>The segue's destination is used to configure data on the view controller that is about to be presented. Let's implement this right now so you can pass the selected contact to the details page. </p>
			<p>Add the following extension to <code>ViewController.swift</code>:</p>
			<pre>extension ViewController {
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let contactDetailVC = segue.destination as? DetailsViewController,
            segue.identifier == "detailViewSegue",
            let selectedIndex = collectionView.indexPathsForSelectedItems?.first {
            
            contactDetailVC.contact = contacts[selectedIndex.row]
            
        }
    }
}</pre>
			<p>A quick overview <a id="_idIndexMarker204"/>of the preceding code is the segue is checked to see if its identifier is <code>"detailViewSegue"</code> (as all segues will pass through this function). If this condition is satisfied, it checks the destination (which is of type <code>UIViewController</code>) is that of the <code>DetailsViewController</code> we are looking for.</p>
			<p>If all is well, we can assign our contact to a property on that View Controller and it will get passed across. Let's hook up our outlets now so we can start to bind some data.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor137"/>Updating our outlets</h2>
			<p>We're all set <a id="_idIndexMarker205"/>to go; we just need to hook up our data to our outlets. To do this, make the following changes in your <code>viewDidLoad()</code> in <code>DetailsViewController</code>:</p>
			<pre>contactImageView.image = UIImage(data: contact.imageData ?? Data())
contactName.text = "\(contact.givenName) \(contact.familyName)"
contactPhoneNumber.text = contact.phoneNumbers.first?.value.stringValue
contactEmailAddress.text = contact.emailAddresses.first?.value as String?
contactAddress.text = contact.postalAddresses.first?.value.street</pre>
			<p>Go ahead and run your app. Lo and behold, if you tap on your contacts, you'll be navigated straight to your new view controller, where you'll be able to see all the details of that particular contact.</p>
			<p>However, taking another look at the code we've just added in, it looks a little messy. We're concatenating <code>givenName</code> and <code>familyName</code> inside our <strong class="bold">View Controller</strong>, and also randomly grabbing the street value from the first persisted address that our contact has. </p>
			<p>All this logic should <a id="_idIndexMarker206"/>not sit in our view controller – this is what we call View model logic, and by that I mean we should create our own contact model that takes everything we need along with all the logic to get it straight from our <code>CNContent</code> object. Let's take a look at how we'd do that.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor138"/>Best practices – creating a view model</h2>
			<p>In our example, our <code>CNContact</code> has multiple properties, some of which we've not even <a id="_idIndexMarker207"/>requested yet from <code>Contacts.framework</code>. As we saw with the logic in the previous section, making logic decisions based on what the view requires and what the model has should not be performed at this level. </p>
			<p>So how can we fix that? Easy. To start with, let's create our custom model. Copy the following to a new file and call it <code>ContactModel.swift</code>:</p>
			<pre>struct ContactModel {
    
    var fullName: String?
    var primaryPhoneNumber: String?
    var primaryEmailAddress: String?
    var addressLine1: String?
    var contactImage: UIImage?
    
    init(_ contact: CNContact) {
        fullName = "\(contact.givenName) \(contact.familyName)"
        primaryPhoneNumber = contact.phoneNumbers.first?.value.stringValue
        primaryEmailAddress = contact.emailAddresses.first?.value as String?
        addressLine1 = contact.postalAddresses.first?.value.street
        contactImage = UIImage(data: contact.imageData ?? Data()) ?? UIImage(systemName: "person.circle")
    }
    
}</pre>
			<p>Here, we've simply created a struct and added properties based on exactly what we're going to display. We'll <a id="_idIndexMarker208"/>then create a custom initializer, which accepts a parameter of <code>CNContact</code>. From here, we strip out all the logic that we originally had in our View Controller and put it in here – one central location for this view model logic.</p>
			<p>All we need to do now is a couple of tweaks. Update our class variable in <code>DetailsViewController</code> to the following:</p>
			<pre>var contact: ContactModel?</pre>
			<p>And adjust our <code>prepare()</code> override in <code>ViewController</code> to the following:</p>
			<pre>contactDetailVC.contact = ContactModel(contacts[selectedIndex.row])</pre>
			<p>With that done, run the app again. You'll see that nothing really changed, but you can walk away now knowing that you've taken some great steps into writing and managing good, maintainable code.</p>
			<p>In this section, we <a id="_idIndexMarker209"/>stitched everything together by using the prepare for segue function to transfer our model over to our <code>DetailViewController</code>.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor139"/>Summary</h1>
			<p>In this section, we started by creating a brand-new View Controller dedicated to displaying selected user information. We learned about the different types of segues, including navigation-based segues and model-based segues. We were also introduced to creating segues both programmatically and via Interface Builder.</p>
			<p>Once we had our connectors all set up, we then started to build our new Detail View Controller, populating it with a contact's information and using the power of <code>UIStackView</code> to lay out our labels and image views.</p>
			<p>We finished off by wiring everything together. We performed some best practices and created a custom view model that we can now pass over to our new <code>prepare()</code> override.</p>
			<p>In the next chapter, we'll go deep into the use of animations and transitions in iOS as we start to get creative!</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor140"/>Further reading</h1>
			<ul>
				<li><strong class="bold">Apple Documentation</strong>: <a href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html">https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html</a></li>
			</ul>
		</div>
	</body></html>