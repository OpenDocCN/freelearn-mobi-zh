["```swift\n UIView.animate(withDuration: 2.0, animations: {\n            sampleView.alpha = 0.0\n        }) { (finished) in\n}\n```", "```swift\n struct UsingAnimationModifier: View {\n    @State var width: CGFloat = 50\n    @State var height: CGFloat = 50\n    var body: some View {\n        ZStack {\n            Circle()\n                .frame(width:width, height:height)\n                .foregroundColor(.blue) <st c=\"5797\">.animation(.easeIn, value: width)</st> .onTapGesture {\n                    width += 50\n                    height += 50\n                }\n        }\n    }\n}\n```", "```swift\n struct UsingWithAnimationFunction: View {\n    @State var greenCircleYPosition: CGFloat = 400\n    @State var redCircleYPosition: CGFloat = 800\n    var body: some View {\n        VStack {\n            ZStack {\n                Circle()\n                    .size(width: 100.0, height: 100.0)\n                    .foregroundColor(.green)\n                    .position(x: 400, y:\n                      greenCircleYPosition)\n                Circle()\n                    .size(width: 100.0, height: 100.0)\n                    .foregroundColor(.red)\n                    .position(x: 200, y:\n                      redCircleYPosition)\n            }\n            Button(\"Animate\") { <st c=\"7335\">withAnimation {</st>\n <st c=\"7350\">greenCircleYPosition =</st>\n <st c=\"7373\">greenCircleYPosition == 400 ?</st> <st c=\"7404\">800 :</st>\n <st c=\"7409\">400</st>\n <st c=\"7413\">redCircleYPosition = redCircleYPosition</st>\n <st c=\"7453\">== 800 ?</st> <st c=\"7463\">400 : 800</st>\n <st c=\"7472\">}</st> }\n        }\n    }\n}\n```", "```swift\n struct WithAnimationCompletionBlock: View {\n    @State var yPos: CGFloat = 300\n    @State var isReset: Bool = false\n    var body: some View {\n        VStack {\n            Circle()\n                .foregroundColor(.blue)\n                .frame(width: 50, height:50)\n                .position(x: 200, y:yPos)\n            Button(isReset ? \"Reset\" : \"Start\") { <st c=\"8155\">withAnimation</st> {\n                    if isReset {\n                        yPos = 300\n                    } else {\n                        yPos = 500\n                    } <st c=\"8217\">} completion: {</st>\n <st c=\"8232\">isReset.toggle()</st>\n <st c=\"8249\">}</st> }\n        }\n    }\n}\n```", "```swift\n withAnimation<st c=\"9179\">(.bouncy(extraBounce: 0.3))</st> {\n       if isReset {\n           yPos = 300\n       } else {\n           yPos = 500\n       }\n   } completion: {\n       isReset.toggle()\n   }\n}\n```", "```swift\n withAnimation(.smooth(extraBounce: 0.3))\n```", "```swift\n withAnimation(.snappy)\n```", "```swift\n struct BuiltInTransitionsView: View {\n    @State var showSlideText: Bool = false\n    var body: some View {\n        VStack {\n            Button(\"Slide in text\") { <st c=\"11473\">withAnimation {</st> showSlideText.toggle()\n                }\n            }\n            if showSlideText {\n                Text(\"Hello, slided\n                  text\")<st c=\"11561\">.transition(.slide)</st> }\n      }\n}\n```", "```swift\n     Text(\"Hello, moved text\")\n                        .transition(.move(edge: .bottom))\n    ```", "```swift\n     Text(\"Hello, scaled text\")\n                        .transition(.scale(scale: 0.5, anchor: .center))\n    ```", "```swift\n     Text(\"Hello, opacity text\")\n                        .transition(.opacity)\n    ```", "```swift\n Text(\"Text scaled in. Now it will slide out\")\n <st c=\"13183\">.transition(.asymmetric(insertion: .scale, removal:</st>\n<st c=\"13272\">scale</st> animation for the insertion of text and a <st c=\"13320\">slide</st> animation for the removal of text.\n\t\t\t<st c=\"13360\">Sometimes, we may want to combine several animations.</st> <st c=\"13415\">For example, we may want to scale</st> <st c=\"13449\">and slide at the same time.</st> <st c=\"13477\">We can do that using the</st> `<st c=\"13502\">combined</st>` <st c=\"13510\">function:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"13586\">We can even combine a</st> <st c=\"13609\">combined transition!</st>\n\n```", "```swift\n\n\t\t\t<st c=\"13696\">However, if things become too complicated, it could be a sign that we should build a</st> <st c=\"13782\">custom transition.</st>\n\t\t\t<st c=\"13800\">Creating a custom transition</st>\n\t\t\t<st c=\"13829\">Building</st> **<st c=\"13839\">custom transitions</st>** <st c=\"13857\">gives us complete control and flexibility of how transitions</st> <st c=\"13919\">work and is useful when other compound transition methods</st> <st c=\"13977\">don’t provide the</st> <st c=\"13995\">expected results.</st>\n\t\t\t<st c=\"14012\">The idea of building a custom transition is built around providing two</st> <st c=\"14084\">view modifiers:</st>\n\n\t\t\t\t*   <st c=\"14099\">One that represents the</st> *<st c=\"14124\">identity</st>* <st c=\"14132\">state of the view (before we started</st> <st c=\"14170\">the transition)</st>\n\t\t\t\t*   <st c=\"14185\">One that represents the</st> *<st c=\"14210\">active</st>* <st c=\"14216\">state of the view (after</st> <st c=\"14242\">the transition)</st>\n\n\t\t\t<st c=\"14257\">Both view modifiers must be of the same type so that SwiftUI has the same properties</st> <st c=\"14343\">to transition.</st>\n\t\t\t<st c=\"14357\">Let’s create a custom transition that takes a view and inserts it with rotation, opacity,</st> <st c=\"14448\">and scale.</st>\n\t\t\t<st c=\"14458\">We will start by creating a view modifier that handles all the</st> <st c=\"14522\">three properties:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"14756\">The</st> `<st c=\"14761\">ViewRotationModifier</st>` <st c=\"14781\">view modifier receives three properties,</st> `<st c=\"14823\">angle</st>`<st c=\"14828\">,</st> `<st c=\"14830\">opacity</st>`<st c=\"14837\">, and</st> `<st c=\"14843\">scale</st>`<st c=\"14848\">, and applies them to the content.</st> <st c=\"14883\">This view modifier is like any view modifier we’re</st> <st c=\"14934\">accustomed to.</st>\n\t\t\t<st c=\"14948\">Now, we can</st> <st c=\"14961\">build our custom transition.</st> <st c=\"14990\">If we look at the built-in transitions we covered in the previous</st> *<st c=\"15056\">Implementing built-in transitions</st>* <st c=\"15089\">section and their code’s documentation, we can see that they are from the type</st> `<st c=\"15169\">AnyTransition</st>`<st c=\"15182\">.</st> `<st c=\"15184\">AnyTransition</st>` <st c=\"15197\">is a struct that describes a SwiftUI transition between</st> <st c=\"15254\">two states.</st>\n\t\t\t<st c=\"15265\">Let’s build our</st> `<st c=\"15282\">rotate</st>` `<st c=\"15288\">AnyTransition</st>`<st c=\"15302\">:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"15500\">The</st> `<st c=\"15505\">AnyTransition</st>` <st c=\"15518\">struct we created receives the</st> `<st c=\"15550\">active</st>` <st c=\"15556\">and</st> `<st c=\"15561\">identity</st>` <st c=\"15569\">view modifiers, each with</st> <st c=\"15596\">different parameters.</st>\n\t\t\t<st c=\"15617\">We can</st> <st c=\"15625\">use the new transition in the same way as the</st> <st c=\"15671\">built-in transitions:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"16015\">The preceding code creates a rectangle and a button.</st> <st c=\"16069\">Tapping on the button toggles the</st> `<st c=\"16103\">showRectangle</st>` <st c=\"16116\">state variable, which reveals the rectangle using our</st> <st c=\"16171\">new transition.</st>\n\t\t\t<st c=\"16186\">So far, we have discussed great animations that were pretty simple and short.</st> <st c=\"16265\">However, if we</st> <st c=\"16280\">want to provide more sophisticated animations that may require multiple stages and different timing,</st> `<st c=\"16381\">AnyTransition</st>` <st c=\"16394\">structure is insufficient.</st> <st c=\"16422\">For much more advanced animations, we should try to implement</st> <st c=\"16484\">keyframe animations.</st>\n\t\t\t<st c=\"16504\">Executing keyframe animations</st>\n\t\t\t<st c=\"16534\">The idea</st> <st c=\"16544\">of</st> **<st c=\"16547\">keyframe animations</st>** <st c=\"16566\">in SwiftUI is similar to how they are implemented</st> <st c=\"16617\">in UIkit.</st>\n\t\t\t<st c=\"16626\">With</st> <st c=\"16632\">keyframe animations, we declare different changes in different properties over time.</st> <st c=\"16717\">There are four primary components</st> <st c=\"16751\">in</st> <st c=\"16754\">keyframe animations:</st>\n\n\t\t\t\t*   `<st c=\"16900\">AnimationsProperties</st>` <st c=\"16920\">struct can define the opacity, scale, or color in different</st> <st c=\"16981\">animation phases.</st>\n\t\t\t\t*   `<st c=\"16998\">KeyFrameAnimator</st>`<st c=\"17015\">: The keyframe animator defines the different animation tracks we have and what happens with the view in</st> <st c=\"17121\">each track.</st>\n\t\t\t\t*   `<st c=\"17132\">KeyframeTrack</st>`<st c=\"17146\">: Each track handles a different animation property and defines the various phases (key frames) for that property.</st> <st c=\"17262\">Tracks work in parallel with each other.</st> <st c=\"17303\">A keyframe animator can have</st> <st c=\"17332\">multiple tracks.</st>\n\t\t\t\t*   `<st c=\"17348\">KeyFrame</st>`<st c=\"17357\">: Defines a single change for a specific property within the</st> <st c=\"17419\">keyframe track.</st>\n\n\t\t\t<st c=\"17434\">With these</st> <st c=\"17446\">four primary components, we can build amazing and complex animations.</st> <st c=\"17516\">Let’s build our first keyframe animation with SwiftUI, but we’ll start by explaining the concept behind</st> <st c=\"17620\">keyframe animations.</st>\n\t\t\t<st c=\"17640\">Understanding a keyframe animation</st>\n\t\t\t<st c=\"17675\">Describing a</st> <st c=\"17689\">keyframe animation can be slightly confusing at first, mainly because it is a way to create complex animations.</st> <st c=\"17801\">Let’s try to explain it in a diagram (</st>*<st c=\"17839\">Figure 6</st>**<st c=\"17848\">.1</st>*<st c=\"17850\">):</st>\n\t\t\t![Figure 6.1: A key frame animation as a diagram](img/B21795_06_1.jpg)\n\n\t\t\t<st c=\"17894\">Figure 6.1: A key frame animation as a diagram</st>\n\t\t\t*<st c=\"17940\">Figure 6</st>**<st c=\"17949\">.1</st>* <st c=\"17951\">shows two tracks – scale and opacity – positioned on a timeline.</st> <st c=\"18017\">In each track, we see two keyframes.</st> <st c=\"18054\">The number inside each keyframe describes the value, and the keyframe length describes its duration.</st> <st c=\"18155\">For example, in the scale track, we have two keyframes – the first sets the scale to 0.7, and the second brings it back to 1.0\\.</st> <st c=\"18283\">We can also see that the durations of both the scale and opacity tracks</st> <st c=\"18355\">are equal.</st>\n\t\t\t<st c=\"18365\">If you think that that resembles a video editing application such as</st> *<st c=\"18435\">iMovie</st>* <st c=\"18441\">or</st> *<st c=\"18445\">Premiere</st>*<st c=\"18453\">, that’s because it is based on the</st> <st c=\"18489\">same concept.</st>\n\t\t\t<st c=\"18502\">Let’s try to create a breathing animation using the concept of keyframe animation.</st> <st c=\"18586\">A breathing animation mimics the way something breathes, such as a balloon slowly inflating</st> <st c=\"18678\">and deflating.</st>\n\t\t\t<st c=\"18692\">Let’s see how to do that</st> <st c=\"18718\">in code:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"19286\">The code example seems long!</st> <st c=\"19316\">However, upon closer examination, we can see that it is not that complex and contains the different components we</st> <st c=\"19430\">discussed earlier.</st>\n\t\t\t<st c=\"19448\">Let’s explain</st> <st c=\"19463\">what we’ve</st> <st c=\"19474\">done here:</st>\n\n\t\t\t\t1.  <st c=\"19484\">We created a circle and added a view modifier called</st> `<st c=\"19538\">keyframeAnimator</st>`<st c=\"19554\">, which handles the general animations.</st> <st c=\"19594\">We initialized it with the</st> `<st c=\"19621\">AnimationProperties</st>` <st c=\"19640\">struct that holds the properties we want to modify during the animation phases, and we defined that animator to repeat by passing</st> `<st c=\"19771\">true</st>` <st c=\"19775\">in the</st> <st c=\"19783\">corresponding parameter.</st>\n\t\t\t\t2.  <st c=\"19807\">The animator has another closure parameter with the content view and the value.</st> <st c=\"19888\">That’s where we can</st> *<st c=\"19908\">modify our view</st>* <st c=\"19923\">according to the animation properties.</st> <st c=\"19963\">In this example, we changed the view opacity</st> <st c=\"20008\">and scale.</st>\n\t\t\t\t3.  <st c=\"20018\">Right after the closure, we define our tracks.</st> <st c=\"20066\">We have two properties we want to change over time, so we’ve created two tracks – one for scale and one for opacity.</st> <st c=\"20183\">Because we wanted a</st> *<st c=\"20203\">breathing</st>* <st c=\"20212\">animation, we’ve created two keyframes – one for exhaling (scale down and reduce opacity) and one for inhaling (scale up and</st> <st c=\"20338\">increase opacity).</st>\n\t\t\t\t4.  <st c=\"20356\">We can see that each one of the frames is declared as</st> `<st c=\"20411\">CubicKeyframe</st>`<st c=\"20424\">. Before we explain what</st> `<st c=\"20449\">CubicKeyframe</st>` <st c=\"20462\">means, let’s talk about keyframes, which are fundamental concepts</st> <st c=\"20529\">in animations.</st>\n\n\t\t\t<st c=\"20543\">A keyframe specifies an object’s state at a particular point in time.</st> <st c=\"20614\">The animator’s responsibility is to perform the animations between these keyframes.</st> <st c=\"20698\">In a way, it’s like animating a state change, but in this case, we define the different</st> <st c=\"20786\">modifications upfront.</st>\n\t\t\t<st c=\"20808\">In the case of SwiftUI’s</st> `<st c=\"20834\">keyframeAnimator</st>`<st c=\"20850\">, the keyframes align with the concept of states – each keyframe defines a change in a specific property</st> <st c=\"20955\">over time.</st>\n\t\t\t<st c=\"20965\">In SwiftUI, we have different types of keyframes, each representing a</st> <st c=\"21036\">different experience:</st>\n\n\t\t\t\t*   `<st c=\"21057\">CubicKeyframe</st>`<st c=\"21071\">: This</st> <st c=\"21079\">is the keyframe we used</st> <st c=\"21103\">in our code example.</st> `<st c=\"21124\">CubicKeyframe</st>` <st c=\"21137\">provides</st> <st c=\"21147\">a smooth transition to the next keyframe while computing something called</st> **<st c=\"21221\">Catmull-Rom splines</st>**<st c=\"21240\">. Catmull-Rom splines are curves used in computer animations to provide</st> <st c=\"21312\">smooth movement.</st>\n\t\t\t\t*   `<st c=\"21328\">SpringKeyframe</st>`<st c=\"21343\">: This</st> <st c=\"21351\">represents a transition</st> <st c=\"21375\">that emulates a spring experience, including a</st> <st c=\"21422\">bouncy effect.</st>\n\t\t\t\t*   `<st c=\"21436\">MoveKeyframe</st>`<st c=\"21449\">: This</st> <st c=\"21457\">type of keyframe modifies</st> <st c=\"21483\">the given</st> <st c=\"21493\">value immediately.</st>\n\t\t\t\t*   `<st c=\"21511\">LinearKeyframe</st>`<st c=\"21526\">: This</st> <st c=\"21534\">keyframe animates</st> <st c=\"21552\">the change without a defined curve and, instead, does that in a simple</st> <st c=\"21623\">linear interpolation.</st>\n\n\t\t\t<st c=\"21644\">SwiftUI is</st> <st c=\"21656\">intelligent enough to smoothly handle the combination of different keyframes on the same track.</st> <st c=\"21752\">For example, let’s see what happens when we define velocity on one of</st> <st c=\"21822\">our keyframes:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"21944\">We can see that the end velocity of the first keyframe is</st> `<st c=\"22003\">0.8</st>`<st c=\"22006\">. However, we haven’t defined any initial velocity for the second keyframe.</st> <st c=\"22082\">In this case, the second keyframe’s</st> `<st c=\"22118\">startVelocity</st>` <st c=\"22131\">value will be the end value of the previous keyframe, which</st> <st c=\"22192\">means</st> `<st c=\"22198\">0.8</st>`<st c=\"22201\">.</st>\n\t\t\t<st c=\"22202\">Now, let’s discuss another crucial aspect of keyframe animations –</st> <st c=\"22270\">animation duration.</st>\n\t\t\t<st c=\"22289\">Handling keyframe animation duration</st>\n\t\t\t<st c=\"22326\">The keyframe animator is a hierarchal structure with three levels – the animator, the tracks, and the keyframe.</st> <st c=\"22439\">This means that different keyframes can have different durations, and these duration values don’t always add up nicely.</st> <st c=\"22559\">That makes duration management complex, especially for long and</st> <st c=\"22623\">intricate animations.</st>\n\t\t\t<st c=\"22644\">How do we</st> <st c=\"22655\">ensure that all the keyframe durations are always aligned with each other and maintain the same scale?</st> <st c=\"22758\">The answer is to use relative duration, not</st> <st c=\"22802\">absolute duration.</st>\n\t\t\t<st c=\"22820\">An absolute duration specifies the exact time an animation should take, regardless of the initial state, or without comparing it to the</st> <st c=\"22957\">other keyframes.</st>\n\t\t\t<st c=\"22973\">Conversely, relative duration reflects the duration time, considering the total animation duration.</st> <st c=\"23074\">For example, if the relative duration is 0.5 and the total animation duration is 3 seconds, the actual keyframe duration would be 1.5 (0.5 *</st> <st c=\"23215\">3.0 seconds).</st>\n\t\t\t<st c=\"23228\">By using relative duration, we can establish an animation’s overall duration and allocate specific durations for each keyframe, relative to the</st> <st c=\"23373\">total duration.</st>\n\t\t\t<st c=\"23388\">Let’s take our “breathing” example and try to implement</st> <st c=\"23445\">relative duration:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"23992\">In this code example, we have a keyframe animation with two keyframes, similar to our previous example.</st> <st c=\"24097\">The first keyframe handles the scale animation, and the second handles</st> <st c=\"24168\">the opacity.</st>\n\t\t\t<st c=\"24180\">We can see</st> <st c=\"24192\">that we have a total duration variable, currently set to</st> `<st c=\"24249\">1.8</st>`<st c=\"24252\">. With each keyframe, we set the duration relative to that value.</st> <st c=\"24318\">In this case, it is</st> `<st c=\"24338\">0.5</st>` <st c=\"24341\">of the total duration, but this can vary from one example</st> <st c=\"24400\">to another.</st>\n\t\t\t<st c=\"24411\">Relative duration can help us set a dynamic overall duration time and change it according to our needs, even</st> <st c=\"24521\">at runtime.</st>\n\t\t\t<st c=\"24532\">SwiftUI animations are extremely powerful and easy to use, and keyframe animations make them even more powerful by allowing us to build complex animations with multiple steps</st> <st c=\"24708\">and durations.</st>\n\t\t\t<st c=\"24722\">However, in many cases, animating views is one of the many challenges that app developers face.</st> <st c=\"24819\">After all, animating simple shapes such as a rectangle or a circle isn’t always what we desire.</st> <st c=\"24915\">So, what about the assets?</st> <st c=\"24942\">Fortunately, the iOS SDK contains a fantastic resource called SF Symbols.</st> <st c=\"25016\">Let’s explore</st> <st c=\"25030\">it now.</st>\n\t\t\t<st c=\"25037\">Animating SF Symbols</st>\n\t\t\t**<st c=\"25058\">SF Symbols</st>** <st c=\"25069\">is a library that</st> <st c=\"25088\">contains over 5,000 symbols that developers can integrate within their text, using the</st> *<st c=\"25175\">San</st>* *<st c=\"25179\">Francisco</st>* <st c=\"25188\">font.</st>\n\t\t\t<st c=\"25194\">Don’t be</st> <st c=\"25204\">confused – SF Symbols are not emojis.</st> <st c=\"25242\">Emojis are meant to express feelings and emotions within text.</st> <st c=\"25305\">Conversely, SF Symbols are excellent replacements for icons that represent states, actions,</st> <st c=\"25397\">and tools.</st>\n\t\t\t<st c=\"25407\">Here’s a basic example of displaying a clock alarm symbol with text next</st> <st c=\"25481\">to it:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"25613\">We can see no surprises here – we use a basic</st> `<st c=\"25660\">Image</st>` <st c=\"25665\">view with the</st> `<st c=\"25680\">systemName</st>` <st c=\"25690\">parameter to provide the</st> <st c=\"25716\">image name.</st>\n\t\t\t<st c=\"25727\">As mentioned earlier in this section, there are thousands of symbols available.</st> <st c=\"25808\">To get the full symbols catalog, we need</st> <st c=\"25849\">to download a Mac application called</st> *<st c=\"25886\">SF Symbols</st>* <st c=\"25896\">(what a coincidence, uh?)</st> <st c=\"25923\">from</st> [<st c=\"25928\">https://developer.apple.com/sf-symbols/</st>](https://developer.apple.com/sf-symbols/)<st c=\"25967\">.</st>\n\t\t\t<st c=\"25968\">The app is simple to use, as we can see in</st> *<st c=\"26012\">Figure 6</st>**<st c=\"26020\">.2</st>*<st c=\"26022\">:</st>\n\t\t\t![Figure 6.2: The SF Symbol Mac app](img/B21795_06_2.jpg)\n\n\t\t\t<st c=\"27085\">Figure 6.2: The SF Symbol Mac app</st>\n\t\t\t<st c=\"27118\">By exploring</st> <st c=\"27132\">the SF Symbol app, we can see how the symbols differ from emojis.</st> <st c=\"27198\">They are not only vector illustrations (meaning they can scale to any size) but also built</st> <st c=\"27289\">as layers.</st>\n\t\t\t<st c=\"27299\">To understand why the SF symbols contain layers, try to perform a bounce animation using the app.</st> <st c=\"27398\">Doing so lets us see how the layers create a</st> *<st c=\"27443\">sense of depth</st>*<st c=\"27457\">, making them bounce at</st> <st c=\"27481\">different intervals.</st>\n\t\t\t<st c=\"27501\">Other than the bounce effect, SF Symbols supports other effects such as pulse, scale, and replace.</st> <st c=\"27601\">We can perform the same animations in our SwiftUI code using the</st> `<st c=\"27666\">symbolEffect</st>` <st c=\"27678\">view modifier:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"27987\">The</st> `<st c=\"27992\">symbolEffect</st>` <st c=\"28004\">view modifier has several parameters.</st> <st c=\"28043\">The first is the</st> `<st c=\"28060\">effect</st>` <st c=\"28066\">type, the same as those found in the SF Symbol app.</st> <st c=\"28119\">The second parameter is</st> `<st c=\"28143\">options</st>` <st c=\"28150\">– we can make the effect repeat itself or even set</st> <st c=\"28202\">its speed.</st>\n\t\t\t<st c=\"28212\">The third</st> <st c=\"28223\">parameter is the</st> `<st c=\"28240\">value</st>` <st c=\"28245\">parameter – the state variable that triggers the animation.</st> <st c=\"28306\">In this case, we trigger the animation by tapping on the</st> `<st c=\"28363\">HStack</st>` <st c=\"28369\">view that contains both the symbol and the</st> <st c=\"28413\">attached text.</st>\n\t\t\t<st c=\"28427\">To read more about SF Symbols, it is recommended to visit Apple’s</st> <st c=\"28494\">website:</st> [<st c=\"28502\">https://developer.apple.com/sf-symbols/</st>](https://developer.apple.com/sf-symbols/)<st c=\"28542\">.</st>\n\t\t\t<st c=\"28543\">Even though this chapter mainly concerns SwiftUI animations, there is much more to SF Symbols than just animations, such as supporting multiple colors.</st> <st c=\"28696\">Let’s see how we can modify different</st> <st c=\"28734\">symbol colors.</st>\n\t\t\t<st c=\"28748\">Modifying symbol colors</st>\n\t\t\t<st c=\"28772\">The fact</st> <st c=\"28782\">that SF Symbols are built with different layers helps not only with animation but also with</st> <st c=\"28874\">coloring them.</st>\n\t\t\t<st c=\"28888\">Let’s take, for instance, the</st> *<st c=\"28919\">two persons</st>* *<st c=\"28931\">waving</st>* <st c=\"28937\">symbol:</st>\n\n```", "```swift\n\n\t\t\t*<st c=\"28982\">Figure 6</st>**<st c=\"28991\">.3</st>* <st c=\"28993\">shows what the symbol</st> <st c=\"29016\">looks like:</st>\n\t\t\t![Figure 6.3: The person.2.wave.2 symbol](img/B21795_06_3.jpg)\n\n\t\t\t<st c=\"29029\">Figure 6.3: The person.2.wave.2 symbol</st>\n\t\t\t<st c=\"29067\">We can see two different types of image components – on the one hand, two people, and on the</st> <st c=\"29161\">other hand, their waves.</st> <st c=\"29186\">So, unlike a regular image, we can set one color for the people and another for</st> <st c=\"29266\">the waves.</st>\n\t\t\t<st c=\"29276\">Every SF Symbol has a</st> **<st c=\"29299\">primary</st>** <st c=\"29306\">and</st> **<st c=\"29311\">secondary</st>** <st c=\"29320\">color, and SwiftUI knows how to color</st> <st c=\"29359\">it accordingly.</st>\n\t\t\t<st c=\"29374\">For example, let’s set a primary color of brown and a secondary color of blue.</st> <st c=\"29454\">We will use the</st> `<st c=\"29470\">foregroundStyle</st>` <st c=\"29485\">view modifier</st> <st c=\"29500\">for that:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"29578\">There are symbols that even have a third color, such as in the case of the three-person symbol (</st>*<st c=\"29675\">Figure 6</st>**<st c=\"29684\">.4</st>*<st c=\"29686\">):</st>\n\t\t\t![Figure 6.4: The person.3.sequence.fill symbol](img/B21795_06_4.jpg)\n\n\t\t\t<st c=\"29691\">Figure 6.4: The person.3.sequence.fill symbol</st>\n\t\t\t<st c=\"29736\">To use the third color, we just need to add one more color as</st> <st c=\"29799\">a parameter:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"29895\">Anyone who has had to manage multi-color icons knows the complexity of supporting different themes and colors, especially when we need to</st> <st c=\"30033\">animate them.</st>\n\t\t\t<st c=\"30046\">So, we know</st> <st c=\"30059\">how to add an SF Symbol, animate it nicely, and color it.</st> <st c=\"30117\">However, we can also use vector multi-layer symbols, which is known</st> <st c=\"30185\">as localization.</st>\n\t\t\t<st c=\"30201\">Localizing our symbols</st>\n\t\t\t<st c=\"30224\">Localizing our apps is a crucial topic today, more than ever.</st> <st c=\"30287\">However, how many of us pay attention</st> <st c=\"30325\">to icon localization and try to adjust them according to the app</st> <st c=\"30390\">layout direction?</st>\n\t\t\t<st c=\"30407\">The excellent news about SF Symbols is that they can adjust to the current app locale.</st> <st c=\"30495\">The even better news is that we can force them to do that if</st> <st c=\"30556\">we want.</st>\n\t\t\t<st c=\"30564\">But why do SF Symbols even need to</st> <st c=\"30600\">support localization?</st>\n\t\t\t<st c=\"30621\">Let’s take the</st> `<st c=\"30637\">arrowshape.turn.up.forward</st>` <st c=\"30663\">SF Symbol (</st>*<st c=\"30675\">Figure 6</st>**<st c=\"30684\">.5</st>*<st c=\"30686\">):</st>\n\n\t\t\t![Figure 6.5: The arrowshap.turn.up.forward SF Symbol](img/B21795_06_5.jpg)\n\n\t\t\t<st c=\"30691\">Figure 6.5: The arrowshap.turn.up.forward SF Symbol</st>\n\t\t\t<st c=\"30742\">The forward</st> <st c=\"30755\">icon arrow points to the right, which fits</st> <st c=\"30798\">nicely in</st> **<st c=\"30808\">LTR</st>** <st c=\"30811\">(</st>**<st c=\"30813\">Left-to-Right</st>**<st c=\"30826\">) layout views.</st> <st c=\"30843\">But what about</st> **<st c=\"30858\">RTL</st>** <st c=\"30861\">(</st>**<st c=\"30863\">Right-to-Left</st>**<st c=\"30876\">) layouts, such as in Hebrew or Arabic</st> <st c=\"30916\">localized applications?</st>\n\t\t\t<st c=\"30939\">Well, in this case, we will have to flip the icon direction.</st> <st c=\"31001\">With SF Symbol, this adjustment is done automatically</st> <st c=\"31055\">for us.</st>\n\t\t\t<st c=\"31062\">Moreover, we can set the icon localization regardless of the view settings, using the</st> `<st c=\"31149\">environment</st>` <st c=\"31160\">view modifier:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"31269\">In the preceding code, we force the SF Symbol to have an RTL layout direction, which flips the forward arrow to the</st> <st c=\"31386\">left direction.</st>\n\t\t\t<st c=\"31401\">Having localization</st> <st c=\"31422\">support doesn’t stop with layout direction.</st> <st c=\"31466\">Some symbols even change their look according to the</st> <st c=\"31519\">current locale.</st>\n\t\t\t<st c=\"31534\">For example, let’s take the</st> `<st c=\"31563\">character.book.closed</st>` <st c=\"31584\">SF Symbol (</st>*<st c=\"31596\">Figure 6</st>**<st c=\"31605\">.6</st>*<st c=\"31607\">):</st>\n\t\t\t![Figure 6.6: The character.book.closed SF Symbol](img/B21795_06_6.jpg)\n\n\t\t\t<st c=\"31612\">Figure 6.6: The character.book.closed SF Symbol</st>\n\t\t\t<st c=\"31659\">In the case of the symbol in</st> *<st c=\"31689\">Figure 6</st>**<st c=\"31697\">.6</st>*<st c=\"31699\">, we can see that in addition to its layout direction (LTR), it also has a letter</st> <st c=\"31781\">on it.</st>\n\t\t\t<st c=\"31787\">In the case of the Hebrew locale, not only does the symbol’s direction change but also the letter (</st>*<st c=\"31887\">Figure 6</st>**<st c=\"31896\">.7</st>*<st c=\"31898\">):</st>\n\t\t\t![Figure 6.7: The character.book.closed SF Symbol in a Hebrew locale](img/B21795_06_7.jpg)\n\n\t\t\t<st c=\"31903\">Figure 6.7: The character.book.closed SF Symbol in a Hebrew locale</st>\n\t\t\t<st c=\"31969\">We can force the symbol to retrieve a specific locale using the</st> `<st c=\"32034\">environment</st>` <st c=\"32045\">view modifier, similar to the</st> <st c=\"32076\">layout direction:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"32184\">To sum up, SF Symbols</st> <st c=\"32207\">contain so much power and valuable features.</st> <st c=\"32252\">Trying to support standard icons in different environments, such as locales and themes, can be a hassle, and animating them without creating a dedicated image sequence is almost impossible.</st> <st c=\"32442\">So, getting all these features for free is l</st><st c=\"32486\">ike a massive present from</st> <st c=\"32514\">Apple engineers.</st>\n\t\t\t<st c=\"32530\">Summary</st>\n\t\t\t<st c=\"32538\">iOS animations are like salt – they can enhance the user experience, but too much</st> <st c=\"32621\">is overwhelming.</st>\n\t\t\t<st c=\"32637\">The great thing about SwiftUI animations is that they are aligned to the screen state because of the declarative implementation.</st> <st c=\"32767\">However, it’s a significant change to how they work</st> <st c=\"32819\">in UIkit.</st>\n\t\t\t<st c=\"32828\">Because of that, in this chapter, we went from understanding the basic concepts and performing fundamental animations to custom transitions and keyframe animations, and we even discussed a great present that Apple gave us,</st> <st c=\"33052\">SF Symbols.</st>\n\t\t\t<st c=\"33063\">Now, we should be able to easily animate changes on our screen in a meaningful and</st> <st c=\"33147\">expressive way!</st>\n\t\t\t<st c=\"33162\">In our next chapter, we’ll explore enhancing user engagement using a built-in solution –</st> <st c=\"33252\">TipKit.</st>\n\n```"]