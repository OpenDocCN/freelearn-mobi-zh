["```swift\nenum PoolBallType { \n    case solid \n    case stripe \n    case black \n}\n```", "```swift\nfunc poolBallType(forNumber number: Int) -> PoolBallType { \n    if number < 8 { \n        return .solid \n    } else if number > 8 { \n        return .stripe \n    } else { \n        return .black \n    } \n}\n```", "```swift\nlet two = poolBallType(forNumber: 2) // .solid \nlet eight = poolBallType(forNumber: 8) // .black \nlet twelve = poolBallType(forNumber: 12) // .stripe \n```", "```swift\nif <#a boolean expression#> { \n    <#executed if boolean expression above is true#> \n} else if <#other boolean expression#> { \n    <#executed if other boolean expression above is true#> \n} else { \n    <#executed if neither boolean expressions are true#> \n} \n```", "```swift\nlet zero = poolBallType(forNumber: 0) // .solid \nlet sixteen = poolBallType(forNumber: 16) // .stripe\n```", "```swift\nfunc poolBallType(forNumber number: Int) -> PoolBallType? {\n    if number > 0 && number < 8 {\n        return .solid\n    } else if number > 8 && number < 16 {\n        return .stripe\n    } else if number == 8 {\n        return .black\n    } else {\n        return nil\n    }\n}\n```", "```swift\nlet two = poolBallType(forNumber: 2) // .solid \nlet eight = poolBallType(forNumber: 8) // .black \nlet twelve = poolBallType(forNumber: 12) // .stripe \nlet zero = poolBallType(forNumber: 0) // nil \nlet sixteen = poolBallType(forNumber: 16) // nil \n```", "```swift\nenum PoolBallType: String {\n    case solid\n    case stripe\n    case black\n}\n```", "```swift\nfunc printBallDetails(ofNumber number: Int) { \n    let possibleBallType = poolBallType(forNumber: number) \n    if let ballType = possibleBallType { \n        print(\"\\(number) - \\(ballType.rawValue)\") \n    } else { \n        print(\"\\(number) is not a valid pool ball number\") \n    } \n} \n```", "```swift\nlet possibleBallType = poolBallType(forNumber: number) \n```", "```swift\nif let ballType = possibleBallType { \n    print(\"\\(number) - \\(ballType.rawValue))\") \n} \n```", "```swift\nelse { \n    print(\"\\(number) is not a valid pool ball number\") \n}\n```", "```swift\nprintBallDetails(ofNumber: 2)  // 2 - solid\nprintBallDetails(ofNumber: 8)  // 8 - black\nprintBallDetails(ofNumber: 12) // 12 - stripe\nprintBallDetails(ofNumber: 0)  // 0 is not a valid pool ball number\nprintBallDetails(ofNumber: 16) // 16 is not a valid pool ball number\n```", "```swift\nclass PoolFrame { \n    var player1BallType: PoolBallType? \n    var player2BallType: PoolBallType? \n} \n```", "```swift\nclass PoolTable { \n    var currentFrame: PoolFrame? \n} \n```", "```swift\nfunc printBallTypeOfPlayer1(forTable table: PoolTable) { \n    if let frame = table.currentFrame, let ballType = \n      frame.player1BallType { \n        print(ballType.rawValue) \n    } else { \n        print(\"Player 1 has no ball type or there is no current frame\") \n    } \n} \n```", "```swift\nfunc printBallTypeOfPlayer1(forTable table: PoolTable) { \n    if let frame = table.currentFrame { \n        if let ballType = frame.player1BallType { \n            print(ballType.rawValue) \n        } //... handle else \n    } //... handle else \n} \n```", "```swift\nfunc printBallTypeOfPlayer1(forTable table: PoolTable) { \n    if let frame = table.currentFrame, let ballType = \n      frame.player1BallType { \n        print(\"\\(ballType)\") \n    } //... handle else  \n} \n```", "```swift\n//\n// Table with no frame in play\n//\nlet table = PoolTable()\ntable.currentFrame = nil\nprintBallTypeOfPlayer1(forTable: table)\n// Player 1 has no ball type or there is no current frame\n```", "```swift\n//\n// Table with frame in play, but no balls potted\n//\nlet frame = PoolFrame()\nframe.player1BallType = nil\nframe.player2BallType = nil\ntable.currentFrame = frame\nprintBallTypeOfPlayer1(forTable: table)\n// Player 1 has no ball type or there is no current frame\n\n```", "```swift\n//\n// Table with frame in play, and a ball potted\n//\nframe.player1BallType = .solid\nframe.player2BallType = .stripe\nprintBallTypeOfPlayer1(forTable: table)\n// solid\n```", "```swift\nenum FrameResult { \n    case win(congratulations: String) \n    case lose(commiserations: String) \n}\n```", "```swift\nfunc printMessage(forResult result: FrameResult) { \n    if case Result.win(congratulations: let winMessage) = result { \n        print(\"You won! \\(winMessage)\") \n    } else if case Result.lose(commiserations: let loseMessage) = \n        result { \n        print(\"You lost :( \\(loseMessage)\") \n    } \n} \n```", "```swift\nlet result = Result.win(congratulations: \"You're simply the best!\") \nprintMessage(forResult: result) // You won! You're simply the best! \n```", "```swift\nif case Result.win(congratulationsMessage: let winMessage) = result { \n    print(\"You won! \\(winMessage)\") \n} \n```", "```swift\nenum CompassPoint { \n    case north \n    case south \n    case east \n    case west \n}\n```", "```swift\nfunc lookTowards(_ direction: CompassPoint) { \n\n    switch direction { \n    case .north: \n        print(\"To the north lies a winding road\") \n    case .south: \n        print(\"To the south is the Prancing Pony tavern\") \n    case .east: \n        print(\"To the east is a blacksmith\") \n    case .west: \n        print(\"The the west is the town square\") \n    } \n} \n\nlookTowards(.south) // To the south is the Prancing Pony tavern\n```", "```swift\nenum Item { \n    case key \n    case lockedDoor \n    case openDoor \n    case bluntKnife \n    case sharpeningStone \n    case sharpKnife \n} \n```", "```swift\nfunc combine(_ firstItem: Item, with secondItem: Item) -> Item? { \n\n    switch (firstItem, secondItem) { \n    case (.key, .lockedDoor): \n        print(\"You have unlocked the door!\") \n        return .openDoor \n    case (.bluntKnife, .sharpeningStone): \n        print(\"Your knife is now sharp\") \n        return .sharpKnife \n    default: \n        print(\"\\(firstItem) and \\(secondItem) cannot be combined\") \n        return nil \n    } \n} \nlet door = combine(.key, with: .lockedDoor) // openDoor \nlet oilAndWater = combine(.bluntKnife, with: .lockedDoor) // nil\n```", "```swift\nenum Character: String { \n    case wizard \n    case bartender \n    case dragon \n}\n```", "```swift\nfunc say(_ textToSay: String, to character: Character? = nil) { \n\n    switch (textToSay, character) { \n    case (\"abracadabra\", .wizard?): \n        print(\"The wizard says, \\\"Hey, that's my line!\\\"\") \n    case (\"Pour me a drink\", .bartender?): \n        print(\"The bartender pours you a drink\") \n    case (\"Can I have some of your gold?\", .dragon?): \n        print(\"The dragon burns you to death with his fiery breath\") \n    case (let textSaid, nil): \n        print(\"You say \\\"\\(textSaid)\\\", to no-one.\") \n    case (_, let anyCharacter?): \n        print(\"The \\(anyCharacter) looks at you, blankly\") \n    } \n} \nsay(\"Is anybody there?\") \n  // You say \"Is anybody there?\", to no-one. \nsay(\"Pour me a drink\", to: .bartender) \n  // The bartender pours you a drink \nsay(\"Can I open a tab?\", to: .bartender) \n  // The bartender looks at you, blankly \n```", "```swift\nfunc lookTowards(_ direction: CompassPoint) { \n\n    switch direction { \n    case .north: \n        print(\"To the north lies a winding road\") \n    case .south: \n        print(\"To the south is the Prancing Pony tavern\") \n    case .east: \n        print(\"To the east is a blacksmith\") \n    case .west: \n        print(\"The the west is the town square\") \n    }\n}\n```", "```swift\nswitch <#value#> { \ncase <#pattern#>: \n    <#code#> \ncase <#pattern#>: \n    <#code#> \n//... \n} \n```", "```swift\nfunc combine(_ firstItem: Item, with secondItem: Item) -> Item? { \n\n    switch (firstItem, secondItem) { \n    //.... \n    } \n} \n```", "```swift\ncase (.key, .lockedDoor): \n    print(\"You have unlocked the door!\") \n    return .openDoor\n```", "```swift\nswitch (firstItem, secondItem) { \n//... \ndefault: \n    print(\"\\(firstItem) and \\(secondItem) cannot be combined\") \n    return nil \n} \n```", "```swift\nlet door1 = combine(.key, with: .lockedDoor) // openDoor \nlet door2 = combine(.lockedDoor, with: .key) // nil \n```", "```swift\nswitch <#value#> { \ncase <#pattern#>, <#pattern#>: \n    <#code#> \ndefault: \n    <#code#> \n} \n```", "```swift\nfunc combine(_ firstItem: Item, with secondItem: Item) -> Item? { \n\n    switch (firstItem, secondItem) { \n    case (.key, .lockedDoor), (.lockedDoor, .key): \n        print(\"You have unlocked the door!\") \n        return .openDoor \n    case (.bluntKnife, .sharpeningStone), (.sharpeningStone, \n      .bluntKnife): \n        print(\"Your knife is now sharp\") \n        return .sharpKnife \n    default: \n        print(\"\\(firstItem) and \\(secondItem) cannot be combined\") \n        return nil \n    } \n} \n\n```", "```swift\nlet door1 = combine(.key, with: .lockedDoor) // openDoor \nlet door2 = combine(.lockedDoor, with: .key) // openDoor\n```", "```swift\nfunc say(_ textToSay: String, to character: Character? = nil) { \n\n    switch (textToSay, character) { \n    case (\"abracadabra\", .wizard?): \n        print(\"The wizard says, \"Hey, that's my line!\"\") \n        //... \n    } \n} \n```", "```swift\nfunc say(_ textToSay: String, to character: Character? = nil) { \n\n    switch (textToSay, character) { \n    //... \n    case (_, let anyCharacter?): \n        print(\"The \\(anyCharacter) looks at you, blankly)\") \n    } \n} \n```", "```swift\nlet theBeatles = [\"John\", \"Paul\", \"George\", \"Ringo\"]\n```", "```swift\nfor musician in theBeatles { \n    print(musician) \n} \n```", "```swift\n// 5 times table \nfor value in 1...12 { \n    print(\"5 x \\(value) = \\(value*5)\") \n}\n```", "```swift\nlet beatlesByInstrument = [\"rhythm guitar\": \"John\", \n                           \"bass guitar\": \"Paul\", \n                           \"lead guitar\": \"George\", \n                           \"drums\": \"Ringo\"] \nfor (key, value) in beatlesByInstrument { \n    print(\"\\(value) plays \\(key)\") \n}\n```", "```swift\nfor musician in theBeatles { \n    print(musician) \n} \n```", "```swift\nfor <#each element#> in <#collection or range#> { \n    <#code to execute#> \n} \n```", "```swift\nfor value in 1...12 { \n    print(\"5 x \\(value) = \\(value*5)\") \n} \n\n```", "```swift\nfor value in 1..<13 { \n    print(\"5 x \\(value) = \\(value*5)\") \n} \n```", "```swift\nfor (key, value) in beatlesByInstrument { \n    print(\"\\(value) plays \\(key)\") \n} \n```", "```swift\nfor (instrument, musician) in beatlesByInstrument { \n    print(\"\\(musician) plays \\(instrument)\") \n} \n```", "```swift\nwhile <#boolean expression#> { \n    <#code to execute#> \n} \n```", "```swift\nimport Foundation\n```", "```swift\nenum CoinFlip: Int { \n    case heads \n    case tails \n\n    static func flipCoin() -> CoinFlip { \n        return CoinFlip(rawValue: Int(arc4random_uniform(2)))! \n    } \n} \n```", "```swift\nfunc howManyHeadsInARow() -> Int { \n\n    var numberOfHeadsInARow = 0 \n    var currentCoinFlip = CoinFlip.flipCoin() \n\n    while currentCoinFlip == .heads { \n        numberOfHeadsInARow = numberOfHeadsInARow + 1 \n        currentCoinFlip = CoinFlip.flipCoin() \n    } \n    return numberOfHeadsInARow \n} \n\nlet noOfHeads = howManyHeadsInARow()\n```", "```swift\nfunc howManyHeadsInARow() -> Int { \n\n    var numberOfHeadsInARow = 0 \n    var currentCoinFlip = CoinFlip.flipCoin() \n    //... \n}\n```", "```swift\nwhile currentCoinFlip == .heads { \n    numberOfHeadsInARow = numberOfHeadsInARow + 1 \n    currentCoinFlip = CoinFlip.flipCoin() \n} \n```", "```swift\nreturn numberOfHeadsInARow \n```", "```swift\nlet noOfHeads = howManyHeadsInARow() \n```", "```swift\nfunc howManyHeadsInARow() -> Int {\n\n    var numberOfHeadsInARow = 0\n\n    while CoinFlip.flipCoin() == .heads {\n        numberOfHeadsInARow = numberOfHeadsInARow + 1\n    }\n    return numberOfHeadsInARow\n}\n```", "```swift\nenum MealState { \n    case initial \n    case buyIngredients \n    case prepareIngredients \n    case cook \n    case plateUp \n    case serve \n}\n```", "```swift\nclass Meal {\n    var state: MealState = .initial\n}\n```", "```swift\nclass Meal {\n    private(set) var state: MealState = .initial\n}\n```", "```swift\nclass Meal {\n\n    private(set) var state: MealState = .initial\n\n    func change(to newState: MealState) throws {\n\n        switch (state, newState) {\n\n        case (.initial, .buyIngredients),\n             (.buyIngredients, .prepareIngredients),\n             (.prepareIngredients, .cook),\n             (.cook, .plateUp),\n             (.plateUp, .serve):\n\n            state = newState\n\n        default:\n            throw MealError.canOnlyMoveToAppropriateState\n        }\n    }\n}\n```", "```swift\nenum MealError: Error { \n    case canOnlyMoveToAppropriateState \n}\n```", "```swift\nlet dinner = Meal() \ndo { \n    try dinner.change(to: .buyIngredients) \n    try dinner.change(to: .prepareIngredients) \n    try dinner.change(to: .cook) \n    try dinner.change(to: .plateUp) \n    try dinner.change(to: .serve) \n    print(\"Dinner is served!\") \n} catch let error { \n    print(error) \n}\n```", "```swift\nfunc change(to newState: MealState) throws { \n    //... \n} \n```", "```swift\nfunc change(to newState: MealState) throws {\n    //...\n    default:\n         throw MealError.canOnlyMoveToAppropriateState\n    }\n}\n```", "```swift\nlet dinner = Meal() \ndo { \n    try dinner.change(to: .buyIngredients) \n    try dinner.change(to: .prepareIngredients) \n    try dinner.change(to: .cook) \n    try dinner.change(to: .plateUp) \n    try dinner.change(to: .serve) \n    print(\"Dinner is served!\") \n} catch let error { \n    print(error) \n} \n```", "```swift\ndo { \n    //... \n} catch { \n    print(error) \n} \n```", "```swift\nclass Meal { \n\n    private(set) var state: MealState = .initial \n\n    private func change(to newState: MealState) throws { \n\n        switch (state, newState) { \n        case (.initial, .buyIngredients), \n             (.buyIngredients, .prepareIngredients),  \n             (.prepareIngredients, .cook),  \n             (.cook, .plateUp),  \n             (.plateUp, .serve): \n            state = newState \n\n        default: \n            throw MealError.canOnlyMoveToAppropriateState \n        } \n    } \n} \n```", "```swift\nclass Meal { \n\n    //...\n\n    func buyIngredients() throws { \n        try change(to: .buyIngredients) \n    } \n\n    func prepareIngredients() throws { \n        try change(to: .prepareIngredients) \n    } \n\n    func cook() throws { \n        try change(to: .cook) \n    } \n\n    func plateUp() throws { \n        try change(to: .plateUp) \n    } \n\n    func serve() throws { \n        try change(to: .serve) \n    } \n} \n```", "```swift\nlet dinner = Meal() \ndo { \n    try dinner.buyIngredients() \n    try dinner.prepareIngredients() \n    try dinner.cook() \n    try dinner.plateUp() \n    try dinner.serve() \n    print(\"Dinner is served!\") \n} catch let error { \n    print(error) \n} \n```", "```swift\nclass Meal { \n    //... \n    private(set) var saltAdded = 0 \n\n    func addSalt() throws { \n        if saltAdded >= 5 { \n            throw MealError.tooMuchSalt \n        } else if case .initial = state, case .buyIngredients = state { \n            throw MealError.wrongStateToAddSalt \n        } else { \n            saltAdded = saltAdded + 1 \n        } \n    } \n} \n```", "```swift\nenum MealError: Error { \n    case canOnlyMoveToAppropriateState \n    case tooMuchSalt \n    case wrongStateToAddSalt \n}\n```", "```swift\nlet dinner = Meal() \ndo { \n    try dinner.buyIngredients() \n    try dinner.prepareIngredients() \n    try dinner.cook() \n    try dinner.plateUp() \n    try dinner.serve() \n    print(\"Dinner is served!\") \n} catch MealError.canOnlyMoveToAppropriateState { \n    print(\"It's not possible to move to this state\") \n} catch MealError.tooMuchSalt { \n    print(\"Too much salt!\") \n} catch MealError.wrongStateToAddSalt { \n    print(\"Can't add salt at this stage\") \n} catch { \n    print(\"Some other error: \\(error)\") \n} \n```", "```swift\nfunc makeMeal(using preparation: (Meal) throws -> ()) rethrows -> Meal { \n    let newMeal = Meal() \n    try preparation(newMeal) \n    return newMeal \n}  \n```", "```swift\ndo { \n    let dinner = try makeMeal { meal in \n        try meal.buyIngredients() \n        try meal.prepareIngredients() \n        try meal.cook() \n        try meal.addSalt() \n        try meal.plateUp() \n        try meal.serve() \n    } \n    if dinner.state == .serve { \n        print(\"Dinner is served!\") \n    } \n} catch MealError.canOnlyMoveToAppropriateState { \n    print(\"It's not possible to move to this state\") \n} catch MealError.tooMuchSalt { \n    print(\"Too much salt!\") \n} catch MealError.wrongStateToAddSalt { \n    print(\"Can't add salt at this stage\") \n} \n```", "```swift\nif <#boolean check and unwrapping#> { \n    <#a block of code#> \n    <#that could be quite long#> \n}\n```", "```swift\n// From https://en.wikipedia.org/wiki/Solar_System \nlet inputData: [[String: Any]] = [ \n    [\"name\": \"Mercury\", \n     \"positionFromSun\": 1, \n     \"fractionOfEarthMass\": 0.055,\n     \"distanceFromSunInAUs\": 0.4, \n     \"hasRings\": false], \n    [\"name\": \"Venus\", \n     \"positionFromSun\": 2, \n     \"fractionOfEarthMass\": 0.815, \n     \"distanceFromSunInAUs\": 0.7, \n     \"hasRings\": false], \n    [\"name\": \"Earth\", \n     \"positionFromSun\": 3, \n     \"fractionOfEarthMass\": 1.0, \n     \"distanceFromSunInAUs\": 1.0, \n     \"hasRings\": false], \n    [\"name\": \"Mars\", \n     \"positionFromSun\": 4, \n     \"fractionOfEarthMass\": 0.107, \n     \"distanceFromSunInAUs\": 1.5, \n     \"hasRings\": false], \n    [\"name\": \"Jupiter\", \n     \"positionFromSun\": 5, \n     \"fractionOfEarthMass\": 318.0,\n     \"distanceFromSunInAUs\": 5.2, \n     \"hasRings\": false], \n    [\"name\": \"Saturn\", \n     \"positionFromSun\": 6, \n     \"fractionOfEarthMass\": 95.0, \n     \"distanceFromSunInAUs\": 9.5, \n     \"hasRings\": true], \n    [\"name\": \"Uranus\", \n     \"positionFromSun\": 7, \n     \"fractionOfEarthMass\": 14.0, \n     \"distanceFromSunInAUs\": 19.2, \n     \"hasRings\": false], \n    [\"name\": \"Neptune\", \n     \"positionFromSun\": 8, \n     \"fractionOfEarthMass\": 17.0, \n     \"distanceFromSunInAUs\": 30.1, \n     \"hasRings\": false] \n] \n```", "```swift\nstruct Planet { \n    let name: String \n    let positionFromSun: Int \n    let fractionOfEarthMass: Double \n    let distanceFromSunInAUs: Double \n    let hasRings: Bool \n}\n```", "```swift\nfunc makePlanet(fromInput input: [String: Any]) -> Planet? { \n\n    guard \n        let name = input[\"name\"] as? String, \n        let positionFromSun = input[\"positionFromSun\"] as? Int, \n        let fractionOfEarthMass = input[\"fractionOfEarthMass\"] as? \n          Double, \n        let distanceFromSunInAUs = input[\"distanceFromSunInAUs\"] as? \n          Double, \n        let hasRings = input[\"hasRings\"] as? Bool \n        else { \n            return nil \n        } \n\n    return Planet(name: name, \n                  positionFromSun: positionFromSun, \n                  fractionOfEarthMass: fractionOfEarthMass, \n                  distanceFromSunInAUs: distanceFromSunInAUs, \n                  hasRings: hasRings)\n}\n```", "```swift\nfunc makePlanets(fromInput input: [[String: Any]]) -> [Planet] { \n\n    var planets = [Planet]() \n    for inputItem in input { \n        guard let planet = makePlanet(fromInput: inputItem) else { \n          continue } \n        planets.append(planet) \n    } \n\n    return planets \n}\n```", "```swift\nfunc makePlanet(fromInput input: [String: Any]) -> Planet? { \n\n    guard  \n        let name = input[\"name\"] as? String,  \n        let positionFromSun = input[\"positionFromSun\"] as? Int,  \n        let fractionOfEarthMass = input[\"fractionOfEarthMass\"] as? \n          Double,  \n        let distanceFromSunInAUs = input[\"distanceFromSunInAUs\"] as? \n          Double,  \n        let hasRings = input[\"hasRings\"] as? Bool  \n        else { \n            return nil \n    } \n     return Planet(name: name,  \n                  positionFromSun: positionFromSun,  \n                  fractionOfEarthMass: fractionOfEarthMass,  \n                  distanceFromSunInAUs: distanceFromSunInAUs,  \n                  hasRings: hasRings) \n} \n```", "```swift\nfunc makePlanets(fromInput input: [[String: Any]]) -> [Planet] { \n    //... \n    for inputItem in input { \n        guard let planet = makePlanet(fromInput: inputItem) else { \n          continue } \n        planets.append(planet) \n    } \n    //... \n} \n```", "```swift\nenum CreationError: Error {\n    case noData\n}\n\nfunc makePlanets(fromInput input: [[String: Any]]) throws -> [Planet] { \n\n    guard input.count > 0 else { throw CreationError.noData } \n    //... \n} \n```", "```swift\nenum MovieReviewClass { \n    case bad \n    case average \n    case good \n    case brilliant \n} \n```", "```swift\nclass MovieReviewClassifier { \n\n    func classify(forStarsOutOf10 stars: Int) -> MovieReviewClass { \n        if stars > 8 { \n            return .brilliant // 9 or 10 \n        } else if stars > 6 { \n            return .good // 7 or 8 \n        } else if stars > 3 { \n            return .average // 4, 5 or 6 \n        } else { \n            return .bad // 1, 2 or 3 \n        } \n    } \n} \n```", "```swift\nlet classifier = MovieReviewClassifier() \nlet review1 = classifier.classify(forStarsOutOf10: 9) \nprint(review1) // brilliant\n```", "```swift\nenum ClassificationState { \n    case initial \n    case classifying \n    case complete \n}\n```", "```swift\nclass MovieReviewClassifier { \n\n    var state: ClassificationState = .initial \n\n    func classify(forStarsOutOf10 stars: Int) -> MovieReviewClass { \n\n        state = .classifying \n\n        defer { \n            state = .complete \n        } \n\n        if stars > 8 { \n            return .brilliant // 9 or 10 \n        } else if stars > 6 { \n            return .good // 7 or 8 \n        } else if stars > 3 { \n            return .average // 4, 5 or 6 \n        } else { \n            return .bad // 1, 2 or 3 \n        } \n    } \n} \n```", "```swift\nlet classifier = MovieReviewClassifier() \nlet review1 = classifier.classify(forStarsOutOf10: 9) \nprint(review1) // brilliant \nprint(classifier.state) // complete \n```", "```swift\nfunc classify(forStarsOutOf10 stars: Int) -> MovieReviewClass { \n\n    //... \n\n    if stars > 8 { \n        return .brilliant // 9 or 10 \n    } else if stars > 6 { \n        return .good // 7 or 8 \n    } else if stars > 3 { \n        return .average // 4, 5 or 6 \n    } else { \n        return .bad // 1, 2 or 3 \n    }\n} \n```", "```swift\nstate = .classifying \n\ndefer { \n    state = .complete \n}\n```", "```swift\nif stars > 8 { \n    state = .complete \n    return .brilliant // 9 or 10 \n} else if stars > 6 { \n    state = .complete \n    return .good // 7 or 8 \n} else if stars > 3 { \n    state = .complete \n    return .average // 4, 5 or 6 \n} else { \n    state = .complete \n    return .bad // 1, 2 or 3 \n} \n```", "```swift\ndefer { \n    state = .complete \n} \n```", "```swift\nenum ClassificationState { \n    case initial \n    case classifying \n    case complete \n    case completeAgain \n} \n```", "```swift\nclass MovieReviewClassifier { \n\n    var state: ClassificationState = .initial \n    var numberOfClassifications = 0 \n\n    func classify(forStarsOutOf10 stars: Int) -> MovieReviewClass { \n\n        state = .classifying \n\n        defer { \n            numberOfClassifications += 1 \n        } \n        defer { \n            if numberOfClassifications > 0 { \n                state = .completeAgain \n            } else { \n                state = .complete \n            } \n        } \n\n        if stars > 8 { \n            return .brilliant // 9 or 10 \n        } else if stars > 6 { \n            return .good // 7 or 8 \n        } else if stars > 3 { \n            return .average // 4, 5 or 6 \n        } else { \n            return .bad // 1, 2 or 3 \n        } \n    } \n} \n```", "```swift\nlet classifier = MovieReviewClassifier() \nlet review1 = classifier.classify(forStarsOutOf10: 9) \nprint(review1) // brilliant \nprint(classifier.state) // complete \nprint(classifier.numberOfClassifications) // 1 \n\nlet review2 = classifier.classify(forStarsOutOf10: 2) \nprint(review2) // bad \nprint(classifier.state) // completeAgain \nprint(classifier.numberOfClassifications) // 2 \n```", "```swift\ndefer { \n    numberOfClassifications += 1 \n} \ndefer { \n    if numberOfClassifications > 0 { \n        state = .completeAgain \n    } else { \n        state = .complete \n    } \n} \n```", "```swift\nenum ClassificationState { \n    case initial \n    case classifying \n    case complete \n} \n\nenum MovieReviewClass { \n    case bad \n    case average \n    case good \n    case brilliant \n}\n```", "```swift\nclass MovieReviewClassifier { \n\n    var state: ClassificationState = .initial \n\n    func classify(forStarsOutOf10 stars: Int) -> MovieReviewClass { \n\n        precondition(state == .initial, \"Classifier state must be \n          initial\") \n\n        state = .classifying \n\n        defer { \n            state = .complete \n        } \n\n        if stars > 8 && stars <= 10 { \n            return .brilliant // 9 or 10 \n        } else if stars > 6 { \n            return .good // 7 or 8 \n        } else if stars > 3 { \n            return .average // 4, 5 or 6 \n        } else if stars > 0 { \n            return .bad // 1, 2 or 3 \n        } else { \n            fatalError(\"Star rating must be between 1 and 10\") \n        } \n    } \n} \n\nlet classifier = MovieReviewClassifier() \nlet review1 = classifier.classify(forStarsOutOf10: 9) \nprint(review1) // brilliant \nprint(classifier.state) // complete \n```", "```swift\nfunc classify(forStarsOutOf10 stars: Int) -> MovieReviewClass { \n\n    precondition(state == .initial, \"Classifier state must be initial\") \n    //... \n} \n```", "```swift\nfunc classify(forStarsOutOf10 stars: Int) -> MovieReviewClass { \n    //... \n    if stars > 8 && stars <= 10 { \n        return .brilliant // 9 or 10 \n    } else if stars > 6 { \n        return .good // 7 or 8 \n    } else if stars > 3 { \n        return .average // 4, 5 or 6 \n    } else if stars > 0 { \n        return .bad // 1, 2 or 3 \n    } else { \n        fatalError(\"Star rating must be between 1 and 10\") \n    } \n}\n```"]