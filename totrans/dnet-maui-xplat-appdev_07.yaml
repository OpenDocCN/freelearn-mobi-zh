- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software Design with Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having introduced navigation and the Shell in .NET MAUI, we’ve laid the groundwork
    for building a comprehensive application. However, we are currently utilizing
    a mock data service, which we intend to modify in this chapter. Before diving
    into this, let’s first review the best practices in software design, starting
    with an overview of design principles. Later, we will explore how to leverage
    dependency injection in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Software design principles and patterns typically form the backbone of best
    practices in software design. These principles offer rules and guidelines that
    software designers adhere to in crafting an efficient and clean design structure.
    They play a key role in shaping the software design process as they dictate the
    most effective practices. Design patterns are effectively best practices that
    experienced developers in object-oriented software employ. They function as templates
    designed to address repetitive design problems in specific contexts, offering
    reusable solutions that can be applied to prevalent issues in software design.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency Injection** (**DI**) is a software design pattern and technique
    that ensures a class is not dependent on its dependencies. It achieves this through
    decoupling an object’s utilization from its creation. The goal here is to create
    a system that is more adaptable, modular, and simpler to debug and maintain. DI
    is embodied in the **Dependency Inversion Principle (DIP)**, one of the five SOLID
    principles in object-oriented programming and design.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the mock data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DI is a method for implementing the design principle of dependency inversion,
    also known as the DIP. The DIP is one of the SOLID design principles, and we will
    learn how to incorporate SOLID principles into our design process. An overview
    of the SOLID design principles will be provided at the beginning of this chapter,
    before delving into the discussion on DI.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following branch on GitHub:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter06](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/8067aa8a0ea9a275b33e64adaae7b09f7414851b).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the below command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design principles are high-level guidelines that offer valuable advice on design
    considerations. These principles can provide essential guidance to help you make
    better design decisions. Some general design principles are applicable not only
    to software design but also to other design disciplines.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review some general design principles before we explore the commonly used
    design principles (SOLID) in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring types of design principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Design principles encompass a vast subject area. Thus, rather than delving into
    intricate details, I will provide insights from my experiences in implementing
    design principles during development, offering a concise overview of the principles
    discussed in this book. We will begin with high-level principles such as **DRY**,
    **KISS**, and **YAGNI**, and then progress to those more commonly used in software
    development. In the realm of **object-oriented programming** (**OOP**), the most
    widely used design principles are the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Repeat Yourself (DRY)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As people often say, don’t reinvent the wheel; we should strive to reuse existing
    components instead of redeveloping what has already been created.
  prefs: []
  type: TYPE_NORMAL
- en: Keep It Simple, Stupid (KISS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should choose a simple and straightforward approach rather than involve unnecessary
    complexity in a design.
  prefs: []
  type: TYPE_NORMAL
- en: You Aren’t Gonna Need It (YAGNI)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should implement functionality when it is required. In software development,
    there is a tendency to futureproof a design. This may create something that is
    actually not needed and increase the complexity of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID design principles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SOLID design principles are widely employed in software development and serve
    as high-level guidelines for numerous design patterns. SOLID is an acronym that
    encapsulates the following five principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle (SRP)**: A class should have a single responsibility.
    Adhering to this design principle, a developer should have only one reason to
    modify a class. By considering this principle during implementation, the resulting
    code becomes easier to comprehend and more effectively adapts to evolving requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open/Closed Principle (OCP)**: Classes should be open for extension but closed
    for modification. The central concept behind this principle is to prevent disruptions
    to existing code when introducing new features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle (LSP)**: If the object of the parent type can
    be used in a context, an object with a child type should also be able to function
    in the same manner without causing any errors or disruptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle (ISP)**: A design should not implement an
    interface that it doesn’t use, and a class should not be forced to depend on methods
    it doesn’t intend to implement. We should design concise and simple interfaces
    rather than large and complex ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle (DIP)**: This principle emphasizes the decoupling
    of software modules. High-level modules should not depend on low-level modules
    directly. Both should depend on abstractions. Abstractions should not depend on
    details. Details should depend on abstractions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design principles are guidelines to help us to make better design decisions.
    However, the responsibility ultimately lies with us to determine the most suitable
    course of action during the actual implementation, rather than solely relying
    on these principles.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will focus on the usage of DI in this chapter, please refer to the
    *Further reading* section to find more information about design principles (SOLID)
    and design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Using design principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having discussed various design principles, allow me to share insights and lessons
    learned from implementing them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app’s model, I utilized the **KeePassLib** from Dominik Reichl. While
    porting it to .NET Standard, I modified the inheritance hierarchy, as depicted
    in *Figure 6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Class diagram of Item, PwEntry, and PwGroup](img/B21554_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Class diagram of Item, PwEntry, and PwGroup'
  prefs: []
  type: TYPE_NORMAL
- en: In the process of porting KeePassLib to .NET Standard, I developed an abstract
    parent class, `Item`, for the group (`PwGroup`) and entry (`PwEntry`). This modification
    appears to violate OCP within the SOLID principles. The rationale behind this
    approach is rooted in a lesson I learned from the past implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier versions, prior to 1.2.3, I had not implemented **KPCLib** in the
    manner described. Instead, I directly used `PwGroup` and `PwEntry`, which required
    handling groups and entries separately. This resulted in increased complexity
    in `ItemsPage` and `ItemsViewModel`. This approach’s most significant consequence
    was the inability to distinctly separate the model and the view model. Consequently,
    I had to manage numerous details using **KeePassLib** directly within the view
    model. However, upon introducing the `Item` abstract parent class, I successfully
    concealed most of the intricate implementation within services (`IDataStore` and
    `IUserService`) and `PassXYZLib`. This led to the elimination of any code reliant
    on KeePassLib within the view and view model.
  prefs: []
  type: TYPE_NORMAL
- en: The inspiration behind this change came from the KISS principle rather than
    merely adhering to OCP. When considering other SOLID principles, such as LSP and
    SRP, this modification significantly improved the overall architecture. It’s essential
    to recognize that, in practical work, conflicts can arise among various design
    principles. It is ultimately our responsibility to make informed decisions instead
    of adhering dogmatically to design principles. The most effective design decisions
    typically arise from the insights gained from prior failures.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our main focus, we will now discuss enhancing the design by employing
    one of the SOLID principles—dependency inversion. As part of the SOLID design
    principles, dependency inversion emphasizes the separation of software modules,
    and it also provides guidelines on how to achieve this. The fundamental concept
    behind it is the preference of relying on abstractions whenever possible. In practice,
    DI is a technique routinely used to implement the idea of dependency inversion.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is a technique that can be utilized in .NET MAUI. Although not a novel concept,
    it has been extensively employed in backend frameworks like ASP.NET Core and the
    Java Spring Framework. DI facilitates dependency inversion (DIP) by decoupling
    an object’s usage from its creation, eliminating the need for direct reliance
    on the object. In our app, once we have separated the `IDataStore` interface implementation,
    we can commence with a mock implementation and subsequently replace it with the
    actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET MAUI, the `Microsoft.Extensions.DependencyInjection` service, which
    we will refer to as MS.DI throughout this chapter, is readily available for us
    to utilize as a built-in feature.
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of .NET, numerous DI containers are available besides MS.DI. Some
    of these alternatives, such as the Autofac DI container and the Simple Injector
    DI container, offer enhanced power and flexibility compared to MS.DI. At this
    point, one may wonder why we are choosing MS.DI over the other potent and adaptable
    DI containers. It is essential to revisit the KISS and YAGNI principles in this
    context. We should not opt for a more powerful solution with the assumption that
    we may utilize certain features in the future. Instead, the most straightforward
    and efficient approach is to leverage what we already possess without any additional
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: With MS.DI, we can avoid introducing extra dependencies. Regardless of our intention
    to use it, it is already incorporated in the .NET MAUI configuration. By simply
    adding a few lines of code, we can enhance our design. Alternative DI containers
    may offer more sophisticated features, but we would need to include additional
    dependencies and perform the necessary configuration in our code before utilizing
    them. If you are working on a complex system design, it’s recommended to evaluate
    the available DI containers and select the most suitable one for your system.
    In our scenario, **PassXYZ.Vault** is a relatively straightforward app, and we
    will not directly benefit from the advanced DI features offered by Autofac or
    Simple Injector. The functionalities provided by MS.DI are adequate for our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, the module we aim to decouple is the model layer, which derives
    from a third-party library provided by KeePass. As depicted in the package diagram
    in *Figure 6.2*, our system comprises three distinct assemblies: **KPCLib**, **PassXYZLib**,
    and **PassXYZ.Vault**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a computer server  Description automatically generated](img/B21554_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Package diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The **KPCLib** package encompasses two namespaces, **KeePassLib** and **KPCLib**.
    **PassXYZLib** serves as an extension package to augment the **KPCLib** package’s
    functionality using .NET MAUI-specific implementation. **PassXYZ.Vault**, our
    app, relies directly on the **PassXYZLib** package and indirectly on the **KPCLib**
    package. In accordance with the DI principle, we aim to establish dependencies
    on abstractions rather than concrete implementations. To achieve this, we have
    designed two interfaces, `IDataStore` and `IUserService`, which enable us to decouple
    from the actual implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual implementations that require access to KPCLib and PassXYZLib are
    encapsulated in the classes that implement these two interfaces: `IDataStore`
    and `IUserService`. The remainder of the code needed to access the functionalities
    in **KPCLib** and **PassXYZLib** can utilize these two interfaces. The key point
    is that we always have the flexibility to replace the implementations of `IDataStore`
    and `IUserService` if necessary. The remaining code will not be affected by these
    changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to utilize MS.DI as a DI service, two primary steps are involved:
    registration and resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we must register our interfaces (such as `IDataStore`) and their
    corresponding implementations (such as `MockDataStore`) during the program’s startup.
    Following that, we can utilize these registered interfaces throughout our program
    without manually creating them. We can then resolve these registered dependencies
    using the DI container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ServiceCollection` class serves as the means for registration, while the
    `ServiceProvider` class facilitates resolution, as depicted in *Figure 6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Usage of MS.DI](img/B21554_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Usage of MS.DI'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.3* presents a simplified class diagram of `ServiceCollection` and
    `ServiceProvider` at the top. `ServiceCollection` serves as the default implementation
    of the `IServiceCollection` interface, while `ServiceProvider` acts as the default
    implementation of the `IServiceProvider` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: These interfaces, `IServiceCollection` and `IServiceProvider`, allow us to register
    and resolve dependencies. At the bottom of *Figure 6.3*, there’s a sequence diagram
    illustrating how to use both interfaces to achieve this. For a clearer understanding,
    we’ll use the `IDataStore` service as an example to explain the utilization of
    `IServiceCollection` and `IServiceProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize DI for implementing the `IDataStore` service, we can follow the
    steps outlined in the subsequent code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**(1)** To begin, we must first create an instance of the `ServiceCollection`
    class that implements the `IServiceCollection` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** The `IServiceCollection` interface does not inherently specify any
    methods. Instead, a collection of extension methods is defined in the MS.DI namespace.
    Among these, the `AddSingleton` extension method can be utilized to register the
    concrete `MockDataStore` class that implements the `IDataStore` interface. The
    method `AddSingleton` is explained in the following section. This method employs
    a generic type to specify both the interface and its implementation. Additionally,
    there are several overloaded variations of the `AddSingleton` extension method
    at your disposal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** In order to access objects, we can obtain an instance of `ServiceProvider`
    by invoking the `BuildServiceProvider` extension method associated with `IServiceCollection`.
    The `ServiceProvider` class complies with the `IServiceProvider` interface. Notably,
    the `IServiceProvider` interface is located within the `System` namespace and
    exclusively defines the `GetService` method. Additional methods are designated
    as extension methods and can be found in the `Microsoft.Extensions.DependencyInjection`
    namespace, as illustrated in *Figure 6.3*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** Once we have an instance of `ServiceProvider`, we can resolve the `IDataStore`
    interface using the `GetRequiredService` extension method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage the scope of a service, we can resolve it within the scope as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss the scope in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though MS.DI is a lightweight DI service, it offers a sufficient range of features
    for .NET MAUI applications, as outlined below:'
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime management of instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor, method, and property injections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming sections, we will delve deeper into these features.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using DI, you should consider how long instances of a registered service
    should be reused or retained before they are disposed of or new instances are
    created. Lifetime management is crucial in defining the scope within which a service
    instance is generated and shared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few aspects to consider for lifecycle management:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource management**: Resources, such as database connections utilized by
    a service, should not be left open indefinitely. For example, if a singleton service
    keeps a database connection open, it holds that resource for the application’s
    lifespan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: It might not always be the most efficient approach to create
    a new instance of a service each time it’s needed, particularly if constructing
    the service is resource-intensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: If your service requires isolation (for instance, if it maintains
    some state), it’s essential to configure its lifecycle in accordance with the
    scope that satisfies such isolation requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Threading issues**: Singleton services need to be thread-safe as they’re
    shared among different requests, usually processed in parallel on separate threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MS.DI, we can manage the lifespan of these instances by configuring the
    `ServiceCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are commonly three types of lifetimes in dependency injection, and we
    can configure them using extension methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singleton**: A single instance of the service is created when requested for
    the first time and then reused for all subsequent requests throughout the application’s
    lifetime. All callers receive the same instance, meaning a singleton service behaves
    like a shared global resource. Singleton services can retain state and are useful
    for providing centralized management of resources, such as logging, caching, or
    configuration. The extension method `AddSingleton` can be used to create a single
    instance throughout the life of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped**: A scoped service creates a new instance per scope, typically per
    request in a web application. Each scope has its instance of the service, which
    is shared among all components within that specific scope. Scoped services are
    useful for maintaining state specific to a single request or user interaction,
    such as user information, request details, or database connections in a per-request
    context. The extension method `AddScoped` can be used to create one instance and
    reuses the same instance within the defined scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transient**: Transient services create a new instance each time the service
    is requested, ensuring that each caller gets a unique instance without sharing
    state or resources. Transient services are useful for services without an internal
    state or a need for resource management. They are often lightweight and don’t
    require sharing across different components. The extension method `AddTransient`
    can be used to create an instance for each call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code, in the lines marked by **(1)**, we registered `IUserService`
    as a `Singleton` object, `IDataStore` as a `Scoped` object, and `ItemsViewModel`
    as a `Transient` object.
  prefs: []
  type: TYPE_NORMAL
- en: Following the registration, in the line marked by **(2)**, we instantiated a
    `ServiceProvider` and stored it in a `rootContainer` variable. In the lines marked
    by **(3)**, utilizing the `rootContainer`, we generated two scopes, named **scope1**
    and **scope2**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lifetime management of these created objects can be examined in *Figure
    6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software application  Description automatically generated](img/B21554_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Lifetime management in MS.DI'
  prefs: []
  type: TYPE_NORMAL
- en: The variable`userService` is created as a `Singleton` object, ensuring that
    only one instance exists, and its lifetime is equal to that of the application.
    The two scopes—namely, **scope1** and **scope2**—possess distinct lifetimes determined
    by our design. The `Scoped` objects—**dataStore1** and **dataStore2**—have the
    same lifetime as the scope to which they belong. Meanwhile, the instances of `ItemViewModel`
    are `Transient` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the three methods—`AddSingleton`, `AddScoped`, and `AddTransient`—numerous
    overloaded variations have been defined to cater to an array of requirements pertaining
    to `ServiceCollection` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we have two versions of the `IDataStore` interface implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataStore`: This version represents the actual implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockDataStore`: This version is employed for testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With MS.DI, we have the ability to utilize `MockDataStore` in the Debug build
    and employ `DataStore` in the Release build. This configuration can be executed
    as demonstrated in the subsequent code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Configuring DI in .NET MAUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MS.DI is incorporated into the .NET release, making it accessible for all types
    of applications in .NET 5 or subsequent versions. As we discussed in the previous
    section, we can implement DI using `ServiceCollection` and `ServiceProvider`.
    However, there is a more straightforward approach to utilizing MS.DI in .NET MAUI.
    With DI integrated as part of the .NET Generic Host configuration, there is no
    need for us to create an instance of `ServiceCollection` manually. This allows
    us to employ the preconfigured DI service directly, without any additional effort.
  prefs: []
  type: TYPE_NORMAL
- en: To gain a deeper understanding of the preconfigured DI service in .NET MAUI,
    let’s revisit the .NET MAUI application startup process as depicted in *Figure
    6.5*. This figure encompasses both a class diagram and a sequence diagram, illustrating
    the classes involved in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please be aware that the number in *Figure 6.5* represents the type of object
    (**(1)** = MauiProgram, **(2)** = MauiApp, and **(3)** = MauiAppBuilder):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a program  Description automatically generated](img/B21554_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: .NET MAUI DI configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 6.5*, at the top, we observe that the initiation of the .NET MAUI
    application involves four different classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform entry point**: The initiation of the .NET MAUI application occurs
    in platform-specific code. For the .NET MAUI project, this can be found in the
    **Platforms** folder. Distinct classes have been defined for each platform, as
    illustrated in *Table 6.1*. In *Figure 6.5*, we use the `MauiApplication` Android
    version as a representative example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Platform** | **Entry point class** | **Implement Interface** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Android | `MauiApplication` | `IPlatformApplication` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| iOS/macOS | `MauiUIApplicationDelegate` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Windows | `MauiWinUIApplication` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Table 6.1: Entry points in different platforms'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All entry-point classes implement the `IPlatformApplication` interface, as
    we can see in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `IPlatformApplication` interface defines a property called `Services`, which
    is of the type `IServiceProvider`. Once the application is initialized, this property
    can be utilized directly to resolve DI objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All platform entry-point classes also implement an override method, `CreateMauiApp`,
    which calls the static method `CreateMauiApp` defined in the `MauiProgram` class.
    Please refer to the following code, *Table 6.1*, and *Figure 6.5*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MauiProgram` **(1)**: In the subsequent `MauiProgram` implementation code,
    it becomes apparent that every .NET MAUI application must define a static `MauiProgram`
    class and include a `CreateMauiApp` method. The `CreateMauiApp` method gets called
    by an override function, which is present in all platform entry points. This override
    function ultimately returns a `MauiApp` instance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MauiApp` **(2)**: Inside `CreateMauiApp`, it creates a `MauiAppBuilder` instance
    by calling the function `MauiApp.CreateBuilder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MauiAppBuilder` **(3)**: `MauiAppBuilder` incorporates an attribute called
    `Services`, which is of the `IServiceCollection` interface type. This attribute
    allows us to configure DI for the .NET MAUI application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the above analysis of the .NET MAUI app startup process, it is apparent
    that both `IServiceCollection` and `IServiceProvider` are initialized during this
    procedure. As a result, we can conveniently utilize them without the need for
    additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MauiProgram` implementation can be observed in the code provided below.
    Here, we have registered interfaces—`IDataStore` and `IUserService`—as well as
    multiple classes including `LoginService`, view models, and pages. It is important
    to note that all of these components are singleton objects, except for `ItemsViewModel`
    and `ItemsPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After configuring DI for interfaces and classes, we can utilize them in our
    implementation. The `IServiceProvider` interface enables us to resolve objects
    effectively. When implementing DI, there are three primary methods for injecting
    dependencies: constructor injection, method injection, and property injection.
    In the subsequent sections, we will explore how to apply these methods to our
    programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With constructor injection, the necessary dependencies for a class are supplied
    as arguments to the constructor, allowing us to resolve dependencies using the
    constructor itself. In the code-behind of `ItemsPage`, `ItemsPage` relies on its
    view model, `ItemsViewModel`. We can establish the constructor of `ItemsPage`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `ItemsPage` constructor, we inject the dependency through the argument
    `viewModel`. In this instance, MS.DI resolves `viewModel` according to the configuration
    defined in `MauiProgram`.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection is the most common and most advised form of DI because
    the object always gets created with the required dependencies. The biggest advantage
    is that it makes dependencies explicit, and the object never exists in an incomplete
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Often, it may not be feasible to inject dependencies through the constructor,
    such as when a class comprises optional dependencies or when there’s a need to
    alter dependencies dynamically. In these circumstances, utilizing method injection
    or property injection would be the recommended approach.
  prefs: []
  type: TYPE_NORMAL
- en: Method injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using constructor injection to provide required dependencies when
    the object is instantiated, method injection passes the dependencies directly
    to the methods that use them. Method injection is a technique in DI where dependencies
    are provided to an object through method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, we can set up dependencies through a method instead of a constructor,
    as illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `IDataStore` is set using the method `SetDataStore` instead
    of being injected through the constructor. However, it has a disadvantage where
    the dependent object might forget to set the dependency. As a result, the object
    can exist in an incomplete state.
  prefs: []
  type: TYPE_NORMAL
- en: In the code example provided, using method injection enables us to utilize both
    the actual and mock DataStore implementations within the same code. Method injection
    also allows for more fine-grained control over when dependencies are created,
    passed, and disposed of compared to constructor injection. However, it can also
    make the method’s call more complex since the caller is responsible for providing
    the dependencies as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In general, constructor injection is often preferred for simplicity and better
    encapsulation, but method injection can be valuable for specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Property injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In property injection, dependencies are set through properties. Generally, method
    and property injection can be used to replace each other. It is similar to method
    injection—in numerous situations, we might be unable to utilize constructor injection,
    so we have to use method or property injection. The issue with method or property
    injection is that the dependent object might forget to set the dependency, so
    the object can exist in an incomplete state.
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be partially mitigated through the use of attributes or annotations
    in object-oriented languages, an approach we will explore later.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET MAUI, we can resolve the dependencies through `IServiceProvider`. Within
    a .NET MAUI application, the hosting environment generates an `IServiceProvider`
    interface for us, as demonstrated in *Figure 6.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the `IServiceProvider` interface, we can employ the `IPlatformApplication`
    interface defined in the platform-specific entry points, as depicted in *Listing
    6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6.1: `ServiceHelper.cs` ([https://epa.ms/ServiceHelper6-1](https://epa.ms/ServiceHelper6-1))'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** In the `ServiceHelper` class, we define a static variable called `Current`,
    which maintains a reference to the `IServiceProvider`. We can obtain the `IServiceProvider`
    through the `Services` property of the `IPlatformApplication` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** A `GetService` static method is defined, which, in turn, invokes the
    `GetService` method of the `IServiceProvider` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ServiceHelper**'
  prefs: []
  type: TYPE_NORMAL
- en: For the **ServiceHelper** implementation, I referred to the **MauiApp-DI** GitHub
    project. Thanks to James Montemagno for the sample code on GitHub!
  prefs: []
  type: TYPE_NORMAL
- en: ([https://github.com/jamesmontemagno/MauiApp-DI](https://github.com/jamesmontemagno/MauiApp-DI))
  prefs: []
  type: TYPE_NORMAL
- en: 'By utilizing the `ServiceHelper` class, we can obtain an instance of `IDataStore`,
    as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You might notice that the property injection code provided earlier appears less
    elegant when compared to constructor injection. We have to set the dependencies
    manually. In the worst case, the object can exist in an incomplete state.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of now, I have not discovered a more efficient method for implementing this
    in .NET MAUI. Nonetheless, in the subsequent sections of this book, when we introduce
    the Blazor Hybrid app, we will be able to utilize C# attributes to address property
    injection more effectively. To resolve the `IDataStore` interface in Blazor, a
    more straightforward approach can be employed, which is demonstrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `Inject` C# attribute to implicitly resolve dependencies without
    explicitly invoking the `GetService` method from the `ServiceHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: By employing DI, we can seamlessly substitute the mock implementation of the
    `IDataStore` interface with the actual one. This implementation can facilitate
    the CRUD operations of the password database. In the upcoming section, we will
    examine this new class in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the mock data store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As explored in previous sections, we can register the implementation of data
    store services in `MauiProgram.cs` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `DataStore` is the actual implementation of the `IDataStore` service,
    which we will fully implement in the remainder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The password database is a local database in the KeePass 2.x format. Within
    this database, password information is organized into groups and entries. The
    `KeePassLib` namespace contains a `PwDatabase` class, which is designed to manage
    database operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To comprehend the relationship between `PwDatabase`, `PwGroup`, and `PwEntry`,
    we can refer to the class diagram in *Figure 6.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Class diagram of KeePass database](img/B21554_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Class diagram of KeePass database'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **PwDatabase**, the **RootGroup** property of type **PwGroup** is defined,
    which contains all groups and entries stored in the database. The data structure
    of the KeePass database can be navigated from **RootGroup** to a specific entry.
    **PwEntry** defines a set of standard fields, as illustrated in *Figure 6.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a phone  Description automatically generated](img/B21554_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Group, entry, and field'
  prefs: []
  type: TYPE_NORMAL
- en: If we possess a list of entries containing only standard fields, it will resemble
    a table. In *Figure 6.7*, the current group consists of five entries (**GitHub**,
    **Google**, **Facebook**, **Instagram**, and **Chase Bank**) along with a sub-group
    (**Cloud**). On the left, a screenshot of the `ItemsPage` displays the items within
    the current group. If the **Google** item is selected, it will appear as an entry
    in the screenshot on the right side. Users have the option to add extra fields
    to the entry, making the KeePass database dissimilar to a relational database;
    it is more akin to a key-value database. Each field consists of a key-value pair,
    such as a URL field.
  prefs: []
  type: TYPE_NORMAL
- en: In order to utilize `PwDatabase` in our application, we have defined a derived
    class called `PxDatabase`. This class introduces additional properties and methods,
    such as `CurrentGroup`, `DeleteGroup`, `DeleteEntry`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: To access a database, one can open the database file and perform CRUD operations
    on it. However, when building a cross-platform app, handling the database file
    directly may not be convenient for the end users. In **PassXYZ.Vault**, the concept
    of users is employed rather than using a data file. Within **PassXYZLib**, a `User`
    class has been defined to encapsulate the underlying file operations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to access the database, we have defined database initialization and
    CRUD operations within the `IDataStore` and `IUserService` interfaces. The `DataStore`
    and `UserService` concrete classes serve to implement these two interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The database initialization is incorporated within the login process, so the
    subsequent login method is defined in the `IUserService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` class serves as an implementation of the `IUserService` interface.
    Within the `UserService` class, the `LoginAsync` method is defined as an asynchronous
    method, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In `LoginAsync`, the `IDataStore` method `ConnectAsync` is invoked to perform
    the actual task. Let’s examine the `ConnectAsync` implementation below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `ConnectAsync` function, **(1)**, a distinct task is employed to manage
    the opening process of the database. The `Open` method of `PxDatabase` is invoked,
    **(2)**, and an instance of the `User` class is provided as an argument to the
    `Open` method.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully establishing a connection and initializing the database,
    we need to implement the methods required for database operations. These can include
    tasks such as data retrieval, data insertion, data update, and data deletion,
    among others. These represent the fundamental operations to interact, manage,
    and maintain data within the database system.
  prefs: []
  type: TYPE_NORMAL
- en: Performing CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user navigates to another group, `SetCurrentGroup` is invoked with
    an argument to set the new location in the navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6.2: `IDataStore.cs` ([https://epa.ms/IDataStore6-2](https://epa.ms/IDataStore6-2))'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The initial operation in CRUD involves creating or adding an item. This item
    could be an entry or a group that is added to the current group. The user interface
    for performing this add operation can be found as a toolbar item in `ItemsPage`,
    as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see a toolbar item icon is shown in the top-right corner of `ItemsPage`
    in *Figure 6.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Adding an item](img/B21554_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Adding an item'
  prefs: []
  type: TYPE_NORMAL
- en: When the **+** button is clicked, the `AddItemCommand` command in the `ItemsViewModel`
    is invoked through data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddItemCommand` command invokes the following `AddItem` method in the
    view model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6.3: `ItemsViewModel.cs` ([https://epa.ms/ItemsViewModel6-3](https://epa.ms/ItemsViewModel6-3))'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** In the `AddItem` function, an `ActionSheet` is displayed, allowing
    the user to select an item type. The item type can either be a group or an entry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** Upon obtaining the item type, we can construct a dictionary that includes
    the item type and the query parameter’s name. Then, we store this dictionary object
    in a variable called `itemType`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** This `itemType` variable can be passed to `NewItemPage` as a query
    parameter. In *Chapter 5*, *Navigation Using .NET MAUI Shell and NavigationPage*,
    we learned how to pass a string value as a query parameter to a page in Shell
    navigation. Here, we can pass an object as a query parameter to a page after we
    wrap it in a dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new item, the user interface is defined in `NewItemPage`, while the
    logic is managed within the `NewItemViewModel`. Let’s examine the `NewItemViewModel`
    implementation as shown in *Listing 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6.4: `NewItemViewModel.cs` ([https://epa.ms/NewItemViewModel6-4](https://epa.ms/NewItemViewModel6-4))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of the `NewItemPage` is quite straightforward, featuring two controls:
    **Entry** and **Editor**, which serve to edit the name and notes of an item, respectively.
    The **Entry** control is employed for entering or editing a single line of text,
    whereas the **Editor** control is utilized for modifying multiple lines of text.
    Within the `NewItemViewModel` view model, we can observe the process of adding
    a new item as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The query parameter is defined using the `QueryPropertyAttribute`.
    **(2)** The `Type` property, declared as `ItemSubType`, is utilized to obtain
    the query parameter. The acquired item type is subsequently stored in the `_type`
    backing variable. Within the `NewItemPage`, two toolbar items are established,
    and their actions are associated with the **Save** and **Cancel** methods found
    in the view model.'
  prefs: []
  type: TYPE_NORMAL
- en: Upon entering a name and notes in the user interface and clicking the **Save**
    button, **(3)**, a new item instance is created using the `CreateNewItem` factory
    method, which is defined in the `IDataStore` interface. **(4)** Once the new item
    instance is populated with the user input, it can be added to the database by
    calling the `AddItemAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have now implemented the addition operation. In the following section, let’s
    proceed to implement the remaining data operations.
  prefs: []
  type: TYPE_NORMAL
- en: Editing or deleting an item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In CRUD operations, a create operation does not require an existing item. However,
    to perform update and delete operations, an instance of the existing item is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In a read operation, when an item is a group, we implement it by transmitting
    an `ItemId` query parameter to the `ItemsPage` and, subsequently, identifying
    the group within the setter of `ItemId` in the `ItemsViewModel` view model. Conversely,
    if the item is an entry, we transmit an `ItemId` query parameter to `ItemDetailPage`
    and locate the entry within the setter of `ItemId` in the `ItemDetailViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For updating, editing, and deleting operations, we can utilize context actions.
    These actions allow us to manipulate items within a `ListView` effectively. It
    is important to note that context actions have a distinct appearance on various
    platforms, such as iOS, Android, and Windows, as depicted in *Figure 6.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Context actions](img/B21554_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Context actions'
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS platform, you can perform an action on an item by swiping it to the
    left. In an Android system, you can access the contextual actions menu by long-pressing
    an item, which will then appear in the top-right corner of the screen. On Windows,
    you might be familiar with right-clicking your mouse to display the contextual
    actions menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we introduce a context actions menu within the `ItemsPage`.
    We configure the context actions in the `ItemViewCell` inside `ItemsPage`, as
    demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ItemViewCell` is a custom view that inherits from `KeyValueView`, which
    was introduced in *Chapter 4*, *Exploring MVVM and Data Binding*. Let’s examine
    the `ItemViewCell` code in *Listing 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6.5: `ItemViewCell.cs` ([https://epa.ms/ItemViewCell6-5](https://epa.ms/ItemViewCell6-5))'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ItemViewCell`, we define two menu items for editing and deleting context
    actions. We assign two event handlers (**(1)** `OnEditAction` and **(2)** `OnDeleteAction`)
    to their corresponding context actions. Within the event handlers, we invoke the
    view model methods, `Update` and `Delete`, to execute the required operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the source code for the `Update` and `Delete` functions in the
    `ItemsViewModel`, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the `ItemsViewModel`, to edit or update an item, **(1)**, we utilize a content
    page called `FieldEditPage` to carry out the editing process. Upon invoking the
    constructor of `FieldEditPage`, an anonymous function is passed as a parameter.
    This function is invoked when the user finishes editing within `FieldEditPage`.
    Within this function, **(2)**, the `UpdateItemAsync` method of the `IDataStore`
    interface is called to update the item.
  prefs: []
  type: TYPE_NORMAL
- en: The delete operation is fairly straightforward. We can simply invoke the `DeleteItemAsync`
    method, **(3)**, from the `IDataStore` interface to eliminate the item.
  prefs: []
  type: TYPE_NORMAL
- en: Once the CRUD operations are implemented, our application will possess the essential
    features required for a password manager app. We can establish a new database
    by registering a new user. Upon creating a new database, we can then log in to
    access our data. Additionally, after generating entries and groups, we have the
    ability to modify or remove them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began by introducing design principles. Following this,
    we delved into the SOLID design principles, and I shared insights gleaned from
    the development of our app. Among the most crucial SOLID principles is the **DIP**.
    **DI** is a technique that applies the DIP in practical implementation. In our
    app, we utilize the built-in DI service of .NET MAUI to decouple dependencies,
    enabling us to separate the implementation of the service from the interface.
  prefs: []
  type: TYPE_NORMAL
- en: We accumulated extensive knowledge about .NET MAUI and successfully completed
    our app implementation by replacing `MockDataStore` with the actual implementation.
    We established CRUD operations on top of this new `IDataStore` service, resulting
    in a fully functional password manager app.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have incorporated essential features in our app, users often expect
    additional desirable features in a password manager application, such as fingerprint
    scanning and one-time passwords. Some of these features are platform-specific,
    which requires knowledge of platform integration. In the next chapter, we will
    delve into various platform integration topics to further improve our app.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Beginning SOLID Principles and Design Patterns for ASP.NET Developers*, by
    Bipin Joshi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autofac** is an **inversion of control** (**IoC**) container for .NET Core,
    ASP.NET Core, .NET 4.5.1+, and more: [https://autofac.org/](https://autofac.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Injector** is a DI container that can support .NET 4.5 and .NET Standard:
    [https://simpleinjector.org/](https://simpleinjector.org/%20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  prefs: []
  type: TYPE_IMG
