- en: Chapter 2. Automatic Reference Counting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good ideas live a long life and bad ones die fast. In Objective-C, reference
    counting's long life was seen as a very good idea. The next step of evolution
    in this is that it became automatic, so we call it **Automatic Reference Counting**
    (**ARC**), which was introduced by Apple Inc. in 2011 for application development
    on its desktop and mobile OS, Mac OS X Lion, and iOS 5\. It changed the name of
    the initial referencing counting to **Manual Reference Counting**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: ARC and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and disadvantages of ARC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project settings for ARC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing code that doesn't support ARC with your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory model in Objective C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARC in UI kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is ARC and how does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you remember, the idea of reference counting covers the actual deletion of
    objects from the memory. With reference counting, Objective-C takes care of the
    actual object destruction. Owner objects are only responsible for releasing their
    claim of ownership on the object. So, logically the idea that appeared next was
    to make everything completely automatic as it was done in languages such as Java
    and C#. This idea was developed in the Garbage collection branch and Automatic
    Reference Counting.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection is only available for Mac OS X, starting with version 10.5\.
    Also, note that iOS applications can't use Garbage collection; since it relies
    on the power of the device, it will take some time to process, forcing the user
    to wait the process end, thus producing a bad user experience. It is also deprecated
    since OS X Version 10.8 is in favor of ARC and is scheduled to be removed in the
    forthcoming versions of OS X.
  prefs: []
  type: TYPE_NORMAL
- en: ARC is a new and innovative way that contains many of the Garbage collection's
    advantages, yet different from Garbage collection. ARC does not have any process
    in the background to make the object's deallocation, which gives ARC a big advantage
    against Garbage collection when comparing their performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before explaining how ARC does this, it''s important to understand
    what ARC does not do:'
  prefs: []
  type: TYPE_NORMAL
- en: ARC does not impose a runtime memory model as Garbage collection does. Code
    compiled under ARC uses the same memory model as plain C or non-ARC Objective-C
    code, and can be linked to the same libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARC only makes automatic memory management possible for Objective-C objects,
    inherited from `NSObject` (note that in Objective-C, blocks also happen to be
    objects under the covers though).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocated in any other way is not touched and must still be managed manually.
    The same goes for other resources such as file handles and sockets, such as streams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How ARC looks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by picturing a traditional Objective-C source code file written by an
    expert Cocoa programmer. The `retain`, `release`, and `autorelease` messages are
    sent in all the right places and are in perfect balance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine editing the source code file, removing every instance of the `retain`,
    `release`, and `autorelease` messages, and changing a single build setting in
    Xcode that instructs the compiler to put all the suitable memory management calls
    back into your program when the source code is compiled. That's ARC. It's just
    what the name suggests—traditional Cocoa reference counting, being automatically
    done.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, ARC is not a runtime service; it doesn't work on program execution,
    as Garbage collection does. On the other hand, the new Clang, the compiler frontend
    for C, C++, Objective-C, and Objective-C++, provides it as a two-part phase (we
    will call these phases "cycles"). In the following diagram, you can see these
    two phases. At the cycle named **frontend** as shown in the following diagram,
    **Clang** will analyze every preprocessed file for properties and objects. And
    then, relying on a few fixed rules, it will insert the correct statements—`retain`,
    `release`, and `autorelease`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How ARC looks](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For instance, if an object is allocated and locally corresponds to a method,
    this object will have a `release` statement close to that method's endpoint. This
    `release` statement, if it is a class property, comes into the `dealloc` method
    in a class, which can be your custom class or any Objective-C class. If it's a
    collection object or a return value, it will get an `autorelease` statement. However,
    if it was referenced as weak, it will be left in peace.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend also inserts `retain` statements for disowned objects locally.
    It goes to every declared accessor and updates them with the directive `@property`.
    It includes calls to the `dealloc` routine of their superclasses such as `NSObject`
    or `UIViewController` or even your own `customer` superclass. It will also report
    any explicit management call and double ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the optimize cycle, the modified sources are sent to load balancing by Clang.
    So, it calculates the retain and release calls created for each object, and reduces
    all to the optimal minimum. This action avoids excessive `retain` and `release`
    messages with the possibility to impact with full performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's an Objective-C class with no `retain` or `release`. There is one private
    property named `myOwnString`, which is an instance of `NSString`. This class imports
    the header of the `MyBar` class (line 1) and declares a read-only getter with
    the same name, `myOwnString`. There is a modifier called `getMyBarWithString`
    and an internal function named `getMyBar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the same piece of code using **Manual Reference Counting**
    (**MRC**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the class interface is still the same. However, now, the `getMyBarWithString`
    modifier has some new statements; more specifically, two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Sending a release statement to the `myOwnString` property (line 24) is the responsibility
    of one of them. The other sends a `retain` message to the `myString` argument
    (line 25). Before returning the last one as its result, the `getMyBar` function
    sends locally a `autorelease` statement to the `yBar` local. Lastly, MRC supersedes
    the `dealloc` method of that class. MRC also releases the `myOwnString` property
    (line 44) and invokes the `dealloc` method of its superclass (line 45); still
    in that method, if there is already a `dealloc` method, MRC properly updates its
    code.
  prefs: []
  type: TYPE_NORMAL
- en: When using ARC, you don't need to explicitly insert `retain` and `release` messages,
    as ARC will automatically insert them during compilation. Since ARC decides by
    itself how an Objective-C object will be better managed, the time that will be
    required to develop the class code is not required anymore. So, ARC avoids any
    empty pointers. ARC can also be excluded on a per-file basis where you select
    your target, go to **Build Phases,** and add the **-fno-objc-arc** flag in **Compiler
    Flags**.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Clang compiler is built into LLVM 3.0, only available on Xcode
    since version 4.2\. There has been optimized runtime support for ARC ever since
    Mac OS X Version 10.7 and iOS Version 5.0\. It is not challenging to use ARC with
    binaries from Mac OS X 10.6 and iOS 4.3, but for iOS 4.3, it's only achievable
    through blue code; and for OS X 10.6, the newest version does not make use of
    weak pointers at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some points about ARC are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not work with `AppleScriptObjC` or even `PyObjC` sources; it works exclusively
    with Objective-C sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, more or less, when there are `PyObjC` and `AppleScriptObjC` classes
    being connected to Cocoa by Objective-C code, ARC will affect that underlying
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that for some third-party frameworks, if ARC is enabled, they might crash
    while compiling. Ensure that the developer of such a framework can and will update
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project settings for ARC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a project is set to utilize ARC, the compiler flag `-fobjc-arc` is by default
    set for every Objective-C source file. ARC can be disabled for particular classes
    through the compiler flag, `-fno-obj-arc`. In Xcode, go to the target **Build
    Phases** tab, open the **Compile Sources** group, and you will be able to see
    the source file list. When you double-click on the file where you want to set
    it, a pop-up panel will appear. In that panel, get in the `-fno-obj-arc` flag
    and click on **Done** to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'If ARC was not enabled when the project was created, then to enable it, follow
    this process:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Edit** | **Refactor** | **Convert to Objective-C ARC**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no problem and it's ready to convert, it will check your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, all newly created Objective-C projects in Xcode 5 are enabled with
    ARC. However, if you need to disable it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Targets**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the right panel, go to **Build Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Automatic Reference Counting**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Apple LLVM compiler 3.0 – Language**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate **Objective-C++ Automatic Reference Counting** and, in all three sections,
    select **NO**.![Project settings for ARC](img/00004.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A memory model in Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very significant improvement in Objective C 2.0 is its memory model. The countless
    remnants of problems from the first Objective-C implementations as a preprocessor
    that induced C were cleaned up. In older versions, Objective-C objects were simply
    C structures, containing a pointer to their classes in their first fields, and
    its pointers were just able to receive messages when you wanted to send them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now every object pointer comes into one of the following categories: `weak`,
    `strong`, `autoreleasing`, and `unsafe unretained`. When ARC is disabled, the
    programmer is responsible to take care of them all, being sure that they are all
    safe, for the reason that all those pointers just fit the last category.'
  prefs: []
  type: TYPE_NORMAL
- en: The default category (type qualifier) is a `strong` pointer; they are largely
    correspondent to the consequences of writing flawless defensive retain/release
    code. Assigning to a `strong` pointer is relative to retain the new value and
    release the old value, because owning references are stored in those pointers.
  prefs: []
  type: TYPE_NORMAL
- en: You need to use `autoreleasing` pointers in order to store values that are autoreleased.
    In Objective-C, such pointers are the most habitual form of non-owning reference
    pointers; they are variables on the heap storing autoreleased values. An owning
    reference pointer, also known as an instance variable, will only be autoreleased
    when it is stored to a non-owning reference pointer, known as an autoreleasing
    variable. If you simply store an autoreleased reference pointer, you will have
    a simple attribution.
  prefs: []
  type: TYPE_NORMAL
- en: In order to decrease the quantity of release and retain statements in a crucial
    piece of code, it's possible to make use of `_autoreleasing`, one of the four
    ARC type qualifiers. However, since the objects will be included in the autoreleasing
    pool and ARC can commonly eliminate this, it's usually not required to use this
    type qualifier, besides the fact that is can make things slower.
  prefs: []
  type: TYPE_NORMAL
- en: Weak is the last category (type qualifier) of pointer. If you used the garbage-collector
    mode in Objective-C, you probably already met `weak` pointers by storing an object
    in such a pointer. It's not seen as an owning reference pointer (for instance,
    a variable), and when the object is deallocated, this point is immediately set
    to nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can count many differences between GC and ARC mode, but the very important
    one is about ARC being deterministic. It''s possible to see it through `weak`
    pointers. See the following code for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, since in the garbage collection mode`__weak` is not granted for on-stack
    variables, the preceding code won't even pass through compilation. However, what
    would happen if the weak declaration is moved to somewhere it's valid? We presume
    that at this point, the object's last reference is already gone. However, the
    log statement will show you that the object is still there, alive. Relying on
    the optimizations that the compiler is running, the collector can possibly see
    its references on the heap if you run the collector by force.
  prefs: []
  type: TYPE_NORMAL
- en: This piece of code will be compiled in the ARC mode—now, weak variables are
    allowed on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: What you need to know about ARC and weak references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Weak references have been supported on GNUstep Objective-C runtime since version
    1.5, since version 5 of iOS, and version 10.7 of OS X. ARC works through the compatibility
    library as well, but it requires modifications of many classes in order to work
    with weak references.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused our attention on Automatic Reference Counter, its
    advantages, how it works, and how to properly set up and integrate it into current
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about the autorelease pool mechanism and its
    classes, blocks, and threads. We will also understand the memory model in Objective-C.
    I hope this chapter has provided you with a good understanding of ARC.
  prefs: []
  type: TYPE_NORMAL
