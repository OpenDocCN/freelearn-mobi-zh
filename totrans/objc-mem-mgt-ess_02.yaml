- en: Chapter 2. Automatic Reference Counting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：自动引用计数
- en: Good ideas live a long life and bad ones die fast. In Objective-C, reference
    counting's long life was seen as a very good idea. The next step of evolution
    in this is that it became automatic, so we call it **Automatic Reference Counting**
    (**ARC**), which was introduced by Apple Inc. in 2011 for application development
    on its desktop and mobile OS, Mac OS X Lion, and iOS 5\. It changed the name of
    the initial referencing counting to **Manual Reference Counting**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的想法可以长久生存，而坏的想法则很快就会消失。在Objective-C中，引用计数的长期存在被视为一个非常好的想法。在这个进化过程中的下一步是它变得自动，所以我们称之为**自动引用计数**（**ARC**），这是苹果公司在2011年为桌面和移动操作系统Mac
    OS X Lion和iOS 5上的应用程序开发引入的。它将初始引用计数的名称更改为**手动引用计数**。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: ARC and how it works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARC及其工作原理
- en: Advantages and disadvantages of ARC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARC的优缺点
- en: Project settings for ARC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARC的项目设置
- en: Mixing code that doesn't support ARC with your project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不支持ARC的代码与您的项目混合
- en: Memory model in Objective C
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C中的内存模型
- en: ARC in UI kit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI套件中的ARC
- en: What is ARC and how does it work?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是ARC以及它是如何工作的？
- en: If you remember, the idea of reference counting covers the actual deletion of
    objects from the memory. With reference counting, Objective-C takes care of the
    actual object destruction. Owner objects are only responsible for releasing their
    claim of ownership on the object. So, logically the idea that appeared next was
    to make everything completely automatic as it was done in languages such as Java
    and C#. This idea was developed in the Garbage collection branch and Automatic
    Reference Counting.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，引用计数的想法涵盖了从内存中实际删除对象。有了引用计数，Objective-C负责实际的对象销毁。拥有对象的对象只负责释放其对对象的所有权。因此，下一个出现的想法是使一切完全自动化，就像在Java和C#等语言中做的那样。这个想法在垃圾回收分支和自动引用计数中得到了发展。
- en: Garbage collection is only available for Mac OS X, starting with version 10.5\.
    Also, note that iOS applications can't use Garbage collection; since it relies
    on the power of the device, it will take some time to process, forcing the user
    to wait the process end, thus producing a bad user experience. It is also deprecated
    since OS X Version 10.8 is in favor of ARC and is scheduled to be removed in the
    forthcoming versions of OS X.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收仅适用于Mac OS X，从版本10.5开始。此外，请注意，iOS应用程序不能使用垃圾回收；因为它依赖于设备的性能，这将需要一些时间来处理，迫使用户等待处理结束，从而产生不良的用户体验。它也被弃用了，因为从OS
    X版本10.8开始，它支持ARC，并计划在即将到来的OS X版本中删除。
- en: ARC is a new and innovative way that contains many of the Garbage collection's
    advantages, yet different from Garbage collection. ARC does not have any process
    in the background to make the object's deallocation, which gives ARC a big advantage
    against Garbage collection when comparing their performance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ARC是一种新的创新方式，它包含了垃圾回收的许多优点，但又不同于垃圾回收。ARC没有后台进程来处理对象的释放，这使得ARC在性能比较中相对于垃圾回收具有很大的优势。
- en: 'However, before explaining how ARC does this, it''s important to understand
    what ARC does not do:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在解释ARC如何做到这一点之前，了解ARC不做什么是很重要的：
- en: ARC does not impose a runtime memory model as Garbage collection does. Code
    compiled under ARC uses the same memory model as plain C or non-ARC Objective-C
    code, and can be linked to the same libraries.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARC不强制运行时内存模型，如垃圾回收所做的那样。在ARC下编译的代码使用与纯C或非ARC Objective-C代码相同的内存模型，并且可以链接到相同的库。
- en: ARC only makes automatic memory management possible for Objective-C objects,
    inherited from `NSObject` (note that in Objective-C, blocks also happen to be
    objects under the covers though).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARC只为从`NSObject`继承的Objective-C对象提供自动内存管理，注意在Objective-C中，块也偶然是底层对象）。
- en: Memory allocated in any other way is not touched and must still be managed manually.
    The same goes for other resources such as file handles and sockets, such as streams.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以任何其他方式分配的内存不会被触及，并且仍然必须手动管理。对于其他资源，如文件句柄和套接字（如流）也是如此。
- en: How ARC looks
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARC的外观
- en: Start by picturing a traditional Objective-C source code file written by an
    expert Cocoa programmer. The `retain`, `release`, and `autorelease` messages are
    sent in all the right places and are in perfect balance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，想象一个由专家Cocoa程序员编写的传统Objective-C源代码文件。`retain`、`release`和`autorelease`消息在所有正确的位置发送，并且处于完美的平衡状态。
- en: Now, imagine editing the source code file, removing every instance of the `retain`,
    `release`, and `autorelease` messages, and changing a single build setting in
    Xcode that instructs the compiler to put all the suitable memory management calls
    back into your program when the source code is compiled. That's ARC. It's just
    what the name suggests—traditional Cocoa reference counting, being automatically
    done.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下编辑源代码文件，移除所有`retain`、`release`和`autorelease`消息的实例，并在Xcode中更改一个单一的构建设置，该设置指示编译器在编译源代码时将所有合适的内存管理调用放回你的程序中。这就是ARC。它正是名字所暗示的——传统的Cocoa引用计数，是自动完成的。
- en: At its core, ARC is not a runtime service; it doesn't work on program execution,
    as Garbage collection does. On the other hand, the new Clang, the compiler frontend
    for C, C++, Objective-C, and Objective-C++, provides it as a two-part phase (we
    will call these phases "cycles"). In the following diagram, you can see these
    two phases. At the cycle named **frontend** as shown in the following diagram,
    **Clang** will analyze every preprocessed file for properties and objects. And
    then, relying on a few fixed rules, it will insert the correct statements—`retain`,
    `release`, and `autorelease`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，ARC（自动引用计数）不是一个运行时服务；它不像垃圾回收那样作用于程序执行。另一方面，新的Clang，C、C++、Objective-C和Objective-C++的编译器前端，将其提供为两个阶段（我们将这些阶段称为“周期”）。在下面的图中，你可以看到这两个阶段。在名为**前端**的周期中（如下所示），**Clang**将分析每个预处理的文件以查找属性和对象。然后，依靠一些固定的规则，它将插入正确的语句——`retain`、`release`和`autorelease`。
- en: '![How ARC looks](img/00003.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![ARC的外观](img/00003.jpeg)'
- en: For instance, if an object is allocated and locally corresponds to a method,
    this object will have a `release` statement close to that method's endpoint. This
    `release` statement, if it is a class property, comes into the `dealloc` method
    in a class, which can be your custom class or any Objective-C class. If it's a
    collection object or a return value, it will get an `autorelease` statement. However,
    if it was referenced as weak, it will be left in peace.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个对象被分配并且局部对应一个方法，这个对象将在该方法端点附近有一个`release`语句。如果这个`release`语句是一个类属性，它将进入类的`dealloc`方法中，这可能是一个自定义类或任何Objective-C类。如果它是一个集合对象或返回值，它将得到一个`autorelease`语句。然而，如果它被作为弱引用引用，它将被留在那里。
- en: The frontend also inserts `retain` statements for disowned objects locally.
    It goes to every declared accessor and updates them with the directive `@property`.
    It includes calls to the `dealloc` routine of their superclasses such as `NSObject`
    or `UIViewController` or even your own `customer` superclass. It will also report
    any explicit management call and double ownership.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前端也会为局部释放的对象插入`retain`语句。它访问每个声明的访问器，并使用指令`@property`更新它们。它包括对超类如`NSObject`或`UIViewController`或甚至你自己的`customer`超类的`dealloc`例程的调用。它还会报告任何显式的管理调用和双重所有权。
- en: 'In the optimize cycle, the modified sources are sent to load balancing by Clang.
    So, it calculates the retain and release calls created for each object, and reduces
    all to the optimal minimum. This action avoids excessive `retain` and `release`
    messages with the possibility to impact with full performance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化周期中，修改后的源代码被发送到Clang的负载均衡。因此，它计算为每个对象创建的`retain`和`release`调用，并将它们减少到最优的最小值。这个动作避免了过多的`retain`和`release`消息，这些消息可能会影响完全的性能：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, it's an Objective-C class with no `retain` or `release`. There is one private
    property named `myOwnString`, which is an instance of `NSString`. This class imports
    the header of the `MyBar` class (line 1) and declares a read-only getter with
    the same name, `myOwnString`. There is a modifier called `getMyBarWithString`
    and an internal function named `getMyBar`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它是一个没有`retain`或`release`的Objective-C类。有一个名为`myOwnString`的私有属性，它是一个`NSString`的实例。这个类导入了`MyBar`类的头文件（第1行）并声明了一个同名只读获取器，`myOwnString`。还有一个名为`getMyBarWithString`的修饰符和一个名为`getMyBar`的内部函数。
- en: 'The following code is the same piece of code using **Manual Reference Counting**
    (**MRC**):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用**手动引用计数**（**MRC**）的相同代码片段：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the class interface is still the same. However, now, the `getMyBarWithString`
    modifier has some new statements; more specifically, two:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类接口仍然是相同的。然而，现在，`getMyBarWithString`修饰符有一些新的语句；更具体地说，两个：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Sending a release statement to the `myOwnString` property (line 24) is the responsibility
    of one of them. The other sends a `retain` message to the `myString` argument
    (line 25). Before returning the last one as its result, the `getMyBar` function
    sends locally a `autorelease` statement to the `yBar` local. Lastly, MRC supersedes
    the `dealloc` method of that class. MRC also releases the `myOwnString` property
    (line 44) and invokes the `dealloc` method of its superclass (line 45); still
    in that method, if there is already a `dealloc` method, MRC properly updates its
    code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 向`myOwnString`属性（第24行）发送释放语句是其中之一的责任。另一个向`myString`参数（第25行）发送`retain`消息。在将最后一个返回作为其结果之前，`getMyBar`函数向`yBar`局部变量发送本地`autorelease`语句。最后，MRC取代了该类的`dealloc`方法。MRC还释放了`myOwnString`属性（第44行）并调用了其超类的`dealloc`方法（第45行）；仍然在该方法中，如果已经存在`dealloc`方法，MRC会适当地更新其代码。
- en: When using ARC, you don't need to explicitly insert `retain` and `release` messages,
    as ARC will automatically insert them during compilation. Since ARC decides by
    itself how an Objective-C object will be better managed, the time that will be
    required to develop the class code is not required anymore. So, ARC avoids any
    empty pointers. ARC can also be excluded on a per-file basis where you select
    your target, go to **Build Phases,** and add the **-fno-objc-arc** flag in **Compiler
    Flags**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ARC时，你不需要显式插入`retain`和`release`消息，因为ARC将在编译期间自动插入它们。由于ARC会自行决定如何更好地管理Objective-C对象，因此不再需要开发类代码所需的时间。因此，ARC避免了任何空指针。你还可以在单个文件的基础上排除ARC，选择你的目标，转到**构建阶段**，并在**编译器标志**中添加**-fno-objc-arc**标志。
- en: However, the Clang compiler is built into LLVM 3.0, only available on Xcode
    since version 4.2\. There has been optimized runtime support for ARC ever since
    Mac OS X Version 10.7 and iOS Version 5.0\. It is not challenging to use ARC with
    binaries from Mac OS X 10.6 and iOS 4.3, but for iOS 4.3, it's only achievable
    through blue code; and for OS X 10.6, the newest version does not make use of
    weak pointers at all.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Clang编译器是构建在LLVM 3.0中的，仅从Xcode 4.2版本开始可用。自从Mac OS X版本10.7和iOS版本5.0以来，已经对ARC提供了优化运行时支持。使用Mac
    OS X 10.6和iOS 4.3的二进制文件启用ARC并不困难，但对于iOS 4.3，只能通过蓝代码实现；而对于OS X 10.6，最新版本根本不使用弱指针。
- en: 'Some points about ARC are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ARC的一些要点如下：
- en: It does not work with `AppleScriptObjC` or even `PyObjC` sources; it works exclusively
    with Objective-C sources.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适用于`AppleScriptObjC`或甚至`PyObjC`源；它仅适用于Objective-C源。
- en: However, more or less, when there are `PyObjC` and `AppleScriptObjC` classes
    being connected to Cocoa by Objective-C code, ARC will affect that underlying
    code.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，或多或少，当有`PyObjC`和`AppleScriptObjC`类通过Objective-C代码连接到Cocoa时，ARC将影响底层代码。
- en: Note that for some third-party frameworks, if ARC is enabled, they might crash
    while compiling. Ensure that the developer of such a framework can and will update
    it.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，对于某些第三方框架，如果启用了ARC，它们在编译时可能会崩溃。请确保该框架的开发者能够并愿意更新它。
- en: Project settings for ARC
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARC的项目设置
- en: When a project is set to utilize ARC, the compiler flag `-fobjc-arc` is by default
    set for every Objective-C source file. ARC can be disabled for particular classes
    through the compiler flag, `-fno-obj-arc`. In Xcode, go to the target **Build
    Phases** tab, open the **Compile Sources** group, and you will be able to see
    the source file list. When you double-click on the file where you want to set
    it, a pop-up panel will appear. In that panel, get in the `-fno-obj-arc` flag
    and click on **Done** to finish.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目设置为使用ARC时，编译器标志`-fobjc-arc`默认为每个Objective-C源文件设置。可以通过编译器标志`-fno-obj-arc`禁用特定类的ARC。在Xcode中，转到**构建阶段**标签，打开**编译源**组，你将能够看到源文件列表。当你双击想要设置的文件时，将出现一个弹出面板。在该面板中，输入`-fno-obj-arc`标志，然后点击**完成**以完成设置。
- en: 'If ARC was not enabled when the project was created, then to enable it, follow
    this process:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建项目时没有启用ARC，那么要启用它，请按照以下步骤操作：
- en: Open the project.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目。
- en: Go to **Edit** | **Refactor** | **Convert to Objective-C ARC**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑** | **重构** | **转换为Objective-C ARC**。
- en: If there is no problem and it's ready to convert, it will check your code.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有问题并且准备转换，它将检查你的代码。
- en: 'By default, all newly created Objective-C projects in Xcode 5 are enabled with
    ARC. However, if you need to disable it, follow these steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Xcode 5中所有新创建的Objective-C项目都启用了ARC。但是，如果你需要禁用它，请按照以下步骤操作：
- en: Select **Project**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**项目**。
- en: Select **Targets**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**目标**。
- en: From the right panel, go to **Build Settings**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右侧面板，转到**构建设置**。
- en: Select **Automatic Reference Counting**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**自动引用计数**。
- en: Select **Apple LLVM compiler 3.0 – Language**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Apple LLVM 编译器 3.0 – 语言**。
- en: Locate **Objective-C++ Automatic Reference Counting** and, in all three sections,
    select **NO**.![Project settings for ARC](img/00004.jpeg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**Objective-C++ 自动引用计数**，并在所有三个部分中，选择**NO**。![ARC的项目设置](img/00004.jpeg)
- en: A memory model in Objective-C
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C 的内存模型
- en: A very significant improvement in Objective C 2.0 is its memory model. The countless
    remnants of problems from the first Objective-C implementations as a preprocessor
    that induced C were cleaned up. In older versions, Objective-C objects were simply
    C structures, containing a pointer to their classes in their first fields, and
    its pointers were just able to receive messages when you wanted to send them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 2.0 的一个非常重要的改进是其内存模型。作为预处理器的第一个Objective-C实现中无数问题的残留都被清理了。在旧版本中，Objective-C对象仅仅是C结构，它们在第一个字段中包含指向其类的指针，并且当你想发送消息时，它们的指针只能接收消息。
- en: 'Now every object pointer comes into one of the following categories: `weak`,
    `strong`, `autoreleasing`, and `unsafe unretained`. When ARC is disabled, the
    programmer is responsible to take care of them all, being sure that they are all
    safe, for the reason that all those pointers just fit the last category.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每一个对象指针都属于以下类别之一：`弱`、`强`、`自动释放`和`不安全未保留`。当ARC被禁用时，程序员需要负责处理它们所有，确保它们都是安全的，因为这些指针仅仅适合最后一个类别。
- en: The default category (type qualifier) is a `strong` pointer; they are largely
    correspondent to the consequences of writing flawless defensive retain/release
    code. Assigning to a `strong` pointer is relative to retain the new value and
    release the old value, because owning references are stored in those pointers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认类别（类型限定符）是一个`强`指针；它们在很大程度上对应于编写无缺陷的防御性保留/释放代码所带来的后果。对`强`指针的赋值相当于保留新值并释放旧值，因为拥有引用的存储就在这些指针中。
- en: You need to use `autoreleasing` pointers in order to store values that are autoreleased.
    In Objective-C, such pointers are the most habitual form of non-owning reference
    pointers; they are variables on the heap storing autoreleased values. An owning
    reference pointer, also known as an instance variable, will only be autoreleased
    when it is stored to a non-owning reference pointer, known as an autoreleasing
    variable. If you simply store an autoreleased reference pointer, you will have
    a simple attribution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储自动释放的值，你需要使用`自动释放`指针。在Objective-C中，这样的指针是最常见的非拥有引用指针形式；它们是在堆上存储自动释放值的变量。一个拥有引用指针，也称为实例变量，只有在它被存储到一个非拥有引用指针，即自动释放变量中时，才会被自动释放。如果你只是存储一个自动释放的引用指针，你将有一个简单的属性。
- en: In order to decrease the quantity of release and retain statements in a crucial
    piece of code, it's possible to make use of `_autoreleasing`, one of the four
    ARC type qualifiers. However, since the objects will be included in the autoreleasing
    pool and ARC can commonly eliminate this, it's usually not required to use this
    type qualifier, besides the fact that is can make things slower.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少关键代码段中释放和保留语句的数量，可以使用四个ARC类型限定符之一`_autoreleasing`。然而，由于对象将被包含在自动释放池中，并且ARC通常可以消除这一点，所以通常不需要使用这个类型限定符，除了它可能会使事情变慢之外。
- en: Weak is the last category (type qualifier) of pointer. If you used the garbage-collector
    mode in Objective-C, you probably already met `weak` pointers by storing an object
    in such a pointer. It's not seen as an owning reference pointer (for instance,
    a variable), and when the object is deallocated, this point is immediately set
    to nil.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`弱`是指针的最后一个类别（类型限定符）。如果你在Objective-C中使用了垃圾回收器模式，你可能已经通过在这样一个指针中存储对象而遇到了`弱`指针。它不被视为一个拥有引用指针（例如，一个变量），当对象被释放时，这个指针立即被设置为nil。'
- en: 'We can count many differences between GC and ARC mode, but the very important
    one is about ARC being deterministic. It''s possible to see it through `weak`
    pointers. See the following code for an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以数出GC和ARC模式之间的许多不同之处，但非常重要的一点是关于ARC的确定性。你可以通过`弱`指针看到这一点。以下代码是一个示例：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Firstly, since in the garbage collection mode`__weak` is not granted for on-stack
    variables, the preceding code won't even pass through compilation. However, what
    would happen if the weak declaration is moved to somewhere it's valid? We presume
    that at this point, the object's last reference is already gone. However, the
    log statement will show you that the object is still there, alive. Relying on
    the optimizations that the compiler is running, the collector can possibly see
    its references on the heap if you run the collector by force.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于在垃圾回收模式下`__weak`对栈变量是不被允许的，所以前面的代码甚至无法通过编译。然而，如果将弱引用声明移动到有效位置会发生什么？我们假设此时对象的最后一个引用已经消失了。然而，日志语句会显示对象仍然存在，是活跃的。依赖于编译器运行的优化，如果强制运行垃圾回收器，收集器可能可以在堆上看到它的引用。
- en: This piece of code will be compiled in the ARC mode—now, weak variables are
    allowed on the heap.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在ARC模式下编译——现在，堆上允许存在弱变量。
- en: What you need to know about ARC and weak references
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要了解的关于ARC和弱引用的内容
- en: Weak references have been supported on GNUstep Objective-C runtime since version
    1.5, since version 5 of iOS, and version 10.7 of OS X. ARC works through the compatibility
    library as well, but it requires modifications of many classes in order to work
    with weak references.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 自从GNUstep Objective-C运行时版本1.5以来，iOS版本5和OS X版本10.7以来，弱引用一直被支持。ARC通过兼容性库工作，但它需要对许多类进行修改才能与弱引用一起工作。
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused our attention on Automatic Reference Counter, its
    advantages, how it works, and how to properly set up and integrate it into current
    projects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关注了自动引用计数（ARC），它的优势、工作原理以及如何正确设置和将其集成到当前项目中。
- en: In the next chapter, we will talk about the autorelease pool mechanism and its
    classes, blocks, and threads. We will also understand the memory model in Objective-C.
    I hope this chapter has provided you with a good understanding of ARC.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论自动释放池机制及其类、块和线程。我们还将了解Objective-C中的内存模型。我希望这一章能让你对ARC有一个良好的理解。
