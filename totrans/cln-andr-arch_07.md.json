["```kt\nplugins {\n    id 'com.android.library'\n    …\n}\n```", "```kt\ndependencies {\n    implementation(project(path: \":my-new-module\"))\n    …\n}\n```", "```kt\ndata class User(\n    val id: String,\n    val firstName: String,\n    val lastName: String,\n    val email: String\n) {\n    fun getFullName() = \"$firstName $lastName\"\n}\n```", "```kt\ninterface UserRepository {\n    fun getUser(id: String): User\n}\n```", "```kt\nclass GetUserUseCase(private val userRepository: UserRepository) {\n    fun getUser(id: String) = userRepository.getUser(id)\n}\n```", "```kt\ndata class Location(\n    val id: String,\n    val userId: String,\n    val lat: Double,\n    val long: Double\n)\n```", "```kt\ninterface LocationRepository {\n    fun getLocation(userId: String): Location\n}\n```", "```kt\nclass GetUserWithLocationUseCase(\n    private val userRepository: UserRepository,\n    private val locationRepository: LocationRepository\n) {\n    fun getUser(id: String) =\n        UserWithLocation(userRepository.getUser(id), locationRepository.getLocation(id))\n}\ndata class UserWithLocation(\n    val user: User,\n    val location: Location\n)\n```", "```kt\ninterface UserRepository {\n    fun getUser(id: String): Flow<User>\n}\ninterface LocationRepository {\n    fun getLocation(id: String): Flow<Location>\n}\n```", "```kt\nclass GetUserWithLocationUseCase(\n    private val userRepository: UserRepository,\n    private val locationRepository: LocationRepository\n) {\n    fun getUser(id: String) = combine(\n        userRepository.getUser(id),\n        locationRepository.getLocation(id)\n    ) { user, location ->\n        UserWithLocation(user, location)\n    }.flowOn(Dispatchers.IO)\n}\n```", "```kt\nsealed class UseCaseException(override val cause: Throwable?) : Throwable(cause) {\n    class UserException(cause: Throwable) : \n        UseCaseException(cause)\n\n    class LocationException(cause: Throwable) : \n        UseCaseException(cause)\n\n    class UnknownException(cause: Throwable) : \n        UseCaseException(cause)\n    companion object {\n        fun extractException(throwable: Throwable): \n            UseCaseException {\n            return if (throwable is UseCaseException) \n                throwable else UnknownException(throwable)\n        }\n    }\n}\n```", "```kt\nsealed class Result<out T : Any> {\n    data class Success<out T : Any>(val data: T) : \n        Result<T>()\n    class Error(val exception: UseCaseException) : \n        Result<Nothing>()\n}\n```", "```kt\nclass GetUserWithLocationUseCase(\n    private val userRepository: UserRepository,\n    private val locationRepository: LocationRepository\n) {\n    fun getUser(id: String) = combine(\n        userRepository.getUser(id),\n        locationRepository.getLocation(id)\n    ) { user, location ->\n        Result.Success(UserWithLocation(user, location)) as \n            Result<UserWithLocation>\n    }.flowOn(Dispatchers.IO)\n        .catch {\n            emit(Result.Error(UseCaseException.\n                extractException(it)))\n        }\n}\n```", "```kt\nabstract class UseCase<T : Any, R : Any>(private val dispatcher: CoroutineDispatcher) {\n    fun execute(input: T): Flow<Result<R>> = \n        executeData(input)\n        .map {\n            Result.Success(it) as Result<R>\n        }\n        .flowOn(dispatcher)\n        .catch {\n            emit(Result.Error(UseCaseException.\n                extractException(it)))\n        }\n    internal abstract fun executeData(input: T): Flow<R>\n}\n```", "```kt\nclass GetUserWithLocationUseCase(\n    dispatcher: CoroutineDispatcher,\n    private val userRepository: UserRepository,\n    private val locationRepository: LocationRepository\n) : UseCase<String, UserWithLocation>(dispatcher) {\n    override fun executeData(input: String): \n        Flow<UserWithLocation> {\n        return combine(\n            userRepository.getUser(input),\n            locationRepository.getLocation(input)\n        ) { user, location ->\n            UserWithLocation(user, location)\n        }\n    }\n}\n```", "```kt\nabstract class UseCase<T : UseCase.Request, R : UseCase.Response>(private val dispatcher: CoroutineDispatcher) {\n    …\n    interface Request\n    interface Response\n}\n```", "```kt\nclass GetUserWithLocationUseCase(\n    dispatcher: CoroutineDispatcher,\n    private val userRepository: UserRepository,\n    private val locationRepository: LocationRepository\n    ) : UseCase<GetUserWithLocationUseCase.Request, \n    GetUserWithLocationUseCase.Response>(dispatcher) {\n    override fun executeData(input: Request): Flow\n        <Response> {\n        return combine(\n            userRepository.getUser(input.userId),\n            locationRepository.getLocation(input.userId)\n        ) { user, location ->\n            Response(UserWithLocation(user, location))\n        }\n    }\n    data class Request(val userId: String) : UseCase.\n        Request\n    data class Response(val userWithLocation: \n        UserWithLocation) : UseCase.Response\n}\n```", "```kt\n class GetUserUseCase(\n    dispatcher: CoroutineDispatcher,\n    private val userRepository: UserRepository\n    ) : UseCase<GetUserUseCase.Request, \n    GetUserUseCase.Response>(dispatcher) {\n    override fun executeData(input: Request): Flow\n        <Response> {\n        return userRepository.getUser(input.userId)\n            .map {\n                Response(it)\n            }\n    }\n    data class Request(val userId: String) : UseCase.\n        Request\n    data class Response(val user: User) : UseCase.Response\n}\nclass GetLocationUseCase(\n    dispatcher: CoroutineDispatcher,\n    private val locationRepository: LocationRepository\n    ) : UseCase<GetLocationUseCase.Request, \n    GetLocationUseCase.Response>(dispatcher) {\n    override fun executeData(input: Request): Flow\n        <Response> {\n        return locationRepository.getLocation(input.userId)\n            .map {\n                Response(it)\n            }\n    }\n    data class Request(val userId: String) : UseCase\n        .Request\n    data class Response(val location: Location) : UseCase.\n        Response\n}\n```", "```kt\nclass GetUserWithLocationUseCase(\n    dispatcher: CoroutineDispatcher,\n    private val getUserUseCase: GetUserUseCase,\n    private val getLocationUseCase: GetLocationUseCase\n    ) : UseCase<GetUserWithLocationUseCase.Request, \n        GetUserWithLocationUseCase.Response>(dispatcher) {\n    override fun executeData(input: Request): Flow\n        <Response> {\n        return combine( getUserUseCase.executeData\n                (GetUserUseCase.Request(input.userId)),\n            getLocationUseCase.executeData\n                (GetLocationUseCase.Request(input.userId))\n        ) { userResponse, locationResponse ->\n            Response(UserWithLocation(userResponse.user, \n                locationResponse.location))\n        }\n    }\n    data class Request(val userId: String) : UseCase\n        .Request\n    data class Response(val userWithLocation:  \n         UserWithLocation) : UseCase.Response\n}\n```", "```kt\n    buildscript {\n        ext {\n            javaCompileVersion = JavaVersion.VERSION_1_8\n            jvmTarget = \"1.8\"\n            defaultCompileSdkVersion = 31\n            defaultTargetSdkVersion = 31\n            defaultMinSdkVersion = 21\n            …\n    }\n    ```", "```kt\n    buildscript {\n        ext {\n            …\n            versions = [\n                    androidGradlePlugin: \"7.0.4\",\n                    kotlin             : \"1.5.31\",\n                    hilt               : \"2.40.5\",\n                    coreKtx            : \"1.7.0\",\n                    appCompat          : \"1.4.1\",\n                    compose            : \"1.0.5\",\n                    lifecycleRuntimeKtx: \"2.4.0\",\n                    activityCompose    : \"1.4.0\",\n                    material           : \"1.5.0\",\n                    coroutines         : \"1.5.2\",\n                    junit              : \"4.13.2\",\n                    mockito            : \"4.0.0\",\n                    espressoJunit      : \"1.1.3\",\n                    espressoCore       : \"3.4.0\"\n            ]\n            …\n    }\n    ```", "```kt\n    buildscript {\n        ext {\n            …\n            gradlePlugins = [\n                    android: \"com.android.tools.build:\n                        gradle:${versions.\n                            androidGradlePlugin}\",\n                    kotlin : \"org.jetbrains.kotlin:kotlin-    \n                        gradle-plugin:${versions.kotlin}\",\n                    hilt   : \"com.google.dagger:hilt-\n                        android-gradle-plugin:\n                            ${versions.hilt}\"\n            ]\n            …\n    }\n    ```", "```kt\n    buildscript {\n        ext {\n            …\n            androidx = [\n                    core                   : \"androidx.core:core-ktx:${versions.coreKtx}\",\n                    appCompat              : \"androidx.appcompat:appcompat:${versions.appCompat}\",\n                    composeUi              : \"androidx.compose.ui:ui:${versions.compose}\",\n                    composeMaterial        : \"androidx.compose.material:material:${versions.compose}\",\n                    composeUiToolingPreview: \"androidx.compose.ui:ui-tooling-preview:${versions.compose}\",\n                    lifecycleRuntimeKtx    : \"androidx.lifecycle:lifecycle-runtime-ktx:${versions.lifecycleRuntimeKtx}\",\n                    composeActivity        : \"androidx.activity:activity-compose:${versions.activityCompose}\"\n            ]\n            …\n    }\n    ```", "```kt\n    buildscript {\n        ext {\n            …\n            material = [\n                    material: \"com.google.android.\n                        material:material:$\n                            {versions.material}\"\n            ]\n            coroutines = [\n                    coroutinesAndroid: \"org.jetbrains.\n                        kotlinx:kotlinx-coroutines-\n                           android:${versions.coroutines}\"\n            ]\n            di = [\n                    hiltAndroid : \"com.google.dagger:hilt-\n                        android:${versions.hilt}\",\n                    hiltCompiler: \"com.google.dagger:hilt-\n                        compiler:${versions.hilt}\"\n            ]\n            test = [\n                    junit     : \n                        \"junit:junit:${versions.junit}\",\n                    coroutines: \"org.jetbrains.kotlinx:\n                        kotlinx-coroutines-test:\n                            ${versions.coroutines}\",\n                    mockito   : \"org.mockito.kotlin:\n                       mockito-kotlin:${versions.mockito}\"\n            ]\n            androidTest = [\n                    junit             : \"androidx.test.ext\n                        :junit:${versions.espressoJunit}\",\n                    espressoCore      : \"androidx.test.\n                        espresso:espresso-core:$\n                            {versions.espressoCore}\",\n                    composeUiTestJunit: \"androidx.compose.\n                    ui:ui-test-junit4:${versions.compose}\"\n            ]\n        }\n        …\n    }\n    ```", "```kt\n    buildscript {\n         …\n        dependencies {\n            classpath gradlePlugins.android\n            classpath gradlePlugins.kotlin\n            classpath gradlePlugins.hilt\n        }\n    }\n    ```", "```kt\n    android {\n        compileSdk defaultCompileSdkVersion\n        defaultConfig {\n            …\n            minSdk defaultMinSdkVersion\n            targetSdk defaultTargetSdkVersion\n            versionCode 1\n            versionName \"1.0\"\n            …\n        }\n        …\n        compileOptions {\n            sourceCompatibility javaCompileVersion\n            targetCompatibility javaCompileVersion\n        }\n        kotlinOptions {\n            jvmTarget = jvmTarget\n            useIR = true\n        }\n        buildFeatures {\n            compose true\n        }\n        composeOptions {\n            kotlinCompilerExtensionVersion \n                versions.compose\n        }\n        …\n    }\n    ```", "```kt\n    dependencies {\n        implementation androidx.core\n        implementation androidx.appCompat\n        implementation material.material\n        implementation androidx.composeUi\n        implementation androidx.composeMaterial\n        implementation androidx.composeUiToolingPreview\n        implementation androidx.lifecycleRuntimeKtx\n        implementation androidx.composeActivity\n        testImplementation test.junit\n    }\n    ```", "```kt\n    plugins {\n        id 'com.android.library'\n        id 'kotlin-android'\n        id 'kotlin-kapt'\n        id 'dagger.hilt.android.plugin'\n    }\n    ```", "```kt\n    android {\n        compileSdk defaultCompileSdkVersion\n        defaultConfig {\n            minSdk defaultMinSdkVersion\n            targetSdk defaultTargetSdkVersion\n            …\n        }\n        …\n        compileOptions {\n            sourceCompatibility javaCompileVersion\n            targetCompatibility javaCompileVersion\n        }\n        kotlinOptions {\n            jvmTarget = jvmTarget\n        }\n    }\n    ```", "```kt\n    dependencies {\n        implementation coroutines.coroutinesAndroid\n        implementation di.hiltAndroid\n        kapt di.hiltCompiler\n        testImplementation test.junit\n        testImplementation test.coroutines\n        testImplementation test.mockito\n    }\n    ```", "```kt\n    data class Post(\n        val id: Long,\n        val userId: Long,\n        val title: String,\n        val body: String\n    )\n    ```", "```kt\n    data class User(\n        val id: Long,\n        val name: String,\n        val username: String,\n        val email: String\n    )\n    ```", "```kt\n    data class PostWithUser(\n        val post: Post,\n        val user: User\n    )\n    ```", "```kt\n    data class Interaction(val totalClicks: Int)\n    ```", "```kt\n    sealed class UseCaseException(cause: Throwable) : Throwable(cause) {\n        class PostException(cause: Throwable) : \n            UseCaseException(cause)\n        class UserException(cause: Throwable) : \n            UseCaseException(cause)\n        class UnknownException(cause: Throwable) : \n            UseCaseException(cause)\n        companion object {\n            fun createFromThrowable(throwable: Throwable): \n                UseCaseException {\n                return if (throwable is UseCaseException) \n                throwable else UnknownException(throwable)\n            }\n        }\n    }\n    ```", "```kt\n    sealed class Result<out T : Any> {\n        data class Success<out T : Any>(val data: T) : \n            Result<T>()\n        class Error(val exception: UseCaseException) : \n            Result<Nothing>()\n    }\n    ```", "```kt\n    interface PostRepository {\n        fun getPosts(): Flow<List<Post>>\n        fun getPost(id: Long): Flow<Post>\n    }\n    ```", "```kt\n    interface UserRepository {\n        fun getUsers(): Flow<List<User>>\n        fun getUser(id: Long): Flow<User>\n    }\n    ```", "```kt\n    interface InteractionRepository {\n        fun getInteraction(): Flow<Interaction>\n        fun saveInteraction(interaction: Interaction): \n            Flow<Interaction>\n    }\n    ```", "```kt\n    abstract class UseCase<I : UseCase.Request, O : UseCase.Response>(private val configuration: Configuration) {\n        fun execute(request: I) = process(request)\n            .map {\n                Result.Success(it) as Result<O>\n            }\n            .flowOn(configuration.dispatcher)\n            .catch {\n                emit(Result.Error(UseCaseException.\n                    createFromThrowable(it)))\n            }\n        internal abstract fun process(request: I): Flow<O>\n        class Configuration(val dispatcher: \n            CoroutineDispatcher)\n        interface Request\n        interface Response\n    }\n    ```", "```kt\n    class GetPostsWithUsersWithInteractionUseCase @Inject constructor(\n        configuration: Configuration,\n        private val postRepository: PostRepository,\n        private val userRepository: UserRepository,\n        private val interactionRepository: \n            InteractionRepository\n        ) : GetPostsWithUsersWithInteractionUseCase \n        GetPostsWithUsersWithInteractionUseCase {\n        override fun process(request: Request): \n            Flow<Response> =\n            combine(\n                postRepository.getPosts(),\n                userRepository.getUsers(),\n                interactionRepository.getInteraction()\n            ) { posts, users, interaction ->\n                val postUsers = posts.map { post ->\n                    val user = users.first {\n                        it.id == post.userId\n                    }\n                    PostWithUser(post, user)\n                }\n                Response(postUsers, interaction)\n            }\n        object Request : UseCase.Request\n        data class Response(\n            val posts: List<PostWithUser>,\n            val interaction: Interaction\n        ) : UseCase.Response\n    }\n    ```", "```kt\n    class GetPostUseCase @Inject constructor(\n        configuration: Configuration,\n        private val postRepository: PostRepository\n        ) : UseCase<GetPostUseCase.Request, \n        GetPostUseCase.Response>(configuration) {\n        override fun process(request: Request): Flow\n            <Response> =\n            postRepository.getPost(request.postId)\n                .map {\n                    Response(it)\n                }\n        data class Request(val postId: Long) : UseCase.\n            Request\n        data class Response(val post: Post) : UseCase.\n            Response\n    }\n    ```", "```kt\n    class GetUserUseCase @Inject constructor(\n        configuration: Configuration,\n        private val userRepository: UserRepository\n        ) : UseCase<GetUserUseCase.Request,\n        GetUserUseCase.Response>(configuration) {\n        override fun process(request: Request): Flow\n            <Response> =\n            userRepository.getUser(request.userId)\n                .map {\n                    Response(it)\n                }\n        data class Request(val userId: Long) : UseCase.\n            Request\n        data class Response(val user: User) : UseCase.\n            Response\n    }\n    ```", "```kt\n    class UpdateInteractionUseCase @Inject constructor(\n        configuration: Configuration,\n        private val interactionRepository: \n            InteractionRepository\n        ) : UseCase<UpdateInteractionUseCase.Request, \n        UpdateInteractionUseCase.Response>(configuration) {\n        override fun process(request: Request): Flow\n            <Response> {\n            return interactionRepository.saveInteraction\n                (request.interaction)\n                .map {\n                    Response\n                }\n        }\n        data class Request(val interaction: Interaction) : \n             UseCase.Request\n        object Response : UseCase.Response\n    }\n    ```", "```kt\n    class UseCaseTest {\n        @ExperimentalCoroutinesApi\n        private val configuration = UseCase.Configuration\n            (TestCoroutineDispatcher())\n        private val request = mock<UseCase.Request>()\n        private val response = mock<UseCase.Response>()\n        @ExperimentalCoroutinesApi\n        private lateinit var useCase: \n            UseCase<UseCase.Request, UseCase.Response>\n        @ExperimentalCoroutinesApi\n        @Before\n        fun setUp() {\n            useCase = object : UseCase<UseCase.Request, \n                UseCase.Response>(configuration) {\n                override fun process(request: Request):  \n                    Flow<Response> {\n                    assertEquals(this@UseCaseTest.request, \n                        request)\n                    return flowOf(response)\n                }\n            }\n        }\n    }\n    ```", "```kt\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testExecuteSuccess() = runBlockingTest {\n            val result = useCase.execute(request).first()\n            assertEquals(Result.Success(response), result)\n        }\n    ```", "```kt\n    class GetPostsWithUsersWithInteractionUseCaseTest {\n        private val postRepository = mock<PostRepository>()\n        private val userRepository = mock<UserRepository>()\n        private val interactionRepository = mock<InteractionRepository>()\n        private val useCase = GetPostsWithUsersWithInteractionUseCase(\n            mock(),\n            postRepository,\n            userRepository,\n            interactionRepository\n        )\n    }\n    ```", "```kt\n        @ExperimentalCoroutinesApi\n        @Test\n        fun testProcess() = runBlockingTest {\n            val user1 = User(1L, \"name1\", \"username1\", \"email1\")\n            val user2 = User(2L, \"name2\", \"username2\", \"email2\")\n            val post1 = Post(1L, user1.id, \"title1\", \"body1\")\n            val post2 = Post(2L, user1.id, \"title2\", \"body2\")\n            val post3 = Post(3L, user2.id, \"title3\", \"body3\")\n            val post4 = Post(4L, user2.id, \"title4\", \"body4\")\n            val interaction = Interaction(10)\n            whenever(userRepository.getUsers()).thenReturn\n                (flowOf(listOf(user1, user2)))\n            whenever(postRepository.getPosts()).thenReturn\n              (flowOf(listOf(post1, post2, post3, post4)))whenever(interactionRepository.getInteraction\n                ()).thenReturn(flowOf(interaction))\n            val response = useCase.process\n                (GetPostsWithUsersWithInteractionUseCase.\n                    Request).first()\n            assertEquals(\n                GetPostsWithUsersWithInteractionUseCase.\n                    Response(\n                    listOf(\n                        PostWithUser(post1, user1),\n                        PostWithUser(post2, user1),\n                        PostWithUser(post3, user2),\n                        PostWithUser(post4, user2),\n                    ), interaction\n                ),\n                response\n            )\n        }\n    ```"]