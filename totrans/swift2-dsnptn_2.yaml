- en: Chapter 2. Structural Patterns – Decorator, Proxy, and Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reviewing the five creational patterns in the previous chapter, we will
    now talk about another category of patterns: the structural patterns. There are
    seven patterns to talk about; these patterns ease the design by identifying a
    simple way to realize relationships between entities.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see how these patterns help you to encapsulate the composition of objects
    through the use of an interface, allowing you to conveniently abstract your system
    as the creational pattern does to encapsulate the creation of objects. Structural
    patterns highlight the use of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how the composition is designed; we will not interfere with the
    object itself but with the one that will transfer the structuration. This second
    object is strongly related to the first one. Indeed, the first object presents
    the interface to the client and manages its relationship with the second object,
    which, manages the composition and doesn't have any interfaces with clients.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to make a note of is that this structuration allows a great
    flexibility to your system by allowing dynamic modification of the composition.
    Indeed, we can substitute an object with another if both inherit the same class
    and use the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can have several possible implementations. The classic way to design this
    is to differentiate these implementations in subclasses. In this case, we will
    provide an interface from where our classes will implement this interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution consists of a static composition. Indeed, once the implementation
    class of an object is chosen, we can no longer change it. The following diagram
    is the implementation of an object by heritage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static and dynamic composition](img/4852_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another way is to separate the implementation in another object. The implementation
    parts are managed by an instance of the `ConcreteImplementationA` class or by
    the `ConcreteImplementationB` class. This reference is referred by the `implementation`
    attribute. This instance can then be easily substituted by another instance at
    runtime. This composition is dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: The following UML class diagram shows us clearly how to structure your objects
    using a dynamic composition. The `ConcreteImplementation` class can be switched
    at runtime, without having to modify the `Realization` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can eventually modify the realization object, without having to modify our
    original object, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static and dynamic composition](img/4852_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you'll see how to use this solution with the bridge pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The discovery of the structural patterns will span three chapters. In this
    chapter, we will introduce you to three of them:'
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bridge pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three patterns provide a mechanism of adding states and behaviors dynamically,
    controlling the creation and access of objects, and keeping the specification
    and implementation separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objectives of the three structural patterns that we will see in this chapter
    are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Objective |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| The decorator pattern | This pattern allows you to dynamically add new behaviors
    and functionalities to the object. |'
  prefs: []
  type: TYPE_TB
- en: '| The proxy pattern | This pattern is a substitute of another object. It provides
    a behavior that can adapt to the optimization or security needs. |'
  prefs: []
  type: TYPE_TB
- en: '| The bridge pattern | This pattern decouples an abstraction from its implementation,
    enabling them to vary independently. |'
  prefs: []
  type: TYPE_TB
- en: The decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first structural pattern that we will discuss is the decorator pattern.
    It introduces you to the object substitution by adding new functionalities or
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main objective of this pattern is to dynamically add new functionalities
    to an object. The interface of the object will not be modified, so from the client's
    perspective, this is fully transparent.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is an alternative to the addition of a subclass that adds functionalities
    to its parent class. A key implementation point in the decorator pattern is that
    decorators both inherit the original class and contain an instantiation of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used when:'
  prefs: []
  type: TYPE_NORMAL
- en: A system adds dynamically new functionalities to an object, without having to
    modify its interface, which means without having to modify the client of this
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A system manages the behavior that can be dynamically removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of inheritance is not a good option because of an already complex class
    hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generic UML class diagram of the decorator pattern is quiet simple: The
    `ConcreteComponent` and `AbstractDecorator` classes share the same interface that
    have the same method name. Our `AbstractDecorator` class defines a constructor
    where we pass our `Abstractcomponent` class as an argument. Then, in our `ConcreteDecorator`
    class, we reroute the operation call to the `additionalOperation` methods to add
    new functionalities or behaviors to the original component, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding diagram, there are four participants in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractComponent`: This is the common interface to components and decorators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteComponent`: This is the main object to which we want to add behaviors
    and/or functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractDecorator`: This abstract class contains a reference to a component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteDecoratorA` and `ConcreteDecoratorB`: These are the concrete subclasses
    of `AbstractDecorator`. These classes implement the functionalities added to the
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a decorator receives a message that must reach the component, it redirects
    the message by making a prior or posterior operation to that redirection.
  prefs: []
  type: TYPE_NORMAL
- en: Sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate this pattern, we will take a simple example. Let''s suppose that
    you have a drawing software that enables you to draw some shapes on the screen:
    a rectangle and square.'
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to draw these shapes. Now, you need to add a new functionality
    that will add a rounded angle to your shapes. To do this, you need to decide which
    decorator pattern you need to use that will allow you to not to interfere with
    the existing class method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create our interface that defines the shape. We will simulate
    a `Draw()` operation. In fact, the method will return a string that tells us what
    is drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create our two concrete classes that implement the `IShape` interface.
    We will have the `Square` and `Rectangle` classes. They both implement the `draw`
    function. This function returns the shape that is currently drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our classes are ready; now, we prepare our abstract `ShapeDecorator` class
    that defines the structure of our future concrete decorators. This class implements
    the `IShape` interface too, so the `Draw()` function must be present. Nevertheless,
    Swift doesn''t have an abstract class, so we implement the draw method, but we
    force an exception to tell us that this method must be implemented. The `ShapeDecorator`
    class will not be used by the client itself. The client will call the `ConcreteDecorator`
    object to add a new functionality to its shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add our concrete decorator class that inherits from the `ShapeDecorator`
    abstract class. We add our new `setRoundedCornerShape` functionality to this class
    and override the `draw` function to return the shape that is drawn, but with rounded
    corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, here is the easy part that shows us how to use all of the code, we already
    have written, from the client perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create our two concrete shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to have some shapes with rounded corners. To do this, we simply
    call the `ConcreteDecorator` class that interests us, the `RoundedCornerShapeDecorator`
    class, and pass a new shape (`Rectangle` or `Square`) as an argument of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we simulate the `Draw()` method on the screen of our shapes by calling
    the `draw` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Playground will return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift allows you to implement the decorator pattern using the concept of extensions.
    This allows you to add additional methods to concrete classes or constructs, without
    having to subclass or alter the original one. With extensions, you can add new
    methods but no new properties, as opposed to a subclass.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second pattern that we will talk about in this chapter is the proxy pattern.
    It is often used for security or optimization purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The objective of the proxy pattern is to substitute an object (the subject)
    with another one that will control its access. The object that substitutes the
    subject shares the same interface, so it is transparent from the consumer's perspective.
    The proxy is often a small (public) object that stands in for a more complex (private)
    object that is activated once certain circumstances are clear. The proxy adds
    a level of indirection by accepting requests from a client object and passing
    them to the real subject as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proxy pattern is used in object-oriented programming. There are several
    types of proxies, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A virtual proxy**: This allows you to create a "big" object at the appropriate
    time (used when the creation process is slow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A remote proxy**: This allows you to access an object that is available on
    another environment (such as on a multiplayer game server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An authentication proxy**: This check whether the access permission for a
    request is correct or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following class diagram is quite simple; we have an interface that defines
    our subject, both the proxy and `RealSubject` implement this interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client will call the proxy, not the `RealSubject` object himself. The proxy
    contains a reference to the `RealSubject` object. When the proxy receives a request,
    it can analyze it, and if the request is considered to be valid, it can be rerouted
    to the `RealSubject.request()` method. The proxy can decide when to create, or
    not, the `RealSubject` object avoiding to have to manage too big object in memory
    if useless. The following figure represent the generic class diagram of the proxy
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are only three participants in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ISubject`: This is the common interface of the `Proxy` and `RealSubject` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RealSubject`: This is the object that is controlled and manipulated by the
    proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Proxy`: This is the object that substitutes `RealSubject`. It has the same
    interface of the `RealSubject` object (the `ISubject` interface). It creates,
    controls, enhances, and authenticates access to a `RealSubject` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proxy receives the incoming request from a client instead of the `RealSubject`.
    If necessary, the message is then delegated to the `RealSubject` object. In this
    case, prior to the delegation, the proxy creates the `RealSubject` object if it
    has not already been done.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are developing a new software; this software presents a video catalog in
    a list. For each video in the list, we have a placeholder for the video and a
    description. The placeholder of the video first displays a screenshot of the video.
    If we click on this image, the video will be launched.
  prefs: []
  type: TYPE_NORMAL
- en: The video catalog contains videos, so it will be too heavy to have all of these
    videos in memory and transferring them through the network will take too long.
    The proxy pattern will help us organize all of this. We will create the subject
    only when we will need it, once the screenshot is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The list is loaded quickly, mainly if it is downloaded from the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only videos that we want to watch are created, loaded, and played
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Screenshot` class that represents the video is called the proxy of the
    `Video` subject. The proxy substitutes the `Video` subject for the display. The
    `Screenshot` class implements the same interface as the `Video` subject (the `RealSubject`
    object).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the proxy pattern design is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Illustration](img/4852_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the proxy receives the `display()` message, it will display the video if
    this one already exists. If it receives the `click()` message, it will first create
    the `Video` subject and then load the video.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first define the interface that will be used by our proxy and real subject.
  prefs: []
  type: TYPE_NORMAL
- en: When we simulate the real behavior of these methods with Playground, these methods
    return a string, telling us what the code is expected to do. We can ensure what
    we are coding is correct by checking the message returned by Playground.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface will have only two methods: `click()` and `display()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RealSubject` object is represented here with the video class. We implement
    the interface and display the message according to the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The proxy now implements the same interface as the `RealSubject` object: the
    `IAnimation` interface but has the intelligence to create the `RealSubject` object,
    here the `video` object, when needed in the `click` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cool part is to simulate the client.
  prefs: []
  type: TYPE_NORMAL
- en: We first create a new proxy, `Screenshot`, and then we simulate the operation.
    We call `display` from the proxy. As the video is not created or loaded, it is
    the screenshot that will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we simulate a click. We can see that when we call the `click` method,
    the video gets loaded. As the video is created and loaded, we call the `display`
    method, which informs us that the video is now playing (instead of the screenshot
    of the video):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result in Playground is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the proxy pattern when you have objects, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Expensive to create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access remote sites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to perform some actions whenever they are accessed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, use the proxy pattern when you want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create objects only when their operations are requested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform checks or housekeeping on objects whenever accessed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a local object that will refer to a remote object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement access rights on objects when their operations are requested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bridge pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that, at the beginning of the chapter, we discussed dynamic composition
    that allows you to change the implementation of an object at runtime. The bridge
    pattern is another structural pattern that allows this.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bridge pattern decouples an abstraction from its implementation. This means
    that this pattern separates the implementation of an object from its representation
    and interface.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, firstly, the implementation can fully be encapsulated, and secondly, the
    implementation and representation can independently change, without having any
    constraints between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid a strong link between the object representation and its implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid any impact between the interaction of the objects and their clients
    when the implementations of objects are modified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow the representation of objects and their implementations to keep their
    extension capability by creating new subclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid to obtain very complex classes hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the class diagram of the bridge pattern, the separation between the abstraction
    and the implementation is very well represented—notice the left-hand side and
    right-hand side of the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bridge pattern uses a minimum of four participants:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AbstractClass` represents the domain objects. This class contains the interface
    used by clients and contains a reference to an object that implements the `Implementation`
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConcreteClass` is the class that implements the methods defined in the
    `AbstractClass`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ImplementationBase` class defines the method signature of the concrete
    implementation classes. The methods defined here differ from the methods of the
    `Abstract` class. These two sets of methods are different. Generally, methods
    of the `AbstractClass` are high-level methods, while the methods of the `implementation`
    class are low-level methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConcreteImplementationA` (`B` …) classes are concrete classes that realize
    methods introduced in the `ImplementationBase` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ImplementationBase` interface represents the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operation of `AbstractClass` and its subclasses invokes the methods defined
    in the `ImplementationBase` interface, which represent the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We should be able to turn on the light or TV using the same object. Once my
    code to turn on the light or TV will be implemented in my client, I don't need
    to modify it if the `ConcreteImplementation` structure changes. Using the bridge
    pattern, I will use an object that inherits from `AbstractClass`. This object
    contains a method that the client will consume. This method doesn't turn on the
    TV, but it calls the method defined in the `ImplementationBase` class; thus, depending
    on the object that our abstract object uses, it will run the actions that are
    defined in the `ConcreteImplementation` class, which are represented by the TV
    or the light.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the preceding problem, we will first define the method and a property
    that contains the object we want to manipulate. This object will implement the
    `ImplementationBase` interface, which represents the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object that will be manipulated by clients will have a `turnOn()` method.
    This is the only method known by the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will define the `ImplementationBase` interface. It contains the `run()`method
    that each `ConcreteImplementation` class will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our interfaces are now ready; we can create the `RemoteControl` class that
    our clients will use. Depending on the object referred in the `concreteImpl` property,
    the `turnOn()` method will call the run method of the `concreteImpl` object. To
    obtain a reference to the `concreteImpl` object, we will add an argument to the
    constructor (`init`) of the `RemoteControl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we implement our `ImplementationBase` class for the `TV` and `Light`
    classes. A `run()` method is needed in each of them. The `run()` method contains
    all the needed logic that will permit you to turn on the light or TV. In our example,
    we only display a text that indicates the action has been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the client''s perspective, we will use our `RemoteControl` abstraction
    class, pass the final object to the constructor when we want to manipulate (the
    `Light` or `TV` class), and call the `turnOn()` method of the `RemoteControl`
    object to execute the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to Playground, we can now see the live result, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see two messages on the right-hand side of our Playground file: **tv
    turned on** and **light turned on**, which means that the `run()` method of each
    final object has been correctly executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed the three structural patterns in this chapter: the decorator pattern,
    the proxy pattern, and the bridge pattern. From a high-level perspective, all
    of them help you extend classes without using inheritance, but using a dynamic
    composition of its class hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending our original class has some impact on our original object except for
    the proxy pattern where it remains completely unchanged. The decorator pattern
    that needs to be designed needs to have the original class already developed because
    every concrete decorator needs to implement an interface based on the original
    object structure. The bridge pattern is more closely coupled, and there is an
    understanding that the original object must incorporate considerable references
    to the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed all the patterns that rely on rerouting operations. We learned
    that the rerouting is always done from the new code back to the original.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that in real-time applications, where performance is
    required, the overhead of the time for rerouting the operations might not be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our discovery of structural patterns with
    the composite and flyweight patterns, which can be applied to systems that have
    huge data objects.
  prefs: []
  type: TYPE_NORMAL
