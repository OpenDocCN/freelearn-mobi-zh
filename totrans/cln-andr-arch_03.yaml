- en: '*Chapter 2*: Deep Diving into Data Sources'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will study some of the popular libraries and frameworks
    used for retrieving and managing data on Android and how to do this without blocking
    the main thread of an application. We will start by going over how multithreading
    should be handled in an Android application and the available technologies we
    now have to easily handle this. We will then move on to implement loading data
    from the internet using libraries such as Retrofit and OkHttp, after which we
    will look at how we can persist data on a device using libraries such as Room
    and DataStore.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kotlin coroutines and flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OkHttp and Retrofit for networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Room library for data persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and using the DataStore library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have become familiar with how we can load,
    manage, and persist data in an Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the following hardware and software requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/38uecPi](https://bit.ly/38uecPi)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kotlin coroutines and Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how threading works in the Android ecosystem
    and what applications must do to ensure that long-running operations do not block
    the user from using an application. We will then look at what available options
    we have available to execute operations in the background, with a focus on coroutines.
    Finally, we will look over Kotlin flows, which we can use to handle asynchronous
    work using a reactive and functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android applications normally run in a single process on a user''s device.
    When the operating system starts the application''s process, it will allocate
    memory resources for the process to be executed. This process, when started, will
    have one thread of execution running within. This thread is referred to as the
    "main thread" or "**user interface** (**UI**) thread". In Android, this concept
    is very important because it is the thread that deals with user interaction. This
    imposes certain limitations for developers when dealing with it, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: The main thread must not be blocked by long-running or **input/output** (**I/O**)
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All updates to the UI must be done on the main thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea is that the user should still be able to interact with an application
    as much as possible even if the application is doing some work. Every time we
    want to load and save data from or to the internet, local storage, content providers,
    and so on, we should use another thread or use multiple threads. The way the device's
    processor deals with multiple threads is by assigning a core for each thread.
    When there are more threads than cores, it will jump back and forth between every
    single instruction from each thread. Having too many threads being executed simultaneously
    will end up creating a bad **user experience** (**UX**) because the processor
    will now need to jump between the main thread and the rest of the threads being
    executed at the same time, so we will need to be mindful of how many threads are
    being executed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, a thread can be created using the `Thread` class; however, creating
    a new thread for every asynchronous operation is a very resource-expensive operation.
    Java also offers the concept of `ThreadPool` or `Executor`. These typically manage
    fixed a collection of threads that will be reused for different operations. Because
    of the Android restriction regarding updating the UI on the main thread, classes
    such as `Handler` and `Looper` were introduced, whereby you can submit the result
    of an operation performed on a background thread back on the main thread. An example
    of this is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the sum of two numbers will be performed on a
    new thread, and the result will then be posted back using the `Handler` object
    that is connected to the main `Looper` object, which itself will loop the main
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repeated usage of `Handler` and `Looper` gave birth to `AsyncTask`, which
    offers the possibility of moving the necessary operations on a background thread
    and receiving the result on the main thread. `AsyncTask` worked with the same
    principle as the preceding example, only instead of creating a new thread for
    every new operation, it would by default use the same thread (although this later
    became configurable), which means that if two `AsyncTask` instances were executed
    at the same time, one would wait after the other. An example of the same sum operations
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the sum is done in the `doInBackground` method, which
    is executed on a separate thread, and the `onPostExecute` method would be executed
    on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now imagine that we want to chain these sums and apply them multiple
    times, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we try to sum two numbers and add the result to number
    `c`. As you can see, we need to use the callback and wait for `a` and `b` to finish
    and then apply the same function to the result of `a+b` and the number `c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine what an application might look like when having to deal with
    loading data from multiple data sources, merging them together, handling errors,
    and stopping the asynchronous execution if the user leaves the current activity
    or fragment. The RxJava library tries to tackle all these problems through an
    event-driven approach. It introduces the concepts of streams and flows of data
    that can be observed, transformed, merged with other data streams, and executed
    on different threads. The sum of two numbers in RxJava might look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a `Single` instance, which is a stream that
    emits only one value (for emitting multiple values, we have the `Flowable` and
    `Observable` options). The value emitted is the sum of the two numbers. The usage
    of `subscribeOn` is for executing the upstream (the sum) on an I/O thread managed
    by RxJava internally, and the usage of `observeOn` is to have everything downstream
    (all the commands that will follow) to get the result on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to chain multiple sums, then we would have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the sum of `a` and `b` is executed, then through the
    `flatMap` operator, we add `c` to that result. The usage of `subscribe` method
    is for triggering sums and listening for the results. This is because the `Single`
    instance used is a cold observable; it will only be executed only when `subscribe`
    is called. There is also the concept of hot observables, which will emit whether
    there are subscribers or not. The result of the `subscribe` operator will return
    a `Disposable` instance that offers a `dispose` method that can be called when
    we want to stop listening for data from the stream. This is useful in situations
    where our activities and fragments are destroyed, and we don't want to update
    our UI to avoid context leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have analyzed technologies that revolve around the Java and Android
    frameworks. With the adoption of Kotlin, other technologies have emerged that
    deal with multithreading and are Kotlin-specific. One of these is the concept
    of coroutines. Coroutines simplify the way we write asynchronous code. Instead
    of dealing with callbacks, coroutines introduce the concept of scopes where we
    can specify which threads our blocks of code will execute in. The scopes can also
    connect to lifecycle-aware components that help us unsubscribe from the results
    of asynchronous work when our lifecycle-aware components terminate. Let''s look
    at the following example of coroutines for the same sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `withContext` method will execute the block of
    code inside it in the threads managed by the I/O dispatcher. The number of threads
    associated with this dispatcher is managed internally by the Kotlin framework
    and is associated with the number of cores the processor of the device has. This
    often means that we don't have to worry about the performance of our applications
    when multiple asynchronous operations are executed concurrently. Another interesting
    thing to note in the example is the usage of the `suspend` keyword. This is to
    alert the caller of this method that it will be executed using coroutines on a
    separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what things will look like when we want to invoke this method.
    Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In `asyncComplicatedSum`, we use the `launch` method. This method is associated
    with the `CoroutineContext` object defined in this class. The context is defined
    using the `Main` dispatcher combined with the `Job` object that will be associated
    with the lifecycle of this object. If the `destroy` method is called while we
    are waiting for the result of the sum, then the execution of the sum will stop
    and we will stop getting the result of the sum. The code will execute each of
    the sums on the I/O thread and then execute log statements on the main thread
    if the job is still alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android, we already have a few `CoroutineScope` objects already defined
    and associated with our lifecycle-aware classes. One that will be relevant to
    us is the one defined for `ViewModels`. This can be found in the `org.jetbrains.kotlinx:kotlinx-coroutines-android`
    library and will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`viewModelScope` is a Kotlin extension created for `ViewModel` instances that
    will execute if the `ViewModel` instance is alive. If `onCleared` is called on
    the `ViewModel` instance, then it will stop listening to the remaining code to
    be executed in the `launch` block.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've analyzed how Kotlin coroutines work and how we can use
    them to handle asynchronous operations in an Android application. In the next
    section, we will create an Android application that will use Kotlin coroutines
    for a simple asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.01 – Using Kotlin coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an application that will display two input fields, one text field, and
    a button. The input fields will be limited to numbers only, and when the user
    presses the button, then the text field will display the sum of the two numbers
    after 5 seconds. The sum and waiting will be implemented using coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A class that will perform the addition of the two numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ViewModel` class that will invoke the addition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The UI using Compose that will use the following function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio using an **Empty Compose Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top level of the `build.gradle` file, define the Compose library version
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `app/build.gradle` file, we need to add the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by creating a `NumberAdder` class and define an `add` operation and a
    delay, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this class, we will add our 5-second delay before performing the sum of the
    two numbers. This is to highlight the asynchronous operation more. `CoroutineDispatcher`
    and the amount we want to delay by will be injected through the constructor. This
    is because we want to unit-test this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to unit-test this class. Before we write the test, create
    a test rule so that we can reuse it for coroutines, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this class, we create a `TestCoroutineDispatcher` instance that will later
    be injected into the unit test so that the test can execute the sum in a synchronous
    way. `@ExperimentalCoroutinesApi` suggests that the usage of `TestCoroutineDispatcher`
    is still in an experimental state and will be moved to a stable version in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, write the unit test for the class, in the form of `NumberAdderTest`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we inject the `testDispatcher` object we created in `DispatcherTestRule`
    into `NumberAdder`, and we then invoke the `add` function. The entire test is
    executed in a special `CoroutineScope` block called `runBlockingTest`, that will
    ensure all the coroutines launched must complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go ahead and create a `ViewModel` class, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use a Compose state that will retain the result of the addition, and
    a method that will trigger the addition into `viewModelScope`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `ViewModel` class has been created, go ahead and create an activity
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we initialize our activity with the content. `Exercise201Theme` should
    be replaced with the theme generated by Android Studio when the project was created.
    Typically, this should be in a `Theme` file and should be a `@Composable` function
    that has the application name followed by the `Theme` suffix. If that is not available,
    you can use `MaterialTheme` instead for the purpose of the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `Screen` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we define variables for our text fields, then we pass the result
    of the addition of the numbers from the ViewModel, and finally, we invoke the
    ViewModel to perform the addition.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, add the `Calculator` function from the exercise definition to the
    `MainActivity` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we run the preceding example, we should see our UI elements, and after inserting
    the numbers and clicking the button, we will get our result. One thing to notice
    is that the user will be able to interact with the UI while the `add` method is
    executed, and clicking multiple times for different numbers will get the results
    5 seconds after each button press.
  prefs: []
  type: TYPE_NORMAL
- en: Using coroutines can improve the quality of an Android application, especially
    when combined with Android extensions for the `ViewModel` class and lifecycle-aware
    components. Coroutines simplify the code we write for asynchronous operations,
    and the addition of the `suspend` keyword can enforce more rigor when dealing
    with these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Coroutines offer a good solution for dealing with asynchronous operations;
    however, they do not offer a good ability to handle multiple streams of data in
    the same way RxJava does. Flows represent an extension to coroutines, which is
    meant to solve this problem. When dealing with flows, there are three entities
    to consider, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Producer**: This entity is responsible for emitting the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intermediary**: This entity deals with the transformation or manipulation
    of the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer**: This entity consumes the data in the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following example of adding two numbers and how it might
    look like using Kotlin flows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a `Flow` object that will emit the result of `a + b` on a stream.
    The `flowOn` method will move the execution of the upstream on an I/O thread.
    Here, we note the similarity to RxJava in the concept of how `Flows` work, but
    we also notice that it''s an extension of coroutines because of the use of `Dispatchers`.
    Let''s now look at how flows look on the consumer side, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we also notice similarities to RxJava—that is, when we try to manipulate
    the stream to perform the addition to number `c` and when it comes to error handling
    due to the `catch` method. The `collect` method, however, is closer to coroutines,
    and it requires a `CoroutineScope` to be used or to declare the calling method
    as a suspend one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flows offer a couple of specialized classes for particular use cases: `StateFlow`
    and `SharedFlow`. The `StateFlow` class is useful because it will offer subscribers
    the last value stored when they subscribe, like how `LiveData` works. Flows can
    also be cold and hot, and `SharedFlow` is a specialized implementation of a hot
    flow. `SharedFlow` will emit items if it is kept in memory if there are any consumers
    or not. When a consumer subscribes to `SharedFlow`, it will also emit the last
    value stored to the consumer, as with `StateFlow`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at Kotlin flows and the benefits they provide
    when it comes to handling asynchronous operations. Next, we will look at how we
    can use Kotlin flows in an Android application through a simple exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.02 – Using Kotlin Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify the application from *Exercise 02.01* so that the addition of the two
    numbers will return a Flow instead of a suspended function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the `add` function in `NumberAdder` to return a Flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change how the `ViewModel` invokes the `add` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `add` function in `NumberAdder` to return a Flow, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create a new Flow where we emit the sum of `a` and `b`, after which
    we put a delay on each item emitted in the stream, and finally, we specify the
    `CoroutineDispatcher` instance we wish to execute the sum on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s modify the unit test for the sum, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the `add` method returns a `Flow` object, we must now find the first
    item emitted in the flow and assert the value of that item against our expected
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `MainViewModel` class to consume the `add` operation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `add` method will still use the same `CoroutineScope` instance to
    launch the `add` method, which will now use the `collect` method to get the result
    of the sum.
  prefs: []
  type: TYPE_NORMAL
- en: If we launch the application after following the steps from the exercise, the
    behavior will be the same as for *Exercise 02.01*, and we can see how Kotlin flows
    extend the functionality of coroutines by introducing concepts from RxJava to
    simplify how we can handle multiple streams of data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've seen how handling asynchronous operations has evolved
    over time and how much our applications benefit from concepts such as coroutines
    and flows that provide management for background threads, simplify how we execute
    asynchronous operations, manage multiple streams of data, and can connect to the
    lifecycle of Android components. In the following section, we will look at tools
    we can use to fetch data from the network and how they can be integrated with
    Kotlin coroutines and flows.
  prefs: []
  type: TYPE_NORMAL
- en: Using OkHttp and Retrofit for networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how we can use the Retrofit library to perform
    networking operations and the benefits it provides.
  prefs: []
  type: TYPE_NORMAL
- en: Many Android applications require the internet to access data stored on various
    servers. Often, this is done through the `HttpURLConnection` or Apache HttpClient.
    Working with either of these components meant that developers would need to manually
    handle the conversion from **plain old Java objects** (**POJOs**) to JSON, handle
    various network configurations, and deal with backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The OkHttp library will address some of these issues through an `OkHttpClient`
    class that will handle various network configurations and that provides other
    features such as caching. The Retrofit library, which can be placed on top of
    the OkHttp library, is meant to ensure type safety when dealing with various data
    formats. It's very configurable and allows the possibility to plug in various
    converter libraries for POJO-to-JSON conversion or **Extensible Markup Language**
    (**XML**) or other types of formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add Retrofit and OkHttp to the project, we will add the following
    dependencies to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to determine which converters we will need to use for the
    data. Because JSON is a common format, we will use a JSON converter and the Moshi
    library to do so, so we will need to add dependencies to these two libraries,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the Moshi library will be responsible for converting POJOs into JSON,
    and the converter library will plug into the Retrofit library and trigger this
    conversion when data is exchanged between the Android application and the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we will need to fetch data from a server in a JSON format. We
    can use the [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    service as an example. If we want to fetch a list of users, we can use the [https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)
    **Uniform Resource Locator** (**URL**). A user''s JSON representation looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the JSON representation that the user has an `id`, a `username`,
    an `email` value, and so on. In Kotlin, we can create a representation of this,
    and we can exclude properties that the application doesn''t need, such as `email`,
    `address`, `phone`, `website`, and `company`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using Moshi to map the property from a JSON to a Kotlin type,
    and we only kept three of the fields present in the initial JSON. Now, let''s
    look at how we can initialize our networking libraries. The code to accomplish
    this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For OkHttp, we use a `Builder` method to create a new `OkHttpClient` instance,
    and we can provide certain configurations for it. We will now use the `OkHttpClient`
    instance created previously to create a `Retrofit` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a new `Retrofit` instance that will have the base URL set to
    [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/).
    Changing the base URL comes in handy during development. Many teams will have
    a development URL used internally to test the development and integration of features
    and will have a production URL where the actual user data is set. Now, we will
    need to connect the Moshi JSON serialization to the `Retrofit` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create `MoshiConverterFactory`, which is a Retrofit converter designed
    to connect `Retrofit` to the JSON serialization done by Moshi. We will now need
    to change our `Retrofit` initialization to what follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we add the `MoshiConverterFactory` converter to the Retrofit `Builder`
    method to allow the two components to work together. Finally, we can create a
    Retrofit interface that will have templates for the HTTP request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface contains an example of various methods for getting, creating,
    updating, and deleting data on servers. Note that the return type of these methods
    is a `Call` object that offers the ability to execute HTTP requests synchronously
    or asynchronously. One of the things that makes Retrofit more appealing to developers
    is the fact that it can be integrated with other asynchronous libraries such as
    RxJava and coroutines. Translating the preceding example to coroutines will look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we add the `suspend` keyword to each method and we
    remove the dependency to the `Call` class. This allows us to execute these methods
    using coroutines. To create an instance of this class, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `Retrofit` instance created previously to create a new instance
    of `UserService`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have analyzed how we can use OkHttp and Retrofit to load
    data from the internet and the benefits these libraries provide, especially when
    combined with Kotlin coroutines and flows. In the next section, we will create
    an Android application that will use these libraries to fetch and display data
    on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.03 – Using OkHttp and Retrofit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an Android application that connects to [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    and displays a list of users using OkHttp, Retrofit, and Moshi. For each user,
    we will display the name, username, and email.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `User` data class that will map the JSON representation of the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `UserService` class that will have a method to retrieve a list of users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `ViewModel` class that will use `UserService` to retrieve a list of
    users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an `Activity` class that will display a list of users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A UI list will be created using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application with an **Empty Compose Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top level of the `build.gradle` file, define the Compose library version,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `app/build.gradle` file, add the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a permission for internet access to the `AndroidManifest.xml` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now move on and create a class that will hold the user information, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we will hold the `id` field, which is generally a relevant field for distinguishing
    between different users and fields that we are required to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `UserService` class that will fetch the user data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we will only have one method that will get a list of users from the `/users`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we initialize the networking objects. Because we aren''t using any `MainApplication`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are initializing our networking libraries and the `UserService` object.
    Currently, we are holding a static reference to this object, which is not a good
    idea in general. Normally, we would rely on DI frameworks to manage these networking
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AndroidManifest.xml` file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Given that we are inheriting from the `Application` class, we will need to add
    this class to the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go ahead and create a `MainViewModel` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `MainViewModel` class will depend on the `UserService` class to get a list
    of `Users` and store them in a Compose state that will be used in the UI. Here,
    we are also creating a `MainViewModelFactory` class that will be responsible for
    injecting the `UserService` class into the `MainViewModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we move on and create a `MainActivity` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we initialize our activity with the content. The `Exercise203Theme` theme
    should be replaced with the theme generated by Android Studio when the project
    was created. Typically, this should be in a `Theme` file and should be a `@Composable`
    function that has the application name followed by the `Theme` suffix. If that
    is not available, you can use `MaterialTheme` instead for the purpose of the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Screen` method in which we will grab a list of users from the `MainViewModel`
    class and draw a list of items, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And finally, add the `UserList` function from the exercise definition into the
    `MainActivity` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we launch the application after following the steps from the exercise, we
    should be able to see a list of users being loaded if the device has internet
    access.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen how we can typically retrieve data from the internet
    in an Android application. We have looked at libraries such as OkHttp and Retrofit
    and seen how straightforward it is to make HTTP calls in a type-safe way without
    converting JSON files to data classes manually. We have also observed the potential
    of these libraries due to their integration with asynchronous technologies such
    as RxJava and coroutines. In the following section, we will look at libraries
    used for persisting data and how we can integrate them with networking libraries
    as well as coroutines and flows.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Room library for data persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how to persist data in Android applications
    and how we can use the Room library to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Android offers many ways for persisting data on an Android device, mostly involving
    files. Some of these files have a specialized approach to persisting data. One
    of these approaches is in the form of SQLite. SQLite is a special type of file
    in which structured data can be stored using **Structured Query Language** (**SQL**)
    queries, as with other types of databases such as MySQL and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, if developers wanted to persist data in SQLite, they were required
    to manually define tables, write queries, and transform objects containing this
    data into the appropriate formats for performing **create, read, update, and delete**
    (**CRUD**) operations. This type of work involved a load of boilerplate code that
    was susceptible to bugs. Room is the answer to that by providing an abstraction
    layer on top of the SQLite operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add Room to an application, we will need to add the following libraries
    in `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for the `kapt` usage is that Room uses annotations that will generate
    the code required for the interaction with the SQLite layer. In order to use the
    `kapt` feature, we will need to add the plugin to the `build.gradle` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will allow the build system to analyze annotations across the project that
    require code generation and generate the necessary classes based on the provided
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data we want to store is annotated with the `@Entity` annotation, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a Room entity named `UserEntity` that will represent a
    table named `user` and has the `@ColumnInfo` annotation is for the name the column
    will have in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical set of CRUD operations might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Just as how we defined in Retrofit a service interface to communicate with the
    server, we also define a similar interface for Room that we annotate with `@Dao`,
    for **data access object** (**DAO**). In this example, we have defined a set of
    functions for getting all users stored in a table, finding users, inserting new
    users, updating a user, and deleting a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Retrofit, Room also provides integrations with coroutines, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we add the `suspend` keyword, which makes the Room
    library easy to integrate and execute as part of a coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of coroutines, the Room library also can integrate with Kotlin flows.
    This is useful for queries that will emit events every time a particular table
    has changed. This integration will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have changed the `@Query` functions to return a
    `Flow` object. If a change occurs in the user table, then the queries will be
    re-triggered and a new list of users will be emitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now need to set up the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we define a new class that extends from the `RoomDatabase`
    class and use the `@Database` annotation to declare our entities and the current
    version. This version is used to keep track of migrations when the structure of
    the database changes in between new releases of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the database, we will need to execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will create our SQLite database and will return an instance of `AppDatabase`
    where we can access the DAO objects we have defined and invoke their methods to
    process the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how we can persist data using Room and how
    it can be integrated with coroutines and flows. In the next section, we will create
    an Android application that will use Room to persist data and look at how it can
    be integrated with Retrofit and OkHttp.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.04 – Using Room to persist data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrate Room into *Exercise 02.03* so that when the users are loaded from
    Retrofit, they will be stored in the database and then displayed on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `UserEntity` class that will be a Room entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `UserDao` class that will contain methods for inserting users and querying
    all the users as flows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `AppDatabase` class that will represent the application's database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `MainViewModel` class to fetch users from the `UserService` class
    and then insert them into the `UserDao` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `MainActivity` class to use a list of `UserEntity` objects instead
    of `User` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `kapt` plugin to the `app/build.gradle` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add Room dependencies to `app/build.gradle`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `UserEntity` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UserEntity` class has the same fields as the `User` class, and it contains
    the Room annotations for the table name and the names of each column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `UserDao` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using flows to return a list of users, and we use the `OnConflictStrategy.REPLACE`
    option so that if the same user is inserted multiple times, then it will be replaced
    with the one that will be inserted. Other options include `OnConflictStrategy.ABORT`,
    which will drop the entire transaction if a conflict occurs, or `OnConflictStrategy.IGNORE`,
    which will skip inserting rows where a conflict occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go ahead and create an `AppDatabase` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `AppDatabase`, we provide the `UserDao` class to be accessed and we use the
    `UserEntity` class for the users' table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to initialize the `AppDatabase` object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are having the same issues that we had for Retrofit, so we will follow
    the same approach and use the `Application` class. Just as with Retrofit, a DI
    framework will help us solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s integrate Room into the `MainViewModel` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `MainViewModel` class now has a new dependency on the `UserDao` class. In
    the `init` block, we now create a flow in which we emit a list of users obtained
    from Retrofit that is then converted into `UserEntity` and inserted into the database.
    After this, we will query the `UserEntities` instances and return them in a stream
    that will be the result. If we have an error, we will return the current stored
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the type of users in the `MainActivity` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we just change the dependency to now rely on the `UserEntity` class.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application after following the steps from the exercise, we will
    see the same output as for *Exercise 02.03*. However, if we close the application,
    turn on Airplane mode on the device, and reopen the app, we will still see the
    previously displayed information.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have analyzed how we can persist structured data on a device
    and used the Room library to do so. We have also observed the interaction between
    Room and other libraries such as Retrofit and flows and how we can use flows to
    combine data streams from Room and Retrofit in a very straightforward way. In
    the next section, we will look at how we can persist simple data in key-value
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using the DataStore library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how we can persist key-value pairs of data
    and how we can use the DataStore library for this. In Android, we have the possibility
    of persisting primitives and strings in key-value pairs. In the past, this was
    done through the `SharedPreferences` class, which was part of the Android framework.
    The keys and values would ultimately be saved inside an XML file on the device.
    Because this deals with I/O operations, it evolved over time to give the possibility
    to save data asynchronously and to keep an in-memory cache for quick access to
    data. There were, however, some inconsistencies with this, especially when the
    `SharedPreferences` object was initialized. DataStore is designed to address these
    issues because it's integrated with coroutines and flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add DataStore to a project, we will need the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Using DataStore will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `KEY_TEXT` field will represent a key that will be used to store some text.
    `DataStore<Preferences>` is responsible for obtaining and writing the data to
    `SharedPreferences`. The `savedText` field will monitor changes in the preferences
    and will emit a new value for each change in a `Flow` object. To write data in
    an asynchronous way, we will need to edit the current data store and set the value
    associated with the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the DataStore library, we will need to declare the following
    as a top-level declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to access the DataStore library in the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to initialize `AppDataStore`, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to wrap the `DataStore` class and avoid exposing the dependencies
    to other places in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how we can persist data in key-value pairs
    and how we can use the DataStore library to do this. In the next section, we will
    create an Android application that will use DataStore and integrate it with Kotlin
    flows and coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.05 – Using DataStore to persist data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *Exercise 02.04* and introduce the DataStore library, which will persist
    the number of executed requests to get the user and display this number above
    the list of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `AppDataStore` that will manage interaction with the DataStore
    library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `MainViewModel` class so that the `AppDataStore` dependency is injected
    and used to retrieve the current number of requests and increment the number of
    requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `MainActivity` class to add a new `Text` object that will display
    the count of requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to the `app/build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `AppDataStore` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `KEY_COUNT` represents the key used by the DataStore library to store
    the number of requests. The `saveCount` field will emit a new count value every
    time it changes, and `incrementCount` will be increment the current saved number
    by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, set up the `AppDataStore` dependency, just like how we handled the Retrofit
    and Room dependencies. The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we initialize the `DataStore` object and then inject it into the `AppDataStore`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify the `MainViewModel` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we add a new dependency to `AppDataStore`, then we call `incrementCount`
    from `AppDataStore` after the users from Retrofit are inserted, and then we will
    insert `savedCount` from `AppDataStore` into the existing flow and create a new
    `UiState` object that contains a list of users and the count, which will be collected
    in the `resultState` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UiState` class will look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class will hold information from both of our persistent data sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, change `MainViewModelFactory`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we will inject a new dependency to `AppDataStore` into the `MainViewModel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, modify the `MainActivity` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we replaced the list of `UserEntity` with the `UiState` dependency and
    added a new row in a list of items that will indicate the count of requests.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application, we will see at the top the current count of requests
    made to the server. If we kill and reopen the application, then we will see that
    count increase, which shows how it will survive the application being stopped
    by the user or killed by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have analyzed another common way of persisting data on an
    Android device through the DataStore library. We also observed how easy it is
    for the DataStore library to be integrated with flows and other libraries such
    as Room and Retrofit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at how we can load and persist data in Android
    and the rules we must follow for threading. We first analyzed how we can load
    data asynchronously and focused on coroutines and flows, for which we have done
    simple exercises for performing asynchronous operations on different threads and
    updating the UI on the main thread. We then studied how to load data from the
    internet using OkHttp and Retrofit, and followed this up with how to persist data
    using Room and DataStore and how we can integrate all of these with coroutines
    and flows. We highlighted the usage of these libraries in exercises, and we also
    showed how they can be integrated with coroutines and flows. The integration of
    different flows of data was combined in the `ViewModel` class, in which we loaded
    the network data and inserted it into the local database. This is generally not
    a good approach, and we will expand on how we can improve this in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can present data to the user and
    the libraries and frameworks we can use to achieve this.
  prefs: []
  type: TYPE_NORMAL
