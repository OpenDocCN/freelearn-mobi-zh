- en: '*Chapter 2*: Deep Diving into Data Sources'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will study some of the popular libraries and frameworks
    used for retrieving and managing data on Android and how to do this without blocking
    the main thread of an application. We will start by going over how multithreading
    should be handled in an Android application and the available technologies we
    now have to easily handle this. We will then move on to implement loading data
    from the internet using libraries such as Retrofit and OkHttp, after which we
    will look at how we can persist data on a device using libraries such as Room
    and DataStore.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kotlin coroutines and flows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OkHttp and Retrofit for networking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Room library for data persistence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and using the DataStore library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have become familiar with how we can load,
    manage, and persist data in an Android application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the following hardware and software requirements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/38uecPi](https://bit.ly/38uecPi)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kotlin coroutines and Flows
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how threading works in the Android ecosystem
    and what applications must do to ensure that long-running operations do not block
    the user from using an application. We will then look at what available options
    we have available to execute operations in the background, with a focus on coroutines.
    Finally, we will look over Kotlin flows, which we can use to handle asynchronous
    work using a reactive and functional approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Android applications normally run in a single process on a user''s device.
    When the operating system starts the application''s process, it will allocate
    memory resources for the process to be executed. This process, when started, will
    have one thread of execution running within. This thread is referred to as the
    "main thread" or "**user interface** (**UI**) thread". In Android, this concept
    is very important because it is the thread that deals with user interaction. This
    imposes certain limitations for developers when dealing with it, as outlined here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The main thread must not be blocked by long-running or **input/output** (**I/O**)
    operations.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All updates to the UI must be done on the main thread.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea is that the user should still be able to interact with an application
    as much as possible even if the application is doing some work. Every time we
    want to load and save data from or to the internet, local storage, content providers,
    and so on, we should use another thread or use multiple threads. The way the device's
    processor deals with multiple threads is by assigning a core for each thread.
    When there are more threads than cores, it will jump back and forth between every
    single instruction from each thread. Having too many threads being executed simultaneously
    will end up creating a bad **user experience** (**UX**) because the processor
    will now need to jump between the main thread and the rest of the threads being
    executed at the same time, so we will need to be mindful of how many threads are
    being executed concurrently.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, a thread can be created using the `Thread` class; however, creating
    a new thread for every asynchronous operation is a very resource-expensive operation.
    Java also offers the concept of `ThreadPool` or `Executor`. These typically manage
    fixed a collection of threads that will be reused for different operations. Because
    of the Android restriction regarding updating the UI on the main thread, classes
    such as `Handler` and `Looper` were introduced, whereby you can submit the result
    of an operation performed on a background thread back on the main thread. An example
    of this is provided here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, the sum of two numbers will be performed on a
    new thread, and the result will then be posted back using the `Handler` object
    that is connected to the main `Looper` object, which itself will loop the main
    thread.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The repeated usage of `Handler` and `Looper` gave birth to `AsyncTask`, which
    offers the possibility of moving the necessary operations on a background thread
    and receiving the result on the main thread. `AsyncTask` worked with the same
    principle as the preceding example, only instead of creating a new thread for
    every new operation, it would by default use the same thread (although this later
    became configurable), which means that if two `AsyncTask` instances were executed
    at the same time, one would wait after the other. An example of the same sum operations
    might look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, the sum is done in the `doInBackground` method, which
    is executed on a separate thread, and the `onPostExecute` method would be executed
    on the main thread.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now imagine that we want to chain these sums and apply them multiple
    times, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we try to sum two numbers and add the result to number
    `c`. As you can see, we need to use the callback and wait for `a` and `b` to finish
    and then apply the same function to the result of `a+b` and the number `c`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine what an application might look like when having to deal with
    loading data from multiple data sources, merging them together, handling errors,
    and stopping the asynchronous execution if the user leaves the current activity
    or fragment. The RxJava library tries to tackle all these problems through an
    event-driven approach. It introduces the concepts of streams and flows of data
    that can be observed, transformed, merged with other data streams, and executed
    on different threads. The sum of two numbers in RxJava might look something like
    this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we create a `Single` instance, which is a stream that
    emits only one value (for emitting multiple values, we have the `Flowable` and
    `Observable` options). The value emitted is the sum of the two numbers. The usage
    of `subscribeOn` is for executing the upstream (the sum) on an I/O thread managed
    by RxJava internally, and the usage of `observeOn` is to have everything downstream
    (all the commands that will follow) to get the result on the main thread.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to chain multiple sums, then we would have something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the sum of `a` and `b` is executed, then through the
    `flatMap` operator, we add `c` to that result. The usage of `subscribe` method
    is for triggering sums and listening for the results. This is because the `Single`
    instance used is a cold observable; it will only be executed only when `subscribe`
    is called. There is also the concept of hot observables, which will emit whether
    there are subscribers or not. The result of the `subscribe` operator will return
    a `Disposable` instance that offers a `dispose` method that can be called when
    we want to stop listening for data from the stream. This is useful in situations
    where our activities and fragments are destroyed, and we don't want to update
    our UI to avoid context leaks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin coroutines
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have analyzed technologies that revolve around the Java and Android
    frameworks. With the adoption of Kotlin, other technologies have emerged that
    deal with multithreading and are Kotlin-specific. One of these is the concept
    of coroutines. Coroutines simplify the way we write asynchronous code. Instead
    of dealing with callbacks, coroutines introduce the concept of scopes where we
    can specify which threads our blocks of code will execute in. The scopes can also
    connect to lifecycle-aware components that help us unsubscribe from the results
    of asynchronous work when our lifecycle-aware components terminate. Let''s look
    at the following example of coroutines for the same sum:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the `withContext` method will execute the block of
    code inside it in the threads managed by the I/O dispatcher. The number of threads
    associated with this dispatcher is managed internally by the Kotlin framework
    and is associated with the number of cores the processor of the device has. This
    often means that we don't have to worry about the performance of our applications
    when multiple asynchronous operations are executed concurrently. Another interesting
    thing to note in the example is the usage of the `suspend` keyword. This is to
    alert the caller of this method that it will be executed using coroutines on a
    separate thread.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what things will look like when we want to invoke this method.
    Have a look at the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `asyncComplicatedSum`, we use the `launch` method. This method is associated
    with the `CoroutineContext` object defined in this class. The context is defined
    using the `Main` dispatcher combined with the `Job` object that will be associated
    with the lifecycle of this object. If the `destroy` method is called while we
    are waiting for the result of the sum, then the execution of the sum will stop
    and we will stop getting the result of the sum. The code will execute each of
    the sums on the I/O thread and then execute log statements on the main thread
    if the job is still alive.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android, we already have a few `CoroutineScope` objects already defined
    and associated with our lifecycle-aware classes. One that will be relevant to
    us is the one defined for `ViewModels`. This can be found in the `org.jetbrains.kotlinx:kotlinx-coroutines-android`
    library and will look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`viewModelScope` is a Kotlin extension created for `ViewModel` instances that
    will execute if the `ViewModel` instance is alive. If `onCleared` is called on
    the `ViewModel` instance, then it will stop listening to the remaining code to
    be executed in the `launch` block.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've analyzed how Kotlin coroutines work and how we can use
    them to handle asynchronous operations in an Android application. In the next
    section, we will create an Android application that will use Kotlin coroutines
    for a simple asynchronous operation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.01 – Using Kotlin coroutines
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an application that will display two input fields, one text field, and
    a button. The input fields will be limited to numbers only, and when the user
    presses the button, then the text field will display the sum of the two numbers
    after 5 seconds. The sum and waiting will be implemented using coroutines.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to build the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: A class that will perform the addition of the two numbers
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ViewModel` class that will invoke the addition
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The UI using Compose that will use the following function:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Follow these steps to complete the exercise:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio using an **Empty Compose Activity**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top level of the `build.gradle` file, define the Compose library version
    as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `app/build.gradle` file, we need to add the following dependencies:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Start by creating a `NumberAdder` class and define an `add` operation and a
    delay, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this class, we will add our 5-second delay before performing the sum of the
    two numbers. This is to highlight the asynchronous operation more. `CoroutineDispatcher`
    and the amount we want to delay by will be injected through the constructor. This
    is because we want to unit-test this class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to unit-test this class. Before we write the test, create
    a test rule so that we can reuse it for coroutines, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this class, we create a `TestCoroutineDispatcher` instance that will later
    be injected into the unit test so that the test can execute the sum in a synchronous
    way. `@ExperimentalCoroutinesApi` suggests that the usage of `TestCoroutineDispatcher`
    is still in an experimental state and will be moved to a stable version in the
    future.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, write the unit test for the class, in the form of `NumberAdderTest`, as
    follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we inject the `testDispatcher` object we created in `DispatcherTestRule`
    into `NumberAdder`, and we then invoke the `add` function. The entire test is
    executed in a special `CoroutineScope` block called `runBlockingTest`, that will
    ensure all the coroutines launched must complete.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go ahead and create a `ViewModel` class, like this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use a Compose state that will retain the result of the addition, and
    a method that will trigger the addition into `viewModelScope`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `ViewModel` class has been created, go ahead and create an activity
    class, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we initialize our activity with the content. `Exercise201Theme` should
    be replaced with the theme generated by Android Studio when the project was created.
    Typically, this should be in a `Theme` file and should be a `@Composable` function
    that has the application name followed by the `Theme` suffix. If that is not available,
    you can use `MaterialTheme` instead for the purpose of the exercise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `Screen` function, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this method, we define variables for our text fields, then we pass the result
    of the addition of the numbers from the ViewModel, and finally, we invoke the
    ViewModel to perform the addition.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: And finally, add the `Calculator` function from the exercise definition to the
    `MainActivity` file.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we run the preceding example, we should see our UI elements, and after inserting
    the numbers and clicking the button, we will get our result. One thing to notice
    is that the user will be able to interact with the UI while the `add` method is
    executed, and clicking multiple times for different numbers will get the results
    5 seconds after each button press.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Using coroutines can improve the quality of an Android application, especially
    when combined with Android extensions for the `ViewModel` class and lifecycle-aware
    components. Coroutines simplify the code we write for asynchronous operations,
    and the addition of the `suspend` keyword can enforce more rigor when dealing
    with these operations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin Flows
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Coroutines offer a good solution for dealing with asynchronous operations;
    however, they do not offer a good ability to handle multiple streams of data in
    the same way RxJava does. Flows represent an extension to coroutines, which is
    meant to solve this problem. When dealing with flows, there are three entities
    to consider, as outlined here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '**Producer**: This entity is responsible for emitting the data.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intermediary**: This entity deals with the transformation or manipulation
    of the data.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer**: This entity consumes the data in the stream.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following example of adding two numbers and how it might
    look like using Kotlin flows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we create a `Flow` object that will emit the result of `a + b` on a stream.
    The `flowOn` method will move the execution of the upstream on an I/O thread.
    Here, we note the similarity to RxJava in the concept of how `Flows` work, but
    we also notice that it''s an extension of coroutines because of the use of `Dispatchers`.
    Let''s now look at how flows look on the consumer side, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we also notice similarities to RxJava—that is, when we try to manipulate
    the stream to perform the addition to number `c` and when it comes to error handling
    due to the `catch` method. The `collect` method, however, is closer to coroutines,
    and it requires a `CoroutineScope` to be used or to declare the calling method
    as a suspend one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Flows offer a couple of specialized classes for particular use cases: `StateFlow`
    and `SharedFlow`. The `StateFlow` class is useful because it will offer subscribers
    the last value stored when they subscribe, like how `LiveData` works. Flows can
    also be cold and hot, and `SharedFlow` is a specialized implementation of a hot
    flow. `SharedFlow` will emit items if it is kept in memory if there are any consumers
    or not. When a consumer subscribes to `SharedFlow`, it will also emit the last
    value stored to the consumer, as with `StateFlow`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at Kotlin flows and the benefits they provide
    when it comes to handling asynchronous operations. Next, we will look at how we
    can use Kotlin flows in an Android application through a simple exercise.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.02 – Using Kotlin Flows
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify the application from *Exercise 02.01* so that the addition of the two
    numbers will return a Flow instead of a suspended function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the `add` function in `NumberAdder` to return a Flow.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change how the `ViewModel` invokes the `add` function.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `add` function in `NumberAdder` to return a Flow, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we create a new Flow where we emit the sum of `a` and `b`, after which
    we put a delay on each item emitted in the stream, and finally, we specify the
    `CoroutineDispatcher` instance we wish to execute the sum on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s modify the unit test for the sum, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because the `add` method returns a `Flow` object, we must now find the first
    item emitted in the flow and assert the value of that item against our expected
    result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `MainViewModel` class to consume the `add` operation, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the `add` method will still use the same `CoroutineScope` instance to
    launch the `add` method, which will now use the `collect` method to get the result
    of the sum.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: If we launch the application after following the steps from the exercise, the
    behavior will be the same as for *Exercise 02.01*, and we can see how Kotlin flows
    extend the functionality of coroutines by introducing concepts from RxJava to
    simplify how we can handle multiple streams of data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've seen how handling asynchronous operations has evolved
    over time and how much our applications benefit from concepts such as coroutines
    and flows that provide management for background threads, simplify how we execute
    asynchronous operations, manage multiple streams of data, and can connect to the
    lifecycle of Android components. In the following section, we will look at tools
    we can use to fetch data from the network and how they can be integrated with
    Kotlin coroutines and flows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Using OkHttp and Retrofit for networking
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how we can use the Retrofit library to perform
    networking operations and the benefits it provides.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Many Android applications require the internet to access data stored on various
    servers. Often, this is done through the `HttpURLConnection` or Apache HttpClient.
    Working with either of these components meant that developers would need to manually
    handle the conversion from **plain old Java objects** (**POJOs**) to JSON, handle
    various network configurations, and deal with backward compatibility.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The OkHttp library will address some of these issues through an `OkHttpClient`
    class that will handle various network configurations and that provides other
    features such as caching. The Retrofit library, which can be placed on top of
    the OkHttp library, is meant to ensure type safety when dealing with various data
    formats. It's very configurable and allows the possibility to plug in various
    converter libraries for POJO-to-JSON conversion or **Extensible Markup Language**
    (**XML**) or other types of formats.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add Retrofit and OkHttp to the project, we will add the following
    dependencies to the `build.gradle` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will need to determine which converters we will need to use for the
    data. Because JSON is a common format, we will use a JSON converter and the Moshi
    library to do so, so we will need to add dependencies to these two libraries,
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the Moshi library will be responsible for converting POJOs into JSON,
    and the converter library will plug into the Retrofit library and trigger this
    conversion when data is exchanged between the Android application and the server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we will need to fetch data from a server in a JSON format. We
    can use the [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    service as an example. If we want to fetch a list of users, we can use the [https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)
    **Uniform Resource Locator** (**URL**). A user''s JSON representation looks like
    this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see in the JSON representation that the user has an `id`, a `username`,
    an `email` value, and so on. In Kotlin, we can create a representation of this,
    and we can exclude properties that the application doesn''t need, such as `email`,
    `address`, `phone`, `website`, and `company`, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we are using Moshi to map the property from a JSON to a Kotlin type,
    and we only kept three of the fields present in the initial JSON. Now, let''s
    look at how we can initialize our networking libraries. The code to accomplish
    this is shown in the following snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For OkHttp, we use a `Builder` method to create a new `OkHttpClient` instance,
    and we can provide certain configurations for it. We will now use the `OkHttpClient`
    instance created previously to create a `Retrofit` instance, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we create a new `Retrofit` instance that will have the base URL set to
    [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/).
    Changing the base URL comes in handy during development. Many teams will have
    a development URL used internally to test the development and integration of features
    and will have a production URL where the actual user data is set. Now, we will
    need to connect the Moshi JSON serialization to the `Retrofit` instance, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we create `MoshiConverterFactory`, which is a Retrofit converter designed
    to connect `Retrofit` to the JSON serialization done by Moshi. We will now need
    to change our `Retrofit` initialization to what follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we add the `MoshiConverterFactory` converter to the Retrofit `Builder`
    method to allow the two components to work together. Finally, we can create a
    Retrofit interface that will have templates for the HTTP request, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This interface contains an example of various methods for getting, creating,
    updating, and deleting data on servers. Note that the return type of these methods
    is a `Call` object that offers the ability to execute HTTP requests synchronously
    or asynchronously. One of the things that makes Retrofit more appealing to developers
    is the fact that it can be integrated with other asynchronous libraries such as
    RxJava and coroutines. Translating the preceding example to coroutines will look
    something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, we add the `suspend` keyword to each method and we
    remove the dependency to the `Call` class. This allows us to execute these methods
    using coroutines. To create an instance of this class, we need to do the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we use the `Retrofit` instance created previously to create a new instance
    of `UserService`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have analyzed how we can use OkHttp and Retrofit to load
    data from the internet and the benefits these libraries provide, especially when
    combined with Kotlin coroutines and flows. In the next section, we will create
    an Android application that will use these libraries to fetch and display data
    on the UI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.03 – Using OkHttp and Retrofit
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an Android application that connects to [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    and displays a list of users using OkHttp, Retrofit, and Moshi. For each user,
    we will display the name, username, and email.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Create a `User` data class that will map the JSON representation of the user.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `UserService` class that will have a method to retrieve a list of users.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `ViewModel` class that will use `UserService` to retrieve a list of
    users.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an `Activity` class that will display a list of users.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A UI list will be created using the following method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Follow these steps to complete the exercise:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Create an Android application with an **Empty Compose Activity**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top level of the `build.gradle` file, define the Compose library version,
    as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `app/build.gradle` file, add the following dependencies:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, add a permission for internet access to the `AndroidManifest.xml` file,
    as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now move on and create a class that will hold the user information, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we will hold the `id` field, which is generally a relevant field for distinguishing
    between different users and fields that we are required to display.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `UserService` class that will fetch the user data, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we will only have one method that will get a list of users from the `/users`
    path.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we initialize the networking objects. Because we aren''t using any `MainApplication`
    class, as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we are initializing our networking libraries and the `UserService` object.
    Currently, we are holding a static reference to this object, which is not a good
    idea in general. Normally, we would rely on DI frameworks to manage these networking
    dependencies.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AndroidManifest.xml` file, add the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Given that we are inheriting from the `Application` class, we will need to add
    this class to the manifest.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go ahead and create a `MainViewModel` class, as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `MainViewModel` class will depend on the `UserService` class to get a list
    of `Users` and store them in a Compose state that will be used in the UI. Here,
    we are also creating a `MainViewModelFactory` class that will be responsible for
    injecting the `UserService` class into the `MainViewModel` class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we move on and create a `MainActivity` class, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we initialize our activity with the content. The `Exercise203Theme` theme
    should be replaced with the theme generated by Android Studio when the project
    was created. Typically, this should be in a `Theme` file and should be a `@Composable`
    function that has the application name followed by the `Theme` suffix. If that
    is not available, you can use `MaterialTheme` instead for the purpose of the exercise.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Screen` method in which we will grab a list of users from the `MainViewModel`
    class and draw a list of items, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And finally, add the `UserList` function from the exercise definition into the
    `MainActivity` file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we launch the application after following the steps from the exercise, we
    should be able to see a list of users being loaded if the device has internet
    access.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen how we can typically retrieve data from the internet
    in an Android application. We have looked at libraries such as OkHttp and Retrofit
    and seen how straightforward it is to make HTTP calls in a type-safe way without
    converting JSON files to data classes manually. We have also observed the potential
    of these libraries due to their integration with asynchronous technologies such
    as RxJava and coroutines. In the following section, we will look at libraries
    used for persisting data and how we can integrate them with networking libraries
    as well as coroutines and flows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Using the Room library for data persistence
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how to persist data in Android applications
    and how we can use the Room library to do this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Android offers many ways for persisting data on an Android device, mostly involving
    files. Some of these files have a specialized approach to persisting data. One
    of these approaches is in the form of SQLite. SQLite is a special type of file
    in which structured data can be stored using **Structured Query Language** (**SQL**)
    queries, as with other types of databases such as MySQL and Oracle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In the past, if developers wanted to persist data in SQLite, they were required
    to manually define tables, write queries, and transform objects containing this
    data into the appropriate formats for performing **create, read, update, and delete**
    (**CRUD**) operations. This type of work involved a load of boilerplate code that
    was susceptible to bugs. Room is the answer to that by providing an abstraction
    layer on top of the SQLite operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add Room to an application, we will need to add the following libraries
    in `build.gradle`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The reason for the `kapt` usage is that Room uses annotations that will generate
    the code required for the interaction with the SQLite layer. In order to use the
    `kapt` feature, we will need to add the plugin to the `build.gradle` file, as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will allow the build system to analyze annotations across the project that
    require code generation and generate the necessary classes based on the provided
    annotations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The data we want to store is annotated with the `@Entity` annotation, as illustrated
    in the following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we have defined a Room entity named `UserEntity` that will represent a
    table named `user` and has the `@ColumnInfo` annotation is for the name the column
    will have in the database.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical set of CRUD operations might look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Just as how we defined in Retrofit a service interface to communicate with the
    server, we also define a similar interface for Room that we annotate with `@Dao`,
    for **data access object** (**DAO**). In this example, we have defined a set of
    functions for getting all users stored in a table, finding users, inserting new
    users, updating a user, and deleting a user.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Retrofit, Room also provides integrations with coroutines, as illustrated
    in the following code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, we add the `suspend` keyword, which makes the Room
    library easy to integrate and execute as part of a coroutine.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of coroutines, the Room library also can integrate with Kotlin flows.
    This is useful for queries that will emit events every time a particular table
    has changed. This integration will look something like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding example, we have changed the `@Query` functions to return a
    `Flow` object. If a change occurs in the user table, then the queries will be
    re-triggered and a new list of users will be emitted.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now need to set up the database, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding snippet, we define a new class that extends from the `RoomDatabase`
    class and use the `@Database` annotation to declare our entities and the current
    version. This version is used to keep track of migrations when the structure of
    the database changes in between new releases of our application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the database, we will need to execute the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will create our SQLite database and will return an instance of `AppDatabase`
    where we can access the DAO objects we have defined and invoke their methods to
    process the data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how we can persist data using Room and how
    it can be integrated with coroutines and flows. In the next section, we will create
    an Android application that will use Room to persist data and look at how it can
    be integrated with Retrofit and OkHttp.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.04 – Using Room to persist data
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrate Room into *Exercise 02.03* so that when the users are loaded from
    Retrofit, they will be stored in the database and then displayed on the UI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Create a `UserEntity` class that will be a Room entity.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `UserDao` class that will contain methods for inserting users and querying
    all the users as flows.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `AppDatabase` class that will represent the application's database.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `MainViewModel` class to fetch users from the `UserService` class
    and then insert them into the `UserDao` class.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `MainActivity` class to use a list of `UserEntity` objects instead
    of `User` objects.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `kapt` plugin to the `app/build.gradle` file, as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add Room dependencies to `app/build.gradle`, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a `UserEntity` class, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `UserEntity` class has the same fields as the `User` class, and it contains
    the Room annotations for the table name and the names of each column.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `UserDao` class, as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we are using flows to return a list of users, and we use the `OnConflictStrategy.REPLACE`
    option so that if the same user is inserted multiple times, then it will be replaced
    with the one that will be inserted. Other options include `OnConflictStrategy.ABORT`,
    which will drop the entire transaction if a conflict occurs, or `OnConflictStrategy.IGNORE`,
    which will skip inserting rows where a conflict occurs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go ahead and create an `AppDatabase` class, as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In `AppDatabase`, we provide the `UserDao` class to be accessed and we use the
    `UserEntity` class for the users' table.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to initialize the `AppDatabase` object, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we are having the same issues that we had for Retrofit, so we will follow
    the same approach and use the `Application` class. Just as with Retrofit, a DI
    framework will help us solve this problem.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s integrate Room into the `MainViewModel` class, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `MainViewModel` class now has a new dependency on the `UserDao` class. In
    the `init` block, we now create a flow in which we emit a list of users obtained
    from Retrofit that is then converted into `UserEntity` and inserted into the database.
    After this, we will query the `UserEntities` instances and return them in a stream
    that will be the result. If we have an error, we will return the current stored
    users.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the type of users in the `MainActivity` class, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we just change the dependency to now rely on the `UserEntity` class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application after following the steps from the exercise, we will
    see the same output as for *Exercise 02.03*. However, if we close the application,
    turn on Airplane mode on the device, and reopen the app, we will still see the
    previously displayed information.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have analyzed how we can persist structured data on a device
    and used the Room library to do so. We have also observed the interaction between
    Room and other libraries such as Retrofit and flows and how we can use flows to
    combine data streams from Room and Retrofit in a very straightforward way. In
    the next section, we will look at how we can persist simple data in key-value
    pairs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using the DataStore library
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how we can persist key-value pairs of data
    and how we can use the DataStore library for this. In Android, we have the possibility
    of persisting primitives and strings in key-value pairs. In the past, this was
    done through the `SharedPreferences` class, which was part of the Android framework.
    The keys and values would ultimately be saved inside an XML file on the device.
    Because this deals with I/O operations, it evolved over time to give the possibility
    to save data asynchronously and to keep an in-memory cache for quick access to
    data. There were, however, some inconsistencies with this, especially when the
    `SharedPreferences` object was initialized. DataStore is designed to address these
    issues because it's integrated with coroutines and flows.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'To add DataStore to a project, we will need the following dependency:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using DataStore will look something like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `KEY_TEXT` field will represent a key that will be used to store some text.
    `DataStore<Preferences>` is responsible for obtaining and writing the data to
    `SharedPreferences`. The `savedText` field will monitor changes in the preferences
    and will emit a new value for each change in a `Flow` object. To write data in
    an asynchronous way, we will need to edit the current data store and set the value
    associated with the key.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the DataStore library, we will need to declare the following
    as a top-level declaration:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will allow us to access the DataStore library in the rest of the application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to initialize `AppDataStore`, we can use the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This allows us to wrap the `DataStore` class and avoid exposing the dependencies
    to other places in the application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how we can persist data in key-value pairs
    and how we can use the DataStore library to do this. In the next section, we will
    create an Android application that will use DataStore and integrate it with Kotlin
    flows and coroutines.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 02.05 – Using DataStore to persist data
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *Exercise 02.04* and introduce the DataStore library, which will persist
    the number of executed requests to get the user and display this number above
    the list of items.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `AppDataStore` that will manage interaction with the DataStore
    library.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `MainViewModel` class so that the `AppDataStore` dependency is injected
    and used to retrieve the current number of requests and increment the number of
    requests.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `MainActivity` class to add a new `Text` object that will display
    the count of requests.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to the `app/build.gradle` file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create an `AppDataStore` class, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, `KEY_COUNT` represents the key used by the DataStore library to store
    the number of requests. The `saveCount` field will emit a new count value every
    time it changes, and `incrementCount` will be increment the current saved number
    by 1.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, set up the `AppDataStore` dependency, just like how we handled the Retrofit
    and Room dependencies. The code is illustrated in the following snippet:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we initialize the `DataStore` object and then inject it into the `AppDataStore`
    class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify the `MainViewModel` class, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we add a new dependency to `AppDataStore`, then we call `incrementCount`
    from `AppDataStore` after the users from Retrofit are inserted, and then we will
    insert `savedCount` from `AppDataStore` into the existing flow and create a new
    `UiState` object that contains a list of users and the count, which will be collected
    in the `resultState` object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UiState` class will look something like this:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This class will hold information from both of our persistent data sources.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, change `MainViewModelFactory`, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we will inject a new dependency to `AppDataStore` into the `MainViewModel`
    class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, modify the `MainActivity` class, as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we replaced the list of `UserEntity` with the `UiState` dependency and
    added a new row in a list of items that will indicate the count of requests.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application, we will see at the top the current count of requests
    made to the server. If we kill and reopen the application, then we will see that
    count increase, which shows how it will survive the application being stopped
    by the user or killed by the operating system.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have analyzed another common way of persisting data on an
    Android device through the DataStore library. We also observed how easy it is
    for the DataStore library to be integrated with flows and other libraries such
    as Room and Retrofit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at how we can load and persist data in Android
    and the rules we must follow for threading. We first analyzed how we can load
    data asynchronously and focused on coroutines and flows, for which we have done
    simple exercises for performing asynchronous operations on different threads and
    updating the UI on the main thread. We then studied how to load data from the
    internet using OkHttp and Retrofit, and followed this up with how to persist data
    using Room and DataStore and how we can integrate all of these with coroutines
    and flows. We highlighted the usage of these libraries in exercises, and we also
    showed how they can be integrated with coroutines and flows. The integration of
    different flows of data was combined in the `ViewModel` class, in which we loaded
    the network data and inserted it into the local database. This is generally not
    a good approach, and we will expand on how we can improve this in future chapters.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何在Android中加载数据和持久化数据，以及我们必须遵循的线程规则。我们首先分析了如何异步加载数据，并专注于协程和流，为此我们进行了简单的练习，以在不同的线程上执行异步操作并更新主线程上的UI。然后我们研究了如何使用OkHttp和Retrofit从互联网加载数据，接着探讨了如何使用Room和DataStore持久化数据，以及我们如何将这些与协程和流集成在一起。我们在练习中强调了这些库的使用，同时也展示了它们如何与协程和流集成。不同数据流的集成被组合在`ViewModel`类中，其中我们加载网络数据并将其插入到本地数据库中。这通常不是一个好的方法，我们将在未来的章节中进一步探讨如何改进这一点。
- en: In the next chapter, we will look at how we can present data to the user and
    the libraries and frameworks we can use to achieve this.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何向用户展示数据，以及我们可以使用的库和框架来实现这一点。
