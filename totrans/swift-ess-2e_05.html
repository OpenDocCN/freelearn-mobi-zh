<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Creating Custom Views in Swift</h1></div></div></div><p class="calibre8">User interfaces can be built by combining standard views and view controllers through Interface Builder, Storyboard Editor, or <a id="id226" class="calibre1"/>with custom code. However, it will eventually become necessary to break apart a user interface into smaller, reusable, and easier to test segments. These are known as <em class="calibre11">custom views</em>.</p><p class="calibre8">This chapter will present the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Customizing table views</li><li class="listitem">Building and laying out custom view subclasses</li><li class="listitem">Drawing graphical views with <code class="literal">drawRect</code></li><li class="listitem">Creating layered graphics with animation</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec32" class="calibre1"/>An overview of UIView</h1></div></div></div><p class="calibre8">All iOS views <a id="id227" class="calibre1"/>are rooted in an Objective-C class called <code class="literal">UIView</code>, which comes from the <code class="literal">UIKit</code> framework/module. The <code class="literal">UIView</code> class represents a rectangular space that may be associated with <code class="literal">UIWindow</code> or constructed to represent an off-screen view. Views that perform user interactions are generally subclasses of <code class="literal">UIControl</code>. Both <code class="literal">UIView</code> and <code class="literal">UIViewController</code> inherit from the <code class="literal">UIResponder</code> class, which in turn inherits from <code class="literal">NSObject</code>:</p><div><img src="img/00066.jpeg" alt="An overview of UIView" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">On Mac OS X, views are rooted in NSView and come from the <code class="literal">AppKit</code> framework. Otherwise, these two<a id="id228" class="calibre1"/> implementations are very similar. A new Xcode project will be used to create custom view classes. Create a new project called <code class="literal">CustomViews</code> that is based on the <strong class="calibre2">Tabbed Application</strong> template. To start with a blank sheet, delete the generated view controllers from the <code class="literal">Main.storyboard</code> and their associated <code class="literal">FirstViewController</code> and <code class="literal">SecondViewController</code> classes.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec33" class="calibre1"/>Creating new views with Interface Builder</h1></div></div></div><p class="calibre8">The <a id="id229" class="calibre1"/>easiest way to create a custom view is<a id="id230" class="calibre1"/> to use Interface Builder to drag and drop the contents. This is typically done with a <code class="literal">UITableView</code> and a <em class="calibre11">prototype table cell</em>.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec62" class="calibre1"/>Creating a table view controller</h2></div></div></div><p class="calibre8">Drag in <a id="id231" class="calibre1"/>a <strong class="calibre2">Table View Controller</strong> from the object library onto the main storyboard, and drag and drop from the tab bar controller to the newly created table view controller to create a relation segue called <code class="literal">view controllers</code>. (Segues are covered in more detail in the <em class="calibre11">Storyboards</em>, <em class="calibre11">Segues</em>
<em class="calibre11">, and Scenes</em> section in <a class="calibre1" title="Chapter 4. Storyboard Applications with Swift and iOS" href="part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b">Chapter 4</a>, <em class="calibre11">Storyboard Applications with Swift and iOS</em>.)</p><p class="calibre8">By default, the table view controller will have <em class="calibre11">dynamic property content</em>—that is, it will be able to display a variable number of rows. This is defined in the <strong class="calibre2">Table View</strong> section of <strong class="calibre2">Attributes Inspector</strong>, which can be displayed by selecting <strong class="calibre2">Table View</strong> from the scene navigator and then pressing <em class="calibre11">Command</em> + <em class="calibre11">Option</em> + <em class="calibre11">4</em>:</p><div><img src="img/00067.jpeg" alt="Creating a table view controller" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="note38" class="calibre1"/>Note</h3><p class="calibre8">There is an option for tables to have <em class="calibre11">static content</em>; a fixed number of rows in the table. This is sometimes useful when creating scrollable content that can be partitioned into slices, even if it doesn't look like a table. Most of the elements in the iOS settings are represented as a fixed-size table view. At the top of the table view are one or more <em class="calibre11">prototype cells</em>. These are used to define the look and feel of the table items. By default, a <code class="literal">UITableViewCell</code> is used, which has a label and an image, but a prototype cell can be used to add more data to the entries.</p></div><div><img src="img/00068.jpeg" alt="Creating a table view controller" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The <a id="id232" class="calibre1"/>prototype cell can be used to provide additional information or views. For example, two labels can be dragged into the view; one label can be centered at the top and can be displayed in the headline font, while the second can be left-aligned.</p><p class="calibre8">Drag two <strong class="calibre2">UILabels</strong> from the object library into the prototype cell and arrange them using <strong class="calibre2">Auto Layout</strong>, appropriately.</p><p class="calibre8">To change a label's font, select the label in the editor and go to <strong class="calibre2">Attributes Inspector</strong>. In the <strong class="calibre2">Label</strong> section, click on the <strong class="calibre2">Font Chooser</strong> icon and select <strong class="calibre2">Headline</strong> or <strong class="calibre2">Subhead</strong>, as appropriate:</p><div><img src="img/00069.jpeg" alt="Creating a table view controller" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When<a id="id233" class="calibre1"/> finished, the prototype cell will look similar to the following screenshot:</p><div><img src="img/00070.jpeg" alt="Creating a table view controller" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When the application is run, an empty table will be seen. This is because the table doesn't have any items displayed at the moment. The next section shows how to add data to a table so that it binds and displays items to the prototype cell.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec63" class="calibre1"/>Showing data in the table</h2></div></div></div><p class="calibre8">A <code class="literal">UITableView</code> acquires <a id="id234" class="calibre1"/>data from a <code class="literal">UITableViewDataSource</code>. The <code class="literal">UITableViewController</code> class already implements the <code class="literal">UITableViewDataSource</code> protocol, so only a small number of methods are required to provide data for the table.</p><div><h3 class="title2"><a id="tip41" class="calibre1"/>Tip</h3><p class="calibre8">As <code class="literal">UITableView</code> was originally implemented in Objective-C, the methods that are defined in the protocol take a <code class="literal">tableView</code>. As a result, all of the <code class="literal">UITableViewDataSource</code> delegate methods in Swift end up being called <code class="literal">tableView</code> with different arguments.</p></div><p class="calibre8">Create a new <code class="literal">SampleTable</code> class that extends <code class="literal">UITableViewController</code>. Implement the class as follows:</p><div><pre class="programlisting">import UIKit
class SampleTable: UITableViewController {
  var items = [
    ("First", "A first item"),
    ("Second", "A second item"),
  ]
  required init?(coder:NSCoder) {
    super.init(coder:coder)
  }
  override func tableView(tableView: UITableView,
    numberOfRowsInSection section:Int) -&gt; Int {
    return items.count
  }
  override func tableView(tableView: UITableView,
    cellForRowAtIndexPath indexPath: NSIndexPath)
     -&gt; UITableViewCell {
    let cell = tableView.
     dequeueReusableCellWithIdentifier("prototypeCell")!
    
    // configure labels
    return cell
  }
}</pre></div><p class="calibre8">Once the data source methods are implemented, the labels need to be configured to display the data from the array. There are three things that need to be done: the prototype cell must be acquired from the <code class="literal">xib</code> file; the labels need to be extracted; and finally the table view controller needs to be associated with the custom <code class="literal">SampleTable</code> class.</p><p class="calibre8">Firstly, the <code class="literal">cellForRowAtIndex</code> function needs an identifier for reusable cells. The <strong class="calibre2">Identifier</strong> is set <a id="id235" class="calibre1"/>on the prototype cell in the main storyboard. To set this, select the prototype cell and go to the <strong class="calibre2">Attributes Inspector</strong>. Enter <code class="literal">prototypeCell</code> in the <strong class="calibre2">Identifier</strong> of the <strong class="calibre2">Table View Cell</strong> section:</p><div><img src="img/00071.jpeg" alt="Showing data in the table" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The identifier is used in the <code class="literal">dequeueReusableCellWithIdentifier</code> method of the <code class="literal">tableView</code>. When a <code class="literal">xib</code> is used to load the cell, the return value will either reuse a cell that has gone off screen earlier, or a new cell will be instantiated from the <code class="literal">xib</code>.</p><p class="calibre8">Each label can be given a non-zero integer <strong class="calibre2">Tag</strong> so that the label can be extracted from the prototype cell using the <code class="literal">viewWithTag</code> method:</p><div><pre class="programlisting">let titleLabel = cell.viewWithTag(1) as! UILabel
let subtitleLabel = cell.viewWithTag(2) as! UILabel</pre></div><p class="calibre8">To assign tags to the views, select the <strong class="calibre2">Heading Label</strong>, navigate to <strong class="calibre2">Attributes Inspector</strong>, and change <strong class="calibre2">Tag</strong> to <code class="literal">1</code>. Do the same thing for the <strong class="calibre2">Subheading Label</strong> with <strong class="calibre2">Tag</strong> set to <code class="literal">2</code>:</p><div><img src="img/00072.jpeg" alt="Showing data in the table" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Now, the text values for the row can be set:</p><div><pre class="programlisting">let (title,subtitle) = items[indexPath.row]
titleLabel.text = title
subtitleLabel.text = subtitle</pre></div><p class="calibre8">Finally, the <code class="literal">SampleTable</code> needs<a id="id236" class="calibre1"/> to be associated with the table view controller. Click the table, go to <strong class="calibre2">Identity Inspector</strong>, and enter <code class="literal">SampleTable</code> in the <strong class="calibre2">Custom Class</strong> section:</p><div><img src="img/00073.jpeg" alt="Showing data in the table" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">When the application is run, the following view will be displayed:</p><div><img src="img/00074.jpeg" alt="Showing data in the table" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="tip42" class="calibre1"/>Tip</h3><p class="calibre8">To hide the status bar, add or change <strong class="calibre2">Status bar is initially hidden</strong> to <strong class="calibre2">YES</strong> and <strong class="calibre2">View controller-based status bar appearance</strong> to <strong class="calibre2">NO</strong> in the <code class="literal">Info.plist</code> file. Please note that Xcode 7 displays a <code class="literal">CGContextRestoreGState: invalid context 0x0</code> error message when using these options, which is a known issue that may be fixed in later releases.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec64" class="calibre1"/>Defining a view in a xib file</h2></div></div></div><p class="calibre8">It is <a id="id237" class="calibre1"/>possible to create a view using <strong class="calibre2">Interface Builder</strong>, save it as a <code class="literal">xib</code> file, and then instantiate it on demand. This is what happens under the covers with <code class="literal">UITableView</code>—there is a <code class="literal">registerNib:forCellReuseIdentifier:</code> method, which takes a <code class="literal">xib</code> file and an identifier (which corresponds to <code class="literal">prototypeCell</code> in the previous example).</p><p class="calibre8">Create a new interface file named <code class="literal">CounterView.xib</code> to represent the view, by navigating to <strong class="calibre2">File</strong> | <strong class="calibre2">New</strong> | <strong class="calibre2">File</strong> | <strong class="calibre2">iOS</strong> | <strong class="calibre2">User Interface</strong> | <strong class="calibre2">View</strong>. When opened, it will display as an empty view with no content and in a 600 x 600 square. To change the size to something that is<a id="id238" class="calibre1"/> a little more reasonable, go to <strong class="calibre2">Attributes Inspector</strong> and change the size from <strong class="calibre2">Inferred</strong> to <strong class="calibre2">Freeform</strong>. At the same time, change the <strong class="calibre2">Status Bar</strong>, <strong class="calibre2">Top Bar</strong>, and <strong class="calibre2">Bottom Bar</strong> to <strong class="calibre2">None</strong>. Then switch to the <strong class="calibre2">Size Inspector</strong> and modify the view's <strong class="calibre2">Frame Rectangle</strong> to <code class="literal">300</code> x <code class="literal">50</code>:</p><div><img src="img/00075.jpeg" alt="Defining a view in a xib file" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">This should resize the view so that it is displayed as 300 by 50 instead of the previous 600 by 600, and the status bar and other bars should not be seen. Now add a <strong class="calibre2">Stepper</strong> from the object library by dragging it to the left-hand side of the view and dragging a <strong class="calibre2">Label</strong> to the right. Adjust the size and add the missing constraints so that the view looks similar to the following screenshot:</p><div><img src="img/00076.jpeg" alt="Defining a view in a xib file" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec65" class="calibre1"/>Wiring a custom view class</h2></div></div></div><p class="calibre8">Create a <a id="id239" class="calibre1"/>new <code class="literal">CounterView</code> class that extends <code class="literal">UIView</code>, and define an <code class="literal">@IBOutlet</code> for the <code class="literal">label</code> and an <code class="literal">@IBAction</code> <code class="literal">change</code> method that takes a <code class="literal">sender</code>.</p><p class="calibre8">Open the <code class="literal">CounterView.xib</code> file and select the view. Change <strong class="calibre2">Custom Class</strong> to be <code class="literal">CounterView</code>. Wire the stepper's <code class="literal">valueChanged</code> event to the <code class="literal">change</code> method and connect the <code class="literal">label</code> outlet:</p><div><img src="img/00077.jpeg" alt="Wiring a custom view class" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Implement <a id="id240" class="calibre1"/>the <code class="literal">change</code> function such that the label text is changed when the stepper is picked:</p><div><pre class="programlisting">import UIKit
class CounterView: UIView {
  @IBOutlet weak var label:UILabel!
  @IBAction func change(sender:AnyObject) {
    let count = (sender as! UIStepper).value
    label.text = "Count is \(count)"
  }
}</pre></div><p class="calibre8">The <code class="literal">CounterView</code> will be added to the <strong class="calibre2">table header</strong> of the <code class="literal">SampleTable</code>. Each <code class="literal">UITableViewController</code> has a reference to its associated <code class="literal">UITableView</code>, and each <code class="literal">UITableView</code> has an optional <code class="literal">headerView</code> (and <code class="literal">footerView</code>) that is used for the table as a whole.</p><div><h3 class="title2"><a id="note39" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">UITableView</code> also has <code class="literal">sectionHeader</code> and <code class="literal">sectionFooter</code>, which are used to separate different sections of the table. A table can have multiple sections—for example, one section per month—and a separate header and footer can be used per section.</p></div><p class="calibre8">To create a <code class="literal">CounterView</code>, the <code class="literal">xib</code> file must be loaded. This is done by instantiating a <code class="literal">UINib</code> with a <code class="literal">nibName</code> and a <code class="literal">bundle</code>. The most appropriate place to do this is in the <code class="literal">viewDidLoad</code> method of the <code class="literal">SampleTable</code> class:</p><div><pre class="programlisting">class SampleTable: UITableViewController {
  override func viewDidLoad() {
    let xib = UINib(nibName:"CounterView", bundle:nil)
    // continued</pre></div><p class="calibre8">Once the <code class="literal">xib</code> is loaded, the view must be created. The <code class="literal">instantiateWithOwner</code> method allows the object(s) in the <code class="literal">xib</code> to be deserialized.</p><div><h3 class="title2"><a id="note40" class="calibre1"/>Note</h3><p class="calibre8">It is possible to store multiple objects in a <code class="literal">xib</code> file (for example, to define a separate view that is suitable for a small display device versus a big display device); but in general, a <code class="literal">xib</code> file only contains one view.</p></div><p class="calibre8">The owner<a id="id241" class="calibre1"/> is passed to the view so that any connections can be wired up to the File's Owner in the interface. This is typically either <code class="literal">self</code> or <code class="literal">nil</code> if there are no connections:</p><div><pre class="programlisting">    // continued from before
    let objects = xib.instantiateWithOwner(self, options:nil)
    // continued</pre></div><p class="calibre8">This returns an array of <code class="literal">AnyObject</code> instances, and so casting the first element to a <code class="literal">UIView</code> is a common step.</p><div><h3 class="title2"><a id="tip43" class="calibre1"/>Tip</h3><p class="calibre8">It is possible to use <code class="literal">objects[0]</code>, but this will cause a failure if the array is empty. Instead, use <code class="literal">objects.first</code> to get an optional value that contains the first element.</p></div><p class="calibre8">Using the <code class="literal">as?</code> cast, it is possible to convert the optional value to a more specific type, and from this, perform the assignment to the <code class="literal">tableHeaderView</code>:</p><div><pre class="programlisting">    // continued from before
    let counter = objects.first as? UIView
    tableView.tableHeaderView = counter
  }</pre></div><p class="calibre8">When this application is run in the simulator, the following header is seen at the top of the table:</p><div><img src="img/00078.jpeg" alt="Wiring a custom view class" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">One of the advantages of having a <code class="literal">xib</code> to represent the user interface is that it can be reused in many places with a single definition. For example, it is possible to use the same <code class="literal">xib</code> to instantiate another view for the footer of the table, as follows:</p><div><pre class="programlisting">tableView.tableFooterView = 
  xib.instantiateWithOwner(self,options:nil).first as? UIView</pre></div><p class="calibre8">When the application <a id="id242" class="calibre1"/>is run now, counters are created at the top and bottom of the table:</p><div><img src="img/00079.jpeg" alt="Wiring a custom view class" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec66" class="calibre1"/>Dealing with intrinsic size</h2></div></div></div><p class="calibre8">When a view is <a id="id243" class="calibre1"/>added into a view that is being managed with <strong class="calibre2">Auto Layout</strong>, its <em class="calibre11">intrinsic content size</em> is used. Unfortunately, views that are defined in <strong class="calibre2">Interface Builder</strong> have no way of setting their intrinsic size programmatically or specifying it in Interface Builder. <strong class="calibre2">Size Inspector</strong> allows this value to be changed, but as Xcode notes, this has no effect at runtime:</p><div><img src="img/00080.jpeg" alt="Dealing with intrinsic size" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">If a custom class is associated with the view, then an appropriate intrinsic size can be defined. Add a method to <code class="literal">CounterView</code> that overrides the <code class="literal">intrinsicContentSize</code> method and returns a <code class="literal">CGSize</code>, allows some <code class="literal">xib</code> customization, and returns the maximum of the label's intrinsic size and a value, such as <code class="literal">(300,50)</code>:</p><div><pre class="programlisting">override func intrinsicContentSize() -&gt; CGSize {
  let height = max(50,label.intrinsicContentSize().height)
  let width = max(300,label.intrinsicContentSize().width)
  return CGSize(width: width, height: height)
}</pre></div><p class="calibre8">Now when <a id="id244" class="calibre1"/>the view is added into a view that is managed by Auto Layout, it will have an appropriate initial size although it can grow larger.</p><div><h3 class="title2"><a id="note41" class="calibre1"/>Note</h3><p class="calibre8">The size should take into account the size of the various views that are contained inside, as well as any font sizes or themes, which might change the view. Using the label's <code class="literal">intrinsicSize</code> to calculate a maximum is a good idea.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec34" class="calibre1"/>Creating new views by subclassing UIView</h1></div></div></div><p class="calibre8">Although the <a id="id245" class="calibre1"/>
<code class="literal">xib</code> files offer a mechanism to customize classes, the majority of <code class="literal">UIKit</code> views outside of standard frameworks are implemented in custom code. This makes it easier to reason what the intrinsic size should be as well as to receive code patches and understand <code class="literal">diffs</code> from version control systems. The downside of this approach is when using Auto Layout, writing the constraints can be a challenge and the intrinsic sizes are often misreported or return the unknown value: <code class="literal">(-1,-1)</code>.</p><p class="calibre8">A custom view can be implemented as a subclass of <code class="literal">UIView</code>. Subclasses of <code class="literal">UIView</code> are expected to have two initializers, one that takes a <code class="literal">frame:CGRect</code> and one that takes a <code class="literal">coder:NSCoder</code>. The <code class="literal">frame</code> is generally used in code, and the <code class="literal">rect</code> specifies the position on screen (<code class="literal">0,0</code> is the top-left) along with the <code class="literal">width</code> and <code class="literal">height</code>. The <code class="literal">coder</code> is used when deserializing from a <code class="literal">xib</code> file.</p><p class="calibre8">To allow custom subclasses to either be used in Interface Builder or instantiated from code, it is good practice to ensure that both the initializers create the necessary views. This can be done using a third method called <code class="literal">setupView</code>, which is invoked from both.</p><p class="calibre8">Create a class called <code class="literal">TwoLabels</code> that has two labels in a view:</p><div><pre class="programlisting">import UIKit
class TwoLabels: UIView {
  var left:UILabel = UILabel()
  var right:UILabel = UILabel()
  required init?(coder:NSCoder) {
    super.init(coder:coder)
    setupView()
  }
  override init(frame:CGRect) {
    super.init(frame:frame)
    setupView()
  }
  // ...
}</pre></div><p class="calibre8">The <code class="literal">setupView</code> call will add the subviews to the view. Code that goes in here should be executed only once. There isn't a standard name, and often, example code will place the setup in one or other of the <code class="literal">init</code> methods instead.</p><p class="calibre8">It is <a id="id246" class="calibre1"/>conventional to have a separate method, such as <code class="literal">configureView</code>, to populate the UI with the current set of data. This can be called repeatedly based on the state of the system; for example, a field may be enabled or disabled based on some condition. This code should be repeatable so that it does not modify the view hierarchy:</p><div><pre class="programlisting">func setupView() {
  addSubview(left)
  addSubview(right)
  configureView()
}
func configureView() {
  left.text = "Left"
  right.text = "Right"
}</pre></div><p class="calibre8">In an explicitly sized environment (where the text label is being set and placed at a particular location), there is a <code class="literal">layoutSubviews</code> method that is called to request the view to be laid out correctly. However, there is a better way to do this, which is to use Auto Layout and constraints.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec67" class="calibre1"/>Auto Layout and custom views</h2></div></div></div><p class="calibre8">Auto Layout is covered in the <em class="calibre11">Using Auto Layout</em> section of <a class="calibre1" title="Chapter 4. Storyboard Applications with Swift and iOS" href="part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b">Chapter 4</a>, <em class="calibre11">Storyboard Applications with Swift and iOS</em>. When creating a user interface explicitly, views must be sized <a id="id247" class="calibre1"/>and managed appropriately. The easiest way to manage this is to use Auto Layout, which requires constraints to be added in order to set up the views.</p><p class="calibre8">Constraints can be added or updated in the <code class="literal">updateConstraints</code> method. This is called after <code class="literal">setNeedsUpdateConstraints</code> is called. Constraints may need to be updated if views become visible or the data is changed. Typically, this can be triggered by placing a call at the end of the <code class="literal">setupView</code> method, as follows:</p><div><pre class="programlisting">func setupView() {
  // addSubview etc
  setNeedsUpdateConstraints()
}</pre></div><p class="calibre8">The <code class="literal">updateConstraints</code> method needs to do several things. To prevent autoresizing masks being translated into constraints, each view needs to call <code class="literal">setTranslatesAutoresizingMaskIntoConstraints</code> with an argument of <code class="literal">false</code>.</p><div><h3 class="title2"><a id="tip44" class="calibre1"/>Tip</h3><p class="calibre8">To facilitate the transition between springs and struts (also known as autoresizing masks) and Auto Layouts, views can be configured to translate springs and struts into Auto Layout constraints. This is enabled by default for all views in order to provide backward compatibility for existing views, but it should be disabled when implementing Auto Layouts.</p></div><p class="calibre8">Either <a id="id248" class="calibre1"/>the constraints can be incrementally updated or the existing constraints can be removed. A <code class="literal">removeConstraints</code> method allows existing constraints to be removed first, as follows:</p><div><pre class="programlisting">override func updateConstraints() {
  translatesAutoresizingMaskIntoConstraints = false
  left.translatesAutoresizingMaskIntoConstraints = false
  right.translatesAutoresizingMaskIntoConstraints = false
  removeConstraints(constraints)
  // add constraints here
}</pre></div><p class="calibre8">Constraints can be added programmatically using the <code class="literal">NSLayoutConstraint</code> class. The constraints that are added in Interface Builder are also instances of the <code class="literal">NSLayoutConstraint</code> class.</p><p class="calibre8">Constraints are represented as an equation; properties of two objects are related as an equality (or inequality) of the following form:</p><div><pre class="programlisting">// object.property = otherObject.property * multiplier + constant</pre></div><p class="calibre8">To declare that both labels are of equal width, the following can be added to the <code class="literal">updateConstraints</code> method:</p><div><pre class="programlisting">// left.width = right.width * 1 + 0
let equalWidths = NSLayoutConstraint(
  item: left,
  attribute: .Width,
  relatedBy: .Equal,
  toItem: right,
  attribute: .Width,
  multiplier: 1,
  constant: 0)
addConstraint(equalWidths)</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec68" class="calibre1"/>Constraints and the visual format language</h2></div></div></div><p class="calibre8">Although <a id="id249" class="calibre1"/>adding individual constraints gives us ultimate flexibility, it can be tedious to set up programmatically. The <em class="calibre11">visual format language</em> can be used to add multiple constraints to a view. This is an ASCII-based representation that allows views to be related to each other in position and extrapolated into an array of constraints.</p><p class="calibre8">Constraints can be applied horizontally (the default) or vertically. The <code class="literal">|</code> character can be used to represent either the start or end of the containing superview, and <code class="literal">–</code> is used to represent the space that separates views, which are named in <code class="literal">[]</code> and referenced in a dictionary.</p><p class="calibre8">To constrain the<a id="id250" class="calibre1"/> two labels that are next to each other in the view, <code class="literal">H:|-[left]-[right]-|</code> can be used. This can be read as a horizontal (<code class="literal">H:</code>) with a gap from the left edge (<code class="literal">|-</code>) followed by the left view (<code class="literal">[left]</code>), a gap (<code class="literal">-</code>), a right view (<code class="literal">[right]</code>), and finally, a gap from the right edge (<code class="literal">-|</code>). Similarly, vertical constraints can be added with a <code class="literal">V:</code> prefix.</p><p class="calibre8">The <code class="literal">constraintsWithVisualFormat</code> method on the <code class="literal">NSLayoutConstraint</code> class can be used to parse visual format constraints. It takes a set of <code class="literal">options</code>, <code class="literal">metrics</code>, and a dictionary of <code class="literal">views</code> that are referenced in the visual format. An array of constraints is returned, which can be passed into the <code class="literal">addConstraints</code> method of the view.</p><p class="calibre8">To add constraints that ensure the <code class="literal">left</code> and <code class="literal">right</code> views have equal widths, a space between them, and a vertical space between the top of the view and the labels, the following code can be used:</p><div><pre class="programlisting">override func updateConstraints() {
  // …
  let options = NSLayoutFormatOptions()
  let namedViews = ["left":left,"right":right]
  addConstraints(NSLayoutConstraint.
    constraintsWithVisualFormat("H:|-[left]-[right]-|",
      options: options, metrics: nil, views: namedViews))
  addConstraints(NSLayoutConstraint.
    constraintsWithVisualFormat("V:|-[left]-|",
      options: options, metrics: nil, views: namedViews))
  addConstraints(NSLayoutConstraint.
    constraintsWithVisualFormat("V:|-[right]-|",
      options: options, metrics: nil, views: namedViews))
  super.updateConstraints()
}</pre></div><div><h3 class="title2"><a id="note42" class="calibre1"/>Note</h3><p class="calibre8">If there are ambiguous constraints, then an error will be printed to the console when the view is displayed. Messages that include the <code class="literal">NSAutoresizingMaskLayout</code> constraints indicate that the view has not disabled the automatic translation of the autoresizing mask into the constraints.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec69" class="calibre1"/>Adding the custom view to the table</h2></div></div></div><p class="calibre8">The <code class="literal">TwoLabels</code> view <a id="id251" class="calibre1"/>can be tested by adding it as a footer to the <code class="literal">SimpleTable</code> that was created previously. The footer is a special class, <code class="literal">UITableViewHeaderFooterView</code>, which needs to be created and added to <code class="literal">tableView</code>. The <code class="literal">TwoLabels</code> view can then be added to the footer's <code class="literal">contentView</code>:</p><div><pre class="programlisting">let footer = UITableViewHeaderFooterView()
footer.contentView.addSubview(TwoLabels(frame:CGRect.zero))
tableView.tableFooterView = footer</pre></div><p class="calibre8">Now when the application is run in the simulator, the custom view will be seen:</p><div><img src="img/00081.jpeg" alt="Adding the custom view to the table" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec35" class="calibre1"/>Custom graphics with drawRect</h1></div></div></div><p class="calibre8">Subclasses of <code class="literal">UIView</code> can<a id="id252" class="calibre1"/> implement their own custom graphics by providing a <strong class="calibre2">drawRect</strong> method<a id="id253" class="calibre1"/> that implements the custom drawing routines. The <code class="literal">drawRect</code> method takes a <code class="literal">CGRect</code> argument, which indicates the area to draw in. However, the actual drawing commands are performed on a <a id="id254" class="calibre1"/>Core Graphics context, which is represented by the <code class="literal">CGContext</code> class and can be obtained by a call to <code class="literal">UIGraphicsGetCurrentContext</code>.</p><p class="calibre8">The <a id="id255" class="calibre1"/>Core Graphics context represents a drawable area in iOS, and it is used to print as well as draw graphics. Each view has the responsibility to draw itself; the rectangle will either be the full area (for example, the first time that a view is drawn) or it may be a subset of the area (for example, when a dialog has been displayed and then subsequently removed).</p><p class="calibre8">
<em class="calibre11">Core Graphics</em> is a C-based interface (rather than Objective-C-based), so the API is exposed as a set of functions beginning with the <code class="literal">UIGraphics</code> prefix. As with other drawing APIs, the program can set the current drawing color, draw lines, set a fill color, fill rectangles, and so on.</p><p class="calibre8">To test this, create a class called <code class="literal">SquaresView</code> that is a subclass of <code class="literal">UIView</code> in a new Swift file.</p><p class="calibre8">All views have the standard <code class="literal">init</code> methods; delegate them to the superclass's implementation. Finally, create a <code class="literal">drawRect</code> method that takes a <code class="literal">CGRect</code>. This will be where the custom drawing occurs. The skeleton will look like the following:</p><div><pre class="programlisting">import UIKit
class SquaresView: UIView {
  required init?(coder: NSCoder) {
    super.init(coder:coder)
    setupView()
  }
  override init(frame: CGRect) {
    super.init(frame:frame)
    setupView()
  }
  func setupView() {
  }
  override func drawRect(rect: CGRect) {
    // drawing code goes here
  }
}</pre></div><p class="calibre8">Open the <code class="literal">Main.storyboard</code>, drag in another <code class="literal">UIViewController</code> and set the custom class of the view to <code class="literal">SquaresView</code> in <strong class="calibre2">Identity Inspector</strong>. Drag in a relationship segue between the tabbed view controller and the new view controller, and set the tab bar item to <code class="literal">Squares</code> which will allow testing to move to a different view. If the application is run, a blank view will be seen in the <strong class="calibre2">Squares</strong> tab.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec70" class="calibre1"/>Drawing graphics in drawRect</h2></div></div></div><p class="calibre8">To draw <a id="id256" class="calibre1"/>graphics in the view, it is necessary to acquire a <code class="literal">CGContext</code> and then set a drawing (stroke) color. A <code class="literal">UIColor</code> can be acquired and then converted into a <code class="literal">CGColor</code> to be able to set it on the graphics context.</p><p class="calibre8">Finally, a rectangle can be drawn with <code class="literal">CGContextStrokeRect</code>:</p><div><pre class="programlisting">override func drawRect(rect: CGRect) {
  let context = UIGraphicsGetCurrentContext()
  let red = UIColor.redColor().CGColor
  CGContextSetStrokeColorWithColor(context, red)
  CGContextStrokeRect(context, 
    CGRect(x:50, y:50, width:100, height:100))
}</pre></div><p class="calibre8">When this is run in the simulator, a red rectangle will be displayed on the <strong class="calibre2">Squares</strong> tab.</p><p class="calibre8">To draw a green square with a black outline in the middle requires a filled green square to be drawn first, followed by a black square afterwards. (Drawing them in the opposite order will result in the solid green square obliterating the black square.)</p><p class="calibre8">There are two different colors in a Core Graphics context: the <em class="calibre11">stroke color</em>, which is used to draw lines and paths, and the <em class="calibre11">fill color</em>, which is used when creating a filled path. Although the <code class="literal">CGContextSetFillColorWithColor</code> function exists, in Swift, there is an easier way of setting this directly with <code class="literal">UIColor</code> using the <code class="literal">setFill</code> or <code class="literal">setStroke</code> methods. The following code will create the green square with a black border:</p><div><pre class="programlisting">UIColor.greenColor().setFill()
UIColor.blackColor().setStroke()
CGContextFillRect(context,
  CGRect(x:75, y:75, width:50, height:50))
CGContextStrokeRect(context,
  CGRect(x:75, y:75, width:50, height:50))</pre></div><p class="calibre8">Now when the application is run, the following will be seen:</p><div><img src="img/00082.jpeg" alt="Drawing graphics in drawRect" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec71" class="calibre1"/>Responding to orientation changes</h2></div></div></div><p class="calibre8">When<a id="id257" class="calibre1"/> the screen rotates, the view is stretched and squashed, resulting in the square turning into a rectangle. The <code class="literal">drawRect</code> call is not called when the view changes orientation; the existing display is squashed and stretched automatically.</p><p class="calibre8">To prevent this, the <em class="calibre11">content mode</em> of the view can be changed. There is a <code class="literal">UIViewContentMode</code> enumeration that can be specified to cause different behaviors. Using <code class="literal">Redraw</code> will result in the <code class="literal">drawRect</code> being called when the orientation changes or when the bounds changes size.</p><div><h3 class="title2"><a id="note43" class="calibre1"/>Note</h3><p class="calibre8">The other <code class="literal">enum</code> values are documented in the <code class="literal">UIViewContentMode</code> type, and they include scaling options as well as being centered or attached to one of the edges or corners.</p></div><p class="calibre8">The squares can be centered on the screen; instead of starting at the position <code class="literal">50,50</code>, the view's <code class="literal">center</code> property can be accessed to find out what the position is. Modify the code as follows:</p><div><pre class="programlisting">func setupView() {
  <strong class="calibre2">contentMode = .Redraw</strong>
}
override func drawRect(rect: CGRect) {
  let context = UIGraphicsGetCurrentContext()
  let red = UIColor.redColor().CGColor
  CGContextSetStrokeColorWithColor(context,red)
  CGContextStrokeRect(context,
    CGRect(<strong class="calibre2">x:center.x-50, y:center.y-50</strong>, width:100, height:100))
  UIColor.greenColor().setFill()
  UIColor.blackColor().setStroke()
  CGContextFillRect(context,
    CGRect(<strong class="calibre2">x:center.x-25, y:center.y-25</strong>, width:50, height:50))
  CGContextStrokeRect(context,
    CGRect(<strong class="calibre2">x:center.x-25, y:center.y-25</strong>, width:50, height:50))
}</pre></div><p class="calibre8">Now when <a id="id258" class="calibre1"/>the application is run, the squares will be centered on the screen. If the screen rotates, <code class="literal">drawRect</code> will be invoked again and the display will be redrawn.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec36" class="calibre1"/>Custom graphics with layers</h1></div></div></div><p class="calibre8">Drawing<a id="id259" class="calibre1"/> graphics by overriding <code class="literal">drawRect</code> is not very performant because all the drawing routines are executed on the CPU. Offloading the graphics drawing to the GPU is both more performant and more power efficient.</p><p class="calibre8">iOS has a concept of layers, which are Core Graphics optimized drawing contents. Operations composed on a <em class="calibre11">layer</em>, including adding a <em class="calibre11">path</em>, can be translated into code that can execute on the GPU and be rendered efficiently. In addition, Core Animation can be used to animate changes on layers efficiently. <em class="calibre11">Core Animation</em> is provided in the <a id="id260" class="calibre1"/>
<strong class="calibre2">QuartzCore</strong> framework/module; the two terms are interchangeable. It is more generally known as Core Animation.</p><p class="calibre8">The download progress icon on iOS can be recreated as a <code class="literal">ProgressView</code> containing layers for the circular outline, a layer for the square stop button in the middle, and a layer for the progress arc. The final view will composite these three layers together to provide the finished view.</p><p class="calibre8">Every <code class="literal">UIView</code> has an implicit associated layer, which can have sublayers added to it. As with views, newly-added layers overlay existing layers. There are several <a id="id261" class="calibre1"/>
<strong class="calibre2">core animation layer</strong> classes that can be used, which are subclasses of <code class="literal">CALayer</code>, and they are as follows:</p><div><ul class="itemizedlist"><li class="listitem">The <a id="id262" class="calibre1"/><code class="literal">CAEAGLLayer</code> class provides a way to embed OpenGL content into a view</li><li class="listitem">The <code class="literal">CAEmitterLayer</code> class <a id="id263" class="calibre1"/>provides a mechanism to generate emitter effects, such as smoke and fire</li><li class="listitem">The <code class="literal">CAGradientLayer</code> class<a id="id264" class="calibre1"/> provides a way to create a background with a gradient color</li><li class="listitem">The <a id="id265" class="calibre1"/><code class="literal">CAReplicatorLayer</code> class provides a means to replicate the existing layers with different transformations, which allows effects, such as reflections and coverflow, to be displayed</li><li class="listitem">The <a id="id266" class="calibre1"/><code class="literal">CAScrollLayer</code> class provides a way to perform scrolling</li><li class="listitem">The <a id="id267" class="calibre1"/><code class="literal">CAShapeLayer</code> class provides a means to draw and animate a single path</li><li class="listitem">The <a id="id268" class="calibre1"/><code class="literal">CATextLayer</code> class allows text to be displayed</li><li class="listitem">The <a id="id269" class="calibre1"/><code class="literal">CATiledLayer</code> class provides a means to generate tiled content at different zoom levels, such as a map</li><li class="listitem">The <a id="id270" class="calibre1"/><code class="literal">CATransformLayer</code> class provides a means to transform layers into 3D views, such as a coverflow style image animation</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec72" class="calibre1"/>Creating a ProgressView from layers</h2></div></div></div><p class="calibre8">Create <a id="id271" class="calibre1"/>another view class called <code class="literal">ProgressView</code> which extends <code class="literal">UIView</code>. Set it up with the default <code class="literal">init</code> methods, a <code class="literal">setupView</code>, and a <code class="literal">configureView</code> method:</p><div><pre class="programlisting">import UIKit
class ProgressView: UIView {
  required init?(coder: NSCoder) {
    super.init(coder:coder)
    setupView()
  }
  override init(frame: CGRect) {
    super.init(frame:frame)
    setupView()
  }
  func setupView() {
    configureView()
  }
  func configureView() {
  }
}</pre></div><p class="calibre8">Create a new <code class="literal">Layers</code> <code class="literal">Scene</code> in the <code class="literal">Main.storyboard</code> by dragging a <code class="literal">UIViewController</code> from the object library onto the storyboard. Connect it to the tab-bar controller by dragging a relationship segue to the newly created layers view controller. Add the <code class="literal">ProgressView</code> by dragging a <strong class="calibre2">View</strong> from the object library and giving it a <strong class="calibre2">Custom Class</strong> of <code class="literal">ProgressView</code>. Size it with an approximate location of the middle of the screen.</p><p class="calibre8">Now add <a id="id272" class="calibre1"/>an instance variable to the <code class="literal">ProgressView</code> class called <code class="literal">circle</code> and create a new instance of <code class="literal">CAShapeLayer</code>. In <code class="literal">setupView</code>, set <code class="literal">strokeColor</code> as <code class="literal">black</code> and <code class="literal">fillColor</code> as <code class="literal">nil</code>. Finally, add the <code class="literal">circle</code> layer to the view's layer so that it is displayed:</p><div><pre class="programlisting">let circle = CAShapeLayer()
func setupView() {
  circle.strokeColor = UIColor.blackColor().CGColor
  circle.fillColor = nil
  self.layer.addSublayer(circle)
  configureView()
}</pre></div><p class="calibre8">
<code class="literal">CAShapeLayer</code> has a <code class="literal">path</code> property, which is used to perform all the drawing. The easiest way to use this is to create a <code class="literal">UIBezierPath</code> and then use the <code class="literal">CGPath</code> accessor to convert it to a <code class="literal">CGPath</code>.</p><div><h3 class="title2"><a id="note44" class="calibre1"/>Note</h3><p class="calibre8">A <em class="calibre11">bezier curve</em> is a way of representing a smooth curve between two points and one or more additional control points. These can be scaled accurately and are easy to compute in a graphics card. A <code class="literal">UIBezierPath</code> provides a way to represent one or several bezier paths together, resulting in smooth and efficient curve generation.</p></div><p class="calibre8">Unlike the <code class="literal">UIGraphics*</code> methods, there are no separate <code class="literal">draw*</code> and <code class="literal">fill*</code> operations; instead, either the <code class="literal">fillColor</code> or <code class="literal">strokeColor</code> is set and then the path is filled or stroked (drawn). The <code class="literal">UIBezierPath</code> can be constructed by adding segments, but there are several initializers that can be used to draw specific shapes. For example, circles can be drawn with the <code class="literal">ovalInRect</code> initializer:</p><div><pre class="programlisting">func configureView() {
  let rect = self.bounds
  circle.path = UIBezierPath(ovalInRect: rect).CGPath
}</pre></div><p class="calibre8">Now when the application is run, a small black circle will be seen on the <strong class="calibre2">Layers</strong> tab:</p><div><img src="img/00083.jpeg" alt="Creating a ProgressView from layers" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec73" class="calibre1"/>Adding the stop square</h2></div></div></div><p class="calibre8">The<a id="id273" class="calibre1"/> stop square can be added by creating another layer. This will allow the stop button to be turned on or off as necessary. (For example, during a download, the stop button can be displayed, and when the download is completed, it can be animated away.)</p><p class="calibre8">Add a new constant called <code class="literal">square</code> of type <code class="literal">CAShapeLayer</code>. It will help to create a constant, <code class="literal">black</code>, as it will be used again elsewhere in this class:</p><div><pre class="programlisting">class ProgressView: UIView {
  let square = CAShapeLayer()
  let circle = CAShapeLayer()
  let black = UIColor.blackColor().CGColor
}</pre></div><p class="calibre8">The <code class="literal">setupView</code> method can now be updated to deal with additional layers. As it is common to set them up in the same way, using a loop is a quick way to set up multiple layers, as follows:</p><div><pre class="programlisting">func setupView() {
  for layer in [square, circle] {
    layer.strokeColor = black
    layer.fillColor = nil
    self.layer.addSublayer(layer)
  }
  configureView()
}</pre></div><p class="calibre8">The path for the <code class="literal">square</code> can be created using the <code class="literal">rect</code> initializer of <code class="literal">UIBezierPath</code>. To create a rectangle that will be centered inside the circle, use the <code class="literal">insetBy</code> method with an appropriate value:</p><div><pre class="programlisting">func configureView() {
  let rect = self.bounds
  let sq = rect.insetBy(dx: rect.width/3, dy: rect.height/3)
  square.fillColor = black
  square.path = UIBezierPath(rect: sq).CGPath
  circle.path = UIBezierPath(ovalInRect: rect).CGPath
}</pre></div><p class="calibre8">Now when<a id="id274" class="calibre1"/> the application is run, the following will be seen:</p><div><img src="img/00084.jpeg" alt="Adding the stop square" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec74" class="calibre1"/>Adding a progress bar</h2></div></div></div><p class="calibre8">The<a id="id275" class="calibre1"/> progress bar can be drawn as an arc representing the amount of data that has downloaded so far. On other iOS applications, the progress bar starts at the 12 o'clock position and then moves clockwise.</p><p class="calibre8">There are two ways to achieve this: using an arc that is drawn up to some particular amount, or by setting a single path that represents the entire circle and then using <code class="literal">strokeStart</code> and <code class="literal">strokeEnd</code> to define which segment of the path should be drawn. The advantage of using <code class="literal">strokeStart</code> and <code class="literal">strokeEnd</code> is that they are <em class="calibre11">animatable properties</em>, which allow some animated effects.</p><p class="calibre8">The arc needs to be drawn from the top, moved clockwise to the right, and then back up again. The <code class="literal">strokeStart</code> and <code class="literal">strokeEnd</code> are <code class="literal">CGFloat</code> values between 0 and 1, so they can be used to represent the progress of the download.</p><div><h3 class="title2"><a id="tip45" class="calibre1"/>Tip</h3><p class="calibre8">
<strong class="calibre2">Easy as Pi</strong>
</p><p class="calibre8">Although circles are often split into 360 degrees (mainly because 360 has a lot of factors and is easily divisible into different numbers), computers tend to work in <em class="calibre11">radians</em>. There are <code class="literal">2pi</code> radians in a circle; so half a circle is <code class="literal">pi</code>, and a quarter of a circle is <code class="literal">pi/2</code>.</p></div><p class="calibre8">There is a <code class="literal">UIBezierPath</code> convenience initializer that can draw an arc; the <code class="literal">center</code> and <code class="literal">radius</code> are specified along with a <code class="literal">startAngle</code> and <code class="literal">endAngle</code> point. The start and end points are both<a id="id276" class="calibre1"/> specified in radians, with 0 being the 3 o' clock position and going clockwise or anticlockwise as specified:</p><div><img src="img/00085.jpeg" alt="Adding a progress bar" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">To draw progress starting from the top of the circle, the start point must be specified as <code class="literal">-pi/2</code>. Drawing clockwise from here around the complete circle takes it to <code class="literal">-pi/2</code> <code class="literal">+</code> <code class="literal">2pi</code>, which is <code class="literal">3</code> <code class="literal">*</code> <code class="literal">pi/2</code>.</p><div><h3 class="title2"><a id="tip46" class="calibre1"/>Tip</h3><p class="calibre8">Computers use pi a lot, defined in <code class="literal">usr/include/math.h</code>, which is included transitively from <code class="literal">UIKit</code> through the <code class="literal">Darwin</code> module. The constants: <code class="literal">M_PI</code>, <code class="literal">M_PI_2</code> (pi/2), and <code class="literal">M_PI_4</code> (pi/4), and the inverses: <code class="literal">M_1_PI</code> (1/pi), and <code class="literal">M_2_PI</code> (2/pi), are available.</p></div><p class="calibre8">The middle of the diagram can be calculated by accessing <code class="literal">self.center</code>, and the <code class="literal">radius</code> of the circle will be half the minimum <code class="literal">width</code> or <code class="literal">height</code>. To add the path, create a new <code class="literal">CAShapeLayer</code> called <code class="literal">progress</code>, add it into the layers array, and optionally give it a different <code class="literal">width</code> and <code class="literal">color</code> to distinguish it from the background:</p><div><pre class="programlisting">class ProgressView: UIView {
  let progress = CAShapeLayer()
  var progressAmount: CGFloat = 0.5
  …
  func setupView() {
    for layer in [progress, square, circle] {
      …
    }
    progress.lineWidth = 10
    progress.strokeColor = UIColor.redColor().CGColor
    configureView()
  }
  func configureView() {
    …
    let radius = min(rect.width, rect.height) / 2
    let center = CGPoint(x:rect.midX, y:rect.midY)
    progress.path = UIBezierPath(
      arcCenter: center,
      radius: radius,
      startAngle: CGFloat(-M_PI_2),
      endAngle: CGFloat(3*M_PI_2),
      clockwise: true
    ).CGPath
    progress.strokeStart = 0
    progress.strokeEnd = progressAmount
  }
}</pre></div><p class="calibre8">When<a id="id277" class="calibre1"/> this is run, the progress bar will be seen behind the circle:</p><div><img src="img/00086.jpeg" alt="Adding a progress bar" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec75" class="calibre1"/>Clipping the view</h2></div></div></div><p class="calibre8">The problem <a id="id278" class="calibre1"/>with the progress line is that it extends beyond the circular boundary of the progress view. A simple approach may be to try and calculate a half-width distance from the radius and redraw the circle, but this is fragile as changes to the line width may result in the diagram not looking right in the future.</p><p class="calibre8">A better approach is to <em class="calibre11">mask</em> the graphics area so that the drawing does not go outside a particular shape. By specifying a mask, any drawing that occurs within the mask is displayed; graphics that are drawn outside the mask are not displayed.</p><p class="calibre8">A mask can be defined as a rectangular area or the result of a filled layer. Creating a circular mask requires creating a new mask layer and then setting a circular path as we did before.</p><div><h3 class="title2"><a id="note45" class="calibre1"/>Note</h3><p class="calibre8">A mask can only be used by a single layer. If the same mask is needed for more than one layer, either the mask layer needs to be copied or the mask can be set on a common parent layer.</p></div><p class="calibre8">Create a new <code class="literal">CAShapeLayer</code> that can be used for the <code class="literal">mask</code>, and create a <code class="literal">path</code> that is based on the <code class="literal">UIBezierPath</code> with an <code class="literal">ovalInRect</code>. The <code class="literal">mask</code> can then be assigned to the <code class="literal">mask</code> layer of the <code class="literal">progress</code> layer:</p><div><pre class="programlisting">class ProgressView: UIView {
  let mask = CAShapeLayer()
  func configureView() {
    … 
    mask.path = UIBezierPath(ovalInRect:rect).CGPath
    progress.mask = mask
  }
}</pre></div><p class="calibre8">Now when<a id="id279" class="calibre1"/> the display is shown, the progress bar does not bleed over the edge:</p><div><img src="img/00087.jpeg" alt="Clipping the view" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec76" class="calibre1"/>Testing views in Xcode</h2></div></div></div><p class="calibre8">To<a id="id280" class="calibre1"/> test the view in Interface Builder directly, the class can be marked as <code class="literal">@IBDesignable</code>. This gives permission for Xcode to instantiate and run the view as well as update it for any changes that are made. If the class is marked as <code class="literal">@IBDesignable</code>, then Xcode will attempt to load the view and display it in storyboard and <code class="literal">xib</code> files.</p><p class="calibre8">However, when the class loads, the UI will not be displayed properly, because the frame size needs to be initialized correctly. Override the <code class="literal">layoutSubviews</code> method to call <code class="literal">configureView</code>, which ensures that the view is properly redrawn when the view changes size or is displayed for the first time:</p><div><pre class="programlisting">@IBDesignable class ProgressView: UIView {
  … 
  override func layoutSubviews() {
    setupView()
  }
}</pre></div><p class="calibre8">Now when the <code class="literal">ProgressView</code> is added or displayed in Interface Builder, it will be rendered in place. Build the project, then open the <code class="literal">Main.storyboard</code>, and click on the <strong class="calibre2">Progress View</strong>; after a brief delay, it will be drawn.</p><p class="calibre8">Xcode can also be used to edit different attributes of an object in Interface Builder. This allows the view to be tested without running the application.</p><p class="calibre8">To allow Interface Builder to edit properties, they can be marked as <code class="literal">@IBInspectable</code>:</p><div><pre class="programlisting">@IBDesignable class ProgressView: UIView {
  @IBInspectable var progressAmount: CGFloat = 0.5 
  …
}</pre></div><p class="calibre8">After building<a id="id281" class="calibre1"/> the project, open the storyboard, select <strong class="calibre2">Progress View</strong> and go to <strong class="calibre2">Attributes Inspector</strong>. Just above the <strong class="calibre2">View</strong> section will be a <strong class="calibre2">Progress View</strong> section with the <strong class="calibre2">Progress Amount</strong> field that is based on the <code class="literal">@IBInspectable</code> field of the same name:</p><div><img src="img/00088.jpeg" alt="Testing views in Xcode" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec77" class="calibre1"/>Responding to change</h2></div></div></div><p class="calibre8">If <code class="literal">UISlider</code> is <a id="id282" class="calibre1"/>added to <strong class="calibre2">Layers View</strong>, changes can be triggered by adding <code class="literal">@IBAction</code> to allow the <code class="literal">valueChanged</code> event to propagate the value to the caller.</p><p class="calibre8">Create an <code class="literal">@IBAction</code> function, <code class="literal">setProgress</code>, which takes a sender and then, depending on the type of that sender, extracts a value:</p><div><pre class="programlisting">@IBAction func setProgress(sender:AnyObject) {
  switch sender {
    case let slider as UISlider: progressAmount =
      CGFloat(slider.value)
    case let stepper as UIStepper: progressAmount = 
      CGFloat(stepper.value)
    default: break
  }
}</pre></div><div><h3 class="title2"><a id="tip47" class="calibre1"/>Tip</h3><p class="calibre8">Using a <code class="literal">switch</code> statement that is based on the type allows additional views to be added in the future.</p></div><p class="calibre8">The <code class="literal">valueChanged</code> event on <code class="literal">UISlider</code> can now be connected to <code class="literal">setProgess</code> on <code class="literal">ProgressView</code>.</p><p class="calibre8">Assigning the <code class="literal">progressAmount</code> value alone has no visible effect, so a property observer can be used to<a id="id283" class="calibre1"/> trigger display changes whenever the field is modified. A <em class="calibre11">property observer</em> is a block of code that gets called before (<code class="literal">willSet</code>) or after (<code class="literal">didSet</code>) a property is changed:</p><div><pre class="programlisting">@IBInspectable var progressAmount: CGFloat = 0.5 {
  didSet {
    setNeedsLayout()
  }
}</pre></div><p class="calibre8">Now when the application is run and the slider value is moved, the download amount will be updated in the view:</p><div><img src="img/00089.jpeg" alt="Responding to change" class="calibre9"/></div><p class="calibre10"> </p><div><h3 class="title2"><a id="tip48" class="calibre1"/>Tip</h3><p class="calibre8">If the image doesn't update when the slider changes value, check that <code class="literal">didSet</code> on <code class="literal">progressAmount</code> triggers a <code class="literal">setNeedsLayout</code> call, and that the <code class="literal">layoutSubviews</code> function correctly calls <code class="literal">configureView</code>.</p></div><p class="calibre8">Observe that the changes to <code class="literal">progressAmount</code> are animated automatically, so if the slider is quickly moved from one end to the other the download arc will smoothly animate.</p><div><h3 class="title2"><a id="tip49" class="calibre1"/>Tip</h3><p class="calibre8">The property observer uses <code class="literal">setNeedsLayout</code> to trigger a call to <code class="literal">layoutSubviews</code> in order to achieve the change in display. As changes only need to be picked up when a size change occurs or when a property is changed, this is more efficient than implementing other methods, such as <code class="literal">drawRect</code>, which will be called every time the display needs to be updated.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec37" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we looked at several different ways to create views in iOS. The first approach was to use Interface Builder to build the view graphically and analyze some of the problems that this can cause. We then looked at subclassing <code class="literal">UIView</code> and adding other views to build up a custom view. Finally, we presented two different ways of drawing custom graphics; first with <code class="literal">drawRect</code>, and subsequently, with layers. The next chapter will show you how to use networking APIs in iOS to download networked data.</p></div></body></html>