["```kt\nclass VeryBasic\n```", "```kt\nfun main(args: Array<String>) {\n    val basic: VeryBasic = VeryBasic()\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val basic = VeryBasic()\n}\n```", "```kt\nclass BlueberryCupcake {\n  var flavour = \"Blueberry\"\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val myCupcake = BlueberryCupcake()\n    println(\"My cupcake has ${myCupcake.flavour}\")\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val myCupcake = BlueberryCupcake()\n    myCupcake.flavour = \"Almond\"\n    println(\"My cupcake has ${myCupcake.flavour}\")\n}\n```", "```kt\nclass BlueberryCupcake {\n    val flavour = \"Blueberry\"\n}\n\nfun main(args: Array<String>) {\n    val myCupcake = BlueberryCupcake()\n    myCupcake.flavour = \"Almond\" //Compilation error: Val cannot be reassigned\n    println(\"My cupcake has ${myCupcake.flavour}\")\n}\n```", "```kt\nclass AlmondCupcake {\n    val flavour = \"Almond\"\n}\n\nfun main(args: Array<String>) {\n    val mySecondCupcake = AlmondCupcake()\n    println(\"My second cupcake has ${mySecondCupcake.flavour} flavour\")\n}\n```", "```kt\nclass Cupcake(flavour: String) { \n  val flavour = flavour\n}\n```", "```kt\nclass Cupcake(val flavour: String)\n```", "```kt\nfun main(args: Array<String>) {\n    val myBlueberryCupcake = Cupcake(\"Blueberry\")\n    val myAlmondCupcake = Cupcake(\"Almond\")\n    val myCheeseCupcake = Cupcake(\"Cheese\")\n    val myCaramelCupcake = Cupcake(\"Caramel\")\n}\n```", "```kt\nclass Cupcake(val flavour: String) {\n  fun eat(): String {\n    return \"nom, nom, nom... delicious $flavour cupcake\"\n  }\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val myBlueberryCupcake = Cupcake(\"Blueberry\")\n    println(myBlueberryCupcake.eat())\n}\n```", "```kt\nclass Biscuit(val flavour: String) { \n  fun eat(): String { \n    return \"nom, nom, nom... delicious $flavour biscuit\" \n  } \n}\n```", "```kt\nopen class BakeryGood(val flavour: String) { \n  fun eat(): String { \n    return \"nom, nom, nom... delicious $flavour bakery good\" \n  } \n} \n\nclass Cupcake(flavour: String): BakeryGood(flavour) \nclass Biscuit(flavour: String): BakeryGood(flavour)\n```", "```kt\nfun main(args: Array<String>) {\n    val myBlueberryCupcake: BakeryGood = Cupcake(\"Blueberry\")\n    println(myBlueberryCupcake.eat())\n}\n```", "```kt\nopen class BakeryGood(val flavour: String) { \n  fun eat(): String { \n    return \"nom, nom, nom... delicious $flavour ${name()}\" \n  } \n\n  open fun name(): String { \n    return \"bakery good\" \n  } \n} \n\nclass Cupcake(flavour: String): BakeryGood(flavour) { \n  override fun name(): String { \n    return \"cupcake\" \n  } \n} \n\nclass Biscuit(flavour: String): BakeryGood(flavour) { \n  override fun name(): String { \n    return \"biscuit\" \n  } \n}\n```", "```kt\nopen class Roll(flavour: String): BakeryGood(flavour) { \n  override fun name(): String { \n    return \"roll\" \n  } \n} \n\nclass CinnamonRoll: Roll(\"Cinnamon\")\n```", "```kt\nopen class Donut(flavour: String, val topping: String) : BakeryGood(flavour)\n{\n    override fun name(): String {\n        return \"donut with $topping topping\"\n    }\n}\n\nfun main(args: Array<String>) {\n    val myDonut = Donut(\"Custard\", \"Powdered sugar\")\n    println(myDonut.eat())\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val anyGood = BakeryGood(\"Generic flavour\")\n}\n```", "```kt\nabstract class BakeryGood(val flavour: String) { \n  fun eat(): String { \n    return \"nom, nom, nom... delicious $flavour ${name()}\" \n  }\n\n  open fun name(): String { \n    return \"bakery good\" \n  } \n}\n```", "```kt\nabstract class BakeryGood(val flavour: String) { \n  fun eat(): String { \n    return \"nom, nom, nom... delicious $flavour ${name()}\" \n  } \n\n  abstract fun name(): String \n}\n```", "```kt\nclass Customer(val name: String) {\n  fun eats(food: BakeryGood) {\n    println(\"$name is eating... ${food.eat()}\")\n  }\n}\n\nfun main(args: Array<String>) {\n    val myDonut = Donut(\"Custard\", \"Powdered sugar\")\n    val mario = Customer(\"Mario\")\n    mario.eats(myDonut)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val mario = Customer(\"Mario\")\n\n    mario.eats(object : BakeryGood(\"TEST_1\") {\n        override fun name(): String {\n            return \"TEST_2\"\n        }\n    })\n}\n```", "```kt\nval food: BakeryGood = object : BakeryGood(\"TEST_1\") { \n  override fun name(): String { \n    return \"TEST_2\" \n  } \n} \n\nmario.eats(food)\n```", "```kt\nabstract class BakeryGood(val flavour: String) { \n  fun eat(): String { \n    return \"nom, nom, nom... delicious $flavour ${name()}\" \n  } \n\n  fun bake(): String { \n    return \"is hot here, isn't??\" \n  } \n\n  abstract fun name(): String \n}\n```", "```kt\nabstract class Bakeable { \n  fun bake(): String { \n    return \"is hot here, isn't??\" \n  } \n} \n\nclass Cupcake(flavour: String) : BakeryGood(flavour), Bakeable() { //Compilation error: Only one class may appear in a supertype list \n  override fun name(): String { \n    return \"cupcake\" \n  } \n}\n```", "```kt\ninterface Bakeable { \n  fun bake(): String { \n    return \"is hot here, isn't??\" \n  } \n} \n\nclass Cupcake(flavour: String) : BakeryGood(flavour), Bakeable { \n  override fun name(): String { \n    return \"cupcake\" \n  } \n}\n```", "```kt\ninterface Fried { \n  fun fry(): String \n} \n\nopen class Donut(flavour: String, val topping: String) : BakeryGood(flavour), Fried { \n  override fun fry(): String { \n    return \"*swimming on oil*\" \n  } \n\n  override fun name(): String { \n    return \"donut with $topping topping\" \n  } \n}\n```", "```kt\nabstract class BakeryGood(val flavour: String) {\n  init { \n    println(\"Preparing a new bakery good\") \n  } \n\n  fun eat(): String { \n    return \"nom, nom, nom... delicious $flavour ${name()}\" \n  } \n\n  abstract fun name(): String \n}\n```", "```kt\nval somethingFried = object : Fried { \n  override fun fry(): String { \n    return \"TEST_3\" \n  } \n}\n```", "```kt\nfun main(args: Array<String>) {\n    val expression = object {\n        val property = \"\"\n\n        fun method(): Int {\n            println(\"from an object expressions\")\n            return 42\n        }\n    }\n\n    val i = \"${expression.method()} ${expression.property}\"\n    println(i)\n}\n```", "```kt\nclass Outer {\n    val internal = object {\n        val property = \"\"\n    }\n}\n\nfun main(args: Array<String>) {\n    val outer = Outer()\n\n    println(outer.internal.property) // Compilation error: Unresolved reference: property\n}\n```", "```kt\nobject Oven {\n  fun process(product: Bakeable) {\n    println(product.bake())\n  }\n}\n\nfun main(args: Array<String>) {\n    val myAlmondCupcake = Cupcake(\"Almond\")\n    Oven.process(myAlmondCupcake)\n}\n```", "```kt\ninterface Oven {\n  fun process(product: Bakeable)\n}\n\nobject ElectricOven: Oven {\n  override fun process(product: Bakeable) {\n    println(product.bake())\n  }\n}\n\nfun main(args: Array<String>) {\n    val myAlmondCupcake = Cupcake(\"Almond\")\n    ElectricOven.process(myAlmondCupcake)\n}\n```", "```kt\nclass Cupcake(flavour: String) : BakeryGood(flavour), Bakeable {\n  override fun name(): String { \n    return \"cupcake\" \n  } \n\n  companion object { \n    fun almond(): Cupcake { \n      return Cupcake(\"almond\") \n    } \n\n    fun cheese(): Cupcake { \n      return Cupcake(\"cheese\") \n    } \n  } \n}\n```", "```kt\nfun main(args: Array<String>) {\n    val myBlueberryCupcake: BakeryGood = Cupcake(\"Blueberry\")\n    val myAlmondCupcake = Cupcake.almond()\n    val myCheeseCupcake = Cupcake.cheese()\n    val myCaramelCupcake = Cupcake(\"Caramel\")\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val myAlmondCupcake = Cupcake.almond()\n    val myCheeseCupcake = myAlmondCupcake.cheese() //Compilation error: Unresolved reference: cheese\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val factory: Cupcake.Companion = Cupcake.Companion\n}\n```", "```kt\nclass Cupcake(flavour: String) : BakeryGood(flavour), Bakeable {\n    override fun name(): String {\n        return \"cupcake\"\n    }\n\n    companion object Factory {\n        fun almond(): Cupcake {\n            return Cupcake(\"almond\")\n        }\n\n        fun cheese(): Cupcake {\n            return Cupcake(\"cheese\")\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val factory: Cupcake.Factory = Cupcake.Factory\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val factory: Cupcake.Factory = Cupcake\n}\n```", "```kt\ninterface Oven {\n  fun process(product: Bakeable)\n}\n```", "```kt\ninterface Machine<T> {\n  fun process(product: T)\n}\n```", "```kt\ninterface Oven: Machine<Bakeable>\n```", "```kt\ntypealias Oven = Machine<Bakeable>\n```", "```kt\ntypealias Flavour = String\n\nabstract class BakeryGood(val flavour: Flavour) {\n```", "```kt\ntypealias OvenTray = List<Bakeable>\n```", "```kt\ntypealias CupcakeFactory = Cupcake.Companion\n```", "```kt\nfun main(args: Array<String>) {\n    val myBlueberryCupcake: Cupcake = null //Compilation error: Null can not be a value of a non-null type Cupcake\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val myBlueberryCupcake: Cupcake? = null\n}\n```", "```kt\nfun eat(cupcake: Cupcake?){\n//  something happens here    \n}\n\nfun main(args: Array<String>) {\n    val myAlmondCupcake = Cupcake.almond()\n\n    eat(myAlmondCupcake)\n\n    eat(null)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val cupcake: Cupcake = Cupcake.almond()\n    val nullabeCupcake: Cupcake? = Cupcake.almond()\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val cupcake: Cupcake = Cupcake.almond()\n    val nullableCupcake: Cupcake? = Cupcake.almond()\n\n    cupcake.eat() // Happy days\n    nullableCupcake.eat() //Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type Cupcake?\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val nullableCupcake: Cupcake? = Cupcake.almond()\n\n    if (nullableCupcake != null) {\n      nullableCupcake.eat()\n    }\n}\n```", "```kt\nif (nullableCupcake is Cupcake) {\n  nullableCupcake.eat()\n}\n```", "```kt\nwhen (nullableCupcake) {\n  is Cupcake -> nullableCupcake.eat()\n}\n```", "```kt\nnullableCupcake?.eat()\n```", "```kt\nval result: String? = nullableCupcake?.eat()\n```", "```kt\nval length: Int? = nullableCupcake?.eat()?.length\n```", "```kt\nval result2: String = nullableCupcake?.eat() ?: \"\"\n```", "```kt\nval length2: Int = nullableCupcake?.eat()?.length ?: 0\n```", "```kt\nval result: String = nullableCupcake!!.eat()\n```", "```kt\nval result: String = nullableCupcake!!.eat()\n\nval length: Int = nullableCupcake.eat().length\n```", "```kt\nfun main(args: Array<String>) {\n\n    val myAlmondCupcake = Cupcake.almond()\n\n    val anyMachine = object : Machine<Any> {\n      override fun process(product: Any) {\n        println(product.toString())\n      }\n    }\n\n    anyMachine.process(3)\n\n    anyMachine.process(\"\")\n\n    anyMachine.process(myAlmondCupcake)    \n}\n```", "```kt\nfun main(args: Array<String>) {\n\n    val anyMachine = object : Machine<Any> {\n      override fun process(product: Any) {\n        println(product.toString())\n      }\n    }\n\n    val nullableCupcake: Cupcake? = Cupcake.almond()\n\n    anyMachine.process(nullableCupcake) //Error:(32, 24) Kotlin: Type mismatch: inferred type is Cupcake? but Any was expected\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val nullableCupcake: Cupcake? = Cupcake.almond()\n\n    val length = nullableCupcake?.eat()?.length ?: \"\"\n}\n```", "```kt\nval length = nullableCupcake?.eat()?.length ?: 0.0\n```", "```kt\nval length: Number = nullableCupcake?.eat()?.length ?: 0.0\n```", "```kt\nanyMachine.process(Unit)\n```", "```kt\nval result: String = nullableCupcake?.eat() ?: throw RuntimeException() // equivalent to nullableCupcake!!.eat()\n```", "```kt\nval x: Nothing? = null\n\nval nullsList: List<Nothing?> = listOf(null)\n```", "```kt\ndata class Item(val product: BakeryGood,\n  val unitPrice: Double,\n  val quantity: Int)\n```", "```kt\nval myItem = Item(myAlmondCupcake, 0.40, 5)\n\nval mySecondItem = myItem.copy(product = myCaramelCupcake) //named parameter\n```", "```kt\nval (prod: BakeryGood, price: Double, qty: Int) = mySecondItem\n```", "```kt\nval (prod, price, qty) = mySecondItem\n```", "```kt\nval (prod, _, qty) = mySecondItem\n```", "```kt\nannotation class Tasty\n```", "```kt\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Tasty\n```", "```kt\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Tasty(val tasty:Boolean = true)\n\n@Tasty(false)\nobject ElectricOven : Oven {\n  override fun process(product: Bakeable) {\n    println(product.bake())\n  }\n}\n\n@Tasty\nclass CinnamonRoll : Roll(\"Cinnamon\")\n\n@Tasty\ninterface Fried {\n  fun fry(): String\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val annotations: List<Annotation> = ElectricOven::class.annotations\n\n    for (annotation in annotations) {\n        when (annotation) {\n            is Tasty -> println(\"Is it tasty? ${annotation.tasty}\")\n            else -> println(annotation)\n        }\n    }\n}\n```", "```kt\nenum class Flour {\n  WHEAT, CORN, CASSAVA\n}\n```", "```kt\ninterface Exotic {\n  fun isExotic(): Boolean\n}\n\nenum class Flour : Exotic {\n  WHEAT {\n    override fun isExotic(): Boolean {\n      return false \n    }\n  },\n\n  CORN {\n    override fun isExotic(): Boolean {\n      return false\n    }\n  },\n\n  CASSAVA {\n    override fun isExotic(): Boolean {\n      return true\n    }\n  }\n}\n```", "```kt\nenum class Flour: Exotic {\n  WHEAT {\n    override fun isGlutenFree(): Boolean {\n      return false\n    }\n\n    override fun isExotic(): Boolean {\n      return false\n    }\n  },\n\n  CORN {\n    override fun isGlutenFree(): Boolean {\n      return true\n    }\n\n    override fun isExotic(): Boolean {\n      return false\n    }\n  },\n\n  CASSAVA {\n    override fun isGlutenFree(): Boolean {\n      return true\n    }\n\n    override fun isExotic(): Boolean {\n      return true\n    }\n  };\n\n  abstract fun isGlutenFree(): Boolean\n}\n```", "```kt\nfun flourDescription(flour: Flour): String {\n  return when(flour) { // error\n    Flour.CASSAVA -> \"A very exotic flavour\"\n  }\n}\n```", "```kt\nfun flourDescription(flour: Flour): String {\n  return when(flour) {\n    Flour.CASSAVA -> \"A very exotic flavour\"\n    else -> \"Boring\"\n  }\n}\n```"]