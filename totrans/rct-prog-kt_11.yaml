- en: REST APIs with Spring JPA and Hibernate
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring JPA 和 Hibernate 的 REST APIs
- en: In the previous chapter, we learned how to create REST APIs with ease. We learned
    how to leverage the power of Spring, Hibernate, and JPA to create REST APIs with
    lines of code that can be counted on one hand. Those were powerful REST APIs,
    but they weren't reactive. This book's primary concern is to teach you how to
    make everything reactive and to teach you how to create non-blocking apps and
    APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何轻松地创建 REST API。我们学习了如何利用 Spring、Hibernate 和 JPA 的力量，用一行代码就能创建 REST
    API。那些是强大的 REST API，但它们不是反应式的。本书的主要关注点是教您如何使一切具有反应性，并教您如何创建非阻塞的应用程序和 API。
- en: 'So, let''s move on. Let''s make our REST API reactive. Due to the power of
    Spring, this chapter will be short. We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们继续前进。让我们使我们的 REST API 具有反应性。由于 Spring 的强大功能，这一章将会很短。我们将涵盖以下主题：
- en: Spring Boot with JPA and Hibernate
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 与 JPA 和 Hibernate
- en: Reactive programming with Reactor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Reactor 进行反应式编程
- en: So, lets get started with the Reactor Framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始使用 Reactor 框架吧。
- en: REST API with Spring Boot, Hibernate, and JPA
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Boot、Hibernate 和 JPA 的 REST API
- en: In the previous chapter, we saw how to create a static RESTful API. We will
    now learn how to manipulate database records as response to an API request. I've
    used MySQL as a database in this project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何创建静态的 RESTful API。现在，我们将学习如何根据 API 请求操作数据库记录。我在这个项目中使用了 MySQL 作为数据库。
- en: 'We will use JPA in this project. You can start a new project and add JPA as
    one of the dependencies. Alternatively, you can add this to your Gradle dependencies
    list:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用 JPA。您可以启动一个新的项目，并将 JPA 作为其中一个依赖项添加。或者，您可以将此添加到您的 Gradle 依赖项列表中：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note: You don''t need to put version and artifacts here, it is automatically
    managed by a Spring Gradle plugin and Spring Boot.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您不需要在此处放置版本和工件，它们将由 Spring Gradle 插件和 Spring Boot 自动管理。
- en: 'Now, as you added the dependency, you have to add `application.properties`.
    Go to resources and add a file named `application.properties` with the following
    content:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于您添加了依赖项，您必须添加 `application.properties` 文件。转到资源文件夹，添加一个名为 `application.properties`
    的文件，并包含以下内容：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Replace `tododb` with your database name, `root` with your database username,
    and `password` with your database password. Please note, that you have to create
    a blank database with the provided database name (in this case, `tododb`) prior
    to running this app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `tododb` 替换为您的数据库名称，将 `root` 替换为您的数据库用户名，将 `password` 替换为您的数据库密码。请注意，您必须在运行此应用程序之前使用提供的数据库名称（在本例中为
    `tododb`）创建一个空数据库。
- en: 'We''ve added a little modification to the `Todo` class. Take a look at the
    following piece of code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `Todo` 类进行了一点点修改。请看以下代码片段：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Yes, we have just added the annotations and a blank constructor, which is required
    by Spring Data. So, let''s take a look at the annotations and their purposes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们刚刚添加了注解和一个空构造函数，这是 Spring Data 所必需的。那么，让我们看看这些注解及其用途：
- en: '`@Entity`: This defines a new entity in the database, that is, for every class
    annotated with `@Entity`, a table in the database will be created.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity`：这定义了数据库中的一个新实体，即对于每个用 `@Entity` 注解的类，数据库中都会创建一个表。'
- en: '`@Id`: This annotation defines the primary key (or composite primary key, if
    multiple) for a table. The `@GeneratedValue` annotation denotes that the field
    value should be autogenerated. JPA has three strategies for ID generation, as
    described here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`：这个注解定义了一个表的主键（或多个主键的复合键）。`@GeneratedValue` 注解表示字段值应该自动生成。JPA 有三种 ID 生成策略，如下所述：'
- en: '`GenerationType.TABLE`: This denotes that the primary keys should be generated
    with an underlying table to ensure uniqueness, that is, a table with a single
    column and a single row will be created, which will hold the next primary key
    value with the column name `next_val`, and every time a row is inserted in the
    target table (the table created with our entity), the primary key will be assigned
    the value of `next_val` and `next_val` will be incremented.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerationType.TABLE`：这表示主键应该由底层表生成以确保唯一性，即创建一个只有一个列和一个行的表，该表将持有下一个主键值，列名为
    `next_val`。每次在目标表（用我们的实体创建的表）中插入一行时，主键将被分配 `next_val` 的值，而 `next_val` 将递增。'
- en: '`GenerationType.SEQUENCE`: This denotes that the primary keys should be generated
    with an underlying database sequence.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerationType.SEQUENCE`：这表示主键应该由底层数据库序列生成。'
- en: '`GenerationType.IDENTITY`: This denotes that the primary keys should be generated
    with an underlying database identity.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerationType.IDENTITY`：这表示主键应该由底层数据库的标识符生成。'
- en: '`GenerationTypeenum`: This also provides an additional option—`GenerationType.AUTO`,
    one which denotes that a proper autogeneration strategy should be automatically
    selected.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerationTypeenum`：这也提供了一个额外的选项——`GenerationType.AUTO`，表示应该自动选择适当的自动生成策略。'
- en: 'The next annotation is `@get: NotBlank`, which denotes that the field in the
    table should be not-null.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '下一个注解是`@get: NotBlank`，表示表中的字段不应为空。'
- en: 'So, we are done with the changes in our `Todo` class. We also have to create
    a `Repository` interface. Take a look at the following interface:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们完成了对`Todo`类的更改。我们还需要创建一个`Repository`接口。请看以下接口：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Yes, that short. The `@Repository` annotation denotes that this interface should
    be used as a repository (a `DAO` class) for the project. We implemented `JpaRepository`
    in this interface, which declares methods to manipulate the table. The first generic
    parameter for this interface is the `Entity` and the second one is for the type
    of the `ID` field.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，如此简短。`@Repository`注解表示此接口应作为项目的存储库（`DAO`类）使用。我们在该接口中实现了`JpaRepository`，它声明了操作表的方法。此接口的第一个泛型参数是`Entity`，第二个是`ID`字段类型的参数。
- en: 'We have also created a new class, `ResponseModel`, to structure our response
    JSON. Find the class definition here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个新的类，`ResponseModel`，以结构化我们的响应JSON。在此处找到类定义：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This response model contains the `error_code` and `error_message` properties. Let's
    describe them; if there's an error while processing the API request, `error_code`
    will hold a non-zero value and `error_message` will hold a message describing
    that error. The `error_message` property can also hold a generic message.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此响应模型包含`error_code`和`error_message`属性。让我们描述一下；如果在处理API请求时出现错误，`error_code`将包含非零值，而`error_message`将包含描述该错误的消息。`error_message`属性也可以包含通用消息。
- en: The `data` property will hold a list of `Todo`, which will be converted to a
    JSON array in the response JSON. The `data` property is optional, as this response
    model will be used for all APIs in this project and all APIs may not return a
    list of `Todo` or even a single `Todo` object (for example the  edit, add, and
    delete Todo APIs do not require to send a `Todo`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`属性将包含一个`Todo`对象的列表，该列表将在响应JSON中转换为JSON数组。`data`属性是可选的，因为此响应模型将用于本项目的所有API，并且并非所有API都返回`Todo`对象的列表或单个`Todo`对象（例如，编辑、添加和删除待办事项的API不需要发送`Todo`）。'
- en: 'The final part of this API is the `controller` class. Here is the definition:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此API的最后一部分是`controller`类。以下是定义：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, apart from the `get_todo` endpoint, we have added endpoints for `add_todo`,
    `edit_todo`, `delete_todo`, and `add_todos`. We will take a closer look at each
    of them. However, the first focus on the constructor of the `TodoController` class.
    It takes a parameter for `TodoRepository`, which will be injected by the Spring
    Annotation. We are using that `todoRepository` property in all our APIs to read/write
    to and from the database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了`get_todo`端点之外，我们还添加了`add_todo`、`edit_todo`、`delete_todo`和`add_todos`端点。我们将逐一仔细研究它们。然而，首先关注`TodoController`类的构造函数。它接受一个`TodoRepository`参数，该参数将由Spring注解注入。我们在所有API中使用`todoRepository`属性来读取/写入数据库。
- en: 'Now, take a closer look at the `get_todo` API. It uses the `findAll` method
    of `TodoRepository` to get all todos from the DB. Here is the JSON response of
    that API (note this response will vary as per the state of the database and `Todo`
    table):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更仔细地看看`get_todo` API。它使用`TodoRepository`的`findAll`方法从数据库中获取所有待办事项。以下是该API的JSON响应（注意，此响应将根据数据库和`Todo`表的状态而变化）：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next API is the `add_todo` API:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个API是`add_todo` API：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This API takes a `Todo` from the body of a `POST` request, stores it, and returns
    a success `ResponseModel`. The following Postman screenshot shows the request
    sent to the API:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此API从`POST`请求体中获取一个`Todo`对象，将其存储并返回一个成功的`ResponseModel`。以下Postman截图显示了发送到API的请求：
- en: '![](img/c784a31d-0f92-4559-97b8-eba51427ad4c.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c784a31d-0f92-4559-97b8-eba51427ad4c.jpg)'
- en: In the JSON request, we are sending all details of `Todo` except the ID, as
    the `id` field will be autogenerated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON请求中，我们发送了`Todo`的所有详细信息，除了ID，因为`id`字段将自动生成。
- en: 'The response of the API is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: API的响应如下：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `add_todos` API is almost similar to the `add_todo` API, except that here
    it takes an arbitrary number of `Todos` to be added to the database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_todos` API几乎与`add_todo` API相同，只是在这里它接受任意数量的要添加到数据库中的`Todos`。'
- en: 'The `delete_todo` API is different than all other APIs in this project. Take
    a closer look at this API here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_todo` API与这个项目中所有其他API都不同。在这里仔细看看这个API：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This API takes a `DELETE` request in all other APIs other than the `POST` request
    (reason is simple, it just deletes `Todo`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`POST`请求之外，这个API接受所有其他API的`DELETE`请求（原因很简单，它只是删除`Todo`）。
- en: It also takes the ID of `todo` in the path variable instead of `RequestBody`;
    again, simple reason, we just need one field in this API, that is, ID of the `Todo`,
    to be deleted. So, no need to take an entire JSON as a request body here. Instead,
    a path variable will be a perfect fit for this API.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它还从路径变量中获取`todo`的ID，而不是`RequestBody`；同样，原因很简单，我们只需要在这个API中获取一个字段，即要删除的`Todo`的ID。因此，没有必要将整个JSON作为请求体发送。相反，路径变量将非常适合这个API。
- en: An example request to this API will be this URL—`http://localhost:8080/api/delete_todo/7`.
    The API will check if `Todo` with the specified ID exists, it will delete `Todo`
    if it exists; otherwise, it will just return an error.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 向此API发送的示例请求将是此URL——`http://localhost:8080/api/delete_todo/7`。API将检查是否存在指定ID的`Todo`，如果存在，则删除`Todo`；否则，它将只返回一个错误。
- en: 'Here are two ideal responses of this API:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个API的两个理想响应示例：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If `Todo` was found and deleted, you''ll get this response:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到并删除了`Todo`，您将得到以下响应：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `Todo` with the specified ID is not found.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到指定ID的`Todo`。
- en: Now, as we gained some knowledge on Spring, let's get started with **Reactor**,
    a fourth-generation reactive programming library by **Pivotal**—the custodian
    for Spring.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们对Spring有了些了解，让我们开始学习**Reactor**，这是由**Pivotal**——Spring的守护者——开发的第四代响应式编程库。
- en: Reactive programming with Reactor
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Reactor进行响应式编程
- en: 'Just like the **ReactiveX** Framework, **Reactor** is also a fourth-generation
    reactive programming library. It allows you to write non-blocking reactive apps.
    However, it has some significant differences as compared to **ReactiveX**, as
    listed here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像**ReactiveX**框架一样，**Reactor**也是一个第四代响应式编程库。它允许您编写非阻塞的响应式应用程序。然而，与**ReactiveX**相比，它有一些显著的不同，如下所示：
- en: Unlike ReactiveX, which supports several platforms and languages (for example,
    RxSwift for Swift, RxJava for JVM, RxKotlin for Kotlin, RxJS for JavaScript, RxCpp
    for C++, and so on), Reactor supports only JVM.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与支持多个平台和语言的ReactiveX（例如，RxSwift for Swift、RxJava for JVM、RxKotlin for Kotlin、RxJS
    for JavaScript、RxCpp for C++等）不同，Reactor只支持JVM。
- en: You can use RxJava and RxKotlin, if you have Java 6+. However, to use Reactor,
    you need Java 8 and above.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有Java 6+，则可以使用RxJava和RxKotlin。但是，要使用Reactor，您需要Java 8及以上版本。
- en: RxJava and RxKotlin doesn't provide any direct integration with Java 8 functional
    APIs, such as CompletableFuture, Stream, and Duration, which Reactor does.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava和RxKotlin不提供与Java 8功能API（如CompletableFuture、Stream和Duration）的直接集成，而Reactor则提供了。
- en: If you're planning to implement reactive programming in Android, you have to
    use RxAndroid, RxJava, and/or RxKotlin (collectively, ReactiveX) or Vert.X, unless
    you have minimum SDK as Android SDK 26 and above, that too without official support.
    As reactor project doesn't have official support on Android and it works only
    on Android SDK 26 and above.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您计划在Android中实现响应式编程，您必须使用RxAndroid、RxJava、RxKotlin（统称为ReactiveX）或Vert.X，除非您的最小SDK为Android
    SDK 26及以上版本，并且没有官方支持。因为Reactor项目在Android上没有官方支持，并且它只在Android SDK 26及以上版本上运行。
- en: Other than these differences, Reactor and ReactiveX APIs are quite similar,
    so get started by adding Reactor to your Kotlin project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些差异之外，Reactor和ReactiveX API相当相似，所以通过将Reactor添加到您的Kotlin项目中开始吧。
- en: Add Reactor to your project
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Reactor添加到您的项目中
- en: 'If you''re using Gradle, add the following dependency:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Gradle，请将以下依赖项添加到您的项目中：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you''re using Maven, add the following dependency to the `POM.xml` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Maven，请将以下依赖项添加到`POM.xml`文件中：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can also download the JAR file from [http://central.maven.org/maven2/io/projectreactor/reactor-core/3.1.1.RELEASE/reactor-core-3.1.1.RELEASE.jar](http://central.maven.org/maven2/io/projectreactor/reactor-core/3.1.1.RELEASE/reactor-core-3.1.1.RELEASE.jar).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从[http://central.maven.org/maven2/io/projectreactor/reactor-core/3.1.1.RELEASE/reactor-core-3.1.1.RELEASE.jar](http://central.maven.org/maven2/io/projectreactor/reactor-core/3.1.1.RELEASE/reactor-core-3.1.1.RELEASE.jar)下载JAR文件。
- en: For more options, check out [https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.1.RELEASE](https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.1.RELEASE).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多选项，请查看[https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.1.RELEASE](https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.1.RELEASE)。
- en: So, as we're done with adding Reactor Core to our project, let's get started
    with `Flux` and `Mono`, producers in Reactor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们将Reactor Core添加到我们的项目之后，让我们开始学习`Flux`和`Mono`，Reactor中的生产者。
- en: Understanding Flux and Mono
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Flux和Mono
- en: As I said, Reactor is another fourth-generation Reactive library like ReactiveX.
    It originally started as a lightweight version of Rx; however, with time, it grew,
    and today it's almost of the same weight as ReactiveX.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，Reactor是另一个像ReactiveX一样的第四代响应式库。它最初是Rx的一个轻量级版本；然而，随着时间的推移，它逐渐发展，如今它的重量几乎与ReactiveX相当。
- en: It also has a producer and consumer module, just like Rx. It has `Flux`, similar
    to `Flowable` and `Mono` as a combination of `Single` and `Maybe`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它也包含生产者和消费者模块，就像Rx一样。它有`Flux`，类似于`Flowable`，以及`Mono`作为`Single`和`Maybe`的组合。
- en: Note that when describing `Flux`, I said Flowable, not Observable. You can probably
    guess the reason. Yes, all Reactor types are backpressure enabled. Basically,
    all the Reactor types are a direct implementation of the Reactive Streams `Publisher`
    API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当描述`Flux`时，我说的是Flowable，而不是Observable。你可能能猜到原因。是的，所有Reactor类型都启用了背压。基本上，所有Reactor类型都是Reactive
    Streams `Publisher` API的直接实现。
- en: Flux is a Reactor producer that can emit *N* number of emissions and can terminate
    successfully or with an error. Similarly, with `Mono`, it may or may not emit
    single items. So, what are we waiting for? Let's get started with `Flux` and `Mono`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Flux是一个可以发出*N*个发射并可以成功终止或带有错误的Reactor生产者。同样，`Mono`可能或可能不会发出单个项目。那么，我们还在等什么呢？让我们开始学习`Flux`和`Mono`。
- en: 'Consider the following code example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/17fd2d06-c2c3-4eea-b9bc-17385d04b36f.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17fd2d06-c2c3-4eea-b9bc-17385d04b36f.jpg)'
- en: The output, as well as the program, is quite similar to RxKotlin, isn't it?
    The only difference is that we are using `Flux` instead of `Flowable`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以及程序都与RxKotlin非常相似，不是吗？唯一的区别是我们使用`Flux`而不是`Flowable`。
- en: 'So, let''s take a Mono example. Take a look at the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来看一个Mono的例子。看一下以下示例：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before we describe the program line by line, let's first focus on the `log`
    operator in each of the subscriptions. The Reactor Framework understands a developer's
    need to log things, that's why they provided an operator so that we can have a
    log of every event within a Flux or Mono.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们逐行描述程序之前，让我们首先关注每个订阅中的`log`操作符。Reactor框架理解开发者对记录事物的需求，这就是为什么他们提供了一个操作符，以便我们可以在Flux或Mono中记录每个事件。
- en: On comment `(1)`, in this program, we created a `Consumer` instance to use in
    all the Subscriptions. On comment `(2)`, we created an empty Mono with the `Mono.empty()`
    factory method. As the name depicts, this factory method creates an empty Mono.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(1)`中，在这个程序中，我们创建了一个`Consumer`实例，用于所有订阅。在注释`(2)`中，我们使用`Mono.empty()`工厂方法创建了一个空的Mono。正如其名称所描述的，这个工厂方法创建了一个空的Mono。
- en: On comment `(3)`, we created another empty `Mono` with `Mono.justOrEmpty()`;
    this method creates `Mono` with the value passed or creates an empty `Mono` if
    null is passed as a value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(3)`中，我们使用`Mono.justOrEmpty()`创建了一个另一个空的`Mono`；这个方法使用传递的值创建`Mono`，如果传递的值为null，则创建一个空的`Mono`。
- en: On comment `(4)`, we created `Mono` with the same factory method, but this time
    with a `String` value passed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(4)`中，我们使用相同的工厂方法创建了`Mono`，但这次传递了一个`String`值。
- en: On comment `(5)`, we created `Mono` with the help of the `toMono` extension
    function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(5)`中，我们使用`toMono`扩展函数创建了`Mono`。
- en: 'Here is the output of the program:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是程序的输出：
- en: '![](img/0fcd8bb8-c716-4244-961c-f6f0283bd884.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fcd8bb8-c716-4244-961c-f6f0283bd884.jpg)'
- en: So, as you have learned about Spring and you also learned about reactive programming
    with Reactor; would you like to do some research yourself and make our API reactive?
    As a helping gesture, I would like to suggest that you study a little bit about
    WebFlux. You can also read through *Reactive Programming in Spring 5.0* by *Oleh
    Dokuka* and *Igor Lozynskyi* ([https://www.packtpub.com/application-development/reactive-programming-spring-50](https://www.packtpub.com/application-development/reactive-programming-spring-50)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然你已经学习了Spring，你也学习了使用Reactor的响应式编程；你愿意自己做一些研究并使我们的API变得响应式吗？作为一个帮助的举动，我想建议你稍微学习一下WebFlux。你也可以阅读由Oleh
    Dokuka和Igor Lozynskyi编写的《Spring 5.0中的响应式编程》(*Reactive Programming in Spring 5.0*)
    ([https://www.packtpub.com/application-development/reactive-programming-spring-50](https://www.packtpub.com/application-development/reactive-programming-spring-50))。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about creating a REST API quickly with Spring JPA,
    Hibernate, and Spring Boot. We also learned about Reactor and its use. We created
    the RESTful API for our project, which we will use in the next chapter while creating
    the Android app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Spring JPA、Hibernate和Spring Boot快速创建REST API。我们还学习了Reactor及其用法。我们为项目创建了RESTful
    API，将在下一章创建Android应用时使用。
- en: The next chapter, which is the last chapter of this book, is about creating
    an Android App with Kotlin and reactive programming.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，也就是本书的最后一章，是关于使用Kotlin和响应式编程创建Android应用。
- en: You're about to complete this book—complete learning *Reactive Programming in
    Kotlin*. Just another chapter is ahead. So, turn the page fast.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将完成这本书——完成学习《Kotlin中的响应式编程》。接下来还有一章。所以，快速翻页吧。
