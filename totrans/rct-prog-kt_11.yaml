- en: REST APIs with Spring JPA and Hibernate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create REST APIs with ease. We learned
    how to leverage the power of Spring, Hibernate, and JPA to create REST APIs with
    lines of code that can be counted on one hand. Those were powerful REST APIs,
    but they weren't reactive. This book's primary concern is to teach you how to
    make everything reactive and to teach you how to create non-blocking apps and
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s move on. Let''s make our REST API reactive. Due to the power of
    Spring, this chapter will be short. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot with JPA and Hibernate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming with Reactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, lets get started with the Reactor Framework.
  prefs: []
  type: TYPE_NORMAL
- en: REST API with Spring Boot, Hibernate, and JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to create a static RESTful API. We will
    now learn how to manipulate database records as response to an API request. I've
    used MySQL as a database in this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use JPA in this project. You can start a new project and add JPA as
    one of the dependencies. Alternatively, you can add this to your Gradle dependencies
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: You don''t need to put version and artifacts here, it is automatically
    managed by a Spring Gradle plugin and Spring Boot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as you added the dependency, you have to add `application.properties`.
    Go to resources and add a file named `application.properties` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Replace `tododb` with your database name, `root` with your database username,
    and `password` with your database password. Please note, that you have to create
    a blank database with the provided database name (in this case, `tododb`) prior
    to running this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve added a little modification to the `Todo` class. Take a look at the
    following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, we have just added the annotations and a blank constructor, which is required
    by Spring Data. So, let''s take a look at the annotations and their purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Entity`: This defines a new entity in the database, that is, for every class
    annotated with `@Entity`, a table in the database will be created.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Id`: This annotation defines the primary key (or composite primary key, if
    multiple) for a table. The `@GeneratedValue` annotation denotes that the field
    value should be autogenerated. JPA has three strategies for ID generation, as
    described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GenerationType.TABLE`: This denotes that the primary keys should be generated
    with an underlying table to ensure uniqueness, that is, a table with a single
    column and a single row will be created, which will hold the next primary key
    value with the column name `next_val`, and every time a row is inserted in the
    target table (the table created with our entity), the primary key will be assigned
    the value of `next_val` and `next_val` will be incremented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GenerationType.SEQUENCE`: This denotes that the primary keys should be generated
    with an underlying database sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GenerationType.IDENTITY`: This denotes that the primary keys should be generated
    with an underlying database identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GenerationTypeenum`: This also provides an additional option—`GenerationType.AUTO`,
    one which denotes that a proper autogeneration strategy should be automatically
    selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next annotation is `@get: NotBlank`, which denotes that the field in the
    table should be not-null.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are done with the changes in our `Todo` class. We also have to create
    a `Repository` interface. Take a look at the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Yes, that short. The `@Repository` annotation denotes that this interface should
    be used as a repository (a `DAO` class) for the project. We implemented `JpaRepository`
    in this interface, which declares methods to manipulate the table. The first generic
    parameter for this interface is the `Entity` and the second one is for the type
    of the `ID` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also created a new class, `ResponseModel`, to structure our response
    JSON. Find the class definition here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This response model contains the `error_code` and `error_message` properties. Let's
    describe them; if there's an error while processing the API request, `error_code`
    will hold a non-zero value and `error_message` will hold a message describing
    that error. The `error_message` property can also hold a generic message.
  prefs: []
  type: TYPE_NORMAL
- en: The `data` property will hold a list of `Todo`, which will be converted to a
    JSON array in the response JSON. The `data` property is optional, as this response
    model will be used for all APIs in this project and all APIs may not return a
    list of `Todo` or even a single `Todo` object (for example the  edit, add, and
    delete Todo APIs do not require to send a `Todo`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of this API is the `controller` class. Here is the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, apart from the `get_todo` endpoint, we have added endpoints for `add_todo`,
    `edit_todo`, `delete_todo`, and `add_todos`. We will take a closer look at each
    of them. However, the first focus on the constructor of the `TodoController` class.
    It takes a parameter for `TodoRepository`, which will be injected by the Spring
    Annotation. We are using that `todoRepository` property in all our APIs to read/write
    to and from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a closer look at the `get_todo` API. It uses the `findAll` method
    of `TodoRepository` to get all todos from the DB. Here is the JSON response of
    that API (note this response will vary as per the state of the database and `Todo`
    table):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next API is the `add_todo` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This API takes a `Todo` from the body of a `POST` request, stores it, and returns
    a success `ResponseModel`. The following Postman screenshot shows the request
    sent to the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c784a31d-0f92-4559-97b8-eba51427ad4c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the JSON request, we are sending all details of `Todo` except the ID, as
    the `id` field will be autogenerated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response of the API is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `add_todos` API is almost similar to the `add_todo` API, except that here
    it takes an arbitrary number of `Todos` to be added to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete_todo` API is different than all other APIs in this project. Take
    a closer look at this API here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This API takes a `DELETE` request in all other APIs other than the `POST` request
    (reason is simple, it just deletes `Todo`).
  prefs: []
  type: TYPE_NORMAL
- en: It also takes the ID of `todo` in the path variable instead of `RequestBody`;
    again, simple reason, we just need one field in this API, that is, ID of the `Todo`,
    to be deleted. So, no need to take an entire JSON as a request body here. Instead,
    a path variable will be a perfect fit for this API.
  prefs: []
  type: TYPE_NORMAL
- en: An example request to this API will be this URL—`http://localhost:8080/api/delete_todo/7`.
    The API will check if `Todo` with the specified ID exists, it will delete `Todo`
    if it exists; otherwise, it will just return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two ideal responses of this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If `Todo` was found and deleted, you''ll get this response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If `Todo` with the specified ID is not found.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we gained some knowledge on Spring, let's get started with **Reactor**,
    a fourth-generation reactive programming library by **Pivotal**—the custodian
    for Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming with Reactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the **ReactiveX** Framework, **Reactor** is also a fourth-generation
    reactive programming library. It allows you to write non-blocking reactive apps.
    However, it has some significant differences as compared to **ReactiveX**, as
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike ReactiveX, which supports several platforms and languages (for example,
    RxSwift for Swift, RxJava for JVM, RxKotlin for Kotlin, RxJS for JavaScript, RxCpp
    for C++, and so on), Reactor supports only JVM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use RxJava and RxKotlin, if you have Java 6+. However, to use Reactor,
    you need Java 8 and above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJava and RxKotlin doesn't provide any direct integration with Java 8 functional
    APIs, such as CompletableFuture, Stream, and Duration, which Reactor does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're planning to implement reactive programming in Android, you have to
    use RxAndroid, RxJava, and/or RxKotlin (collectively, ReactiveX) or Vert.X, unless
    you have minimum SDK as Android SDK 26 and above, that too without official support.
    As reactor project doesn't have official support on Android and it works only
    on Android SDK 26 and above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than these differences, Reactor and ReactiveX APIs are quite similar,
    so get started by adding Reactor to your Kotlin project.
  prefs: []
  type: TYPE_NORMAL
- en: Add Reactor to your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re using Gradle, add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re using Maven, add the following dependency to the `POM.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can also download the JAR file from [http://central.maven.org/maven2/io/projectreactor/reactor-core/3.1.1.RELEASE/reactor-core-3.1.1.RELEASE.jar](http://central.maven.org/maven2/io/projectreactor/reactor-core/3.1.1.RELEASE/reactor-core-3.1.1.RELEASE.jar).
  prefs: []
  type: TYPE_NORMAL
- en: For more options, check out [https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.1.RELEASE](https://mvnrepository.com/artifact/io.projectreactor/reactor-core/3.1.1.RELEASE).
  prefs: []
  type: TYPE_NORMAL
- en: So, as we're done with adding Reactor Core to our project, let's get started
    with `Flux` and `Mono`, producers in Reactor.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Flux and Mono
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I said, Reactor is another fourth-generation Reactive library like ReactiveX.
    It originally started as a lightweight version of Rx; however, with time, it grew,
    and today it's almost of the same weight as ReactiveX.
  prefs: []
  type: TYPE_NORMAL
- en: It also has a producer and consumer module, just like Rx. It has `Flux`, similar
    to `Flowable` and `Mono` as a combination of `Single` and `Maybe`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when describing `Flux`, I said Flowable, not Observable. You can probably
    guess the reason. Yes, all Reactor types are backpressure enabled. Basically,
    all the Reactor types are a direct implementation of the Reactive Streams `Publisher`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is a Reactor producer that can emit *N* number of emissions and can terminate
    successfully or with an error. Similarly, with `Mono`, it may or may not emit
    single items. So, what are we waiting for? Let's get started with `Flux` and `Mono`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17fd2d06-c2c3-4eea-b9bc-17385d04b36f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The output, as well as the program, is quite similar to RxKotlin, isn't it?
    The only difference is that we are using `Flux` instead of `Flowable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a Mono example. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Before we describe the program line by line, let's first focus on the `log`
    operator in each of the subscriptions. The Reactor Framework understands a developer's
    need to log things, that's why they provided an operator so that we can have a
    log of every event within a Flux or Mono.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(1)`, in this program, we created a `Consumer` instance to use in
    all the Subscriptions. On comment `(2)`, we created an empty Mono with the `Mono.empty()`
    factory method. As the name depicts, this factory method creates an empty Mono.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(3)`, we created another empty `Mono` with `Mono.justOrEmpty()`;
    this method creates `Mono` with the value passed or creates an empty `Mono` if
    null is passed as a value.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(4)`, we created `Mono` with the same factory method, but this time
    with a `String` value passed.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(5)`, we created `Mono` with the help of the `toMono` extension
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fcd8bb8-c716-4244-961c-f6f0283bd884.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, as you have learned about Spring and you also learned about reactive programming
    with Reactor; would you like to do some research yourself and make our API reactive?
    As a helping gesture, I would like to suggest that you study a little bit about
    WebFlux. You can also read through *Reactive Programming in Spring 5.0* by *Oleh
    Dokuka* and *Igor Lozynskyi* ([https://www.packtpub.com/application-development/reactive-programming-spring-50](https://www.packtpub.com/application-development/reactive-programming-spring-50)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about creating a REST API quickly with Spring JPA,
    Hibernate, and Spring Boot. We also learned about Reactor and its use. We created
    the RESTful API for our project, which we will use in the next chapter while creating
    the Android app.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter, which is the last chapter of this book, is about creating
    an Android App with Kotlin and reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: You're about to complete this book—complete learning *Reactive Programming in
    Kotlin*. Just another chapter is ahead. So, turn the page fast.
  prefs: []
  type: TYPE_NORMAL
