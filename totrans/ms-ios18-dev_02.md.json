["```swift\n<st c=\"4058\">import SwiftData</st>\n<st c=\"4075\">@Model</st> class Book {\n    var author: String\n    var title: String\n    var publishedDate: Date\n    init(author: String, title: String, publishedDate:\n      Date) {\n        self.author = author\n        self.title = title\n        self.publishedDate = publishedDate\n    }\n}\n```", "```swift\n @Transient\nprivate var _$backingData: any SwiftData.BackingData<Book>\n  = Book.createBackingData()\npublic var persistentBackingData: any\n  SwiftData.BackingData<Book> {\n    get {\n        _$backingData\n    }\n    set {\n        _$backingData = newValue\n    }\n}\nstatic var schemaMetadata:\n  [SwiftData.Schema.PropertyMetadata] {\n  return [\n    SwiftData.Schema.PropertyMetadata(name: \"author\",\n      keypath: \\Book.author, defaultValue: nil, metadata:\n      nil),\n    SwiftData.Schema.PropertyMetadata(name: \"title\",\n      keypath: \\Book.title, defaultValue: nil, metadata:\n      nil),\n    SwiftData.Schema.PropertyMetadata(name:\n      \"publishedDate\", keypath: \\Book.publishedDate,\n      defaultValue: nil, metadata: nil)\n  ]\n}\nrequired init(backingData: any SwiftData.BackingData<Book>) {\n  _author = _SwiftDataNoType()\n  _title = _SwiftDataNoType()\n  _publishedDate = _SwiftDataNoType()\n  self.persistentBackingData = backingData\n}\n@Transient\nprivate let _$observationRegistrar = Observation.ObservationRegistrar()\nstruct _SwiftDataNoType {\n}\nextension Book: SwiftData.PersistentModel {\n}\nextension Book: Observation.Observable {\n}\n```", "```swift\n    <st c=\"7635\">@_PersistedProperty</st> var author: String <st c=\"7675\">@_PersistedProperty</st> var title: String <st c=\"7713\">@_PersistedProperty</st> var publishedDate: Date\n    ```", "```swift\n @Model\nclass Book {\n    var title: String\n    var publishedDate: Date <st c=\"9127\">var author: Author</st><st c=\"9145\">var pages: [Page]</st> init(author: Author, title: String, publishedDate:\n      Date) {\n        self.title = title\n        self.publishedDate = publishedDate <st c=\"9277\">self.author = author</st><st c=\"9297\">self.pages = []</st> }\n}\n```", "```swift\n<st c=\"9786\">@Model</st> class Author {\n    var name: String\n    init() {\n        self.name = \"\"\n    }\n} <st c=\"9854\">@Model</st> class Page {\n    var content: String\n    var order: Int\n    init(content: String, order: Int) {\n        self.content = content\n        self.order = order\n    }\n}\n```", "```swift\n<st c=\"11653\">cascade</st>.\n\t\t\t<st c=\"11661\">We have four different</st> <st c=\"11685\">deletion rules:</st>\n\n\t\t\t\t*   `<st c=\"11700\">cascade</st>`<st c=\"11708\">: Deletes any</st> <st c=\"11723\">related objects</st>\n\t\t\t\t*   `<st c=\"11738\">deny</st>`<st c=\"11743\">: Prevents deletion of an object if it contains one or more references to</st> <st c=\"11818\">other objects</st>\n\t\t\t\t*   `<st c=\"11831\">nullify</st>`<st c=\"11839\">: Nullifies the related object’s reference to the</st> <st c=\"11890\">deleted object</st>\n\t\t\t\t*   `<st c=\"11904\">noAction</st>`<st c=\"11913\">: In this case, nothing will happen to the</st> <st c=\"11957\">other object</st>\n\n\t\t\t<st c=\"11969\">We should remember that a deletio</st><st c=\"12003\">n rule is not arbitrary; it should be based on our app</st> <st c=\"12059\">business ideas.</st>\n\t\t\t<st c=\"12074\">For example, the reason why a book has a</st> *<st c=\"12116\">to-one</st>* <st c=\"12122\">connection to an author sounds logical, but there are books with co-authors as well.</st> <st c=\"12208\">So, this is something that should be aligned with our</st> <st c=\"12262\">product manager.</st>\n\t\t\t<st c=\"12278\">Most of us</st> <st c=\"12290\">are more familiar with the term</st> *<st c=\"12322\">one-to-many</st>* <st c=\"12333\">than</st> *<st c=\"12339\">to-many</st>*<st c=\"12346\">. This is because relationships between objects go both ways – the fact that each book has one author doesn’t mean that each author has only one book.</st> <st c=\"12497\">So, as part of th</st><st c=\"12514\">e relationship definition, we also need to define its</st> <st c=\"12569\">inverse relationship.</st>\n\t\t\t<st c=\"12590\">Defining the inverse relationship</st>\n\t\t\t<st c=\"12624\">Why do we need to define the inverse relationship?</st> <st c=\"12676\">We need to realize that relationships</st> <st c=\"12714\">always have two sides (like in real life!), and we need to maintain them to have a proper</st> <st c=\"12804\">data schema.</st>\n\t\t\t<st c=\"12816\">When establishing a relationship between a book and its pages, it’s better to define the inverse relationship as well.</st> <st c=\"12936\">This way, we can create a proper reference back to</st> <st c=\"12987\">the book.</st>\n\t\t\t<st c=\"12996\">Let’s see how to create an inverse relationship between a book and its pages through the</st> <st c=\"13086\">following code:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"13291\">Looking at the code, we can see that we define the relationship as</st> <st c=\"13359\">a keypath:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"13380\">A keypath can</st> <st c=\"13395\">help us avoid typos and mistakes when defining the</st> <st c=\"13446\">inverse property.</st>\n\t\t\t<st c=\"13463\">Moreover, if we add a new page to the</st> `<st c=\"13502\">pages</st>` <st c=\"13507\">property, SwiftData will automatically set the Page’s</st> `<st c=\"13562\">book</st>` <st c=\"13566\">property to the</st> <st c=\"13583\">new book:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"13696\">SwiftData knows how to do that using our</st> <st c=\"13738\">inverse declaration.</st>\n\t\t\t<st c=\"13758\">The inverse relationship may sound like an obvious feature – if we have a book with several pages, and each page is related to a book, isn’t it obvious that the</st> `<st c=\"13920\">book</st>` <st c=\"13924\">property in the</st> `<st c=\"13941\">page</st>` <st c=\"13945\">class is the inverse relationship?</st> <st c=\"13981\">However, in reality, it’s not obvious.</st> <st c=\"14020\">There are several real-world use cases when relationships can be much</st> <st c=\"14090\">more complex.</st>\n\t\t\t<st c=\"14103\">Let’s take, for example, the data structure of a folder tree – each folder has its sub-folders.</st> <st c=\"14200\">This means that a folder has a</st> *<st c=\"14231\">to-one</st>* <st c=\"14237\">relationship to its parent and a</st> *<st c=\"14271\">to-many</st>* <st c=\"14278\">relationship to its children.</st> <st c=\"14309\">Let’s see that in</st> <st c=\"14327\">the code:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"14632\">This example</st> <st c=\"14646\">demonstrates what a</st> `<st c=\"14666\">Folder</st>` <st c=\"14672\">class looks like when trying to create a multi-level hierarchical structure.</st> <st c=\"14750\">In this case, we must define the inverse relationship to</st> <st c=\"14807\">avoid cycles.</st>\n\t\t\t<st c=\"14820\">Now that we know how relationships work in SwiftData, let’s see more ways to customize our model, using the</st> `<st c=\"14929\">@</st>``<st c=\"14930\">Attribute</st>` <st c=\"14939\">macro.</st>\n\t\t\t<st c=\"14946\">Adding the @Attribute macro</st>\n\t\t\t<st c=\"14974\">So far, we have learned how to declare new entities, properties, and even relationships between</st> <st c=\"15071\">our entities.</st> <st c=\"15085\">It looks like we can do anything with our data entities!</st> <st c=\"15142\">Now, it’s essential to drill down to the</st> <st c=\"15183\">property level.</st>\n\t\t\t<st c=\"15198\">Along with our</st> `<st c=\"15214\">@Model</st>` <st c=\"15220\">and</st> `<st c=\"15225\">@Relationship</st>` <st c=\"15238\">macros, we now have the</st> `<st c=\"15263\">@Attribute</st>` <st c=\"15273\">macro to define the behavior of a</st> <st c=\"15308\">specific property.</st>\n\t\t\t<st c=\"15326\">If you remember from Core Data, each attribute has an inspector window where we can configure an attribute’s behavior (</st>*<st c=\"15446\">Figure 2</st>**<st c=\"15455\">.1</st>*<st c=\"15457\">):</st>\n\t\t\t![Figure 2.1: The Attribute inspector in Core Data](img/B21795_02_1.jpg)\n\n\t\t\t<st c=\"15805\">Figure 2.1: The Attribute inspector in Core Data</st>\n\t\t\t*<st c=\"15853\">Figure 2</st>**<st c=\"15862\">.1</st>* <st c=\"15864\">shows what it looks like when we select one of the attributes (</st>`<st c=\"15928\">firstName</st>` <st c=\"15938\">in this example) and how we can customize</st> <st c=\"15981\">its behavior.</st>\n\t\t\t<st c=\"15994\">We can</st> <st c=\"16002\">define some of these settings in SwiftData as part of the property declaration.</st> <st c=\"16082\">For example, the Optional feature, as seen in</st> *<st c=\"16128\">Figure 2</st>**<st c=\"16136\">.1</st>*<st c=\"16138\">, is defined by marking a property as Swift optional type, and the default value is part of</st> <st c=\"16230\">variable initialization:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"16288\">However, other settings need to be declared as part of the</st> `<st c=\"16348\">@</st>``<st c=\"16349\">Attribute</st>` <st c=\"16358\">macro.</st>\n\t\t\t<st c=\"16365\">Let’s start with the most common one,</st> `<st c=\"16404\">unique</st>`<st c=\"16410\">, and making attributes unique is an important feature of many databases,</st> <st c=\"16484\">including</st> *<st c=\"16494\">SQLite</st>*<st c=\"16500\">.</st>\n\t\t\t<st c=\"16501\">The following are a few</st> <st c=\"16526\">reasons why:</st>\n\n\t\t\t\t*   **<st c=\"16538\">Setting up a primary key</st>**<st c=\"16563\">: A primary key represents a record’s unique identifier.</st> <st c=\"16621\">We use a primary key to ensure that there are no duplicates in</st> <st c=\"16684\">our table.</st>\n\t\t\t\t*   **<st c=\"16694\">Supporting indexing</st>**<st c=\"16714\">: Unique attributes can help us index our database for searching</st> <st c=\"16780\">and retrieval.</st>\n\t\t\t\t*   **<st c=\"16794\">Helping with data validation</st>**<st c=\"16823\">: Utilizing unique attributes goes beyond primary keys and extends to other distinctive attributes, enhancing our ability to validate data</st> <st c=\"16963\">during insertion.</st>\n\n\t\t\t<st c=\"16980\">Even though</st> *<st c=\"16993\">SQLite</st>* <st c=\"16999\">supports unique attributes, Core Data doesn’t have a built-in way to support</st> <st c=\"17077\">unique identifiers, derived from its design philosophy to offer complete flexibility</st> <st c=\"17162\">to developers.</st>\n\t\t\t<st c=\"17176\">Conversely, SwiftData supports unique attributes out of</st> <st c=\"17233\">the box:</st>\n\n```", "```swift\n @Model\nclass Book { <st c=\"18624\">#Unique<Book>([\\.name, \\.publicationName])</st> var publicationName: String = \"Packt\"\n    var name: String\n}\n```", "```swift\n @Transient\nvar openCounter: Int = 0\n```", "```swift\n var container: ModelContainer = {\n        do {\n            return try <st c=\"22271\">ModelContainer</st>(for:\n              Schema([<st c=\"22300\">Book.self, Author.self, Page.self</st>]) )\n        } catch {\n            fatalError(\"Could not create ModelContainer:\n              \\(error)\")\n        }\n    }()\n```", "```swift\n Schema([Book.self])\n```", "```swift\n var body: some Scene {\n        WindowGroup {\n            ContentView()\n        } <st c=\"23954\">.modelContainer(container)</st> }\n```", "```swift\n .modelContainer(for: [Book.self, Author.self, Page.self])\n```", "```swift\n var modelContainer: ModelContainer = {\n        do {\n            let schema = Schema([Book.self, Author.self,\n              Page.self]) <st c=\"24891\">let modelConfiguration =</st>\n <st c=\"24915\">ModelConfiguration(schema: schema,</st>\n <st c=\"24950\">isStoredInMemoryOnly: true)</st> return try ModelContainer(for: schema, <st c=\"25018\">configurations: [modelConfiguration]</st>)\n        } catch {\n            fatalError(\"Could not create ModelContainer:\n              \\(error)\")\n        }\n    }()\n```", "```swift\n var modelContainer: ModelContainer = {\n      do {\n          let <st c=\"26092\">brainstormDataConfiguration</st> =\n            ModelConfiguration(\"brainstorm_configuration\",\n            schema: schemaForBrainstorm,\n            isStoredInMemoryOnly: true)\n          let <st c=\"26230\">projectsDataConfiguration</st> =\n            ModelConfiguration(\"projects_configuration\",\n            schema: schemaForProjects,\n            cloudKitDatabase: .automatic)\n          return try ModelContainer(for: fullSchema,\n            configurations: [<st c=\"26420\">brainstormDataConfiguration,</st>\n <st c=\"26449\">projectsDataConfiguration</st>])\n        } catch {\n            fatalError(\"Could not create ModelContainer:\n              \\(error)\")\n        }\n    }()\n```", "```swift\n struct ContentView: View { <st c=\"28059\">@Environment(\\.modelContext)</st> private var modelContext\n}\n```", "```swift\n let modelContext = modelContainer.mainContext\n```", "```swift\n let newBook = Book(name: \"Mastering iOS 18 – the future\")\n```", "```swift\n modelContext.insert(newBook)\n```", "```swift\n try? modelContext.<st c=\"29593\">save()</st> method pushes changes to the store for each model, according to its configuration.\n\t\t\t<st c=\"29682\">The way the</st> `<st c=\"29695\">save()</st>` <st c=\"29701\">method works resembles how Core Data works.</st> <st c=\"29746\">But there’s one difference here.</st> <st c=\"29779\">SwiftData allows us to have an</st> *<st c=\"29810\">auto-save</st>* <st c=\"29819\">feature for the</st> <st c=\"29836\">model container:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"29966\">In our code</st> <st c=\"29979\">example, we set the</st> `<st c=\"29999\">isAutosaveEnabled</st>` <st c=\"30016\">parameter to</st> `<st c=\"30030\">false</st>`<st c=\"30035\">. By default, SwiftData auto-saves every change we make to the persistent store, so there’s no need to call the</st> `<st c=\"30147\">save()</st>` <st c=\"30153\">function unless you have a</st> <st c=\"30181\">perfect reason.</st>\n\t\t\t<st c=\"30196\">Due to performance considerations, SwiftData doesn’t save every single time we perform a change to the context but, rather, in the following</st> <st c=\"30338\">two situations:</st>\n\n\t\t\t\t*   <st c=\"30353\">During the app life cycle – for example, when moving from the foreground to</st> <st c=\"30430\">the background</st>\n\t\t\t\t*   <st c=\"30444\">In a certain time period after we perform</st> <st c=\"30487\">the change</st>\n\n\t\t\t<st c=\"30497\">Now that we know how to create and insert new objects, we can move on</st> <st c=\"30568\">to fetching.</st>\n\t\t\t<st c=\"30580\">Fetching objects</st>\n\t\t\t<st c=\"30597\">Fetching objects in SwiftData is slightly different than what we know from Core Data, as there are</st> <st c=\"30697\">two primary ways to</st> <st c=\"30717\">retrieve data.</st>\n\t\t\t<st c=\"30731\">The first way</st> <st c=\"30746\">is to fetch an object, or objects,</st> *<st c=\"30781\">based on a predicate</st>* <st c=\"30801\">as part of an app flow – for example, fetching objects to sync with the server or to make some kind</st> <st c=\"30902\">of calculation.</st>\n\t\t\t<st c=\"30917\">The second way is to fetch objects</st> *<st c=\"30953\">based on a query</st>* <st c=\"30969\">and bind them to the SwiftUI view.</st> <st c=\"31005\">An example would be when we want to bind a collection of objects to</st> <st c=\"31073\">a list.</st>\n\t\t\t<st c=\"31080\">Let’s go over both ways and explore new structures and macros that SwiftData brings to</st> <st c=\"31168\">our project.</st>\n\t\t\t<st c=\"31180\">Fetching objects using FetchDescriptor</st>\n\t\t\t`<st c=\"31219\">FetchDescriptor</st>` <st c=\"31235\">is a struct equivalent to</st> `<st c=\"31262\">NSFetchRequest</st>` <st c=\"31276\">in</st> <st c=\"31280\">Core Data.</st>\n\t\t\t<st c=\"31290\">Like</st> `<st c=\"31296\">NSFetchRequest</st>`<st c=\"31310\">,</st> `<st c=\"31312\">FetchDescriptor</st>` <st c=\"31327\">also works with a specific type of object; to use it, we can pass an optional predicate and</st> <st c=\"31420\">sort descriptor.</st>\n\t\t\t<st c=\"31436\">Here’s</st> <st c=\"31444\">an example of how to</st> <st c=\"31465\">use</st> `<st c=\"31469\">FetchDescriptor</st>`<st c=\"31484\">:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"31636\">If you look closely, you can see that</st> `<st c=\"31675\">FetchDescriptor</st>` <st c=\"31690\">is not the only new type we encounter in this context, as we also have a new</st> `<st c=\"31768\">Predicate</st>` <st c=\"31777\">macro that creates</st> `<st c=\"31797\">PredicateExpression</st>` <st c=\"31816\">(a new type in</st> <st c=\"31832\">iOS 17).</st>\n\t\t\t<st c=\"31840\">Unlike the familiar</st> `<st c=\"31861\">NSPredicate</st>`<st c=\"31872\">, the</st> `<st c=\"31878\">Predicate</st>` <st c=\"31887\">macro works a little bit differently.</st> <st c=\"31926\">Instead of creating a query, we have a closure where we define the condition of the return instances, like the array</st> <st c=\"32043\">filter method.</st>\n\t\t\t<st c=\"32057\">The following example returns books with more than</st> <st c=\"32109\">10 pages:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"32226\">Using the</st> `<st c=\"32237\">#Predicate</st>` <st c=\"32247\">macro is simple and doesn’t require us to use a special syntax to perform</st> <st c=\"32322\">complex queries.</st>\n\t\t\t<st c=\"32338\">In most cases, we won’t have to use</st> `<st c=\"32375\">FetchDescriptor</st>`<st c=\"32390\">. If we want to connect data to our SwiftUI views, SwiftData has a better solution – the</st> `<st c=\"32479\">@</st>``<st c=\"32480\">Query</st>` <st c=\"32485\">macro.</st>\n\t\t\t<st c=\"32492\">Conn</st><st c=\"32497\">ecting data to a view using the @Query macro</st>\n\t\t\t<st c=\"32542\">Data is there to be seen.</st> <st c=\"32569\">Showing information to the user is perhaps the most common task</st> <st c=\"32633\">for iOS developers, and SwiftData’s</st> <st c=\"32669\">goal is just to</st> <st c=\"32685\">simplify that.</st>\n\t\t\t<st c=\"32699\">As part</st> <st c=\"32708\">of the SwiftData package, we now have an</st> `<st c=\"32749\">@Query</st>` <st c=\"32755\">macro that helps us present information in</st> <st c=\"32799\">SwiftUI views:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"32922\">This example displays a simple list of</st> `<st c=\"32962\">Book</st>` <st c=\"32966\">items based on the</st> `<st c=\"32986\">books</st>` <st c=\"32991\">variable.</st> <st c=\"33002\">The</st> `<st c=\"33006\">@Query</st>` <st c=\"33012\">macro before the variable declaration makes the variable a state of the view, ensuring that data is constantly updated.</st> <st c=\"33133\">This means that we get an instant UI update whenever we insert a new book into our</st> <st c=\"33216\">persistent store.</st>\n\t\t\t<st c=\"33233\">This is pretty remarkable for just one</st> <st c=\"33273\">additional word!</st>\n\t\t\t<st c=\"33289\">The</st> `<st c=\"33294\">@Query</st>` <st c=\"33300\">macro also has two important additional features – filter</st> <st c=\"33359\">and sorting.</st>\n\t\t\t<st c=\"33371\">Filtering the query</st>\n\t\t\t<st c=\"33391\">The chances</st> <st c=\"33404\">that we will fetch</st> *<st c=\"33423\">all</st>* <st c=\"33426\">the items of a particular entity are pretty low, and the previous example of fetching all the books and presenting them is more common in tutorials and</st> <st c=\"33579\">demo presentations.</st>\n\t\t\t<st c=\"33598\">In real life, we want to filter our queries.</st> <st c=\"33644\">To do that, we can use</st> `<st c=\"33667\">#Predicate</st>`<st c=\"33677\">, which we learned about in the</st> *<st c=\"33709\">Fetching objects using</st>* *<st c=\"33732\">FetchDescriptor</st>* <st c=\"33747\">section:</st>\n\n```", "```swift\n @Query(filter: <st c=\"34075\">#Predicate<Book> {</st>\n <st c=\"34093\">$0.pages.count > 300 && (!$0.isRead ||</st>\n <st c=\"34132\">$0.isFavorite)</st> }) private var bigBooks: [Book]\n```", "```swift\n @Query(filter: #Predicate<Book> {\n        $0.pages.count > 300\n    }, <st c=\"35071\">sort: [SortDescriptor(\\Book.name),</st>\n <st c=\"35105\">SortDescriptor(\\Book.pages.count)]</st>) private var\n         bigBooks: [Book]\n```", "```swift\n @Model\nclass Book { <st c=\"36564\">#Index<Book>([\\.name], [\\.name, \\.publicationName])</st> var publicationName: String = \"Packt\"\n    var name: String\n}\n```", "```swift\n enum BookSchemaV1: VersionedSchema {\n    static var versionIdentifier: Schema.Version\n    { return .init(1, 0, 0) }\n    static var models: [any PersistentModel.Type] {\n        [Book.self]\n    }\n    @Model class Book {\n        var name: String\n        init(name: String) {\n            self.name = name\n        }\n    }\n}\nenum BookSchemaV2: VersionedSchema {\n    static var versionIdentifier: Schema.Version\n    {return .init(1, 1, 0) }\n    static var models: [any PersistentModel.Type] {\n        [Book.self]\n    }\n    @Model class Book {\n <st c=\"41373\">var subtitle: String = \"\"</st> var name: String\n        init(subtitle: String, name: String) { <st c=\"41455\">self.subtitle = subtitle</st> self.name = name\n        }\n    }\n}\n```", "```swift\n static let migrateV1toV2 = <st c=\"42196\">MigrationStage.lightweight</st>(fromVersion:\n  BookSchemaV1.self, toVersion: BookSchemaV2.self)\n```", "```swift\n static let migrateV2toV3 = <st c=\"42844\">MigrationStage.custom</st>(fromVersion: BookSchemaV2.self,\n  toVersion: BookSchemaV3.self, <st c=\"42929\">willMigrate</st>: { context in\n        if let books = try? context.fetch(FetchDescriptor<Book>()) {\n            for book in books {\n                let newName = book.name + \" \" +\n                  book.subtitle\nbook.name = newName\n            }\n        }\n        try? context.save()\n    }, didMigrate: nil)\n```", "```swift\n<st c=\"43510\">enum MyMigrationPlan: SchemaMigrationPlan</st> {\n    static var schemas: [VersionedSchema.Type] {\n        [BookSchemaV1.self, BookSchemaV2.self,\n          BookSchemaV3.self]\n    } <st c=\"43660\">static var stages: [MigrationStage] {</st>\n <st c=\"43697\">[migrateV1toV2, migrateV2toV3]</st>\n <st c=\"43728\">}</st> static let migrateV1toV2 =\n      MigrationStage.lightweight(fromVersion:\n      BookSchemaV1.self, toVersion: BookSchemaV2.self)\n    static let migrateV2toV3 =\n      MigrationStage.custom(fromVersion: BookSchemaV2.self,\n      toVersion: BookSchemaV3.self, willMigrate:{context in\n        if let books = try? context.fetch(FetchDescriptor<Book>()) {\n            for book in books {\n                let newName = book.name + \" \" +\n                  book.subtitle\n                book.name = newName\n            }\n        }\n        try? context.save()\n    }, didMigrate: nil)\n}\n```", "```swift\n return try ModelContainer(for: schema, <st c=\"44830\">migrationPlan:</st>\n <st c=\"44844\">MyMigrationPlan.self,</st> configurations:\n   [modelConfiguration])\n```", "```swift\n\n```", "```swift\n\n```"]