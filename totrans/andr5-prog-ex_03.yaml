- en: Chapter 3. Activities and Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are very few useful apps that run on just a single screen, or just use
    a single Activity; and we need a way to switch from one Activity to another and
    to pass information from one to another. Generally speaking, each new Activity
    will require its own layout file, but this not always the case; there are times
    when we want the same layout but with different data and resources. Later in this
    book, we will be building an app that acts as a tourist guide for some of the
    world's most famous and visited sites. We will start this journey by building
    a simple example for just one site that will include an introduction to the `CardView`
    widget introduced in Android 5, and learn how to start one Activity from another.
  prefs: []
  type: TYPE_NORMAL
- en: We will then take a look at Fragments which allow us to construct layouts in
    a modular fashion. Fragments behave a little like mini Activities and can be added
    to Activities dynamically at runtime or can be defined in a layout file like other
    ViewGroups. We will build a small timekeeping app that uses Fragments to switch
    between a digital and an analog clock face.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will include an Options menu in our app to allow the user to change
    time-and locale-related settings on their device. We will add action icons to
    the menu, so that it can be displayed on what was, prior to Lollipop, called the
    Action Bar. Finally, we will take advantage of the Action Bar's replacement, the
    Toolbar, customizing it so that it can be placed anywhere on a screen and contain
    far more functionality than its predecessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `CardView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give the `CardView` a layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a second Activity and Layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use XML to define `onClick` behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program the two activities to work together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Fragments to dynamically change layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the Translations Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add static fragments with XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include an Options menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access user settings with intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add menu icons to the action bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the action bar with a custom toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a CardView widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the views we have already met, `CardView` does not come included in the
    standard SDK libraries but rather as part of the (Lollipop specific) V7 Support
    Libraries and not available from the graphic layout design mode; therefore, it
    requires a little more work to apply one in a layout.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Android project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Application name:** to `Stonehenge Guide`, although you can call it
    anything you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Phone and Tablet** form factor and **Blank Activity** from the
    next page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the other options as they are and wait for the project to build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file in design view and delete the `"Hello World!"`
    text view that was automatically generated when we created the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For completeness, also delete the `"Hello World!"` string resource in the `res/value/strings.xml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `styles.xml` (v21) file and create a `colors.xml` file to implement
    a Material Design color scheme, as we did in the last chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Gradle Scripts/build.gradle (Module: app)` file from the project
    explorer:![Adding a CardView widget](img/B04321_03_01.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `dependencies` section to match the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Synchronize the project via the toolbar icon shown here:![Adding a CardView
    widget](img/B04321_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `app/res/values/dimens.xml` and add the following three new dimension
    resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `activity_main.xml` file from `app/res/layout` and add the following
    `CardView` code, so that the finished layout looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created this project in very much the same way we did the last, and it is
    very useful to have initial activity and layout files created for us; this can
    save us a lot of time, when setting up most new projects.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, `CardView` is not a part of the standard libraries, which
    is why we had to include it in a build file, and we will have to do the same thing
    when we apply the other new Lollipop widget, `RecyclerView`. It is because of
    this that we had to **Synchronize** the project again, so that the build engine
    knows what libraries to load, in very much the same way that one might import
    a Java library. In this case, we could have just rebuilt the project from the
    **Build** | **Rebuild Project** menu item, but this won't always be the case,
    and it is a good idea to get into the habit of a full synchronization, as this
    not only rebuilds our project but also checks for other possible errors such as
    missing resource definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, when we added values to the `dimens.xml` file, there is also a `dimens.xml
    (w820dp)` file. This is used when designing layouts for tablets and devices wider
    than 820 pixels, where the margins and padding we set for smaller devices might
    look wrong.
  prefs: []
  type: TYPE_NORMAL
- en: It will be immediately evident from examining the XML code for the `CardView`,
    that it is implemented in quite a different way from the widgets we have dealt
    with so far. Including elements from an external library like this is very straightforward,
    and although we will not be covering it in this book, it is useful to know that
    there are a number of third-party libraries available that include many features
    otherwise unavailable through the standard SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CardView` comes with two properties exclusive to Lollipop that we have
    not yet come across: `cardCornerRadius` and `cardElevation`. The purpose of these
    properties is obvious, but it is worth noting that the effect of changing them
    does not show in the preview pane and that increasing elevation only affects the
    widget''s shadow but not its size.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a CardView widget](img/B04321_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Having created a `CardView` as a container, it's now time to provide it with
    some content.
  prefs: []
  type: TYPE_NORMAL
- en: Adding images and text to the layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now use our `CardView` to display some basic information, namely a photo,
    a title and a short piece of text. To do this, you will need to locate where the
    studio stores your project files. This directory will be called `AndroidStudioProjects`
    and will more than likely be located in your Home directory or your specified
    save location.
  prefs: []
  type: TYPE_NORMAL
- en: Locate your `AndroidStudioProjects` directory, and open the `\StonehengeGuide\app\src\main\res\drawable`
    folder. This can be done by right-clicking on the drawable in the project explorer
    and selecting **Show in Explorer** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find an image and save it in the `drawable` directory. Any image will do; the
    one I use here is called `stonehenge.png` and is roughly 640 x 480 pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your `res/values/strings.xml` file and add the following strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `res/values/dimens.xml` file and add the following dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to place a `RelativeLayout` inside our `CardView`. This is not possible
    from graphic design mode, so drag a `RelativeLayout` anywhere on the screen and
    then edit the XML code so that the card looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will populate this `RelativeLayout` with a `FrameLayout` containing
    an `ImageView` and two TextViews, so that it looks like this:![Adding images and
    text to the layout](img/B04321_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The best way to demonstrate the other settings and properties is with the full
    code for the `RelativeLayout` inside the `CardView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we saw, any image file placed within a `drawable` directory in our project,
    becomes accessible to us in the same way that other resources do. Images placed
    in this folder will be available to our apps, regardless of the device they are
    running on. You will have noticed that there are four other drawable directories,
    such as the `drawable-xxhdpi` folder. Theses are particularly useful when it comes
    to building apps to run on a wide variety of screen densities for two reasons.
    Firstly, they allow us to include high-quality images for users whose devices
    support such screens, and secondly, they can save memory on devices that have
    lower screen densities as Android only loads images that can be supported by each
    particular physical screen.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the layout features we encountered here we already met in the previous
    chapters and there is not much to explain, other than perhaps the `ImageView`.
    It is worth noting that, as well as using `android:src` to associate our photo
    with the `ImageView`, we could also have used `android:background`, which performs
    a very similar function, although it does not respect the original aspect ratio
    of the image. Having created our Layout, we can now move on to adding another
    Activity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a second Activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our app does nothing other than display information. So, next we will
    add some functionality by making it so that, when the user taps the image, a larger
    version of the picture will be shown in an another Activity. As you will see,
    creating new Activities with the Android Studio is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the Java node of the project explorer and select **New** | **Activity**
    | **Blank Activity**.![Creating a second Activity](img/B04321_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the resultant wizard, enter `ImageActivity` as the **Activity Name:**, `activity_image`
    as the **Layout Name:**, `image_menu` as the **Menu Resource Name**, and leave
    **Title:** as it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `activity_image.xml` file and place a single `ImageView` inside the
    layout, as below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following string resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `MainActivity` Java file and add the following code under the line
    `setContentView(R.layout.activity_main);` in the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `ImageActivity` Java file and add the following public method to the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app on a device or an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new Activity wizard conveniently created both a Java Activity and a Layout
    XML file for us, but it is not always necessary to have a `Layout` file associated
    with every Activity. Often we can use the same layout for many Activities, providing
    each Java Activity has a way of selecting which data to access and display.
  prefs: []
  type: TYPE_NORMAL
- en: Without us realizing it, when we created our new Activity, the wizard also modified
    the manifest file to include the new Activity. It is worth taking a look at, because
    there will be times when you will not use the wizard to create an Activity and
    in such cases it will be necessary to modify the `AndroidManifest.xml` file by
    hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our second Activity's Layout file contains just a single view, but there is
    a significant difference from the views we've explored so far, and this is the
    use of the `android:onClick` property. Previously we have used `View.OnClickListener()`
    to control how a widget behaves when clicked on. Declaring this in XML offers
    us an alternative way of doing this and although it lacks some of the flexibility
    of the Java version, it is simple and quick to use. All we had to do was declare
    the method called when the widget is clicked on and then add that method in Java,
    which here we called `returnToMainActivity()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapters, we had the user click on a `Button` widget and, although
    this seems like an obvious choice, it is well worth noting that almost any view
    or widget can respond to click events.
  prefs: []
  type: TYPE_NORMAL
- en: The `StartActivity()` method takes an `Intent` as its argument. This is a vital
    object in any Android app and is worth taking a quick look at, as it is not only
    essential when working with Activities but also services and broadcasts, which
    form the other two main components of most apps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Services** are similar to threads and run in the background and **Broadcasts**
    are system-wide messages that can potentially be received and acted upon by any
    app.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intents** are basically descriptions of the operations we want our app to
    perform. They are formed of two parts, and action and the data to be acted upon.
    There are several `Intent()` constructors and here, we used `Intent(String action,
    Uri data)`. Being able to start one Activity from another is useful in many situations
    and here we set it in motion with a method, called by a click. There is of course,
    another familiar input feature that is found in nearly every mobile app, the menu,
    which is what we will look at next.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using two or more Activities to create separate screens is a straightforward
    way to include multiple pages in our apps. However, it is not the only method,
    and the system also provides the **Fragment** classes. Fragments are similar to
    ViewGroups; in that they exist as part of an Activity, but the way that they are
    created and destroyed makes them behave more like mini Activities. Unlike Activities,
    we can also have more than one Fragment to a screen.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to deploy Fragments in an Android app. Firstly they can be
    added directly to our layout XML files with the `<fragment>` tag and they can
    also be added and removed dynamically at run time. Although we will now look at
    both these techniques, it is the second, dynamic method that makes Fragments so
    flexible and useful.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the usual main Activity layout and code, each Fragment also has an
    XML and a Java component, making the coding a little more complex than when working
    with Activities alone. In the following exercise, we will create a simple app
    that lets us add and replace fragments during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Android Studio project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Blank Activity** template (not **Blank Activity with Fragment**),
    call the project `Fragment Example`, or something like that, and open the `activity_main.xml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change from a `RelativeLayout` to a `Linear` one by editing the code directly.
    The editor should change the closing tag to match as you type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set a vertical orientation for the layout with this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `TextView` with these two buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the line `android:text="Analog";` an amber quick fix will appear in
    the gutter, like below:![Applying Fragments](img/B04321_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on it select **Extract string resource**, and in the resultant dialog
    name the string `button_analog_text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same with the other button, calling it `button_digital_text`, and beneath
    these buttons add this `FrameLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the `layout` folder in the project explorer and select **New**
    | **New resource file**. Call it `fragment_analog` and give it a `RelativeLayout`
    root element, as follows:![Applying Fragments](img/B04321_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file and insert this `AnalogClock` inside the root element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select `fragment_analog.xml` in the project explorer and create a copy with
    *Ctrl* + *C* and *Ctrl* + *V*, naming the copy `fragment_digital.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this new file, replace the `AnalogClock` with this `TextClock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Locate and select the folder that contains your `MainActivity.java` file in
    the project explorer. It will have the same name as your package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From its context menu, select **New** | **Java Class** and call it `FragmentAnalog`.
    Fill out the class like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make a copy of this file and call it `FragmentDigital.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change only the layout reference in the return statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `MainActivity.java` file and change the class declaration so that
    it implements a click listener, like below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate an error and a red quick fix. Select **Implement methods**
    to add the `onClick()` method to the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add these `Button` fields to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include these four lines at the end of the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the `onClick()` method like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `replaceFragment()` method like below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now run the app on a device or an emulator.![Applying Fragments](img/B04321_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We started this exercise by creating a simple layout, but we also used a handy
    shortcut to avoid having **hardcoded** strings in our layouts. Doing this makes
    creating translated versions of our apps very simple and saves a lot of work when
    creating alternative layouts. It is not necessary for exercises such as those
    in this book to follow this practice, and to save time we will not concern ourselves
    with it further.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Translations Editor can be opened by right-clicking on the `res/values/strings.xml`
    file in the project explorer and selecting **Open Translation Editor (Preview)**.
    This editor makes translating Android apps very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: We also added an empty **FrameLayout** to serve as the container for our fragments
    we could have used any ViewGroup, but the FrameLayout is the simplest. Fragments
    are like Activities in that they have both an XML and a Java component, and here
    we created two very simple fragments just to see how they can be included and
    replaced dynamically. Fragments can of course contain many widgets and views,
    all of which can be interacted with in the usual ways and controlled with code
    in their respective Java files. Fragments, like Activities, have a life cycle
    and associated callbacks like the `onCreate()` method, and here we used `onCreateView()`,
    which is called when an attempt to inflate the Fragment is made. It is important
    to note that, although Fragments can, and usually do, contain all kinds of code,
    they should not communicate directly with each other. This should be done from
    the Activity containing them.
  prefs: []
  type: TYPE_NORMAL
- en: You will have noticed, that the way we implemented our **OnClickListener** here
    differed from the way we did in the previous chapter, where we implemented it
    directly on the view to be clicked on. Here, the OnClickListener is part of the
    whole class. This method is generally preferred and despite the small amount of
    extra work required to calculate which widget was clicked on, it is usually a
    far tidier solution, especially for very complex and interactive layouts.
  prefs: []
  type: TYPE_NORMAL
- en: '**FragmentManager** and **FragmentTransaction** are the tools we use to directly
    manipulate our Fragments. The first two lines, where these are defined, set the
    transaction in process, although no action is taken until `commit()` is called.
    We called `replace(layout, fragment)` to switch between our displays but we could
    also have used `add()` with the same arguments or `remove()` with only the Fragment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `addToBackStack()` is very important as, without it, a user pressing
    the back button on their device will be taken back to the previous Activity and
    not the previous Fragment, which, most of the time, will be what we want. Another
    interesting note is that the manager and transaction commands can be chained,
    and if we wanted we could replace all six lines with just this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The fade transition was not strictly necessary, as the system usually handles
    transitions between Activities and Fragments intelligently, but here there would
    have been none. There is a lot more that can be done with the FragmentManager
    and FragmentTransaction and the full documentation can be found at [developer.android.com/reference/android/app/FragmentManager.html](http://developer.android.com/reference/android/app/FragmentManager.html)
    and [developer.android.com/reference/android/app/FragmentTransaction.html](http://developer.android.com/reference/android/app/FragmentTransaction.html).
    Next, we need to take a look at another way to apply Fragments in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Adding static Fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot complete this introduction to Fragments without looking quickly at
    the other way that they can be implemented, as static layouts defined as `<fragment>`
    tags in XML files. Although these Fragments lack the flexibility of the dynamic
    sort we just encountered, they are nevertheless extremely useful, in particular
    when it comes to complex multi-pane apps where different Fragments perform very
    different functions. Not only does this help keep our code organized, it is also
    far less resource-hungry than a complicated network of nested ViewGroups.
  prefs: []
  type: TYPE_NORMAL
- en: To best see how this is done, start a project using the **Blank Activity with
    Fragment** template and take a look at the `activity_main.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates how a static Fragment can be included in a standard layout
    file. It shows which layout is to be inflated inside it with `tools:layout` and
    which Java class controls it with `android:name`. Several Fragments can be combined
    this way, along with ViewGroups and Views to create complex Activities.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth taking a look at both Java classes and the other XML file in this
    template, to see how the other components work. You will be familiar now with
    most of it, due to the work we have just completed. Do not close the project just
    for now, as we are going to use it to see how to add a menu.
  prefs: []
  type: TYPE_NORMAL
- en: Adding menus and toolbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly all mobile apps contain some form of global menu that provides access
    to functions required throughout the app. Menus can be opened in several ways
    on Android apps, but most commonly used is the **Options menu** which is accessed
    from the toolbar or action bar. Options menu items can also appear on the toolbar,
    as text or graphically.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a basic drop-down toolbar menu to implement the functions
    currently provided by the two buttons. Open the project from the **Fragments**
    section and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `res/menu/menu_main.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing `<item>` tag with these three:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Menus can be previewed in the same way as the layouts, by opening the preview
    pane:![Adding menus and toolbars](img/B04321_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainActivity` file and locate the `onOptionsItemSelected()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rewrite it to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app on a device and use the menu to open date, locale, and volume settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding menu items to the menu XML files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each item requires a title and an ID. We can change the order the items appear
    in with the `orderInCategory` attribute with ascending integer values ordering
    items from top to bottom (and left to right on the toolbar). Menu items can be
    categorized and ordered separately by nesting them inside `<group>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sub-menus can be created by embedding a `<menu>` tag, with its own items inside
    an `<item>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see shortly, menu items can be displayed on the toolbar in the same
    way they were on the Action bar in versions of Android older that API 21\. This
    can be done with the `showAsAction` attribute; if you still have the project open,
    it is worth running the app again with this value set to `always` and `ifRoom`,
    to see the effect this has. Doing this simply moves our menu options to the bar,
    but we can also use icons to represent our options; this, along with the new features
    of the Android 5 toolbar, is what we will explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As already mentioned, Android 5 introduced a replacement for the Action bar
    at the top of many app screens: the toolbar. The toolbar does performs all the
    same functions as its predecessor, such as displaying menu options and other frequently
    performed actions, but is far more customizable. Most interestingly, the toolbar
    can now be placed anywhere on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: In this next exercise, we will add our menus to the toolbar as icons; include
    navigation, logo, and titles on the toolbar; and then place it at the bottom of
    our screen.
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar icons need to comply with some specific material design guidelines,
    a complete guide to which can be found at [http://www.google.com/design/spec/style/icons.html](http://www.google.com/design/spec/style/icons.html).
    Basically, they need to be simple, single-color symbols on a transparent background.
    To begin with, you can download purpose-built system icons for specific screen
    densities from [http://www.google.com/design/icons/](http://www.google.com/design/icons/).
    Below are the three that were download for this project, along with the names
    used in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the toolbar](img/B04321_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Download or find something similar of a pixel density that is suitable for
    the devices you are developing for. Then carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project we were just working on and copy your icons into the `drawable`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `menu_main.xml` file and add the following line into the `menu_date`
    item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do the same for the location and sleep icons in their respective item tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change all three items' `android:showAsAction` attribute from `"never"` to `"ifRoom"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wish to see how your brand colors will appear against your action icons,
    apply a material theme as we have before, and run the app to see how your icons
    look.![Configuring the toolbar](img/B04321_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the `main_activity.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert this `Toolbar` above the two buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `res/values/styles/styles.xml (v21)` file and edit the `AppTheme`
    definition like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will need another image for the logo here. This does not have to be plain
    and simple but should not contain text, and it should be around 96 x 96 px, depending
    on your device's pixel density. If you want to save time, use one of the other
    images in the `setLogo()` command in step 11.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainActivity` file and add this field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add these lines to the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `activity_main.xml` file, remove the padding from the root layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it. You can now run the app, with an output something like this:![Configuring
    the toolbar](img/B04321_03_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding option menu items to the action bar is done simply by setting `showAsAction`
    to `ifRoom` or `always`, and we could have included both text and icon with `withText`.
    This provides a handy way to present options to the user, but it is transformed
    into a far more powerful tool once we can define it in a layout and refer to it
    from Java. This means we can place it anywhere on our screen and place anything
    inside it. We could add an `ImageView` or `Button`, simply by adding that element
    inside the `Toolbar` element in XML. Once we have a reference in Java, we can
    add click listeners or any other method, just as we can with other components.
  prefs: []
  type: TYPE_NORMAL
- en: We needed to remove the original action bar by changing the theme to `Material.Light.NoActionBar`,
    although we could have kept it and added a toolbar and of course, we can have
    two or more toolbars, perhaps even contained in a `Fragment` and replacing each
    other to create a more dynamic interface. We also had to remove padding from the
    parent layout, so as to have it plush to the edges like a traditional action bar
    and we set its elevation so that it looks like the action bar we are used to.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter, starting with an introduction to the
    `CardView` widget and the new features incorporated in Android 5, such as the
    ability to elevate it and other views so that they appear to float above the screen.
    We saw how to add image files to a project and how we can optimize such images
    so as to efficiently match the screen density of the user's device. We saw how
    to include new Activities and how to use XML (as well as Java) to control how
    widgets and views behave when clicked on. The chapter also covered one of the
    many ways that Activities can communicate with one another.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to explore another way to add flexibility to our apps with the `Fragment`
    classes which have much of the functionality of Activities but can be combined
    in one layout and treated like ViewGroups.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we investigated the relationship between **Options menu** and the action
    bar and saw how the toolbar introduced in Android 5 can be thought of as a part
    of our activity rather than a fixed widget stuck to the top of it.
  prefs: []
  type: TYPE_NORMAL
- en: Having grasped some of the more important fundamentals of Android programming,
    we can now go on to consider how to build more sophisticated apps that incorporate
    larger data sets, and how to utilize more of the technologies found in today's
    mobile devices.
  prefs: []
  type: TYPE_NORMAL
