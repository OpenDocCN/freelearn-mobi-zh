<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor112" class="calibre3 pcalibre pcalibre1"/>9</h1>
<h1 id="_idParaDest-101" class="calibre6"><a id="_idTextAnchor113" class="calibre3 pcalibre pcalibre1"/>Runtime Permissions</h1>
<p class="calibre4">As we build our Android apps, there are some functionalities that require permissions to be granted for them to function properly. Due to privacy and data security policies, we as developers can not automatically grant permissions to the apps that we develop. We need to inform the users of the permissions that the apps need and why they need them.</p>
<p class="calibre4">In this chapter, we will understand runtime permissions and how to request them in our app.</p>
<p class="calibre4">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre16">
<li class="calibre15">Understanding runtime permissions</li>
<li class="calibre15">Requesting permissions at runtime</li>
</ul>
<h1 id="_idParaDest-102" class="calibre6"><a id="_idTextAnchor114" class="calibre3 pcalibre pcalibre1"/>Technical requirements</h1>
<p class="calibre4">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1">https://developer.android.com/studio</a>) downloaded.</p>
<p class="calibre4">You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine" class="calibre3 pcalibre pcalibre1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine</a>.</p>
<h1 id="_idParaDest-103" class="calibre6"><a id="_idTextAnchor115" class="calibre3 pcalibre pcalibre1"/>Understanding runtime permissions</h1>
<p class="calibre4"><code>requestPermissions()</code> and <code>checkSelfPermission()</code>. The user only needs to grant permission once during the lifetime of the app.</p>
<p class="calibre4">Some of the features that need permission to be granted to work are camera, location, microphone and storage. Before using them, ensure that a user has permission to use them. If the user has not granted permission, you must request it from them. If the user has denied the permission, you must show a dialog explaining why you need it and ask the user to grant it from the settings. If the user has granted permission, you can use the feature. Failing to do these checks often results in an app crashing or a feature not working. If your app targets <a id="_idIndexMarker463" class="calibre3 pcalibre pcalibre1"/>Android 6.0 and above, you must request these permissions at runtime, and the user must grant the permission for the app to work.</p>
<p class="calibre4">The flow for requesting<a id="_idIndexMarker464" class="calibre3 pcalibre pcalibre1"/> permissions is shown in the following chart:</p>
<div><div><img alt="Figure 9.1 – The runtime permissions flow" src="img/B19779_09_01.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The runtime permissions flow</p>
<p class="calibre4">As shown in the preceding diagram, this is the flow:</p>
<ol class="calibre14">
<li class="calibre15">The initial step is to <em class="italic">declare</em> the permission in the manifest file. This is done by adding the permission to the manifest file.</li>
<li class="calibre15">After adding the permission to the manifest file, we must <em class="italic">design the UX</em> for the feature that needs <a id="_idIndexMarker465" class="calibre3 pcalibre pcalibre1"/>the permission to be granted.</li>
<li class="calibre15">The next step is <em class="italic">waiting for the user to use</em> the feature that needs permission to be granted. At this point, we check whether the user has granted permission. If the user has granted permission, we proceed to use the feature.</li>
<li class="calibre15">If the user <em class="italic">has not granted permission</em>, we first check whether we need to <em class="italic">show a rationale</em> that explains why we need permission. If we need to show the rationale, we show it with explanations and then request permission from the user. If we do not need to show the rationale, we just request permission from the user.</li>
<li class="calibre15">Once the permission is requested, we wait for the <em class="italic">user to grant or deny</em> permission. If the user grants permission, we proceed to use the feature. If the user denies permission, we allow the app to work, but the user cannot use the feature that needs permission to work.</li>
</ol>
<p class="calibre4">With this flow in mind, let us look at how to implement it in code. We are going to request permission to access a location.</p>
<h1 id="_idParaDest-104" class="calibre6"><a id="_idTextAnchor116" class="calibre3 pcalibre pcalibre1"/>Requesting permissions at runtime</h1>
<p class="calibre4">We will follow the<a id="_idIndexMarker466" class="calibre3 pcalibre pcalibre1"/> steps covered in <em class="italic">Figure 9</em><em class="italic">.1</em> to request runtime permissions for our app:</p>
<ol class="calibre14">
<li class="calibre15">Let us start by adding the permission to the manifest file. We will request permission to access the user’s location. To do this, we add the following permission to the manifest file:<pre class="source-code">
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;</pre><p class="calibre4">This specifies that our app will be using the <code>ACCESS_COARSE_LOCATION</code> permission. Declaring permissions in the manifests is crucial for enhancing security, user awareness, and overall app compatibility. By explicitly specifying the actions or resources apps require access to permissions informs users during installations, allowing them to make informed decisions about granting or denying access. This declaration ensures compatibility across different Android versions and devices, facilitates inter-app communication, and supports intent filtering to control <a id="_idIndexMarker467" class="calibre3 pcalibre pcalibre1"/>component access. Permissions also play a role in runtime permission requests for dangerous permissions and help maintain platform compatibility. Additionally, Play Store reviews declare permissions as part of the submission process, contributing to adherence to policies and guidelines. In essence, manifest-based permission declarations are fundamental for creating secure, transparent, and user-controlled environments in our apps.</p><p class="calibre4">The next thing is to create the UX for the feature that needs permission. We will create a dialog to request permissions from the user. It will also have the logic that shows the rationale to the user if permission was previously denied.</p></li> <li class="calibre15">Let’s create a new file in the <strong class="source-inline1">view</strong> package named <strong class="source-inline1">PermissionDialog.kt</strong> and add the utility functions to the file:<pre class="source-code">
fun checkIfPermissionGranted(context: Context, permission: String): Boolean {
    return (ContextCompat.checkSelfPermission(context, permission)
            == PackageManager.PERMISSION_GRANTED)
}
fun shouldShowPermissionRationale(context: Context, permission: String): Boolean {
    val activity = context as Activity?
    if (activity == null)
        Log.d("Permissions", "Activity is null")
    return ActivityCompat.shouldShowRequestPermissionRationale(
        activity!!,
        permission
    )
}</pre><p class="calibre4">The first function checks whether the permission has been granted using the <code>ContextCompat.checkSelfPermission()</code> function. The second function checks whether <a id="_idIndexMarker468" class="calibre3 pcalibre pcalibre1"/>we need to show the rationale to the user. This is done using the <code>ActivityCompat.shouldShowRequestPermissionRationale()</code> function. This function returns <code>true</code> if the app has requested this permission previously and the user denied the request. If the user turned down the permission request in the past and chose the <code>false</code>.</p><p class="calibre4">Next, let us create a sealed class that will be used to represent the state of the permission request.</p></li> <li class="calibre15">Create a new file named <strong class="source-inline1">PermissionAction.kt</strong> in the <strong class="source-inline1">data</strong> package, and add the following code to the file:<pre class="source-code">
sealed class PermissionAction {
    data object PermissionGranted : PermissionAction()
    data object PermissionDenied : PermissionAction()
}</pre><p class="calibre4">The class has two states, <code>PermissionGranted</code> and <code>PermissionDenied</code>. A user can either grant or deny permission.</p></li> <li class="calibre15">Next, let us create <a id="_idIndexMarker469" class="calibre3 pcalibre pcalibre1"/>the dialog that will be used to request permission from the user. Head back to the <strong class="source-inline1">PermissionDialog.kt</strong> file and add the following code to the file:<pre class="source-code">
@Composable
fun PermissionDialog(
    context: Context,
    permission: String,
    permissionAction: (PermissionAction) -&gt; Unit
) {
    val isPermissionGranted = checkIfPermissionGranted(context, permission)
    if (isPermissionGranted) {
        permissionAction(PermissionAction.PermissionGranted)
        return
    }
    val permissionsLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean -&gt;
        if (isGranted) {
            permissionAction(PermissionAction.PermissionGranted)
        } else {
            permissionAction(PermissionAction.PermissionDenied)
        }
    }
    val showPermissionRationale = shouldShowPermissionRationale(context, permission)
    var isDialogDismissed by remember { mutableStateOf(false) }
    var isPristine by remember { mutableStateOf(true) }
    if ((showPermissionRationale &amp;&amp; !isDialogDismissed) || (!isDialogDismissed &amp;&amp; !isPristine)) {
        isPristine = false
        AlertDialog(
            onDismissRequest = {
                isDialogDismissed = true
                permissionAction(PermissionAction.PermissionDenied)
            },
            title = { Text(text = "Permission Required") },
            text = { Text(text = "This app requires the location permission to be granted.") },
            confirmButton = {
                Button(
                    onClick = {
                        isDialogDismissed = true
                        permissionsLauncher.launch(permission)
                    }
                ) {
                    Text(text = "Grant Access")
                }
            },
            dismissButton = {
                Button(
                    onClick = {
                        isDialogDismissed = true
                        permissionAction(PermissionAction.PermissionDenied)
                    }
                ) {
                    Text(text = "Cancel")
                }
            }
        )
    } else {
        if (!isDialogDismissed) {
            SideEffect {
                permissionsLauncher.launch(permission)
            }
        }
    }
}</pre><p class="calibre4">Let’s break down the preceding code:</p><ul class="calibre17"><li class="calibre15">We have created a composable, <code>PetsScreen</code> composable.</p></li> <li class="calibre15">Let’s head to the <strong class="source-inline1">PetsScreen.kt</strong> file and modify it to the following:<pre class="source-code">
@Composable
fun PetsScreen(
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    val context = LocalContext.current
    var showContent by rememberSaveable { mutableStateOf(false) }
    PermissionDialog(
        context = context,
        permission = Manifest.permission.ACCESS_COARSE_LOCATION
    ) { permissionAction -&gt;
        when (permissionAction) {
            is PermissionAction.PermissionDenied -&gt; {
                showContent = false
            }
            is PermissionAction.PermissionGranted -&gt; {
                showContent = true
                Toast.makeText(
                    context,
                    "Location permission granted!",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
    }
    if (showContent) {
        PetsScreenContent(
            modifier = Modifier
                .fillMaxSize(),
            onPetClicked = onPetClicked,
            contentType = contentType,
            petsUIState = petsUIState,
            onFavoriteClicked = {
                petsViewModel.updatePet(it)
            }
        )
    }
}</pre><p class="calibre4">We have only made a few changes to this file:</p><ul class="calibre17"><li class="calibre15">First, we have added a <strong class="source-inline1">showContent</strong> mutable state that is used to check whether we should show the content of the screen. We have also set the initial value of the state to <strong class="source-inline1">false</strong>. We will use this state to show the content of the screen if<a id="_idIndexMarker472" class="calibre3 pcalibre pcalibre1"/> the user grants permission. We also have the <strong class="source-inline1">context</strong> variable used to get the screen’s context.</li><li class="calibre15">We have also added the <strong class="source-inline1">PermissionDialog</strong> composable to the <strong class="source-inline1">PetsScreen</strong> composable. We have passed the context and the permission – in this case, the <strong class="source-inline1">ACCESS_COARSE_LOCATION</strong> permission – to the composable. We have also passed a callback to the composable that is used to get the state of the permission request. If the user grants the permission, we set the <strong class="source-inline1">showContent</strong> state to <strong class="source-inline1">true</strong> and show a toast with the <strong class="bold">Location permission granted</strong> message. If the user denies the permission, we set the <strong class="source-inline1">showContent</strong> state to <strong class="source-inline1">false</strong>.</li><li class="calibre15">Lastly, we have added a check to see whether the <strong class="source-inline1">showContent</strong> state is <strong class="source-inline1">true</strong>. If the state is <strong class="source-inline1">true</strong>, we show the content of the screen. If the state is <strong class="source-inline1">false</strong>, we do not show the content of the screen.</li></ul></li> <li class="calibre15">Build and run the app. At first, we<a id="_idIndexMarker473" class="calibre3 pcalibre pcalibre1"/> will see the permission dialog, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 9.2 – The permission dial﻿og" src="img/B19779_09_02.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The permission dial<a id="_idTextAnchor117" class="calibre3 pcalibre pcalibre1"/>og</p>
<ol class="calibre14">
<li value="7" class="calibre15">Tap the <strong class="bold">Don’t allow</strong> option, which will show an empty white screen, since we don’t show any content when the user has not granted the app permission.</li>
</ol>
<div><div><img alt="Figure 9.3 – The no permission screen" src="img/B19779_09_03.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The no permission screen</p>
<p class="calibre4">The next time we run the<a id="_idIndexMarker474" class="calibre3 pcalibre pcalibre1"/> app, we will see the rationale dialog showing why the app needs permission.</p>
<div><div><img alt="Figure 9.4 – The permission rationale" src="img/B19779_09_04.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The permission rationale</p>
<p class="calibre4">On this rationale dialog, we can either cancel the request or grant access. Tapping the <strong class="bold">Grant Access</strong> option should bring up the permission dialog shown in <em class="italic">Figure 9</em><em class="italic">.2</em>, and by tapping the <strong class="bold">While using the app</strong> option, we grant the app the location <a id="_idIndexMarker475" class="calibre3 pcalibre pcalibre1"/>permission, and now, we should be able to see the list of cute cats o<a id="_idTextAnchor118" class="calibre3 pcalibre pcalibre1"/>nce again. Running the app again does not show the dialogs, since we have already granted the app the location permission.</p>
<div><div><img alt="Figure 9.5 – Cute cats" src="img/B19779_09_05.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Cute cats</p>
<h1 id="_idParaDest-105" class="calibre6"><a id="_idTextAnchor119" class="calibre3 pcalibre pcalibre1"/>Summary</h1>
<p class="calibre4">In this chapter, we explored what runtime permissions are and why we should declare and request permissions in our apps. Step by step, we learned how to request runtime permissions in our app and how to show permission rationale dialogs, explaining to users why we need access to runtime permissions in cases where they have denied apps access to permissions.</p>
<p class="calibre4">In the next chapter, we will learn debugging tips and tricks, how to detect leaks using LeakCanary, how to inspect HTTPS requests/responses fired by our app using Chucker, and how to inspect the Room database.</p>
</div>
</body></html>