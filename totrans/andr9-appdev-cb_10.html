<html><head></head><body>
        

                            
                    <h1 class="header-title">Graphics and Animation</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Scaling down large images to avoid Out of Memory exceptions</li>
<li>A transition animation: Defining scenes and applying a transition</li>
<li>Creating a Compass using sensor data and RotateAnimation</li>
<li>Creating a slideshow with ViewPager</li>
<li>Creating a Card Flip Animation with Fragments</li>
<li>Creating a Zoom Animation with a Custom Transition</li>
<li>Displaying an animated image (GIF/WebP) with the new ImageDecoder library</li>
<li>Creating a circle image with the new ImageDecoder</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Animations can be both visually appealing and functional, as demonstrated with the simple button press. The graphical representation of the button press brings the app alive, plus it provides a functional value by giving the user a visual response to the event.</p>
<p>The Android Framework provides several animation systems to make it easier to include animations in your own application. They include the following:</p>
<ul>
<li><strong>View Animation </strong>(the original animation system): It usually requires less code but has limited animation options</li>
<li><strong>Property Animation</strong>: It's a more flexible system, allowing the animation of any property of any object</li>
<li><strong>Drawable Animation</strong>: It uses drawable resources to create frame-by-frame animations (like a movie)</li>
</ul>
<p>The Property Animation system was introduced in Android 3.0, and it is usually preferred over the View Animation because of the flexibility. The main drawbacks to the View Animation include the following:</p>
<ul>
<li>Limited aspects of what can be animated, such as scale and rotation</li>
<li>Can only animate the contents of the view; it cannot change where on the screen the view is drawn (so it cannot animate moving a ball across the screen)</li>
<li>Can only animate View objects</li>
</ul>
<p>Here is a simple example demonstrating a View Animation to "blink" a view (a simple simulation of a button press):</p>
<pre>Animation blink =AnimationUtils.loadAnimation(this,R.anim.blink); 
view.startAnimation(blink); </pre>
<p>Here are the contents for the <kbd>blink.xml</kbd> resource file, located in the <kbd>res/anim</kbd> folder:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;set &gt; 
    &lt;alpha android:fromAlpha="1.0" 
        android:toAlpha="0.0" 
        android:background="#000000" 
        android:interpolator="@android:anim/linear_interpolator" 
        android:duration="100" 
        android:repeatMode="restart" 
        android:repeatCount="0"/&gt; 
&lt;/set&gt; </pre>
<p>As you can see, it's very simple to create this animation, so if the View Animation accomplishes your goal, use it. When it doesn't meet your needs, turn to the Property Animation system. We'll demonstrate Property Animation using the new <kbd>objectAnimator</kbd> in the <em>Creating a Card Flip Animation with Fragments</em> and <em>Creating a Zoom Animation with a Custom Transition</em> recipes.</p>
<p>The <em>A transition animation – defining scenes and applying a transition</em> recipe will provide additional information on the Android Transition Framework, which we will use in many of the recipes.</p>
<p>The Interpolator is a function that defines the rate of change for an animation.</p>
<p><kbd>Interpolators</kbd> will be mentioned in several recipes in this chapter, as well as in the previous blink example. The Interpolator defines how the transition is calculated. A Linear Interpolator will calculate the change evenly over a set duration, whereas an <kbd>AccelerateInterpolator</kbd> function would create faster movement for the duration. Here is the full list of <kbd>Interpolators</kbd> available, along with the XML identifier:</p>
<ul>
<li>AccelerateDecelerateInterpolator (<kbd>@android:</kbd>anim<kbd>/accelerate_decelerate_interpolator</kbd>)</li>
<li>AccelerateInterpolator (<kbd>@android:anim/accelerate_interpolator</kbd>)</li>
<li>AnticipateInterpolator (<kbd>@android:anim/anticipate_interpolator</kbd>)</li>
<li>AnticipateOvershootInterpolator (<kbd>@android:anim/anticipate_overshoot_interpolator</kbd>)</li>
<li>BounceInterpolator (<kbd>@android:anim/bounce_interpolator</kbd>)</li>
<li>CycleInterpolator (<kbd>@android:anim/cycle_interpolator</kbd>)</li>
<li>DecelerateInterpolator (<kbd>@android:anim/decelerate_interpolator</kbd>)</li>
<li>LinearInterpolator (<kbd>@android:anim/linear_interpolator</kbd>)</li>
<li>OvershootInterpolator (<kbd>@android:anim/overshoot_interpolator</kbd>)</li>
</ul>
<p>Although animations don't generally require much memory, the graphic resources often do. Many of the images you may want to work with often exceed the available device memory. In the first recipe of this chapter, <em>Scaling down large images to avoid Out of Memory exceptions</em>, we'll discuss how to subsample (or scale down) images.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scaling down large images to avoid Out of Memory exceptions</h1>
                
            
            
                
<p>Working with images can be very memory intensive, often resulting in your application crashing with an <em>Out of Memory</em> exception. This is especially true with pictures taken with the device camera, as they often have a much higher resolution than the device itself.</p>
<p>Loading a higher resolution image than the UI supports doesn't provide any visual benefit to the user. In this example, we'll demonstrate how to take smaller samples of the image for display. We'll use <kbd>BitmapFactory</kbd> to first check the image size, then load a scaled-down image.</p>
<p>Here's a screenshot from this recipe showing a thumbnail of a very large image:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b2913624-48e4-4b0d-ab2c-50d09ed1a42e.png" style="width:20.42em;height:40.67em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>LoadLargeImage</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>
<p>We'll need a large image for this recipe. We turned to Unsplash.com to download a free image, (<a href="https://unsplash.com">https://unsplash.com</a>), although any large (multi-megabyte) image will do.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>As mentioned in <em>Getting ready</em>, we need a large image to demonstrate the scaling. Once you have the image, follow these steps:</p>
<ol>
<li>Copy the image to your <kbd>res/drawable</kbd> folder.</li>
<li>Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>TextView</kbd> with the following <kbd>ImageView</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.AppCompatImageView<br/>    android:id="@+id/imageViewThumbnail"<br/>    android:layout_width="100dp"<br/>    android:layout_height="100dp"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="3">
<li>Now, open <kbd>MainActivity.java</kbd> and add this method, which we'll explain shortly:</li>
</ol>
<pre style="padding-left: 60px">public Bitmap loadSampledResource(int imageID, int targetHeight, int targetWidth) {<br/>    final BitmapFactory.Options options = new BitmapFactory.Options();<br/>    options.inJustDecodeBounds = true;<br/>    BitmapFactory.decodeResource(getResources(), imageID, options);<br/>    final int originalHeight = options.outHeight;<br/>    final int originalWidth = options.outWidth;<br/>    int inSampleSize = 1;<br/>    while ((originalHeight / (inSampleSize *2)) &gt; targetHeight<br/>            &amp;&amp; (originalWidth / (inSampleSize *2)) &gt; targetWidth) {<br/>        inSampleSize *= 2;<br/>    }<br/>    options.inSampleSize = inSampleSize;<br/>    options.inJustDecodeBounds = false;<br/>    return BitmapFactory.decodeResource(getResources(), imageID, options);<br/>}</pre>
<ol start="4">
<li>Add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">AppCompatImageView imageView = findViewById(R.id.imageViewThumbnail);<br/>imageView.setImageBitmap(<br/>        loadSampledResource(R.drawable.miguel_henriques_789508_unsplash, 100, 100));</pre>
<ol start="5">
<li>Run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The purpose of the <kbd>loadSampledResource()</kbd> method is to load a smaller image, to reduce the memory consumption of the image. If we attempted to load the original full-size image (see the previous <em>Getting ready</em> section), the app would require over 3 MB of RAM to load. That's more memory than most devices can handle (at the moment anyway), and even if it could be loaded completely, it would provide no visual benefit to our thumbnail view.</p>
<p>To avoid an <kbd>Out of Memory</kbd> situation, we use the <kbd>inSampleSize</kbd> property of <kbd>BitmapFactory.Options</kbd> to reduce, or subsample, the image. (If we set the <kbd>inSampleSize=2</kbd>, it will reduce the image by half. If we use <kbd>inSampleSize=4</kbd>, it will<br/>
reduce the image by one quarter) To calculate <kbd>inSampleSize</kbd>, first, we need to know the image size. We can use the <kbd>inJustDecodeBounds</kbd> property as follows:</p>
<pre>options.inJustDecodeBounds = true; </pre>
<p>This tells <kbd>BitmapFactory</kbd> to get the image dimensions without actually storing the image contents. Once we have the image size, we calculate the sample using this code:</p>
<pre>while ((originalHeight / (inSampleSize *2)) &gt; targetHeight<br/>            &amp;&amp; (originalWidth / (inSampleSize *2)) &gt; targetWidth) {<br/>        inSampleSize *= 2;<br/>    }</pre>
<p>The purpose of this code is to determine the largest sample size that does not reduce the image below the target dimensions. To do that, we double the sample size and check whether the size exceeds the target size dimensions. If it doesn't, we save the doubled sample size and repeat. Once the reduced size falls below the target dimensions, we use the last saved <kbd>inSampleSize</kbd>.</p>
<p>From the <kbd>inSampleSize</kbd> documentation (link in the following <em>See also</em> section), note that the decoder uses a final value based on powers of 2, so any other value will be rounded down to the nearest power of 2.</p>
<p>Once we have the sample size, we set the <kbd>inSampleSize</kbd> property and set <kbd>inJustDecodeBounds</kbd> to <kbd>false</kbd>, to load normally. Here is the code:</p>
<pre>options.inSampleSize = inSampleSize; 
options.inJustDecodeBounds = false; </pre>
<p>It's important to note that this recipe illustrates the concept of applying the task to your own application. Loading and processing images can be a long operation, which can cause your application to stop responding. This is not a good thing and could cause Android to show the <strong>Application Not Responding</strong> (<strong>ANR</strong>) dialog. It is recommended to perform long tasks on a background thread to keep your UI thread responsive. The <kbd>AsyncTask</kbd> class is available for doing background network processing, but there are many other libraries available as well (links at the end of the recipe).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It's important to note that the <kbd>targetHeight</kbd> and <kbd>targetWidth</kbd> parameters we pass to the <kbd>loadSampledResource()</kbd> method do not actually set the image size. If you run the application using the same size image we used (4,000 x 6,000), the sample size will be 32, resulting in a loaded image size of 187 x 125.</p>
<p>If your layout needs a specific size of image, either set the size in the layout file, or you can modify the image size directly using the Bitmap class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Developer Docs: BitmapFactory.inSampleSize() at <a href="https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inSampleSize">https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inSampleSize</a></li>
<li>Refer to Glide at <a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a></li>
<li>Refer to Picasso from Square at <a href="https://square.github.io/picasso/">https://square.github.io/picasso/</a></li>
<li>Refer to Fresco from Facebook at <a href="https://github.com/facebook/fresco">https://github.com/facebook/fresco</a></li>
<li>Check the <em>AsyncTask</em> task in <a href="98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml">Chapter 15</a>, <em>Getting Your App Ready for the Play Store</em>, for processing long-running operations on a background thread.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">A transition animation – defining scenes and applying a transition</h1>
                
            
            
                
<p>The Android Transition Framework offers the following:</p>
<ul>
<li><strong>Group-level animations</strong>: Animation applies to all views in a hierarchy</li>
<li><strong>Transition-based animation</strong>: Animation based on starting and ending property change</li>
<li><strong>Built-in animations</strong>: Some common transition effects, such as fade-in/out<br/>
and movement</li>
<li><strong>Resource file support</strong>: Save animation values to a resource (XML) file to load<br/>
during runtime</li>
<li><strong>Lifecycle callbacks</strong>: Receive callback notifications during the animation</li>
</ul>
<p>A transition animation consists of the following:</p>
<ul>
<li><strong>Starting Scene</strong>: The view (or <kbd>ViewGroup</kbd>) at the start of the animation</li>
<li><strong>Transition</strong>: The change type (see later on)</li>
<li><strong>Ending Scene</strong>: The ending view (or <kbd>ViewGroup</kbd>)</li>
<li><strong>Transitions</strong>: Android provides built-in support for the following three transitions:
<ul>
<li><strong>AutoTransition (default transition)</strong>: Fade out, move, resize, then fade in (in that order)</li>
<li><strong>Fade</strong>: Fade in, fade out (default), or both (specify order)</li>
<li><strong>ChangeBounds</strong>: Move and resize</li>
</ul>
</li>
</ul>
<p>The Transition Framework will automatically create the frames needed to animate from the start to end scenes.</p>
<p>The following are some known limitations of the Transition Framework when working with the following classes:</p>
<ul>
<li><strong>SurfaceView</strong>: Animations may not appear correct since the <kbd>SurfaceView</kbd> animations are performed on a non-UI thread, so they may be out of sync with the application</li>
<li><strong>TextView</strong>: Animating text-size changes may not work correctly resulting in the text jumping to the final state</li>
<li><strong>AdapterView</strong>: Classes that extend <kbd>AdapterView</kbd>, such as <kbd>ListView</kbd> and <kbd>GridView</kbd>, may hang</li>
<li><strong>TextureView</strong>: Some transitions may not work</li>
</ul>
<p>This recipe provides a quick tutorial on using the transition animation system. We'll start by defining the scenes and transition resources, then applying the transition, which creates the animation. The following steps will walk you through creating the resources in XML, as they are generally recommended. Resources can also be created through code, which we'll<br/>
discuss in the <em>There's more</em> section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>TransitionAnimation</kbd>. In the Target Android Devices dialog, select the Phone &amp; Tablet option and choose API 19 (or above) for the Minimum SDK. Select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Here are the steps to create the resource files and apply the transition animation:</p>
<ol>
<li>Replace the existing <kbd>activity.main.xml</kbd> layout with the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;RelativeLayout  
     
    android:id="@+id/layout" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="Top" 
        android:id="@+id/textViewTop" 
        android:layout_alignParentTop="true" 
        android:layout_centerHorizontal="true" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="Bottom" 
        android:id="@+id/textViewBottom" 
        android:layout_alignParentBottom="true" 
        android:layout_centerHorizontal="true" /&gt; 
    &lt;Button 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="Go" 
        android:id="@+id/button" 
        android:layout_centerInParent="true" 
        android:onClick="goAnimate"/&gt; 
&lt;/RelativeLayout&gt; </pre>
<ol start="2">
<li>Create a new layout file called <kbd>activity_main_end.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;RelativeLayout  
     
    android:id="@+id/layout" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="Bottom" 
        android:id="@+id/textViewBottom" 
        android:layout_alignParentTop="true" 
        android:layout_centerHorizontal="true" /&gt; 
    &lt;TextView 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="Top" 
        android:id="@+id/textViewTop" 
        android:layout_alignParentBottom="true" 
        android:layout_centerHorizontal="true" /&gt; 
    &lt;Button 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:text="Go" 
        android:id="@+id/button" 
        android:layout_centerInParent="true"/&gt; 
&lt;/RelativeLayout&gt; </pre>
<ol start="3">
<li>Make a new transition resource directory (File | New | Android resource directory and choose Transition as the Resource type).</li>
</ol>
<ol start="4">
<li>Create a new file in the <kbd>res/transition</kbd> folder called <kbd>transition_move.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;changeBounds xmlns:android=<br/>     "http://schemas.android.com/apk/res/android" /&gt;</pre>
<ol start="5">
<li>Add the <kbd>goAnimate()</kbd> method using the following code:</li>
</ol>
<pre style="padding-left: 60px">public void goAnimate(View view) {<br/>    ViewGroup root = findViewById(R.id.layout);<br/>    Scene scene = Scene.getSceneForLayout(root, R.layout.activity_main_end, this);<br/>    Transition transition = TransitionInflater.from(this)<br/>            .inflateTransition(R.transition.transition_move);<br/>    TransitionManager.go(scene, transition);<br/>}</pre>
<ol start="6">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You probably find the code itself rather simple. As outlined in the recipe introduction, we just need to create the starting and ending scenes and set the transition type. Here's a detailed breakdown of the code:</p>
<ul>
<li>Creating the start Scene: The following line of code will load the Start Scene:</li>
</ul>
<pre style="padding-left: 60px">ViewGroup root = findViewById(R.id.layout); </pre>
<ul>
<li>Creating the transition: The following line of code will create the transition:</li>
</ul>
<pre style="padding-left: 60px">Transition transition = TransitionInflater.from(this)<br/>            .inflateTransition(R.transition.transition_move);</pre>
<ul>
<li>Defining the ending scene: The following line of code will define the ending scene:</li>
</ul>
<pre style="padding-left: 60px">Scene scene = Scene.getSceneForLayout(root, R.layout.activity_main_end, this);</pre>
<ul>
<li>Starting the transition: The following line of code will start the transition:</li>
</ul>
<pre style="padding-left: 60px">TransitionManager.go(scene, transition); </pre>
<p>Although simple, most of the work for this recipe was in creating the necessary resource files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Now, we'll take a look at creating this same transition animation with a code-only solution (although we'll still use the initial <kbd>activity_main.xml</kbd> layout file):</p>
<pre>ViewGroup root = findViewById(R.id.layout);<br/>Scene scene = new Scene(root);<br/><br/>Transition transition = new ChangeBounds();<br/>TransitionManager.beginDelayedTransition(root,transition);<br/><br/>TextView textViewTop = findViewById(R.id.textViewTop);<br/>RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams)textViewTop.getLayoutParams();<br/>params.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM,1);<br/>params.addRule(RelativeLayout.ALIGN_PARENT_TOP, 0);<br/>textViewTop.setLayoutParams(params);<br/><br/>TextView textViewBottom = findViewById(R.id.textViewBottom);<br/>params = (RelativeLayout.LayoutParams) textViewBottom.getLayoutParams();<br/>params.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM,0);<br/>params.addRule(RelativeLayout.ALIGN_PARENT_TOP, 1);<br/>textViewBottom.setLayoutParams(params);<br/><br/>TransitionManager.go(scene);</pre>
<p>We still need the starting and ending scene along with the transition; the only difference is how we create the resources. In the previous code, we created the Start Scene using the current layout.</p>
<p>Before we start modifying the layout through code, we call the <kbd>beginDelayedTransition()</kbd> method of <kbd>TransitionManager</kbd> with the transition type. <kbd>TransitionManager</kbd> will track the changes for the ending scene. When we call the <kbd>go()</kbd> method, <kbd>TransitionManager</kbd> automatically animates the change.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to the Animation resources web page at <a href="https://developer.android.com/guide/topics/resources/animation-resource.html">https://developer.android.com/guide/topics/resources/animation-resource.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Compass using sensor data and RotateAnimation</h1>
                
            
            
                
<p>In the previous chapter, we demonstrated reading sensor data from the physical device sensors. In that recipe, we used the Light Sensor since the data from Environment Sensors generally doesn't require any extra processing. Although it's easy to get the magnetic field strength data, the numbers themselves don't have much meaning and certainly don't<br/>
create an appealing display.</p>
<p>In this recipe, we'll demonstrate getting the magnetic field data along with the accelerometer data to calculate magnetic north. We'll use <kbd>SensorManager.getRotationMatrix</kbd> to animate the compass while responding to the device movement. Here's a screenshot of our compass application on a physical device:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d8692248-5175-434a-a9b9-aefb66083553.png" style="width:20.08em;height:35.67em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>Compass</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>
<p>We will need an image for the compass indicator. There's an image on www.Pixabay.Com that will work for us at this link:</p>
<p><a href="https://pixabay.com/en/geography-map-compass-rose-plot-42608/">https://pixabay.com/en/geography-map-compass-rose-plot-42608/</a>.</p>
<p>Although not required, this image has a transparent background, which looks better when rotating the image.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>As mentioned in the previous <em>Getting ready</em> section, we'll need an image for the compass. You can download the one previously linked, or use any image you prefer, then follow these steps:</p>
<ol>
<li>Copy your image to the <kbd>res/drawable</kbd> folder and name it <kbd>compass.png</kbd>.</li>
<li>Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>TextView</kbd> with the following <kbd>ImageView</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.AppCompatImageView<br/>    android:id="@+id/imageViewCompass"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:layout_centerInParent="true"<br/>    android:src="img/compass"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="3">
<li>Now, open <kbd>MainActivity.java</kbd> and add the following global variable declarations:</li>
</ol>
<pre style="padding-left: 60px">private SensorManager mSensorManager;<br/>private Sensor mMagnetometer;<br/>private Sensor mAccelerometer;<br/>private AppCompatImageView mImageViewCompass;<br/>private float[] mGravityValues=new float[3];<br/>private float[] mAccelerationValues=new float[3];<br/>private float[] mRotationMatrix=new float[9];<br/>private float mLastDirectionInDegrees = 0f;</pre>
<ol start="4">
<li>Add the following <kbd>SensorEventListener</kbd> class to the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private SensorEventListener mSensorListener = new SensorEventListener() {<br/>    @Override<br/>    public void onSensorChanged(SensorEvent event) {<br/>        calculateCompassDirection(event);<br/>    }<br/><br/>    @Override<br/>    public void onAccuracyChanged(Sensor sensor, int<br/>            accuracy) {<br/>        //Nothing to do <br/>    }<br/>};</pre>
<ol start="5">
<li>Override <kbd>onResume()</kbd> and <kbd>onPause()</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected void onResume() {<br/>    super.onResume();<br/>    mSensorManager.registerListener(mSensorListener, mMagnetometer, <br/>            SensorManager.SENSOR_DELAY_FASTEST);    <br/>    mSensorManager.registerListener(mSensorListener, mAccelerometer, <br/>            SensorManager.SENSOR_DELAY_FASTEST);<br/>}<br/><br/>@Override<br/>protected void onPause() {<br/>    super.onPause();<br/>    mSensorManager.unregisterListener(mSensorListener);<br/>}</pre>
<ol start="6">
<li>Add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">mImageViewCompass = findViewById(R.id.imageViewCompass);<br/>mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);<br/>mMagnetometer = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);<br/>mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);</pre>
<ol start="7">
<li>The final code does the actual calculations and animation:</li>
</ol>
<pre style="padding-left: 60px">private void calculateCompassDirection(SensorEvent event) {<br/>    switch (event.sensor.getType()) {<br/>        case Sensor.TYPE_ACCELEROMETER:<br/>            mAccelerationValues = event.values.clone();<br/>            break;<br/>        case Sensor.TYPE_MAGNETIC_FIELD:<br/>            mGravityValues = event.values.clone();<br/>            break;<br/>    }<br/>    boolean success = SensorManager.getRotationMatrix(mRotationMatrix, null,<br/>            mAccelerationValues, mGravityValues);<br/>    if (success) {<br/>        float[] orientationValues = new float[3];<br/>        SensorManager.getOrientation(mRotationMatrix, orientationValues);<br/>        float azimuth = (float) Math.toDegrees(-orientationValues[0]);<br/>        RotateAnimation rotateAnimation = new RotateAnimation(mLastDirectionInDegrees, azimuth,<br/>                Animation.RELATIVE_TO_SELF, 0.5f,<br/>                Animation.RELATIVE_TO_SELF, 0.5f);<br/>        rotateAnimation.setDuration(50);<br/>        rotateAnimation.setFillAfter(true);<br/>        mImageViewCompass.startAnimation(rotateAnimation);<br/>        mLastDirectionInDegrees = azimuth;<br/>    }<br/>}</pre>
<ol start="8">
<li>You're ready to run the application. Although you can run this application on an emulator, without an accelerometer and magnetometer, you won't see the compass move.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Since we've already covered reading sensor data in the <em>Reading sensor data – using the Android Sensor Framework</em> section (in the previous chapter), we won't repeat explaining the sensor framework, and, instead, jump right to the <kbd>calculateCompassDirection()</kbd> method.</p>
<p>We call this method directly from the <kbd>onSensorChanged()</kbd> callback. Since we used the same class to handle the sensor callbacks for both the Magnetometer and Accelerometer, we first check which sensor is being reported in <kbd>SensorEvent</kbd>. Then, we call <kbd>SensorManager.getRotationMatrix()</kbd>, passing in the last sensor data. If the calculation is successful, it returns <kbd>RotationMatrix</kbd>, which we use to call the <kbd>SensorManager.getOrientation()</kbd> method. Note that <kbd>getOrientation()</kbd> will return the following data in the <kbd>orientationValues</kbd> array:</p>
<ul>
<li><strong>Azimuth</strong>: <kbd>value [0]</kbd></li>
<li><strong>Pitch</strong>: <kbd>value [1]</kbd></li>
<li><strong>Roll</strong>: <kbd>value [2]</kbd></li>
</ul>
<p>The azimuth is reported in radians, in the opposite direction, so we reverse the sign and convert it to degrees using <kbd>Math.toDegrees()</kbd>. The azimuth represents the direction of North, so we use it in our <kbd>RotateAnimation</kbd>.</p>
<p>With the math already done by <kbd>SensorManager</kbd>, the actual compass animation is very simple. We create <kbd>RotateAnimation</kbd> using the previous direction and the new direction. We use the <kbd>Animation.RELATIVE_TO_SELF</kbd> flag and 0.5f (or 50%) to set the center of the image as the rotation point. Before calling <kbd>startAnimation()</kbd> to update the compass, we set the animation duration using <kbd>setDuration()</kbd> and <kbd>setFillAfter(true)</kbd>. (Using <kbd>true</kbd> indicates we want the image to be left "as is" after the animation completes; otherwise, the image would reset back to the original image.) Finally, we save the azimuth for the next sensor update.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It's worth taking some time to experiment with the <kbd>RotationAnimation</kbd> settings and the sensor update timing. In our call to register the sensor listener, we use <kbd>SensorManager.SENSOR_DELAY_FASTEST</kbd> along with 50 milliseconds for <kbd>setDuration()</kbd> to create a fast animation. You could also try using a slower sensor update and a slower animation, and compare the results.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>Reading sensor data - using the Android Sensor Framework</em> in the previous chapter for details on reading sensor data</li>
<li>Refer to the getRotationMatrix() Developer Document at <a href="http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float%5B%5D,%20float%5B%5D,%20float%5B%5D,%20float%5B%5D)">http://developer.android.com/reference/android/hardware/SensorManager.html#getRotationMatrix(float[], float[], float[], float[])</a></li>
<li>Refer to the getOrientation() Developer Document at <a href="http://developer.android.com/reference/android/hardware/SensorManager.html#getOrientation(float%5B%5D,%20float%5B%5D)">http://developer.android.com/reference/android/hardware/SensorManager.html#getOrientation(float[], float[])</a></li>
<li>Refer to the RotateAnimation Developer Document at <a href="http://developer.android.com/reference/android/view/animation/RotateAnimation.html">http://developer.android.com/reference/android/view/animation/RotateAnimation.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a slideshow with ViewPager</h1>
                
            
            
                
<p>This recipe will show you how to create a slideshow using the <kbd>ViewPager</kbd> class. Here is a screenshot showing a transition from one picture to another:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a2476c32-99a9-4b69-a8cd-a8e9705f7bca.png" style="width:41.25em;height:21.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>SlideShow</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>
<p>We need four images for the slideshow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll create a Fragment to display each image for our slideshow, then set up <kbd>ViewPager</kbd> in the Main Activity. Here are the steps:</p>
<ol>
<li>Copy four images to the <kbd>/res/drawable</kbd> folder and name them <kbd>slide_0</kbd> through <kbd>slide_3</kbd>, keeping the original file extensions.</li>
<li>Create a new layout file called <kbd>fragment_slide.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:orientation="vertical"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"&gt;<br/>    &lt;android.support.v7.widget.AppCompatImageView<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:id="@+id/imageView"<br/>        android:layout_gravity="center_horizontal" /&gt;<br/>&lt;/LinearLayout&gt;</pre>
<ol start="3">
<li>Now, create a new Java class called <kbd>SlideFragment.java</kbd>. It will extend <kbd>Fragment</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">public class SlideFragment extends Fragment { </pre>
<ul>
<li style="padding-left: 60px">Import from the support library, resulting in the following import:</li>
</ul>
<pre style="padding-left: 120px">import android.support.v4.app.Fragment; </pre>
<ol start="4">
<li>Add the following global declaration:</li>
</ol>
<pre style="padding-left: 60px">private int mImageResourceID; </pre>
<ol start="5">
<li>Add the following empty, default fragment constructor:</li>
</ol>
<pre style="padding-left: 60px">public SlideFragment() {}</pre>
<ol start="6">
<li>Add the following method to save the image resource ID:</li>
</ol>
<pre style="padding-left: 60px">public void setImage(int resourceID) { 
    mImageResourceID=resourceID; 
} </pre>
<ol start="7">
<li>Override <kbd>on</kbd><kbd>CreateView()</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){<br/>    ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_slide, container, false);<br/>    AppCompatImageView imageView = rootView.findViewById(R.id.imageView);<br/>    imageView.setImageResource(mImageResourceID);<br/>    return rootView;<br/>}</pre>
<ol start="8">
<li>Our main activity will display just a <kbd>ViewPager</kbd>. Open <kbd>activity_main.xml</kbd> and replace the file contents with the following:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v4.view.ViewPager<br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:id="@+id/viewPager"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" /&gt;</pre>
<ol start="9">
<li>Now, open <kbd>MainActivity.java</kbd> and add the following global declarations:</li>
</ol>
<pre style="padding-left: 60px">private final int PAGE_COUNT=4; 
private ViewPager mViewPager; 
private PagerAdapter mPagerAdapter; </pre>
<ul>
<li style="padding-left: 60px">Use the following imports:</li>
</ul>
<pre style="padding-left: 120px">import android.support.v4.view.PagerAdapter; 
import android.support.v4.view.ViewPager; </pre>
<ol start="10">
<li>Create the following subclass within the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private class SlideAdapter extends FragmentStatePagerAdapter {<br/>    public SlideAdapter(FragmentManager fm) {<br/>        super(fm);<br/>    }<br/>    @Override<br/>    public Fragment getItem(int position) {<br/>        SlideFragment slideFragment = new SlideFragment();<br/>        switch (position) {<br/>            case 0:<br/>                slideFragment.setImage(R.drawable.slide_0);<br/>                break;<br/>            case 1:<br/>                slideFragment.setImage(R.drawable.slide_1);<br/>                break;<br/>            case 2:<br/>                slideFragment.setImage(R.drawable.slide_2);<br/>                break;<br/>            case 3:<br/>                slideFragment.setImage(R.drawable.slide_3);<br/>                break;<br/>        }<br/>        return slideFragment;<br/>    }<br/>    @Override<br/>    public int getCount() {<br/>        return PAGE_COUNT;<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 60px">Use the following imports:</li>
</ul>
<pre style="padding-left: 120px">import android.support.v4.app.Fragment; 
import android.support.v4.app.FragmentManager; 
import android.support.v4.app.FragmentStatePagerAdapter; </pre>
<p style="padding-left: 60px">11. Override <kbd>onBackPressed()</kbd> in the <kbd>MainActivity</kbd> class as follows:</p>
<pre style="padding-left: 60px">@Override<br/>public void onBackPressed() {<br/>    if (mViewPager.getCurrentItem() == 0) {<br/>        super.onBackPressed();<br/>    } else {<br/>        mViewPager.setCurrentItem(mViewPager.getCurrentItem() - 1);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">12. Add the following code to the <kbd>onCreate()</kbd> method:</p>
<pre style="padding-left: 60px">mViewPager = findViewById(R.id.viewPager);<br/>mPagerAdapter = new SlideAdapter(getSupportFragmentManager());<br/>mViewPager.setAdapter(mPagerAdapter);</pre>
<p style="padding-left: 60px">13. Run the application on a device or emulator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first step is to create a fragment. Since we're doing a slideshow, all we need is <kbd>ImageViewer</kbd>. We also change <kbd>MainActivity</kbd> to extend <kbd>FragmentActivity</kbd> to load the fragments into <kbd>ViewPager</kbd>.</p>
<p> <kbd>ViewPager</kbd> uses <kbd>FragmentStatePagerAdapter</kbd> as the source for the fragments to transition. We create <kbd>SlideAdapter</kbd> to handle the two callbacks from the <kbd>FragmentStatePagerAdapter</kbd> class:</p>
<ul>
<li><kbd>getCount()</kbd></li>
<li><kbd>getItem()</kbd></li>
</ul>
<p>Furthermore, <kbd>getCount()</kbd> simply returns the number of pages we have in our slideshow, and <kbd>getItem()</kbd> returns the actual fragment to display. This is where we specify the image we want to display. As you can see, it would be very easy to add to or change the slideshow.</p>
<p>Handling the <em>Backspace</em> key isn't a requirement for <kbd>ViewPager</kbd>, but it does provide a better user experience. However, <kbd>onBackPressed()</kbd> decrements the current page until it reaches the first page, then it sends the <em>Back</em> key to the superclass, which exits the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>As you can see from the example, <kbd>ViewPager</kbd> takes care of most of the work, including handling the transition animations. We can customize the transition if we want, by implementing the <kbd>transformPage()</kbd> callback on the <kbd>ViewPager.PageTransformer</kbd> interface. (See the next recipe for a custom animation.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Setup Wizard</h1>
                
            
            
                
<p>The <kbd>ViewPager</kbd> can also be used to create a Setup Wizard. Instead of creating a single fragment to display an image, create a fragment for each step of your wizard and return the appropriate fragment in the <kbd>getItem()</kbd> callback.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to the Android ViewPager Documentation at <a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html">http://developer.android.com/reference/android/support/v4/view/ViewPager.html</a></li>
<li>Refer to the <em>Creating a custom Zoom Animation</em> recipe for an example of creating a custom animation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Card Flip Animation with Fragments</h1>
                
            
            
                
<p>The card flip is a common animation that we will demonstrate using fragment transitions. We'll use two different images, one for the front and one for the back, to create the card flip effect. We'll need four animation resources, two for the front and two for the back transitions, which we will define in XML using <kbd>objectAnimator</kbd>.</p>
<p>Here's a screenshot of the application we'll build showing the Card Flip Animation in action:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9a28221e-b11b-4186-8222-d44b06b23bd4.png" style="width:13.75em;height:26.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>CardFlip</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>
<p>For the front and back images of the playing card, we found the following images on <a href="http://www.pixabay.com">www.pixabay.com</a>:</p>
<ul>
<li><a href="https://pixabay.com/en/ace-hearts-playing-cards-poker-28357/">https://pixabay.com/en/ace-hearts-playing-cards-poker-28357/</a></li>
<li><a href="https://pixabay.com/en/card-game-deck-of-cards-card-game-48978/">https://pixabay.com/en/card-game-deck-of-cards-card-game-48978/</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll need two fragments: one for the front of the card and the other for the back. Each fragment will define the image for the card. Then, we'll need four animation files for the full card flip effect. Here are the steps to set up the project structure correctly and to create the resources needed:</p>
<ol>
<li>Once you have front and back images for the cards, copy them to the <kbd>res/drawable</kbd> folder as <kbd>card_front.jpg</kbd> and <kbd>card_back.jpg</kbd> (keep the original file extension of your images if different).</li>
<li>Create an animator resource directory: <kbd>res/animator</kbd>. (In Android Studio, go to File | New | Android resource directory. When the New Android Resource dialog displays, choose <kbd>animator</kbd> in the Resource Type drop-down list.)</li>
<li>Create <kbd>card_flip_left_enter.xml</kbd> in <kbd>res/animator</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="1.0"<br/>        android:valueTo="0.0"<br/>        android:propertyName="alpha"<br/>        android:duration="0" /&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="-180"<br/>        android:valueTo="0"<br/>        android:propertyName="rotationY"<br/>        android:interpolator="@android:interpolator/accelerate_decelerate"        <br/>        android:duration="@integer/card_flip_duration_full"/&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="0.0"<br/>        android:valueTo="1.0"<br/>        android:propertyName="alpha"<br/>        android:startOffset="@integer/card_flip_duration_half"<br/>        android:duration="1" /&gt;<br/>&lt;/set&gt;</pre>
<ol start="4">
<li>Create <kbd>card_flip_left_exit.xml</kbd> in <kbd>res/animator</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="0"<br/>        android:valueTo="180"<br/>        android:propertyName="rotationY"<br/>        android:interpolator="@android:interpolator/accelerate_decelerate"<br/>        android:duration="@integer/card_flip_duration_full"/&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="1.0"<br/>        android:valueTo="0.0"<br/>        android:propertyName="alpha"<br/>        android:startOffset="@integer/card_flip_duration_half"<br/>        android:duration="1" /&gt;<br/>&lt;/set&gt;</pre>
<ol start="5">
<li>Create <kbd>card_flip_right_enter.xml</kbd> in <kbd>res/animator</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="1.0"<br/>        android:valueTo="0.0"<br/>        android:propertyName="alpha"<br/>        android:duration="0" /&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="180"<br/>        android:valueTo="0"<br/>        android:propertyName="rotationY"<br/>        android:interpolator="@android:interpolator/accelerate_decelerate"        <br/>        android:duration="@integer/card_flip_duration_full" /&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="0.0"<br/>        android:valueTo="1.0"<br/>        android:propertyName="alpha"<br/>        android:startOffset="@integer/card_flip_duration_half"<br/>        android:duration="1" /&gt;<br/>&lt;/set&gt;</pre>
<ol start="6">
<li>Create <kbd>card_flip_right_exit.xml </kbd>in <kbd>res/animator</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="0"<br/>        android:valueTo="-180"<br/>        android:propertyName="rotationY"<br/>        android:interpolator="@android:interpolator/accelerate_decelerate"        <br/>        android:duration="@integer/card_flip_duration_full" /&gt;<br/>    &lt;objectAnimator<br/>        android:valueFrom="1.0"<br/>        android:valueTo="0.0"<br/>        android:propertyName="alpha"<br/>        android:startOffset="@integer/card_flip_duration_half"<br/>        android:duration="1" /&gt;<br/>&lt;/set&gt;</pre>
<ol start="7">
<li>Create a new resource file in <kbd>res/values</kbd> called <kbd>timing.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;resources&gt;<br/>    &lt;integer name="card_flip_duration_full"&gt;1000&lt;/integer&gt;<br/>    &lt;integer name="card_flip_duration_half"&gt;500&lt;/integer&gt;<br/>&lt;/resources&gt;</pre>
<ol start="8">
<li>Create a new file in <kbd>res/layout</kbd> called <kbd>fragment_card_front.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.v7.widget.AppCompatImageView <br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:src="img/card_front"<br/>    android:scaleType="centerCrop" /&gt;</pre>
<ol start="9">
<li>Create a new file in <kbd>res/layout</kbd> called <kbd>fragment_card_back.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.v7.widget.AppCompatImageView <br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:src="img/card_back"<br/>    android:scaleType="centerCrop" /&gt; </pre>
<ol start="10">
<li>Create a new Java class called <kbd>CardFrontFragment</kbd> using the following code:</li>
</ol>
<pre style="padding-left: 60px">public class CardFrontFragment extends Fragment {<br/>    @Override<br/>    public View onCreateView(LayoutInflater inflater, ViewGroup container, <br/>                             Bundle savedInstanceState) {<br/>        return inflater.inflate(R.layout.fragment_card_front, container, false);<br/>    }<br/>}</pre>
<ol start="11">
<li>Create a new Java class called <kbd>CardBackFragment</kbd> using the following code:</li>
</ol>
<pre style="padding-left: 60px">public class CardBackFragment extends Fragment {<br/>    @Override<br/>    public View onCreateView(LayoutInflater inflater, ViewGroup container, <br/>                             Bundle savedInstanceState) {        <br/>        return inflater.inflate(R.layout.fragment_card_back, container, false);<br/>    }<br/>} </pre>
<ol start="12">
<li>Replace the existing <kbd>activity_main.xml</kbd> file with the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;FrameLayout<br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:id="@+id/container"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" /&gt;</pre>
<ol start="13">
<li>Open <kbd>MainActivity.java</kbd> and add the following global declaration:</li>
</ol>
<pre style="padding-left: 60px">boolean mShowingBack = false;</pre>
<ol start="14">
<li>Add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">FrameLayout frameLayout = findViewById(R.id.container);<br/>frameLayout.setOnClickListener(new View.OnClickListener() {<br/>    @Override<br/>    public void onClick(View v) {<br/>        flipCard();<br/>    }<br/>});<br/><br/>if (savedInstanceState == null) {<br/>    getSupportFragmentManager()<br/>            .beginTransaction()<br/>            .add(R.id.container, new CardFrontFragment())<br/>            .commit();<br/>}</pre>
<ol start="15">
<li>Add the following method, which handles the actual fragment transition:</li>
</ol>
<pre style="padding-left: 60px">void flipCard() {<br/>    if (mShowingBack) {<br/>        mShowingBack = false;<br/>        getSupportFragmentManager().popBackStack();<br/>    } else {<br/>        mShowingBack = true;<br/>        getSupportFragmentManager()<br/>                .beginTransaction()<br/>                .setCustomAnimations(<br/>                        R.animator.card_flip_right_enter,<br/>                        R.animator.card_flip_right_exit,<br/>                        R.animator.card_flip_left_enter,<br/>                        R.animator.card_flip_left_exit)<br/>                .replace(R.id.container, new CardBackFragment())<br/>                .addToBackStack(null)<br/>                .commit();<br/>    }<br/>}</pre>
<ol start="16">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Most of the effort to create the card flip is in setting up the resources. Since we want a front and back view of the card, we create two fragments with the appropriate images. We call the <kbd>flipCard()</kbd> method when the card is pressed. The actual animation is handled by <kbd>setCustomAnimations()</kbd>. This is where we pass in the four animation resources we defined in the XML. As you can see, Android makes it very easy.</p>
<p>It's important to note that we did not use the Support Library Fragment Manager, as the support library does not support <kbd>objectAnimator</kbd>. If you want support pre-Android 3.0, you'll need to include the old anim resources and check the OS version at runtime, or create the animation resources in code. (See the next recipe.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>See the next recipe, <em>Creating a Zoom Animation with a Custom Transition</em>, for an example of animation resources created in code</li>
<li>Refer to the Integer Resource Type web page at <a href="https://developer.android.com/guide/topics/resources/more-resources.html#Integer">https://developer.android.com/guide/topics/resources/more-resources.html#Integer</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Zoom Animation with a Custom Transition</h1>
                
            
            
                
<p>The previous recipe, <em>Creating a Card Flip Animation with Fragments</em>, demonstrated a transition animation using animation resource files. In this recipe, we will create a zoom effect using animation resources created in code. The application shows a thumbnail image, then expands to an enlarged image when pressed.</p>
<p>The following image contains three screenshots showing the zoom animation in action:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9eb564f2-bccd-4f96-bd93-23ba94c62e87.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>ZoomAnimation</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>
<p>For the image needed for this recipe, we downloaded a picture from <a href="http://www.pixabay.com">www.pixabay.com</a> to include in the project source files, but you can use any image.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Once you have your image ready, follow these steps:</p>
<ol>
<li>Copy your image to the <kbd>res/drawable</kbd> folder and name it <kbd>image.jpg</kbd> (if not a JPEG image, keep the original file extension).</li>
</ol>
<ol start="2">
<li>Now, open <kbd>activity_main.xml</kbd> and replace the existing XML with the following:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:id="@+id/frameLayout"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"&gt;<br/>    &lt;LinearLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:orientation="vertical"<br/>        android:padding="16dp"&gt;<br/>        &lt;android.support.v7.widget.AppCompatImageButton<br/>            android:id="@+id/imageViewThumbnail"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:scaleType="centerCrop"<br/>            android:background="@android:color/transparent"/&gt;<br/>    &lt;/LinearLayout&gt;<br/>    &lt;android.support.v7.widget.AppCompatImageView<br/>        android:id="@+id/imageViewExpanded"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        android:visibility="invisible" /&gt;<br/>&lt;/FrameLayout&gt;</pre>
<ol start="3">
<li>Now, open <kbd>MainActivity.java</kbd> and declare the following global variables:</li>
</ol>
<pre style="padding-left: 60px">private Animator mCurrentAnimator;<br/>private AppCompatImageView mImageViewExpanded;</pre>
<ol start="4">
<li>Add the <kbd>loadSampledResource()</kbd> method we created in the <em>Scaling down large images to avoid Out of Memory exceptions</em> recipe to scale the image:</li>
</ol>
<pre style="padding-left: 60px">private Bitmap loadSampledResource(int imageID, int targetHeight, int targetWidth) {<br/>    final BitmapFactory.Options options = new BitmapFactory.Options();<br/>    options.inJustDecodeBounds = true;<br/>    BitmapFactory.decodeResource(getResources(), imageID, options);<br/>    final int originalHeight = options.outHeight;<br/>    final int originalWidth = options.outWidth;<br/>    int inSampleSize = 1;<br/>    while ((originalHeight / (inSampleSize *2)) &gt; targetHeight<br/>            &amp;&amp; (originalWidth / (inSampleSize *2))<br/>            &gt; targetWidth) {<br/>        inSampleSize *= 2;<br/>    }<br/>    options.inSampleSize =inSampleSize;<br/>    options.inJustDecodeBounds = false;<br/>    return (BitmapFactory.decodeResource(getResources(), imageID, options));<br/>}</pre>
<ol start="5">
<li>Add the following code to the <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">final AppCompatImageButton imageViewThumbnail = findViewById(R.id.imageViewThumbnail);<br/>imageViewThumbnail.setImageBitmap(loadSampledResource(R.drawable.image, 100, 100));<br/>imageViewThumbnail.setOnClickListener(new View.OnClickListener() {<br/>    @Override<br/>    public void onClick(View view) {<br/>        zoomFromThumbnail(imageViewThumbnail);<br/>    }<br/>});<br/>mImageViewExpanded = findViewById(R.id.imageViewExpanded);<br/>mImageViewExpanded.setOnClickListener(new View.OnClickListener() {<br/>    @Override<br/>    public void onClick(View v) {<br/>        mImageViewExpanded.setVisibility(View.GONE);<br/>        mImageViewExpanded.setImageBitmap(null);<br/>        imageViewThumbnail.setVisibility(View.VISIBLE);<br/>    }<br/>});</pre>
<ol start="6">
<li>Add the following <kbd>zoomFromThumbnail()</kbd> method, which handles the actual animation and is explained later:</li>
</ol>
<pre style="padding-left: 60px">private void zoomFromThumbnail(final AppCompatImageButton imageViewThumb) {<br/>    if (mCurrentAnimator != null) {<br/>        mCurrentAnimator.cancel();<br/>    }<br/><br/>    final Rect startBounds = new Rect();<br/>    final Rect finalBounds = new Rect();<br/>    final Point globalOffset = new Point();<br/><br/>    imageViewThumb.getGlobalVisibleRect(startBounds);<br/>    findViewById(R.id.frameLayout).getGlobalVisibleRect(finalBounds, globalOffset);<br/>    mImageViewExpanded.setImageBitmap(<br/>            loadSampledResource(R.drawable.image, finalBounds.height(), finalBounds.width()));<br/><br/>    startBounds.offset(-globalOffset.x, -globalOffset.y);<br/>    finalBounds.offset(-globalOffset.x, -globalOffset.y);<br/><br/>    float startScale;<br/>    if ((float) finalBounds.width() / finalBounds.height() &gt;<br/>            (float) startBounds.width() / startBounds.height()) {<br/>        startScale = (float) startBounds.height() / finalBounds.height();<br/>        float startWidth = startScale * finalBounds.width();<br/>        float deltaWidth = (startWidth - startBounds.width()) / 2;<br/>        startBounds.left -= deltaWidth;<br/>        startBounds.right += deltaWidth;<br/>    } else {<br/>        startScale = (float) startBounds.width() / finalBounds.width();<br/>        float startHeight = startScale * finalBounds.height();<br/>        float deltaHeight = (startHeight - startBounds.height()) / 2;<br/>        startBounds.top -= deltaHeight;<br/>        startBounds.bottom += deltaHeight;<br/>    }<br/><br/>    imageViewThumb.setVisibility(View.GONE);<br/>    mImageViewExpanded.setVisibility(View.VISIBLE);<br/>    mImageViewExpanded.setPivotX(0f);<br/>    mImageViewExpanded.setPivotY(0f);<br/><br/>    AnimatorSet animatorSet = new AnimatorSet();<br/>    animatorSet.play(ObjectAnimator.ofFloat(mImageViewExpanded, View.X,<br/>            startBounds.left, finalBounds.left))<br/>            .with(ObjectAnimator.ofFloat(mImageViewExpanded, View.Y,<br/>                    startBounds.top, finalBounds.top))<br/>            .with(ObjectAnimator.ofFloat(mImageViewExpanded, View.SCALE_X, startScale, 1f))<br/>            .with(ObjectAnimator.ofFloat(mImageViewExpanded, View.SCALE_Y, startScale, 1f));<br/>    animatorSet.setDuration(1000);<br/>    animatorSet.setInterpolator(new DecelerateInterpolator());<br/>    animatorSet.addListener(new AnimatorListenerAdapter() {<br/>        @Override<br/>        public void onAnimationEnd(Animator animation) {<br/>            mCurrentAnimator = null;<br/>        }<br/><br/>        @Override<br/>        public void onAnimationCancel(Animator animation) {<br/>            mCurrentAnimator = null;<br/>        }<br/>    });<br/>    animatorSet.start();<br/>    mCurrentAnimator = animatorSet;<br/>}</pre>
<ol start="7">
<li>Run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, take a look at the layout file we used. There are two parts: the <kbd>LinearLayout</kbd> with the <kbd>ImageView</kbd> thumbnail, and the expanded <kbd>ImageView</kbd>. We control the visibility of both views as the images are clicked. We set the starting thumbnail image using the same <kbd>loadSampledResource()</kbd> as discussed in the <em>Scaling down large images to avoid Out of Memory exceptions</em> recipe.</p>
<p>However, <kbd>zoomFromThumbnail()</kbd> is where the real work is being done for this demonstration. There's a lot of code, which breaks down as follows.</p>
<p>First, we store the current animation in <kbd>mCurrentAnimator</kbd>, so we can cancel if the animation is currently running.</p>
<p>Next, we get the starting position of the image using the <kbd>getGlobalVisibleRect()</kbd> method. This returns the screen position of the view. When we get the visible bounds of expanded <kbd>ImageView</kbd>, we also get <kbd>GlobalOffset</kbd> of the view to offset the coordinates from app coordinates to screen coordinates.</p>
<p>With the starting bounds set, the next step is to calculate the ending bounds. We want to keep the same aspect ratio for the final image to prevent it from being skewed. We need to calculate how the bounds need to be adjusted to keep the aspect ratio within the expanded <kbd>ImageView</kbd>. The screenshot shown in the introduction shows how this image was sized, but this will vary by image and device.</p>
<p>With the starting and ending bounds calculated, we can now create the animation. Actually, four animations, in this case, one animation for each point of the rectangle, as shown in this code:</p>
<pre>animatorSet.play(ObjectAnimator.ofFloat(mImageViewExpanded, View.X,<br/>        startBounds.left, finalBounds.left))<br/>        .with(ObjectAnimator.ofFloat(mImageViewExpanded, View.Y,<br/>                startBounds.top, finalBounds.top))<br/>        .with(ObjectAnimator.ofFloat(mImageViewExpanded, View.SCALE_X, startScale, 1f))<br/>        .with(ObjectAnimator.ofFloat(mImageViewExpanded, View.SCALE_Y, startScale, 1f));</pre>
<p>These two lines of code control the animation timing:</p>
<pre>animatorSet.setDuration(1000); 
animatorSet.setInterpolator(new AccelerateInterpolator()); </pre>
<p>The <kbd>setDuration()</kbd> method tells the animator object how long it should take to animate the translations set previously. However, <kbd>setInterpolator()</kbd> governs how the translation is made. (The Interpolator was mentioned in the <em>Introduction</em>, and a link is provided in the <em>See also</em> section of this recipe.) After starting the animation with the <kbd>start()</kbd> method, we save the current animation to the <kbd>mCurrentAnimator</kbd> variable, so the animation can be canceled, if needed. We create an <kbd>AnimatorListenerAdapter</kbd> to respond to the animation events and clear the <kbd>mCurrentAnimator</kbd> variable upon completion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>When the user presses the expanded image, the application just hides the expanded <kbd>ImageView</kbd> and sets the thumbnail as <kbd>visible</kbd>. We could create a reverse zoom animation in the <kbd>mImageViewExpanded</kbd> click event using the expanded bounds as the starting point, then returning to the thumbnail bounds. (It would probably be easier to create the <kbd>mImageViewExpanded</kbd> event in <kbd>zoomFromThumbnail()</kbd> to avoid having to duplicate calculating the start and stop bounds again.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting the default animation duration</h1>
                
            
            
                
<p>Our code used 1,000 milliseconds when setting the duration with <kbd>setDuration()</kbd>. We purposely used a long duration to make it easier to view the animation. We can get the default Android animation duration using the following code:</p>
<pre>getResources().getInteger(android.R.integer.config_shortAnimTime)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>See the first recipe, <em>Scaling down large images to avoid Out of Memory exceptions</em>, for a detailed explanation of the <kbd>loadSampledResource()</kbd> method</li>
<li>Refer to the Interpolator Developer Document at <a href="http://developer.android.com/reference/android/view/animation/Interpolator.html">http://developer.android.com/reference/android/view/animation/Interpolator.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying animated image (GIF/WebP) with the new ImageDecoder library</h1>
                
            
            
                
<p>Android P (API 28) introduces a new library called ImageDecoder, which will be deprecating the BitmapFactory class. This new image library promises to make it easier to work with not just bitmaps, but several other file formats not supported in the old BitmapFactory class, such as GIF and WebP animated images.</p>
<p>At the time of writing, it is only available on devices running Android P (or later) and is not available in the support library, but according to this issue on the Google issue tracker, there are plans to add ImageDecoder to the support library: <a href="https://issuetracker.google.com/issues/78041382">https://issuetracker.google.com/issues/78041382</a>.</p>
<p>When, or if, that happens, the previous examples will be updated to use this new library instead. For now, we'll take a look at new functionality, and that is native support for displaying GIF images.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>AnimatedImage</kbd>. In the Target Android Devices dialog, make sure to select API 28 (or greater) for the Phone &amp; Tablet option. Select Empty Activity when prompted for the Activity Type. In the Configure Activity dialog (shown next), deselect the Backwards Compatibility option since this feature is not yet available in the support library:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/44fe8b12-8dcf-46ab-9b06-ee8525066084.png" style="width:53.75em;height:36.58em;"/></p>
<p>We'll also need a GIF image. We turned to Giphy.com for a royalty-free image, which you can see in the downloadable project files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Once you have your GIF image, follow these steps:</p>
<ol>
<li>Copy your image to the <kbd>res/drawable</kbd> folder. Our file is named <kbd>giphy.gif</kbd> but you can use your own filename instead.</li>
<li>Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>TextView</kbd> with the following <kbd>ImageView</kbd>: </li>
</ol>
<pre style="padding-left: 60px">&lt;ImageView<br/>    android:id="@+id/imageView"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="3">
<li>Open <kbd>MainActivity.java</kbd> and add the following line of code to the existing <kbd>onCreate()</kbd> method: </li>
</ol>
<pre style="padding-left: 60px">loadGif();</pre>
<ol start="4">
<li> Finally, add the loadGif method as follows: </li>
</ol>
<pre style="padding-left: 60px">private void loadGif() {<br/>    try {<br/>        ImageDecoder.Source source = ImageDecoder.createSource(getResources(),<br/>                R.drawable.giphy);<br/>        Drawable decodedAnimation = ImageDecoder.decodeDrawable(source);<br/><br/>        ImageView imageView = findViewById(R.id.imageView);<br/>        imageView.setImageDrawable(decodedAnimation);<br/><br/>        if (decodedAnimation instanceof AnimatedImageDrawable) {<br/>            ((AnimatedImageDrawable) decodedAnimation).start();<br/>        }<br/>    } catch (IOException e) {<br/>        e.printStackTrace();<br/>    }<br/>}</pre>
<ol start="5">
<li>Run your app on a device or emulator running at least Android P.</li>
</ol>
<p>If you do not see the animated image when running this code, try disabling hardware acceleration in the Android Manifest. Add the following to either the <kbd>&lt;application&gt;</kbd> node or the  <kbd>&lt;activity&gt;</kbd> node: <br/>
 <kbd>android:hardwareAccelerated="false"</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As you can see in the preceding code, the <kbd>ImageDecoder</kbd> library has made it very simple to display a GIF. First, you have to define your source image. Currently, the <kbd>createSource()</kbd> method can read an image from the following sources:</p>
<ul>
<li>Resources (drawable) folder</li>
<li>Assets folder</li>
<li>ContentResolver (URI)</li>
<li>Byte buffer</li>
<li>File</li>
</ul>
<p>(This could change in the final Android P release.)</p>
<p>In our code, we copied the image to the drawable folder. If we had copied it to the assets folder instead, the code would have been as follows:</p>
<pre>ImageDecoder.Source source = ImageDecoder.createSource(getAssets(), "giphy.gif");</pre>
<p>With the image source defined, we just have to call <kbd>decodeDrawable()</kbd> to decode the image and set the drawable for the ImageView. Once the drawable is set, the final key to the animated image is to call the <kbd>start()</kbd> method. If the decoded image is of type <kbd>AnimatedDrawable</kbd> (which it will be if we loaded a valid GIF), we then call the start method to activate the animation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <kbd>ImageDecoder</kbd> documentation: <a href="https://developer.android.com/reference/android/graphics/ImageDecoder">https://developer.android.com/reference/android/graphics/ImageDecoder</a></li>
<li>See the next recipe for more examples of using the ImageDecoder library</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a circle image with the new ImageDecoder</h1>
                
            
            
                
<p>As mentioned in the previous recipe, the ImageDecoder library is a new library introduced in Android P and promises many new and exciting features not available before with the BitmapFactory class. One of those features is the ability to apply effects to the image with a post processor. A post processor is a new helper class allowing you to add custom processing (or manipulation) to an image after it is loaded. Custom processing might include adding a tint to the image, drawing (such as stamps) on top of the image, adding a frame, or in our example making the image round.</p>
<p class="CDPAlignLeft CDPAlign">In our example, we start with a rectangle image (downloaded from Pixabay.com, which you can see here: <a href="https://pixabay.com/en/wallpaper-background-eclipse-1492818/">https://pixabay.com/en/wallpaper-background-eclipse-1492818/</a>.) We then apply a post processor to create a rounded image, as you can see in this screenshot: </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5757b552-0f27-42bc-97a3-f0980a77b43f.png" style="width:20.42em;height:40.92em;"/></p>
<p>This is another exciting new feature available in the ImageDecoder library because until now, developers usually turned to third-party libraries. Although many of these libraries are still going to be very useful, especially for handling image loading in lists; for something as simple as creating a rounded image, say, for a profile picture, there is now an easy native solution.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>CircleImage</kbd>. In the Target Android Devices dialog, make sure to select API 28 (or greater) for the Phone &amp; Tablet option.  Select Empty Activity when prompted for the Activity Type. In the Configure Activity dialog (shown next), deselect the Backwards Compatibility option since this feature is not yet available in the support library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Once you have your GIF image, follow these steps:</p>
<ol>
<li>Copy an image to the <kbd>res/drawable</kbd> folder. (This example uses an image named stars.jpg. Use your image name instead.) If it's smaller than the size of our circle created here, you'll need to use a smaller radius.</li>
<li>Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>TextView</kbd> with the following <kbd>ImageView</kbd>: </li>
</ol>
<pre style="padding-left: 60px">&lt;ImageView<br/>    android:id="@+id/imageView"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<p style="padding-left: 60px">3. Open <kbd>MainActivity.java</kbd> and add the following code to the class declaration: </p>
<pre style="padding-left: 60px">PostProcessor mCirclePostProcessor = new PostProcessor() {<br/>    @Override<br/>    public int onPostProcess(Canvas canvas) {<br/>        Path path = new Path();<br/>        path.setFillType(Path.FillType.INVERSE_EVEN_ODD);<br/>        int width = canvas.getWidth();<br/>        int height = canvas.getHeight();<br/>        path.addCircle(width/2,height/2,600, Path.Direction.CW);<br/>        Paint paint = new Paint();<br/>        paint.setAntiAlias(true);<br/>        paint.setColor(Color.TRANSPARENT);<br/>        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));<br/>        canvas.drawPath(path, paint);<br/>        return PixelFormat.TRANSLUCENT;<br/>    }<br/>};</pre>
<p style="padding-left: 60px">4. Add the following line of code to the existing <kbd>onCreate()</kbd> method: </p>
<pre style="padding-left: 60px">loadImage();</pre>
<p style="padding-left: 60px">5. The last code to add is the following <kbd>loadImage()</kbd> method: </p>
<pre style="padding-left: 60px">private void loadImage() {<br/>    ImageDecoder.Source source = ImageDecoder.createSource(getResources(),<br/>            R.drawable.stars);<br/><br/>    ImageDecoder.OnHeaderDecodedListener listener = <br/>            new ImageDecoder.OnHeaderDecodedListener() {<br/>        public void onHeaderDecoded(ImageDecoder decoder, ImageDecoder.ImageInfo info,<br/>                                    ImageDecoder.Source source) {<br/>            decoder.setPostProcessor(mCirclePostProcessor);<br/>        }<br/>    };<br/>    try {<br/>        Drawable drawable = ImageDecoder.decodeDrawable(source, listener);<br/>        ImageView imageView = findViewById(R.id.imageView);<br/>        imageView.setImageDrawable(drawable);<br/>    } catch (IOException e) {<br/>        e.printStackTrace();<br/>    }<br/>}</pre>
<p style="padding-left: 60px">6. Run the app on a device or emulator running at least Android P.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We start off with the same XML layout as the previous recipe. And if we omitted adding the post processor, we'd get a standard rectangle image. To see for yourself, comment the following line of code in <kbd>OnHeaderDecodedListener</kbd>:</p>
<pre>decoder.setPostProcessor(mCirclePostProcessor);</pre>
<p>The core of the work being done here is in <kbd>PostProcessor</kbd> created in step 3. Although there are a several lines of code, what's being done is pretty simple. It just creates a circle (using the dimensions we specified) and clears everything out (by setting the color to <kbd>TRANSPARENT</kbd>) not in our circle.</p>
<p>The key is setting the post processor, which can only be done in the <kbd>onHeaderDecoded()</kbd> callback. This is why we first create the <kbd>OnHeaderDecodedListener</kbd> so we can get a reference to the decoder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>What if you wanted rounded corners instead of a circle image? With one simple change in the <kbd>Path</kbd> created for the post processor, you could have that effect instead. Instead of the <kbd>addCircle()</kbd> call when creating the <kbd>Path</kbd>, use this line of code instead:</p>
<pre>path.addRoundRect(0, 0, width, height, 250, 250, Path.Direction.CW);</pre>
<p>The value of 250 used creates a very rounded corner, so experiment to get the amount of rounding desired. Take a look at the reference links in <em>See also</em> for more information on the post processor and <kbd>Path</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <kbd>PostProcessor</kbd> reference documentation: <a href="https://developer.android.com/reference/android/graphics/PostProcessor">https://developer.android.com/reference/android/graphics/PostProcessor</a></li>
<li>The <kbd>Path</kbd> reference documentation: <a href="https://developer.android.com/reference/android/graphics/Path">https://developer.android.com/reference/android/graphics/Path</a></li>
</ul>


            

            
        
    </body></html>