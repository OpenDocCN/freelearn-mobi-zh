<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Home Screen Widgets, Search, and the System UI</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating a shortcut on the Home screen</li>
<li>Creating a Home screen widget</li>
<li>Adding Search to the Action Bar</li>
<li>Showing your app full-screen</li>
<li>Lock screen shortcuts</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>With an understanding of Fragments from the previous chapter, we're ready to expand on our discussion of widgets. In <a href="3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 3</span></a>,<em> <span class="ItalicsPACKT">Views, Widgets, and Styles</span></em>, we discussed how to add widgets to your own app. Now, we'll look at how to create an App Widget so users can add your app on their Home screen.</span></p>
<p>The remaining recipes in this chapter will explore System UI options. There's a recipe for adding a<span> </span><span class="CodeInTextPACKT">Search</span><span> </span>option to the Action Bar using the Android<span> </span><span class="CodeInTextPACKT">SearchManager</span><span> </span>API. Another recipe will explore Full Screen mode and several additional variations on altering the System UI. The final recipe will showcase the new Lock Screen shortcuts introduced in Android O (API 26).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a shortcut on the Home screen</h1>
                </header>
            
            <article>
                
<p>This recipe explains how to create a link or create a shortcut for your app on the user's Home screen. So as not to be too obtrusive, it's generally best to make this an option for the user to initiate, such as in the settings.</p>
<p>The following is a screenshot showing our shortcut on the Home screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c0c71732-d9bd-4752-af84-086fd7d0bbab.png" style="width:23.00em;height:43.42em;"/></div>
<p>As you can see, this is just a shortcut to your app. The next recipe will go deeper by creating a Home screen (AppWidget).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it<span> </span><kbd><span class="CodeInTextPACKT">HomeScreenShortcut</span></kbd>. Use the default<span> </span><span class="ScreenTextPACKT">Phone &amp; Tablet</span><span> </span>options and select the<span> </span><span class="ScreenTextPACKT"><span class="packt_screen">Empty Activity</span></span><span> </span><span>option when prompted for the </span><span class="ScreenTextPACKT">Activity Type</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>For an app to create a shortcut, it must have the <kbd>INSTALL_SHORTCUT</kbd> permission. With the appropriate permission, it's a simple matter of calling an intent with your app properties. The following are the steps:</p>
<ol>
<li>Open the<span> </span><kbd><span class="CodeInTextPACKT">AndroidManifest</span></kbd><span> </span>file and add the following permission:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;uses-permission </span><span>android</span><span>:name=</span><span>"com.android.launcher.permission.INSTALL_SHORTCUT" </span><span>/&gt;</span></pre>
<ol start="2">
<li>Next, open<span> </span><kbd><span class="CodeInTextPACKT">activity_main.xml</span></kbd><span> </span>and replace the existing TextView with the following button:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/button"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Create Shortcut"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"createShortcut"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent" </span><span>/&gt;</span></pre>
<ol start="3">
<li>Add the following method to<span> </span><kbd><span class="CodeInTextPACKT">ActivityMain.java</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>createShortcut</span>(View view) {<br/>    Intent shortcutIntent = <span>new </span>Intent(<span>this, </span>MainActivity.<span>class</span>)<span>;<br/></span><span>    </span>shortcutIntent.setAction(Intent.<span>ACTION_MAIN</span>)<span>;<br/></span><span>    </span>Intent intent = <span>new </span>Intent()<span>;<br/></span><span>    </span>intent.putExtra(Intent.<span>EXTRA_SHORTCUT_INTENT</span><span>, </span>shortcutIntent)<span>;<br/></span><span>    </span>intent.putExtra(Intent.<span>EXTRA_SHORTCUT_NAME</span><span>, </span>getString(R.string.<span>app_name</span>))<span>;<br/></span><span>    </span>intent.putExtra(Intent.<span>EXTRA_SHORTCUT_ICON_RESOURCE</span><span>,<br/></span><span>            </span>Intent.ShortcutIconResource.<span>fromContext</span>(<span>this, </span>R.mipmap.<span>ic_launcher</span>))<span>;<br/></span><span>    </span>intent.setAction(<span>"com.android.launcher.action.INSTALL_SHORTCUT"</span>)<span>;<br/></span><span>    </span>sendBroadcast(intent)<span>;<br/></span>}</pre>
<ol start="4">
<li>Run the program on a device or emulator. Notice that, each time you press the button, the app will make a shortcut on the Home screen.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Once you set up the proper permission, this is a rather straightforward task. When the button is clicked, the code creates two intents. The first intent broadcasts to the OS that you want a shortcut created. The second intent is the intent that launches your app when the icon is pressed. One important consideration to keep in mind is that Home screens vary and may not support the <kbd>INSTALL_SHORTCUT</kbd> intent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you also wanted to remove the shortcut, you would need the following permission:</p>
<pre><span>&lt;uses-permission </span><span>android</span><span>:name=</span><span>"com.android.launcher.permission.UNINSTALL_SHORTCUT" </span><span>/&gt;</span></pre>
<p>Instead of using the <kbd>INSTALL_SHORTCUT</kbd> action, you would set the following action instead:</p>
<pre>com.android.launcher.action.UNINSTALL_SHORTCUT </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Home screen widget</h1>
                </header>
            
            <article>
                
<p>Before we dig into the code for creating an App Widget, let's cover the basics. There are three required and one optional component:</p>
<ul>
<li>The<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProviderInfo</span></kbd><span> </span>file: It's an XML resource (described later)</li>
<li>The<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProvider</span><span> </span>class</kbd>: This is a Java class</li>
<li><span><span>The <kbd>View layout</kbd> file: It's a standard layout XML file, with some restrictions (explained later)</span></span></li>
<li>The App Widget configuration Activity (optional): This is an Activity the OS will launch when placing the widget to provide configuration options</li>
</ul>
<p>The<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProvider</span></kbd><span> </span>must also be declared in the<span> </span><kbd><span class="CodeInTextPACKT">AndroidManifest</span></kbd><span> </span>file. Since <kbd><span class="CodeInTextPACKT">AppWidgetProvider</span></kbd><span> </span><span>is a helper class based on the Broadcast Receiver, it is declared in the manifest with the</span><span> </span><kbd><span class="CodeInTextPACKT">&lt;receiver&gt;</span></kbd><span> </span>element. Here is an example manifest entry:</p>
<pre><span>&lt;receiver </span><span>android</span><span>:name=</span><span>".HomescreenWidgetProvider" </span><span>&gt;<br/></span><span>    &lt;intent-filter&gt;<br/></span><span>        &lt;action </span><span>android</span><span>:name=</span><span>"android.appwidget.action.APPWIDGET_UPDATE" </span><span>/&gt;<br/></span><span>    &lt;/intent-filter&gt;<br/></span><span>    &lt;meta-data </span><span>android</span><span>:name=</span><span>"android.appwidget.provider"<br/></span><span>        </span><span>android</span><span>:resource=</span><span>"@xml/appwidget_info" </span><span>/&gt;<br/></span><span>&lt;/receiver&gt;</span></pre>
<p>The metadata points to the<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProviderInfo</span></kbd><span> </span>file, which is placed in the<span> </span><kbd><span class="CodeInTextPACKT">res/xml</span></kbd><span> </span>directory. Here is a sample<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProviderInfo.xml</span></kbd><span> </span>file:</p>
<pre><span>&lt;appwidget-provider </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>android</span><span>:minWidth=</span><span>"40dp"<br/></span><span>    </span><span>android</span><span>:minHeight=</span><span>"40dp"<br/></span><span>    </span><span>android</span><span>:updatePeriodMillis=</span><span>"0"<br/></span><span>    </span><span>android</span><span>:initialLayout=</span><span>"@layout/widget"<br/></span><span>    </span><span>android</span><span>:resizeMode=</span><span>"none"<br/></span><span>    </span><span>android</span><span>:widgetCategory=</span><span>"home_screen"</span><span>&gt;<br/></span><span>&lt;/appwidget-provider&gt;</span></pre>
<p>The following is a brief overview of the available attributes:</p>
<ul>
<li><kbd><span class="CodeInTextPACKT">minWidth</span></kbd>: The default width when placed on the Home screen</li>
<li><kbd><span class="CodeInTextPACKT">minHeight</span></kbd>: The default height when placed on the Home screen</li>
<li><kbd><span class="CodeInTextPACKT">updatePeriodMillis</span></kbd>: It's part of<span> the </span><kbd><span class="CodeInTextPACKT">onUpdate()</span></kbd><span> </span>polling interval (in milliseconds)</li>
<li><kbd><span class="CodeInTextPACKT">initialLayout</span></kbd>: The AppWidget layout</li>
<li><kbd><span class="CodeInTextPACKT">previewImage</span></kbd><span> </span>(optional): The image shown when browsing App Widgets</li>
<li><kbd><span class="CodeInTextPACKT">configure</span></kbd><span> </span>(optional): The activity to launch for configuration settings</li>
<li><kbd><span class="CodeInTextPACKT">resizeMode</span></kbd><span> </span>(optional): The flags indicate resizing options:<span> </span><span class="CodeInTextPACKT">horizontal</span>,<span> </span><span class="CodeInTextPACKT">vertical</span>,<span> </span><span class="CodeInTextPACKT">none</span></li>
<li><kbd><span class="CodeInTextPACKT">minResizeWidth</span></kbd><span> </span>(optional): The minimum width allowed when resizing</li>
<li><kbd><span class="CodeInTextPACKT">minResizeHeight</span></kbd><span> </span>(optional): The minimum height allowed when resizing</li>
<li><kbd><span class="CodeInTextPACKT">widgetCategory</span></kbd><span> </span>(optional): Android 5+ only supports Home screen widgets</li>
</ul>
<p>The<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProvider</span></kbd><span> </span>extends the<span> </span><kbd><span class="CodeInTextPACKT">BroadcastReceiver</span></kbd><span> </span>class, which is why<span> the </span><kbd><span class="CodeInTextPACKT">&lt;receiver&gt;</span></kbd><span> element </span>is used when declaring the<span> </span><span class="CodeInTextPACKT">AppWidget</span><span> </span>in the Manifest. As it's<span> </span><kbd><span class="CodeInTextPACKT">BroadcastReceiver</span></kbd>, the class still receives OS broadcast events, but the helper class filters those events down to those applicable for an App Widget. The<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProvider</span></kbd><span> </span>class exposes the following methods:</p>
<ul>
<li><kbd><span class="CodeInTextPACKT">onUpdate()</span></kbd>: It's called when initially created and at the interval specified.</li>
<li><kbd><span class="CodeInTextPACKT">onAppWidgetOptionsChanged()</span></kbd>: It's called when initially created and any time the size changes.</li>
<li><kbd><span class="CodeInTextPACKT">onDeleted()</span></kbd>: It's called any time a widget is removed.</li>
<li><kbd><span class="CodeInTextPACKT">onEnabled()</span></kbd>: It's called the first time a widget is placed (it isn't called when adding second and subsequent widgets).</li>
<li><kbd><span class="CodeInTextPACKT">onDisabled()</span></kbd>: It's called when the last widget is removed.</li>
<li><kbd><span class="CodeInTextPACKT">onReceive()</span></kbd>: It's called on every event received, including the preceding event. Usually not overridden as the default implementation only sends applicable events.</li>
</ul>
<p>The last required component is the layout. An App Widget uses a Remote View, which only supports<span> a subset of the available layouts</span>:</p>
<ul>
<li>AdapterViewFlipper</li>
<li>FrameLayout</li>
<li>GridLayout</li>
<li>GridView</li>
<li>LinearLayout</li>
<li>ListView</li>
<li>RelativeLayout</li>
<li>StackView</li>
<li>ViewFlipper</li>
</ul>
<p>And it supports the following widgets:</p>
<ul>
<li>AnalogClock</li>
<li>Button</li>
<li>Chronometer</li>
<li>ImageButton</li>
<li>ImageView</li>
<li>ProgressBar</li>
<li>TextClock</li>
<li>TextView</li>
</ul>
<p>With App Widget basics covered, it's now time to start coding. Our example will cover the basics so you can expand the functionality as needed. This recipe uses a View with a clock, which, when pressed, opens our activity.</p>
<p>The following screenshot shows the widget in the widget list when adding it to the Home screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/24cd27b9-b7e1-4ac7-b7b3-b5634da66d8a.png" style="width:21.08em;height:42.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">The purpose of the image is to show how to add a widget to the home screen</div>
<div class="packt_infobox">The widget list's appearance varies by the launcher used.</div>
<p>Here's a screenshot showing the widget after it is added to the Home screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/acaa88e4-26cc-4f86-8bb8-623eddeaeda4.png" style="width:16.58em;height:33.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it<span> </span><span class="CodeInTextPACKT">AppWidget</span>. Use the default<span> </span><span class="ScreenTextPACKT">Phone &amp; Tablet</span><span> </span>options and select the<span> </span><span class="ScreenTextPACKT"><span class="packt_screen">Empty Activity</span></span><span> </span>option when prompted for the<span> </span><span class="ScreenTextPACKT">Activity Type</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We'll start by creating the widget layout, which resides in the standard layout resource directory. Then, we'll create the XML resource directory to store the<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProviderInfo</span></kbd><span> </span>file. We'll add a new Java class and extend<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProvider</span></kbd>, which handles the<span> </span><kbd><span class="CodeInTextPACKT">onUpdate()</span></kbd><span> </span><span>call for the widget. With the receiver created, we can then add it to the Android Manifest.</span></p>
<p>Here are the detailed steps:</p>
<ol>
<li>Create a new file in<span> </span><kbd><span class="CodeInTextPACKT">res/layout</span></kbd><span> </span>called<span> </span><kbd><span class="CodeInTextPACKT">widget.xml</span></kbd><span> </span>using the following XML:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;RelativeLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent"</span><span>&gt;<br/></span><span>    &lt;AnalogClock<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/analogClock"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_centerVertical=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_centerHorizontal=</span><span>"true" </span><span>/&gt;<br/></span><span>&lt;/RelativeLayout&gt;</span></pre>
<ol start="2">
<li>Create a new directory called<span> </span><span class="CodeInTextPACKT">XML</span><span> </span>in the resource directory. The final result will be<span> </span><kbd><span class="CodeInTextPACKT">res/xml</span></kbd>.</li>
<li>Create a new file in<span> </span><kbd><span class="CodeInTextPACKT">res/xml</span></kbd><span> </span>called<span> </span><kbd><span class="CodeInTextPACKT">appwidget_info.xml</span></kbd><span> </span>using the following XML:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;appwidget-provider </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>android</span><span>:minWidth=</span><span>"40dp"<br/></span><span>    </span><span>android</span><span>:minHeight=</span><span>"40dp"<br/></span><span>    </span><span>android</span><span>:updatePeriodMillis=</span><span>"0"<br/></span><span>    </span><span>android</span><span>:initialLayout=</span><span>"@layout/widget"<br/></span><span>    </span><span>android</span><span>:resizeMode=</span><span>"none"<br/></span><span>    </span><span>android</span><span>:widgetCategory=</span><span>"home_screen"</span><span>&gt;<br/></span><span>&lt;/appwidget-provider&gt;</span></pre>
<div class="packt_tip">If you cannot see the new XML directory, switch from Android view to Project view in the Project panel drop-down.</div>
<ol start="4">
<li>Create a new Java class called<span> </span><kbd><span class="CodeInTextPACKT">HomescreenWidgetProvider</span></kbd><span>, </span>extending<span> from </span><span class="CodeInTextPACKT"><kbd>AppWidgetProvider</kbd></span>.</li>
<li>Add the following<span> </span><kbd><span class="CodeInTextPACKT">onUpdate()</span></kbd><span> </span>method to the<span> </span><kbd><span class="CodeInTextPACKT">HomescreenWidgetProvider</span></kbd><span> </span>class:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>public void </span><span>onUpdate</span>(Context context<span>, </span>AppWidgetManager appWidgetManager<span>, int</span>[] appWidgetIds) {<br/>    <span>super</span>.onUpdate(context<span>, </span>appWidgetManager<span>, </span>appWidgetIds)<span>;<br/></span><span><br/></span><span>    for </span>(<span>int </span>count=<span>0</span><span>; </span>count&lt;appWidgetIds.<span>length</span><span>; </span>count++) {<br/>        RemoteViews appWidgetLayout = <span>new<br/></span><span>                </span>RemoteViews(context.getPackageName()<span>,<br/></span><span>                </span>R.layout.<span>widget</span>)<span>;<br/></span><span>        </span>Intent intent = <span>new </span>Intent(context<span>, </span>MainActivity.<span>class</span>)<span>;<br/></span><span>        </span>PendingIntent pendingIntent = PendingIntent.<span>getActivity</span>(context<span>, </span><span>0</span><span>, </span>intent<span>, </span><span>0</span>)<span>;<br/></span><span>        </span>appWidgetLayout.setOnClickPendingIntent(R.id.<span>analogClock</span><span>, </span>pendingIntent)<span>;<br/></span><span>        </span>appWidgetManager.updateAppWidget(appWidgetIds[count]<span>, </span>appWidgetLayout)<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="6">
<li>Add<span> the </span><span class="CodeInTextPACKT"><kbd>HomescreenWidgetProvider</kbd></span><span> </span>to the<span> </span><span class="CodeInTextPACKT">AndroidManifest</span><span> </span>using the following XML declaration within the<span> </span><kbd><span class="CodeInTextPACKT">&lt;application&gt;</span></kbd><span> </span>element:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;receiver </span><span>android</span><span>:name=</span><span>".HomescreenWidgetProvider" </span><span>&gt;<br/></span><span>    &lt;intent-filter&gt;<br/></span><span>        &lt;action </span><span>android</span><span>:name=</span><span>"android.appwidget.action.APPWIDGET_UPDATE" </span><span>/&gt;<br/></span><span>    &lt;/intent-filter&gt;<br/></span><span>    &lt;meta-data </span><span>android</span><span>:name=</span><span>"android.appwidget.provider"<br/></span><span>        </span><span>android</span><span>:resource=</span><span>"@xml/appwidget_info" </span><span>/&gt;<br/></span><span>&lt;/receiver&gt;</span></pre>
<ol start="7">
<li>Run the program on a device or emulator. After first running the application, the widget will then be available to add to the Home screen.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Our first step is to create the layout file for the widget. This is a standard layout resource with the restrictions based on the App Widget being a Remote View, as discussed in the recipe introduction. Although our example uses an Analog Clock widget, this is where you'd want to expand the functionality based on your application needs.</p>
<p>The XML resource directory serves to store the<span> </span><span class="CodeInTextPACKT">AppWidgetProviderInfo</span><span>, which defines the default widget settings. The configuration settings determine how the widget is displayed when initially browsing the available widgets. We use very basic settings for this recipe, but they can easily be expanded to include additional features, such as a preview image to show<br/>
a functioning widget and sizing options. The</span><span> </span><kbd><span class="CodeInTextPACKT">updatePeriodMillis</span></kbd><span> </span><span>attribute sets the update frequency. Since the update will wake up the device, it's a trade-off between having up-to-date data and battery life. (This is where the optional Settings Activity is useful by letting the user decide.)</span></p>
<p>The<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProvider</span></kbd><span> </span>class is where we handle the<span> </span><kbd><span class="CodeInTextPACKT">onUpdate()</span></kbd><span> </span>event triggered by the<span> </span><kbd><span class="CodeInTextPACKT">updatePeriodMillis</span></kbd><span> </span>polling. Our example doesn't need any updating so we set the polling to zero. The update is still called when initially placing the widget. <kbd><span class="CodeInTextPACKT">onUpdate()</span></kbd><span> </span>is where we set the pending intent to open our app when the clock is pressed.</p>
<p>Since the<span> </span><kbd><span class="CodeInTextPACKT">onUpdate()</span></kbd><span> </span>method is probably the most complicated aspect of AppWidgets, we'll explain this in some detail. First, it's worth noting that<span> </span><kbd><span class="CodeInTextPACKT">onUpdate()</span><span> </span></kbd>will occur only once each polling interval for all the widgets is created by this provider. (All additional widgets created will use the same cycle as the first widget created.) This explains the<span> </span><span class="CodeInTextPACKT">for</span><span> </span>loop, as we need it to iterate through all the existing widgets. This is where we create a pending intent, which calls our app when the clock widget is pressed. As discussed earlier, an AppWidget is a Remote View. Therefore, to get the layout, we call<span> </span><kbd><span class="CodeInTextPACKT">RemoteViews()</span></kbd><span> </span>with our fully qualified package name and the layout ID. Once we have the layout, we can attach the pending intent to the clock view using<span> </span><kbd><span class="CodeInTextPACKT">setOnClickPendingIntent()</span></kbd>. We call the<span> </span><span class="CodeInTextPACKT">AppWidgetManager</span><span> </span>named<span> </span><kbd><span class="CodeInTextPACKT">updateAppWidget()</span></kbd><span> </span>to initiate the changes we made.</p>
<p>The last step to make all this work is to declare the widget in the Android Manifest. We identify the action we want to handle with the<span> </span><kbd><span class="CodeInTextPACKT">&lt;intent-filter&gt;</span></kbd>. Most App Widgets will likely want to handle the Update event, as ours does. The other item to note in the declaration is the following line:</p>
<pre>&lt;meta-data android:name="android.appwidget.provider" 

    android:resource="@xml/appwidget_info" /&gt;</pre>
<p>This tells the system where to find our configuration file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Adding an App Widget configuration Activity allows greater flexibility with your widget. Not only can you offer polling options, but you could offer different layouts, click behaviors, and so on. Users tend to really appreciate flexible App Widgets.</p>
<p>Adding a configuration Activity requires a few additional steps. The Activity needs to be declared in the Manifest as usual, but needs to include the<span> </span><kbd><span class="CodeInTextPACKT">APPWIDGET_CONFIGURE</span></kbd><span> </span>action, as shown in the following example:</p>
<pre><span>&lt;activity </span><span>android</span><span>:name=</span><span>".AppWidgetConfigureActivity"</span><span>&gt;<br/></span><span>    &lt;intent-filter&gt;<br/></span><span>        &lt;action </span><span>android</span><span>:name=</span><span>"android.appwidget.action.APPWIDGET_CONFIGURE"</span><span>/&gt;<br/></span><span>    &lt;/intent-filter&gt;<br/></span><span>&lt;/activity&gt;</span></pre>
<p>The Activity also needs to be specified in the<span> </span><kbd><span class="CodeInTextPACKT">AppWidgetProviderInfo</span></kbd><span> </span>file using the configure attribute, as shown in this example:</p>
<pre><span>android</span><span>:configure=</span><span>"com.packtpub.appwidget.AppWidgetConfigureActivity"</span></pre>
<p>The<span> </span><span class="CodeInTextPACKT">configure</span><span> </span>attribute requires the fully qualified package name as this Activity will be called from outside of your application.</p>
<div class="packt_tip">Remember, the<span> </span><kbd><span class="CodeInTextPACKT">onUpdate()</span></kbd><span> </span>method will not be called when using a configuration Activity. The configuration Activity is responsible for handling any initial setup if required.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>For App Widget Design Guidelines, visit Google's page:<span> </span><a href="http://developer.android.com/design/patterns/widgets.html"><span class="URLPACKT">http://developer.android.com/design/patterns/widgets.html</span></a></li>
<li>For detailed information on RemoteViews, visit <a href="https://developer.android.com/reference/android/widget/RemoteViews">https://developer.android.com/reference/android/widget/RemoteViews</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding Search to the Action Bar</h1>
                </header>
            
            <article>
                
<p>Along with the Action Bar, Android 3.0 introduced the<span> </span><span class="CodeInTextPACKT">SearchView</span><span> </span>widget, which<span> </span><span>can be included as a menu item when creating a menu. This is now the recommended UI pattern to provide a consistent user experience.</span></p>
<p>The following screenshot shows the initial appearance of the Search icon in the Action Bar:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bd37bc6b-7747-4d27-abca-bccde619583d.png" style="width:38.00em;height:5.67em;"/></div>
<p>The following screenshot shows how the Search option expands when pressed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d8e33142-60e2-4c0f-b107-de4e0c850759.png" style="width:38.25em;height:5.67em;"/></div>
<p>If you want to add Search functionality to your application, this recipe will walk you through the steps to set up your User Interface and properly configure the Search Manager API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it<span> </span><kbd><span class="CodeInTextPACKT">SearchView</span></kbd>. Use the default<span> </span><span class="ScreenTextPACKT">Phone &amp; Tablet</span><span> </span>options and select<span> </span><span class="ScreenTextPACKT"><span class="packt_screen">Empty Activity</span></span><span> </span>when prompted for the Activity Type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To set up the Search UI pattern, we need to create the Search menu item and a resource called<span> </span><span class="CodeInTextPACKT">searchable</span>. We'll create a second activity to receive the search query. Then, we'll hook it all up in the<span> </span><kbd><span class="CodeInTextPACKT">AndroidManifest</span></kbd><span> </span>file. To get started, open the<span> </span><kbd><span class="CodeInTextPACKT">strings.xml</span></kbd><span> </span><span>file in</span><span> </span><kbd><span class="CodeInTextPACKT">res/values</span></kbd><span> </span>and follow these steps:</p>
<ol>
<li>Add the following string resources:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;string </span><span>name=</span><span>"search_title"</span><span>&gt;</span>Search<span>&lt;/string&gt;<br/></span><span>&lt;string </span><span>name=</span><span>"search_hint"</span><span>&gt;</span>Enter text to search<span>&lt;/string&gt;</span></pre>
<ol start="2">
<li>Create the menu directory:<span> </span><kbd><span class="CodeInTextPACKT">res/menu</span></kbd>.</li>
<li>Create a new menu resource called<span> </span><kbd><span class="CodeInTextPACKT">menu_search.xml</span></kbd><span> </span>in<span> </span><kbd><span class="CodeInTextPACKT">res/menu</span></kbd><span> </span>using the following XML:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;menu </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>xmlns:</span><span>app</span><span>=</span><span>"http://schemas.android.com/apk/res-auto"</span><span>&gt;<br/></span><span>    &lt;item </span><span>android</span><span>:id=</span><span>"@+id/menu_search"<br/></span><span>        </span><span>android</span><span>:title=</span><span>"@string/search_title"<br/></span><span>        </span><span>android</span><span>:icon=</span><span>"@android:drawable/ic_menu_search"<br/></span><span>        </span><span>app</span><span>:showAsAction=</span><span>"collapseActionView|ifRoom"<br/></span><span>        </span><span>app</span><span>:actionViewClass=</span><span>"android.support.v7.widget.SearchView" </span><span>/&gt;<br/></span><span>&lt;/menu&gt;</span></pre>
<ol start="4">
<li>Open ActivityMain and add the following <kbd><span class="CodeInTextPACKT">onCreateOptionsMenu()</span></kbd><span> </span>to inflate the menu and set up the Search Manager:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>public boolean </span><span>onCreateOptionsMenu</span>(Menu menu) {<br/>    MenuInflater inflater = getMenuInflater()<span>;<br/></span><span>    </span>inflater.inflate(R.menu.<span>menu_search</span><span>, </span>menu)<span>;<br/></span><span>    </span>SearchManager searchManager = (SearchManager) getSystemService(Context.<span>SEARCH_SERVICE</span>)<span>;<br/></span><span>    </span>MenuItem searchItem = menu.findItem(R.id.<span>menu_search</span>)<span>;<br/></span><span>    </span>SearchView searchView = (SearchView) searchItem.getActionView()<span>;</span><span><br/></span><span>    </span>searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()))<span>;<br/></span><span>    return true;<br/></span>}</pre>
<ol start="5">
<li>Create a new XML resource directory:<span> </span><kbd><span class="CodeInTextPACKT">res/xml</span></kbd>.</li>
<li>Create a new file in <kbd><span class="CodeInTextPACKT">res/xml</span></kbd><span> </span>called<span> </span><kbd><span class="CodeInTextPACKT">searchable.xml</span></kbd><span> </span>using the following XML:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;searchable </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>android</span><span>:label=</span><span>"@string/app_name"<br/></span><span>    </span><span>android</span><span>:hint=</span><span>"@string/search_hint" </span><span>/&gt;</span></pre>
<ol start="7">
<li>Create a new layout called<span> </span><kbd><span class="CodeInTextPACKT">activity_search_result.xml</span></kbd><span> </span>using this XML:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;RelativeLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent" </span><span>&gt;<br/></span><span>    &lt;TextView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/textViewSearchResult"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_centerInParent=</span><span>"true" </span><span>/&gt;<br/></span><span>&lt;/RelativeLayout&gt; </span></pre>
<ol start="8">
<li>Add a new <span class="packt_screen">Empty Activity</span> to the project called<span> </span><kbd><span class="CodeInTextPACKT">SearchResultActivity</span></kbd>.</li>
<li>Add the following variable to the class:</li>
</ol>
<pre style="padding-left: 60px">TextView mTextViewSearchResult; </pre>
<ol start="10">
<li>Change <kbd><span class="CodeInTextPACKT">onCreate()</span></kbd><span> </span>to load our layout, set the TextView, and check for the<span> </span><span class="CodeInTextPACKT"><span class="packt_screen">QUERY</span></span><span> </span>action:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>protected void </span><span>onCreate</span>(Bundle savedInstanceState) {<br/>    <span>super</span>.onCreate(savedInstanceState)<span>;<br/></span><span>    </span>setContentView(R.layout.<span>activity_search_result</span>)<span>;<br/></span><span>    </span><span>mTextViewSearchResult </span>= findViewById(R.id.<span>textViewSearchResult</span>)<span>;<br/></span><span>    if </span>(Intent.<span>ACTION_SEARCH</span>.equals(getIntent().getAction())) {<br/>        handleSearch(getIntent().getStringExtra(SearchManager.<span>QUERY</span>))<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="11">
<li>Add the following method to handle the search:</li>
</ol>
<pre style="padding-left: 60px"><span>private void </span><span>handleSearch</span>(String searchQuery) {<br/>    <span>mTextViewSearchResult</span>.setText(searchQuery)<span>;<br/></span>}</pre>
<ol start="12">
<li>With the User Interface and code now complete, we just need to hook everything up correctly in the<span> </span><span class="CodeInTextPACKT">AndroidManifest</span>. Here is the complete manifest, including both activities:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;manifest </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>package=</span><span>"com.packtpub.searchview"</span><span>&gt;<br/></span><span>    &lt;application<br/></span><span>        </span><span>android</span><span>:allowBackup=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:icon=</span><span>"@mipmap/ic_launcher"<br/></span><span>        </span><span>android</span><span>:label=</span><span>"@string/app_name"<br/></span><span>        </span><span>android</span><span>:roundIcon=</span><span>"@mipmap/ic_launcher_round"<br/></span><span>        </span><span>android</span><span>:supportsRtl=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:theme=</span><span>"@style/AppTheme"</span><span>&gt;<br/></span><span>        &lt;meta-data </span><span>android</span><span>:name=</span><span>"android.app.default_searchable"<br/></span><span>            </span><span>android</span><span>:value=</span><span>".SearchResultActivity" </span><span>/&gt;<br/></span><span>        &lt;activity </span><span>android</span><span>:name=</span><span>".MainActivity"</span><span>&gt;<br/></span><span>            &lt;intent-filter&gt;<br/></span><span>                &lt;action </span><span>android</span><span>:name=</span><span>"android.intent.action.MAIN" </span><span>/&gt;<br/></span><span>                &lt;category </span><span>android</span><span>:name=</span><span>"android.intent.category.LAUNCHER" </span><span>/&gt;<br/></span><span>            &lt;/intent-filter&gt;<br/></span><span>        &lt;/activity&gt;<br/></span><span>        &lt;activity </span><span>android</span><span>:name=</span><span>".SearchResultActivity"</span><span>&gt;<br/></span><span>            &lt;intent-filter&gt;<br/></span><span>                &lt;action </span><span>android</span><span>:name=</span><span>"android.intent.action.SEARCH" </span><span>/&gt;<br/></span><span>            &lt;/intent-filter&gt;<br/></span><span>            &lt;meta-data </span><span>android</span><span>:name=</span><span>"android.app.searchable"<br/></span><span>                </span><span>android</span><span>:resource=</span><span>"@xml/searchable" </span><span>/&gt;<br/></span><span>        &lt;/activity&gt;<br/></span><span>    &lt;/application&gt;<br/></span><span>&lt;/manifest&gt;</span></pre>
<ol start="13">
<li>Run the application on a device or emulator. Type in a search query and hit the<span> </span><span class="ScreenTextPACKT">Search</span><span> </span>button (or press <em>Enter</em>). The<span> </span><span class="CodeInTextPACKT"><span class="packt_screen">SearchResultActivity</span></span><span> </span>will be displayed, showing the search query entered.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Since the New Project Wizard uses the<span> </span><span class="CodeInTextPACKT">AppCompat</span><span> </span>library, our example uses the support library API. Using the support library provides the greatest device compatibility as it allows the use of modern features (such as the Action Bar) on older versions of the Android OS. This can sometimes provide an extra challenge as often the official documentation focuses on the framework API. Although usually the support library closely follows the framework API, they are not always interchangeable. The Search UI pattern is one of those situations, so it's worth paying extra attention to the steps outlined previously.</p>
<p>We start by creating string resources for the<span> </span><span class="CodeInTextPACKT">Search View (which is declared later in </span>step 6.)</p>
<p>In step 3, we create the menu resource, as we've done many times. One difference is that we use the<span> </span><span class="CodeInTextPACKT">app</span><span> </span>namespace for the<span> </span><kbd><span class="CodeInTextPACKT">showAsAction</span></kbd><span> </span>and<span> </span><kbd><span class="CodeInTextPACKT">actionViewClass</span></kbd><span> </span>attributes. The earlier versions of the Android OS don't include these attributes in the Android namespace, which is why we create an app namespace. This serves as a way to bring new functionality to older versions of the Android OS.</p>
<p>In step 4, we set up the<span> </span><span class="CodeInTextPACKT">SearchManager</span>, using the support library APIs.</p>
<p>Step 6 is where we define the<span> </span><span class="CodeInTextPACKT">searchable XML resource</span>, which is used by the<span> </span><span class="CodeInTextPACKT">SearchManager</span>. The only required attribute is the<span> </span><span class="CodeInTextPACKT">label</span>, but a <span class="CodeInTextPACKT">hint</span><span> </span><span>is recommended so the user will have an idea of what they should type in the field.</span></p>
<div class="packt_tip">The<span> </span><kbd><span class="CodeInTextPACKT">android:label</span></kbd><span> </span>must match the application name or the activity name and must use a string resource (as it does not work with a hardcoded string).</div>
<p>Steps 7-11 are for the<span> </span><kbd><span class="CodeInTextPACKT">SearchResultActivity</span></kbd>. Calling the second activity is not a requirement of the<span> </span><span class="CodeInTextPACKT">SearchManager</span><span>, but is commonly done to provide a single activity for all searches initiated in your application.</span></p>
<p>If you ran the application at this point, you would see the search icon, but nothing would work. Step 12 is where we put it all together in the<span> </span><kbd><span class="CodeInTextPACKT">AndroidManifest</span></kbd><span> </span><span>file. The first item to note is the following:</span></p>
<pre><span>&lt;meta-data </span><span>android</span><span>:name=</span><span>"android.app.default_searchable"<br/></span><span>    </span><span>android</span><span>:value=</span><span>".SearchResultActivity" </span><span>/&gt;</span></pre>
<p>Notice this is in the <kbd>&lt;application&gt;</kbd> element and not in either of the<span> </span><kbd><span class="CodeInTextPACKT">&lt;activity&gt;</span></kbd><span> </span>elements. By defining it at the <kbd>&lt;application&gt;</kbd> level, it will automatically apply to all <kbd>&lt;activities&gt;</kbd>. If we moved it to the <kbd>MainActivity</kbd> element, it would behave exactly the same in our example.</p>
<div class="packt_tip">You can define styles for your application in the <span><kbd>&lt;application&gt;</kbd> node and still override individual activity styles in the <kbd>&lt;activity&gt;</kbd> node.</span></div>
<p>We specify the searchable resource in the<span> </span><span class="CodeInTextPACKT">SearchResultActivity <kbd>&lt;meta-data&gt;</kbd></span><span> </span>element:</p>
<pre><span>&lt;meta-data </span><span>android</span><span>:name=</span><span>"android.app.searchable"<br/></span><span>    </span><span>android</span><span>:resource=</span><span>"@xml/searchable" </span><span>/&gt;</span></pre>
<p>We also need to set the intent filter for<span> </span><kbd><span class="CodeInTextPACKT">SearchResultActivity</span></kbd><span> </span>as we do here:</p>
<pre><span>&lt;intent-filter&gt;<br/></span><span>    &lt;action </span><span>android</span><span>:name=</span><span>"android.intent.action.SEARCH" </span><span>/&gt;<br/></span><span>&lt;/intent-filter&gt;</span></pre>
<p>The<span> </span><span class="CodeInTextPACKT">SearchManager</span><span> </span>broadcasts the<span> </span><span class="CodeInTextPACKT">SEARCH</span><span> </span>intent when the user initiates the search. This declaration directs the intent to the<span> </span><span class="CodeInTextPACKT">SearchResultActivity</span><span> </span>activity. Once the search is triggered, the query text is sent to the<span> </span><span class="CodeInTextPACKT">SearchResultActivity</span><span> </span>using the<span> </span><span class="CodeInTextPACKT">SEARCH</span><span> </span>intent. We check for the<span> </span><span class="CodeInTextPACKT">SEARCH</span><span> </span>intent in the<span> </span><kbd><span class="CodeInTextPACKT">onCreate()</span></kbd><span> </span>and extract the query string using the following code:</p>
<pre><span>if </span>(Intent.<span>ACTION_SEARCH</span>.equals(getIntent().getAction())) {<br/>    handleSearch(getIntent().getStringExtra(SearchManager.<span>QUERY</span>))<span>;<br/></span>}</pre>
<p>You now have the Search UI pattern fully implemented. With the UI pattern complete, what you do with the search results is specific to your application needs. Depending on your application, you might search a local database or maybe a web service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p><span>To take your search to the internet, see i<span class="ItalicsPACKT">nternet queries</span> in <span class="ChapterrefPACKT"><a href="d130c363-73b4-48bd-aa87-e4398aef7664.xhtml">Chapter 13</a></span>,<em> <span class="ItalicsPACKT">Telephony, Networks, and the Web</span>.</em></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing your app full-screen</h1>
                </header>
            
            <article>
                
<p>Android 4.4 (API 19) introduced a UI feature called Immersive Mode. Unlike the previous full-screen flag, your app receives all touch events while in Immersive Mode. This mode is ideal for certain activities, such as reading books and news, full-screen drawing, gaming, or watching a video. There are several different approaches to full-screen, and each has a best use case:</p>
<ul>
<li><span>Reading books/articles, and so on: Immersive Mode with easy access to the<br/>
System UI</span></li>
<li>Game/drawing app: Immersive Mode for full-screen use but minimal System UI</li>
<li>Watching video: Full-screen and normal System UI</li>
</ul>
<p>The key difference between the modes is how the System UI responds. In the first two scenarios, your app is expecting user interaction, so the System UI is hidden to make it easier for your user (such as not hitting the back button while playing a game). While using full-screen with a normal System UI, such as watching a video, you wouldn't expect your user to use the screen at all, so when they do the System UI should respond normally. In all modes, the user can bring back the System UI with a swipe inward across the hidden System Bar.</p>
<p>Since watching a video doesn't require the new<span> </span><span class="KeyWordPACKT">Immersive Mode</span>, full-screen mode can be achieved using two flags,<span> </span><kbd><span class="CodeInTextPACKT">SYSTEM_UI_FLAG_FULLSCREEN</span></kbd><span> </span>and<span> </span><kbd><span class="CodeInTextPACKT">SYSTEM_UI_FLAG_HIDE_NAVIGATION</span></kbd>, available since Android 4.0 (API 14).</p>
<p>Our recipe will demonstrate setting up Immersive Mode. We're also going to add the ability to toggle the System UI with a tap on the screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and call it<span> </span><kbd><span class="CodeInTextPACKT">ImmersiveMode</span></kbd>. Use the default<span> </span><span class="ScreenTextPACKT">Phone &amp; Tablet</span><span> </span>options and select<span> </span><span class="ScreenTextPACKT"><span class="packt_screen">Empty Activity</span></span><span> </span>when prompted for the<span> </span><span class="ScreenTextPACKT">Activity Type</span>. When selecting the<span> </span><span class="ScreenTextPACKT">Minimum API Level</span>, choose<span> </span><span class="ScreenTextPACKT">API 19</span><span> </span>or higher.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We'll create two functions for handling the System UI visibility, then we'll create a gesture listener to detect when the user taps on the screen. All the steps for this recipe are adding code to<span> </span><kbd><span class="CodeInTextPACKT">MainActivity.java</span></kbd>, so open the file and let's begin:</p>
<ol>
<li>Add the following method to hide the System UI:</li>
</ol>
<pre style="padding-left: 60px"><span>private void </span><span>hideSystemUi</span>() {<br/>    getWindow().getDecorView().setSystemUiVisibility(View.<span>SYSTEM_UI_FLAG_IMMERSIVE </span>|<br/>            View.<span>SYSTEM_UI_FLAG_FULLSCREEN </span>|<br/>            View.<span>SYSTEM_UI_FLAG_LAYOUT_STABLE </span>|<br/>            View.<span>SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION </span>|<br/>            View.<span>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN </span>|<br/>            View.<span>SYSTEM_UI_FLAG_HIDE_NAVIGATION</span>)<span>;</span><span><br/></span>}</pre>
<ol start="2">
<li>Add the following method to show the System UI:</li>
</ol>
<pre style="padding-left: 60px"><span>private void </span><span>showSystemUI</span>() {<br/>    getWindow().getDecorView().setSystemUiVisibility(<br/>            View.<span>SYSTEM_UI_FLAG_LAYOUT_STABLE </span>|<br/>            View.<span>SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION </span>|<br/>            View.<span>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</span>)<span>;</span><span><br/></span>}</pre>
<ol start="3">
<li>Add the following class variable:</li>
</ol>
<pre style="padding-left: 60px">private GestureDetectorCompat mGestureDetector;</pre>
<ol start="4">
<li>Add the following<span> </span><kbd><span class="CodeInTextPACKT">GestureListener</span></kbd><span> </span>class at the class level, below the previous class variable:</li>
</ol>
<pre style="padding-left: 60px"><span>private class </span>GestureListener <span>extends </span>GestureDetector.SimpleOnGestureListener {<br/>    <span>@Override<br/></span><span>    </span><span>public boolean </span><span>onDown</span>(MotionEvent event) {<br/>        <span>return true;<br/></span><span>    </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public boolean </span><span>onFling</span>(MotionEvent event1<span>, </span>MotionEvent event2<span>, <br/></span><span>                           float </span>velocityX<span>, float </span>velocityY) {<br/>        <span>return true;<br/></span><span>    </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public boolean </span><span>onSingleTapUp</span>(MotionEvent e) {<br/>        <span>if </span>(getSupportActionBar()!= <span>null </span>&amp;&amp; getSupportActionBar().isShowing()) {<br/>            hideSystemUi()<span>;<br/></span><span>        </span>} <span>else </span>{<br/>            showSystemUI()<span>;<br/></span><span>        </span>}<br/>        <span>return true;<br/></span><span>    </span>}<br/>}</pre>
<ol start="5">
<li>Override the<span> </span><kbd><span class="CodeInTextPACKT">onTouchEvent()</span></kbd><span> </span>callback with the following:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>public boolean </span><span>onTouchEvent</span>(MotionEvent event) {<br/>    <span>mGestureDetector</span>.onTouchEvent(event)<span>;<br/></span><span>    return super</span>.onTouchEvent(event)<span>;<br/></span>}</pre>
<ol start="6">
<li>Add the following code to the<span> </span><kbd><span class="CodeInTextPACKT">onCreate()</span></kbd><span> </span>method to set the<span> </span><span class="CodeInTextPACKT">GestureListener</span><span> </span>and hide the System UI:</li>
</ol>
<pre style="padding-left: 60px"><span>mGestureDetector </span>= <span>new </span>GestureDetectorCompat(<span>this, new </span>GestureListener())<span>;<br/></span>hideSystemUi()<span>;</span></pre>
<ol start="7">
<li>Run the application on a device or emulator. Tapping the screen will toggle the System UI. Depending on your version of the Android OS, you can either swipe up from the bottom or swipe down from the top to reveal the System UI.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We call <kbd><span class="CodeInTextPACKT">setSystemUiVisibility()</span></kbd><span> with the appropriate flags in the</span><span> </span><kbd><span class="CodeInTextPACKT">showSystemUI()</span></kbd><span> </span>and<span> </span><kbd><span class="CodeInTextPACKT">hideSystemUI()</span></kbd><span> </span>methods to set the application window state. The flags we set (and don't set) control what is visible and what is hidden. When we set the visibility without the<span> </span><kbd><span class="CodeInTextPACKT">SYSTEM_UI_FLAG_IMMERSIVE</span></kbd><span> </span>flag, we in effect disable Immersive Mode.</p>
<p>If all we wanted to do was hide the System UI, we could just add<span> </span><kbd><span class="CodeInTextPACKT">hideSystemUI()</span></kbd><span> </span>to<span> </span><kbd><span class="CodeInTextPACKT">onCreate()</span></kbd><span> </span>and we'd be done. The problem is it wouldn't stay hidden. Once the user left Immersive Mode, it would stay in the regular display mode. That's why we created the<span> </span><kbd><span class="CodeInTextPACKT">GestureListener</span></kbd><span>. (We'll discuss gestures again in <a href="9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em><span class="ItalicsPACKT">Using the Touchscreen and Sensors</span></em>.) Since we only want to respond to the</span><span> </span><kbd><span class="CodeInTextPACKT">onSingleTapUp()</span></kbd><span> </span>gesture, we don't implement the full range of gestures. When<span> </span><kbd><span class="CodeInTextPACKT">onSingleTapUp</span></kbd><span> </span>is detected, we toggle the System UI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Let's look at some other important tasks that can be performed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sticky Immersion</h1>
                </header>
            
            <article>
                
<p>There's another option we can use if we want the System UI to stay hidden automatically. Instead of using<span> </span><kbd><span class="CodeInTextPACKT">SYSTEM_UI_FLAG_IMMERSIVE</span></kbd><span> </span>to hide the UI, we can use<span> </span><kbd><span class="CodeInTextPACKT">SYSTEM_UI_FLAG_IMMERSIVE_STICKY</span></kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dimming the System UI</h1>
                </header>
            
            <article>
                
<p>If all you need is to reduce the visibility of the Navigation bar, there's also<span> </span><kbd><span class="CodeInTextPACKT">SYSTEM_UI_FLAG_LOW_PROFILE</span></kbd><span> </span>to dim the UI.</p>
<p>Use this flag with the same<span> </span><kbd><span class="CodeInTextPACKT">setSystemUiVisibility()</span></kbd><span> </span>call as the Immersive Mode flag:</p>
<pre>getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE); </pre>
<p>Call<span> </span><kbd><span class="CodeInTextPACKT">setSystemUiVisibility()</span></kbd><span> </span>with 0 to clear all flags:</p>
<pre>getWindow().getDecorView().setSystemUiVisibility(0); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting the Action Bar as an overlay</h1>
                </header>
            
            <article>
                
<p>If you just need to hide or show the Action Bar, use these methods:</p>
<pre>getActionBar().hide(); 

getActionBar().show(); </pre>
<p>One problem with this approach is that the system resizes the layout each time either method is called. Instead, you might want to consider using a theme option to make the System UI behave as an overlay. To enable overlay mode, add the following to the theme:</p>
<pre>&lt;item name="android:windowActionBarOverlay"&gt;true&lt;/item&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Translucent system bars</h1>
                </header>
            
            <article>
                
<p>The following two themes enable translucent settings:</p>
<pre>Theme.Holo.NoActionBar.TranslucentDecor 

Theme.Holo.Light.NoActionBar.TranslucentDecor </pre>
<p>If you are creating your own theme, use the following theme settings:</p>
<pre>&lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt; 

&lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p><span>For more on handling gestures, refer to <a href="9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>,<em> <span class="ItalicsPACKT">Using the Touchscreen and Sensors</span></em>.</span></p>


            </article>

            
        </section>
    </body></html>