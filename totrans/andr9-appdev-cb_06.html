<html><head></head><body>
        

                            
                    <h1 class="header-title">Home Screen Widgets, Search, and the System UI</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating a shortcut on the Home screen</li>
<li>Creating a Home screen widget</li>
<li>Adding Search to the Action Bar</li>
<li>Showing your app full-screen</li>
<li>Lock screen shortcuts</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>With an understanding of Fragments from the previous chapter, we're ready to expand on our discussion of widgets. In <a href="3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml" target="_blank">Chapter 3</a>,<em> Views, Widgets, and Styles</em>, we discussed how to add widgets to your own app. Now, we'll look at how to create an App Widget so users can add your app on their Home screen.</p>
<p>The remaining recipes in this chapter will explore System UI options. There's a recipe for adding a Search option to the Action Bar using the Android SearchManager API. Another recipe will explore Full Screen mode and several additional variations on altering the System UI. The final recipe will showcase the new Lock Screen shortcuts introduced in Android O (API 26).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a shortcut on the Home screen</h1>
                
            
            
                
<p>This recipe explains how to create a link or create a shortcut for your app on the user's Home screen. So as not to be too obtrusive, it's generally best to make this an option for the user to initiate, such as in the settings.</p>
<p>The following is a screenshot showing our shortcut on the Home screen:</p>
<div><img src="img/c0c71732-d9bd-4752-af84-086fd7d0bbab.png" style="width:23.00em;height:43.42em;"/></div>
<p>As you can see, this is just a shortcut to your app. The next recipe will go deeper by creating a Home screen (AppWidget).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>HomeScreenShortcut</kbd>. Use the default Phone &amp; Tablet options and select the Empty Activity option when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>For an app to create a shortcut, it must have the <kbd>INSTALL_SHORTCUT</kbd> permission. With the appropriate permission, it's a simple matter of calling an intent with your app properties. The following are the steps:</p>
<ol>
<li>Open the <kbd>AndroidManifest</kbd> file and add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT" /&gt;</pre>
<ol start="2">
<li>Next, open <kbd>activity_main.xml</kbd> and replace the existing TextView with the following button:</li>
</ol>
<pre style="padding-left: 60px">&lt;Button<br/>    android:id="@+id/button"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Create Shortcut"<br/>    android:onClick="createShortcut"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="3">
<li>Add the following method to <kbd>ActivityMain.java</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public void createShortcut(View view) {<br/>    Intent shortcutIntent = new Intent(this, MainActivity.class);<br/>    shortcutIntent.setAction(Intent.ACTION_MAIN);<br/>    Intent intent = new Intent();<br/>    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);<br/>    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, getString(R.string.app_name));<br/>    intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,<br/>            Intent.ShortcutIconResource.fromContext(this, R.mipmap.ic_launcher));<br/>    intent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");<br/>    sendBroadcast(intent);<br/>}</pre>
<ol start="4">
<li>Run the program on a device or emulator. Notice that, each time you press the button, the app will make a shortcut on the Home screen.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Once you set up the proper permission, this is a rather straightforward task. When the button is clicked, the code creates two intents. The first intent broadcasts to the OS that you want a shortcut created. The second intent is the intent that launches your app when the icon is pressed. One important consideration to keep in mind is that Home screens vary and may not support the <kbd>INSTALL_SHORTCUT</kbd> intent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you also wanted to remove the shortcut, you would need the following permission:</p>
<pre>&lt;uses-permission android:name="com.android.launcher.permission.UNINSTALL_SHORTCUT" /&gt;</pre>
<p>Instead of using the <kbd>INSTALL_SHORTCUT</kbd> action, you would set the following action instead:</p>
<pre>com.android.launcher.action.UNINSTALL_SHORTCUT </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Home screen widget</h1>
                
            
            
                
<p>Before we dig into the code for creating an App Widget, let's cover the basics. There are three required and one optional component:</p>
<ul>
<li>The <kbd>AppWidgetProviderInfo</kbd> file: It's an XML resource (described later)</li>
<li>The <kbd>AppWidgetProvider class</kbd>: This is a Java class</li>
<li>The <kbd>View layout</kbd> file: It's a standard layout XML file, with some restrictions (explained later)</li>
<li>The App Widget configuration Activity (optional): This is an Activity the OS will launch when placing the widget to provide configuration options</li>
</ul>
<p>The <kbd>AppWidgetProvider</kbd> must also be declared in the <kbd>AndroidManifest</kbd> file. Since <kbd>AppWidgetProvider</kbd> is a helper class based on the Broadcast Receiver, it is declared in the manifest with the <kbd>&lt;receiver&gt;</kbd> element. Here is an example manifest entry:</p>
<pre>&lt;receiver android:name=".HomescreenWidgetProvider" &gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;<br/>    &lt;/intent-filter&gt;<br/>    &lt;meta-data android:name="android.appwidget.provider"<br/>        android:resource="@xml/appwidget_info" /&gt;<br/>&lt;/receiver&gt;</pre>
<p>The metadata points to the <kbd>AppWidgetProviderInfo</kbd> file, which is placed in the <kbd>res/xml</kbd> directory. Here is a sample <kbd>AppWidgetProviderInfo.xml</kbd> file:</p>
<pre>&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:minWidth="40dp"<br/>    android:minHeight="40dp"<br/>    android:updatePeriodMillis="0"<br/>    android:initialLayout="@layout/widget"<br/>    android:resizeMode="none"<br/>    android:widgetCategory="home_screen"&gt;<br/>&lt;/appwidget-provider&gt;</pre>
<p>The following is a brief overview of the available attributes:</p>
<ul>
<li><kbd>minWidth</kbd>: The default width when placed on the Home screen</li>
<li><kbd>minHeight</kbd>: The default height when placed on the Home screen</li>
<li><kbd>updatePeriodMillis</kbd>: It's part of the <kbd>onUpdate()</kbd> polling interval (in milliseconds)</li>
<li><kbd>initialLayout</kbd>: The AppWidget layout</li>
<li><kbd>previewImage</kbd> (optional): The image shown when browsing App Widgets</li>
<li><kbd>configure</kbd> (optional): The activity to launch for configuration settings</li>
<li><kbd>resizeMode</kbd> (optional): The flags indicate resizing options: horizontal, vertical, none</li>
<li><kbd>minResizeWidth</kbd> (optional): The minimum width allowed when resizing</li>
<li><kbd>minResizeHeight</kbd> (optional): The minimum height allowed when resizing</li>
<li><kbd>widgetCategory</kbd> (optional): Android 5+ only supports Home screen widgets</li>
</ul>
<p>The <kbd>AppWidgetProvider</kbd> extends the <kbd>BroadcastReceiver</kbd> class, which is why the <kbd>&lt;receiver&gt;</kbd> element is used when declaring the AppWidget in the Manifest. As it's <kbd>BroadcastReceiver</kbd>, the class still receives OS broadcast events, but the helper class filters those events down to those applicable for an App Widget. The <kbd>AppWidgetProvider</kbd> class exposes the following methods:</p>
<ul>
<li><kbd>onUpdate()</kbd>: It's called when initially created and at the interval specified.</li>
<li><kbd>onAppWidgetOptionsChanged()</kbd>: It's called when initially created and any time the size changes.</li>
<li><kbd>onDeleted()</kbd>: It's called any time a widget is removed.</li>
<li><kbd>onEnabled()</kbd>: It's called the first time a widget is placed (it isn't called when adding second and subsequent widgets).</li>
<li><kbd>onDisabled()</kbd>: It's called when the last widget is removed.</li>
<li><kbd>onReceive()</kbd>: It's called on every event received, including the preceding event. Usually not overridden as the default implementation only sends applicable events.</li>
</ul>
<p>The last required component is the layout. An App Widget uses a Remote View, which only supports a subset of the available layouts:</p>
<ul>
<li>AdapterViewFlipper</li>
<li>FrameLayout</li>
<li>GridLayout</li>
<li>GridView</li>
<li>LinearLayout</li>
<li>ListView</li>
<li>RelativeLayout</li>
<li>StackView</li>
<li>ViewFlipper</li>
</ul>
<p>And it supports the following widgets:</p>
<ul>
<li>AnalogClock</li>
<li>Button</li>
<li>Chronometer</li>
<li>ImageButton</li>
<li>ImageView</li>
<li>ProgressBar</li>
<li>TextClock</li>
<li>TextView</li>
</ul>
<p>With App Widget basics covered, it's now time to start coding. Our example will cover the basics so you can expand the functionality as needed. This recipe uses a View with a clock, which, when pressed, opens our activity.</p>
<p>The following screenshot shows the widget in the widget list when adding it to the Home screen:</p>
<div><img src="img/24cd27b9-b7e1-4ac7-b7b3-b5634da66d8a.png" style="width:21.08em;height:42.42em;"/></div>
<p>The purpose of the image is to show how to add a widget to the home screen</p>
<p>The widget list's appearance varies by the launcher used.</p>
<p>Here's a screenshot showing the widget after it is added to the Home screen:</p>
<div><img src="img/acaa88e4-26cc-4f86-8bb8-623eddeaeda4.png" style="width:16.58em;height:33.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it AppWidget. Use the default Phone &amp; Tablet options and select the Empty Activity option when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll start by creating the widget layout, which resides in the standard layout resource directory. Then, we'll create the XML resource directory to store the <kbd>AppWidgetProviderInfo</kbd> file. We'll add a new Java class and extend <kbd>AppWidgetProvider</kbd>, which handles the <kbd>onUpdate()</kbd> call for the widget. With the receiver created, we can then add it to the Android Manifest.</p>
<p>Here are the detailed steps:</p>
<ol>
<li>Create a new file in <kbd>res/layout</kbd> called <kbd>widget.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"&gt;<br/>    &lt;AnalogClock<br/>        android:id="@+id/analogClock"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:layout_centerVertical="true"<br/>        android:layout_centerHorizontal="true" /&gt;<br/>&lt;/RelativeLayout&gt;</pre>
<ol start="2">
<li>Create a new directory called XML in the resource directory. The final result will be <kbd>res/xml</kbd>.</li>
<li>Create a new file in <kbd>res/xml</kbd> called <kbd>appwidget_info.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:minWidth="40dp"<br/>    android:minHeight="40dp"<br/>    android:updatePeriodMillis="0"<br/>    android:initialLayout="@layout/widget"<br/>    android:resizeMode="none"<br/>    android:widgetCategory="home_screen"&gt;<br/>&lt;/appwidget-provider&gt;</pre>
<p>If you cannot see the new XML directory, switch from Android view to Project view in the Project panel drop-down.</p>
<ol start="4">
<li>Create a new Java class called <kbd>HomescreenWidgetProvider</kbd>, extending from <kbd>AppWidgetProvider</kbd>.</li>
<li>Add the following <kbd>onUpdate()</kbd> method to the <kbd>HomescreenWidgetProvider</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {<br/>    super.onUpdate(context, appWidgetManager, appWidgetIds);<br/><br/>    for (int count=0; count&lt;appWidgetIds.length; count++) {<br/>        RemoteViews appWidgetLayout = new<br/>                RemoteViews(context.getPackageName(),<br/>                R.layout.widget);<br/>        Intent intent = new Intent(context, MainActivity.class);<br/>        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);<br/>        appWidgetLayout.setOnClickPendingIntent(R.id.analogClock, pendingIntent);<br/>        appWidgetManager.updateAppWidget(appWidgetIds[count], appWidgetLayout);<br/>    }<br/>}</pre>
<ol start="6">
<li>Add the <kbd>HomescreenWidgetProvider</kbd> to the AndroidManifest using the following XML declaration within the <kbd>&lt;application&gt;</kbd> element:</li>
</ol>
<pre style="padding-left: 60px">&lt;receiver android:name=".HomescreenWidgetProvider" &gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;<br/>    &lt;/intent-filter&gt;<br/>    &lt;meta-data android:name="android.appwidget.provider"<br/>        android:resource="@xml/appwidget_info" /&gt;<br/>&lt;/receiver&gt;</pre>
<ol start="7">
<li>Run the program on a device or emulator. After first running the application, the widget will then be available to add to the Home screen.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Our first step is to create the layout file for the widget. This is a standard layout resource with the restrictions based on the App Widget being a Remote View, as discussed in the recipe introduction. Although our example uses an Analog Clock widget, this is where you'd want to expand the functionality based on your application needs.</p>
<p>The XML resource directory serves to store the AppWidgetProviderInfo, which defines the default widget settings. The configuration settings determine how the widget is displayed when initially browsing the available widgets. We use very basic settings for this recipe, but they can easily be expanded to include additional features, such as a preview image to show<br/>
a functioning widget and sizing options. The <kbd>updatePeriodMillis</kbd> attribute sets the update frequency. Since the update will wake up the device, it's a trade-off between having up-to-date data and battery life. (This is where the optional Settings Activity is useful by letting the user decide.)</p>
<p>The <kbd>AppWidgetProvider</kbd> class is where we handle the <kbd>onUpdate()</kbd> event triggered by the <kbd>updatePeriodMillis</kbd> polling. Our example doesn't need any updating so we set the polling to zero. The update is still called when initially placing the widget. <kbd>onUpdate()</kbd> is where we set the pending intent to open our app when the clock is pressed.</p>
<p>Since the <kbd>onUpdate()</kbd> method is probably the most complicated aspect of AppWidgets, we'll explain this in some detail. First, it's worth noting that <kbd>onUpdate() </kbd>will occur only once each polling interval for all the widgets is created by this provider. (All additional widgets created will use the same cycle as the first widget created.) This explains the for loop, as we need it to iterate through all the existing widgets. This is where we create a pending intent, which calls our app when the clock widget is pressed. As discussed earlier, an AppWidget is a Remote View. Therefore, to get the layout, we call <kbd>RemoteViews()</kbd> with our fully qualified package name and the layout ID. Once we have the layout, we can attach the pending intent to the clock view using <kbd>setOnClickPendingIntent()</kbd>. We call the AppWidgetManager named <kbd>updateAppWidget()</kbd> to initiate the changes we made.</p>
<p>The last step to make all this work is to declare the widget in the Android Manifest. We identify the action we want to handle with the <kbd>&lt;intent-filter&gt;</kbd>. Most App Widgets will likely want to handle the Update event, as ours does. The other item to note in the declaration is the following line:</p>
<pre>&lt;meta-data android:name="android.appwidget.provider" 

    android:resource="@xml/appwidget_info" /&gt;</pre>
<p>This tells the system where to find our configuration file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Adding an App Widget configuration Activity allows greater flexibility with your widget. Not only can you offer polling options, but you could offer different layouts, click behaviors, and so on. Users tend to really appreciate flexible App Widgets.</p>
<p>Adding a configuration Activity requires a few additional steps. The Activity needs to be declared in the Manifest as usual, but needs to include the <kbd>APPWIDGET_CONFIGURE</kbd> action, as shown in the following example:</p>
<pre>&lt;activity android:name=".AppWidgetConfigureActivity"&gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.appwidget.action.APPWIDGET_CONFIGURE"/&gt;<br/>    &lt;/intent-filter&gt;<br/>&lt;/activity&gt;</pre>
<p>The Activity also needs to be specified in the <kbd>AppWidgetProviderInfo</kbd> file using the configure attribute, as shown in this example:</p>
<pre>android:configure="com.packtpub.appwidget.AppWidgetConfigureActivity"</pre>
<p>The configure attribute requires the fully qualified package name as this Activity will be called from outside of your application.</p>
<p>Remember, the <kbd>onUpdate()</kbd> method will not be called when using a configuration Activity. The configuration Activity is responsible for handling any initial setup if required.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>For App Widget Design Guidelines, visit Google's page: <a href="http://developer.android.com/design/patterns/widgets.html">http://developer.android.com/design/patterns/widgets.html</a></li>
<li>For detailed information on RemoteViews, visit <a href="https://developer.android.com/reference/android/widget/RemoteViews">https://developer.android.com/reference/android/widget/RemoteViews</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Search to the Action Bar</h1>
                
            
            
                
<p>Along with the Action Bar, Android 3.0 introduced the SearchView widget, which can be included as a menu item when creating a menu. This is now the recommended UI pattern to provide a consistent user experience.</p>
<p>The following screenshot shows the initial appearance of the Search icon in the Action Bar:</p>
<div><img src="img/bd37bc6b-7747-4d27-abca-bccde619583d.png" style="width:38.00em;height:5.67em;"/></div>
<p>The following screenshot shows how the Search option expands when pressed:</p>
<div><img src="img/d8e33142-60e2-4c0f-b107-de4e0c850759.png" style="width:38.25em;height:5.67em;"/></div>
<p>If you want to add Search functionality to your application, this recipe will walk you through the steps to set up your User Interface and properly configure the Search Manager API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>SearchView</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To set up the Search UI pattern, we need to create the Search menu item and a resource called searchable. We'll create a second activity to receive the search query. Then, we'll hook it all up in the <kbd>AndroidManifest</kbd> file. To get started, open the <kbd>strings.xml</kbd> file in <kbd>res/values</kbd> and follow these steps:</p>
<ol>
<li>Add the following string resources:</li>
</ol>
<pre style="padding-left: 60px">&lt;string name="search_title"&gt;Search&lt;/string&gt;<br/>&lt;string name="search_hint"&gt;Enter text to search&lt;/string&gt;</pre>
<ol start="2">
<li>Create the menu directory: <kbd>res/menu</kbd>.</li>
<li>Create a new menu resource called <kbd>menu_search.xml</kbd> in <kbd>res/menu</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/>    &lt;item android:id="@+id/menu_search"<br/>        android:title="@string/search_title"<br/>        android:icon="@android:drawable/ic_menu_search"<br/>        app:showAsAction="collapseActionView|ifRoom"<br/>        app:actionViewClass="android.support.v7.widget.SearchView" /&gt;<br/>&lt;/menu&gt;</pre>
<ol start="4">
<li>Open ActivityMain and add the following <kbd>onCreateOptionsMenu()</kbd> to inflate the menu and set up the Search Manager:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public boolean onCreateOptionsMenu(Menu menu) {<br/>    MenuInflater inflater = getMenuInflater();<br/>    inflater.inflate(R.menu.menu_search, menu);<br/>    SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);<br/>    MenuItem searchItem = menu.findItem(R.id.menu_search);<br/>    SearchView searchView = (SearchView) searchItem.getActionView();<br/>    searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));<br/>    return true;<br/>}</pre>
<ol start="5">
<li>Create a new XML resource directory: <kbd>res/xml</kbd>.</li>
<li>Create a new file in <kbd>res/xml</kbd> called <kbd>searchable.xml</kbd> using the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;searchable xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:label="@string/app_name"<br/>    android:hint="@string/search_hint" /&gt;</pre>
<ol start="7">
<li>Create a new layout called <kbd>activity_search_result.xml</kbd> using this XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" &gt;<br/>    &lt;TextView<br/>        android:id="@+id/textViewSearchResult"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:layout_centerInParent="true" /&gt;<br/>&lt;/RelativeLayout&gt; </pre>
<ol start="8">
<li>Add a new Empty Activity to the project called <kbd>SearchResultActivity</kbd>.</li>
<li>Add the following variable to the class:</li>
</ol>
<pre style="padding-left: 60px">TextView mTextViewSearchResult; </pre>
<ol start="10">
<li>Change <kbd>onCreate()</kbd> to load our layout, set the TextView, and check for the QUERY action:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected void onCreate(Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    setContentView(R.layout.activity_search_result);<br/>    mTextViewSearchResult = findViewById(R.id.textViewSearchResult);<br/>    if (Intent.ACTION_SEARCH.equals(getIntent().getAction())) {<br/>        handleSearch(getIntent().getStringExtra(SearchManager.QUERY));<br/>    }<br/>}</pre>
<ol start="11">
<li>Add the following method to handle the search:</li>
</ol>
<pre style="padding-left: 60px">private void handleSearch(String searchQuery) {<br/>    mTextViewSearchResult.setText(searchQuery);<br/>}</pre>
<ol start="12">
<li>With the User Interface and code now complete, we just need to hook everything up correctly in the AndroidManifest. Here is the complete manifest, including both activities:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"<br/>    package="com.packtpub.searchview"&gt;<br/>    &lt;application<br/>        android:allowBackup="true"<br/>        android:icon="@mipmap/ic_launcher"<br/>        android:label="@string/app_name"<br/>        android:roundIcon="@mipmap/ic_launcher_round"<br/>        android:supportsRtl="true"<br/>        android:theme="@style/AppTheme"&gt;<br/>        &lt;meta-data android:name="android.app.default_searchable"<br/>            android:value=".SearchResultActivity" /&gt;<br/>        &lt;activity android:name=".MainActivity"&gt;<br/>            &lt;intent-filter&gt;<br/>                &lt;action android:name="android.intent.action.MAIN" /&gt;<br/>                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br/>            &lt;/intent-filter&gt;<br/>        &lt;/activity&gt;<br/>        &lt;activity android:name=".SearchResultActivity"&gt;<br/>            &lt;intent-filter&gt;<br/>                &lt;action android:name="android.intent.action.SEARCH" /&gt;<br/>            &lt;/intent-filter&gt;<br/>            &lt;meta-data android:name="android.app.searchable"<br/>                android:resource="@xml/searchable" /&gt;<br/>        &lt;/activity&gt;<br/>    &lt;/application&gt;<br/>&lt;/manifest&gt;</pre>
<ol start="13">
<li>Run the application on a device or emulator. Type in a search query and hit the Search button (or press <em>Enter</em>). The SearchResultActivity will be displayed, showing the search query entered.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Since the New Project Wizard uses the AppCompat library, our example uses the support library API. Using the support library provides the greatest device compatibility as it allows the use of modern features (such as the Action Bar) on older versions of the Android OS. This can sometimes provide an extra challenge as often the official documentation focuses on the framework API. Although usually the support library closely follows the framework API, they are not always interchangeable. The Search UI pattern is one of those situations, so it's worth paying extra attention to the steps outlined previously.</p>
<p>We start by creating string resources for the Search View (which is declared later in step 6.)</p>
<p>In step 3, we create the menu resource, as we've done many times. One difference is that we use the app namespace for the <kbd>showAsAction</kbd> and <kbd>actionViewClass</kbd> attributes. The earlier versions of the Android OS don't include these attributes in the Android namespace, which is why we create an app namespace. This serves as a way to bring new functionality to older versions of the Android OS.</p>
<p>In step 4, we set up the SearchManager, using the support library APIs.</p>
<p>Step 6 is where we define the searchable XML resource, which is used by the SearchManager. The only required attribute is the label, but a hint is recommended so the user will have an idea of what they should type in the field.</p>
<p>The <kbd>android:label</kbd> must match the application name or the activity name and must use a string resource (as it does not work with a hardcoded string).</p>
<p>Steps 7-11 are for the <kbd>SearchResultActivity</kbd>. Calling the second activity is not a requirement of the SearchManager, but is commonly done to provide a single activity for all searches initiated in your application.</p>
<p>If you ran the application at this point, you would see the search icon, but nothing would work. Step 12 is where we put it all together in the <kbd>AndroidManifest</kbd> file. The first item to note is the following:</p>
<pre>&lt;meta-data android:name="android.app.default_searchable"<br/>    android:value=".SearchResultActivity" /&gt;</pre>
<p>Notice this is in the <kbd>&lt;application&gt;</kbd> element and not in either of the <kbd>&lt;activity&gt;</kbd> elements. By defining it at the <kbd>&lt;application&gt;</kbd> level, it will automatically apply to all <kbd>&lt;activities&gt;</kbd>. If we moved it to the <kbd>MainActivity</kbd> element, it would behave exactly the same in our example.</p>
<p>You can define styles for your application in the <kbd>&lt;application&gt;</kbd> node and still override individual activity styles in the <kbd>&lt;activity&gt;</kbd> node.</p>
<p>We specify the searchable resource in the SearchResultActivity <kbd>&lt;meta-data&gt;</kbd> element:</p>
<pre>&lt;meta-data android:name="android.app.searchable"<br/>    android:resource="@xml/searchable" /&gt;</pre>
<p>We also need to set the intent filter for <kbd>SearchResultActivity</kbd> as we do here:</p>
<pre>&lt;intent-filter&gt;<br/>    &lt;action android:name="android.intent.action.SEARCH" /&gt;<br/>&lt;/intent-filter&gt;</pre>
<p>The SearchManager broadcasts the SEARCH intent when the user initiates the search. This declaration directs the intent to the SearchResultActivity activity. Once the search is triggered, the query text is sent to the SearchResultActivity using the SEARCH intent. We check for the SEARCH intent in the <kbd>onCreate()</kbd> and extract the query string using the following code:</p>
<pre>if (Intent.ACTION_SEARCH.equals(getIntent().getAction())) {<br/>    handleSearch(getIntent().getStringExtra(SearchManager.QUERY));<br/>}</pre>
<p>You now have the Search UI pattern fully implemented. With the UI pattern complete, what you do with the search results is specific to your application needs. Depending on your application, you might search a local database or maybe a web service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>To take your search to the internet, see internet queries in <a href="d130c363-73b4-48bd-aa87-e4398aef7664.xhtml">Chapter 13</a>,<em> Telephony, Networks, and the Web.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Showing your app full-screen</h1>
                
            
            
                
<p>Android 4.4 (API 19) introduced a UI feature called Immersive Mode. Unlike the previous full-screen flag, your app receives all touch events while in Immersive Mode. This mode is ideal for certain activities, such as reading books and news, full-screen drawing, gaming, or watching a video. There are several different approaches to full-screen, and each has a best use case:</p>
<ul>
<li>Reading books/articles, and so on: Immersive Mode with easy access to the<br/>
System UI</li>
<li>Game/drawing app: Immersive Mode for full-screen use but minimal System UI</li>
<li>Watching video: Full-screen and normal System UI</li>
</ul>
<p>The key difference between the modes is how the System UI responds. In the first two scenarios, your app is expecting user interaction, so the System UI is hidden to make it easier for your user (such as not hitting the back button while playing a game). While using full-screen with a normal System UI, such as watching a video, you wouldn't expect your user to use the screen at all, so when they do the System UI should respond normally. In all modes, the user can bring back the System UI with a swipe inward across the hidden System Bar.</p>
<p>Since watching a video doesn't require the new Immersive Mode, full-screen mode can be achieved using two flags, <kbd>SYSTEM_UI_FLAG_FULLSCREEN</kbd> and <kbd>SYSTEM_UI_FLAG_HIDE_NAVIGATION</kbd>, available since Android 4.0 (API 14).</p>
<p>Our recipe will demonstrate setting up Immersive Mode. We're also going to add the ability to toggle the System UI with a tap on the screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>ImmersiveMode</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type. When selecting the Minimum API Level, choose API 19 or higher.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll create two functions for handling the System UI visibility, then we'll create a gesture listener to detect when the user taps on the screen. All the steps for this recipe are adding code to <kbd>MainActivity.java</kbd>, so open the file and let's begin:</p>
<ol>
<li>Add the following method to hide the System UI:</li>
</ol>
<pre style="padding-left: 60px">private void hideSystemUi() {<br/>    getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_IMMERSIVE |<br/>            View.SYSTEM_UI_FLAG_FULLSCREEN |<br/>            View.SYSTEM_UI_FLAG_LAYOUT_STABLE |<br/>            View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |<br/>            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN |<br/>            View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);<br/>}</pre>
<ol start="2">
<li>Add the following method to show the System UI:</li>
</ol>
<pre style="padding-left: 60px">private void showSystemUI() {<br/>    getWindow().getDecorView().setSystemUiVisibility(<br/>            View.SYSTEM_UI_FLAG_LAYOUT_STABLE |<br/>            View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |<br/>            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);<br/>}</pre>
<ol start="3">
<li>Add the following class variable:</li>
</ol>
<pre style="padding-left: 60px">private GestureDetectorCompat mGestureDetector;</pre>
<ol start="4">
<li>Add the following <kbd>GestureListener</kbd> class at the class level, below the previous class variable:</li>
</ol>
<pre style="padding-left: 60px">private class GestureListener extends GestureDetector.SimpleOnGestureListener {<br/>    @Override<br/>    public boolean onDown(MotionEvent event) {<br/>        return true;<br/>    }<br/>    @Override<br/>    public boolean onFling(MotionEvent event1, MotionEvent event2, <br/>                           float velocityX, float velocityY) {<br/>        return true;<br/>    }<br/>    @Override<br/>    public boolean onSingleTapUp(MotionEvent e) {<br/>        if (getSupportActionBar()!= null &amp;&amp; getSupportActionBar().isShowing()) {<br/>            hideSystemUi();<br/>        } else {<br/>            showSystemUI();<br/>        }<br/>        return true;<br/>    }<br/>}</pre>
<ol start="5">
<li>Override the <kbd>onTouchEvent()</kbd> callback with the following:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public boolean onTouchEvent(MotionEvent event) {<br/>    mGestureDetector.onTouchEvent(event);<br/>    return super.onTouchEvent(event);<br/>}</pre>
<ol start="6">
<li>Add the following code to the <kbd>onCreate()</kbd> method to set the GestureListener and hide the System UI:</li>
</ol>
<pre style="padding-left: 60px">mGestureDetector = new GestureDetectorCompat(this, new GestureListener());<br/>hideSystemUi();</pre>
<ol start="7">
<li>Run the application on a device or emulator. Tapping the screen will toggle the System UI. Depending on your version of the Android OS, you can either swipe up from the bottom or swipe down from the top to reveal the System UI.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We call <kbd>setSystemUiVisibility()</kbd> with the appropriate flags in the <kbd>showSystemUI()</kbd> and <kbd>hideSystemUI()</kbd> methods to set the application window state. The flags we set (and don't set) control what is visible and what is hidden. When we set the visibility without the <kbd>SYSTEM_UI_FLAG_IMMERSIVE</kbd> flag, we in effect disable Immersive Mode.</p>
<p>If all we wanted to do was hide the System UI, we could just add <kbd>hideSystemUI()</kbd> to <kbd>onCreate()</kbd> and we'd be done. The problem is it wouldn't stay hidden. Once the user left Immersive Mode, it would stay in the regular display mode. That's why we created the <kbd>GestureListener</kbd>. (We'll discuss gestures again in <a href="9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml">Chapter 9</a>, <em>Using the Touchscreen and Sensors</em>.) Since we only want to respond to the <kbd>onSingleTapUp()</kbd> gesture, we don't implement the full range of gestures. When <kbd>onSingleTapUp</kbd> is detected, we toggle the System UI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Let's look at some other important tasks that can be performed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sticky Immersion</h1>
                
            
            
                
<p>There's another option we can use if we want the System UI to stay hidden automatically. Instead of using <kbd>SYSTEM_UI_FLAG_IMMERSIVE</kbd> to hide the UI, we can use <kbd>SYSTEM_UI_FLAG_IMMERSIVE_STICKY</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dimming the System UI</h1>
                
            
            
                
<p>If all you need is to reduce the visibility of the Navigation bar, there's also <kbd>SYSTEM_UI_FLAG_LOW_PROFILE</kbd> to dim the UI.</p>
<p>Use this flag with the same <kbd>setSystemUiVisibility()</kbd> call as the Immersive Mode flag:</p>
<pre>getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE); </pre>
<p>Call <kbd>setSystemUiVisibility()</kbd> with 0 to clear all flags:</p>
<pre>getWindow().getDecorView().setSystemUiVisibility(0); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting the Action Bar as an overlay</h1>
                
            
            
                
<p>If you just need to hide or show the Action Bar, use these methods:</p>
<pre>getActionBar().hide(); 

getActionBar().show(); </pre>
<p>One problem with this approach is that the system resizes the layout each time either method is called. Instead, you might want to consider using a theme option to make the System UI behave as an overlay. To enable overlay mode, add the following to the theme:</p>
<pre>&lt;item name="android:windowActionBarOverlay"&gt;true&lt;/item&gt; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Translucent system bars</h1>
                
            
            
                
<p>The following two themes enable translucent settings:</p>
<pre>Theme.Holo.NoActionBar.TranslucentDecor 

Theme.Holo.Light.NoActionBar.TranslucentDecor </pre>
<p>If you are creating your own theme, use the following theme settings:</p>
<pre>&lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt; 

&lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>For more on handling gestures, refer to <a href="9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml">Chapter 9</a>,<em> Using the Touchscreen and Sensors</em>.</p>


            

            
        
    </body></html>