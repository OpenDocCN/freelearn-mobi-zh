- en: Chapter 9. Custom Subscripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。自定义下标
- en: Custom subscripts were added to Objective-C in 2012\. At that time, Chris Lattner
    was already 2 years into developing Swift and like other good features of Objective-C,
    subscripts became a part of the Swift language. I did not frequently use custom
    subscripts in Objective-C, but I did know that they were a part of the language
    when I needed them. Subscripts in Swift seem, to me, to be a more natural part
    of the language, possibly because they were part of the language when it was released
    and not added in later.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义下标于 2012 年添加到 Objective-C 中。当时，Chris Lattner 已经开发了 Swift 两年，并且像 Objective-C
    的其他良好特性一样，下标成为了 Swift 语言的一部分。我在 Objective-C 中并不经常使用自定义下标，但我知道当需要时它们是语言的一部分。在我看来，Swift
    中的下标似乎更像是语言的自然部分，这可能是由于它们在发布时就是语言的一部分，而不是后来添加的。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: What are custom subscripts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是自定义下标
- en: How to add custom subscripts to classes, structures, or enums
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为类、结构体或枚举添加自定义下标
- en: How to create read/write and read-only subscripts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建读写和只读下标
- en: How to use external names without custom subscripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不使用自定义下标的情况下使用外部名称
- en: How to use multidimensional subscripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用多维下标
- en: Introducing subscripts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍下标
- en: Subscripts are shortcuts for accessing elements of a collection, list, or sequence.
    They are used to set or retrieve the values by index rather than using getter
    and setter methods. Subscripts, if used correctly, can significantly enhance the
    usability and readability of our custom types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下标是访问集合、列表或序列元素的快捷方式。它们用于通过索引设置或检索值，而不是使用获取器和设置器方法。如果使用正确，下标可以显著提高我们自定义类型的可用性和可读性。
- en: We can define multiple subscripts for a single type, and the appropriate subscript
    will be chosen, based on the type of index passed into the subscript. We can also
    set external parameter names for our subscripts that can help distinguish between
    subscripts that have the same type.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为单个类型定义多个下标，并且将根据传递给下标的索引类型选择适当的下标。我们还可以为我们的下标设置外部参数名称，这有助于区分具有相同类型的下标。
- en: Using a custom subscript is similar to using subscripts for arrays and dictionaries.
    For example, to access an element in an array, we will use the `anArray[index]`
    syntax, and to access an element of a dictionary, we will use the same syntax,
    that is, `aDictionary[key]`. When we define a custom subscript for our custom
    types, we also access them with the same syntax, `ourType[key]`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义下标类似于使用数组和字典的下标。例如，要访问数组中的一个元素，我们将使用 `anArray[index]` 语法，要访问字典中的一个元素，我们将使用相同的语法，即
    `aDictionary[key]`。当我们为我们的自定义类型定义自定义下标时，我们也将使用相同的语法访问它们，即 `ourType[key]`。
- en: When creating custom subscripts, we should try to make them feel like they are
    a natural part of the class, structure, or enum. As mentioned earlier, subscripts
    can significantly enhance the usability and readability of our code, but if we
    try to overuse subscripts, they will not feel natural and will be hard to use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义下标时，我们应该努力使它们感觉像是类、结构体或枚举的自然部分。如前所述，下标可以显著提高我们代码的可用性和可读性，但如果我们过度使用下标，它们将不会感觉自然，并且难以使用。
- en: In this chapter, we will look at several examples of how we can create and use
    custom subscripts. We will also show an example of how not to use a subscript.
    Before we show how to use custom subscripts, let's review how subscripts are used
    with Swift arrays to see how subscripts are used within the Swift language. We
    should use subscripts in a similar manner to how Apple uses them within the language
    itself to make our custom subscripts easy to understand and use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个如何创建和使用自定义下标的示例。我们还将展示一个不使用下标的示例。在我们展示如何使用自定义下标之前，让我们回顾一下如何在 Swift
    数组中使用下标，以了解 Swift 语言中下标的用法。我们应该以类似于 Apple 在语言本身中使用下标的方式使用下标，使我们的自定义下标易于理解和使用。
- en: Subscripts with Swift arrays
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 数组中的下标
- en: 'The following example shows how to use subscripts to access and change the
    values of an array:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用下标访问和更改数组的值：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, we create an array of integers and then use the subscript
    syntax to display and change the item of element number `3` in the array. Subscripts
    are mainly used to get or retrieve information from a collection. We generally
    do not use subscripts when specific logic needs to be applied to determine which
    item to select. As examples, we will not use subscripts to append an item to the
    end of the array or to retrieve the number of items in the array. To append an
    item to the end of an array, or to get the number of items in an array, we will
    use functions or properties like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，我们创建了一个整数数组，然后使用下标语法显示并更改数组中元素编号为`3`的项。下标主要用于从集合中获取或检索信息。我们通常不使用下标来应用特定逻辑以确定要选择哪个项。例如，我们不会使用下标向数组末尾添加项或检索数组中的项数。要向数组末尾添加项或获取数组中的项数，我们将使用类似这样的函数或属性：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Subscripts in our custom types should follow the same standard set by the Swift
    language itself, so other developers that use our types are not confused by the
    implementation. The key to knowing when to use subscripts, and when not to, is
    to understand how the subscript will be used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自定义的类型中，下标应该遵循Swift语言本身设定的相同标准，这样使用我们类型的其他开发者就不会因为实现方式而感到困惑。知道何时使用下标，何时不使用的关键在于理解下标将如何被使用。
- en: Read and write custom subscripts
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写自定义下标
- en: 'Let''s see how to define a subscript that is used to read and write to a backend
    array. Reading and writing to a backend storage class is one of the most common
    uses of custom subscripts, but, as we will see in this chapter, we do not need
    to have a backend storage class. The following code is a subscript to read and
    write an array:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义一个用于读取和写入后端数组的下标。读取和写入后端存储类是自定义下标最常见的使用之一，但正如我们将在本章中看到的，我们不需要有一个后端存储类。以下代码是一个用于读取和写入数组的下标：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, the syntax is similar to how we can define properties within
    a class using the `get` and `set` keywords. The difference is that we declare
    the subscript using the `subscript` keyword. We then specify one or more inputs
    and the return type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，语法与我们使用`get`和`set`关键字在类中定义属性的方式相似。区别在于我们使用`subscript`关键字声明下标。然后我们指定一个或多个输入和返回类型。
- en: 'We can now use the custom subscript, just like we used subscripts with arrays
    and dictionaries. The following code shows how to use the subscript in the preceding
    example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用自定义下标，就像我们使用数组或字典的下标一样。以下代码展示了如何在先前的例子中使用下标：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we create an instance of the `MyNames` class. We then
    display the original name at index `0`, change the name at index `0`, and redisplay
    it. In this example, we use the subscript that we defined in the `MyNames` class
    to retrieve and set elements of the `names` array within the `MyNames` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们创建了一个`MyNames`类的实例。然后我们显示索引`0`处的原始名称，更改索引`0`处的名称，并重新显示它。在这个例子中，我们使用在`MyNames`类中定义的下标来检索和设置`MyNames`类中`names`数组的元素。
- en: While we could just make the `names` array property available for external code
    to read and write directly to, this would lock our code into using an array to
    store the data. If we ever want to change the backend storage mechanism to a dictionary
    object, or even an SQLite database, we will be unable to do so because all of
    the external code would also have to be changed. Subscripts are very good at hiding
    how we store information within our custom types; therefore, external code that
    uses our custom type does not rely on any specific storage implementations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以直接让`names`数组属性对外部代码开放，以便直接读写，但这会将我们的代码锁定在必须使用数组来存储数据。如果我们想将后端存储机制更改为字典对象，甚至SQLite数据库，我们将无法做到，因为所有外部代码也必须进行更改。下标非常擅长隐藏我们在自定义类型中存储信息的方式；因此，使用我们自定义类型的外部代码不依赖于任何特定的存储实现。
- en: We would also be unable to verify that the external code was inserting valid
    information into the array if we gave direct access to it. With subscripts, we
    can add validation to our setters to verify that the data being passed in is correct
    before adding it to the array. This can be very useful whether we are creating
    a framework or a library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接提供对数组的访问权限，我们也将无法验证外部代码是否将有效信息插入数组。使用下标，我们可以在将数据添加到数组之前通过设置器添加验证来确保传入的数据是正确的。这无论我们是在创建框架还是库时都非常有用。
- en: Read-only custom subscripts
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读自定义下标
- en: 'We can also make the subscript read-only by either not declaring a setter method
    within the subscript or by not implicitly declaring a getter or setter method.
    The following code shows how to declare a read-only property by not declaring
    a setter method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过不在下标中声明setter方法或没有隐式声明getter或setter方法来使下标只读。以下代码展示了如何通过不声明setter方法来声明只读属性：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example shows how to declare a read-only property by only declaring
    a getter method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何通过只声明getter方法来声明只读属性：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first example, we do not define either a getter or setter method. So,
    Swift sets the subscript as read-only and the code acts as if it was in a getter
    definition. In the second example, we specifically set the code in a getter definition.
    Both examples are valid read-only subscripts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们没有定义getter或setter方法。所以，Swift将下标设置为只读，代码的行为就像是在getter定义中。在第二个例子中，我们特别在getter定义中设置了代码。这两个例子都是有效的只读下标。
- en: Calculated subscripts
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算下标
- en: 'While the preceding example is very similar to using the stored properties
    in a class or structure, we can also use subscripts in a similar manner to the
    computed properties. Let''s see how to do this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子与在类或结构中使用存储属性非常相似，但我们也可以以类似计算属性的方式使用下标。让我们看看如何做到这一点：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we used an array as the backend storage mechanism
    for the subscript. In this example, we use the value of the subscript to calculate
    the return value. We will use this subscript as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用数组作为下标的后端存储机制。在这个例子中，我们使用下标的值来计算返回值。我们将使用这个下标如下：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example will display the calculated value of `5` (the number defined in
    the initialization) times `4` (the subscript value), which is equal to 20.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将显示初始化中定义的数字`5`乘以下标值`4`的计算值，等于20。
- en: Subscript values
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下标值
- en: 'In the preceding subscript examples, all of the subscripts accepted integers
    as the value for the subscript; however, we are not limited to integers. In the
    following example, we will use a string type as the value for the subscript. The
    subscript will also return a string type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的下标示例中，所有的下标都接受整数作为下标的值；然而，我们并不限于整数。在以下示例中，我们将使用字符串类型作为下标的值。下标也将返回字符串类型：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, the subscript takes a string as the value within the subscript
    and returns a message, saying `Hello`. Let''s see how to use this subscript:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，下标接受一个字符串作为下标内的值，并返回一条消息，说“Hello”。让我们看看如何使用这个下标：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example will display the message, `Hello Jon`, to the console.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将在控制台显示消息，“Hello Jon”。
- en: Subscripts with ranges
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有范围的下标
- en: 'Similar to how we use `range` operators with arrays, we can also let our custom
    subscripts use the `range` operator. Let''s expand the `MathTable` structure that
    we created earlier to include a second subscript that will take a range operator
    and see how it works:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们如何使用数组中的`range`运算符，我们也可以让我们的自定义下标使用`range`运算符。让我们扩展之前创建的`MathTable`结构，包括一个将接受`range`运算符的第二个下标，看看它是如何工作的：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The new subscript in our example takes a range as the value for the subscript
    and then returns an array of integers. Within the subscript, we generate an array,
    which will be returned to the calling code by using the other subscript method
    that we previously created to multiply each value of the range by the `num` property.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们例子中的新下标接受范围作为下标的值，然后返回一个整数数组。在下标内部，我们生成一个数组，将通过我们之前创建的另一个下标方法将范围的每个值乘以`num`属性，返回给调用代码。
- en: 'The following example shows how to use this new subscript:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用这个新的下标：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we run the example, we will see an array that contains the value, `10`, `15`,
    `20`, and `25`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个例子，我们将看到一个包含值`10`、`15`、`20`和`25`的数组。
- en: External names for subscripts
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下标的外部名称
- en: As we mentioned earlier in this chapter, we can have multiple subscript signatures
    for our custom types. The appropriate subscript will be chosen, based on the type
    of index passed into the subscript. There are times when we may wish to define
    multiple subscripts that have the same type. For this, we could use external names
    similar to how we define external names for the parameters of a function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章前面提到的，我们可以为自定义类型有多个下标签名。将根据传入下标的索引类型选择合适的下标。有时我们可能希望定义多个具有相同类型的下标。为此，我们可以使用类似于为函数参数定义外部名称的外部名称。
- en: 'Let''s rewrite the original `MathTable` structure to include two subscripts
    that each accept an integer as the subscript type; however, one will perform a
    multiplication operation, and the other will perform an addition operation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写原始的`MathTable`结构，以包含两个下标，每个下标都接受一个整数作为下标类型；然而，一个将执行乘法操作，另一个将执行加法操作：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, in this example we define two subscripts and each subscript is
    an integer type. The difference between the two subscripts is the external name
    within the definition. In the first subscript, we define an external name of `multiply`
    because we multiply the value of the subscript by the `num` property within this
    subscript. In the second subscript, we define an external name of `addition` because
    we add the value of the subscript to the `num` property within the subscript.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这个例子中，我们定义了两个下标，每个下标都是整数类型。两个下标之间的区别在于定义中的外部名称。在第一个下标中，我们定义了一个外部名称为`multiply`，因为我们在这个下标中将下标的值乘以下标内的`num`属性。在第二个下标中，我们定义了一个外部名称为`addition`，因为我们在这个下标中将下标的值加以下标内的`num`属性。
- en: 'Let''s see how to use these two subscripts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这两个下标：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we run this example, we will see that the correct subscript is used, based
    on the external name within the subscript.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个示例，我们将看到根据下标内的外部名称使用了正确的下标。
- en: Using external names within our subscript is very useful if we need multiple
    subscripts of the same type; I would not recommend using external names unless
    they are needed to distinguish between multiple subscripts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要多个相同类型的下标，使用我们的下标内的外部名称非常有用；除非它们需要用来区分多个下标，否则我不建议使用外部名称。
- en: Multidimensional subscripts
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维下标
- en: While the most common subscripts are the ones that take a single parameter,
    subscripts are not limited to single parameters. They can take any number of input
    parameters, and these parameters can be of any type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最常见的下标是只接受单个参数的下标，但下标并不限于单个参数。它们可以接受任何数量的输入参数，并且这些参数可以是任何类型。
- en: 'Let''s see how we could use a multidimensional subscript to implement a Tic-Tac-Toe
    board. A Tic-Tac-Toe board looks similar to this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用多维下标来实现Tic-Tac-Toe棋盘。Tic-Tac-Toe棋盘看起来类似于这个：
- en: '![Multidimensional subscripts](img/B05115_09_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![多维下标](img/B05115_09_01.jpg)'
- en: The board can be represented by a two-dimensional array where each dimension
    has three elements. Each player will then take a turn placing his/her pieces (typically,
    X or O) within the board until one player has three pieces in a row or the board
    is full.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘可以用一个二维数组来表示，其中每个维度有三个元素。然后，每位玩家将轮流在棋盘上放置他的/她的棋子（通常是X或O），直到有玩家在行中放置了三个棋子或者棋盘被填满。
- en: 'Let''s see how we could implement a Tic-Tac-Toe board using a multidimensional
    array and multidimensional subscripts:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用多维数组和多维下标实现Tic-Tac-Toe棋盘：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We start the Tic-Tac-Toe structure by defining a 3x3 array that will represent
    the game board. We then define a subscript that can be used to set and retrieve
    player pieces on the board. The subscript will accept two integer values. Multiple
    types are defined by putting the value types between parentheses. In our example,
    we are defining the subscript with the parameters, `(x: Int, y: Int)`. We can
    then use the `x` and `y` variable names within our subscripts to access the values
    that are passed in.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通过定义一个3x3的数组来开始Tic-Tac-Toe结构，这个数组将代表游戏棋盘。然后我们定义一个下标，可以用来设置和检索棋盘上的玩家棋子。下标将接受两个整数值。通过在括号中放置值类型来定义多种类型。在我们的例子中，我们定义了下标，参数为`(x:
    Int, y: Int)`。然后我们可以在我们的下标中使用`x`和`y`变量名来访问传递进来的值。'
- en: 'Let''s see how to use this subscript to set the user''s pieces on the board:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个下标来设置用户在棋盘上的棋子：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we run this code, we will see that we added the player `x` piece to the
    center square and player `o` piece to the upper-left square, so our game board
    will look similar to this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们将看到我们在中心方格添加了玩家`x`的棋子，在左上角方格添加了玩家`o`的棋子，因此我们的游戏棋盘看起来将类似于这个：
- en: '![Multidimensional subscripts](img/B05115_09_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![多维下标](img/B05115_09_02.jpg)'
- en: 'We are not limited to using only one type in our multidimensional subscripts,
    so we can use multiple types. For example, we could have a subscript of the `(x:
    Int, y:Double, z: String)` type.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的多维下标中，我们不仅限于使用单一类型，因此我们可以使用多种类型。例如，我们可能有一个`(x: Int, y: Double, z: String)`类型的下标。'
- en: 'We can also add external names for our multidimensional subscript types to
    help identify what values are used for and to distinguish between the subscripts
    that have the same types. Let''s take a look at how to use multiple types and
    external names with subscripts by creating a subscript that will return an array
    of string instances, based on the values of the subscript:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为我们的多维下标类型添加外部名称，以帮助识别使用哪些值，并区分具有相同类型的下标。让我们通过创建一个将根据下标值返回字符串实例数组的下标来查看如何使用多个类型和外部名称与下标一起使用：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `SayHello` structure, we define our subscript like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SayHello`结构体中，我们定义我们的下标如下：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This defines a subscript with three elements. Each element has an external
    name (`message`, `name`, and `number`) and an internal name (`message`, `name`,
    and `number`). The first two elements are of the string type and the last one
    is an int type. We use the first two elements to create a message for the user
    that will repeat the number of times defined by the last (`number`) element. We
    will use this subscript as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个包含三个元素的下标。每个元素都有一个外部名称（`message`、`name`和`number`）和一个内部名称（`message`、`name`和`number`）。前两个元素是字符串类型，最后一个元素是整型。我们使用前两个元素为用户创建一个消息，该消息将重复由最后一个（`number`）元素定义的次数。我们将使用此下标如下：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we run this code, we will see that the `ret` variable contains an array of
    five strings, where each string equals `Bonjour Jon`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们将看到`ret`变量包含一个包含五个字符串的数组，每个字符串等于`Bonjour Jon`。
- en: When not to use a custom subscript
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时不应使用自定义下标
- en: As we have seen in this chapter, creating custom subscripts can really enhance
    our code; however, we should avoid overusing them or using them in a way that
    is not consistent with the standard subscript usage. The way to avoid overusing
    subscripts is to examine how subscripts are used in Swift's standard libraries.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，创建自定义下标可以真正增强我们的代码；然而，我们应该避免过度使用它们或以不符合标准下标用法的方式使用它们。避免过度使用下标的方法是检查Swift标准库中下标的用法。
- en: 'Let''s take a look at the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding example, within the `MyNames` class, we define an array of
    names that is used within our application. As an example, let''s say that within
    our application, we display this list of names and allow users to add names to
    it. Within the `MyNames` class, we then define the following subscript that allows
    us to append a new name to the array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在`MyNames`类中，我们定义了一个数组，该数组在我们的应用程序中使用。例如，假设在我们的应用程序中，我们显示这个名字列表，并允许用户向其中添加名字。在`MyNames`类中，我们定义以下下标，允许我们向数组中添加新名字：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will be a poor use of subscript syntax because its usage is not consistent
    with how subscripts are used within the Swift language. This might cause confusion
    when the class is used in the future. It will be more appropriate to rewrite this
    subscript as a function like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个对下标语法的糟糕使用，因为它的使用与Swift语言中下标的用法不一致。这可能会在将来使用该类时造成混淆。更合适的方式是将这个下标重写为一个函数，如下所示：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember, when you are using custom subscripts make sure that you are using
    them appropriately.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你使用自定义下标时，确保你正在适当地使用它们。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we saw in this chapter, adding support for subscripts to our custom types
    can greatly enhance their readability and usability. We saw that subscripts can
    be used to add an abstraction layer between our backend storage class and external
    code. Subscripts can also be used in a similar manner to computed properties where
    the subscript is used to calculate a value. As we noted, the key with subscripts
    is to use them appropriately and in a manner that is consistent with subscripts
    in the Swift language.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，为我们的自定义类型添加对下标的支持可以极大地增强其可读性和可用性。我们看到了下标可以用来在后台存储类和外部代码之间添加一个抽象层。下标也可以以类似的方式用于计算属性，其中下标用于计算一个值。正如我们指出的，下标的关键是适当地使用它们，并且以与Swift语言中的下标一致的方式使用。
