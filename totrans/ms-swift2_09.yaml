- en: Chapter 9. Custom Subscripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom subscripts were added to Objective-C in 2012\. At that time, Chris Lattner
    was already 2 years into developing Swift and like other good features of Objective-C,
    subscripts became a part of the Swift language. I did not frequently use custom
    subscripts in Objective-C, but I did know that they were a part of the language
    when I needed them. Subscripts in Swift seem, to me, to be a more natural part
    of the language, possibly because they were part of the language when it was released
    and not added in later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are custom subscripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add custom subscripts to classes, structures, or enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create read/write and read-only subscripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use external names without custom subscripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use multidimensional subscripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing subscripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subscripts are shortcuts for accessing elements of a collection, list, or sequence.
    They are used to set or retrieve the values by index rather than using getter
    and setter methods. Subscripts, if used correctly, can significantly enhance the
    usability and readability of our custom types.
  prefs: []
  type: TYPE_NORMAL
- en: We can define multiple subscripts for a single type, and the appropriate subscript
    will be chosen, based on the type of index passed into the subscript. We can also
    set external parameter names for our subscripts that can help distinguish between
    subscripts that have the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom subscript is similar to using subscripts for arrays and dictionaries.
    For example, to access an element in an array, we will use the `anArray[index]`
    syntax, and to access an element of a dictionary, we will use the same syntax,
    that is, `aDictionary[key]`. When we define a custom subscript for our custom
    types, we also access them with the same syntax, `ourType[key]`.
  prefs: []
  type: TYPE_NORMAL
- en: When creating custom subscripts, we should try to make them feel like they are
    a natural part of the class, structure, or enum. As mentioned earlier, subscripts
    can significantly enhance the usability and readability of our code, but if we
    try to overuse subscripts, they will not feel natural and will be hard to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at several examples of how we can create and use
    custom subscripts. We will also show an example of how not to use a subscript.
    Before we show how to use custom subscripts, let's review how subscripts are used
    with Swift arrays to see how subscripts are used within the Swift language. We
    should use subscripts in a similar manner to how Apple uses them within the language
    itself to make our custom subscripts easy to understand and use.
  prefs: []
  type: TYPE_NORMAL
- en: Subscripts with Swift arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example shows how to use subscripts to access and change the
    values of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create an array of integers and then use the subscript
    syntax to display and change the item of element number `3` in the array. Subscripts
    are mainly used to get or retrieve information from a collection. We generally
    do not use subscripts when specific logic needs to be applied to determine which
    item to select. As examples, we will not use subscripts to append an item to the
    end of the array or to retrieve the number of items in the array. To append an
    item to the end of an array, or to get the number of items in an array, we will
    use functions or properties like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Subscripts in our custom types should follow the same standard set by the Swift
    language itself, so other developers that use our types are not confused by the
    implementation. The key to knowing when to use subscripts, and when not to, is
    to understand how the subscript will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Read and write custom subscripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to define a subscript that is used to read and write to a backend
    array. Reading and writing to a backend storage class is one of the most common
    uses of custom subscripts, but, as we will see in this chapter, we do not need
    to have a backend storage class. The following code is a subscript to read and
    write an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the syntax is similar to how we can define properties within
    a class using the `get` and `set` keywords. The difference is that we declare
    the subscript using the `subscript` keyword. We then specify one or more inputs
    and the return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the custom subscript, just like we used subscripts with arrays
    and dictionaries. The following code shows how to use the subscript in the preceding
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an instance of the `MyNames` class. We then
    display the original name at index `0`, change the name at index `0`, and redisplay
    it. In this example, we use the subscript that we defined in the `MyNames` class
    to retrieve and set elements of the `names` array within the `MyNames` class.
  prefs: []
  type: TYPE_NORMAL
- en: While we could just make the `names` array property available for external code
    to read and write directly to, this would lock our code into using an array to
    store the data. If we ever want to change the backend storage mechanism to a dictionary
    object, or even an SQLite database, we will be unable to do so because all of
    the external code would also have to be changed. Subscripts are very good at hiding
    how we store information within our custom types; therefore, external code that
    uses our custom type does not rely on any specific storage implementations.
  prefs: []
  type: TYPE_NORMAL
- en: We would also be unable to verify that the external code was inserting valid
    information into the array if we gave direct access to it. With subscripts, we
    can add validation to our setters to verify that the data being passed in is correct
    before adding it to the array. This can be very useful whether we are creating
    a framework or a library.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only custom subscripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also make the subscript read-only by either not declaring a setter method
    within the subscript or by not implicitly declaring a getter or setter method.
    The following code shows how to declare a read-only property by not declaring
    a setter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to declare a read-only property by only declaring
    a getter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we do not define either a getter or setter method. So,
    Swift sets the subscript as read-only and the code acts as if it was in a getter
    definition. In the second example, we specifically set the code in a getter definition.
    Both examples are valid read-only subscripts.
  prefs: []
  type: TYPE_NORMAL
- en: Calculated subscripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the preceding example is very similar to using the stored properties
    in a class or structure, we can also use subscripts in a similar manner to the
    computed properties. Let''s see how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used an array as the backend storage mechanism
    for the subscript. In this example, we use the value of the subscript to calculate
    the return value. We will use this subscript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example will display the calculated value of `5` (the number defined in
    the initialization) times `4` (the subscript value), which is equal to 20.
  prefs: []
  type: TYPE_NORMAL
- en: Subscript values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding subscript examples, all of the subscripts accepted integers
    as the value for the subscript; however, we are not limited to integers. In the
    following example, we will use a string type as the value for the subscript. The
    subscript will also return a string type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the subscript takes a string as the value within the subscript
    and returns a message, saying `Hello`. Let''s see how to use this subscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example will display the message, `Hello Jon`, to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Subscripts with ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to how we use `range` operators with arrays, we can also let our custom
    subscripts use the `range` operator. Let''s expand the `MathTable` structure that
    we created earlier to include a second subscript that will take a range operator
    and see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The new subscript in our example takes a range as the value for the subscript
    and then returns an array of integers. Within the subscript, we generate an array,
    which will be returned to the calling code by using the other subscript method
    that we previously created to multiply each value of the range by the `num` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use this new subscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we run the example, we will see an array that contains the value, `10`, `15`,
    `20`, and `25`.
  prefs: []
  type: TYPE_NORMAL
- en: External names for subscripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier in this chapter, we can have multiple subscript signatures
    for our custom types. The appropriate subscript will be chosen, based on the type
    of index passed into the subscript. There are times when we may wish to define
    multiple subscripts that have the same type. For this, we could use external names
    similar to how we define external names for the parameters of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the original `MathTable` structure to include two subscripts
    that each accept an integer as the subscript type; however, one will perform a
    multiplication operation, and the other will perform an addition operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in this example we define two subscripts and each subscript is
    an integer type. The difference between the two subscripts is the external name
    within the definition. In the first subscript, we define an external name of `multiply`
    because we multiply the value of the subscript by the `num` property within this
    subscript. In the second subscript, we define an external name of `addition` because
    we add the value of the subscript to the `num` property within the subscript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use these two subscripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we run this example, we will see that the correct subscript is used, based
    on the external name within the subscript.
  prefs: []
  type: TYPE_NORMAL
- en: Using external names within our subscript is very useful if we need multiple
    subscripts of the same type; I would not recommend using external names unless
    they are needed to distinguish between multiple subscripts.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional subscripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the most common subscripts are the ones that take a single parameter,
    subscripts are not limited to single parameters. They can take any number of input
    parameters, and these parameters can be of any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we could use a multidimensional subscript to implement a Tic-Tac-Toe
    board. A Tic-Tac-Toe board looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multidimensional subscripts](img/B05115_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The board can be represented by a two-dimensional array where each dimension
    has three elements. Each player will then take a turn placing his/her pieces (typically,
    X or O) within the board until one player has three pieces in a row or the board
    is full.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we could implement a Tic-Tac-Toe board using a multidimensional
    array and multidimensional subscripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the Tic-Tac-Toe structure by defining a 3x3 array that will represent
    the game board. We then define a subscript that can be used to set and retrieve
    player pieces on the board. The subscript will accept two integer values. Multiple
    types are defined by putting the value types between parentheses. In our example,
    we are defining the subscript with the parameters, `(x: Int, y: Int)`. We can
    then use the `x` and `y` variable names within our subscripts to access the values
    that are passed in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use this subscript to set the user''s pieces on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, we will see that we added the player `x` piece to the
    center square and player `o` piece to the upper-left square, so our game board
    will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multidimensional subscripts](img/B05115_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not limited to using only one type in our multidimensional subscripts,
    so we can use multiple types. For example, we could have a subscript of the `(x:
    Int, y:Double, z: String)` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add external names for our multidimensional subscript types to
    help identify what values are used for and to distinguish between the subscripts
    that have the same types. Let''s take a look at how to use multiple types and
    external names with subscripts by creating a subscript that will return an array
    of string instances, based on the values of the subscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `SayHello` structure, we define our subscript like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a subscript with three elements. Each element has an external
    name (`message`, `name`, and `number`) and an internal name (`message`, `name`,
    and `number`). The first two elements are of the string type and the last one
    is an int type. We use the first two elements to create a message for the user
    that will repeat the number of times defined by the last (`number`) element. We
    will use this subscript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we run this code, we will see that the `ret` variable contains an array of
    five strings, where each string equals `Bonjour Jon`.
  prefs: []
  type: TYPE_NORMAL
- en: When not to use a custom subscript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in this chapter, creating custom subscripts can really enhance
    our code; however, we should avoid overusing them or using them in a way that
    is not consistent with the standard subscript usage. The way to avoid overusing
    subscripts is to examine how subscripts are used in Swift's standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, within the `MyNames` class, we define an array of
    names that is used within our application. As an example, let''s say that within
    our application, we display this list of names and allow users to add names to
    it. Within the `MyNames` class, we then define the following subscript that allows
    us to append a new name to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be a poor use of subscript syntax because its usage is not consistent
    with how subscripts are used within the Swift language. This might cause confusion
    when the class is used in the future. It will be more appropriate to rewrite this
    subscript as a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Remember, when you are using custom subscripts make sure that you are using
    them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in this chapter, adding support for subscripts to our custom types
    can greatly enhance their readability and usability. We saw that subscripts can
    be used to add an abstraction layer between our backend storage class and external
    code. Subscripts can also be used in a similar manner to computed properties where
    the subscript is used to calculate a value. As we noted, the key with subscripts
    is to use them appropriately and in a manner that is consistent with subscripts
    in the Swift language.
  prefs: []
  type: TYPE_NORMAL
