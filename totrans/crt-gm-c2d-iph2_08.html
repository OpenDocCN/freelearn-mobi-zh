<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Shoot, Scroll, Shoot Again"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Shoot, Scroll, Shoot Again</h1></div></div></div><p>In this chapter, we will be creating a game using tile maps and an on-screen joystick. We will explore how to use <span class="strong"><strong>Tiled</strong></span>, the free tile map editor, as well as how to implement SneakyJoystick. As a stretch, we will also use some advanced pathfinding code to make slightly smarter enemies.</p><p>In this chapter, we cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tiled</li><li class="listitem" style="list-style-type: disc">SneakyJoystick</li><li class="listitem" style="list-style-type: disc">Tilt Controls</li><li class="listitem" style="list-style-type: disc">Separating our game layers</li><li class="listitem" style="list-style-type: disc">Semi-smart enemies </li></ul></div><div class="section" title="The game is…"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>The game is…</h1></div></div></div><p>In this chapter, we will be building a <a id="id1823" class="indexterm"/>
<a id="id1824" class="indexterm"/>top-down scrolling shooter. It sounds simple, but we will be making it a little more challenging with on-screen joystick control, enemy AI, and some more sophisticated layer designs. Traditionally, this type of game is military-themed, with soldiers running around shooting each other. For our game, we have decided it is fruits versus vegetables battling in the desert. We don't really have a good backstory to explain this. However, if millions of mobile gamers accept that birds and pigs are mortal enemies, then you can certainly invent an equally improbable storyline to explain this odd pairing.</p></div></div>
<div class="section" title="Design review"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Design review</h1></div></div></div><p>The design of this game is based on a decent sized tile map, 50 tiles wide and 50 tiles high. Our basic tile size (non-Retina) is 32 x 32 pixels. <a id="id1825" class="indexterm"/>We will implement the tile map as a <a id="id1826" class="indexterm"/>single scrolling layer, keeping our hero centered on the screen (except near the edges, but we'll get to that). The goal of the hero is to pick up three goal "signposts" scattered around the map. There will also be health power-ups on the map to restore the hero's health. We want to have two types of enemies. The first will move in a straight path toward the hero. The second type will be a little smarter. When they run into an impassable wall, we will use an <a id="id1827" class="indexterm"/>
<a id="id1828" class="indexterm"/>
<code class="literal">A* Pathfinding</code> algorithm to find a way around the wall, and then revert to the same straight line toward the hero logic. The player will be able to control the hero using either an on-screen joystick or tilt controls. With either method, there will be a fire button on-screen to shoot. We will break out our game into three layers for easier management: the map layer, the Heads-Up Display (HUD) layer, and the control layer. <a id="id1829" class="indexterm"/>
<a id="id1830" class="indexterm"/>This will keep our code cleaner, and avoid the problem of having our controls scroll off-screen when the tile map moves. Shall we get started?</p></div>
<div class="section" title="Tiled &#x2013; a primer"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Tiled – a primer</h1></div></div></div><p>Tiled is an open source tile map editor available at <a class="ulink" href="http://mapeditor.org">http://mapeditor.org</a>. It is available for Mac, Windows, and Linux. <a id="id1831" class="indexterm"/>As Tiled is an open source program, you can also download the source code if you want to see what is "under the hood". <a id="id1832" class="indexterm"/>We are using Tiled version 0.8.1, which is the current version at the same time writing.</p><p>When you first load Tiled, you will create a new map. Go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> from the menu. In the <span class="strong"><strong>New Map</strong></span> dialog box, configure your map like this:</p><div class="mediaobject"><img src="graphics/9007_08_01.jpg" alt="Tiled – a primer"/></div><p>For our game, we will be building our map using non-Retina assets and will later "fake" a Retina sizing. Normally, you would be building the Retina version first, and then "shrink" the map for the non-Retina version. The same techniques work both ways, so we will leave it to you to decide. Anyway, most of these settings are self-explanatory, except perhaps the "Orientation". <a id="id1833" class="indexterm"/>
<a id="id1834" class="indexterm"/>
<span class="strong"><strong>Orthogonal</strong></span> is a term most people are not familiar with. Basically, it means normal square grid, aligned to the x and y axes.</p><p>You will now be presented with a blank grid of squares. <a id="id1835" class="indexterm"/>
<a id="id1836" class="indexterm"/>
<a id="id1837" class="indexterm"/>We need to have some tiles to use, so we use the menu option <span class="strong"><strong>Map</strong></span> | <span class="strong"><strong>NewTileset…</strong></span>, and are presented with the following dialog:</p><div class="mediaobject"><img src="graphics/9007_08_02.jpg" alt="Tiled – a primer"/></div><p>For our game, we will be using the tile map file <code class="literal">tmw_desert_spacing.png</code> that is bundled with the Tiled download under the folder <code class="literal">examples</code>. (This image is also included in the cocos2D downloadable as well, under <code class="literal">Resources/TileMaps</code>.)</p><p>We select this as our image in the dialog box, and then we need to adjust the parameters at the bottom of the window. Our tiles are 32 x 32, so we set those values for the <span class="strong"><strong>Tile width</strong></span> and <span class="strong"><strong>Tile height</strong></span>. If you look at the tile image, you will see that the tiles are not exactly touching. There are black boundaries that enforce the grid so you can see which tile is which easily. Because of this, we need to set the <span class="strong"><strong>Margin</strong></span> to <code class="literal">1</code> and the <span class="strong"><strong>Spacing</strong></span> to <code class="literal">1</code>.  You will know these settings are correct because in the <a id="id1838" class="indexterm"/>
<a id="id1839" class="indexterm"/>
<span class="strong"><strong>Tilesets</strong></span> window (by default in the lower-right pane), you will see the tiles arranged nicely without any traces of the black gridlines between them. Tiled shows the tiles with white separators, which is fine. </p><div class="section" title="Drawing the ground"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec100"/>Drawing the ground</h2></div></div></div><p>To draw your map, you simply select the tile you want to use from the <span class="strong"><strong>Tilesets</strong></span> pane, and draw on the grid. (If the <span class="strong"><strong>Tilesets</strong></span> pane is not visible, you can <a id="id1840" class="indexterm"/>
<a id="id1841" class="indexterm"/>turn it on under the <span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Tilesets</strong></span> in the menu.)</p><p>One of the strengths of Tiled is that you can define multiple layers on a map. These layers are visible in the <span class="strong"><strong>Layers</strong></span> pane, which is normally at the top left of the display. We start by drawing our basic ground layer, so we rename the default layer from <span class="strong"><strong>Tile Layer 1</strong></span> to <code class="literal">ground</code>. Before we go any further, let's see part of our ground layer that we have drawn:</p><div class="mediaobject"><img src="graphics/9007_08_03.jpg" alt="Drawing the ground"/></div><p>When we drew our ground layer, we avoided drawing anything that would be picked up from the map. In our game, we will be able to pick up health and our goals. The reason we avoid drawing those on the ground layer is that when we pick them up, the image will be removed from the map. If we had the pickups on the ground layer, we would have a blank spot in the map after we picked them up. Instead, we create a new layer, name it <code class="literal">pickups</code>, and draw the items we want to be picked up. <a id="id1842" class="indexterm"/>
<a id="id1843" class="indexterm"/>The following screenshot shows the same area of the map, with the ground layer turned off, and only the pickups layer visible:</p><div class="mediaobject"><img src="graphics/9007_08_04.jpg" alt="Drawing the ground"/></div><p>As you see, the goal marker (the signpost) will be inside the building, and the health (flowery cactus thing) will be near the top-left corner. Simply adding the graphics is not enough. We need to be able to add triggers to the map to be able to easily interpret the map. We will handle this by building what we refer to as "logic layers" into the map. These will not be seen by the user, but will be used to trigger <a id="id1844" class="indexterm"/>events in the code.</p></div><div class="section" title="Logic layers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Logic layers</h2></div></div></div><p>To identify where tiles should have some logic associated with them, we need a new tileset. We have built another tileset called <a id="id1845" class="indexterm"/>
<a id="id1846" class="indexterm"/>
<code class="literal">tile_markers.png</code> that we need to load. This tileset is simply three semi-transparent boxes of <a id="id1847" class="indexterm"/>
<a id="id1848" class="indexterm"/>different colors. When you load this, it is important to change the spacing and margin to 0 (we didn't use any grid lines in this PNG file.) Also, since we have transparency saved in the image file, make sure the <span class="strong"><strong>Use transparent color</strong></span> box is <span class="emphasis"><em>not</em></span> checked. If it is, then any transparency in the loaded image will be discarded, and our nicely transparent tiles will be opaque.</p><p>Once the tileset is loaded, select it from the <span class="strong"><strong>Tilesets</strong></span> pane. You will see three tiles: blue, green, and red. Right-click (or <span class="emphasis"><em>Ctrl</em></span> + click) on the blue tile and select <span class="strong"><strong>Tile Properties…</strong></span>. Double-click on <span class="strong"><strong>&lt;new property&gt;</strong></span> and name it <code class="literal">Goal</code>. Under <span class="strong"><strong>Value</strong></span>, enter <code class="literal">Yes</code>. Then click on <span class="strong"><strong>OK</strong></span> to store the property. This will identify the blue tile as a goal tile. Repeat the same process for the green tile, except name it <code class="literal">Health</code> with a value of <code class="literal">Yes</code>. Finally, the red tile should be set with the property <code class="literal">Blocked</code> with a value of <code class="literal">Yes</code>.</p><p>Now that we have our logic tiles defined, we need to build something with them. Create a new layer, named <span class="strong"><strong>triggers</strong></span>. With the <span class="strong"><strong>triggers</strong></span> layer selected, draw blue tiles on the positions of the goal markers, and draw green layers on our health cacti. Because the tiles have partial transparency, you can see the ground tile through the colored tile.</p><p>Our next logic layer we need is to define the walls and other impassable tiles. We create a new layer, named <code class="literal">walls</code>. (Make sure you are drawing on the correct layer; the layer currently active will be highlighting in the <span class="strong"><strong>Layers</strong></span> pane.) Using the red tile, we draw over all walls and rocks in the tile map.</p><p>The same area of the map now looks like the following screenshot:</p><div class="mediaobject"><img src="graphics/9007_08_05.jpg" alt="Logic layers"/></div></div><div class="section" title="Spawn layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Spawn layer</h2></div></div></div><p>We have only one more layer to complete the tile map. We now add an <span class="strong"><strong>Object Layer</strong></span> to the map. Objects are features on the map that do not necessarily correspond to tiles. We will be using this layer to identify <a id="id1849" class="indexterm"/>
<a id="id1850" class="indexterm"/>
<a id="id1851" class="indexterm"/>spawn points for both the hero and the enemies. Let's create an object layer, and name it <code class="literal">spawns</code>. With the spawn layer selected, you will see that different options in the toolbar are selected. Select the <span class="strong"><strong>Insert Object</strong></span> button from the toolbar. The following screenshot shows how it looks:</p><div class="mediaobject"><img src="graphics/9007_08_06.jpg" alt="Spawn layer"/></div><p>Now click on the map to create an object near the opening in the walls on the left side of the map. It will display as a grey square. Now you can right-click (or <span class="emphasis"><em>Ctrl</em></span> + click) on the box to get a menu. Select <span class="strong"><strong>Object Properties</strong></span>. In the window, name this "playerSpawn". This will be the location where the hero will be created. You will notice that there are both x and y coordinates, as well as width and height. For our use, we will not be using the width and height. The x and y coordinates look a little odd. That is because these are tile coordinates. Tile coordinates are similar to the coordinates we are used to in cocos2d, except the (0, 0) coordinate corresponds to the top-left corner, not the bottom-left. When we use these, we will have to do some translation on these coordinates, but we will deal with that later.</p><p>Now, we need to make a few more objects on the tile map, preferably keeping most of them farther away from the hero's spawn point. For each of these, we will name them with incremental names <code class="literal">EnemySpawn1</code>, <code class="literal">EnemySpawn2</code>, and so on. For our game, we have chosen to have 11 enemy spawn points to add some variety. <a id="id1852" class="indexterm"/>Once these are all created, let's save the map as <code class="literal">desert_map.tmx</code>.</p></div><div class="section" title="Understanding TMX format"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Understanding TMX format</h2></div></div></div><p>Now, we will go ahead and add our <code class="literal">.tmx</code> file and our two PNG files to our project. If you select the <code class="literal">.tmx</code> file in Xcode, you can read and edit it <a id="id1853" class="indexterm"/>directly in the Xcode <a id="id1854" class="indexterm"/>editor. Go ahead and look at the <code class="literal">desert_map.tmx</code>. It is a plain XML file, so it is fairly easy to understand most of the <a id="id1855" class="indexterm"/>parameters. For now, look at the top of the file where the <code class="literal">&lt;tileset&gt;</code> tags are. You need to make sure there isn't a file path attached to the source value. The first few lines of the file should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/9007_08_07.jpg" alt="Understanding TMX format"/></div><p>Here you can see that all of the parameters we put in <a id="id1856" class="indexterm"/>Tiled for the map and the tilesets is all represented in easily readable and <span class="emphasis"><em>changeable</em></span> text. This is important for creating the Retina version of this map.</p></div><div class="section" title="Creating an HD map"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec104"/>Creating an HD map</h2></div></div></div><p>As we said earlier, the usual direction is to create the HD version of everything first, and downscale it to the SD resolution. Because we started with a tile set that was in non-Retina resolution, we opted to build that version first, and then <a id="id1857" class="indexterm"/>upscale everything.</p><p>The first thing we need to do is take both of our tile set <a id="id1858" class="indexterm"/>
<a id="id1859" class="indexterm"/>PNG images and convert them into HD sized assets. We did this by using Photoshop, and resized them to 200 percent, and then saved them as -hd files. When doing the resizing (regardless of the tool), make sure that it is not doing any clever antialiasing or anything like that. By allowing Photoshop to use its <span class="strong"><strong>Resample Image</strong></span> option, it will leave strange edges on all the tiles, where it feathers out the black separator lines into the tiles themselves. We just need a straight doubling of the pixels for this operation.</p><p>Now comes the easier part of making an HD map. Copy the <code class="literal">desert_map.tmx</code> as a new file, <code class="literal">desert_map-hd.tmx</code>. Add all three of these -hd files into Xcode as well, and edit the new TMX file. Since we have just doubled all of the tile sizes, we need to edit the sizes in the TMX file. In the <code class="literal">&lt;map&gt;</code> section, change the <code class="literal">tilewidth</code> and <code class="literal">tileheight</code> properties to <code class="literal">64</code>, since that is our HD tile size. Make the same changes to the parameters for both <code class="literal">&lt;tileset&gt;</code> sections. We also need to change the <code class="literal">spacing</code> and <code class="literal">margin</code> on the desert tileset to <code class="literal">2</code> and <code class="literal">2</code>. Finally, the width and height for both <code class="literal">&lt;image&gt;</code> sections need to be doubled from their former values.</p><p>As a final step, we need to change the image source values to reflect the –hd filenames. These should be <code class="literal">tmw_desert_spacing-hd.png</code> and <code class="literal">tile_markers-hd.png</code>.</p><p>There is one set of values that will not be correct – <a id="id1860" class="indexterm"/>the object positions. Since these are not tile-based, they will look a little odd if you reload the new –hd tilemap into Tiled. You could compensate for this in code, but our preference is to <a id="id1861" class="indexterm"/>reload the –hd tilemap into Tiled, and manually move these around. That is the approach we used for this game. </p></div></div>
<div class="section" title="Implementing the tilemap"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Implementing the tilemap</h1></div></div></div><p>So far, we've spent considerable time without really building the project, so now let's turn our attention to our Xcode project. The first thing we need to do is load the tilemap into the layer. We will need to persist the tilemap, so <a id="id1862" class="indexterm"/>first let's look <a id="id1863" class="indexterm"/>at the header to see our variables.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.h</code> <a id="id1864" class="indexterm"/>
<a id="id1865" class="indexterm"/>(partial)</p><div class="informalexample"><pre class="programlisting">    CCTMXTiledMap *_tileMap;
    CCTMXLayer *_ground;
    CCTMXLayer *_triggers;
    CCTMXLayer *_pickups;
    CCTMXLayer *_walls;
    CCTMXObjectGroup *spawns;
    
    NSInteger tmw; // tilemap width
    NSInteger tmh; // tilemap height
    NSInteger tw; // tile width
    NSInteger th; // tile height</pre></div><p>Here you see that we keep the tilemap, as well as individual variables for each layer. We also introduce a few <code class="literal">NSInteger</code> variables to store the values of several important numbers, as a shorthand to avoid repeatedly writing a relatively long bit of code. Let's look at the relevant sections of the <code class="literal">init</code> method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code> <a id="id1866" class="indexterm"/>
<a id="id1867" class="indexterm"/> (partial)</p><div class="informalexample"><pre class="programlisting">        // Load the map
        self.tileMap = [CCTMXTiledMap tiledMapWithTMXFile:
                        @"desert_map.tmx"];
        self.ground = [_tileMap layerNamed:@"ground"];
        self.triggers = [_tileMap layerNamed:@"triggers"];
        self.pickups = [_tileMap layerNamed:@"pickups"];
        self.walls = [_tileMap layerNamed:@"walls"];
        self.triggers.visible = NO;
        self.walls.visible = NO;

        [self addChild:_tileMap z:-1];
        
        // Load the spawn object layer
        spawns = [_tileMap objectGroupNamed:@"spawns"];
        NSAssert(spawns != nil, @"'spawns' missing");</pre></div><p>That is all it takes to load the tilemap on a layer. You will notice we set the visible attributes for both the triggers and walls to <code class="literal">NO</code>. For debugging, you can easily set these to <code class="literal">YES</code>, and the map will look more like it does in Tiled, with the colored overlays on the trigger tiles. You will also notice we only add the <code class="literal">_tileMap</code> to self, and not the layers within the tilemap. This is because the TMX handling classes of cocos2d are built to assume the tilemap should be kept together and used together. Finally, we load the <code class="literal">spawns</code> object group a little differently, because object layers are stored a little differently in the file.</p><p>There is a second set of initializations that we do to <a id="id1868" class="indexterm"/>make it easier to <a id="id1869" class="indexterm"/>write the code later.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1870" class="indexterm"/>
<a id="id1871" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">        // Shorthand for tilemap sizes, with retina fix
        tmw = _tileMap.mapSize.width;
        tmh = _tileMap.mapSize.height;
        tw = _tileMap.tileSize.width /
                            CC_CONTENT_SCALE_FACTOR();
        th = _tileMap.tileSize.height /
                            CC_CONTENT_SCALE_FACTOR();</pre></div><p>Here we are using the "shorthand" variables that we identified in the header file. This allows us to write shorter lines of code when referencing any of these values. Because the tiles are represented in pixel sizes only, we divide them by <a id="id1872" class="indexterm"/>the <code class="literal">CC_CONTENT_SCALE_FACTOR()</code> to ensure that we are dealing with the sizes in points, not pixels.</p></div>
<div class="section" title="Adding our hero"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Adding our hero</h1></div></div></div><p>Now that we have a world to live in, we need to add our hero. We have broken out our hero into a separate class, but first let's look at how we figure out where the hero will spawn. As you may recall, we have the location <span class="strong"><strong>playerSpawn</strong></span> <a id="id1873" class="indexterm"/>marked on the <a id="id1874" class="indexterm"/>map. Now, we need to translate that location into game coordinates.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1875" class="indexterm"/>
<a id="id1876" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addHero {
    // Get the player spawn location
    NSMutableDictionary *playerSpawn =
                    [spawns objectNamed:@"playerSpawn"];
    NSAssert(playerSpawn != nil, @"playerSpawn missing");
    int x = [[playerSpawn valueForKey:@"x"] intValue];
    int y = [[playerSpawn valueForKey:@"y"] intValue];
    CGPoint heroPos = ccp(x / CC_CONTENT_SCALE_FACTOR(),
                          y / CC_CONTENT_SCALE_FACTOR());
    
    // Create the player
    hero = [TDHero heroAtPos:heroPos onLayer:self];
    [self addChild:hero];
}</pre></div><p>Here you see that we create an <code class="literal">NSMutableDictionary</code> from the <code class="literal">playerSpawn</code>. The data is stored in this way inside the TMX map, because the format does allow us to add other properties to the objects (in our case, we care only about the coordinates). We extract the x and y coordinates for the <code class="literal">playerSpawn</code> object, but then we alter the coordinates by dividing them by the <code class="literal">CC_CONTENT_SCALE_FACTOR()</code>. Why? Remember that the TMX file format produced by Tiled is not a cocos2d-specific format, so everything is represented as pixels. We divide the coordinates by the <code class="literal">CC_CONTENT_SCALE_FACTOR()</code>, which will give us the correct location in points. We then call the constructor for our <code class="literal">TDHero</code> class, and add the hero to the layer. We also <a id="id1877" class="indexterm"/>store a reference to the hero in the <code class="literal">hero</code> variable. Now let's see how the <code class="literal">TDHero</code> is constructed.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1878" class="indexterm"/>
<a id="id1879" class="indexterm"/>
<code class="literal">TDHero.h</code>
</p><div class="informalexample"><pre class="programlisting">@class TDPlayfieldLayer;

@interface TDHero : CCNode {
    TDPlayfieldLayer *parentLayer;
    CCSprite *sprite; // sprite for the hero
}

@property (nonatomic, retain) CCSprite *sprite;

+(id) heroAtPos:(CGPoint)pos onLayer:(TDPlayfieldLayer*)layer;

-(void) shoot;
-(void) rotateToTarget:(CGPoint)target;

@end</pre></div><p>The hero keeps a reference to the <a id="id1880" class="indexterm"/>
<code class="literal">TDPlayfieldLayer</code> (using a forward declaration to avoid an import loop), and we keep a reference to the sprite. You will notice that we have <code class="literal">TDHero</code> as a subclass of <code class="literal">CCNode</code>, not <code class="literal">CCSprite</code>. We do this to keep the class more uniform with the <code class="literal">TDEnemy</code> class we will look at later. By having the <code class="literal">CCSprite</code> as a variable inside a <code class="literal">CCNode</code> subclass, it makes it easier to use a single class with different graphics. By keeping these two classes more uniform, it makes it easier to remember how to code the collision and movement classes. Now <a id="id1881" class="indexterm"/>let's look at the implementation:</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1882" class="indexterm"/>
<a id="id1883" class="indexterm"/>
<code class="literal">TDHero.m</code>
</p><div class="informalexample"><pre class="programlisting">+(id) heroAtPos:(CGPoint)pos onLayer:(TDPlayfieldLayer*)layer {
    return [[[self alloc] initForHeroAtPos:pos onLayer:layer]
                                                 autorelease];
}

-(id) initForHeroAtPos:(CGPoint)pos onLayer:(TDPlayfieldLayer*)layer  {
    if((self = [super init])) {
        
        // Keep a reference to the layer
        parentLayer = layer;
        
        // Build the sprite
        self.sprite = [CCSprite
                    spriteWithSpriteFrameName:IMG_HERO];
        [sprite setPosition:pos];
        // Add the sprite to the layer
        [parentLayer addChild:sprite z:2];
    }
    return self;
}</pre></div><p>Here we have a convenience constructor, and the <a id="id1884" class="indexterm"/>
<code class="literal">init</code> method. We keep a reference to the parent layer, build a sprite, set its opening position, and add the sprite to the parent layer. Yes, we already added the hero (of <code class="literal">TDHero</code> class) to the parent layer. That is a "handle" on the <code class="literal">CCNode</code> that we need to keep to avoid having it autorelease. But that does not add the sprite to the layer, so we add that separately. We want our hero to be able to rotate in the direction he is heading, so we will add a rotation method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDHero.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) rotateToTarget:(CGPoint)target {
    // Rotate toward player
    CGPoint diff = ccpSub(target,sprite.position);
    float angleRadians = atanf((float)diff.y /
                               (float)diff.x);
    float angleDegrees=CC_RADIANS_TO_DEGREES(angleRadians);
    float cocosAngle = -angleDegrees;
    if (diff.x &lt; 0) {
        cocosAngle += 180;
    }
    sprite.rotation = cocosAngle;
}</pre></div><p>This is a fairly standard rotation method that is often used in sample projects. It calculates the angle between the sprite and the target coordinate passed to it. The calculation results in radians, converts that to degrees, and sets the new rotation.</p><p>Our hero also needs to be able to shoot. Let's take a look at that:</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDHero.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) shoot {
    // Create a projectile at hero's position
    TDBullet *bullet = [TDBullet
                   bulletFactoryForLayer:parentLayer];
    bullet.position = self.sprite.position;
    bullet.rotation = self.sprite.rotation;
    bullet.isEnemy = NO;
    
    // Add bullets to parentLayer's array
    [parentLayer addBullet:bullet];

    // Play a sound effect
    [[SimpleAudioEngine sharedEngine] playEffect:SND_SHOOT];
}</pre></div><p>Here we see that we will also have a <a id="id1885" class="indexterm"/>
<code class="literal">TDBullet</code> class as a factory for new bullets. We will take a closer look at bullets later in the chapter. For now, you see that we set the bullet to be at the same position and rotation as the hero, and we set an <code class="literal">isEnemy</code> flag, so we can make friendly-fire impossible. We send the bullet to the <a id="id1886" class="indexterm"/>parent layer to be added, and we play a sound effect.</p><div class="section" title="Focus on the hero"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Focus on the hero</h2></div></div></div><p>If we were to go forward with the code thus far, we have a slight problem. The hero is nowhere on the screen, as we see in the <a id="id1887" class="indexterm"/>following screenshot:</p><div class="mediaobject"><img src="graphics/9007_08_08.jpg" alt="Focus on the hero"/></div><p>We need a way to focus the view on the hero, but at the same time we need to make sure that we never see any area outside the map. Ray Wenderlich posted a wonderfully compact method of doing this in one of his tutorials at <a class="ulink" href="http://www.raywenderlich.com">http://www.raywenderlich.com</a>.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void)setViewpointCenter:(CGPoint) position {
    // Method written Ray Wenderlich
    // Posted at www.raywenderlich.com
    int x = MAX(position.x, size.width / 2);
    int y = MAX(position.y, size.height / 2);
    x = MIN(x, (_tileMap.mapSize.width *
                _tileMap.tileSize.width) - size.width / 2);
    y = MIN(y, (_tileMap.mapSize.height *
                _tileMap.tileSize.height) - size.height/2);
    CGPoint actualPosition = ccp(x, y);
    CGPoint centerOfView = ccp(size.width/2,
                               size.height/2);
    CGPoint viewPoint = ccpSub(centerOfView,
                               actualPosition);
    self.position = viewPoint;
}</pre></div><p>The first <code class="literal">x</code> and <code class="literal">y</code> assignments get the <code class="literal">MAX</code> value of either middle of the screen, or the passed position. Then it takes that result and selects the <code class="literal">MIN</code> of that value or the right edge of the map minus half a screen. This paired calculation will give you the coordinates of the hero, unless he is near the edge of the screen, in which case it will give the coordinates of a point that is exactly half a screen away from the nearest edge. We then subtract the center of the screen size from the actual position on the map, and we end up with a screen coordinate perfect for the layer's position. You will notice that this actually works by repositioning the layer itself. Here we use it only for following the hero, but if you wanted to call the player's attention to some other feature of the map (show them the goal, for example) you can use this same method by <a id="id1888" class="indexterm"/>passing it a different coordinate.</p></div></div>
<div class="section" title="Controlling the hero with SneakyJoystick"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Controlling the hero with SneakyJoystick</h1></div></div></div><p>Now, we need a way to control our hero. For <a id="id1889" class="indexterm"/>our game, we will be using two different control methods, joystick and tilt. We will look at <a id="id1890" class="indexterm"/>the joystick control first.</p><p>Our joystick control will use the <a id="id1891" class="indexterm"/>
<code class="literal">SneakyJoystick</code> class, available at <a class="ulink" href="https://github.com/sneakyness/SneakyInput">https://github.com/sneakyness/SneakyInput</a>. <code class="literal">SneakyInput</code>/<code class="literal">SneakyJoystick</code>. This is probably the most commonly used joystick class in the cocos2d community. It has a lot of features (such as skinning the joystick with better graphics), which we will not be using in this project, but which are definitely worth exploring in the projects you will create.</p><p>We create a new layer to handle the controls, <code class="literal">TDControlLayer</code>. In some projects, it doesn't make a big difference how you organize your objects on layers. When you are using a scrolling tilemap, however, separation of your layers is essential. If you don't put your controls on a separate layer, as soon as you scroll the tilemap, the controls will scroll off-screen. By keeping them as a separate layer (that is <span class="emphasis"><em>not</em></span> a child of the tilemap's layer), the controls will be fixed in the screen positioning you want, <a id="id1892" class="indexterm"/>regardless of any map scrolling.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1893" class="indexterm"/>
<a id="id1894" class="indexterm"/>
<code class="literal">TDControlLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addJoystick {
    SneakyJoystickSkinnedBase *leftJoy =
            [[[SneakyJoystickSkinnedBase alloc] init]
             autorelease];
    leftJoy.backgroundSprite = [ColoredCircleSprite
       circleWithColor:ccc4(255, 255, 0, 128) radius:32];
    leftJoy.thumbSprite = [ColoredCircleSprite
       circleWithColor:ccc4(0, 0, 255, 200) radius:16];
    leftJoy.joystick = [[[SneakyJoystick alloc]
       initWithRect:CGRectMake(0,0,64,64)] autorelease];
    leftJoystick = leftJoy.joystick;
    leftJoy.position = ccp(64,36);
    [self addChild:leftJoy z:30];
} </pre></div><p>Most of this method is concerned with the building of the images used for the sprite. We are using a simple example with colored circles to represent the base of the joystick and the thumb. (The "thumb" is the movable part of the joystick, adopting the term from scrollbar controls). We build the joystick, and add it to the layer.</p><p>We also need a fire button in our game, so we will use the <code class="literal">SneakyButton</code> class for it.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDControlLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addFireButton {
    SneakyButtonSkinnedBase *rightBut =
            [[[SneakyButtonSkinnedBase alloc] init]
             autorelease];
    rightBut.position = ccp(420,36);
    rightBut.defaultSprite = [ColoredCircleSprite
      circleWithColor:ccc4(255, 255, 255, 128) radius:32];
    rightBut.activatedSprite = [ColoredCircleSprite
      circleWithColor:ccc4(255, 255, 255, 255) radius:32];
    rightBut.pressSprite = [ColoredCircleSprite
      circleWithColor:ccc4(255, 0, 0, 255) radius:32];
    rightBut.button = [[[SneakyButton alloc]
      initWithRect:CGRectMake(0, 0, 64, 64)] autorelease];
    rightButton = rightBut.button;
    rightButton.isToggleable = YES;
    [self addChild:rightBut];
}</pre></div><p>The setup of the <code class="literal">SneakyButton</code> is very similar to the <code class="literal">SneakyJoystick</code>, except instead of the base and thumb images, we set up the alternate images for the button press. </p><p>Now that we have built the controls, let's see how to use them. <a id="id1895" class="indexterm"/>
<a id="id1896" class="indexterm"/>We schedule an <code class="literal">update</code> method on this layer, and the <code class="literal">update</code> handles parsing the controls.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1897" class="indexterm"/>
<a id="id1898" class="indexterm"/>
<code class="literal">TDControlLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void)update:(ccTime)delta {
    // Do nothing if the touches are off
    if ([pf preventTouches]) {
        return;
    }
    if ([pf isGameOver]) {
        [[CCDirector sharedDirector] replaceScene:
                                [TDMenuScene node]];
    }
    if (isTiltControl) {
        // Tilt code here
    } else {
        // If the stick isn't centered, then we're moving
        if (CGPointEqualToPoint(leftJoystick.stickPosition,
                                CGPointZero) == NO) {
            // Pass the call to the playfield
            [pf applyJoystick:leftJoystick
                         toNode:pf.hero.sprite
                   forTimeDelta:delta];
        }
    }
    // If the button is active, let the playfield know
    if (rightButton.active) {
        [pf setHeroShooting:YES];
    } else {
        [pf setHeroShooting:NO];
    }
}</pre></div><p>This is all of the <code class="literal">update</code> method, except for the tilt control section, which we will get to in a few moments. We handle a couple of standard cases first (<code class="literal">preventTouches</code> and <code class="literal">isGameOver</code>), and then we check the joystick. If the <a id="id1899" class="indexterm"/>
<code class="literal">stickPosition</code> is equal to <code class="literal">CGPointZero</code>, it means the stick is centered, so we don't actually have any movement requested. If they are not equal, then we need to send the message to the hero to move. We do this by sending a call to the playfield layer (<code class="literal">pf</code> is a reference to it), and pass some parameters to it. (The method call is a fairly standard one when using <code class="literal">SneakyJoystick</code>. That is why the terminology in the method call is a little different <a id="id1900" class="indexterm"/>from the other code.) We then check to see if the button has its <code class="literal">active</code> property set. If it <a id="id1901" class="indexterm"/>does, then we need to shoot. We again pass that call to the playfield layer to set a Boolean variable, <code class="literal">heroShooting</code>. This class does not have any direct connections to the <code class="literal">TDHero</code> class. The call routing is done by way of the playfield layer, which acts as liaison between the two classes.</p><div class="section" title="Tilt controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec106"/>Tilt controls</h2></div></div></div><p>The addition of tilt controls to our game is almost trivial. Since the tilt control will only be replacing the joystick, we will still need the <a id="id1902" class="indexterm"/>button to <a id="id1903" class="indexterm"/>be used, so it makes sense for these two control methods to be housed in the same class.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1904" class="indexterm"/>
<a id="id1905" class="indexterm"/>
<code class="literal">TDControlLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addTiltControl {
    // Set up the accelerometer
    self.isAccelerometerEnabled = YES;

    [[UIAccelerometer sharedAccelerometer]
                  setUpdateInterval:1.0 / 60];
    [[UIAccelerometer sharedAccelerometer] setDelegate:self];
}

- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration {
    // Accelerometer values based on portrait mode, so
    // we reverse them for landscape
    accelX = acceleration.y * 7;
    accelY = -acceleration.x * 7;
}</pre></div><p>With these two simple methods, we have most of the code we need to make the tilt controls functional. In the <a id="id1906" class="indexterm"/>
<a id="id1907" class="indexterm"/>
<code class="literal">addTiltControl</code> method, we turn on the accelerometer and set its delegate to this class. That delegate uses a callback, which is the second method listed in the preceding code. At the frequency specified, the <code class="literal">accelerometer:didAccelerate:</code> method <a id="id1908" class="indexterm"/>
<a id="id1909" class="indexterm"/>will be called. On each call, we store a modified version of the acceleration values in our <code class="literal">accelX</code> and <code class="literal">accelY</code> variables. Because our game is in landscape and the accelerometer <a id="id1910" class="indexterm"/>reports only in portrait-based values, we reverse the <code class="literal">x</code> and <code class="literal">y</code> values. We multiply them by <code class="literal">7</code> to <a id="id1911" class="indexterm"/>provide a larger change value. Testing found <code class="literal">7</code> to be a good multiplier value.</p><p>Finally, we have a small bit of code to add into our update method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDControlLayer.m</code> (<code class="literal">update</code> method, under <code class="literal">Tilt Code here</code>):</p><div class="informalexample"><pre class="programlisting">        // Tilt code here
        CGPoint heroPos = [pf getHeroPos];
        CGPoint newHeroPos = ccp(heroPos.x + accelX,
                                 heroPos.y + accelY);
        
        [pf rotateHeroToward:newHeroPos];
        [pf setHeroPos:newHeroPos];</pre></div><p>Here we could have easily taken the same approach as with the joystick and passed everything to the playfield layer, but we wanted to show an alternate approach with this control. There is no difference in the performance of having the code here or in the playfield layer (as all called methods are in <code class="literal">pf</code> anyway). The code itself calculates a new position for the hero by adding the <code class="literal">accelX</code> and <code class="literal">accelY</code> values to the coordinates. It then calls to rotate the hero, and then move the hero.</p><p>To wrap up the control section, let's look at the constructor and the <code class="literal">init</code> methods.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDControlLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">+(id) controlsWithPlayfieldLayer:(TDPlayfieldLayer*)
                   playfieldLayer withTilt:(BOOL)isTilt {
    return [[[self alloc]
                   initWithPlayfieldLayer:playfieldLayer
                   withTilt:isTilt] autorelease];
}

-(id) initWithPlayfieldLayer:(TDPlayfieldLayer*)playfieldLayer
                                   withTilt:(BOOL)isTilt {
    if(self = [super init]) {
        pf = playfieldLayer;
        isTiltControl = isTilt;
        if (isTiltControl) {
            // Set up the tilt controls
            [self addTiltControl];
        } else {
            // Set up the joystick
            [self addJoystick];
        }
        
        // Add the fire button (all modes)
        [self addFireButton];
        
        [self scheduleUpdate];
    }
    return self;
}</pre></div><p>We will be creating the control layer with two parameters: the playfield layer, and a Boolean value to indicate if we want tilt controls or not. Based on the <code class="literal">isTilt</code> value, we either create the joystick or we start with tilt. That's all it <a id="id1912" class="indexterm"/>takes to implement both <a id="id1913" class="indexterm"/>control mechanisms.</p></div><div class="section" title="Interpreting the controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Interpreting the controls</h2></div></div></div><p>Now we turn our attention to the <a id="id1914" class="indexterm"/>
<a id="id1915" class="indexterm"/>
<code class="literal">TDPlayfieldLayer</code> class to see how we fully interpret the control methods that were called in the <a id="id1916" class="indexterm"/>control layer. <a id="id1917" class="indexterm"/>We'll start with the joystick control:</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void)applyJoystick:(SneakyJoystick*)joystick
              toNode:(CCSprite*)sprite
        forTimeDelta:(float)delta {
    
    // Scale up the joystick's reading to faster movement
    CGPoint scaledVelocity = ccpMult(joystick.velocity,
                                     200);
    
    // Apply the scaled velocity to the position
    float newPosX = hero.sprite.position.x +
                        scaledVelocity.x * delta;
    float newPosY = hero.sprite.position.y +
                        scaledVelocity.y * delta;
    CGPoint newPos = ccp(newPosX, newPosY);
    
    // Rotate the hero
    [hero rotateToTarget:newPos];

    // Set the new position
    [self setHeroPos:newPos];
}</pre></div><p>We start by creating a <a id="id1918" class="indexterm"/>
<a id="id1919" class="indexterm"/>
<code class="literal">scaledVelocity</code> variable, which is the data from the joystick times <code class="literal">200</code>, to give a larger value than the joystick's reading. We then apply this to the hero's position. You will notice we multiply the <code class="literal">scaledVelocity</code> by the delta time. We do this to allow for variable update time, so the movement is not jerky, if there is any lag. We then tell the hero to rotate toward the new position, and set the hero's position to the new value. </p><p>Now we will look at an abbreviated version of the <a id="id1920" class="indexterm"/>
<a id="id1921" class="indexterm"/>
<code class="literal">setHeroPos</code> method. <a id="id1922" class="indexterm"/>We <a id="id1923" class="indexterm"/>will revisit this later to add some more logic to it. For now, it is very simple.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1924" class="indexterm"/>
<a id="id1925" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) setHeroPos:(CGPoint)pos {
    // Set the new position
    hero.sprite.position = pos;
    
    // Center the view on the hero
    [self setViewpointCenter:pos];
}</pre></div><p>For now, the <a id="id1926" class="indexterm"/>
<a id="id1927" class="indexterm"/>
<code class="literal">setHeroPos</code> method simply sets the hero's position and then centers the view on the hero. Nothing fancy, but it gets the job done. At this point, we have used a couple of small pass-through methods that we should mention.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(CGPoint) getHeroPos {
    return hero.sprite.position;
}

-(void) rotateHeroToward:(CGPoint)target {
    [hero rotateToTarget:target];
}</pre></div><p>As we mentioned before, we want the playfield to be the central point of contact, so these two methods provide easy data pass-throughs that can be called from other classes. Both of these classes were used in the control layer, but they really <a id="id1928" class="indexterm"/>do nothing special except reduce the number of classes that are directly connected to each other.</p></div></div>
<div class="section" title="Building the HUD"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Building the HUD</h1></div></div></div><p>We have a third layer that we need to build, the heads-up display (HUD) layer. This is a mostly trivial layer to implement, but it must be its own layer, <a id="id1929" class="indexterm"/>for the same reasons we discussed with the controls. If this were on the main layer, the HUD <a id="id1930" class="indexterm"/>would scroll off-screen whenever we moved away from the first view.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDHUDLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addDisplay {
    // Add the fixed text of the HUD
    CCLabelTTF *kills = [CCLabelTTF 
                      labelWithString:@"Kills:"
                      fontName:@"Verdana" fontSize:16];
    [kills setAnchorPoint:ccp(0,0.5)];
    [kills setPosition:ccp(10,305)];
    [kills setColor:ccRED];
    [self addChild:kills];
    
    CCLabelTTF *health = [CCLabelTTF
                      labelWithString:@"Health:"
                      fontName:@"Verdana" fontSize:16];
    [health setAnchorPoint:ccp(0,0.5)];
    [health setPosition:ccp(140,305)];
    [health setColor:ccGREEN];
    [self addChild:health];
    
    CCLabelTTF *goals = [CCLabelTTF
                      labelWithString:@"Goalposts Left:"
                      fontName:@"Verdana" fontSize:16];
    [goals setAnchorPoint:ccp(0,0.5)];
    [goals setPosition:ccp(300,305)];
    [goals setColor:ccBLUE];
    [self addChild:goals];
    
    // Add the kill counter
    lblKills = [CCLabelTTF labelWithString:@""
                       fontName:@"Verdana" fontSize:16];
    [lblKills setAnchorPoint:ccp(0,0.5)];
    [lblKills setPosition:ccp(60,305)];
    [lblKills setColor:ccRED];
    [self addChild:lblKills];
    
    // Add the health counter
    lblHeroHealth = [CCLabelTTF labelWithString:@""
                      fontName:@"Verdana" fontSize:16];
    [lblHeroHealth setAnchorPoint:ccp(0,0.5)];
    [lblHeroHealth setPosition:ccp(200,305)];
    [lblHeroHealth setColor:ccGREEN];
    [self addChild:lblHeroHealth];
    
    // Add the goal counter
    lblGoalsRemaining = [CCLabelTTF labelWithString:@""
                      fontName:@"Verdana" fontSize:16];
    [lblGoalsRemaining setAnchorPoint:ccp(0,0.5)];
    [lblGoalsRemaining setPosition:ccp(430,305)];
    [lblGoalsRemaining setColor:ccBLUE];
    [self addChild:lblGoalsRemaining];
}</pre></div><p>By now this should be simple code to read. We create three labels that are the fixed names of the stats presented: kills, health, and goals. We then <a id="id1931" class="indexterm"/>create three counter labels for the corresponding values. This handles the initial construction of the layer, <a id="id1932" class="indexterm"/>but we need to be able to update the values easily, so we create three helper methods.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1933" class="indexterm"/>
<a id="id1934" class="indexterm"/>
<code class="literal">TDHUDLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) changeHealthTo:(NSInteger)newHealth {
    NSString *newVal = [NSString stringWithFormat:@"%i %%",
                          newHealth];
    [lblHeroHealth setString:newVal];
}

-(void) changeGoalTo:(NSInteger)newGoal {
    NSString *newVal = [NSString stringWithFormat:@"%i",
                          newGoal];
    [lblGoalsRemaining setString:newVal];
}

-(void) changeKillsTo:(NSInteger)newKills {
    NSString *newVal = [NSString stringWithFormat:@"%i",
                         newKills];
    [lblKills setString:newVal];
}</pre></div><p>Now we have three methods that allow us to easily change the values of the counter labels as needed. As you probably figured out, we will be calling these directly from the playfield layer. There is nothing fancy here, just code that works. You could always embellish this by adding some animation when the values <a id="id1935" class="indexterm"/>change, or some other graphic flair. Since this code is self contained in its own layer, you can expand this without any changes to the playfield layer.</p></div>
<div class="section" title="Scene construction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec83"/>Scene construction</h1></div></div></div><p>We now have three layers for our game, and some layers need to know about the others. Nothing can be a child of the playfield layer, due to the <a id="id1936" class="indexterm"/>scrolling issue. <a id="id1937" class="indexterm"/>This is exactly the type of situation that causes us to prefer the separation of scene and layer files, unlike the common template format (a scene method embedded in the <code class="literal">CCLayer</code> class). If we were to do that, in which class would you include the scene method, since there is really not one parent layer? (Some would argue that the HUD should be the master layer, with others as children of it. Technically, that works too. We're not fans of that structure, however). <a id="id1938" class="indexterm"/>Our solution is in the construction of the <code class="literal">TDPlayfieldScene</code> class.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1939" class="indexterm"/>
<a id="id1940" class="indexterm"/>
<code class="literal">TDPlayfieldScene.m</code>
</p><div class="informalexample"><pre class="programlisting">@implementation TDPlayfieldScene

+(id) sceneWithTiltControls:(BOOL)isTilt {
    return [[[self alloc] initWithTiltControls:isTilt]
                                         autorelease];
}

-(id) initWithTiltControls:(BOOL)isTilt {
   if( (self=[super init])) {
        TDHUDLayer *hudLayer = [TDHUDLayer node];
        [self addChild:hudLayer z:5];
    
        TDPlayfieldLayer *pf = [TDPlayfieldLayer
                      layerWithHUDLayer:hudLayer];
        [self addChild: pf];
        
        TDControlLayer *controls = [TDControlLayer
                      controlsWithPlayfieldLayer:pf
                      withTilt:isTilt];
        [self addChild:controls z:10];

   }
   return self;
}

@end</pre></div><p>This allows us to build all three layers in the correct order, with all being children of the scene. This way, none of the layers are children of each other. The playfield layer can be initialized with a reference to the HUD <a id="id1941" class="indexterm"/>layer, and the controls can be initialized with a reference to the playfield layer. Everything works, and it is easily readable. This construction also makes it trivial to determine the hierarchy of the scenes and layers. The following screenshot shows what our game looks like with all layers included:</p><div class="mediaobject"><img src="graphics/9007_08_09.jpg" alt="Scene construction"/></div></div>
<div class="section" title="Tile helper methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec84"/>Tile helper methods</h1></div></div></div><p>One of the challenges in using tile maps is that we have at least two different coordinate positions that can be used to refer to a position on the map: pixels on the tilemap, and the tile coordinates. The tile coordinates relate to each individual tile, so the top left tile is (0,0) and the bottom right is (49,49) for our 50 by 50 map. <a id="id1942" class="indexterm"/>
<a id="id1943" class="indexterm"/>What we need are some helper methods to easily convert between the two.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1944" class="indexterm"/>
<a id="id1945" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(CGPoint)tileCoordForPos:(CGPoint)pos {
    // Convert map posiiton to tile coordinate
    NSInteger x = pos.x / tw;
    NSInteger y = ((tmh * th) - pos.y) / th;
    
    return ccp(x,y);
}</pre></div><p>Here we are finally making use of the shorthand variables we saw in the <code class="literal">init</code> method. As a refresher, the variables are as follows: </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">tmw</code> = tilemap width</li><li class="listitem" style="list-style-type: disc"><code class="literal">tmh</code> = tilemap height</li><li class="listitem" style="list-style-type: disc"><code class="literal">tw</code> = tile width</li><li class="listitem" style="list-style-type: disc"><code class="literal">th</code> = tile height</li></ul></div><p>So the <code class="literal">x</code> value is the position divided by the tile width. For the <code class="literal">y</code> value, the calculation is a little longer, because the origin point of the tile map is top left instead of bottom left. By multiplying the tilemap height times the tile height we have the total map height. From that we subtract the position, and then divide the result by the tile height. This gives us the reversed <code class="literal">y</code> positioning that we need. The final <code class="literal">CGPoint</code> <a id="id1946" class="indexterm"/>from this method is the tile coordinate for the given position.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1947" class="indexterm"/>
<a id="id1948" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">- (CGPoint)posForTileCoord:(CGPoint)tileCoord {
    // Convert the tile coordinate to map position
    NSInteger x = (tileCoord.x * tw) + tw / 2;
    NSInteger y = (tmh * th)-(tileCoord.y * th)-th / 2;

    return ccp(x, y);
}</pre></div><p>This method reverses the same calculation that we just saw. One callout on this method is the last bit of each formula. The "core" of the formulas will result in the edge of the tile being converted. By adding half the tile width (or subtracting half of the tile height), the end result is the center of the tile, which is what we <a id="id1949" class="indexterm"/>want.</p><div class="section" title="Tile self-identification"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec108"/>Tile self-identification</h2></div></div></div><p>We need some methods to perform what we refer to as <a id="id1950" class="indexterm"/>
<a id="id1951" class="indexterm"/>self-identification. <a id="id1952" class="indexterm"/>
<a id="id1953" class="indexterm"/>This is where we can "ask" each tile about any special properties. </p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">- (BOOL)isValidTileCoord:(CGPoint)tileCoord {
    if (tileCoord.x &lt; 0 || tileCoord.y &lt; 0 ||
        tileCoord.x &gt;= tmw ||
        tileCoord.y &gt;= tmh) {
        return FALSE;
    } else {
        return TRUE;
    }
}</pre></div><p>The first of these methods is the <a id="id1954" class="indexterm"/>
<a id="id1955" class="indexterm"/>
<code class="literal">isValidTileCoord</code> method, so we can check to see if a tile coordinate being passed is even on the map. A simple check on the lower bounds (zero) and the upper bounds (tilemap width, tilemap height) will allow us to return a Boolean value to identify if this is a valid tile.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(BOOL)isWallAtTileCoord:(CGPoint)tileCoord {
    // If it is invalid, act like it is a wall
    if ([self isValidTileCoord:tileCoord] == NO) {
        return YES;
    }
    
    int gid = [self.walls tileGIDAt:tileCoord];
    NSDictionary *properties = [_tileMap
                                   propertiesForGID:gid];

    return ([properties valueForKey:@"Blocked"] != nil);
} </pre></div><p>This method uses the <code class="literal">isValidTileCoord:</code> method to determine if the tile is valid. If it is not, then we can treat it as though it is a wall and return <code class="literal">YES</code>. Otherwise, we get the tile's GID for the specified tile coordinate in the walls layer. (<a id="id1956" class="indexterm"/>
<a id="id1957" class="indexterm"/>
<span class="strong"><strong>GID</strong></span> is a <span class="strong"><strong>Global Identifier</strong></span> used by the tilemap.) We then poll the tilemap to get any properties related to that tile. We return the value for the <a id="id1958" class="indexterm"/>key <code class="literal">Blocked</code>. If you recall when we built the map in Tiled, we gave the red tile a property of <code class="literal">Blocked</code>, with a value of <code class="literal">Yes</code>. Here is where we get the benefit of that tilemap. With this simple check, we can "ask" the <a id="id1959" class="indexterm"/>map if there is a wall, and get a definitive answer. How easy is that?</p><p>We follow the same basic logic to identify both goal markers and health powerups.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1960" class="indexterm"/>
<a id="id1961" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(BOOL)isGoalAtTileCoord:(CGPoint)tileCoord {
    int gid = [self.triggers tileGIDAt:tileCoord];
    NSDictionary *properties = [_tileMap
                                propertiesForGID:gid];
    
    return ([properties valueForKey:@"Goal"] != nil);
}

-(BOOL)isHealthAtTileCoord:(CGPoint)tileCoord {
    int gid = [self.triggers tileGIDAt:tileCoord];
    NSDictionary *properties = [_tileMap
                                propertiesForGID:gid];

    return ([properties valueForKey:@"Health"] != nil);
}</pre></div><p>As you can see, the code is virtually identical between these methods. If you were so inclined, you could extrapolate a base method that could do both, but we prefer explicit method calls in this case, mostly because we only have two types of triggers.</p></div></div>
<div class="section" title="Smarter hero walking"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec85"/>Smarter hero walking</h1></div></div></div><p>With the code that we have covered so far, our hero will walk around without any awareness of the special tiles that we have placed, so he will walk right through walls. We need to fix this. Now that we have added <a id="id1962" class="indexterm"/>methods to make it <a id="id1963" class="indexterm"/>fairly simple to determine where our special triggers are, we can revisit the <a id="id1964" class="indexterm"/>
<a id="id1965" class="indexterm"/>
<code class="literal">setHeroPos</code> method, which we started earlier. This is a complete replacement of the earlier method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) setHeroPos:(CGPoint)pos {
    // Get the tile coordinates
    CGPoint tileCoord = [self tileCoordForPos:pos];

    // Check if the new tile is blocked
    if ([self isWallAtTileCoord:tileCoord]) {
        // Return without allowing the move
        return;
    }

    // Check if the hero picked up health
    if ([self isHealthAtTileCoord:tileCoord]) {
        // Remove it from the map
        [_triggers removeTileAt:tileCoord];
        [_pickups removeTileAt:tileCoord];
        // Add health to the player
        [self heroGetsHealth];
    }

    // Check if the hero grabbed a goal
    if ([self isGoalAtTileCoord:tileCoord]) {
        // Remove it from the map
        [_triggers removeTileAt:tileCoord];
        [_pickups removeTileAt:tileCoord];
        // Add goal to the player
        [self heroGetsGoal];
    }

    // Set the new position
    hero.sprite.position = pos;
    
    // Center the view on the hero
    [self setViewpointCenter:pos];
}</pre></div><p>We begin the method by converting the new hero position to a tile coordinate. We then check to see if this is actually a wall. If the desired coordinate is a blocked tile, then the method will return without moving the hero. This will effectively prevent the hero from walking on any of the blocked tiles. We then check for health powerups or goal markers, using our helper methods. If we have picked up a <a id="id1966" class="indexterm"/>goal or health, we remove the corresponding tile from both the <code class="literal">_triggers</code> and the <code class="literal">_pickups </code>layers. Removing it from the <code class="literal">_pickups</code> layer <a id="id1967" class="indexterm"/>
<a id="id1968" class="indexterm"/>will take away the visible tile, and removing it from the <code class="literal">_triggers</code> layer <a id="id1969" class="indexterm"/>
<a id="id1970" class="indexterm"/>will prevent us from triggering the same event the next time the player passes over this tile. In both cases, we call out to the <a id="id1971" class="indexterm"/>appropriate handling method to take action on the item that was picked up. After this new code, we see the same hero positioning and viewpoint centering code we saw earlier. Let's look at the item pickup handler methods.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1972" class="indexterm"/>
<a id="id1973" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) heroGetsHealth {
    heroHealth = heroHealth + 40;
    [hudLayer changeHealthTo:heroHealth];
}</pre></div><p>We decided that the hero should have a 40 point boost to his health when he picks up one of the odd cactus things. We update the <a id="id1974" class="indexterm"/>
<a id="id1975" class="indexterm"/>
<code class="literal">heroHealth</code> variable, and update the HUD by calling out to the <code class="literal">hudLayer</code> for the <a id="id1976" class="indexterm"/>
<a id="id1977" class="indexterm"/>
<code class="literal">changeHealthTo</code>: method we <a id="id1978" class="indexterm"/>saw earlier.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1979" class="indexterm"/>
<a id="id1980" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) heroGetsGoal {
    heroGoalsRemaining--;
    [hudLayer changeGoalTo:heroGoalsRemaining];
    
    if (heroGoalsRemaining &lt;= 0) {
        // hero wins
        isGameOver = YES;
        preventTouches = YES;
    }
}</pre></div><p>For the goal, we adjust the <code class="literal">heroGoalsRemaining</code> variable and change the HUD in a similar fashion. However, since the goals are the point of the game, we check to see if all the goals have been reached (picked up). If so, we set the <code class="literal">isGameOver</code> and <code class="literal">preventTouches</code> to <code class="literal">YES</code>, which will end the game when the next <code class="literal">update</code> loop runs.</p></div>
<div class="section" title="Time for bullets"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec86"/>Time for bullets</h1></div></div></div><p>All this running around and hitting walls is fine and good, <a id="id1981" class="indexterm"/>but we need to be able to shoot, don't we? As you may recall from our discussion of the <code class="literal">TDControlLayer</code> class, <a id="id1982" class="indexterm"/>you will recall that when the button is pressed we simply set the Boolean variable <code class="literal">heroShooting</code> to <code class="literal">YES</code>. We handle this value in the <code class="literal">TDPlayfieldLayer</code> update method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1983" class="indexterm"/>
<a id="id1984" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) update:(ccTime) dt {
    // If the shoot button is pressed
    if (heroShooting) {
        // We limit the hero's shoot speed to avoid
        // massive "bullet rain" effect
        if (currHeroShootSpeed &gt; 0) {
            currHeroShootSpeed -= dt;
        } else {
            // Ready to shoot
            [hero shoot];
            currHeroShootSpeed = shootSpeed;
        }
    } else {
        // Get ready to shoot next press
        currHeroShootSpeed = 0;
    }
    
    // Move the enemies

    // Move the bullets

    // Check collisions

    // Is the game over?
    if (isGameOver) {
        [self gameOver];
    }
}</pre></div><p>We have left a few blanks here to fill in later, but this is the structure of the entire <code class="literal">update</code> method. When the <code class="literal">heroShooting</code> variable is <code class="literal">YES</code>, we evaluate the <code class="literal">currHeroShootSpeed</code> variable. If it is greater than zero, we subtract the delta time from it. If it has reached zero, we call the hero's <code class="literal">shoot</code> method. We then reset the <code class="literal">currHeroShootSpeed</code> to the value of the <code class="literal">shootSpeed</code> variable. This is set in the <code class="literal">init</code> method, and is set to a value of <code class="literal">0.2</code> to avoid <a id="id1985" class="indexterm"/>ridiculous machine-gunning of bullets. This means you can only shoot a maximum of once every 0.2 seconds. That's still fast enough, isn't it? If the hero is not shooting (that is, not pressing the shoot button), then we reset the <code class="literal">currHeroShootSpeed</code> variable to <code class="literal">0</code>. This allows the hero to shoot immediately when they press the button without having this "cooldown" timer delaying their shot.</p><div class="section" title="TDBullet class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec109"/>TDBullet class</h2></div></div></div><p>Now that we know how to shoot, we need to <a id="id1986" class="indexterm"/>know what we're <a id="id1987" class="indexterm"/>shooting.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id1988" class="indexterm"/>
<a id="id1989" class="indexterm"/>
<code class="literal">TDBullet.m</code>
</p><div class="informalexample"><pre class="programlisting">+(id) bulletFactoryForLayer:(TDPlayfieldLayer*)layer {
    return [[[self alloc] initForLayer:layer
               withSpriteFrameName:IMG_BULLET] autorelease];
}

-(id) initForLayer:(TDPlayfieldLayer*)layer
         withSpriteFrameName:(NSString*)spriteFrameName {
    if((self = [super
                initWithSpriteFrameName:spriteFrameName])) {

        parentLayer = layer;
        
        totalMoveDist = 200;
        thisMoveDist = 10;
        
        isDead = NO;
        
    }
    return self;
}</pre></div><p>Here we use the convenience method <code class="literal">bulletFactoryForLayer</code> to build the bullet. Because the <code class="literal">TDBullet</code> is a <a id="id1990" class="indexterm"/>
<a id="id1991" class="indexterm"/>
<code class="literal">CCSprite</code> subclass, we can use a call to <code class="literal">super initWithSpriteFrameName</code> to build the sprite. We keep a reference to the parent layer, and we set the <code class="literal">totalMoveDist</code> variable to be our limit of how far the bullet can travel before it expires. The variable <code class="literal">thisMoveDist</code> is used to determine how far on each update the bullet should travel. Most of the <a id="id1992" class="indexterm"/>work of this class is done in the <code class="literal">update</code> method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDBullet.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) update:(ccTime)dt {
    
    if (isDead) {
        return;
    }
    // Calculate the movement
    CGFloat targetAngle =
            CC_DEGREES_TO_RADIANS(-self.rotation);
    CGPoint targetPoint = ccpMult(ccpForAngle(targetAngle),
                                  thisMoveDist);
    CGPoint finalTarget = ccpAdd(targetPoint, self.position);

    self.position = finalTarget;

    totalMoveDist = totalMoveDist - thisMoveDist;

    if (totalMoveDist &lt;= 0) {
        [parentLayer removeBullet:self];
        return;
    }
    
    // Convert location to tile coords
    CGPoint tileCoord = [parentLayer tileCoordForPos:
                         self.position];
    
    // Check for walls.  Walls stop bullets.
    if ([parentLayer isWallAtTileCoord:tileCoord]) {
        [parentLayer removeBullet:self];
    }
}</pre></div><p>We begin this method by checking to make sure this bullet is not dead. It is possible to call <code class="literal">update</code> on a bullet in the process of being discarded, so this will prevent us from trying to move an object as it is being dereferenced. We then go through a bit of code that takes the current rotation and calculates a target in that direction that is <code class="literal">thisMoveDist</code> away from the current position. We subtract this from <a id="id1993" class="indexterm"/>the <code class="literal">totalMoveDist</code> value, so we can keep track of how far the bullet has left to move. If the <a id="id1994" class="indexterm"/>
<a id="id1995" class="indexterm"/>
<code class="literal">totalMoveDist</code> variable reaches zero, then we call to the <code class="literal">parentLayer</code> object to remove the bullet. If it is not zero, we convert the bullet's current position to a tile coordinate using the method in the <code class="literal">parentLayer</code>. We then check to see if the tile is a wall. If it is, the bullet is removed, <a id="id1996" class="indexterm"/>because we do not want the bullets to go through the walls.</p><p>We also have two bullet-handling methods in the playfield layer.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addBullet:(TDBullet*)thisBullet {
    [self addChild:thisBullet z:5];
    [bulletArray addObject:thisBullet];
}

-(void) removeBullet:(TDBullet*)thisBullet {
    [thisBullet setIsDead:YES];
    [bulletArray removeObject:thisBullet];
    [thisBullet removeFromParentAndCleanup:YES];
}</pre></div><p>If you recall from our review of the <a id="id1997" class="indexterm"/>
<a id="id1998" class="indexterm"/>
<code class="literal">TDHero</code> class, when the <code class="literal">shoot</code> method is called, it builds a bullet and then passes that bullet to the <code class="literal">addBullet</code> method of the layer stored in the <code class="literal">parentLayer</code> variable. Here you can see what that does. It adds it to the layer, and then adds the bullet to the <code class="literal">bulletArray</code> array. When we need to remove a bullet, we first set the bullet's <code class="literal">isDead</code> property to <code class="literal">YES</code>, and then remove the bullet from the array and the layer.</p><p>The final bit of the bullet movement code that we need is in the <code class="literal">update</code> method of the <code class="literal">TDPlayfieldLayer</code>. We need to add a couple of lines there:</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code> (update method, under <code class="literal">Move The Bullets</code>):</p><div class="informalexample"><pre class="programlisting">    for (int i = 0; i &lt; [bulletArray count]; i++) {
        [[bulletArray objectAtIndex:i] update:dt];
    }</pre></div><p>This is nicely compact code, just as we like it. Here we <a id="id1999" class="indexterm"/>iterate through all the bullets in the <code class="literal">bulletArray</code>, and call each one's <code class="literal">update</code> method, with the current delta. We iterate using a traditional <code class="literal">for</code> loop instead of fast enumeration (that is <code class="literal">for (TDBullet *aBullet in bulletArray)</code>) because we may be calling for some bullets to die in this loop. Mutating the array while using fast enumeration will cause a crash. Don't believe us? Try it and you'll see for yourself.</p></div></div>
<div class="section" title="Building the enemy"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec87"/>Building the enemy</h1></div></div></div><p>Now we have a world to run around in and bullets to shoot, but nobody to stop us from reaching our goals. We need to add some enemies to spice it up. <a id="id2000" class="indexterm"/>
<a id="id2001" class="indexterm"/>As we go through the enemy handling code, keep in mind how we set up the hero. You will see a lot of similarities, and we could have compressed them into a single base class, but opted not to do so for clarity's sake. </p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id2002" class="indexterm"/>
<a id="id2003" class="indexterm"/>
<code class="literal">TDEnemy.m</code>
</p><div class="informalexample"><pre class="programlisting">+(id) enemyAtPos:(CGPoint)pos onLayer:(TDPlayfieldLayer*)layer {
    return [[[self alloc] initForEnemyAtPos:pos onLayer:layer]
                                                autorelease];
}

-(id) initForEnemyAtPos:(CGPoint)pos
                   onLayer:(TDPlayfieldLayer*)layer  {
    if((self = [super init])) {
        // Keep a reference to the layer
        parentLayer = layer;

        // Build the sprite
        [self buildEnemySpriteAtPos:pos];
 
        // Add the sprite to the layer
        [parentLayer addChild:sprite z:2];
    
        // Set the max shooting speed
        maxShootSpeed = 3;
    }
    return self;
}</pre></div><p>Here we have the constructors for the <code class="literal">TDEnemy</code> class. We keep a reference to the <code class="literal">parentLayer</code>, set the <code class="literal">maxShootSpeed</code> variable, and <a id="id2004" class="indexterm"/>we call out to <a id="id2005" class="indexterm"/>the <code class="literal">buildEnemySpriteAtPos</code> method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDEnemy.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) buildEnemySpriteAtPos:(CGPoint)pos {
    sprite = [CCSprite
                spriteWithSpriteFrameName:IMG_ENEMY];
    [sprite setPosition:pos];
}</pre></div><p>Why did we break this method out separately, instead of embedding these two lines in the <code class="literal">init</code> method? We did this to make subclassing of the <a id="id2006" class="indexterm"/>
<a id="id2007" class="indexterm"/>
<code class="literal">TDEnemy</code> class easier. Because we have kept this separate, we can override this method without needing to override the <code class="literal">init</code> method in any subclasses of the <code class="literal">TDEnemy</code>. This allows us to not repeat the boilerplate <code class="literal">init</code> method for both enemy classes, when the only difference is the sprite used.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDEnemy.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) rotateToTarget:(CGPoint)target {
    // Rotate toward player
    CGPoint diff = ccpSub(target,sprite.position);
    float angleRadians = atanf((float)diff.y / (float)diff.x);
    float angleDegrees = CC_RADIANS_TO_DEGREES(angleRadians);
    float cocosAngle = -angleDegrees;
    if (diff.x &lt; 0) {
        cocosAngle += 180;
    }
    sprite.rotation = cocosAngle;
} </pre></div><p>This rotation method works the same way that the rotation method in the hero class operates. It determines the angle toward the specified target, and rotates accordingly.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDEnemy.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) moveToward:(CGPoint)target {
    // Rotate toward player
    [self rotateToTarget:target];

    // Move toward the player
    CGFloat targetAngle =
                CC_DEGREES_TO_RADIANS(-sprite.rotation);
    CGPoint targetPoint = ccpForAngle(targetAngle);
    CGPoint finalTarget = ccpAdd(targetPoint,
                                 sprite.position);
    CGPoint tileCoord = [parentLayer
                         tileCoordForPos:finalTarget];
    
    if ([parentLayer isWallAtTileCoord:tileCoord]) {
        // Cannot move - hit a wall
        return;
    }
    
    // Set the new position
    sprite.position = finalTarget;
}</pre></div><p>Here we are using some basic movement code. The enemy will determine the most direct path toward the hero, and try to move there. Just as we did with the hero and bullets, the enemies are unable to pass through walls. We don't <a id="id2008" class="indexterm"/>have any special handling for the enemy to do something different when they hit a wall, so they will continue to <a id="id2009" class="indexterm"/>try to move into a wall for as long as it is between the hero and the enemy. Not too smart, but this is supposed to be your basic enemy grunt. Not too bright.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDEnemy.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) shoot {
    // Create a projectile at hero's position
    TDBullet *bullet = [TDBullet
                         bulletFactoryForLayer:parentLayer];
    bullet.position = self.sprite.position;
    bullet.rotation = self.sprite.rotation;
    bullet.isEnemy = YES;
    [bullet setColor:ccRED];
    
    // add bullets to parentLayer's array
    [parentLayer addBullet:bullet];
    
    // Play a sound effect
    [[SimpleAudioEngine sharedEngine] playEffect:SND_SHOOT];
}</pre></div><p>This method is virtually identical to the hero's <code class="literal">shoot</code> method, with two exceptions. The first is that we set the <a id="id2010" class="indexterm"/>
<a id="id2011" class="indexterm"/>
<code class="literal">isEnemy</code> variable to <code class="literal">YES</code>, to identify that this is a bullet fired by an enemy unit. The second is that we set the bullet's color to red. <a id="id2012" class="indexterm"/>The sprite we are using is blue, so this gives the enemy a "bad guys shoot red" effect. Everything else in this method is identical.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDEnemy.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) update:(ccTime)dt {
    currShootSpeed = currShootSpeed - dt;
    
    // Take a step
    [self moveToward:[parentLayer getHeroPos]];
    
    if (ccpDistance(sprite.position, 
                     [parentLayer getHeroPos]) &lt; 250) {
        // Limit the shoot speed
        if (currShootSpeed &lt;= 0) {
            // Ready to shoot
            [self shoot];
            currShootSpeed = maxShootSpeed;
        }
    }
}</pre></div><p>In the enemy's <a id="id2013" class="indexterm"/>
<a id="id2014" class="indexterm"/>
<code class="literal">update</code> method, we move toward the hero's position on each update. We also check to see if the distance from the enemy to the hero is less than <code class="literal">250</code> points. If it is, then the enemy will try to shoot. Since he is already rotated toward the hero, he will always shoot directly at the hero.</p><p>Just as with the bullets, we need to make a small addition to the main layer's <code class="literal">update</code> method to make the enemies move.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code> (update method, under <code class="literal">Move The Enemies</code>):</p><div class="informalexample"><pre class="programlisting">    for (int i = 0; i &lt; [enemyArray count]; i++) {
        [[enemyArray objectAtIndex:i] update:dt];
    }</pre></div><p>This is virtually identical to the movement code for the bullets. For each update, we instruct each enemy to move himself.</p><div class="section" title="Adding the enemies"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Adding the enemies</h2></div></div></div><p>We now know how the enemy class is <a id="id2015" class="indexterm"/>constructed, and <a id="id2016" class="indexterm"/>how to make them move, so next we need to add them to the game itself.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addEnemyOfType:(EnemyType)enemyType {
    // Randomly pick a spawn point
    NSString *enemySpawnID = [NSString stringWithFormat:
                              @"EnemySpawn%i",
                              (arc4random() % 11) + 1];

    // Get the point
    NSMutableDictionary *enemySpawn = [spawns objectNamed:
                                       enemySpawnID];
    float x = [[enemySpawn valueForKey:@"x"] floatValue];
    float y = [[enemySpawn valueForKey:@"y"] floatValue];
    
    // Retina-ize the position (TMX files are in pixels)
    x /= CC_CONTENT_SCALE_FACTOR();
    y /= CC_CONTENT_SCALE_FACTOR();

    if (enemyType == kEnemyEasy) {
        // Create the enemy (will put itself on the layer)
        TDEnemy *enemy = [TDEnemy enemyAtPos:ccp(x,y)
                                     onLayer:self];
        
        // Add it to the array
        [enemyArray addObject:enemy];
    }
    else if (enemyType == kEnemyHard) {
        // Create the enemy (will put itself on the layer)
        TDEnemySmart *enemy = [TDEnemySmart
                               enemyAtPos:ccp(x,y)
                               onLayer:self];
        
        // Add it to the array
        [enemyArray addObject:enemy];
    }
}</pre></div><p>If you recall when we built the tilemap, we designated objects on the map named <code class="literal">EnemySpawn1</code>, <code class="literal">EnemySpawn2</code>, and so on. Now we can finally use those spawn points. We don't like the idea of enemies always spawning at the same spot, <a id="id2017" class="indexterm"/>so we randomly pick a number between <code class="literal">1</code> and <code class="literal">11</code> using <code class="literal">arc4random()</code>. We use this to build a string that corresponds to an object name on our <code class="literal">spawns</code> layer of the tilemap. We can't use these values directly, because of the points versus pixels issue, so we divide the <code class="literal">x</code> and <code class="literal">y</code> coordinates by the <code class="literal">CC_CONTENT_SCALE_FACTOR()</code> to get the correct positioning.</p><p>Here you see we have defined two types of enemy: <code class="literal">kEnemyEasy</code> and <code class="literal">kEnemyHard</code>. We use the same basic constructor for both, but the hard enemy will <a id="id2018" class="indexterm"/>use the <code class="literal">TDEnemySmart</code> class instead (we'll get to that later).</p><p>Now, we need to be able to build enemies of both types in the game.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addEnemies {
    // Add some enemies
    for (int i = 0; i &lt; 5; i++) {
        [self addEnemyOfType:kEnemyEasy];
    }
    for (int i = 0; i &lt; 3; i++) {
        [self addEnemyOfType:kEnemyHard];
    }
}</pre></div><p>We simply step through two <code class="literal">for</code> loops to add the specified number of enemies for each type. The numbers are arbitrarily chosen, and you can adjust them as you see fit to provide a hard enough challenge for you.</p></div></div>
<div class="section" title="Collision handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec88"/>Collision handling</h1></div></div></div><p>At this point we have everything we need, except <a id="id2019" class="indexterm"/>for a way to make bullets hit the <a id="id2020" class="indexterm"/>hero and enemies. What fun is shooting if you can't hit anything?</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id2021" class="indexterm"/>
<a id="id2022" class="indexterm"/>
<code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) checkCollisions {
    NSMutableArray *bulletsToDelete = 
                         [[NSMutableArray alloc] init];
    
    for (TDBullet *aBullet in bulletArray) {
        if (CGRectIntersectsRect(aBullet.boundingBox,
                                 hero.sprite.boundingBox)
                                &amp;&amp; aBullet.isEnemy) {
            // Hero got hit!
            [self heroGetsHit];
            [bulletsToDelete addObject:aBullet];
            [aBullet removeFromParentAndCleanup:YES];
            break;
        }
        // Iterate through enemies, see if they got hit
        for (TDEnemy *anEnemy in enemyArray) {
            if (CGRectIntersectsRect(aBullet.boundingBox,
                                anEnemy.sprite.boundingBox)
                            &amp;&amp; aBullet.isEnemy == NO) {
                //Enemy got hit
                [self enemyGetsHit:anEnemy];
                [bulletsToDelete addObject:aBullet];
                [aBullet removeFromParentAndCleanup:YES];
                break;
            }
        }
    }
    // Remove the bullets
    for (int i = 0; i &lt; [bulletsToDelete count]; i++) {
        [bulletArray removeObjectsInArray:bulletsToDelete];
    }
    
    [bulletsToDelete release];
} </pre></div><p>As we have seen, all the bullets in the game are stored in a single array, <code class="literal">bulletArray</code>. We iterate through that array and first check to see if a bullet hit the hero. We use <code class="literal">CGRectIntersectsRect</code> to see if there is any overlap of the <code class="literal">boundingBox</code> objects of the bullet and the hero. We also check the bullet's <code class="literal">isEnemy</code> property to make sure it is an enemy bullet. (Remember, we don't want any friendly-fire!) If the bullet is touching the hero and an enemy fired it, we register the collision. We call the <code class="literal">heroGetsHit</code> method, add the bullet to the <a id="id2023" class="indexterm"/>
<a id="id2024" class="indexterm"/>
<code class="literal">bulletsToDelete</code> array, and remove the bullet from the layer. Why didn't we use the <code class="literal">removeBullet</code> method that we saw earlier? We can't use that because we would be removing the bullet from the array while <a id="id2025" class="indexterm"/>iterating through it, which would cause a mutation (leading to a crash). Because we need to <a id="id2026" class="indexterm"/>remove the bullets after the iteration is done, we use the <code class="literal">bulletsToDelete</code> array instead.</p><p>If the hero was not hit by a bullet, we then iterate through all enemies in the <code class="literal">enemyArray</code>. We do a similar check of each <code class="literal">boundingBox</code> and make sure it is not an enemy-fired bullet. If the enemy is hit, we call the <code class="literal">enemyGetsHit</code> method, and pass it a reference to the enemy that was hit.</p><p>Finally, we remove all bullets from the <a id="id2027" class="indexterm"/>
<a id="id2028" class="indexterm"/>
<code class="literal">bulletsToDelete</code> array (when the other loops are done) so we can remove them safely.</p><p>We trigger the collision check in the update method, as follows.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code> (update method, under <code class="literal">Check collisions</code>):</p><div class="informalexample"><pre class="programlisting">    [self checkCollisions];</pre></div><p>We check for collisions at the end of every update, so we can <a id="id2029" class="indexterm"/>always be using the <a id="id2030" class="indexterm"/>current state of the game field.</p><div class="section" title="Everybody gets hit"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Everybody gets hit</h2></div></div></div><p>Now, we will look at the methods that were called when the hero or an enemy gets hit by a bullet. First, we will look at the hero.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) heroGetsHit {
    // Decrease the hero's health
    heroHealth = heroHealth - 20;
    [hudLayer changeHealthTo:heroHealth];
    
    // Play the effect
    [[SimpleAudioEngine sharedEngine] playEffect:SND_HERO];
    
    if (heroHealth &lt;= 0) {
        // Hero died.
        isGameOver = YES;
        preventTouches = YES;
    }
}</pre></div><p>Our hero is pretty tough, so a single bullet isn't enough to kill him. Instead, we subtract <code class="literal">20</code> from his health and update the HUD. If his health has reached zero, he is dead. We set the <a id="id2031" class="indexterm"/>
<a id="id2032" class="indexterm"/>
<code class="literal">isGameOver</code> variable to <code class="literal">YES</code> so it will be handled at the end of the update loop. This is why collisions are handled after the movement, and game over is checked for after the collision handler.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) enemyGetsHit:(TDEnemy*) thisEnemy {
    // Get rid of the enemy
    [thisEnemy.sprite removeFromParentAndCleanup:YES];
    [enemyArray removeObject:thisEnemy];
    
    // Score the kill
    heroKills++;
    [hudLayer changeKillsTo:heroKills];
    
    // Play the effect
    [[SimpleAudioEngine sharedEngine] playEffect:SND_ENEMY];

    // Spawn a new enemy to replace this one
    [self addEnemyOfType:kEnemyEasy];
}</pre></div><p>When an enemy gets hit, they die immediately. We could have given them a health level like the hero, but who wants really strong enemies? We remove the enemy from the layer and remove it from the <code class="literal">enemyArray</code>. Because we want to track our hero's kill count, we increment his kills and call to the <code class="literal">hudLayer</code> to update the display. We then play a death sound, and spawn a new enemy. As it is written, we will only spawn easy enemies when any enemy dies. This could be modified, if you prefer to do something like randomly picking a new enemy type. We decided that the hard enemies were the commanders, and you can't as easily replace a commander as a grunt.</p></div></div>
<div class="section" title="Game over, man"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec89"/>Game over, man</h1></div></div></div><p>We have seen where we set game over conditions, so let's look at the <a id="id2033" class="indexterm"/>
<a id="id2034" class="indexterm"/>actual game over method. It's pretty basic, but it serves its purpose.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) gameOver {
    [self unscheduleUpdate];
    
    NSString *msg = @"You win!";
    
    if (heroHealth &lt;= 0) {
        msg = @"You died.";
    }
    
    [hudLayer showGameOver:msg];
        
    CCDelayTime *delay = [CCDelayTime actionWithDuration:3.0];
    CCCallBlock *allowExit = [CCCallBlock actionWithBlock:^{
        preventTouches = NO;
    }];
    
    [self runAction:[CCSequence actions: delay, allowExit,
                     nil]];
}</pre></div><p>The first thing we do at game over is to unschedule the update so the enemies stop moving. As you may recall, when we have been setting the <code class="literal">isGameOver</code> variable, we have also been setting <code class="literal">preventTouches</code> to <code class="literal">YES</code>. That flag will stop any input from being accepted (as we saw in the <code class="literal">update</code> method of the <a id="id2035" class="indexterm"/>
<code class="literal">TDControlLayer</code> class), so here we just need to stop everything else from moving. If the hero is out of health, he died. Otherwise, they must have won, since the only two ways for the game to end are dying or collecting all of the goals. We call out the <code class="literal">hudLayer</code> to the <a id="id2036" class="indexterm"/>
<a id="id2037" class="indexterm"/>
<code class="literal">showGameOver</code> method, and then we set up a <code class="literal">3.0</code> second delay before the <code class="literal">preventTouches</code> is reset to <code class="literal">NO</code>. Once <code class="literal">preventTouches</code> is reset to <code class="literal">NO</code> from within the <code class="literal">CCCallBlock</code> action, then the <code class="literal">TDControlLayer</code> will accept the next touch to <a id="id2038" class="indexterm"/>send the player back to the menu.</p><p>You might be asking why we put the game over message in the <code class="literal">hudLayer</code> class. This is for convenience, since we really don't want to display <a id="id2039" class="indexterm"/>user messages on the same layer as the tilemap. We could have created another layer for just the game over message, but that seemed like extra code that wasn't really needed. So we put it in the <code class="literal">hudLayer</code> class.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">TDHUDLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) showGameOver:(NSString*)msg {
    
    CGSize size = [[CCDirector sharedDirector] winSize];
    
    CCLabelTTF *gameOver = [CCLabelTTF labelWithString:msg
                     fontName:@"Verdana" fontSize:30];
    [gameOver setColor:ccRED];
    [gameOver setPosition:ccp(size.width/2,
                            size.height/2)];
    [self addChild:gameOver z:50];
}</pre></div><p>We display the message that was passed as the contents of a label, which we center on the screen. Obviously, this is pretty simple and barebones, but it serves its purpose. Feel free to dress it up and make it more sensational, if you so desire. For now, this is what you see when you die:</p><div class="mediaobject"><img src="graphics/9007_08_10.jpg" alt="Game over, man"/></div></div>
<div class="section" title="Smarter enemies"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec90"/>Smarter enemies</h1></div></div></div><p>We have a fully functional game at this point, except for fleshing out the smarter enemies. After quite a bit of experimentation, we have found several things that don't work to improve the enemies, and a couple of things we can do to make them better. We tried using an enemy that used <a id="id2040" class="indexterm"/>
<a id="id2041" class="indexterm"/>
<code class="literal">A* Pathfinding</code>, which is <a id="id2042" class="indexterm"/>considered the "gold standard" of pathfinding algorithms. However, this was not a great answer for the enemies, as they would stop and pause to recalculate a new route, which would often take a second or two, depending on how far away from the hero they were. If you had a couple of these enemies in the game at the same time, the entire system would freeze for a second or two. Not good.</p><p>After trying some different approaches (and different <code class="literal">A*</code> implementations), we have settled on a hybrid enemy pathfinding. Most of the time it works like a standard enemy. The difference is when it hits a wall, it changes to use <code class="literal">A* Pathfinding</code> to negotiate a route to the hero around the wall. As soon as it reaches that destination, it reverts to the standard movement code.</p><div class="section" title="Code not covered here"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Code not covered here</h2></div></div></div><p>We have decided that, far from being experts at <code class="literal">A* Pathfinding</code>, we will be using the <code class="literal">A*</code> code written by <a id="id2043" class="indexterm"/>
<a id="id2044" class="indexterm"/>Johann Fradj, and published in a tutorial at <a class="ulink" href="http://www.raywenderlich.com">http://www.raywenderlich.com</a>. We <a id="id2045" class="indexterm"/>
<a id="id2046" class="indexterm"/>have included it in this project with the permission of both Johann Fradj and Ray Wenderlich. (Thanks to you both!)</p><p>Instead of covering this code method by method, I will instead refer you to his tutorial, from which this code was <a id="id2047" class="indexterm"/>
<a id="id2048" class="indexterm"/>taken:</p><p>
<a class="ulink" href="http://www.raywenderlich.com/4970/how-to-implement-a-pathfinding-with-cocos2d-tutorial">http://www.raywenderlich.com/4970/how-to-implement-a-pathfinding-with-cocos2d-tutorial</a>
</p><p>He explains it better than we can, and it is a very good explanation. Instead of quoting his code in detail here, we will instead explain our modifications to his code, and our rationale for doing so. (We might miss some minor modifications, but we'll try to cover the major ones.)</p><p>The first major modification we made is to rename the class <code class="literal">ShortestPathStep</code> to <code class="literal">AStarNode</code>. This is because it is a shorter name, and it was originally being overlaid on an earlier code base. Really, it was mostly because we wanted a shorter name that felt like a better description to us.</p><p>Our entrance to the <code class="literal">A*</code> code is in the <code class="literal">moveTowardWithPathfinding</code> method in the <code class="literal">TDEnemySmart</code> class. We perform our <code class="literal">rotateToTarget</code> at the beginning of this class, so we are always pointed in the right direction.</p><p>The other major change we made to the code is to insert the Boolean variable <code class="literal">isUsingPathfinding</code> to control when the <code class="literal">A*</code> code would recursively call itself. Because we wanted to revert to simple pathfinding after an obstacle was passed, we turn off the <code class="literal">isUsingPathfinding</code> in each of the <code class="literal">if</code> statements in the <code class="literal">popStepAndAnimate</code> method.</p><p>We urge you to read Johann's wonderful tutorial (as well as a related <span class="emphasis"><em>Introduction To A* Pathfinding</em></span> that is linked to from that tutorial) to learn more about how <code class="literal">A* Pathfinding</code> works, as well as consulting the source code bundle for this chapter to see how our <code class="literal">TDEnemySmart</code> class is constructed.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec91"/>Summary</h1></div></div></div><p>We have covered a lot of material that is familiar yet new here. We have leveraged quite a few community resources for this project. We built our tile map with Tiled. We used SneakyJoystick rather than build our own joystick and button classes. We have dipped our toe in the <code class="literal">A*</code> waters with the help of Johann Fradj. We kept our layers separated into functional units so we could keep our code cleaner and more performant. Not to mention we had the opportunity to ponder why an orange would be the mortal enemy of lettuce. </p><p>This game is very basic on purpose. Once you master the concepts we covered here, it is easy to leverage this project to power a much bigger (and more sensible, perhaps) game. One of the great things about creating a game with tilemaps is that there is a lot of directly reusable code from game to game. For instance, the <code class="literal">isValidTile</code>, <code class="literal">isWall</code>, and so on methods are easily adaptable to any tilemap-based project. Reusability of code is key to writing code faster.</p><p>As we have probably made clear, we are big fans of open source tools and projects, both to use for our own development, but also to learn from those with much more experience.</p><p>Now we need to take a deep breath before we take on the final project of this book: An endless runner.</p></div></body></html>