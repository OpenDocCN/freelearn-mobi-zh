<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Creating Tasks and Plugins</h1></div></div></div><p>So far, we have been manipulating properties for our Gradle builds and learning how to run tasks. In this chapter, we will get a deeper understanding of those properties, and start creating our own tasks. Once we know how to write our own tasks, we can go even further, and look at how to make our own plugins that can be reused in several projects.</p><p>Before we look at how to create custom tasks, we need to learn a few important Groovy concepts. This is because having a basic understanding of how Groovy works makes it a lot easier to get started with custom tasks and plugins. Knowing Groovy also helps to understand how Gradle works, and why the build configuration files look the way they do.</p><p>In this chapter, we will look at the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding Groovy</li><li class="listitem" style="list-style-type: disc">Getting started with tasks</li><li class="listitem" style="list-style-type: disc">Hooking into the Android plugin</li><li class="listitem" style="list-style-type: disc">Creating your own plugins</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Understanding Groovy</h1></div></div></div><p>As most Android developers are proficient Java developers, it is interesting to look at how <a id="id245" class="indexterm"/>Groovy works compared to Java. Groovy is quite easy to read if you are a Java developer, but writing your own Groovy code would be a hard task without a small introduction.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>A good way to experiment with Groovy is to use the Groovy Console. This application comes with the Groovy SDK and makes it easy to try out Groovy statements while getting an immediate response. The Groovy Console is also able to handle pure Java code, which makes it easy to compare Java and Groovy code. You can download the Groovy SDK, including the Groovy Console, from the <a id="id246" class="indexterm"/>Groovy website at <a class="ulink" href="http://groovy-lang.org/download.html">http://groovy-lang.org/download.html</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec59"/>Introduction</h2></div></div></div><p>Groovy<a id="id247" class="indexterm"/> is derived from Java and runs on the Java Virtual Machine. Its goal is to be a simpler, more straightforward language that can be used either as a scripting language or as a full-blown programming language. Throughout this section, we will compare Groovy with Java to make it easier to grasp how Groovy works and to clearly see the difference between both languages.</p><p>In Java, printing a string to the screen looks like this:</p><div><pre class="programlisting">System.out.println("Hello, world!");</pre></div><p>In Groovy, you can accomplish the same with this line of code:</p><div><pre class="programlisting">println 'Hello, world!'</pre></div><p>You will immediately notice a few key differences:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No <code class="literal">System.out</code> namespace </li><li class="listitem" style="list-style-type: disc">No parentheses around method parameters</li><li class="listitem" style="list-style-type: disc">No semicolons at the end of a line</li></ul></div><p>The example also uses single quotes around a string. You can use either single quotes or double quotes for strings, but they have different usages. Double-quoted string can also include interpolated expressions. Interpolation is the process of evaluating a string that contains placeholders, and replacing those placeholders with their values. These placeholder expressions can be variables, or even methods. Placeholder expressions that contain a method or multiple variables need to be surrounded by curly brackets and prefixed by <code class="literal">$</code>. Placeholder expressions that contain a single variable can just be prefixed with <code class="literal">$</code>. Here are some examples of string interpolation in Groovy:</p><div><pre class="programlisting">def name = 'Andy'
def greeting = "Hello, $name!"
def name_size "Your name is ${name.size()} characters long."</pre></div><p>The <code class="literal">greeting</code> variable contains the string "Hello, Andy" and <code class="literal">name_size</code> is "Your name is 4 characters long.".</p><p>String interpolation allows you to execute code dynamically as well. This example is valid code that prints the current date:</p><div><pre class="programlisting">def method = 'toString'
new Date()."$method"()</pre></div><p>This looks very strange when you are used to Java, but it is normal syntax and behavior in dynamic programming languages.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec60"/>Classes and members</h2></div></div></div><p>Creating a class in <a id="id248" class="indexterm"/>Groovy looks a lot like creating a class in Java. Here is an example of a simple class containing one member:</p><div><pre class="programlisting">class MyGroovyClass {
    String greeting

    String getGreeting() {
        return 'Hello!'
    }
}</pre></div><p>Notice that neither the class nor the <a id="id249" class="indexterm"/>member has explicit access modifiers. The default access modifiers in Groovy are different from in Java. Classes themselves are public, just like methods, while class members are private.</p><p>To use <code class="literal">MyGroovyClass</code>, make a new instance of it:</p><div><pre class="programlisting">def instance = new MyGroovyClass()
instance.setGreeting 'Hello, Groovy!'
instance.getGreeting()</pre></div><p>You can use the keyword <code class="literal">def</code> to create new variables. Once you have a new instance of a class, you can manipulate its members. Accessors are added automatically by Groovy. You can still override them, as we did with <code class="literal">getGreeting()</code> in the definition of <code class="literal">MyGroovyClass</code>. If you specify nothing, you will still be able to use both a getter and a setter for every member in your class.</p><p>If you try to call a member directly, you will, in fact, call the getter. This means you do not need to type <code class="literal">instance.getGreeting()</code>, you can just use the shorter <code class="literal">instance.greeting</code> instead:</p><div><pre class="programlisting">println instance.getGreeting()
println instance.greeting</pre></div><p>Both lines in the preceding code sample print out the exact same thing.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec61"/>Methods</h2></div></div></div><p>Just like with variables, you<a id="id250" class="indexterm"/> do not need to define a specific return type for your methods. You are free to do so anyway, even if it is just for the sake of clarity. Another difference between Java and Groovy methods is that in Groovy, the last line of a method is always returned by default, even without using the <code class="literal">return</code> keyword.</p><p>To demonstrate the differences between Java and Groovy, consider this Java example of a method that returns the square of a number:</p><div><pre class="programlisting">public int square(int num) {
    return num * num;
}
square(2);</pre></div><p>You need to specify that the method is publicly accessible, what the return type is, and what the type of the parameter is. At the end of the method, you need to return a value of the return type.</p><p>The same method definition looks like this in Groovy:</p><div><pre class="programlisting">def square(def num) {
    num * num
}
square 4</pre></div><p>Neither the return type, nor the <a id="id251" class="indexterm"/>parameter type is explicitly defined. The <code class="literal">def</code> keyword is used instead of an explicit type, and the method implicitly returns a value without using the <code class="literal">return</code> keyword. However, using the <code class="literal">return</code> keyword is still recommended for clarity. When you call the method, you do not need parentheses or semicolon.</p><p>There is also another, even shorter, way to define new methods in Groovy. The same <code class="literal">square</code> method can also look like this:</p><div><pre class="programlisting">def square = { num -&gt;
    num * num
}
square 8</pre></div><p>This is not a regular method, but a closure. The concept of closures does not exist in the same way in Java, but it plays a significant role in Groovy and in Gradle especially.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec62"/>Closures</h2></div></div></div><p>Closures<a id="id252" class="indexterm"/> are anonymous blocks of code that can accept parameters and can return a value. They can be assigned to variables and can be passed as parameters to methods.</p><p>You can define a closure simply by adding a block of code between curly brackets, as you saw in the previous example. If you want to be a bit more explicit, you can add the type to your definition, like this:</p><div><pre class="programlisting">Closure square = {
    it * it
}
square 16</pre></div><p>Adding the <code class="literal">Closure</code> type makes it clear to everyone working with the code that a closure is being defined. The preceding example also introduces the concept of an implicit untyped argument named <code class="literal">it</code>. If you do not explicitly add a parameter to a closure, Groovy will add one automatically. This parameter is always called <code class="literal">it</code>, and you can use it in all closures. If the caller does not specify any parameters, <code class="literal">it</code> is null. This can make your code a bit more concise, but it is only useful if the closure takes just one single parameter.</p><p>In the context of <a id="id253" class="indexterm"/>Gradle, we work with closures all the time. In this book, we have been referring to closures as blocks so far. This means that, for example, the <code class="literal">android</code> block and the <code class="literal">dependencies</code> block are closures.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec63"/>Collections</h2></div></div></div><p>There are two important collection<a id="id254" class="indexterm"/> types when using Groovy in a Gradle context: lists and maps.</p><p>Creating a new list in Groovy is easy. There is no need for special initializers; you can simply create a list like this:</p><div><pre class="programlisting">List list = [1, 2, 3, 4, 5]</pre></div><p>Iterating over a list is also extremely easy. You can use the <code class="literal">each</code> method to iterate over every element in a list:</p><div><pre class="programlisting">list.each() { element -&gt;
    println element
}</pre></div><p>The <code class="literal">each</code> method enables you to access each element in the list. You can make this code even shorter by using the <code class="literal">it</code> variable that was mentioned earlier:</p><div><pre class="programlisting">list.each() {
    println it
}</pre></div><p>Another type of collection that is important in the context of Gradle is <code class="literal">Map</code>. Maps are used in several Gradle settings and methods. A map is, simply put, a list that contains key-value pairs. You can define a map like this:</p><div><pre class="programlisting">Map pizzaPrices = [margherita:10, pepperoni:12]</pre></div><p>To access specific items in a map, use the <code class="literal">get</code> method or square brackets:</p><div><pre class="programlisting">pizzaPrices.get('pepperoni')
pizzaPrices['pepperoni']</pre></div><p>Groovy has a shortcut for this functionality as well. You can use dot notation for map elements, using the key to retrieve the value:</p><div><pre class="programlisting">pizzaPrices.pepperoni</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec64"/>Groovy in Gradle</h2></div></div></div><p>Now that you know the basics of <a id="id255" class="indexterm"/>Groovy, it is an interesting exercise to go back, look at a Gradle build file, and read it. Notice that it has become easier to understand why the syntax for configuration looks the way it does. For example, look at the line where the Android plugin is applied to the build:</p><div><pre class="programlisting">apply plugin: 'com.android.application'</pre></div><p>This piece of code is full of Groovy shortcuts. If you write it out without any of the shortcuts, it looks like this:</p><div><pre class="programlisting">project.apply([plugin: 'com.android.application'])</pre></div><p>Rewriting the line without Groovy shortcuts makes it clear that <code class="literal">apply()</code> is a method of the <code class="literal">Project</code> class, which is the basic building block of every Gradle build. The <code class="literal">apply()</code> method takes one parameter, which is a <code class="literal">Map</code> with a key <code class="literal">plugin</code> and value <code class="literal">com.android.application</code>.</p><p>Another example is the <code class="literal">dependencies</code> block. Previously, we defined dependencies like this:</p><div><pre class="programlisting">dependencies {
    compile 'com.google.code.gson:gson:2.3'
}</pre></div><p>We now know that this block is a closure, passed to the <code class="literal">dependencies()</code> method on a <code class="literal">Project</code> object. This closure is passed to a <code class="literal">DependencyHandler</code>, which contains the <code class="literal">add()</code> method. That method accepts three parameters: a string defining the configuration, an object defining the dependency notation, and a closure that contains properties specifically for this dependency. When you write this out in full, it looks like this:</p><div><pre class="programlisting">project.dependencies({
    add('compile', 'com.google.code.gson:gson:2.3', {
        // Configuration statements
    })
})</pre></div><p>The build configuration files we have been looking at so far should start making a lot more sense, now that you know what it looks like behind the curtains.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>If you want to know more about the way Gradle makes use of Groovy under the hood, you can use the official documentation for <code class="literal">Project</code> as a starting point. You can find it at <a class="ulink" href="http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html">http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html</a>.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Getting started with tasks</h1></div></div></div><p>Custom Gradle tasks <a id="id256" class="indexterm"/>can significantly improve the daily life of a developer. Tasks can manipulate the existing build process, add new build steps, or influence the outputs of a build. You can perform simple tasks, such as renaming a generated APK, by hooking into the Android plugin for Gradle. Tasks also enable you to run more complex code, so you can generate images for several densities before your app is packaged, for instance. Once you know how to create your own tasks, you will find yourself empowered to change every aspect of your build process. This is especially true when you learn how to hook into the Android plugin.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec65"/>Defining tasks</h2></div></div></div><p>Tasks<a id="id257" class="indexterm"/> belong to a <code class="literal">Project</code> object, and each task implements the <code class="literal">Task</code> interface. The easiest way to define a new task is by executing the <code class="literal">task</code> method with the name of the task as its parameter:</p><div><pre class="programlisting">task hello</pre></div><p>This creates the task, but it will not do anything when you execute it. To create a task that is somewhat useful, you need to add some actions to it. A common beginner's mistake is to create tasks like this:</p><div><pre class="programlisting">task hello {
  println 'Hello, world!'
}</pre></div><p>When you execute this task, you see this output:</p><div><pre class="programlisting">
<strong>$ gradlew hello</strong>
<strong>Hello, world!</strong>
<strong>:hello</strong>
</pre></div><p>From the output, you might get the impression that this works, but, in fact, "Hello, world!" was printed out before the task was even executed. To understand what is going on here, we need to get back to the basics. In <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Gradle and Android Studio">Chapter 1</a>, <em>Getting Started with Gradle and Android Studio</em>, we talked about the lifecycle of a Gradle build. There are three phases in any Gradle build: the initialization phase, the configuration phase, and the execution phase. When you add code to a task in the same way as in the previous example, you are actually setting up the configuration of the task. Even if you were to execute a different task, the "Hello, world!" message would still show up.</p><p>If you want to add actions to a task for the execution phase, use this notation:</p><div><pre class="programlisting">task hello &lt;&lt; {
  println 'Hello, world!'
}</pre></div><p>The only difference here is the <code class="literal">&lt;&lt;</code> before the closure. This tells Gradle that the code is meant for the execution phase, and not the configuration phase.</p><p>To demonstrate the difference, consider this build file:</p><div><pre class="programlisting">task hello &lt;&lt; {
  println 'Execution'
}

hello {
  println 'Configuration'
}</pre></div><p>We define the<a id="id258" class="indexterm"/> task <code class="literal">hello</code>, which prints to the screen when it is executed. We also define code for the configuration phase of the <code class="literal">hello</code> task, which prints <code class="literal">Configuration</code> to the screen. Even though the configuration block is defined after the actual task code definition, it will still be executed first. This is the output of the preceding example:</p><div><pre class="programlisting">
<strong>$ gradlew hello</strong>
<strong>Configuration</strong>
<strong>:hello</strong>
<strong>Execution</strong>
</pre></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>Accidental use of the configuration phase resulting in failing tasks is a common mistake. Keep that in mind when you start creating your own tasks.</p></div></div><p>Because Groovy has so many shortcuts, there are several ways to define tasks in Gradle:</p><div><pre class="programlisting">task(hello) &lt;&lt; {
  println 'Hello, world!'
}

task('hello') &lt;&lt; {
  println 'Hello, world!'
}

tasks.create(name: 'hello') &lt;&lt; {
  println 'Hello, world!'
}</pre></div><p>The first two blocks are just two different ways to achieve the same thing with Groovy. You can use parentheses, but you do not need to. You do not need single quotes around the parameter either. In these two blocks, we call the <code class="literal">task()</code> method, which takes in two parameters: a string for the name of the task, and a closure. The <code class="literal">task()</code> method is a part of Gradle's <code class="literal">Project</code> class.</p><p>The last block does not use the <code class="literal">task()</code> method. Instead, it makes use of an object named <code class="literal">tasks</code>, which is an instance of <code class="literal">TaskContainer</code>, and is present in every <code class="literal">Project</code> object. This class provides a <code class="literal">create()</code> method that takes a <code class="literal">Map</code> and a closure as parameters and returns a <code class="literal">Task</code>.</p><p>It is convenient to write the<a id="id259" class="indexterm"/> short form, and most online examples and tutorials will use them. However, writing the longer form can be useful while learning. This way, Gradle will seem a lot less like magic, and it will become a lot easier to understand what is going on.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec66"/>Anatomy of a task</h2></div></div></div><p>The <code class="literal">Task</code> interface is<a id="id260" class="indexterm"/> the basis of all tasks and defines a collection of properties and methods. All of these are implemented by a class named <code class="literal">DefaultTask</code>. This is the standard task type implementation, and when you create a new task, it is based on <code class="literal">DefaultTask</code>.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>Technically speaking, <code class="literal">DefaultTask</code> is not really the class that implements all the methods in the <code class="literal">Task</code> interface. Gradle has an internal type named <code class="literal">AbstractTask</code>, that contains the implementation for all the methods. Because <code class="literal">AbstractTask</code> is internal, we cannot override it. Thus, we focus on <code class="literal">DefaultTask</code>, which derives from <code class="literal">AbstractTask</code>, and which can be overridden.</p></div></div><p>Every <code class="literal">Task</code> contains a collection of <code class="literal">Action</code> objects. When a task is executed, all of these actions are executed in a sequential order. To add actions to a task, you can use the methods <code class="literal">doFirst()</code> and <code class="literal">doLast()</code>. These methods both take a closure as a parameter, and then wrap it into an <code class="literal">Action</code> object for you.</p><p>You always need to use either <code class="literal">doFirst()</code> or <code class="literal">doLast()</code> to add code to a task if you want that code to be a part of the execution phase. The left-shift operator (<code class="literal">&lt;&lt;</code>) we used previously to define tasks is a shortcut for the <code class="literal">doFirst()</code> method.</p><p>Here is an example of the use of <code class="literal">doFirst()</code> and <code class="literal">doLast()</code>:</p><div><pre class="programlisting">task hello {
  println 'Configuration'

  doLast {
    println 'Goodbye'
  }

  doFirst {
    println 'Hello'
  }
}</pre></div><p>When you execute the <code class="literal">hello</code> task, this is the output:</p><div><pre class="programlisting">
<strong>$ gradlew hello</strong>
<strong>Configuration</strong>
<strong>:hello</strong>
<strong>Hello</strong>
<strong>Goodbye</strong>
</pre></div><p>Even though the line of code that prints "Goodbye" is defined before the line of code that prints "Hello", they<a id="id261" class="indexterm"/> end up in the correct order when the task is executed. You can even use <code class="literal">doFirst()</code> and <code class="literal">doLast()</code> multiple times, as shown in this example:</p><div><pre class="programlisting">task mindTheOrder {
  doFirst {
    println 'Not really first.'
  }

  doFirst {
    println 'First!'
  }

  doLast {
    println 'Not really last.'
  }

  doLast {
    println 'Last!'
  }
}</pre></div><p>Executing this task will return the following output:</p><div><pre class="programlisting">
<strong>$ gradlew mindTheOrder</strong>
<strong>:mindTheOrder</strong>
<strong>First!</strong>
<strong>Not really first.</strong>
<strong>Not really last.</strong>
<strong>Last!</strong>
</pre></div><p>Notice how <code class="literal">doFirst()</code> always adds an action to the very beginning of a task, and <code class="literal">doLast()</code> adds an action to the very end. This means you need to be careful when you use these methods, especially when the order is important.</p><p>When it comes to ordering tasks, you can use the <code class="literal">mustRunAfter()</code> method. This method allows you to influence how Gradle constructs the dependency graph. When you use <code class="literal">mustRunAfter()</code>, you specify that if two tasks are executed, one must always be executed before the other:</p><div><pre class="programlisting">task task1 &lt;&lt; {
    println 'task1'
}
task task2 &lt;&lt; {
    println 'task2'
}
task2.mustRunAfter task1</pre></div><p>Running both <code class="literal">task1</code> and <code class="literal">task2</code> will always result in the execution of <code class="literal">task1</code> before <code class="literal">task2</code>, regardless of the order you specify:</p><div><pre class="programlisting">
<strong>$ gradlew task2 task1</strong>
<strong>:task1</strong>
<strong>task1</strong>
<strong>:task2</strong>
<strong>task2</strong>
</pre></div><p>The <code class="literal">mustRunAfter()</code> method <a id="id262" class="indexterm"/>does not add a dependency between the tasks; it is still possible to execute <code class="literal">task2</code> without executing <code class="literal">task1</code>. If you need one task to depend on another, use the <code class="literal">dependsOn()</code> method instead. The difference between <code class="literal">mustRunAfter()</code> and <code class="literal">dependsOn()</code> is best explained with an example:</p><div><pre class="programlisting">task task1 &lt;&lt; {
    println 'task1'
}
task task2 &lt;&lt; {
    println 'task2'
}
task2.dependsOn task1</pre></div><p>This is what it looks like when you try to execute <code class="literal">task2</code> without executing <code class="literal">task1</code>:</p><div><pre class="programlisting">
<strong>$ gradlew task2</strong>
<strong>:task1</strong>
<strong>task1</strong>
<strong>:task2</strong>
<strong>task2</strong>
</pre></div><p>Using <code class="literal">mustRunAfter()</code>, <code class="literal">task1</code> is always executed before <code class="literal">task2</code> when you run them both, but both can still be executed independently. With <code class="literal">dependsOn()</code>, the execution of <code class="literal">task2</code> always triggers <code class="literal">task1</code> as well, even if it is not explicitly mentioned. This is an important distinction.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec67"/>Using a task to simplify the release process</h2></div></div></div><p>Before you can release an<a id="id263" class="indexterm"/> Android app to the Google Play store, you <a id="id264" class="indexterm"/>need to sign it with a certificate. To do this, you need to create your own keystore, which contains a set of private keys. When you have your keystore and a private key for the application, you can define the signing configuration in Gradle, like this:</p><div><pre class="programlisting">android {
    signingConfigs {
        release {
            storeFile file("release.keystore")
            storePassword "password"
            keyAlias "ReleaseKey"
            keyPassword "password"
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.release
        }
    }
}</pre></div><p>The downside of<a id="id265" class="indexterm"/> this approach is that your keystore <a id="id266" class="indexterm"/>passwords are stored in plaintext in the repository. If you are working on an open source project, this is a definite no-go; anyone with access to both the keystore file and the keystore passwords would be able to publish apps using your identity. In order to prevent this, you could create a task that asks for the release passwords every time you assemble the release package. This is a little cumbersome though, and it makes it impossible for your build server to automatically generate release builds. A good solution to store the keystore passwords is to create a configuration file that is not included in the repository.</p><p>Start by creating a file named <code class="literal">private.properties</code> in the root of the project, and add this line to it:</p><div><pre class="programlisting">release.password = thepassword</pre></div><p>We assume that the passwords for both the keystore and the key itself are the same. If you have two different passwords, it is easy to add a second property.</p><p>Once that is set up, you can define a new task named <code class="literal">getReleasePassword</code>:</p><div><pre class="programlisting">task getReleasePassword &lt;&lt; {
    def password = ''

    if (rootProject.file('private.properties').exists()) {
        Properties properties = new Properties();
        properties.load( rootProject.file('private.properties').newDataInputStream())
        password = properties.getProperty('release.password')
    }
}</pre></div><p>This task will look for a file named <code class="literal">private.properties</code> in the root of the project. If this file exists, the task will load all properties from its content. The <code class="literal">properties.load()</code> method looks for key-value pairs, such as the <code class="literal">release.password</code> we defined in the properties file.</p><p>To make sure anyone can run the script without the private properties files, or to handle the case where the properties file exists, but the password property is not present, add a fallback. If the password is still empty, ask for the password in the console:</p><div><pre class="programlisting">    if (!password?.trim()) {
        password = new String(System.console().readPassword("\nWhat's the secret password? "))
    }</pre></div><p>Checking if <a id="id267" class="indexterm"/>a string is not null or empty is a very<a id="id268" class="indexterm"/> concise process with Groovy. The question mark in <code class="literal">password?.trim()</code> does a null check and will prevent the <code class="literal">trim()</code> method from being called if it turns out <code class="literal">password</code> is null. We do not need to explicitly check for null or empty, because both null and empty strings are equal to false in the context of an if-clause.</p><p>The use of <code class="literal">new String()</code> is necessary because <code class="literal">System.readPassword()</code> returns an array of characters, which needs to be converted to a string explicitly.</p><p>Once we have the keystore passwords, we can configure the signing configuration for the release build:</p><div><pre class="programlisting">android.signingConfigs.release.storePassword = password
android.signingConfigs.release.keyPassword = password</pre></div><p>Now that we have finished our task, we need to make sure it is executed when performing a release build. To do this, add these lines to the <code class="literal">build.gradle</code> file:</p><div><pre class="programlisting">tasks.whenTaskAdded { theTask -&gt;
    if (theTask.name.equals("packageRelease")) {
        theTask.dependsOn "getReleasePassword"
    }
}</pre></div><p>This code hooks into Gradle and the Android plugin by adding a closure that needs to be run when the tasks are being added to the dependency graph. The password is not required until the <code class="literal">packageRelease</code> task is executed, so we make sure that <code class="literal">packageRelease</code> depends on our <code class="literal">getReleasePassword</code> task. The reason we cannot just use <code class="literal">packageRelease.dependsOn()</code> is that the Android plugin for Gradle generates the packaging tasks dynamically, based on the build variants. This means that the <code class="literal">packageRelease</code> task does not exist until the Android plugin has discovered all of the build variants. The discovery process is kicked off before every single build.</p><p>After adding the task and the build hook, this is the result of executing <code class="literal">gradlew assembleRelease</code>:</p><div><img src="img/B01061_07_01.jpg" alt="Using a task to simplify the release process"/></div><p>As you can see in <a id="id269" class="indexterm"/>the preceding screenshot, the <code class="literal">private.properties</code> file was not available, so the task asked for the password in the<a id="id270" class="indexterm"/> console. In this case, we also added a message explaining how to create the properties file and add the password property to make future builds easier. Once our task picked up the keystore password, Gradle was able to package our app and finish the build.</p><p>To get this task to work, it was essential to hook into Gradle and the Android plugin. This is a powerful concept, so we will explore this in detail.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Hooking into the Android plugin</h1></div></div></div><p>When developing for <a id="id271" class="indexterm"/>Android, most tasks we want to influence are related to the Android plugin. It is possible to augment the behavior of tasks by hooking into the build process. In the previous example, we already saw how to add a dependency on a custom task to include a new task in the regular build process. In this section, we will look at some possibilities for Android-specific build hooks.</p><p>One way to hook into the Android plugin is to manipulate the build variants. Doing this is quite straightforward; you just need the following code snippet to iterate over all the build variants of an app:</p><div><pre class="programlisting">android.applicationVariants.all { variant -&gt;
  // Do something
}</pre></div><p>To get the collection of <a id="id272" class="indexterm"/>build variants, you can use the <code class="literal">applicationVariants</code> object. Once you have a reference to a build variant, you can access and manipulate its properties, such as name, description, and so on. If you want to use the same logic for an Android library, use <code class="literal">libraryVariants</code> instead of <code class="literal">applicationVariants</code>.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Notice that we iterate over the build variants with <code class="literal">all()</code> instead of the <code class="literal">each()</code> method that we mentioned earlier. This is necessary because <code class="literal">each()</code> is triggered in the evaluation phase before the build variants have been created by the Android plugin. The <code class="literal">all()</code> method, on the other hand, is triggered every time a new item is added to the collection.</p></div></div><p>This hook can be used to change the name of the APK before it is saved, to add the version number to the filename. This makes it easy to maintain an archive of APKs without manually editing file names. In the next section, we will see how to accomplish that.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec68"/>Automatically renaming APKs</h2></div></div></div><p>A common use case for<a id="id273" class="indexterm"/> manipulating the build process is to rename APKs to include the version number after they are packaged. You can do this by iterating over the build variants of the app, and changing the <code class="literal">outputFile</code> property of its outputs, as demonstrated in the following code snippet:</p><div><pre class="programlisting">android.applicationVariants.all { variant -&gt;
  variant.outputs.each { output -&gt;
    def file = output.outputFile
    output.outputFile = new File(file.parent, file.name.replace(".apk", "-${variant.versionName}.apk"))
  }
}</pre></div><p>Every build variant has a collection of outputs. The output of an Android app is just an APK. The output objects each have a property of the type <code class="literal">File</code> named <code class="literal">outputFile</code>. Once you know the path of the output, you can manipulate it. In this example, we add the version name of the variant to the file name. This will result in an APK named <code class="literal">app-debug-1.0.apk</code> instead of <code class="literal">app-debug.apk</code>.</p><p>Combining the power of <a id="id274" class="indexterm"/>build hooks for the Android plugin with the simplicity of Gradle tasks opens up a world of possibilities. In the next section, we will see how to create a task for every build variant of an app.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Dynamically creating new tasks</h2></div></div></div><p>Because of the way that <a id="id275" class="indexterm"/>Gradle works and tasks are constructed, we can easily create our own tasks in the configuration phase, based on the Android build variants. To demonstrate this powerful concept, we will create a task to not just install, but also run any build variant of an Android app. The <code class="literal">install</code> task is a part of the Android plugin, but if you install an app from the command-line interface using the <code class="literal">installDebug</code> task, you will still need to start it manually when the installation is complete. The task we will create in this section will eliminate that last step.</p><p>Start by hooking into the <code class="literal">applicationVariants</code> property that we used earlier:</p><div><pre class="programlisting">android.applicationVariants.all { variant -&gt;
  if (variant.install) {
    tasks.create(name: "run${variant.name.capitalize()}", dependsOn: variant.install) {
        description "Installs the ${variant.description} and runs the main launcher activity."
      }
  }
}</pre></div><p>For every variant, we check if it has a valid <code class="literal">install</code> task. This needs to be present because the new <code class="literal">run</code> task we are creating will depend on the <code class="literal">install</code> task. Once we have verified that the <code class="literal">install</code> task is present, we create a new task, and name it based on the variant's name. We also make our new task dependent on <code class="literal">variant.install</code>. This will trigger the <code class="literal">install</code> task before our task is executed. Inside the <code class="literal">tasks.create()</code> closure, start by adding a description, which is displayed when you execute <code class="literal">gradlew tasks</code>.</p><p>Besides adding the description, we also need to add the actual task action. In this example, we want to launch the app. You can launch an app on a connected device or emulator with the <a id="id276" class="indexterm"/>
<strong>Android Debug Tool</strong> (<strong>ADB</strong>):</p><div><pre class="programlisting">
<strong>$ adb shell am start -n com.package.name/com.package.name.Activity</strong>
</pre></div><p>Gradle has a method called <code class="literal">exec()</code> that makes it possible to execute a command-line process. To make <code class="literal">exec()</code> work, we need to provide an executable that is present in the <code class="literal">PATH</code> environment variable. We also need to pass all the parameters with the <code class="literal">args</code> property, which takes a list of strings. Here is what that looks like:</p><div><pre class="programlisting">doFirst {
    exec {
        executable = 'adb'
        args = ['shell', 'am', 'start', '-n', "${variant.applicationId}/.MainActivity"]
    }
}</pre></div><p>To get the full package name, use the application ID of the build variant, which includes a suffix, if provided. There is one issue with suffixes in this case, though. Even if we add a suffix, the classpath to the activity is still the same. For example, consider this configuration:</p><div><pre class="programlisting">android {
    defaultConfig {
        applicationId 'com.gradleforandroid'
    }

    buildTypes {
        debug {
            applicationIdSuffix '.debug'
        }
   }</pre></div><p>The package <a id="id277" class="indexterm"/>name is <code class="literal">com.gradleforandroid.debug</code>, but the activity's path is still <code class="literal">com.gradleforandroid.Activity</code>. To make sure we get the right class to the activity, strip the suffix from the application ID:</p><div><pre class="programlisting">doFirst {
    def classpath = variant.applicationId
    if(variant.buildType.applicationIdSuffix) {
        classpath -= "${variant.buildType.applicationIdSuffix}"
}
    def launchClass = "${variant.applicationId}/${classpath}.MainActivity"
    exec {
        executable = 'adb'
        args = ['shell', 'am', 'start', '-n', launchClass]
    }
}</pre></div><p>First, we create a variable named <code class="literal">classpath</code>, based on the application ID. Then we find the suffix, provided by the <code class="literal">buildType.applicationIdSuffix</code> property. In Groovy, it is possible to subtract a string from another string, using the minus operator. These changes make sure running the app after installation does not fail when suffixes are used.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Creating your own plugins</h1></div></div></div><p>If you have a collection of <a id="id278" class="indexterm"/>Gradle tasks that you want to reuse in several projects, it makes sense to extract these tasks into a custom plugin. This makes it possible to reuse build logic yourself, and to share it with others.</p><p>Plugins can be written in Groovy, but also in other languages that make use of the JVM, such as Java and Scala. In fact, big parts of the Android plugin for Gradle are written in Java in combination with Groovy.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>Creating a simple plugin</h2></div></div></div><p>To extract build logic that is <a id="id279" class="indexterm"/>already stored in your build configuration file, you <a id="id280" class="indexterm"/>can create a plugin within the <code class="literal">build.gradle</code> file. This is the easiest way to get started with custom plugins.</p><p>To create a plugin, create a new class that implements the <code class="literal">Plugin</code> interface. We will use the code we wrote previously in this chapter, which dynamically creates <code class="literal">run</code> tasks. Our plugin class looks like this:</p><div><pre class="programlisting">
<strong>class RunPlugin implements Plugin&lt;Project&gt; {</strong>
  <strong>void apply(Project project) {</strong>
    <strong>project.android.applicationVariants.all</strong> { variant -&gt;
      if (variant.install) {
        <strong>project.tasks.create</strong>(name: "run${variant.name.capitalize()}", dependsOn: variant.install) {
            // Task definition
        }
      }
    }
  }
}</pre></div><p>The <code class="literal">Plugin</code> interface defines an <code class="literal">apply()</code> method. Gradle calls this method when the plugin is used in a build file. The project is passed as a parameter so that the plugin can configure the project or use its methods and properties. In the preceding example, we cannot call properties from the Android plugin directly. Instead, we need to access the project object first. Note that this requires the Android plugin to be applied to the project before our custom plugin is applied. Otherwise, <code class="literal">project.android</code> will cause an exception.</p><p>The code for the task is the same as it was earlier, except for one method call: instead of calling <code class="literal">exec()</code>, we now need to call <code class="literal">project.exec()</code>.</p><p>To make sure the<a id="id281" class="indexterm"/> plugin is <a id="id282" class="indexterm"/>applied to our build configuration, add this line to <code class="literal">build.gradle</code>:</p><div><pre class="programlisting">apply plugin: RunPlugin</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec71"/>Distributing plugins</h2></div></div></div><p>In order to<a id="id283" class="indexterm"/> distribute a plugin and share it with others, you need to move it into a standalone module (or project). A standalone plugin has its own build file to configure dependencies and means of distribution. This module produces a JAR file, containing the plugin classes and properties. You can use this JAR file to apply the plugin in several modules and projects, and to share it with others.</p><p>As with any Gradle project, create a <code class="literal">build.gradle</code> file to configure the build:</p><div><pre class="programlisting">apply plugin: 'groovy'

dependencies {
    compile gradleApi()
    compile localGroovy()
}</pre></div><p>Since we are writing the plugin in Groovy, we need to apply the Groovy plugin. The Groovy plugin extends on the Java plugin, and enables us to build and package Groovy classes. Both Groovy and plain Java are supported, so you can mix them if you like. You can even go so far as to extend a Java class using Groovy, or the other way around. This makes it easy to get started, even if you do not feel confident using Groovy for everything.</p><p>Our build configuration file contains two dependencies: <code class="literal">gradleApi()</code> and <code class="literal">localGroovy()</code>. The Gradle API is required to access Gradle namespaces from our custom plugin, and <code class="literal">localGroovy()</code> is a distribution of the Groovy SDK that comes with the Gradle installation. Gradle provides these dependencies by default for our convenience. If Gradle did not provide these dependencies out of the box, we would have to download and reference them manually.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>If you plan to distribute your plugin publically, make sure to specify the group and version information in the build configuration file, like this:</p><div><pre class="programlisting">group = 'com.gradleforandroid'
version = '1.0'</pre></div></div></div><p>To get started with the code in our standalone module, we first need to make sure to use the correct directory structure:</p><div><pre class="programlisting">plugin
└── src
    └── main
        ├── groovy
        │   └── com
        │       └── package
        │           └── name
        └── resources
            └── META-INF
                └── gradle-plugins</pre></div><p>As with any<a id="id284" class="indexterm"/> other Gradle module, we need to provide a <code class="literal">src/main</code> directory. Because this is a Groovy project, the subdirectory of <code class="literal">main</code> is called <code class="literal">groovy</code> instead of <code class="literal">java</code>. There is another subdirectory of <code class="literal">main</code> called <code class="literal">resources</code>, which we will use to specify our plugin's properties.</p><p>We create a file called <code class="literal">RunPlugin.groovy</code> in the package directory, where we define the class for our plugin:</p><div><pre class="programlisting">package com.gradleforandroid

import org.gradle.api.Project
import org.gradle.api.Plugin

class RunPlugin implements Plugin&lt;Project&gt; {
    void apply(Project project) {
        project.android.applicationVariants.all { variant -&gt;
            // Task code
        }
    }
}</pre></div><p>In order for Gradle to be able to find the plugin, we need to provide a properties file. Add this properties file to the <code class="literal">src/main/resources/META-INF/gradle-plugins/</code> directory. The name of the file needs to match the ID of our plugin. For the <code class="literal">RunPlugin</code>, the file is named <code class="literal">com.gradleforandroid.run.properties</code>, and this is its content:</p><div><pre class="programlisting">implementation-class=com.gradleforandroid.RunPlugin</pre></div><p>The only thing that the properties file contains is the package and name of the class that implements the <code class="literal">Plugin</code> interface.</p><p>When the plugin and the properties file are ready, we can build the plugin using the <code class="literal">gradlew assemble</code> command. This creates a JAR file in the build output directory. If you want to push the plugin to a Maven repository instead, you first need to apply the Maven plugin:</p><div><pre class="programlisting">apply plugin: 'maven'</pre></div><p>Next, you need to configure the <code class="literal">uploadArchives</code> task, like this:</p><div><pre class="programlisting">uploadArchives {
    repositories {
        mavenDeployer {
          repository(url: uri('repository_url'))
}
    }
}</pre></div><p>The <code class="literal">uploadArchives</code> task is a predefined task. Once you configure a repository on the task, you<a id="id285" class="indexterm"/> can execute it to publish your plugin. We will not cover how to set up a Maven repository in this book.</p><p>If you want to make your plugin publically available, consider publishing it to <a id="id286" class="indexterm"/>Gradleware's plugin portal (<a class="ulink" href="https://plugins.gradle.org">https://plugins.gradle.org</a>). The plugin portal has a great collection of Gradle plugins (not just specific to Android development) and is the place to go when you want to extend Gradle's default behavior. You can find information on how to publish a plugin<a id="id287" class="indexterm"/> in the documentation at <a class="ulink" href="https://plugins.gradle.org/docs/submit">https://plugins.gradle.org/docs/submit</a>.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>Writing tests for custom plugins is not covered in this book, but is highly recommended if you plan to make your plugins publically available. You can find more information on writing tests for plugins in the Gradle user guide at <a class="ulink" href="https://gradle.org/docs/current/userguide/custom_plugins.html#N16CE1">https://gradle.org/docs/current/userguide/custom_plugins.html#N16CE1</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Using a custom plugin</h2></div></div></div><p>To use a plugin, we need to add it<a id="id288" class="indexterm"/> as a dependency to the <code class="literal">buildscript</code> block. First, we need <a id="id289" class="indexterm"/>to configure a new repository. The configuration of the repository depends on the way that the plugin is distributed. Second, we need to configure the classpath of the plugin in the <code class="literal">dependencies</code> block.</p><p>If we want to include the JAR file that we created in the earlier example, we can define a <code class="literal">flatDir</code> repository:</p><div><pre class="programlisting">buildscript {
    repositories {
        flatDir { dirs 'build_libs' }
    }
    dependencies {
        classpath 'com.gradleforandroid:plugin'
    }
}</pre></div><p>If we had uploaded the plugin to a Maven or Ivy repository, this would look a little different. We covered dependency management already in <a class="link" href="ch03.html" title="Chapter 3. Managing Dependencies">Chapter 3</a>, <em>Managing Dependencies</em>, so we will <a id="id290" class="indexterm"/>not repeat the different options here.</p><p>After we set up the <a id="id291" class="indexterm"/>dependency, we need to apply the plugin:</p><div><pre class="programlisting">apply plugin: com.gradleforandroid.RunPlugin</pre></div><p>When using the <code class="literal">apply()</code> method, Gradle creates an instance of the plugin class, and executes the plugin's own <code class="literal">apply()</code> method.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we discovered how Groovy is different from Java, and how Groovy is used in Gradle. We saw how to create our own tasks and how to hook into the Android plugin, giving us a lot of power to manipulate the build process or dynamically add our own tasks.</p><p>In the last part of the chapter, we looked at creating plugins and ensured that we can reuse them in several projects by creating a standalone plugin. There is much more to learn about plugins, but unfortunately, we cannot cover it all in this book. Luckily, the Gradle user guide has a thorough description of all the possibilities at <a class="ulink" href="https://gradle.org/docs/current/userguide/custom_plugins.html">https://gradle.org/docs/current/userguide/custom_plugins.html</a>.</p><p>In the next chapter, we will talk about the importance of continuous integration (CI). With a good CI system in place, we can build, test, and deploy apps and libraries with one click. Continuous integration is thus an important part of build automation in general.</p></div></body></html>