# *第一章*: iOS 14 的新功能是什么？

在 2020 年的 WWDC 上，苹果介绍了 iOS 14 中包含的新功能和改进。使用您应用的最新功能可以在用户参与度、正面评价和整体用户体验方面为用户带来巨大差异。它还可以带来其他好处，例如在 App Store 中被苹果推荐，以及在同类竞品应用中具有优势。

苹果于 2020 年 3 月 24 日发布了 Swift 5.2，供开发者使用。同年晚些时候，苹果发布了 Swift 5.3。这些版本侧重于质量、性能改进，新语言特性，以及增加对 Windows 平台和 Linux 发行版的支持。

在 2020 年的 WWDC 上还有另一个重大公告：苹果硅。苹果向世界推出了自己的处理器。开发者可以从 2020 年底开始构建应用并发布它们，这将开启一个为期两年的过渡。这个过渡将在所有苹果产品中建立统一的架构。有了统一的架构，将更容易为整个苹果生态系统创建应用。

在本章中，你将学习 iOS 14 中两个最重要的新功能的基础：App Clips 和小部件。我们还将介绍增强现实、机器学习和用户隐私的最新更新。在本章结束时，你将通过一些代码示例了解 Swift 语言的最新更新。

在本章中，我们将介绍 iOS 14、Swift 5.2 和 Swift 5.3 的以下主要主题：

+   介绍 App Clips

+   介绍 WidgetKit

+   增强现实改进

+   机器学习改进

+   用户隐私改进

+   介绍 Swift 5.2

+   介绍 Swift 5.3

# 技术要求

本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New).

如果你想在阅读本章时尝试 Swift 5.2 的功能，你需要安装 Xcode 版本 11.4 或更高版本：[https://itunes.apple.com/app/xcode/id497799835](https://itunes.apple.com/app/xcode/id497799835).

# 介绍 App Clips

**App Clips** 允许用户以快速和轻量级的方式发现您的应用。使用 App Clips，用户可以快速使用您应用的功能，即使没有在他们的手机上安装该应用。让我们看看一个 App Clip 的例子：

![图 1.1 − App Clip UI

](img/Figure_1.01_B14717.jpg)

图 1.1 − App Clip UI

App Clips 应该轻量级、简洁，并在几秒钟内完成用户任务。让我们看看一些 App Clips 的用例：

+   当你经过咖啡店门口并点击 NFC 标签时，可以订购咖啡的 App Clip。

+   通过扫描停在街上的电动自行车上的二维码，即可租用该电动自行车。此外，您还可以使用 Apple 登录和 Apple Pay 来避免填写表格和界面复杂性，让您能在几秒钟内租用自行车。

+   一个 App Clip，可以预先从餐厅菜单中订购，并在等待就座时节省时间。

+   当你在艺术画廊或博物馆的 NFC 点周围轻触时触发的 App Clip，并在你的 iPhone 上显示增强现实场景。

如您所见，App Clips 的可能性是无限的。现在我们已经介绍了什么是 App Clip，我们将解释用户使用 App Clip 的旅程（从调用到结束）。我们将涵盖调用方法（如何触发 App Clip 出现）。最后，我们将探讨构建 App Clip 时推荐的指南。

## App Clip 用户旅程

现在我们将更详细地探索整个过程和步骤，从用户发现您的 App Clip 到用户完成 App Clip 之旅。

让我们想象一下，我们有一个在街头租用电动自行车的应用。App Clip 流程涉及几个阶段：

![Figure 1.2 − App Clip 流程和步骤

![img/Figure_1.02_B14717.jpg]

图 1.2 − App Clip 流程和步骤

AppClip 的步骤如下：

1.  **调用方法**：App Clip 调用方法是用户如何触发和打开 App Clip 的方式。以我们电动自行车租赁的例子，用户使用设备摄像头扫描放置在自行车上的二维码，App Clip 就会在主屏幕上打开。在这种情况下，调用方法是二维码。我们将在本章后面进一步探讨更多调用方法。

1.  **用户旅程**：在调用后，App Clip 会向用户展示一些选项供其选择（例如，1 小时租赁费用为 2 美元，24 小时租赁费用为 5 美元）。用户在 App Clip 内进行所需的选择。

1.  **账户和支付**：在我们的自行车租赁示例中，我们的 App Clip 需要识别哪个用户在租用自行车，并且用户需要为服务付费。一些 App Clip 可能不需要注册用户账户或支付即可工作；这一步是可选的。

1.  **完整应用推荐**：当自行车租赁完成并准备就绪时，您的 App Clip 可以推荐用户下载您的完整应用，这样用户下次就可以使用完整应用而不是 App Clip。建议整个应用是一个可选步骤，但非常推荐。

现在我们已经概述了 App Clip 的高级别步骤，让我们更详细地回顾一些部分。

## App Clip 调用方法

我们已经看到，为了显示 App Clip，用户需要调用它或发现它。我们之前讨论过，它可以通过二维码、NFC 标签或消息中的链接来调用。以下是可用选项的总结：

+   App Clip 代码：每个 App Clip 代码都包含一个二维码和一个 NFC 标签，以便用户可以使用他们的摄像头扫描它或轻触它。它也适用于单个 NFC 标签和二维码。

+   Safari应用横幅

+   消息中的链接

+   在地图中放置卡片

+   iOS 14新应用库中最近使用的App Clips类别

让我们讨论一下苹果在设计和开发您的App Clip时推荐的指南。

## App Clips指南

为了使App Clips对用户来说有效、轻量且易于使用，苹果有几项指南：

+   专注于您应用的核心任务：假设您有一个拥有许多不同功能的咖啡店应用，包括允许用户收集积分、订购咖啡、保存用户偏好、购买咖啡礼品卡等。您的应用不应一次性显示如此庞大的功能集。App Clip应仅提供最重要的任务（在本例中，仅为订购咖啡的功能）。如果用户需要更多功能，他们可以下载完整的应用。

+   App Clips应该从开始到结束整个过程都快速且易于使用。避免使用复杂的用户界面、过多的菜单、详细视图和其他可能导致用户花费过多时间的元素。

+   App Clips应该体积小，下载速度快。在App Clip内包含所有必要的资产，但避免大文件下载。

+   在您的App Clip中避免复杂的用户账户创建过程。只需“**使用Apple登录**”。

+   避免要求用户输入复杂且易出错的信用卡表单和详细信息。当需要时，尝试使用Apple Pay。

+   当用户完成App Clip任务后，他们无法返回。您的App Clip可以建议用户安装完整的应用以保持用户后续的参与度。但要以非侵入性和礼貌的方式进行，例如，在用户旅程结束后，不要使其成为强制性的。

+   App Clips提供在启动后8小时内发送或安排通知的选项，以满足任何所需任务。但不建议将此功能用于纯粹的市场营销目的。

在本节中，您已经了解了什么是App Clip，用户在使用它时会经历什么样的旅程，不同的调用方法，以及构建您的App Clip时推荐的指南。在[*第14章*](B14717_14_Final_ASB_ePub.xhtml#_idTextAnchor457)，“为您的应用创建App Clip”，我们将为现有应用创建一个App Clip，以查看一个实际示例。

现在，让我们跳转到iOS 14带来的另一个令人兴奋的新功能：WidgetKit。

# 介绍WidgetKit

用户和开发者已经多年以来一直在请求一个特定的功能：他们所有人都希望能够在他们的主屏幕上拥有小部件。小部件允许用户从主屏幕配置、个性化并消费相关数据的片段。它们还允许开发者向用户提供可快速查看的内容，并为他们的应用创造附加价值。

下面是**小部件**（在这种情况下是日历和提醒小部件）在iPhone主屏幕上的预览：

![Figure 1.3 − iOS Home screen with Widgets]

![img/Figure_1.03_B14717.jpg]

图1.3 − 带有小部件的iOS主屏幕

现在，在 iOS 14、macOS 11 及更高版本上，这是可能的。开发者可以使用 **WidgetKit** 和 SwiftUI 的新 **小部件 API** 在 iOS、iPadOS 和 macOS 上创建小部件。

iOS 14 中的 **智能堆叠** 包含一组不同的小部件，包括用户经常打开的小部件。如果用户启用了 **智能旋转**，Siri 可以突出显示自定义堆叠中的相关小部件。

在 iOS 13 及更早版本上创建的小部件

在 iOS 14 或 macOS 11 上创建的小部件不能放置在主屏幕上，但它们仍然可在 Today View 和 macOS 通知中心中查看。

在介绍完新小部件之后，让我们看看在构建小部件时有哪些选项，并查看苹果的设计指南。

## 小部件选项

用户可以在 iOS 的主屏幕或 Today View 上，或在 iPad 的 Today View 和 macOS 的通知中心上放置小部件。

小部件有三种尺寸：小、中、大。每种尺寸应有不同的用途。这意味着一个更大尺寸的小部件不应该只是小尺寸的字体和图像更大，而应该包含更多信息。例如，天气小部件在小尺寸版本中只提供当前温度，但在中尺寸版本中还会包括一周的天气预报。

用户可以在屏幕的不同部分排列小部件，甚至创建堆叠小部件来分组它们。

为了开发小部件，开发者需要为他们的应用创建一个新的扩展：一个**小部件扩展**。他们可以使用时间线提供者来配置小部件。时间线提供者在需要时更新小部件信息。

如果小部件需要一些配置（例如，在天气应用中选择默认城市，或在大型天气小部件中显示多个城市），开发者应在小部件扩展中添加自定义 Siri 意图。这样做会自动为用户的小部件提供定制界面。

## 小部件指南

当为 iOS 14 或 macOS 11 创建小部件时，请考虑以下设计指南：

+   将你的小部件聚焦于你应用的功能。如果你的应用是关于股市的，你的小部件可以显示用户的投资组合总价值。

+   每种尺寸的小部件应显示不同数量的信息。如果你的骑行追踪小部件在小尺寸小部件中显示当天燃烧的卡路里，它也可以在中尺寸小部件中显示一周内每天的卡路里，并在大尺寸小部件中添加额外的信息，如行驶的公里数/英里数。

+   更倾向于动态信息，这些信息在一天中会变化，而不是固定信息；这将使你的小部件对用户更具吸引力。

+   相比于配置选项更多的复杂小部件，更倾向于简单的小部件，配置选项较少。

+   小部件提供点击目标和检测功能，允许用户选择并点击它们以在应用中打开详细信息。小型小部件支持单个点击目标，中型和大型小部件支持多个目标。尽量保持简单。

+   支持暗黑模式。同时，考虑使用 SF Pro 作为字体，如果需要，使用 SF Symbols。

在本节中，我们介绍了新的小部件和 WidgetKit。我们涵盖了构建小部件时可用选项和设计指南。在下一节中，我们将介绍 iOS 14 中增强现实的新改进和新增功能。

# 增强现实改进

在 iOS 14 和 iPadOS 14 的新 ARKit 4 中，有四个主要的新特性：

+   **位置锚点** 允许开发者将 AR 场景放置在地理坐标上。位置锚点使用户能够在全球特定位置、地标和地点显示这些 AR 体验。

+   **扩展人脸** 跟踪支持允许通过具有 A12 Bionic 芯片或更高版本的设备的正面摄像头访问 AR 体验。

+   **RealityKit** 将使开发者能够将视频纹理添加到 AR 场景或 AR 对象的任何部分。视频纹理还包括空间化音频。

+   `ARView` – `环境` 对象。场景理解包含四个选项：**遮挡**，其中现实世界对象遮挡虚拟对象；**接收光照**，允许虚拟对象在现实世界对象上投下阴影；**物理**，使虚拟对象能够以物理方式与真实世界交互；以及 **碰撞**，使虚拟对象与现实世界对象之间发生碰撞。

    注意

    激活 **接收光照** 选项会自动开启 **遮挡**。激活 **物理** 选项会自动开启 **碰撞**。

在本节中，我们看到了增强现实的改进。现在让我们回顾一下机器学习中的新内容。

# 机器学习改进

WWDC2020 期间展示的 Core ML 改进将帮助开发者开发他们的机器学习应用，通过改进升级您的应用模型，确保它们的安全，并将它们分组到定向集合中。在本节中，我们将介绍新的 Core ML 模型部署，新的具有定向部署的模型集合，以及新的模型加密。

## Core ML 模型部署、集合和定向部署

WWDC 2020 为 Core ML 引入的最显著特性之一是来自云端的 `mlmodel` 文件。

开发者将能够在云上创建**机器学习模型集合**并使用 CloudKit 更新它们。应用将下载这些集合并保持更新，中间没有版本升级过程。然而，开发者不控制下载过程。应用将检测到有新的模型版本可用，并在系统决定合适的时机（例如，在手机锁定且在 Wi-Fi 连接下充电的背景中）下载它。因此，开发者应该考虑到模型更新可能或可能不会快速或实时。操作系统将拥有最终决定权。

模型集合的一个有用特性是它们可以被针对不同的用户（例如，在具有不同能力的设备上的用户，如 iPhone 与 iPad）。可以通过对集合应用**定向部署**来为不同的用户分配不同的模型。有六个选项可用于配置和针对设备将要部署的模型：语言代码、设备类别、操作系统、操作系统版本、区域代码和应用程序版本。

## 模型加密

从 iOS 14 和 macOS 11 开始，Core ML 可以自动加密 Core ML 模型。

Xcode 将加密编译后的模型，`mlmodelc`（而不是原始的 `mlmodel`）。解密发生在应用实例化时，并在设备上发生。此外，解密结果不会存储在任何地方；它只是加载到内存中。

关于这个好消息：Xcode 将帮助你创建加密密钥，将其与你的开发者账户关联，并且它将自动存储在苹果服务器上。你可以随时下载一个本地副本，但这个过程并不流畅。

当加密密钥存储在苹果服务器上时，文件是 `.mlmodelkey`。当你想加密你的模型时，你只需将 `--encrypt {YourModel}.mlmodelkey` 添加到编译器标志中。如果你更喜欢使用 CloudKit，你只需在创建模型存档时提供加密密钥。

这个过程的缺点是：当应用实例化时，它需要与苹果服务器建立互联网连接来下载加密密钥并解密你的模型。如果由于任何原因没有连接，你需要在新的 `{YourModel}.load()` 方法的完成错误中实现你的回退流程。如果加密密钥不可用，完成处理程序将抛出 `modelKeyFetch` 错误，你可以相应地采取行动。

重要提示

你不应该在你的应用包中包含加密密钥。这并不是必要的，而且可能会危及你的数据。

在本节中，我们发现了如何在不更新我们的app的情况下升级我们的机器学习模型，如何将模型分组到集合中并将它们分配给不同类型的用户/设备，以及如何通过加密我们的模型并无需努力来保护我们的机器学习数据。在下一节中，我们将介绍对用户隐私的改进。

# 用户隐私改进

在iOS 14中，苹果以不同的方式让用户对他们的隐私和个人数据有更多的控制：

+   应用商店将显示每个app的隐私实践，因此用户在下载app之前可以检查它们。

+   当一个应用使用相机或麦克风时，手机右上角会出现一个指示器来表示。控制中心会记录最近使用过这些功能的app。

+   应用可以提供用户保留他们已有的账户，但将其与**使用Apple ID登录**集成。

+   **近似位置**是针对位置服务的新选项，为那些不需要精确位置的应用提供更不准确的位置。

+   限制照片库访问：用户现在可以仅授予对所选照片的访问权限，而不是整个库。

在iOS的每个新版本中，苹果都在给用户和开发者提供越来越多的隐私设置控制权。在本节中，我们看到了新的改进，这些改进使得用户的位置和照片更加私密，改进了让用户知道应用何时使用相机或麦克风的机制，以及在应用商店页面上添加了关于应用使用数据和隐私的额外信息。下一节将重点介绍Swift 5.2在语言中引入的变化。

# 介绍Swift 5.2

由苹果（2020年3月24日推出）引入的Swift 5.2具有针对改进开发者体验和提供额外语言特性的实用功能。一些新的语言特性似乎旨在增强函数式编程风格。让我们通过一些代码示例来回顾这些新特性。

## 键路径表达式作为函数

这个新功能允许开发者使用键路径表达式，如`\Root.value`，在允许`(Root) -> Value`函数的任何地方使用。让我们看看它是如何工作的。

让我们创建一个具有两个属性`brand`和`isElectric`的`Car`结构体：

[PRE0]

然后，让我们实例化一个包含两辆车的`Car`结构体数组，一辆是电动汽车，另一辆不是：

[PRE1]

现在，如果我们想过滤这个`cars`数组并只获取其中的电动汽车，我们过去是这样做的：

[PRE2]

我们也可以这样做：

[PRE3]

现在，随着Swift 5.2的推出，我们能够更简洁地做到这一点：

[PRE4]

如果你打印结果，你会看到输出是相同的：

[PRE5]

输出如下：

[PRE6]

注意，这适用于更多的情况，例如`map`、`compactMap`以及允许`(Root) -> Value`函数的任何地方。

**SE-0249** 提案包含了这次变化背后的所有细节。对于额外的参考和提案背后的动机，你可以查看原始文档[https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md](https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md)。

## 用户定义名义类型的可调用值

这个新特性允许具有以`callAsFunction`为基本名称的方法的值像函数一样被调用。

用一个简单的例子更容易解释这个概念。让我们创建一个名为`MyPow`的结构体，帮助我们计算给定基数的一个数的幂：

[PRE7]

现在，我们可以通过以下方式计算`base`的`pow`：

[PRE8]

此`print`语句将产生以下结果：

[PRE9]

现在，使用Swift 5.2，我们可以计算基数的`pow`，但使用这种方法：

[PRE10]

这导致了相同的输出：

[PRE11]

Swift **SE-0253** 提案文档包含了这次变化背后的所有细节。对于额外的参考和提案背后的动机，你可以查看原始文档[https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md](https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md)。

## 下标现在可以声明默认参数

当声明下标时，我们现在可以为参数分配一个默认值。

让我们用一个例子来看看它的实际效果。我们创建一个名为`Building`的结构体，它包含一个表示楼层名称的`String`数组。我们添加一个下标来获取给定索引的楼层名称。如果索引不存在，我们希望获取默认值，`Unknown`：

[PRE12]

我们可以在以下输出中看到，当我们使用`building[0]`访问索引`0`时，我们返回值`Ground Floor`：

[PRE13]

控制台输出如下：

[PRE14]

在以下场景中，当我们使用`building[5]`访问索引`5`时，我们返回值`Unknown`：

[PRE15]

控制台输出如下：

[PRE16]

此代码示例展示了在使用下标时如何使用默认参数，以及它如何有助于处理边缘情况。

## 懒过滤顺序现在已反转

当与懒数组一起使用过滤时，对过滤链中应用的运算顺序有新的变化。请看以下代码：

[PRE17]

在Swift 5.2中，此代码将打印以下内容：

[PRE18]

这是因为`.filter { $0 % 2 == 0 }`语句是在`.filter { print($0); return true }`语句之前应用的。

然而，如果我们在这个5.2之前的Swift版本中执行此代码，我们会注意到顺序是相反的。首先，我们将打印所有数字；然后，我们将过滤并只获取偶数。`.filter`语句将从下到上执行。

如果我们从代码中移除`.lazy`，这种行为将再次改变。然后，无论Swift版本如何，我们都会看到输出仅为`2`和`4`。过滤器将按预期从上到下应用。

重要提示

这种变化可能会破坏您的代码和应用程序的逻辑。确保在将代码更新到Swift 5.2或更高版本时，审查任何类似的场景。

## 新增和改进的诊断

在Swift 5.2中，错误信息在质量和精度上都有所提高。在之前的版本中，编译器试图通过将表达式分解成更小的部分来猜测错误的精确位置。但这种方法遗漏了一些错误。

现在当编译器在尝试推断类型时遇到失败，它会记录这些元素的位置。这些记录允许编译器在需要时检测到确切的错误。

让我们看看在Swift 5.1和Swift 5.2中编译的例子，以及每个版本上的输出。看看这个包含错误的代码：

[PRE19]

在Swift 5.2中，我们可以在错误发生的确切位置得到一个清晰的错误，并且有准确的原因：

[PRE20]

如您所见，编译器告诉我们我们正在尝试使用一个不存在的枚举成员，`c`。

如果我们尝试在Swift 5.1中编译相同的代码，我们将看到不同的（并且是错误的）错误信息：

[PRE21]

编译器错误改进使得iOS开发者日常调试变得更加舒适。

在本节中，您已经了解了语言最新的添加内容以及Swift 5.2上的改进诊断，并伴随着代码示例。现在，让我们跳转到Swift 5.3的特性。

# 介绍Swift 5.3

由苹果在2020年引入，Swift 5.3的主要目标是提升质量和性能，并通过添加对Windows和额外的Linux发行版的支持来扩展Swift可用的平台数量。

现在，让我们回顾一些新的语言特性。

## 多模式`catch`子句

使用这个新特性，Swift将允许在`do catch`子句内部有多个错误处理块。看看下面的例子。

假设我们有一个`performTask()`函数，它可以抛出不同类型的`TaskError`错误：

[PRE22]

在Swift 5.3之前，如果我们想在`do catch`块内部处理不同的`TaskError`情况，我们需要在`catch`子句中添加一个`switch`语句，这使得代码变得复杂，如下所示：

[PRE23]

现在Swift 5.3允许我们定义多个`catch`块，这样我们可以使我们的代码更易读，如下面的例子所示：

[PRE24]

我们不再需要在`catch`块内部使用`switch`。

## 多个尾随闭包

从Swift开始，它就支持尾随闭包语法。看看使用`UIView.animate`方法时的经典例子：

[PRE25]

在这里，我们能够将尾随闭包语法应用到`completion`块中，通过从括号中提取`completion`并移除其标签，使我们的代码更短、更易读：

[PRE26]

这种闭包语法也有一些副作用。如果开发者不习惯我们的方法，它可能会使我们的代码难以阅读（想想我们自己的 API 库，它不像 UIKit 方法那样广为人知）。它也使代码显得有些无结构。

在 Swift 5.3 中，当我们同一个方法中有多个闭包时，我们现在可以在第一个未标记参数之后提取并标记所有这些闭包：

[PRE27]

注意现在我们有了括号外的两个闭包，`UIView.animate(withDuration: 0.3)`。也请注意，标记 `completion` 方法使它更容易理解，并且代码在结构上现在看起来更加对称，所有闭包都以相同的方式编写。

## 为枚举类型合成的可比较遵从

Swift 5.3 允许没有关联值或只有 `Comparable` 值的 `enum` 类型有资格进行合成遵从。让我们看看一个例子。在 Swift 5.3 之前，如果我们想要比较 `enum` 的值，我们需要遵从 `Comparable`，并且需要实现 `<` 和 `minimum` 方法（以及其他实现此目的的方法）：

[PRE28]

这段代码难以维护；一旦我们向 `enum` 添加更多值，我们就需要一次又一次地更新方法。

在 Swift 5.3 中，只要枚举没有关联值或者它只有 `Comparable` 关联值，实现就会为我们合成。查看以下例子，我们定义了一个名为 `Size` 的枚举，并且我们能够对 `Size` 实例的数组进行排序（无需进一步实现 `Comparable` 方法）：

[PRE29]

如果我们使用 `print(sizes.sorted())` 打印数组，我们将在控制台得到以下内容：

[PRE30]

注意排序的顺序与定义我们的情况的顺序相同，假设它是递增顺序：当我们排序值时，`.small` 出现在 `.large` 之前。对于包含关联值（如 `.small(Int)` 和 `.large(Int)`) 的相同情况的实例，我们在排序时应用相同的原则：`.small(1)` 出现在 `.small(2)` 之前。

## 当不太可能发生引用循环时，增加逃逸闭包中隐式 `self` 的可用性

有时候，强制所有逃逸闭包中的 `self` 使用都是显式的规则增加了样板代码。一个例子是当我们在一个 `Struct` 中使用闭包时（在这种情况下，引用循环不太可能发生）。在 Swift 5.3 的这个新变化中，我们可以省略 `self`，就像下面的例子一样：

[PRE31]

当需要时，还有一种新的方式在捕获列表中使用 `self`（只需添加 `[self] in`），这样我们就可以避免在闭包内部反复使用 `self`。请看以下例子：

[PRE32]

这个变化减少了在许多情况下使用 `self`，并在不需要时完全省略它。

## 基于类型的程序入口点 – @main

到目前为止，在开发 Swift 程序（如终端应用程序）时，我们需要在 `main.swift` 文件中定义程序的启动点。现在我们能够在一个结构体或基类（在任何文件中）上标记 `@main` 并定义一个 `static func main()` 方法，程序启动时它将被自动触发：

[PRE33]

重要提示

考虑以下关于 `@main` 的内容：如果已经存在 `main.swift` 文件，则不应使用它；它应在基类（或结构体）中使用，并且只能定义一次。

## 在上下文泛型声明中使用 where 子句

我们可以在具有泛型类型和扩展的函数中使用 `where` 子句。例如，看看以下代码：

[PRE34]

我们将这个 `Stack` 结构体扩展中的 `sorted()` 方法限制为 `Comparable` 元素。

## 枚举案例作为协议见证

这个提案旨在取消一个现有的限制，即枚举案例不能参与协议见证匹配。这在将枚举符合协议要求时引起了问题。请看以下定义 `maxValue` 变量的协议示例：

[PRE35]

我们可以这样使 `Int` 符合 `Maximizable`：

[PRE36]

但如果我们尝试用枚举做同样的事情，我们会遇到编译问题。现在可以这样做：

[PRE37]

此代码现在可以与 Swift 5.3 正确编译。

## 精炼 didSet 语义

根据 Swift 提案，这是一个非常直接的变化：

+   如果 `didSet` 观察者在其主体中不引用 `oldValue`，则将跳过获取 `oldValue` 的调用。我们称这种 `didSet` 为“简单”的 `didSet`。

+   如果我们有一个“简单”的 `didSet` 而没有 `willSet`，那么我们可以允许修改就地发生。

## Float16

Float16 已添加到标准库中。Float16 是一个半精度（16b）浮点值类型。在 Swift 5.3 之前，我们有 Float32、Float64 和 Float80。

在本节中，你通过代码示例学习了 Swift 5.3 中语言的新增功能。现在，让我们以本章总结结束。

# 摘要

在本章中，我们涵盖了 iOS 14、Swift 5.2 和 Swift 5.3 的新功能。我们首先介绍了 App Clips 以及它们为 iOS 和 macOS 带来的惊人可能性。我们列出了一些现实世界的例子，并学习了调用它们的不同方式。我们研究了设计指南，并通过使用 Apple 登录和 Apple Pay 简化了流程。后来，我们跳入了 WidgetKit 中的小部件。我们描述了如何创建三种不同大小的小部件，并研究了它们的设计指南。我们发现了增强现实和机器学习的新功能和改进。隐私也得到了一些更新，允许最终用户更详细地控制他们分享的内容。最后，我们还学习了 Swift 5.2 和 Swift 5.3 的新语言功能。

在我们的下一章中，我们将探讨 iOS 14 的深色模式，涵盖你需要了解的所有内容，并将其付诸实践。

# 进一步阅读

+   苹果人机界面指南（App Clips）: [https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)

+   苹果人机界面指南（小部件）: [https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/](https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/)
