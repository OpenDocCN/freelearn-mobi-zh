<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Getting Around – Pathfinding and AI</h1></div></div></div><p>
<em>In the previous chapter, we learned about camera and lighting effects. We added a skybox, lights, and shadows to our Tank Battle game. We created lightmaps to make our scene dynamic. We took a look at cookies by giving our tank headlights. We also took a look at projectors by creating a blob shadow for the tank. A turbo boost was also created for the tank. By adjusting the viewing angle of the camera, we were able to make the tank look as if it is going much faster than it really is. When we finished, we had a dynamic and exciting-looking scene.</em>
</p><p>
<em>This chapter is all about the enemy. No longer will the player be able to just sit in one place to gather points. We will be adding an enemy tank to the game. By using Unity's NavMesh system, the tank will be able to do pathfinding and chase the player. Once found, the tanks will shoot and reduce the player's score.</em>
</p><p>In this chapter, we will be covering the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">NavMesh</li><li class="listitem" style="list-style-type: disc">NaveMeshAgent</li><li class="listitem" style="list-style-type: disc">Pathfinding</li><li class="listitem" style="list-style-type: disc">Chase and attack AI</li><li class="listitem" style="list-style-type: disc">Spawn points</li></ul></div><p>We will be adding modifications to the Tank Battle game from <a class="link" href="ch04.html" title="Chapter 4. Setting the Stage – Camera Effects and Lighting">Chapter 4</a>, <em>Setting the Stage – Camera Effects and Lighting</em>, so open it up and we can begin.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec70"/>Understanding AI and pathfinding</h1></div></div></div><p>
<strong>AI</strong> is, as you might have guessed, <strong>artificial intelligence</strong>. In the broadest sense<a id="id353" class="indexterm"/> this is anything an inanimate object might do to appear to be making decisions. You are probably most familiar with this concept from video games. When a character, not controlled by the player, selects a weapon to use and a target to use it on, this is AI.</p><p>In its most complex form, AI attempts to mimic full human intelligence. However, there is still far too much happening incredibly fast for this to truly succeed. Video games do not need to reach nearly this far. We are primarily concerned with making our characters appear intelligent, but still conquerable by our players. Usually, this means not allowing characters to act on more information than a real player might have. Adjusting how much information characters have and can act on is a good way to adjust the level of difficulty in a game.</p><p>
<strong>Pathfinding</strong> is a subset of AI. We<a id="id354" class="indexterm"/> use it all the time, though you have probably never realized it. Pathfinding is, as the word suggests, the act of finding a path. Every time<a id="id355" class="indexterm"/> you need to find your way between any two points, you are doing pathfinding. As far as our characters are concerned, the simplest form of pathfinding is to follow a straight line to the goal point. Obviously, this method works best on an open plain, but tends to fail when there are any obstacles in the way. Another method is to overlay the game with a grid. Using the grid, we can find a path that goes around any obstacles and reaches our target.</p><p>An alternative method of pathfinding, and perhaps the one most often chosen, makes use of a special navigation mesh, or NavMesh. This is just a special model that is never seen by the player but covers all of the area that a computer character can move around in. It is then navigated in a similar way to the grid, the difference being that the triangles of the mesh are used rather than the squares of the grid. This is the method we will be using in Unity. Unity provides a nice set of tools for creating the NavMesh and utilizing it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec71"/>The NavMesh</h1></div></div></div><p>Creating the navigation mesh in Unity is very simple. The process is similar to the one we used for making lightmaps. We just mark some meshes to be used,<a id="id356" class="indexterm"/> adjust some settings in a special window, and hit a button. So, load up the Tank Battle game in Unity, if you haven't already done so, and we can get started.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec72"/>Time for action – creating the NavMesh</h1></div></div></div><p>Unity can automatically <a id="id357" class="indexterm"/>generate a NavMesh from any meshes that exist in a scene. To do so, the mesh must first be marked as static, just as we did for lightmaps. However, we do not want or need to be able to navigate the roofs of our city, so we make use of a special <a id="id358" class="indexterm"/>list of settings for dictating what type of static each object will be:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the city from the <strong>Hierarchy</strong> window and click on the down arrow to the right of <strong>Static</strong> in the <strong>Inspector</strong> window and we can take a look at the options available for static objects as follows:<div><img src="img/2014OT_05_01.jpg" alt="Time for action – creating the NavMesh"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Nothing</strong>: This option is used to quickly deselect all the other options. If all the others are unchecked, this one will be checked.</li><li class="listitem" style="list-style-type: disc"><strong>Everything</strong>: Using this option, you can quickly select all the other options. When all of them are checked, this one will also be checked. The checkbox next to the <strong>Static</strong> label in the <strong>Inspector</strong> window performs the same function as checking and unchecking the <strong>Everything</strong> checkbox.</li><li class="listitem" style="list-style-type: disc"><strong>Lightmap Static</strong>: This option needs to be checked, when working with lightmaps, in order for them to work. Any mesh that does not have this checked will not be lightmapped.</li><li class="listitem" style="list-style-type: disc"><strong>Occluder Static</strong>: This is an option for working with occlusion. <strong>Occlusion</strong><a id="id359" class="indexterm"/> is a method of runtime optimization that involves only rendering objects that can actually be seen whether or not they are within the camera's view space. An <a id="id360" class="indexterm"/><strong>Occluder</strong> is an object that will block other objects from being seen. It works in conjunction with the <strong>Occludee Static</strong> option. The best object choices for this option are large and solid.</li><li class="listitem" style="list-style-type: disc"><strong>Batching Static</strong>: This is another option for runtime optimization. Batching is the act of grouping objects together before rendering them. It greatly increases the overall render speed of a game.</li><li class="listitem" style="list-style-type: disc"><strong>Navigation Static</strong>: This is the option we are primarily concerned with at this point. <a id="id361" class="indexterm"/>Any mesh that has this option checked will be used when calculating the NavMesh.</li><li class="listitem" style="list-style-type: disc"><strong>Occludee Static</strong>: As mentioned a moment ago, this option works in conjunction with <strong>Occluder Static</strong> for the good of occlusion. An Occludee is an object that will be obscured by other objects. When covered by an Occluder, this object will not be drawn.</li><li class="listitem" style="list-style-type: disc"><strong>Off Mesh Link Generation</strong>: This option also works with the NavMesh calculation. An Off Mesh Link is a connection between two parts of the NavMesh that aren't physically connected, such as the roof and the street. Using a few settings in the <strong>Navigation</strong> window and this option, the links are automatically generated.</li></ul></div></li><li class="listitem">In order to make the NavMesh work properly, we need to change the settings so that only the streets of the city can be navigated. When was the last time you saw a tank jump to or fall from the roof of a building? So, we need to change the <strong>Static</strong> options so that only the streets have <strong>Navigation Static</strong> checked. This can be done in one of the following two ways:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first way is to go through and uncheck the option for each object we want changed.</li><li class="listitem" style="list-style-type: disc">The second is to uncheck <strong>Naviagation Static</strong> for the top-level object in the <strong>Hierarchy</strong> window and, when Unity asks if we want to make the change for all children objects, reply with a yes. Then, go to just the objects that we want to navigate and recheck the option.</li></ul></div></li><li class="listitem">Now, open the <strong>Navigation</strong> window by going to Unity's toolbar and clicking on <strong>Window</strong> followed by <strong>Navigation</strong> at the bottom of the menu. The following screenshot displays the window where all the work of making the NavMesh happens:<div><img src="img/2014OT_05_02.jpg" alt="Time for action – creating the NavMesh"/></div></li><li class="listitem">This window consists of three pages and a variety of settings:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When an object is selected, the settings will appear on the <strong>Object</strong> page. The two checkboxes correspond directly with the <strong>Static</strong> options of the same name that we set a moment ago. <a id="id362" class="indexterm"/>The drop-down list in <strong>Navigation Layer</strong> lets us use different layers for different parts of our NavMesh. These layers can be used to affect the pathfinding calculation. For example, a car can be set to only travel on a road layer and the human can follow the sidewalk layer.</li><li class="listitem" style="list-style-type: disc">The <strong>Bake</strong> page is the one <a id="id363" class="indexterm"/>we are interested in; it is full of options to change how the NavMesh is generated.<p>
<strong>Radius</strong>: This should be set to the size of the average character. It is used to keep characters from walking too close to the walls.</p><p>
<strong>Height</strong>: This is the height of your characters. Using this, Unity can calculate and remove the areas that are too low for them to pass. Anything lower than this value is deemed too small.</p><p>
<strong>Max Slope</strong>: Anything steeper than this value is ignored when calculating NavMesh.</p><p>
<strong>Step Height</strong>: When making use of stairs, one must use this value. This is the maximum height of a stair that a character can step on.</p><p>
<strong>Drop Height</strong>: This is the height from which characters can fall. With it, paths will include jumping off ledges, if it is faster to do so. As you can tell from the screenshot, this is a Unity Pro-only feature.</p><p>
<strong>Jump Distance</strong>: Using this value, characters can jump across gaps in NavMesh. This value represents the longest distance that can be jumped. As you can tell from the screenshot, this is a Unity Pro only feature.</p><p>
<strong>Min Region Area</strong>: If parts of the NavMesh are too small, anything smaller than this value, they will not be used in the final NavMesh.</p><p>
<strong>Width Inaccuracy %</strong>: When doing the NavMesh calculations, Unity makes use of a number of approximations. This is not entirely accurate, but it is fast. This value represents how much inaccuracy is allowed for the horizontal.</p><p>
<strong>Height Inaccuracy %</strong>: This is the same as the previous settings, the difference being that it works for the vertical.</p><p>
<strong>Height Mesh</strong>: With this option checked, the original height information is maintained in NavMesh. Unless you have a special need of it, this option should remain off. It takes the system longer to calculate and requires more memory to store.</p></li><li class="listitem" style="list-style-type: disc">The third page, <strong>Layers</strong>, allows us to adjust the cost of movement for each of our layers. Essentially, how difficult is it to move through different parts of our game world. With cars, we could adjust the layers, so it is twice as costly for them to move through the field as it is to move along the road.<p>At the bottom of the window, we have two buttons:</p><p>
<strong>Clear</strong>: This button removes the previously created NavMesh. After using this button, you will need to re-bake the NavMesh before you can make use of pathfinding again.</p><p>
<strong>Bake</strong>: This button starts the work and creates the NavMesh.</p></li></ul></div></li><li class="listitem">Our city is very simple, so the default values will suit us well enough. Hit <strong>Bake</strong> and watch the progress bar in the bottom-right corner. Once it is done, a blue mesh will appear. This is the NavMesh and, of course, represents all of the area that a<a id="id364" class="indexterm"/> character can move through.</li><li class="listitem">There is one last thing we need to do. Our NavMesh is just right but, if you look closely, it goes through the fountain in the center of the city. It would just be wrong if enemy tanks start driving through the fountain. To fix this, start by selecting the mesh that forms the wall around the fountain.</li><li class="listitem">In the toolbar of Unity, click on <strong>Component</strong>, followed by <strong>Navigation</strong>, and finally <strong>NavMeshObstacle</strong>. This simply adds a component that tells the navigation system to go around when finding a path. Because we had the wall already selected, the new component is already sized to fit. You can see it represented as a wire cylinder in the <strong>Scene</strong> view.<div><img src="img/2014OT_05_07.jpg" alt="Time for action – creating the NavMesh"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the NavMesh. <a id="id365" class="indexterm"/>We made use of the <strong>Navigation</strong> window and the <strong>Static</strong> options to tell Unity which meshes to use when calculating the NavMesh. The Unity team put a lot of work into making this process quick and easy.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Have a go hero – creating extra obstacles</h2></div></div></div><p>Remember, in <a class="link" href="ch03.html" title="Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations">Chapter 3</a>, <em>The Backbone of Any Game – Meshes, Materials, and Animation</em>, when the challenge was to create obstacles for the player, you were encouraged to create additional meshes, such as tank traps and rubble. It would be a bad idea to let the enemy tanks drive through these, as well. So, have a go at turning these into obstacles for the navigation system. This will be done just as with the fountain.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec73"/>The NavMeshAgent component</h1></div></div></div><p>You might be thinking that it <a id="id366" class="indexterm"/>is all well and good that we have a NavMesh, but there are no characters to navigate it. In this section, we will start the creation of our enemy tank.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec74"/>Time for action – creating the enemy</h1></div></div></div><p>We will need to import and do a little setup <a id="id367" class="indexterm"/>on a second tank, before we can do any AI type programming:</p><div><ol class="orderedlist arabic"><li class="listitem">Select <code class="literal">Tanks_Type03.png</code> and <code class="literal">Tanks_Type03.blend</code> from the starting assets for the chapter and import them to the <code class="literal">Tanks</code> folder under the <code class="literal">Models</code> folder.</li><li class="listitem">Once Unity has finished importing, select the new tank in the <strong>Project</strong> window and take a look at it in the <strong>Inspector</strong> window.</li><li class="listitem">This tank has no animations, so the <strong>Animation Type</strong> can be set to <strong>None</strong> and <strong>Import Animation</strong> can be unchecked from the <strong>Rig</strong> and <strong>Animations</strong> pages respectively.</li><li class="listitem">Drag the tank from the <strong>Project</strong> window to the <strong>Scene</strong> window; any clear patch of street will work just fine.</li><li class="listitem">For starters, rename the model in the <strong>Scene</strong> view to <code class="literal">EnemyTank</code>.</li><li class="listitem">Now, we need to change the parenting of the tank so the turret can turn and the cannon will follow, just as we did for the player's tank. To do that, create an empty <strong>GameObject</strong> and rename it to <code class="literal">TurretPivot</code>.</li><li class="listitem">Position <code class="literal">TurretPivot</code> to be at the base of the turret.</li><li class="listitem">In the <strong>Hierarchy</strong> window, drag-and-drop <code class="literal">TurretPivot</code> onto <code class="literal">EnemyTank</code> to make <code class="literal">EnemyTank</code> the parent.</li><li class="listitem">Still in the <strong>Hierarchy</strong> window, make the cannon and turret mesh objects children of <code class="literal">TurretPivot</code>. When Unity asks whether you are sure that you want to break the prefab connection, be sure to click on <strong>Yes</strong>.</li><li class="listitem">The tank is a little large, so adjust the <strong>Scale Factor</strong> of the tank's Import Settings in the <strong>Inspector</strong> window to <code class="literal">0.6</code> to give us a tank that is about the size of the player's.</li><li class="listitem">In order for the tank to be able to navigate our new NavMesh, we need to add a <strong>NavMeshAgent</strong> component. First, select <code class="literal">EnemyTank</code> in the <strong>Hierarchy</strong> window and then go to the toolbar of Unity; click on <strong>Component</strong>, followed by <strong>Navigation</strong>, <a id="id368" class="indexterm"/>and then click on <strong>NavMeshAgent</strong>. In the <a id="id369" class="indexterm"/><strong>Inspector</strong> window, we can see the new component and the settings associated with it, as shown in the following screenshot:<div><img src="img/2014OT_05_03.jpg" alt="Time for action – creating the enemy"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Radius</strong>: This is simply how big the agent is. Working in conjunction with the <strong>Radius</strong> <a id="id370" class="indexterm"/>value we set in the <strong>Navigation</strong> window, this keeps the object from walking partly in the walls.</li><li class="listitem" style="list-style-type: disc"><strong>Speed</strong>: The <strong>NavMeshAgent</strong> component <a id="id371" class="indexterm"/>automatically moves the connected object when it has a path. This value dictates how fast to follow the path in units per second.</li><li class="listitem" style="list-style-type: disc"><strong>Acceleration</strong>: This is the maximum<a id="id372" class="indexterm"/> speed that the agent will accelerate with.</li><li class="listitem" style="list-style-type: disc"><strong>Angular Speed</strong>: This is the<a id="id373" class="indexterm"/> degrees per second that the agent can turn. A person would have a very high angular speed, while a car's angular speed would be low.</li><li class="listitem" style="list-style-type: disc"><strong>Stopping Distance</strong>: This is how far away from the target destination the agent will start to<a id="id374" class="indexterm"/> slow down and stop.</li><li class="listitem" style="list-style-type: disc"><strong>Auto Traverse Off Mesh Link</strong>: With this checkbox checked, the agent will use the Off Mesh Links when pathfinding, such as jumping gaps and falling off ledges.</li><li class="listitem" style="list-style-type: disc"><strong>Auto Braking</strong>: With this checkbox<a id="id375" class="indexterm"/> checked, the agent will stop as soon as it reaches the destination, rather than overshooting, because of the irregular frame rate.</li><li class="listitem" style="list-style-type: disc"><strong>Auto Repath</strong>: If the path that <a id="id376" class="indexterm"/>was found is incomplete for any reason, this checkbox allows<a id="id377" class="indexterm"/> Unity to automatically try to find a new one.</li><li class="listitem" style="list-style-type: disc"><strong>Height</strong>: This setting affects<a id="id378" class="indexterm"/> the cylinder that appears in the editor, around the agent. It simply sets the height of that cylinder.</li><li class="listitem" style="list-style-type: disc"><strong>Base Offset</strong>: This is the vertical <a id="id379" class="indexterm"/>offset of the colliders that are attached to the agent.</li><li class="listitem" style="list-style-type: disc"><strong>Obstacle Avoidance Type</strong>: This is<a id="id380" class="indexterm"/> how much effort the agent will put in to find a smooth path around obstacles. The higher the quality, the more work is done.</li><li class="listitem" style="list-style-type: disc"><strong>Avoidance Priority</strong>: This value dictates who has the right of way. An agent with a high value <a id="id381" class="indexterm"/>will go around an agent with a low value.</li><li class="listitem" style="list-style-type: disc"><strong>NavMesh Walkable</strong>: Remember those layers that were mentioned earlier when discussing<a id="id382" class="indexterm"/> the <strong>Navigation</strong> window? This is where we can set which layers the agent is able to traverse. Only the layers in this list that are checked will be used for pathfinding.</li></ul></div></li><li class="listitem">Now that we understand the settings, let's use them. For the enemy tank, a value of <code class="literal">2.4</code> for the <strong>Radius</strong> and <code class="literal">4</code> for the <strong>Height</strong> will work well. You should be able to see another wire cylinder in the <strong>Scene</strong> window, this time around our enemy tank.</li><li class="listitem">The last thing to do is to turn <code class="literal">EnemyTank</code> into a prefab. Do this just as we did with the targets, by dragging it from the <strong>Hierarchy</strong> window and dropping it on the <code class="literal">Prefabs</code> folder in the <strong>Project</strong> window.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created an enemy tank. We also learned about the settings for the <strong>NavMeshAgent</strong> component. However, if you try to play the game now, nothing will appear to happen. This is because the <strong>NavMeshAgent</strong> component is not being given a destination. We will solve that in the next section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec75"/>The chase</h1></div></div></div><p>Our next task is to make our<a id="id383" class="indexterm"/> enemy tank chase the player around. We will need two scripts. The first will simply advertise the player's current position. The second will use that position and the <strong>NavMeshAgent</strong> component that we set up earlier to find a path to the player.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec76"/>Time for action – the player is over here</h1></div></div></div><p>With a very short script, we can easily allow all our enemies know the location of the player:</p><div><ol class="orderedlist arabic"><li class="listitem">Start by creating a new script in the <code class="literal">Scripts</code> folder of the <strong>Project</strong> window. Name it <code class="literal">PlayerPosition</code>.</li><li class="listitem">This script will start with a single static variable. This variable will simply hold the current position of the player. Because it is static, we will be able to easily access it from the rest of our scripts.<div><pre class="programlisting">public static Vector3 position = Vector3.zero;</pre></div></li><li class="listitem">For the next lines of code, we make use of the <code class="literal">Start</code> function. This function is automatically called when a scene is first loaded. We use it so that the <code class="literal">position</code> variable can be filled and used as soon as the game starts.<div><pre class="programlisting">public void Start() {
  position = transform.position;
}</pre></div></li><li class="listitem">The last segment of code simply updates the <code class="literal">position</code> variable in every frame to the player's current position. We also do this in the <code class="literal">LateUpdate</code> function so that it is done after the player has moved. The <code class="literal">LateUpdate</code> function is called at the end of every frame. With that, the player is able to move during the <code class="literal">OnGUI</code> and <code class="literal">Update</code> functions and their position is updated later.<div><pre class="programlisting">public void LateUpdate() {
  position = transform.position;
}</pre></div></li><li class="listitem">The last thing to do with this script is to add it to the player's tank. So, return to Unity and drag-and-drop the script from the Project window to the tank to add it as a component, just as we have<a id="id384" class="indexterm"/> done with all our other scripts.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the first script needed for our chase AI. This script simply updates a variable with the player's current position. We will make use of it in our next script, where we will make the enemy tank move around.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec77"/>Time for action – chasing the player</h1></div></div></div><p>Our next script will control our simple chase AI. Because we are making use of the <strong>NavMesh</strong> and <strong>NavMeshAgent</strong> components, <a id="id385" class="indexterm"/>we can leave nearly all the difficult portions of pathfinding to Unity:</p><div><ol class="orderedlist arabic"><li class="listitem">Again, create a new script. This time name it <code class="literal">ChasePlayer</code>.</li><li class="listitem">The first line for this script simply holds a reference to the <strong>NavMeshAgent</strong> component that we set up earlier. We need access to this component in order to move the enemy.<div><pre class="programlisting">public NavMeshAgent agent;</pre></div></li><li class="listitem">The last segment of code first makes sure that we have our <strong>NavMeshAgent</strong> reference and then updates our goal destination. It uses the <code class="literal">PlayerPosition</code> script's variable, that was set up earlier, and the<a id="id386" class="indexterm"/> <code class="literal">SetDestination</code> function from the <strong>NavMeshAgent</strong>. Once we tell the function where to go, the <strong>NavMeshAgent</strong> component does all the hard work of getting us there. We are updating our goal destination in the <code class="literal">FixedUpdate</code> function because we do not need to update the destination in every frame. Updating too often could cause a serious lag if there are a whole lot of enemies. The <code class="literal">FixedUpdate</code> function is called at regular intervals and is slower than the frame rate, so it is perfect.<div><pre class="programlisting">public void FixedUpdate() {
  if(agent == null) return;

  agent.SetDestination(PlayerPosition.position);
}</pre></div></li><li class="listitem">We now need to add the script to our enemy tank. Select the <code class="literal">prefab</code> in the <strong>Project</strong> window, and drag-and-drop the script in the <strong>Inspector</strong> panel, underneath the <strong>NavMeshAgent</strong> component.</li><li class="listitem">Be sure to connect the reference, as we have done previously. Drag the <strong>NavMeshAgent</strong> component to the <strong>Agent</strong> value in the <strong>Inspector</strong> window.</li><li class="listitem">Play the game now to try it out. Wherever the enemy starts, it finds its way around all the buildings<a id="id387" class="indexterm"/> and makes it to the player's position. As you drive around, you can watch the enemy follow. However, the enemy tank ends up going through our tank. Also, we can drive through it.</li><li class="listitem">The first step to fixing it is to add some colliders. Add a <strong>Box Collider</strong> component from underneath <strong>Physics</strong> in the <strong>Component</strong> menu to the turret, chassis, and each of the <strong>TreadCase</strong> objects. Neither the cannon nor the treads need colliders. The tread casings already cover the area of the treads, and the cannon is too small a target to be shot at properly.<div><img src="img/2014OT_05_08.jpg" alt="Time for action – chasing the player"/></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>If you are making any of these changes in the <strong>Scene</strong> view, be sure to click on the <strong>Apply</strong> button in the <strong>Inspector</strong> window to update the root prefab object.</p></div></div></li><li class="listitem">The last thing to change is the <strong>Stopping Distance</strong> property on the <strong>NavMeshAgent</strong> component. When the tanks fight, they move into range and start firing. They do not try to occupy the same space as the enemy, unless that enemy is <a id="id388" class="indexterm"/>small and squishy. By setting <strong>Stopping Distance</strong> to <code class="literal">10</code> we are able to replicate this behavior.<div><img src="img/2014OT_05_04.jpg" alt="Time for action – chasing the player"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>
<em>What just happened?</em>
</h2></div></div></div><p>In this section, we created a script that causes a <strong>NavMeshAgent</strong> component, in this case our enemy tank, to chase the player. We added colliders to stop us from driving through the enemy. And, we adjusted the <strong>Stopping Distance</strong> to give us a better tank behavior.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Have a go hero – adding shadow</h2></div></div></div><p>Try adding a blob shadow to the enemy tank. This will give it a better visual sense of being grounded. You can just copy the one that was made for the player's tank.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec78"/>Being attacked</h1></div></div></div><p>What fun is a game without a little conflict; the nagging choice, the fight to the death, the doom of the cosmos? Every game needs some form of conflict to drive the player towards seeking a resolution. Our game will become a battle for points. Before, it was just shoot some targets and get some points.</p><p>Now, we will make the enemy tank shoot at the player. Every time the enemy scores a hit, we will reduce the player's score by a few points.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec79"/>Time for action – getting ready to fire</h1></div></div></div><p>The enemy will shoot in a similar manner<a id="id389" class="indexterm"/> to how the player fires, but we will use some basic AI to control the direction and firing speed, replacing the player's input controls:</p><div><ol class="orderedlist arabic"><li class="listitem">We will start this off with a new script called <code class="literal">ShootAtPlayer</code>. Create it in the <code class="literal">Scripts</code> folder.</li><li class="listitem">As with all our other scripts, we start this one out with two variables. The first variable will hold the last position the enemy tank was at. It will not be shooting if the tank is in motion, so we need to store that last position to see if we have moved. The second variable will be the maximum speed at which we can move and shoot. If the tank moves faster than this, it will not fire.<div><pre class="programlisting">private Vector3 lastPosition = Vector3.zero;
public float maxSpeed = 1f;</pre></div></li><li class="listitem">The next two variables dictate how long it takes the tank to ready a shot. It is unrealistic to be shooting the player in every single frame. So, we use the first variable to adjust the length of time it takes to ready a shot, and the second to store when the shot is ready.<div><pre class="programlisting">public float readyLength = 2f;
private float readyTime = -1;</pre></div></li><li class="listitem">The next variable is how fast the turret can rotate. While the tank is readying its shot, the turret will not be rotating to point at the player. That gives the player an opportunity to move out of the way. However, we need a speed to keep the turret from snapping to face the player after shooting.<div><pre class="programlisting">public float turretSpeed = 45f;</pre></div></li><li class="listitem">The last two variables here hold references to other parts of the tank. The <code class="literal">turretPivot</code> variable, of course, is the pivot of the turret that we will be rotating. The <code class="literal">muzzlePoint</code> variable will be used as the point from where our cannon is fired. These will be used in the same manner as the ones for the player's tank.<div><pre class="programlisting">public Transform turretPivot;
public Transform muzzlePoint;</pre></div></li><li class="listitem">For the first function of the script, we will make use of the <a id="id390" class="indexterm"/><code class="literal">Update</code> function. It starts by calling a function that will check to see whether it is possible to fire the cannon. If we can fire, we perform some checks on our <code class="literal">readyTime</code> variable. If it is less than zero, we have not yet begun to ready our shot and call a function to do so. Otherwise, if it is less than the current time, we have finished the preparation<a id="id391" class="indexterm"/> and call the function to fire the cannon. If we are unable to fire, we first call a function to clear any preparations and then rotate the turret to face the player.<div><pre class="programlisting">public void Update() {
  if(CheckCanFire()) {
    if(readyTime &lt; 0) {
      PrepareFire();
    }
    else if(readyTime &lt;= Time.time) {
      Fire();
    }
  }
  else {
    ClearFire();
    RotateTurret();
  }
}</pre></div></li><li class="listitem">Next, we will create our <code class="literal">CheckCanFire</code> function. The first part of code checks to see if we have moved too fast. First, we use <code class="literal">Vector3.Distance</code> to see how far we have moved since the last frame. By dividing the distance by the length of the frame, we are able to determine the speed with which we moved. Next, we update our <code class="literal">lastPosition</code> variable with our current position, so it is ready for the next frame. Finally, we compare the current speed with the <code class="literal">maxSpeed</code>. If we moved too fast in this frame, we are unable to fire and return a result of <code class="literal">false</code>.<div><pre class="programlisting">public bool CheckCanFire() {
  float move = Vector3.Distance(lastPosition, transform.position);
  float speed = move / Time.deltaTime;

  lastPosition = transform.position;

  if(speed &gt; maxSpeed) return false;</pre></div></li><li class="listitem">For the second half of the <code class="literal">CheckCanFire</code> function<a id="id392" class="indexterm"/>, we check to see if the turret is pointed at the player. First, we find the direction to the player. Given any point in space and subtracting the second point's location from it, will give us the direction from the second point to the first as a vector. We then flatten the direction by setting the <code class="literal">y</code> value to <code class="literal">0</code>. This is done because we do not want to be looking up or down at the player. Then, we use <code class="literal">Vector3.Angle</code> to<a id="id393" class="indexterm"/> find the angle between the direction to the player and our turret's forward direction. Finally, we compare the angle to a low value to determine whether we are looking at the player, and return the result.<div><pre class="programlisting">  Vector3 targetDir = PlayerPosition.position – turretPivot.position;
  targetDir.y = 0;

  float angle = Vector3.Angle(targetDir, turretPivot.forward);

  return angle &lt; 0.1f;
}</pre></div></li><li class="listitem">The <code class="literal">PrepareFire</code> function<a id="id394" class="indexterm"/> is quick and easy. It simply sets our <code class="literal">readyTime</code> variable to the time in the future when the tank will be done preparing its shot.<div><pre class="programlisting">public void PrepareFire() {
  readyTime = Time.time + readyLength;
}</pre></div></li><li class="listitem">The <code class="literal">Fire</code> function starts by making sure that we have a <code class="literal">muzzlePoint</code> reference to shoot from.<div><pre class="programlisting">public void Fire() {
  if(muzzlePoint == null) return;</pre></div></li><li class="listitem">The function continues with the creation of a <code class="literal">RaycastHit</code> variable to store the result of our shot. We use <code class="literal">Physics.Raycast</code> and <code class="literal">SendMessage</code>, just as we did in the <code class="literal">FireControls</code> script, to shoot at anything and tell it that we hit it.<div><pre class="programlisting">RaycastHit hit;
if(Physics.Raycast(muzzlePoint.position, muzzlePoint.forward, out hit)) {
  hit.transform.gameObject.SendMessage("RemovePoints", 3, SendMessageOptions.DontRequireReceiver);
}</pre></div></li><li class="listitem">The <code class="literal">Fire</code> function<a id="id395" class="indexterm"/> finishes by clearing the fire preparations.<div><pre class="programlisting">  ClearFire();
}</pre></div></li><li class="listitem">The <code class="literal">ClearFire</code> function<a id="id396" class="indexterm"/> is another quick function. It sets our <code class="literal">readyTime</code> variable to be less than zero, indicating that the tank is not preparing to fire.<div><pre class="programlisting">public void ClearFire() {
  readyTime = -1;
}</pre></div></li><li class="listitem">The last function for the script is <code class="literal">RotateTurret</code>. It begins by checking the <code class="literal">turretPivot</code> variable and canceling the function should the reference be missing. It is followed by the finding of the flat direction that points at the player, just as we did earlier. Next, <a id="id397" class="indexterm"/>we create the <code class="literal">step</code> variable to hold how much we can move this frame. We use <code class="literal">Vector3.RotateTowards</code> to find a vector that is closer to pointing at our target than the current forward direction is. Finally, we use <code class="literal">Quaternion.LookRotation</code> to create a special rotation that points our turret in the new direction.<div><pre class="programlisting">public void RotateTurret() {
  if(turretPivot == null) return;

  Vector3 targetDir = PlayerPosition.position – turretPivot.position;
  targetDir.y = 0;

  float step = turretSpeed * Time.deltaTime;

  Vector3 rotateDir = Vector3.RotateTowards(turretPivot.forward, targetDir, step, 0);
  turretPivot.rotation = Quaternion.LookRotation(rotateDir);
}</pre></div></li><li class="listitem">Now, returning to Unity, create an empty <strong>GameObject</strong> and rename it to <code class="literal">MuzzlePoint</code>.</li><li class="listitem">Position <code class="literal">MuzzlePoint</code> as we did for the player, at the end of the cannon.</li><li class="listitem">Make <code class="literal">MuzzlePoint</code> a child of the cannon and zero out any <strong>Y</strong> rotation that might be on it, in the <strong>Inspector</strong> window.</li><li class="listitem">Next, add our new <code class="literal">ShootAtPlayer</code> script to the enemy tank. Additionally, connect the references to the <code class="literal">TurretPivot</code> and <code class="literal">MuzzlePoint</code> variables.</li><li class="listitem">Finally, for the enemy tank, hit the <strong>Apply</strong> button in the <strong>Inspector</strong> window to update the prefab.</li><li class="listitem">If you play the game now, you will see the enemy rotating to point at you, but your score never decreases. This is because of two issues. First, the tank is slightly floating. It doesn't matter where in the world you place it, when playing the game, the tank will slightly float. This is because of the way the NavMeshAgent component functions. The fix is simple, just set the <strong>Base Offset</strong> to <code class="literal">-0.3</code> in the <strong>Inspector</strong> window. This tricks the system and puts the tank on the ground.</li><li class="listitem">The second reason the score isn't changing is because the player is missing a function. Open the <code class="literal">ScoreCounter</code> script.</li><li class="listitem">We will be adding the <code class="literal">RemovePoints</code> function<a id="id398" class="indexterm"/>. Given an amount, this function simply removes<a id="id399" class="indexterm"/> that many points from the player's score.<div><pre class="programlisting">public void RemovePoints(int amount) {
  score -= amount;
}</pre></div><div><img src="img/2014OT_05_05.jpg" alt="Time for action – getting ready to fire"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>
<em>What just happened?</em>
</h2></div></div></div><p>We gave the enemy the ability to attack the player. The new <code class="literal">ShootAtPlayer</code> script checks first to see whether the tank has slowed down and whether the cannon is trained on the player. If so, it will take regular shots at the player to reduce their score. The player is going to need to keep moving and aim at targets fast, if they hope to be left with any points at the end of the game.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Have a go hero – player feedback</h2></div></div></div><p>Unless you are paying close attention to your score, it is difficult to tell when you are being shot at. We will be working with explosions in a future chapter but, even so, the player needs some feedback to tell what is going on. Most games will flash a red texture on the screen when the player is hit, whether or not there are any explosions. Try creating a simple texture and drawing it on the screen for half a second when the player is hit.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec80"/>Attacking the enemy</h1></div></div></div><p>Players tend to become frustrated quickly<a id="id400" class="indexterm"/> when faced with an enemy they are unable to fight against. So, we are going to give our player the ability to hurt and destroy the enemy tank. This will function in a similar manner to the way the targets are shot.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec81"/>Time for action – giving it a weakness</h1></div></div></div><p>The easiest way to weaken our<a id="id401" class="indexterm"/> enemies is to give them some health that is reduced when they are shot, and to destroy them when they run out of health:</p><div><ol class="orderedlist arabic"><li class="listitem">We start by creating a new script and naming it <code class="literal">Health</code>.</li><li class="listitem">This script is rather short and starts with a single variable. This variable will keep track of the remaining health of the tank. By setting the default value to <code class="literal">3</code>, the tank will be able to survive three hits before being destroyed.<div><pre class="programlisting">public int health = 3;</pre></div></li><li class="listitem">This script also contains only one function, <code class="literal">Hit</code>. As in the case of the targets, this function is called by the <code class="literal">BroadcastMessage</code> function<a id="id402" class="indexterm"/> when the player shoots at it. The first line of the function reduces <code class="literal">health</code> by one point. The next line checks to see if <code class="literal">health</code> is below zero. If it is, the tank is destroyed by calling the <code class="literal">Destroy</code> function and passing it the <code class="literal">gameObject</code> variable. We also give the player a handful of points.<div><pre class="programlisting">public void Hit() {
  health--;
  if(health &lt;= 0) {
    Destroy(gameObject);
    ScoreCounter.score += 5;
  }
}</pre></div></li><li class="listitem">It really is just that simple. Now, add the new script to the <code class="literal">EnemyTank</code> prefab in the <strong>Project</strong> window, and it will update all the enemy tanks that you currently have in the scene.</li><li class="listitem">Try it out. Add a few extra enemy tanks to the scene and watch them follow you around and disappear when you shoot them.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>
<em>What just happened?</em>
</h2></div></div></div><p>We gave the enemy tank a weakness, health. <a id="id403" class="indexterm"/>By creating a short script, the tank is able to track its health and detect when it has been shot. Once the tank runs out of health, it is removed from the game.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Have a go hero – coloring the enemy</h2></div></div></div><p>We now have two targets to shoot at: the animated ones and the tank. However, they are both indicated with red slices. Try<a id="id404" class="indexterm"/> to make the ones that point at tanks be a different color. You will have to make a duplicate of the <code class="literal">IndicatorSlice</code> prefab and change the <code class="literal">IndicatorControl</code> script so that it can be told which type of slice to use when the <code class="literal">CreateSlice</code> and <code class="literal">NewSlice</code> functions are called.</p><p>As a further challenge, the moment we give a creature some health, players want to be able to see how much damage they have done to it. There are two ways you could do this. First, you could put a cluster of cubes above the tank. Then, each time the tank loses health, you delete one of the cubes. The second option is a little more difficult, drawing the bar in the GUI and changing its size based on the remaining health. To make the bar stay above the tank as the camera moves around, take a look at <code class="literal">Camera.WorldToScreenPoint</code>, in the documentation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec82"/>Spawning</h1></div></div></div><p>Having a limited number of enemies in the game, at the beginning, is not suitable for our game to have lasting fun. Therefore, we need to make some spawn points. As tanks are destroyed, these will issue forth new tanks to keep the player on their toes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec83"/>Time for action – creating spawns</h1></div></div></div><p>The script we will be creating in this<a id="id405" class="indexterm"/> section will keep our game world populated with all the enemies our player might want to destroy:</p><div><ol class="orderedlist arabic"><li class="listitem">We need another new script for this section. Once created, name it <code class="literal">SpawnPoint</code>.</li><li class="listitem">This script begins simply with a few variables. The first variable will hold a reference to our <code class="literal">EnemyTank</code> prefab. We need it so we can spawn duplicates.<div><pre class="programlisting">public GameObject tankPrefab;</pre></div></li><li class="listitem">The second variable tracks the spawned tank. When it is destroyed we will create a new one. Using this variable we prevent the game from becoming overwhelmed with the enemy. There will only be as many tanks as spawn points.<div><pre class="programlisting">private GameObject currentTank;</pre></div></li><li class="listitem">The third variable is for setting a distance from the player, to prevent spawning tanks on top of the player. If the player is outside this distance, a new tank can be spawned. If they are within, a new tank will not be spawned.<div><pre class="programlisting">public float minPlayerDistance = 10;</pre></div></li><li class="listitem">The first function we <a id="id406" class="indexterm"/>will use is <code class="literal">FixedUpdate</code>. It will start by checking a function to see whether it needs to spawn a new tank. If it does, it will call the <code class="literal">SpawnTank</code> function to do so.<div><pre class="programlisting">public void FixedUpdate() {
  if(CanSpawn())
    SpawnTank();
}</pre></div></li><li class="listitem">Next, we create the <a id="id407" class="indexterm"/><code class="literal">CanSpawn</code> function. The first line of the function checks to see whether we already have a tank and returns <code class="literal">false</code> if we do. The second line uses <code class="literal">Vector3.Distance</code> to determine how far away the player currently is. The last line compares that distance to the minimum distance away that the player needs to be before we can spawn anything and returns the result.<div><pre class="programlisting">public bool CanSpawn() {
  if(current != null) return false;

  float currentDistance = Vector3.Distance(PlayerPosition.position, transform.position);
  return currentDistance &gt; minPlayerDistance;
}</pre></div></li><li class="listitem">The last function, <code class="literal">SpawnTank</code>, starts by checking to make sure the <code class="literal">tankPrefab</code> reference has been connected. It can't continue if there is nothing to spawn. The second line uses the <code class="literal">Instantiate</code> function to create a duplicate of the prefab. In order to store it in our variable, we use <code class="literal">as GameObject</code> to make it the proper type. The last line moves the new tank to the spawn point's position. We don't want the tanks appearing in random locations.<div><pre class="programlisting">public void SpawnTank() {
  if(tankPrefab == null) return;

  currentTank = Instantiate(tankPrefab) as GameObject;
  currentTank.transform.position = transform.position;
}</pre></div></li><li class="listitem">Return to Unity, create an empty <strong>GameObject</strong>, and rename it to <code class="literal">SpawnPoint</code>.</li><li class="listitem">Add the <code class="literal">SpawnPoint</code> script that we just created, to it.</li><li class="listitem">Next, with the spawn point selected, connect the prefab reference by dragging the <code class="literal">EnemyTank</code> prefab<a id="id408" class="indexterm"/> from the <code class="literal">Prefabs</code> folder and dropping it on the appropriate value.</li><li class="listitem">Now, turn the <code class="literal">SpawnPoint</code> object into a prefab, by dragging-and-dropping it from the <strong>Hierarchy</strong> window<a id="id409" class="indexterm"/> and into the <code class="literal">Prefabs</code> folder.</li><li class="listitem">Finally, populate the city with the new points. Positioning one in each corner of the city will work well.<div><img src="img/2014OT_05_06.jpg" alt="Time for action – creating spawns"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created spawn points for the game. Each point will spawn a new tank. When a tank is destroyed, a new one is created at the spawn point. Feel free to build the game and try it out on your device. This section and chapter are now complete and ready for wrap up.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Have a go hero – two for one</h2></div></div></div><p>Having one spawn point per tank is great, until we want many tanks. Or, we desire them to all spawn in the same location. Your challenge here is to make a single spawn point track multiple tanks. If any one of the tanks is destroyed, a new one should be created. You will definitely need an array to keep track of all the tanks. Also, implement a delay for the spawn. We don't want it spawning multiple tanks on top of each other.</p><p>Now that you have all the knowledge and tools that you need, as a further challenge, try creating other types of enemy tanks. Experiment with size and speed. They can also have different strengths, or give more<a id="id410" class="indexterm"/> points when destroyed. Perhaps there is a tank that actually gives the player points when shooting at them. Play around and have some fun with it.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Pop Quiz – understanding enemies</h2></div></div></div><p>Q1. Probably the most common act performed in games is shooting with guns. We have done it a couple of times now. Do you remember what function we use to determine where and what our bullet might hit?</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">Input.mousePosition</code></li><li class="listitem"><code class="literal">Transform.position</code></li><li class="listitem"><code class="literal">Physics.Raycast</code></li></ol></div><p>Q2. We will need a great many enemies running around for us to shoot at. Do you remember which function we use to make them move around our NavMesh?</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">CharacterController.Move</code></li><li class="listitem"><code class="literal">NavMeshAgent.SetDestination</code></li><li class="listitem"><code class="literal">NavMesh.CalculatePath</code></li></ol></div><p>Q3. Finally, all these enemies will have to be spawned again and again. Do you remember what function we use to spawn these enemies?</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">Instantiate</code></li><li class="listitem"><code class="literal">Destroy</code></li><li class="listitem"><code class="literal">Start</code></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec84"/>Summary</h1></div></div></div><p>In this chapter, we learned about NavMeshes and pathfinding. We also did a little work with AI. It was perhaps among the simplest types of AI but chase behaviors are highly important to all types of games. To utilize all of this, we created an enemy tank. It chased the player and shot at them to reduce their score. To give the edge back to the player, we gave health to the enemy tanks. The player can now shoot the enemy tanks as well as the targets for points. But, we also created some spawn points. Every time a tank was destroyed a new one will be created. In terms of general game play, our Tank Battle game is pretty much complete.</p><p>In the next chapter, we will be creating a new game. In order to explore some of the special features of the mobile platform, we will create a Space Fighter game. Nearly all the buttons will be removed from the screen, in favor of new control methods. We will be turning the device's tilt sensors into our steering method. And, we will have to touch enemies and targets to shoot at them. We will also take a look at a different methods of spawning to give the player an endless amount of space to fly through.</p></div></body></html>