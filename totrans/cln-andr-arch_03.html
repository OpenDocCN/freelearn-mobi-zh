<html><head></head><body>
		<div><h1 id="_idParaDest-37"><em class="italic"><a id="_idTextAnchor038"/>Chapter 2</em>: Deep Diving into Data Sources</h1>
			<p>In this chapter, we will study some of the popular libraries and frameworks used for retrieving and managing data on Android and how to do this without blocking the main thread of an application. We will start by going over how multithreading should be handled in an Android application and the available technologies we now have to easily handle this. We will then move on to implement loading data from the internet using libraries such as Retrofit and OkHttp, after which we will look at how we can persist data on a device using libraries such as Room and DataStore.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Understanding Kotlin coroutines and flows</li>
				<li>Using OkHttp and Retrofit for networking</li>
				<li>Using the Room library for data persistence</li>
				<li>Understanding and using the DataStore library</li>
			</ul>
			<p>By the end of this chapter, you will have become familiar with how we can load, manage, and persist data in an Android application.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor039"/>Technical requirements </h1>
			<p>This chapter has the following hardware and software requirements:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: </p>
			<p><a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2</a></p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/38uecPi">https://bit.ly/38uecPi</a></p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Understanding Kotlin coroutines and Flows</h1>
			<p>In this section, we<a id="_idIndexMarker125"/> will look at how threading works in the Android <a id="_idIndexMarker126"/>ecosystem and what applications must do to ensure that long-running operations do not block the user from using an application. We will then look at what available options we have available to execute operations in the background, with a focus on coroutines. Finally, we will look over Kotlin flows, which we can use to handle asynchronous work using a reactive and functional approach.</p>
			<p>Android applications normally run in a single process on a user's device. When the operating system starts the application's process, it will allocate memory resources for the process to be executed. This process, when started, will have one thread of execution running within. This thread is referred to as the "main thread" or "<strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) thread". In<a id="_idIndexMarker127"/> Android, this concept is very important because it is the thread that deals with user interaction. This imposes certain limitations for developers when dealing with it, as outlined here: </p>
			<ul>
				<li>The main thread must not be <a id="_idIndexMarker128"/>blocked by long-running or <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) operations.</li>
				<li>All updates to the UI must be done on the main thread.</li>
			</ul>
			<p>The idea is that the user should still be able to interact with an application as much as possible even if the application is doing some work. Every time we want to load and save data from or to the internet, local storage, content providers, and so on, we should use another thread or use multiple threads. The way the device's processor deals with multiple threads is by assigning a core for each thread. When there are more threads than cores, it will jump back and forth between every single instruction from each thread. Having too<a id="_idIndexMarker129"/> many threads being executed simultaneously will end up creating a bad <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>) because the processor will now need to jump between the main thread and the rest of the threads being executed at the same time, so we will need to be mindful of how many threads are being executed concurrently.</p>
			<p>In Java, a thread can be created using the <code>Thread</code> class; however, creating a new thread for every asynchronous operation is a very resource-expensive operation. Java also offers the concept of <code>ThreadPool</code> or <code>Executor</code>. These typically manage fixed a collection of threads that will be reused for different operations. Because of the Android restriction regarding updating the UI on the main thread, classes such as <code>Handler</code> and <code>Looper</code> were introduced, whereby you can submit the result of an operation performed on a background thread back on the main thread. An example of this is provided here:</p>
			<pre>class MyClass {
    fun asyncSum(a: Int, b: Int, callback: (Int) -&gt; Unit) {
        val handler = Handler(Looper.getMainLooper())
        Thread(Runnable {
            val result = a + b
            handler.post(Runnable {
                callback(result)
            })
        }).start()
    }
}</pre>
			<p>In the <a id="_idIndexMarker130"/>preceding<a id="_idIndexMarker131"/> code snippet, the sum of two numbers will be performed on a new thread, and the result will then be posted back using the <code>Handler</code> object that is connected to the main <code>Looper</code> object, which itself will loop the main t<a id="_idTextAnchor041"/>hread.</p>
			<p>The repeated usage of <code>Handler</code> and <code>Looper</code> gave birth to <code>AsyncTask</code>, which offers the possibility of moving the necessary operations on a background thread and receiving the result on the main thread. <code>AsyncTask</code> worked with the same principle as the preceding example, only instead of creating a new thread for every new operation, it would by default use the same thread (although this later became configurable), which means that if two <code>AsyncTask</code> instances were executed at the same time, one would wait after the other. An example of the same sum operations might look like this:</p>
			<pre>    fun asyncSum(a: Int, b: Int, callback: (Int) -&gt; Unit) {
        object : AsyncTask&lt;Nothing, Nothing, Int&gt;() {
            override fun doInBackground(vararg params: 
                Nothing?): Int {
                return a+b
            }
            override fun onPostExecute(result: Int) {
                super.onPostExecute(result)
                callback(result)
            }
        }.execute()
    }</pre>
			<p>In the<a id="_idIndexMarker132"/> preceding<a id="_idIndexMarker133"/> example, the sum is done in the <code>doInBackground</code> method, which is executed on a separate thread, and the <code>onPostExecute</code> method would be executed on the main thread.</p>
			<p>Let's now imagine that we want to chain these sums and apply them multiple times, as follows:</p>
			<pre>    fun asyncComplicatedSum(a: Int, b: Int, c: Int) {
        asyncSum(a, b) { tempSum -&gt;
            asyncSum(tempSum, c) { finalSum -&gt;
                Log.d(this.javaClass.name, "Final sum 
                    $finalSum")
            }
        }
    }</pre>
			<p>In the preceding example, we try to sum two numbers and add the result to number <code>c</code>. As you can see, we need to use the callback and wait for <code>a</code> and <code>b</code> to finish and then apply the same function to the result of <code>a+b</code> and the number <code>c</code>. </p>
			<p>Let's imagine what an application might look like when having to deal with loading data from multiple data sources, merging them together, handling errors, and stopping the asynchronous execution if the user leaves the current activity or fragment. The RxJava library tries to tackle all these problems through an event-driven approach. It introduces the concepts of streams and flows of data that can be observed, transformed, merged with other data streams, and executed on different threads. The sum of two numbers in RxJava <a id="_idIndexMarker134"/>might<a id="_idIndexMarker135"/> look something like this:</p>
			<pre>fun asyncSum(a: Int, b: Int): Single&lt;Int&gt; {
        return Single.create&lt;Int&gt; {
            it.onSuccess(a + b)
        }.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
    }</pre>
			<p>In the preceding example, we create a <code>Single</code> instance, which is a stream that emits only one value (for emitting multiple values, we have the <code>Flowable</code> and <code>Observable</code> options). The value emitted is the sum of the two numbers. The usage of <code>subscribeOn</code> is for executing the upstream (the sum) on an I/O thread managed by RxJava internally, and the usage of <code>observeOn</code> is to have everything downstream (all the commands that will follow) to get the result on the main thread.</p>
			<p>If we want to chain multiple sums, then we would have something like this:</p>
			<pre>fun asyncComplicatedSum(a: Int, b: Int, c: Int) {
        val disposable = asyncSum(a, b)
            .flatMap {
                asyncSum(it, c)
            }
            .subscribe ({
                Log.d(this.javaClass.name, "Final sum $it")
            },{
                Log.d(this.javaClass.name, "Something went 
                    wrong")
          <a id="_idTextAnchor042"/>  })
    }</pre>
			<p>In the preceding example, the sum of <code>a</code> and <code>b</code> is executed, then through the <code>flatMap</code> operator, we add <code>c</code> to that result. The usage of <code>subscribe</code> method is for triggering sums and listening for the results. This is because the <code>Single</code> instance used is a cold observable; it will only be executed only when <code>subscribe</code> is called. There is also the concept of hot observables, which will emit whether there are subscribers or not. The result of the <code>subscribe</code> operator will return a <code>Disposable</code> instance that offers a <code>dispose</code> method that can be called when we want to stop listening for data from the stream. This<a id="_idIndexMarker136"/> is <a id="_idIndexMarker137"/>useful in situations where our activities and fragments are destroyed, and we don't want to update our UI to avoid context leaks.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor043"/>Kotlin coroutines</h2>
			<p>So far, we <a id="_idIndexMarker138"/>have analyzed technologies that revolve around the Java and Android frameworks. With the adoption of Kotlin, other technologies have emerged that deal with multithreading and are Kotlin-specific. One of these is the concept of coroutines. Coroutines simplify the way we write asynchronous code. Instead of dealing with callbacks, coroutines introduce the concept of scopes where we can specify which threads our blocks of code will execute in. The scopes can also connect to lifecycle-aware components that help us unsubscribe from the results of asynchronous work when our lifecycle-aware components terminate. Let's look at the following example of coroutines for the same sum:</p>
			<pre>   suspend fun asyncSum(a: Int, b: Int): Int {
        return withContext(Dispatchers.IO) {
            a + b
        }
    }</pre>
			<p>In the preceding example, the <code>withContext</code> method will execute the block of code inside it in the threads managed by the I/O dispatcher. The number of threads associated with this dispatcher is managed internally by the Kotlin framework and is associated with the number of cores the processor of the device has. This often means that we don't have to worry about the performance of our applications when multiple asynchronous operations are executed concurrently. Another interesting thing to note in the example is the usage of the <code>suspend</code> keyword. This is to alert the caller of this method that it will be executed using coroutines on a separate thread.</p>
			<p>Now, let's see what things will look like when we want to invoke this method. Have a look at the <a id="_idIndexMarker139"/>following code snippet: </p>
			<pre>class MyClass : CoroutineScope {
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
    private lateinit var job: Job
    fun asyncComplicatedSum(a: Int, b: Int, c: Int) {
        launch {
            try {
                val tempSum = asyncSum(a, b)
                val finalSum = asyncSum(tempSum, c)
                Log.d(this.javaClass.name, "Final sum 
                    $finalSum")
            } catch (e: Exception) {
                Log.d(this.javaClass.name, "Something went 
                    wrong")
            }
        }
    }
    fun create() {
        job = Job()
    }
    fun destroy() {
        job.cancel()
    }
}</pre>
			<p>In <code>asyncComplicatedSum</code>, we use the <code>launch</code> method. This method is associated with the <code>CoroutineContext</code> object defined in this class. The context is defined using the <code>Main</code> dispatcher <a id="_idIndexMarker140"/>combined with the <code>Job</code> object that will be associated with the lifecycle of this object. If the <code>destroy</code> method is called while we are waiting for the result of the sum, then the execution of the sum will stop and we will stop getting the result of the sum. The code will execute each of the sums on the I/O thread and then execute log statements on the main thread if the job is still alive.</p>
			<p>In Android, we already have a few <code>CoroutineScope</code> objects already defined and associated with our lifecycle-aware classes. One that will be relevant to us is the one defined for <code>ViewModels</code>. This can be found in the <code>org.jetbrains.kotlinx:kotlinx-coroutines-android</code> library and will look something like this:</p>
			<pre>class MyViewModel: ViewModel() {
    init {
        viewModelScope.launch {  }
    }
}</pre>
			<p><code>viewModelScope</code> is a Kotlin extension created for <code>ViewModel</code> instances that will execute if the <code>ViewModel</code> instance is alive. If <code>onCleared</code> is called on the <code>ViewModel</code> instance, then it will stop listening to the remaining code to be executed in the <code>launch</code> block.</p>
			<p>In this section, we've analyzed how Kotlin coroutines work and how we can use them to handle asynchronous operations in an Android application. In the next section, we will create an Android <a id="_idIndexMarker141"/>application that will use Kotlin coroutines for a simple asynchronous operation.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor044"/>Exercise 02.01 – Using Kotlin coroutines</h2>
			<p>Create an <a id="_idIndexMarker142"/>application that will display two input fields, one text field, and a button. The input fields will be limited to numbers only, and when the user presses the button, then the text field will display the sum of the two numbers after 5 seconds. The sum and waiting will be implemented using coroutines.</p>
			<p>To complete the exercise, you will need to build the following:</p>
			<ul>
				<li>A class that will perform the addition of the two numbers</li>
				<li>A <code>ViewModel</code> class that will invoke the addition</li>
				<li>The UI using Compose that will use the following function:<pre>@Composable
fun Calculator(
    a: String,
    onAChanged: (String) -&gt; Unit,
    b: String,
    onBChanged: (String) -&gt; Unit,
    result: String,
    onButtonClick: () -&gt; Unit
) {
    Column(modifier = Modifier.padding(16.dp)) {
        OutlinedTextField(
            value = a,
            onValueChange = onAChanged,
            keyboardOptions = KeyboardOptions
                (keyboardType = KeyboardType.Number),
            label = { Text("a") }
        )
        OutlinedTextField(
            value = b,
            onValueChange = onBChanged,
            keyboardOptions = KeyboardOptions
                (keyboardType = KeyboardType.Number),
            label = { Text("b") }
        )
        Text(text = result)
        Button(onClick = onButtonClick) {
            Text(text = "Calculate")
        }
    }
}</pre></li>
			</ul>
			<p>Follow these <a id="_idIndexMarker143"/>steps to complete the exercise:</p>
			<ol>
				<li>Create a new project in Android Studio using an <strong class="bold">Empty Compose Activity</strong>.</li>
				<li>At the top level of the <code>build.gradle</code> file, define the Compose library version as follows:<pre>buildscript {
    ext {
        compose_version = '1.0.5'
    }
    … 
}</pre></li>
				<li>In<a id="_idIndexMarker144"/> the <code>app/build.gradle</code> file, we need to add the following dependencies:<pre>dependencies {
    implementation 'androidx.core:core-ktx:1.7.0'
    implementation 'androidx.appcompat:appcompat:1.4.0'
    implementation 'com.google.android.material:material:1.4.0'
    implementation "androidx.compose.ui:ui:$compose_version"
    implementation "androidx.compose.material:material:$compose_version"
    implementation "androidx.compose.ui:ui-tooling-preview:$compose_version"
    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.4.0'
    implementation 'androidx.activity:activity-compose:1.4.0'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0'
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0"
    implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0"
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
    androidTestImplementation "androidx.compose.ui:ui-test-junit4:$compose_version"
    testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.5.0"
    debugImplementation "androidx.compose.ui:ui-tooling:$compose_version"
}</pre></li>
				<li>Start by<a id="_idIndexMarker145"/> creating a <code>NumberAdder</code> class and define an <code>add</code> operation and a delay, as follows:<pre>private const val DELAY = 5000
class NumberAdder(
    private val dispatcher: CoroutineDispatcher = 
        Dispatchers.IO,
    private val delay: Int = DELAY
) {
    suspend fun add(a: Int, b: Int): Int {
        return withContext(dispatcher) {
            delay(delay.toLong())
            a + b
        }
    }
}</pre></li>
			</ol>
			<p>In this class, we will add our 5-second delay before performing the sum of the two numbers. This is to highlight the asynchronous operation more. <code>CoroutineDispatcher</code> and the amount we want to delay by will be injected through the constructor. This is because we want to unit-test this class.</p>
			<ol>
				<li value="5">Next, we will need to unit-test this class. Before we write the test, create a test rule so that <a id="_idIndexMarker146"/>we can reuse it for coroutines, as follows:<pre>class DispatcherTestRule : TestRule {
    @ExperimentalCoroutinesApi
    val testDispatcher = TestCoroutineDispatcher()
    @ExperimentalCoroutinesApi
    override fun apply(base: Statement?, description: 
        Description?): Statement {
        try {
            Dispatchers.setMain(testDispatcher)
            base?.evaluate()
        } catch (e: Exception) {
        } finally {
            Dispatchers.resetMain()
            testDispatcher.cleanupTestCoroutines()
        }
        return base!!
    }
}</pre></li>
			</ol>
			<p>In this class, we create a <code>TestCoroutineDispatcher</code> instance that will later be injected into the unit test so that the test can execute the sum in a synchronous way. <code>@ExperimentalCoroutinesApi</code> suggests that the usage of <code>TestCoroutineDispatcher</code> is still in an experimental state and will be moved to a stable version in the future.</p>
			<ol>
				<li value="6">Now, write <a id="_idIndexMarker147"/>the unit test for the class, in the form of <code>NumberAdderTest</code>, as follows:<pre>class NumberAdderTest {
    @get:Rule
    val dispatcherTestRule = DispatcherTestRule()
    @ExperimentalCoroutinesApi
    @Test
    fun testAdd() = runBlockingTest {
        val adder = NumberAdder(dispatcherTestRule.
            testDispatcher, 0)
        assertEquals(5, adder.add(1, 4))
    }
}</pre></li>
			</ol>
			<p>Here, we inject the <code>testDispatcher</code> object we created in  <code>DispatcherTestRule</code> into <code>NumberAdder</code>, and we then invoke the <code>add</code> function. The entire test is executed in a special <code>CoroutineScope</code> block called <code>runBlockingTest</code>, that will ensure all the coroutines launched must complete.</p>
			<ol>
				<li value="7">Next, go ahead and<a id="_idIndexMarker148"/> create a <code>ViewModel</code> class, like this:<pre>class MainViewModel(private val adder: NumberAdder = NumberAdder()) : ViewModel() {
    var resultState by mutableStateOf("0")
        private set
    fun add(a: String, b: String) {
        viewModelScope.launch {
            val result = adder.add(a.toInt(), 
                b.toInt())
            resultState = result.toString()
        }
    }
}</pre></li>
			</ol>
			<p>Here, we use a Compose state that will retain the result of the addition, and a method that will trigger the addition into <code>viewModelScope</code>.</p>
			<ol>
				<li value="8">After the <code>ViewModel</code> class has been created, go ahead and create an activity class, as follows: <pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Exercise201Theme {
                Surface {
                    Screen()
                }
            }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we initialize our activity with the content. <code>Exercise201Theme</code> should be replaced with the theme generated by Android Studio when the project was created. Typically, this<a id="_idIndexMarker149"/> should be in a <code>Theme</code> file and should be a <code>@Composable</code> function that has the application name followed by the <code>Theme</code> suffix. If that is not available, you can use <code>MaterialTheme</code> instead for the purpose of the exercise.</p>
			<ol>
				<li value="9">Next, create a <code>Screen</code> function, as follows:<pre>@Composable
fun Screen(viewModel: MainViewModel = viewModel()) {
    var a by remember { mutableStateOf("") }
    var b by remember { mutableStateOf("") }
    Calculator(
        a = a,
        onAChanged = {
            a = it
        },
        b = b,
        onBChanged = {
            b = it
        },
        result = viewModel.resultState,
        onButtonClick = {
            viewModel.add(a, b)
        })
}</pre></li>
			</ol>
			<p>In this method, we define variables for our text fields, then we pass the result of the addition of the numbers from the ViewModel, and finally, we invoke the ViewModel to perform the addition.</p>
			<ol>
				<li value="10">And finally, add the <code>Calculator</code> function from the exercise definition to the <code>MainActivity</code> file.</li>
			</ol>
			<p>If we run the preceding example, we should see our UI elements, and after inserting the numbers and clicking the button, we will get our result. One thing to notice is that the user will be able to interact with the UI while the <code>add</code> method is executed, and clicking multiple times for different numbers will get the results 5 seconds after each button press. </p>
			<p>Using coroutines can improve the quality of an Android application, especially when combined with Android extensions for the <code>ViewModel</code> class and lifecycle-aware components. Coroutines <a id="_idIndexMarker150"/>simplify the code we write for asynchronous operations, and the addition of the <code>suspend</code> keyword can enforce more rigor when dealing with these operations.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor045"/>Kotlin Flows</h2>
			<p>Coroutines offer a <a id="_idIndexMarker151"/>good solution for dealing with asynchronous operations; however, they do not offer a good ability to handle multiple streams of data in the same way RxJava does. Flows represent an extension to coroutines, which is meant to solve this problem. When dealing with flows, there are three entities to consider, as outlined here:</p>
			<ul>
				<li><strong class="bold">Producer</strong>: This <a id="_idIndexMarker152"/>entity is responsible for emitting the data.</li>
				<li><strong class="bold">Intermediary</strong>: This entity deals with the transformation or manipulation of the data.</li>
				<li><strong class="bold">Consumer</strong>: This entity consumes the data in the stream.</li>
			</ul>
			<p>Let's look at the<a id="_idIndexMarker153"/> following example of adding two numbers and how it might look like using Kotlin flows:</p>
			<pre>fun asyncSum(a: Int, b: Int): Flow&lt;Int&gt; {
        return flow {
            this.emit(a + b)
        }.flowOn(Dispatchers.IO)
    }</pre>
			<p>Here, we create a <code>Flow</code> object that will emit the result of <code>a + b</code> on a stream. The <code>flowOn</code> method will move the execution of the upstream on an I/O thread. Here, we note the similarity to RxJava in the concept of how <code>Flows</code> work, but we also notice that it's an extension of coroutines because of the use of <code>Dispatchers</code>. Let's now look at how flows look on the consumer side, as follows:</p>
			<pre>class MyClass : CoroutineScope {
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job
    private lateinit var job: Job
    @FlowPreview
    fun asyncComplicatedSum(a: Int, b: Int, c: Int) {
        launch {
            asyncSum(a, b)
                .flatMapConcat {
                    asyncSum(it, c)
                }
                .catch {
                    Log.d(this.javaClass.name, "Something 
                         went wrong")
                }
                .collect {
                    Log.d(this.javaClass.name, "Final sum 
                        $it")
                }
        }
    }
}</pre>
			<p>Here, we also notice <a id="_idIndexMarker154"/>similarities to RxJava—that is, when we try to manipulate the stream to perform the addition to number <code>c</code> and when it comes to error handling due to the <code>catch</code> method. The <code>collect</code> method, however, is closer to coroutines, and it requires a <code>CoroutineScope</code> to be used or to declare the calling method as a suspend one. </p>
			<p>Flows offer a couple of specialized classes for particular use cases: <code>StateFlow</code> and <code>SharedFlow</code>. The <code>StateFlow</code> class is useful because it will offer subscribers the last value stored when they subscribe, like how <code>LiveData</code> works. Flows can also be cold and hot, and <code>SharedFlow</code> is a specialized implementation of a hot flow. <code>SharedFlow</code> will emit items if it is kept in memory if there are any consumers or not. When a consumer subscribes to <code>SharedFlow</code>, it will also emit the last value stored to the consumer, as with <code>StateFlow</code>.</p>
			<p>In this section, we have looked at Kotlin flows and the benefits they provide when it comes to handling asynchronous operations. Next, we will look at how we can use Kotlin flows in an Android application through a simple exercise.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor046"/>Exercise 02.02 – Using Kotlin Flows</h2>
			<p>Modify the <a id="_idIndexMarker155"/>application from <em class="italic">Exercise 02.01</em> so that the addition of the two numbers will return a Flow instead of a suspended function.</p>
			<p>To complete the exercise, you will need to do the following:</p>
			<ul>
				<li>Rewrite the <code>add</code> function in <code>NumberAdder</code> to return a Flow.</li>
				<li>Change how the <code>ViewModel</code> invokes the <code>add</code> function.</li>
			</ul>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Modify the <code>add</code> function in <code>NumberAdder</code> to return a Flow, as follows:<pre>private const val DELAY = 5000
class NumberAdder(
    private val dispatcher: CoroutineDispatcher = 
        Dispatchers.IO,
    private val delay: Int = DELAY
) {
    suspend fun add(a: Int, b: Int): Flow&lt;Int&gt; {
        return flow {
            emit(a + b)
        }.onEach {
            delay(delay.toLong())
        }.flowOn(dispatcher)
    }
}</pre></li>
			</ol>
			<p>Here, we create a new Flow where we emit the sum of <code>a</code> and <code>b</code>, after which we put a delay on each item emitted in the stream, and finally, we specify the <code>CoroutineDispatcher</code> instance we wish to execute the sum on.</p>
			<ol>
				<li value="2">Next, let's <a id="_idIndexMarker156"/>modify the unit test for the sum, as follows:<pre>class NumberAdderTest {
    @get:Rule
    val dispatcherTestRule = DispatcherTestRule()
    @ExperimentalCoroutinesApi
    @Test
    fun testAdd() = runBlockingTest {
        val adder = NumberAdder
            (dispatcherTestRule.testDispatcher, 0)
        val result = adder.add(1, 4).first()
        assertEquals(5, result)
    }
}</pre></li>
			</ol>
			<p>Because the <code>add</code> method returns a <code>Flow</code> object, we must now find the first item emitted in the flow and assert the value of that item against our expected result.</p>
			<ol>
				<li value="3">Modify the <code>MainViewModel</code> class to consume the <code>add</code> operation, as follows: <pre>class MainViewModel(private val adder: NumberAdder = NumberAdder()) : ViewModel() {
    var resultState by mutableStateOf("0")
        private set
    fun add(a: String, b: String) {
        viewModelScope.launch {
            adder.add(a.toInt(), b.toInt())
                .collect {
                    resultState = it.toString()
                }
        }
    }
}</pre></li>
			</ol>
			<p>Here, the <code>add</code> method will still use the same <code>CoroutineScope</code> instance to launch the <code>add</code> method, which will now use the <code>collect</code> method to get the result of the sum.</p>
			<p>If we launch the<a id="_idIndexMarker157"/> application after following the steps from the exercise, the behavior will be the same as for <em class="italic">Exercise 02.01</em>, and we can see how Kotlin flows extend the functionality of coroutines by introducing concepts from RxJava to simplify how we can handle multiple streams of data.</p>
			<p>In this section, we've seen how handling asynchronous operations has evolved over time and how much our applications benefit from concepts such as coroutines and flows that provide management for background threads, simplify how we execute asynchronous operations, manage multiple streams of data, and can connect to the lifecycle of Android components. In the following section, we will look at tools we can use to fetch data from the network and how they can be integrated with Kotlin coroutines and flows.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor047"/>Using OkHttp and Retrofit for networking</h1>
			<p>In this<a id="_idIndexMarker158"/> section, we <a id="_idIndexMarker159"/>will look <a id="_idIndexMarker160"/>at<a id="_idIndexMarker161"/> how we can use the Retrofit library to perform networking operations and the benefits it provides.</p>
			<p>Many Android applications require the internet to access data stored on various servers. Often, this is done through <a id="_idIndexMarker162"/>the <code>HttpURLConnection</code> or Apache HttpClient. Working with either of these components meant that developers would need to manually handle the conversion from <strong class="bold">plain old Java objects</strong> (<strong class="bold">POJOs</strong>) to JSON, handle <a id="_idIndexMarker164"/>various network configurations, and deal with backward compatibility.</p>
			<p>The OkHttp library will address some of these issues through an <code>OkHttpClient</code> class that will handle various network configurations and that provides other features such as caching. The Retrofit library, which can be placed on top of the OkHttp library, is meant to ensure type safety when dealing with various data formats. It's very configurable and allows the<a id="_idIndexMarker165"/> possibility to plug in various converter libraries for POJO-to-JSON conversion or <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>) or other types of formats. </p>
			<p>In order to add Retrofit and OkHttp to the project, we will add the following dependencies to the <code>build.gradle</code> file:</p>
			<pre>dependencies {
    …
    implementation "com.squareup.okhttp3:okhttp:4.9.0"
    implementation "com.squareup.retrofit2:retrofit:2.9.0"
    …
}</pre>
			<p>Next, we will need to determine which converters we will need to use for the data. Because JSON is a common format, we will use a JSON converter and the Moshi library to do so, so we will need to add dependencies to these two libraries, as follows:</p>
			<pre>dependencies {
    …
    implementation "com.squareup.okhttp3:okhttp:4.9.0"
    implementation "com.squareup.retrofit2:retrofit:2.9.0"
    implementation "com.squareup.retrofit2:converter-moshi:2.9.0"
    implementation "com.squareup.moshi:moshi:1.13.0"
    …
}</pre>
			<p>Here, the Moshi library will be responsible for converting POJOs into JSON, and the converter library will plug into the Retrofit library and trigger this conversion when data is<a id="_idIndexMarker166"/> exchanged<a id="_idIndexMarker167"/> between <a id="_idIndexMarker168"/>the<a id="_idIndexMarker169"/> Android application and the server. </p>
			<p>Let's assume we will need to fetch data from a server in a JSON format. We can use the <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a> service as an example. If we want to fetch a list of users, we <a id="_idIndexMarker170"/>can use the <a href="https://jsonplaceholder.typicode.com/users">https://jsonplaceholder.typicode.com/users</a> <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>). A user's JSON representation looks like this:</p>
			<pre>{
"id": 1,
    "name": "Leanne Graham",
    "username": "Bret",
    "email": "Sincere@april.biz",
    "address": {
      "street": "Kulas Light",
      "suite": "Apt. 556",
      "city": "Gwenborough",
      "zipcode": "92998-3874",
      "geo": {
        "lat": "-37.3159",
        "lng": "81.1496"
      }
    },
    "phone": "1-770-736-8031 x56442",
    "website": "hildegard.org",
    "company": {
      "name": "Romaguera-Crona",
      "catchPhrase": "Multi-layered client-server neural-
          net",
      "bs": "harness real-time e-markets"
    }</pre>
			<p>We can see<a id="_idIndexMarker171"/> in <a id="_idIndexMarker172"/>the<a id="_idIndexMarker173"/> JSON<a id="_idIndexMarker174"/> representation that the user has an <code>id</code>, a <code>username</code>, an <code>email</code> value, and so on. In Kotlin, we can create a representation of this, and we can exclude properties that the application doesn't need, such as <code>email</code>, <code>address</code>, <code>phone</code>, <code>website</code>, and <code>company</code>, as follows:</p>
			<pre>    data class User(
        @Json(name = "id") val id: Long,
        @Json(name = "name") val name: String,
        @Json(name = "username") val username: String
    )</pre>
			<p>Here, we are using Moshi to map the property from a JSON to a Kotlin type, and we only kept three of the fields present in the initial JSON. Now, let's look at how we can initialize our networking libraries. The code to accomplish this is shown in the following snippet:</p>
			<pre>  fun createOkHttpClient() =  OkHttpClient
        .Builder()
        .readTimeout(15, TimeUnit.SECONDS)
        .connectTimeout(15, TimeUnit.SECONDS)
        .build()</pre>
			<p>For OkHttp, we use a <code>Builder</code> method to create a new <code>OkHttpClient</code> instance, and we can provide certain configurations for it. We will now use the <code>OkHttpClient</code> instance<a id="_idIndexMarker175"/> created<a id="_idIndexMarker176"/> previously<a id="_idIndexMarker177"/> to <a id="_idIndexMarker178"/>create a <code>Retrofit</code> instance, as follows:</p>
			<pre>fun createRetrofit(
        okHttpClient: OkHttpClient
    ): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://jsonplaceholder.typicode.com/")
            .client(okHttpClient)
            .build()
    }</pre>
			<p>Here, we create a new <code>Retrofit</code> instance that will have the base URL set to <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a>. Changing the base URL comes in handy during development. Many teams will have a development URL used internally to test the development and integration of features and will have a production URL where the actual user data is set. Now, we will need to connect the Moshi JSON serialization to the <code>Retrofit</code> instance, as follows:</p>
			<pre>Fun createConverterFactory(): MoshiConverterFactory = MoshiConverterFactory.create()</pre>
			<p>Here, we create <code>MoshiConverterFactory</code>, which is a Retrofit converter designed to connect <code>Retrofit</code> to the JSON serialization done by Moshi. We will now need to change our <code>Retrofit</code> initialization to what follows:</p>
			<pre>fun createRetrofit(
        okHttpClient: OkHttpClient,
        gsonConverterFactory: MoshiConverterFactory
    ): Retrofit {
        return Retrofit.Builder()
.baseUrl("https://jsonplaceholder.typicode.com/")
            .client(okHttpClient)
            .addConverterFactory(gsonConverterFactory)
            .build()
    }</pre>
			<p>Here, we <a id="_idIndexMarker179"/>add <a id="_idIndexMarker180"/>the <code>MoshiConverterFactory</code> converter<a id="_idIndexMarker181"/> to<a id="_idIndexMarker182"/> the Retrofit <code>Builder</code> method to allow the two components to work together. Finally, we can create a Retrofit interface that will have templates for the HTTP request, as follows:</p>
			<pre>interface UserService {
        @GET("/users")
        fun getUsers(): Call&lt;List&lt;User&gt;&gt;
        @GET("/users/{userId}")
        fun getUser(@Path("userId") userId: Int): 
            Call&lt;User&gt;
        @POST("/users")
        fun createUser(@Body user: User): Call&lt;User&gt;
        @PUT("/users/{userId}")
        fun updateUser(@Path("userId") userId: Int, @Body 
            user: User): Call&lt;User&gt;   
    }</pre>
			<p>This interface contains an example of various methods for getting, creating, updating, and deleting data on servers. Note that the return type of these methods is a <code>Call</code> object that offers the ability to execute HTTP requests synchronously or asynchronously. One of the things that makes Retrofit more appealing to developers is the fact that it can be integrated with other asynchronous libraries such as RxJava and coroutines. Translating<a id="_idIndexMarker183"/> the <a id="_idIndexMarker184"/>preceding <a id="_idIndexMarker185"/>example <a id="_idIndexMarker186"/>to coroutines will look something like this:</p>
			<pre>interface UserService {
        @GET("/users")
        suspend fun getUsers(): List&lt;User&gt;
        @GET("/users/{userId}")
        suspend fun getUser(@Path("userId") userId: Int): 
            User
        @POST("/users")
        suspend fun createUser(@Body user: User): User
        @PUT("/users/{userId}")
        suspend fun updateUser(@Path("userId") userId: Int, 
            @Body user: User): User
    }</pre>
			<p>In the preceding example, we add the <code>suspend</code> keyword to each method and we remove the dependency to the <code>Call</code> class. This allows us to execute these methods using coroutines. To create an instance of this class, we need to do the following:</p>
			<pre>fun createUserService(retrofit: Retrofit) = retrofit.create(UserService::class.java)</pre>
			<p>Here, we use the <code>Retrofit</code> instance created previously to create a new instance of <code>UserService</code>.</p>
			<p>In this section, we have analyzed how we can use OkHttp and Retrofit to load data from the internet and the benefits these libraries provide, especially when combined with Kotlin <a id="_idIndexMarker187"/>coroutines <a id="_idIndexMarker188"/>and<a id="_idIndexMarker189"/> flows. In <a id="_idIndexMarker190"/>the next section, we will create an Android application that will use these libraries to fetch and display data on the UI.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor048"/>Exercise 02.03 – Using OkHttp and Retrofit</h2>
			<p>Create an<a id="_idIndexMarker191"/> Android <a id="_idIndexMarker192"/>application that connects to <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a> and displays a list of users using OkHttp, Retrofit, and Moshi. For each user, we will display the name, username, and email.</p>
			<p>To complete the exercise, you will need to do the following:</p>
			<ul>
				<li>Create a <code>User</code> data class that will map the JSON representation of the user.</li>
				<li>Create a <code>UserService</code> class that will have a method to retrieve a list of users.</li>
				<li>Create a <code>ViewModel</code> class that will use <code>UserService</code> to retrieve a list of users.</li>
				<li>Implement an <code>Activity</code> class that will display a list of users.</li>
			</ul>
			<p>A UI list will be created using the following method:</p>
			<pre>@Composable
fun UserList(users: List&lt;User&gt;) {
    LazyColumn(modifier = Modifier.padding(16.dp)) {
        items(users) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(text = it.name)
                Text(text = it.username)
                Text(text = it.email)
            }
        }
    }
}</pre>
			<p>Follow<a id="_idIndexMarker193"/> these<a id="_idIndexMarker194"/> steps to complete the exercise:</p>
			<ol>
				<li value="1">Create an Android application with an <strong class="bold">Empty Compose Activity</strong>.</li>
				<li>At the top level of the <code>build.gradle</code> file, define the Compose library version, as follows:<pre>buildscript {
    ext {
        compose_version = '1.0.5'
    }
    … 
}</pre></li>
				<li>In the <code>app/build.gradle</code> file, add<a id="_idIndexMarker195"/> the<a id="_idIndexMarker196"/> following dependencies:<pre>dependencies {
    implementation 'androidx.core:core-ktx:1.7.0'
    implementation 'androidx.appcompat:appcompat:1.4.0'
    implementation 'com.google.android.material:material:1.4.0'
    implementation "androidx.compose.ui:ui:$compose_version"
    implementation "androidx.compose.material:material:$compose_version"
    implementation "androidx.compose.ui:ui-tooling-preview:$compose_version"
    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.4.0'
    implementation 'androidx.activity:activity-compose:1.4.0'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0'
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0"
    implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0"
    implementation "com.squareup.okhttp3:okhttp:4.9.0"
    implementation "com.squareup.retrofit2:retrofit:2.9.0"
    implementation "com.squareup.retrofit2:converter-moshi:2.9.0"
    implementation "com.squareup.moshi:moshi:1.13.0"
    implementation "com.squareup.moshi:moshi-kotlin:1.13.0"
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
    androidTestImplementation "androidx.compose.ui:ui-test-junit4:$compose_version"
    testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.5.0"
    debugImplementation "androidx.compose.ui:ui-tooling:$compose_version"
}</pre></li>
				<li>Now, add<a id="_idIndexMarker197"/> a <a id="_idIndexMarker198"/>permission for internet access to the <code>AndroidManifest.xml</code> file, as follows: <pre>&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</pre></li>
				<li>Now move on and create a class that will hold the user information, as follows:<pre>@JsonClass(generateAdapter = true)
data class User(
    @Json(name = "id") val id: Long,
    @Json(name = "name") val name: String,
    @Json(name = "username") val username: String,
    @Json(name = "email") val email: String
)</pre></li>
			</ol>
			<p>Here, we will hold the <code>id</code> field, which is generally a relevant field for distinguishing between different users and fields that we are required to display.</p>
			<ol>
				<li value="6">Next, create a <code>UserService</code> class that will fetch the user data, as follows:<pre>interface UserService {
    @GET("/users")
    suspend fun getUsers(): List&lt;User&gt;
}</pre></li>
			</ol>
			<p>Here, we will <a id="_idIndexMarker199"/>only<a id="_idIndexMarker200"/> have one method that will get a list of users from the <code>/users</code> path.</p>
			<ol>
				<li value="7">Now, we initialize<a id="_idIndexMarker201"/> the networking objects. Because we aren't using any <code>MainApplication</code> class, as follows:<pre>class MyApplication : Application() {
    companion object {
        <strong class="bold">lateinit var userService: UserService</strong>
    }
    override fun onCreate() {
        super.onCreate()
        val okHttpClient = OkHttpClient
            .Builder()
            .readTimeout(15, TimeUnit.SECONDS)
            .connectTimeout(15, TimeUnit.SECONDS)
            .build()
        val moshi = Moshi.Builder().
            add(KotlinJsonAdapterFactory()).build()
        val retrofit = Retrofit.Builder()
            .baseUrl("https://jsonplaceholder.typicode.com/")
            .client(okHttpClient)
            .addConverterFactory(MoshiConverterFactory.create(moshi))
            .build()
        userService = retrofit.create(UserService::class.java)
    }
}</pre></li>
			</ol>
			<p>Here, we<a id="_idIndexMarker202"/> are<a id="_idIndexMarker203"/> initializing our networking libraries and the <code>UserService</code> object. Currently, we are holding a static reference to this object, which is not a good idea in general. Normally, we would rely on DI frameworks to manage these networking dependencies. </p>
			<ol>
				<li value="8">In the <code>AndroidManifest.xml</code> file, add the following c<a id="_idTextAnchor049"/>ode:<pre>  &lt;application
        …
        android:name=".MyApplication"
        …&gt;</pre></li>
			</ol>
			<p>Given that we are inheriting from the <code>Application</code> class, we will need to add this class to the manifest.</p>
			<ol>
				<li value="9">Next, go ahead<a id="_idIndexMarker204"/> and<a id="_idIndexMarker205"/> create a <code>MainViewModel</code> class, as follows: <pre>class MainViewModel(private val userService: 
    UserService) : ViewModel() {
    var resultState by mutableStateOf
        &lt;List&lt;User&gt;&gt;(emptyList())
        private set
    init {
        viewModelScope.launch {
                val users = userService.getUsers()
                resultState = users
        }
    }
}
class MainViewModelFactory : ViewModelProvider.Factory {
    override fun &lt;T : ViewModel&gt; create(modelClass: 
        Class&lt;T&gt;): T =
        MainViewModel(MyApplication.userService) as T
}</pre></li>
			</ol>
			<p>The <code>MainViewModel</code> class will depend on the <code>UserService</code> class to get a list of <code>Users</code> and store them in a Compose state that will be used in the UI. Here, we are also creating a <code>MainViewModelFactory</code> class that will be responsible for injecting the <code>UserService</code> class into the <code>MainViewModel</code> class.</p>
			<ol>
				<li value="10">Now, we move<a id="_idIndexMarker206"/> on<a id="_idIndexMarker207"/> and create a <code>MainActivity</code> class, as follows:<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Exercise0203Theme {
                Surface {
                    Screen()
                }
            }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we initialize our activity with the content. The <code>Exercise203Theme</code> theme should be replaced with the theme generated by Android Studio when the project was created. Typically, this should be in a <code>Theme</code> file and should be a <code>@Composable</code> function that has the application name followed by the <code>Theme</code> suffix. If that is not available, you can use <code>MaterialTheme</code> instead for the purpose of the exercise.</p>
			<ol>
				<li value="11">Create a <code>Screen</code> method in which we will grab a list of users from the <code>MainViewModel</code> class and draw a list of items, as follows:<pre>@Composable
fun Screen(viewModel: MainViewModel = viewModel
    (factory = MainViewModelFactory())) {
    UserList(users = viewModel.resultState)
}</pre></li>
				<li>And finally, add the <code>UserList</code> function from the exercise definition into the <code>MainActivity</code> file.</li>
			</ol>
			<p>If we launch the application after following the steps from the exercise, we should be able to see a list of users being loaded if the device has internet access.</p>
			<p>In this section, we have seen how we can typically retrieve data from the internet in an Android application. We have looked at libraries such as OkHttp and Retrofit and seen how straightforward it is to make HTTP calls in a type-safe way without converting JSON files to data classes<a id="_idIndexMarker208"/> manually. We have also observed the potential of these libraries<a id="_idIndexMarker209"/> due to their integration with asynchronous technologies such as RxJava and coroutines. In the following section, we will look at libraries used for persisting data and how we can integrate them with networking libraries as well as coroutines and flows.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor050"/>Using the Room library for data persistence</h1>
			<p>In this <a id="_idIndexMarker210"/>section, we will discuss how to persist data in <a id="_idIndexMarker211"/>Android applications and how we can use the Room library to do this.</p>
			<p>Android offers many ways for persisting data on an Android device, mostly involving files. Some of these files have a specialized approach to persisting data. One of these approaches is in the form of SQLite. SQLite is a special type of file in which structured data can be <a id="_idIndexMarker212"/>stored using <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) queries, as with other types of databases such as MySQL and Oracle. </p>
			<p>In the past, if developers wanted to persist data in SQLite, they were required to manually define tables, write queries, and transform objects containing this data into the appropriate formats for<a id="_idIndexMarker213"/> performing <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations. This type of work involved a load of boilerplate code that was susceptible to bugs. Room is the answer to that by providing an abstraction layer on top of the SQLite operations. </p>
			<p>In order to add Room to an application, we will need to add the following libraries in <code>build.gradle</code>:</p>
			<pre>dependencies {
    …
    implementation "androidx.room:room-runtime:2.4.0"
    kapt "androidx.room:room-compiler:2.4.0"
    …
}</pre>
			<p>The reason<a id="_idIndexMarker214"/> for<a id="_idIndexMarker215"/> the <code>kapt</code> usage is that Room uses annotations that will generate the code required for the interaction with the SQLite layer. In order to use the <code>kapt</code> feature, we will need to add the plugin to the <code>build.gradle</code> file, as follows:</p>
			<pre>plugins {
    …
    id 'kotlin-kapt'
}</pre>
			<p>This will allow the build system to analyze annotations across the project that require code generation and generate the necessary classes based on the provided annotations.</p>
			<p>The data we want to store is annotated with the <code>@Entity</code> annotation, as illustrated in the following code snippet:</p>
			<pre>@Entity(tableName = "user")class UserEntity(
    @PrimaryKey @ColumnInfo(name = "id") val id: Long,
    @ColumnInfo(name = "name") val name: String,
    @ColumnInfo(name = "username") val username: String
)</pre>
			<p>Here, we have defined a Room entity named <code>UserEntity</code> that will represent a table named <code>user</code> and<a id="_idIndexMarker216"/> has the <code>@ColumnInfo</code> annotation is for the name the column will have in the database.</p>
			<p>A typical set of <a id="_idIndexMarker217"/>CRUD <a id="_idIndexMarker218"/>operations might look like this:</p>
			<pre>@Dao
interface UserDao {
    @Query("SELECT * FROM user")
    fun getAll(): List&lt;UserEntity&gt;
    @Query("SELECT * FROM user WHERE id IN (:userIds)")
    fun loadAllByIds(userIds: IntArray): List&lt;UserEntity&gt;
    @Insert
    fun insert(vararg users: User)
    @Update
    fun update(vararg users: User)
    @Delete
    fun delete(user: User)
}</pre>
			<p>Just as how we defined in Retrofit a service interface to communicate with the server, we also define a similar interface for Room that we annotate with <code>@Dao</code>, for <strong class="bold">data access object</strong> (<strong class="bold">DAO</strong>). In this<a id="_idIndexMarker219"/> example, we have defined a set of functions for getting all users stored in a table, finding users, inserting new users, updating a user, and deleting a user.</p>
			<p>As with Retrofit, Room also provides integrations with coroutines, as illustrated in the following <a id="_idIndexMarker220"/>code<a id="_idIndexMarker221"/> snippet:</p>
			<pre>@Dao
interface UserDao {
    @Query("SELECT * FROM user")
    suspend fun getAll(): List&lt;UserEntity&gt;
    @Query("SELECT * FROM user WHERE id IN (:userIds)")
    suspend fun loadAllByIds(userIds: IntArray): 
        List&lt;UserEntity&gt;
    @Insert
    suspend fun insert(vararg users: User)
    @Update
    suspend fun update(vararg users: User)
    @Delete
    suspend fun delete(user: User)
}</pre>
			<p>In the preceding example, we add the <code>suspend</code> keyword, which makes the Room library easy to integrate and execute as part of a coroutine.</p>
			<p>On top of coroutines, the Room library also can integrate with Kotlin flows. This is useful for queries that will emit events every time a particular table has changed. This integration will look something like this:</p>
			<pre>@Dao
interface UserDao {
    @Query("SELECT * FROM user")
    fun getAll(): Flow&lt;List&lt;UserEntity&gt;&gt;
    @Query("SELECT * FROM user WHERE id IN (:userIds)")
    fun loadAllByIds(userIds: IntArray): 
        Flow&lt;List&lt;UserEntity&gt;&gt;
}</pre>
			<p>In the <a id="_idIndexMarker222"/>preceding <a id="_idIndexMarker223"/>example, we have changed the <code>@Query</code> functions to return a <code>Flow</code> object. If a change occurs in the user table, then the queries will be re-triggered and a new list of users will be emitted.</p>
			<p>We will now need to set up the database, as follows:</p>
			<pre>@Database(entities = [UserEntity::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}</pre>
			<p>In the preceding snippet, we define a new class that extends from the <code>RoomDatabase</code> class and use the <code>@Database</code> annotation to declare our entities and the current version. This version is used to keep track of migrations when the structure of the database changes in between new releases of our application.</p>
			<p>To initialize the database, we will need to execute the following code:</p>
			<pre>val db = Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java, "name"
        ).build()</pre>
			<p>This will create our SQLite database and will return an instance of <code>AppDatabase</code> where we can access the DAO objects we have defined and invoke their methods to process the data.</p>
			<p>In this section, we have looked at how we can persist data using Room and how it can be integrated with coroutines and flows. In the next section, we will create an Android application that <a id="_idIndexMarker224"/>will <a id="_idIndexMarker225"/>use Room to persist data and look at how it can be integrated with Retrofit and OkHttp.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor051"/>Exercise 02.04 – Using Room to persist data</h2>
			<p>Integrate Room into <em class="italic">Exercise 02.03</em> so that when the users are loaded from Retrofit, they will be stored in the database and then displayed on the UI.</p>
			<p>To complete the exercise, you will need to do the following:</p>
			<ol>
				<li value="1">Create a <code>UserEntity</code> class that will be a Room entity.</li>
				<li>Create a <code>UserDao</code> class that will contain methods for inserting users and querying all the users as flows.</li>
				<li>Create an <code>AppDatabase</code> class that will represent the application's database.</li>
				<li>Modify the <code>MainViewModel</code> class to fetch users from the <code>UserService</code> class and then insert them into the <code>UserDao</code> class.</li>
				<li>Modify the <code>MainActivity</code> class to use a list of <code>UserEntity</code> objects instead of <code>User</code> objects.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Add the <code>kapt</code> plugin to the <code>app/build.gradle</code> file, as follows:<pre>plugins {
    …
    id 'kotlin-kapt'
}</pre></li>
				<li>Add Room dependencies to <code>app/build.gradle</code>, as follows:<pre>dependencies {
    … 
    implementation "androidx.room:room-runtime:2.4.0"
    implementation "androidx.room:room-ktx:2.4.0"
    kapt "androidx.room:room-compiler:2.4.0"
    …
}</pre></li>
				<li>Create<a id="_idIndexMarker226"/> a <code>UserEntity</code> class, as<a id="_idIndexMarker227"/> follows:<pre>@Entity(tableName = "user")
class UserEntity(
    @PrimaryKey @ColumnInfo(name = "id") val id: Long,
    @ColumnInfo(name = "name") val name: String,
    @ColumnInfo(name = "username") val username:
        String,
    @ColumnInfo(name = "email") val email: String
)</pre></li>
			</ol>
			<p>The <code>UserEntity</code> class has the same fields as the <code>User</code> class, and it contains the Room annotations for the table name and the names of each column.</p>
			<ol>
				<li value="4"> Next, create a <code>UserDao</code> class, as follows:<pre>@Dao
interface UserDao {
    @Query("SELECT * FROM user")
    fun getUsers(): Flow&lt;List&lt;UserEntity&gt;&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertUsers(users: List&lt;UserEntity&gt;)
}</pre></li>
			</ol>
			<p>Here, we are using flows to return a list of users, and we use the <code>OnConflictStrategy.REPLACE</code> option so that if the same user is inserted multiple times, then it will be replaced with the one that will be inserted. Other options include <code>OnConflictStrategy.ABORT</code>, which will drop the entire transaction if a conflict occurs, or <code>OnConflictStrategy.IGNORE</code>, which will<a id="_idIndexMarker228"/> skip <a id="_idIndexMarker229"/>inserting rows where a conflict occurs.</p>
			<ol>
				<li value="5">Now, go ahead and create an <code>AppDatabase</code> class, as follows:<pre>@Database(entities = [UserEntity::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
} </pre></li>
			</ol>
			<p>In <code>AppDatabase</code>, we provide the <code>UserDao</code> class to be accessed and we use the <code>UserEntity</code> class for the users' table.</p>
			<ol>
				<li value="6">Next, we will need to initialize the <code>AppDatabase</code> object, as follows:<pre>class MyApplication : Application() {
    companion object {
        …
        lateinit var userDao: UserDao 
        …
    }
    override fun onCreate() {
        super.onCreate()
        …
        val db = Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java, "my-database"
        ).build()
        userDao = db.userDao()
        …
    }
} </pre></li>
			</ol>
			<p>Here, we are having the same issues that we had for Retrofit, so we will follow the <a id="_idIndexMarker230"/>same<a id="_idIndexMarker231"/> approach and use the <code>Application</code> class. Just as with Retrofit, a DI framework will help us solve this problem.</p>
			<ol>
				<li value="7">Now, let's integrate Room into the <code>MainViewModel</code> class, as follows:<pre>class MainViewModel(
    private val userService: UserService,
    <strong class="bold">private val userDao: UserDao</strong>
) : ViewModel() {
    var resultState by mutableStateOf&lt;List&lt;<strong class="bold">UserEntity</strong>&gt;&gt;(emptyList())
        private set
    init {
        viewModelScope.launch {
<strong class="bold">            flow { emit(userService.getUsers()) }</strong>
<strong class="bold">                .onEach {</strong>
<strong class="bold">                val userEntities =</strong>
<strong class="bold">                    it.map { user -&gt; UserEntity</strong>
<strong class="bold">                        (user.id, user.name, </strong>
<strong class="bold">                         user.username, user.email) }</strong>
<strong class="bold">                userDao.insertUsers(userEntities)</strong>
<strong class="bold">            }.flatMapConcat { userDao.getUsers() }</strong>
<strong class="bold">                .catch { emitAll(userDao.getUsers()) }</strong>
<strong class="bold">                .flowOn(Dispatchers.IO)</strong>
<strong class="bold">                .collect {</strong>
<strong class="bold">                    resultState = it</strong>
<strong class="bold">                }</strong>
<strong class="bold">        }</strong>
    } 
}
class MainViewModelFactory : ViewModelProvider.Factory {
    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T =
        MainViewModel(MyApplication.userService, <strong class="bold">MyApplication.userDao</strong>) as T
} </pre></li>
			</ol>
			<p>The <code>MainViewModel</code> class now has a new dependency on the <code>UserDao</code> class. In the <code>init</code> block, we now create a flow in which we emit a list of users obtained from Retrofit that is then converted into <code>UserEntity</code> and inserted into the database. After this, we will query the <code>UserEntities</code> instances and return them in a stream that will be the result. If we have an error, we will return the current stored users.</p>
			<ol>
				<li value="8">Finally, update<a id="_idIndexMarker232"/> the type of users in the <code>MainActivity</code> class, as <a id="_idIndexMarker233"/>follows:<pre>class MainActivity : ComponentActivity() {
…
@Composable
fun UserList(users: List&lt;<strong class="bold">UserEntity</strong>&gt;) {
…
    }
} </pre></li>
			</ol>
			<p>Here, we just change the dependency to now rely on the <code>UserEntity</code> class.</p>
			<p>If we run the application after following the steps from the exercise, we will see the same output as for <em class="italic">Exercise 02.03</em>. However, if we close the application, turn on Airplane mode on the device, and reopen the app, we will still see the previously displayed information.</p>
			<p>In this section, we have<a id="_idIndexMarker234"/> analyzed how we can persist structured data on a <a id="_idIndexMarker235"/>device and used the Room library to do so. We have also observed the interaction between Room and other libraries such as Retrofit and flows and how we can use flows to combine data streams from Room and Retrofit in a very straightforward way. In the next section, we will look at how we can persist simple data in key-value pairs.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor052"/>Understanding and using the DataStore library</h1>
			<p>In this section, we <a id="_idIndexMarker236"/>will <a id="_idIndexMarker237"/>discuss how we can persist key-value pairs of data and how we can use the DataStore library for this. In Android, we have the possibility of persisting primitives and strings in key-value pairs. In the past, this was done through the <code>SharedPreferences</code> class, which was part of the Android framework. The keys and values would ultimately be saved inside an XML file on the device. Because this deals with I/O operations, it evolved over time to give the possibility to save data asynchronously and to keep an in-memory cache for quick access to data. There were, however, some inconsistencies with this, especially when the <code>SharedPreferences</code> object was initialized. DataStore is designed to address these issues because it's integrated with coroutines and flows. </p>
			<p>To add DataStore to a project, we will need the following dependency:</p>
			<pre>dependencies {
    …
    implementation "androidx.datastore:datastore-preferences:1.0.0"
    …
} </pre>
			<p>Using DataStore will look something like this:</p>
			<pre>private val KEY_TEXT = stringPreferencesKey("key_text")
class AppDataStore(private val dataStore: 
    DataStore&lt;Preferences&gt;) {
    val savedText: Flow&lt;String&gt; = dataStore.data
        .map { preferences -&gt;
            preferences[KEY_TEXT].orEmpty()
        }
    suspend fun saveText(text: String) {
        dataStore.edit { preferences -&gt;
            preferences[KEY_TEXT] = text
        }
    }
}</pre>
			<p>The <code>KEY_TEXT</code> field will represent a key that will be used to store some text. <code>DataStore&lt;Preferences&gt;</code> is responsible for obtaining and writing the data to <code>SharedPreferences</code>. The <code>savedText</code> field will monitor changes in the preferences and will emit a new value for each change in a <code>Flow</code> object. To write data in an asynchronous way, we will need to edit the current data store and set the value associated with the key.</p>
			<p>To initialize the DataStore library, we will need to declare the following as a top-level declaration:</p>
			<pre>val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = "my_preferences")</pre>
			<p>This will allow us to access the DataStore library in the rest of the application.</p>
			<p>When we want to initialize <code>AppDataStore</code>, we can use the following code:</p>
			<pre>val appDataStore = AppDataStore(dataStore) </pre>
			<p>This allows us to wrap the <code>DataStore</code> class and avoid exposing the dependencies to other places in the application.</p>
			<p>In this<a id="_idIndexMarker238"/> section, we<a id="_idIndexMarker239"/> have looked at how we can persist data in key-value pairs and how we can use the DataStore library to do this. In the next section, we will create an Android application that will use DataStore and integrate it with Kotlin flows and coroutines.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor053"/>Exercise 02.05 – Using DataStore to persist data</h2>
			<p>Modify <em class="italic">Exercise 02.04</em> and<a id="_idIndexMarker240"/> introduce the DataStore library, which <a id="_idIndexMarker241"/>will persist the number of executed requests to get the user and display this number above the list of items.</p>
			<p>To complete the exercise, you will need to do the following:</p>
			<ul>
				<li>Create a class named <code>AppDataStore</code> that will manage interaction with the DataStore library.</li>
				<li>Modify the <code>MainViewModel</code> class so that the <code>AppDataStore</code> dependency is injected and used to retrieve the current number of requests and increment the number of requests.</li>
				<li>Modify the <code>MainActivity</code> class to add a new <code>Text</code> object that will display the count of requests.</li>
			</ul>
			<p>Follow these steps <a id="_idIndexMarker242"/>to<a id="_idIndexMarker243"/> complete the exercise:</p>
			<ol>
				<li value="1">Add the following dependency to the <code>app/build.gradle</code> file:<pre>dependencies {
    …
    implementation "androidx.datastore:datastore-
        preferences:1.0.0"
    …
}</pre></li>
				<li>Create an <code>AppDataStore</code> class, as follows:<pre>private val KEY_COUNT = intPreferencesKey("key_count")
class AppDataStore(private val dataStore: 
    DataStore&lt;Preferences&gt;) {
    val savedCount: Flow&lt;Int&gt; = dataStore.data
        .map { preferences -&gt;
            preferences[KEY_COUNT] ?: 0
        }
    suspend fun incrementCount() {
        dataStore.edit { preferences -&gt;
            val currentValue = preferences[KEY_COUNT] 
                ?: 0
            preferences[KEY_COUNT] = currentValue.
                inc()
        }
    }
}}</pre></li>
			</ol>
			<p>Here, <code>KEY_COUNT</code> represents the key used by the DataStore library to store the number of requests. The <code>saveCount</code> field will emit a new count value every time<a id="_idIndexMarker244"/> it <a id="_idIndexMarker245"/>changes, and <code>incrementCount</code> will be increment the current saved number by 1.</p>
			<ol>
				<li value="3">Now, set up the <code>AppDataStore</code> dependency, just like how we handled the Retrofit and Room dependencies. The code is illustrated in the following snippet:<pre>val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = "my_preferences")
class MyApplication : Application() {
    companion object {
        …
        lateinit var appDataStore: AppDataStore
    }
    override fun onCreate() {
        super.onCreate()
        …
        appDataStore = AppDataStore(dataStore)
    }
}</pre></li>
			</ol>
			<p>Here, we initialize the <code>DataStore</code> object and then inject it into the <code>AppDataStore</code> class.</p>
			<ol>
				<li value="4">Next, modify<a id="_idIndexMarker246"/> the <code>MainViewModel</code> class, as<a id="_idIndexMarker247"/> follows:<pre>class MainViewModel(
    private val userService: UserService,
    private val userDao: UserDao,
    <strong class="bold">private val appDataStore: AppDataStore</strong>
) : ViewModel() {
    var resultState by mutableStateOf(<strong class="bold">UiState()</strong>)
        private set
    init {
        viewModelScope.launch {
            flow { emit(userService.getUsers()) }
                .onEach {
                    val userEntities =
                        it.map { user -&gt; UserEntity
                            (user.id, user.name, user.
                             username, user.email) }
                    userDao.insertUsers(userEntities)
                    <strong class="bold">appDataStore.incrementCount()</strong>
                }.flatMapConcat { userDao.getUsers() }
                .catch { emitAll(userDao.getUsers()) }
<strong class="bold">                .flatMapConcat { users -&gt;</strong>
<strong class="bold">                    appDataStore.savedCount.map { </strong>
<strong class="bold">                        count -&gt; UiState(users,  </strong>
<strong class="bold">                            count.toString()) }</strong>
<strong class="bold">                }</strong>
                .flowOn(Dispatchers.IO)
                .collect {
                    resultState = it
                }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we<a id="_idIndexMarker248"/> add <a id="_idIndexMarker249"/>a new dependency to <code>AppDataStore</code>, then we call <code>incrementCount</code> from <code>AppDataStore</code> after the users from Retrofit are inserted, and then we will insert <code>savedCount</code> from <code>AppDataStore</code> into the existing flow and create a new <code>UiState</code> object that contains a list of users and the count, which will be collected in the <code>resultState</code> object.</p>
			<ol>
				<li value="5">The <code>UiState</code> class will look something like this:<pre>data class UiState(
    val userList: List&lt;UserEntity&gt; = listOf(),
    val count: String = ""
)</pre></li>
			</ol>
			<p>This class will hold information from both of our persistent data sources.</p>
			<ol>
				<li value="6">Next, change<a id="_idIndexMarker250"/> <code>MainViewModelFactory</code>, as <a id="_idIndexMarker251"/>follows:<pre>class MainViewModelFactory : ViewModelProvider.Factory {
    override fun &lt;T : ViewModel&gt; create(modelClass: 
        Class&lt;T&gt;): T =
        MainViewModel(
            MyApplication.userService,
            MyApplication.userDao,
            <strong class="bold">MyApplication.appDataStore</strong>
        ) as T
}</pre></li>
			</ol>
			<p>Here, we will inject a new dependency to <code>AppDataStore</code> into the <code>MainViewModel</code> class.</p>
			<ol>
				<li value="7">Finally, modify the <code>MainActivity</code> class, as follows:<pre>@Composable
fun UserList(uiState: UiState) {
    LazyColumn(modifier = Modifier.padding(16.dp)) {
        item(uiState.count) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(text = uiState.count)
            }
        }
        items(uiState.userList) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(text = it.name)
                Text(text = it.username)
                Text(text = it.email)
            }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker252"/>replaced<a id="_idIndexMarker253"/> the list of <code>UserEntity</code> with the <code>UiState</code> dependency and added a new row in a list of items that will indicate the count of requests.</p>
			<p>If we run the application, we will see at the top the current count of requests made to the server. If we kill and reopen the application, then we will see that count increase, which shows how it will survive the application being stopped by the user or killed by the operating system.</p>
			<p>In this section, we have analyzed another common way of persisting data on an Android device through the DataStore library. We also observed how easy it is for the DataStore library to be integrated with flows and other libraries such as Room and Retrofit. </p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor054"/>Summary</h1>
			<p>In this chapter, we have looked at how we can load and persist data in Android and the rules we must follow for threading. We first analyzed how we can load data asynchronously and focused on coroutines and flows, for which we have done simple exercises for performing asynchronous operations on different threads and updating the UI on the main thread. We then studied how to load data from the internet using OkHttp and Retrofit, and followed this up with how to persist data using Room and DataStore and how we can integrate all of these with coroutines and flows. We highlighted the usage of these libraries in exercises, and we also showed how they can be integrated with coroutines and flows. The integration of different flows of data was combined in the <code>ViewModel</code> class, in which we loaded the network data and inserted it into the local database. This is generally not a good approach, and we will expand on how we can improve this in future chapters.</p>
			<p>In the next chapter, we will look at how we can present data to the user and the libraries and frameworks we can use to achieve this.</p>
		</div>
	</body></html>