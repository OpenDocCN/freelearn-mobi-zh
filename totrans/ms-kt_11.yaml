- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Code Quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we develop our Android apps, we must ensure that the code we write complies
    with the set rules and follows the best practices. This not only helps us to write
    good code but also makes it easier to maintain and easily onboard others to the
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the Kotlin style and the best practices
    for writing Kotlin code. We will also learn how to use plugins such as Ktlint
    and Detekt to format, lint, and detect the code smells early.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Kotlin style and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ktlint for static analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting code smells with Detekt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven)
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Kotlin style and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 1*](B19779_01.xhtml#_idTextAnchor015), Kotlin is
    a very concise and static language. As such, it is easier for us as developers
    to not follow some of the recommended practices. This leads to a lot of code smells
    and technical debt. A **code smell** is a pattern or practice that might indicate
    a deeper problem within the code. It indicates that the code might lead to potential
    problems or hinder maintainability. On the other hand, **technical debt** refers
    to the cost or consequences of choosing quick and suboptimal solutions in development
    to meet immediate needs rather than developing robust and maintainable solutions.
    We always have to come back later to such solutions to refactor them to be more
    scalable and maintainable. Let us start by learning about some of the best practices
    and how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Coding conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin has a wide variety of coding conventions that cover everything from
    naming conventions to formatting. Following these conventions makes it easier
    to read our code and makes it maintainable. Examples of these are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names should be in **camelCase**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class names should be in **PascalCase**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants should be in **UPPERCASE**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions should be in **camelCase**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with multiple words should be separated by **underscores**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with a single expression should be **inlined**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin offers a lot of coding conventions. You can find them at [https://kotlinlang.org/docs/coding-conventions.html](https://kotlinlang.org/docs/coding-conventions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Null safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed extensively in [*Chapter 1*](B19779_01.xhtml#_idTextAnchor015),
    Kotlin has a very strong `null`. When working with nullable types, it is recommended
    that we use the safe call operator (`?.`) and the Elvis operator (`?:`) to avoid
    null pointer exceptions. We should also use the `let` function to perform operations
    on nullable types. We should also use the safe cast operator (`as?`) to avoid
    class cast exceptions. An example is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declared a `name` variable of the `String` type
    and assigned it `null`. Then, we used the `let` function to check whether the
    variable is `null` or not. If the variable is not `null`, then the `println(it)`
    function will print the value of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin makes it easy for us to create `equals`, `hashCode`, `toString`, and
    `copy` functions. We should use data classes when we need to hold data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created a `Person` data class with two properties:
    `name` (which is a `String` type) and `age` (which is an `Int` type).'
  prefs: []
  type: TYPE_NORMAL
- en: Extensions functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin provides **extension functions**, which allow us to add new functions
    to new classes without having to inherit from them. This will help us avoid creating
    utility classes. While extension functions are powerful, overuse or inappropriate
    use can lead to code that is hard to read and maintain. An example is shown in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created an extension function on the `String`
    class. The function removes the first and last character of the string and returns
    the remaining string. Additionally, we used the `when` expression to check whether
    the length of the string is less than or equal to `1`. If the length is less than
    or equal to `1`, then the function returns an empty string. Otherwise, it returns
    the substring of the string from index 1 to the length of the string – `1`. We
    used the extension function in the `main` function to remove the first and last
    character of the `"Hello Everyone"` string. The result is then printed to the
    console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin has a very strong type system. As such, we can omit specifying the type
    of a variable and let the compiler infer the type. This will help us avoid a lot
    of boilerplate code. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin has a rich `List`, `Set`, `Map`, `Array`, and `Sequence` as collection
    types available in Kotlin. Collections can either be `mutable` or `immutable`.
    A `mutable` collection can be modified after creation, while an `immutable` collection
    cannot be modified after creation. An example of a `mutable` list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created a `mutable` list of strings. We used the
    `mutableListOf` function to create the list. We then added a new string to the
    list using the `add` function. An example of an `immutable` list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created an `immutable` list of strings. We used
    the `listOf` function to create the list. We cannot add or remove items from the
    list after creation. We can only read items from the list. Kotlin collections
    also have a wide variety of functions that can be used to perform operations on
    collections. We should use these functions instead of writing our own functions.
    This helps us make our code concise and readable. Let us see the following example
    of creating a list and filtering odd and even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created a list of numbers. We then used the `filter`
    function to filter even and odd numbers. The `filter` function takes a lambda
    as an argument. The lambda is used to filter the numbers. The `filter` function
    returns a new list with the filtered numbers. We used the `it` keyword to refer
    to the current item in the list. We then used the `%` operator to check whether
    the number is even or odd. If the number is even, then the `filter` function returns
    `true` and the number is added to the `evenNumbers` variable. For odd numbers,
    the `filter` function returns `false` and the number is added to the `oddNumbers`
    variable. Kotlin collections also have functions such as `map`, `reduce`, `fold`,
    `flatMap`, and so on. We should use these functions instead of writing our own
    functions. This helps us make our code concise and readable.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin provides **sealed classes**, which are used to represent restricted
    class and interface hierarchies. This improves code readability and ensures that
    we know all the possible subclasses of a class. Here’s an example of a sealed
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created a sealed class called `Shape`. We then
    created three classes (`Circle`, `Square`, and `Rectangle`), which are subclasses
    of the `Shape` class. The `Shape` class can only be extended in the same file
    where it is declared. We cannot extend the `Shape` class in another file.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use four spaces for indentation in Kotlin. However, note that this is a convention
    and not a strict rule. We should always ensure that our code is properly formatted
    as per the conventions agreed upon by the team or company
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should take advantage of Kotlin **functional programming** features such
    as **lambdas**, **higher-order functions**, and **inline functions**. This will
    help us make our code more concise and readable. An example is shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin provides **coroutines**, which are used to perform asynchronous operations.
    They are very lightweight and easy to use and help us avoid callback hell. We
    should use coroutines when we need to perform asynchronous operations. An example
    of a coroutine in Kotlin is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used `viewModelScope` to launch a coroutine. This
    is to ensure that the coroutine is canceled when the view model is destroyed.
    We used the `launch` coroutine builder to create a new coroutine. Inside the `launch`
    lambda, we performed our network call, which is supposed to happen in the background.
    We used the `async` coroutine builder, which allows us to await the result of
    the network call. The `async` coroutine builder returns a `Deferred` object. Lastly,
    we updated the UI with the result of the network call.
  prefs: []
  type: TYPE_NORMAL
- en: The when statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin provides `when` statements, which are used to replace `switch` statements.
    We should use `when` statements when we need to perform conditional operations.
    If we have blocks with more than one `if` `else` statement, we should consider
    using `when` statements. An example is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Classes and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kotlin allows us to declare multiple classes in a single file. We should use
    this feature to avoid creating a lot of files, especially for classes that are
    closely related. We should, however, be keen not to have bloated files with a
    lot of classes, so we should use this feature with caution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to ensure that we define only one **primary constructor** per class.
    Instead of overloading the constructor with a second one, we can always consider
    using default values for the constructor parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use **companion objects** to create static members. Both Kotlin’s companion
    objects and Java’s **static members** facilitate the creation of class-level members
    that can be accessed without creating an instance of the class. However, Kotlin’s
    companion objects provide additional flexibility by allowing access to non-static
    members and offer a more expressive syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should always avoid returning `null` from functions. Instead, we should use
    nullable types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can always use **scope functions** to perform operations on objects. This
    will help us avoid creating a lot of temporary variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just a small list of best practices. As the code base grows, it’s hard
    at times to keep track of all the best practices. This is where static code analysis
    tools come in handy. They help us identify code smells and technical debt. They
    also help us identify bugs and security vulnerabilities. In the next section,
    we will learn about some of the static code analysis tools that we can use to
    improve the quality of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ktlint for static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the official documentation, ktlint is “*an anti-bikeshedding Kotlin
    linter with a built-in formatter*.” It helps us do `gradle` tasks that allow us
    to run `ktlint` on our project. We are also able to do auto-formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Ktlint in our project, we need to add the Ktlint plugin to our project’s
    `build.gradle.kts` file in the plugins block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Tap the `build.gradle.kts` file below the plugins block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will apply the plugin to all the project modules. Tap the `ktlint` block.
    In our case, we are setting the `verbose` and `android` properties to `true`.
    We are also excluding the `generated` folder from the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we are ready to use Ktlint. First, though, let’s disable some formatting
    options. To do this, we need to create an `.editorconfig` file in the root of
    our project. In the file, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This disables some formatting options, the key one being `insert_final_newline`
    at the end of each file. This is especially useful for existing projects as it
    prevents us from having to reformat the whole project. If you need to customize
    Ktlint behavior, this is the file you use to enable or disable some options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now run the `ktlintCheck` task. To do this, let us open the **Terminal**
    tab in our IDE and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After the task completes, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Ktlint check failure](img/B19779_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Ktlint check failure
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Ktlint check failure continued](img/B19779_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Ktlint check failure continued
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding figures, we can see that the task was completed with failures,
    which means our project is not correctly formatted. The output also shows the
    specific formatting error and the file. We can see indentation, formatting, and
    new lines issues. We can opt to fix the issues by ourselves but, first, we should
    always check whether the Ktlint formatter can fix the issues for us. To do this,
    we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run the `ktlintFormat` task. After the task is completed, we will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – ktlintFormat successful](img/B19779_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – ktlintFormat successful
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding figure, the task was completed successfully. This
    means the Ktlint formatter was able to fix the issues for us. If the Ktlint formatter
    is not able to fix the issues, it normally highlights the issues that the plugin
    is not able to fix and shows the file and line number. We can then fix the issues
    manually. For now, we don’t have such issues. We can now run the `ktlintCheck`
    task again to confirm that the issues have been fixed. After the task completes,
    we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – ktlintFormat successful](img/B19779_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – ktlintFormat successful
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding figure, the build was successful. This means our project
    is correctly formatted. By using the Git tool in our IDE by pressing *Command*
    + *K* on macOS and *Ctrl* + *K* on Windows, we can see the files that have changes
    and see the changes made by the Ktlint formatter. From our project, this is what
    the commit modal looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Git commit modal](img/B19779_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Git commit modal
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 11**.5*, the `ktlintFormat` command has made a bunch of
    changes to our files. We can check each file for changes too. The formatter is
    a good tool to help us quickly format our code according to the Kotlin style and
    conventions. The `ktlintFormat` and `ktlintCheck` commands are the ones to run
    after you complete your changes before you commit your code. This will help you
    avoid committing code that is not formatted correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have done a basic setup, which is sufficient for most projects. For more
    information, you can learn more about the plugin, the rules available, and how
    to customize it here: [https://github.com/jlleitschuh/ktlint-gradle](https://github.com/jlleitschuh/ktlint-gradle).'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to use the Ktlint plugin to format and perform static analysis
    of our code. In the next section, we will learn how to use the detekt plugin to
    check for code smells and technical debt in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting code smells with detekt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'detekt is another static code analysis tool for Kotlin. It helps us identify
    problems early and keep the technical debt low throughout the development process.
    It enforces a set of rules that help us avoid code smells and technical debt.
    It also gives us the flexibility to create our own custom rule sets. Detekt offers
    the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It identifies code smell for Kotlin projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easily configurable and customizable to suit our needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can always suppress the warnings if we feel they are not applicable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can specify the code smell thresholds that we want to enforce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be using these features in our project. But before that, let us understand
    the rule sets. detekt has several rule sets that check the compliance of your
    code with the Kotlin style guide. The available rule sets are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments**: This rule set provides rules that address issues in comments
    and the documentation of the code. It checks header files, comments on private
    methods, and undocumented classes, properties, or methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**: This rule set contains rules that report complex code. It checks
    for complex conditions, methods, expressions, and classes, as well as long methods
    and long parameter lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coroutines**: This rule set analyzes code for potential coroutine problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catch` blocks, empty class blocks, and empty function and conditional function
    blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exceptions**: This rule set reports issues related to how code throws and
    handles exceptions. For example, it has rules for if you’re catching generic exceptions,
    among other issues related to handling exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatting**: This rule set checks whether your code base follows a specific
    formatting rule set. It allows for checking indentation, spacing, semicolons,
    or even import ordering, among other things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naming**: This rule set contains rules that assert the naming of different
    parts of the code base. It checks how we name our classes, packages, functions,
    and variables. It reports the errors in case we’re not following the set conventions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArrayPrimitives` or the misuse of `forEach` loops, for instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential-Bugs**: This rule set provides rules that detect potential bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ruleauthors**: This rule set provides rules that ensure good practices are
    followed when writing custom rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Style**: This rule set provides rules that assert the style of the code.
    This will help keep the code in line with the given code style guidelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this understanding of detekt rule sets and features, let us now set up
    detekt in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up detekt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to Ktlint, detekt is available as a Gradle plugin. To add the plugin
    to our project, we need to add the following code to our project’s `build.gradle.kts`
    file in the plugins block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `build.gradle.kts` file below the plugins block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This applies the detekt plugin to all the modules that will be in our project
    so we do not need to add the plugin to each module. We also set the `parallel`
    property to `true`. This will help us run the detekt tasks in parallel and save
    time when running the tasks. Click on the **Sync Now** button at the top to add
    the changes to the project. We are now set to use detekt. Open your terminal and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run the `detekt` task. After the task completes, we will see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – detekt errors](img/B19779_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – detekt errors
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time we run the task, we will get a number of errors. As we can see
    from the preceding figure, detekt shows the file and line number with the error
    and the type of rule set that has not been complied with. In *Figure 11**.6*,
    we can see the common ones being the function is too long, and magic numbers are
    included, among others. At the end of the list of errors, detekt normally shows
    the total number of weighted issues, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – detekt errors summary](img/B19779_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – detekt errors summary
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a total of 121 weighted issues. We are going to see how to suppress
    some as well as increase thresholds for others and fix the ones that we can shortly.
    First, we need to change the default behavior of detekt. To do this, we need to
    create a `detekt-config.yml` file in the root of our project. detekt has a task
    that does this. Let us open the **Terminal** tab in our IDE and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a `config` file if we don’t have it already. After the task
    completes, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – detekt config file](img/B19779_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – detekt config file
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to reference this file to our detekt setup. Let us head over to the
    project-level `build.gradle.kts` file and modify our `detekt` block to look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using our newly created file as the `config` file. Click on the
    `config` file.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing detekt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times, `detekt` might be reporting issues that we do not want to fix or
    we might want to change the severity or thresholds of the issue. Here is where
    customizing detekt comes in handy. We can customize `detekt` in the `detekt.yml`
    file and customize the rules that we are interested in. The first issue we are
    going to disable is the `detekt.yml` file and press *Command* + *F* on macOS or
    *Ctrl* + *F* on Windows to search for the `MagicNumber` issue and modify it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are setting the `active` property to `false`. This will disable the issue.
    By running the `./gradlew detekt` command again, we can see that we have reduced
    the error from 121 to 60 now! That’s a significant drop. We can also see that
    the `MagicNumber` issue is no longer present.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – detekt with no magic numbers](img/B19779_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – detekt with no magic numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us ensure that detekt doesn’t complain about Jetpack Compose function
    naming. Search for the `FunctionNaming` issue and modify it to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added `ignoreAnnotated: [''Composable'']`. This will not report issues
    for all functions annotated with the `@Composable` annotation. Composable functions
    use the Pascal case naming convention. Next, we want to disable the new line at
    the end of the file rule on detekt since we disabled it on Ktlint. Search for
    the `FinalNewline` issue and modify it to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will disable the issue. By running the `./gradlew detekt` command again,
    we can see that we have reduced the errors to only eight now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – detekt errors reduced](img/B19779_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – detekt errors reduced
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us see how to increase the thresholds to resolve the *function too
    long* issue. Search for the `FunctionTooLong` issue and modify it to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will solve all the issues related to the function being too long. Search
    for the `LongParameterList` issue and modify it to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have increased the threshold from `6` to `8`. Lastly, search for the `ComplexCondition`
    issue and modify it to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also increased the threshold from `4` to `6`. By running the `./gradlew
    detekt` command again, we can see that we have reduced the errors to only three
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – More errors removed](img/B19779_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – More errors removed
  prefs: []
  type: TYPE_NORMAL
- en: 'Increasing thresholds is a good way of reducing errors. It’s also great since
    it reduces the amount of refactoring that we have to do. However, we should be
    careful not to increase the thresholds too much. Let us now try to fix the remaining
    issues. Let us start with the `TooGenericExceptionCaught` and `SwallowedException`
    issues. This is in our `PetsSyncWorker` `doWork` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To resolve the issues, we need to add a `log` statement to the `catch` block
    and catch only the exceptions that we expect. Let us modify the code to be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a `log` statement and we are only catching `IOException`. Lastly,
    let us fix the `UtilityClassWithPublicConstructor` issue. This is in our `LeakTestUtils`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This class only has a companion object, which returns an instance of the `LeakCanaryTest`
    class. We can use an object instead of a class. Let us modify the class to be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'All the issues should be fixed now. By running the `./gradlew detekt` command
    again, we can see that we have no errors now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – detekt successful run](img/B19779_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – detekt successful run
  prefs: []
  type: TYPE_NORMAL
- en: Our build successfully passes. Our project now has a plugin that helps us do
    static analysis of our code. We can now identify code smells and technical debt
    early in the development process. We can also use these plugins on **Continuous
    Integration/ Continuous Delivery** (**CI/CD**) pipelines to ensure that we don’t
    merge code that has code smells and technical debt. This will help us keep our
    code base clean and maintainable, especially when we are working in teams. We
    will learn about this extensively in [*Chapter 14*](B19779_14.xhtml#_idTextAnchor198).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the Kotlin style and the best practices
    for writing Kotlin code. We have also learned how to use plugins such as Ktlint
    and Detekt to format, lint, and detect code smells early.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to add tests for the different layers
    in the MVVM architecture. We will learn about the importance of adding tests to
    our apps and how to add unit tests, integration tests, and instrumentation tests.
  prefs: []
  type: TYPE_NORMAL
