<html><head></head><body>
		<div><h1 id="_idParaDest-183" class="chapter-number"><a id="_idTextAnchor269" class="calibre6 pcalibre pcalibre1"/>9</h1>
			<h1 id="_idParaDest-184" class="calibre5"><a id="_idTextAnchor270" class="calibre6 pcalibre pcalibre1"/>Understanding Persistent Memory</h1>
			<p class="calibre3">While, as iOS developers, we primarily focus on UI-related topics such as UIKit and SwiftUI, there are other essential aspects of iOS development to consider, such as persistent memory. This topic is critical as it enables us to store and retrieve information even after an app is closed.</p>
			<p class="calibre3">There are many benefits to managing persistent memory well, some of which are detailed here:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Improving user experience</strong>: Apps that can save and retrieve user data later provide a better user experience. For instance, if the user has downloaded information from our backend <a id="_idIndexMarker698" class="calibre6 pcalibre pcalibre1"/>server, we can show it to them the next time they enter the app without waiting for network requests to complete.</li>
				<li class="calibre11"><strong class="bold">Providing offline access</strong>: Offline access is a great feature allowing users to work with our app even when they are offline. For example, a messaging app may allow users to view their previous conversations even when they don’t have an internet connection.</li>
				<li class="calibre11"><strong class="bold">Keeping a local state</strong>: With persistent memory, we can keep a local state even after the app is closed. For example, storing access tokens, user profile details, or continuing the user experience from the last time the user stopped are essential features we can add to our app.</li>
			</ul>
			<p class="calibre3">Persistent memory is a critical component for iOS developers, involving user experience, security, and efficiency.</p>
			<p class="calibre3">This chapter covers the following important topics in persistent memory:</p>
			<ul class="calibre10">
				<li class="calibre11">Mastering <em class="italic">Core </em><em class="italic">Data</em> questions</li>
				<li class="calibre11">Handling persistent state with <strong class="source-inline1">UserDefaults</strong></li>
				<li class="calibre11">Storing sensitive information in the <em class="italic">Keychain</em></li>
				<li class="calibre11">Working with the <em class="italic">filesystem</em></li>
			</ul>
			<p class="calibre3">Many young developers are often intimidated by a framework called Core Data. Let’s begin by exploring this topic.</p>
			<h1 id="_idParaDest-185" class="calibre5"><a id="_idTextAnchor271" class="calibre6 pcalibre pcalibre1"/>Mastering Core Data questions</h1>
			<p class="calibre3">Most interviewers don’t ask about general frameworks (besides UIKit, SwiftUI, and Foundation), but Core Data is considered an exception. <strong class="bold">Core Data</strong> is a fundamental framework in iOS development <a id="_idIndexMarker699" class="calibre6 pcalibre pcalibre1"/>because it’s an optimized and simple solution for setting up our data layer and managing a persistent store.</p>
			<p class="calibre3">Core Data evolved over the years and became a primary framework for many developers. It is integrated perfectly into the iOS development ecosystem, working perfectly with Xcode and other iOS frameworks.</p>
			<p class="calibre3">There are several concepts to know about Core Data:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Data model</strong>: Core Data is built around a data model, which defines the data structure stored in the app. The <a id="_idIndexMarker700" class="calibre6 pcalibre pcalibre1"/>data model is typically determined using Xcode’s data modeling tool and includes entities (which represent objects in the app), attributes (which describe properties of those objects), and relationships (which define how entities are related to each other).</li>
				<li class="calibre11"><strong class="bold">Managed object context</strong>: The managed object context is the heart of the Core Data framewor<a id="_idTextAnchor272" class="calibre6 pcalibre pcalibre1"/>k. It is<a id="_idIndexMarker701" class="calibre6 pcalibre pcalibre1"/> responsible for managing the life cycle of the <a id="_idIndexMarker702" class="calibre6 pcalibre pcalibre1"/>app’s data objects (known as “managed objects”) and provides a way for the app to query, create, update, and delete those objects. It is also responsible for handling undo/redo operations and managing object relationships.</li>
				<li class="calibre11"><strong class="bold">Persistent store coordinator</strong>: The persistent store coordinator is responsible for managing the app’s persistent store, where<a id="_idIndexMarker703" class="calibre6 pcalibre pcalibre1"/> the data is stored on disk. It coordinates communication between the managed object context and the persistent store and ensures that changes made to the managed object context are properly persisted to disk.</li>
				<li class="calibre11"><strong class="bold">Fetch requests</strong>: We use Fetch requests to query the app’s data model and retrieve specific objects from the <a id="_idIndexMarker704" class="calibre6 pcalibre pcalibre1"/>managed object context. We can also customize Fetch requests with predicates (to filter results), sort descriptors (to order results), and fetch limits (to limit the number of results returned).</li>
				<li class="calibre11"><strong class="bold">Relationships</strong>: Core Data provides a powerful mechanism for defining relationships between<a id="_idIndexMarker705" class="calibre6 pcalibre pcalibre1"/> entities in the data model. Relationships can be one-to-one, one-to-many, or many-to-many and can be uni-directional or bi-directional. Relationships can also be configured with delete rules, which define how objects should be deleted when a relationship is broken.</li>
				<li class="calibre11"><strong class="bold">Migration</strong>: Core <a id="_idIndexMarker706" class="calibre6 pcalibre pcalibre1"/>Data includes tools for migrating data between different data model versions. This allows developers to change the data model over time while preserving existing data.</li>
			</ul>
			<p class="calibre3">There’s another important term we know about Core Data, and that’s the <strong class="bold">Core Data Stack</strong>. The Core Data Stack is a layer set that allows our app to interact with the persistent store.</p>
			<p class="calibre3">Here are the three Core Data Stack layers:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Managed object model</strong>: This is the<a id="_idIndexMarker707" class="calibre6 pcalibre pcalibre1"/> bottom layer containing the data model. Because everything is built around the data structure, we start with that layer.</li>
				<li class="calibre11"><strong class="bold">Persistent store coordinator</strong>: This is the <a id="_idIndexMarker708" class="calibre6 pcalibre pcalibre1"/>persistent store coordinator built upon the object model. The coordinator uses the data model to define a corresponding persistent store that matches the data scheme. The store could be based on XML, SQLite, JSON, or a backend service. Core Data allows us to base the persistent store upon any technology we want. Another essential thing to remember about the persistent store is that it needs to match the data model exactly. Any change in the data model will require a modification to the store and migration.</li>
				<li class="calibre11"><strong class="bold">Managed object context</strong>: This is the managed object context that manages the life cycle of the app’s data <a id="_idIndexMarker709" class="calibre6 pcalibre pcalibre1"/>objects (known as “managed objects”). It provides a way for the app to query, create, update, and delete those objects. It is also responsible for handling undo/redo operations and managing object relationships.</li>
			</ul>
			<p class="calibre3">We need to set up the Core Data Stack to start using Core Data. This can be done quickly using <code>NSPersistentContainer</code>:</p>
			<pre class="source-code">
import CoreData// 1. Create a persistent container
let container = NSPersistentContainer(name: "MyDataModel")
// 2. Load the persistent store
container.loadPersistentStores { (storeDescription, error)
    in
    if let error = error {
        fatalError("Failed to load persistent store: \(error)")
    }
}
// 3. Create a managed object context
let context = container.viewContext</pre>
			<p class="calibre3">In the code <a id="_idIndexMarker710" class="calibre6 pcalibre pcalibre1"/>example, we use <code>MyDataModel</code>. This line also creates the persistent store and returns a container object.</p>
			<p class="calibre3">Afterward, we <em class="italic">load</em> the persistent store into the stack and create a managed object context so we can start working with Core Data.</p>
			<p class="calibre3">Once we have the context, we can perform entity creation, fetching, updates, and deletion:</p>
			<pre class="source-code">
let newEmployee = Employee(context: context)newEmployee.name = "John Doe"
newEmployee.title = "Software Engineer"
newEmployee.startDate = Date()
do {
    try context.save()
} catch {
    fatalError("Failed to save context: \(error)")
}</pre>
			<p class="calibre3">The code is so simple that it speaks for itself. We create a new <code>Employee</code> object based on the context we created earlier, set its properties, and save the new object using the <code>context</code> save method.</p>
			<p class="calibre3"><code>Employee</code> is a subclass of <code>NSManagedObject</code>, and it allows us direct access to the entity’s properties and an easy way to modify its data. The <code>context.save()</code> action commits the changes into the persistent store.</p>
			<p class="calibre3">Generally speaking, the primary usage of Core Data is straightforward, and it has become even simpler over the years. While setting up a Core Data Stack is essential to using Core Data, it’s not the only aspect developers need to master. Due to the challenges and complexities of working with Core Data, interviewers often ask about these challenges rather than just the basic setup.</p>
			<p class="calibre3">Here are some challenges we may consider learning well before the interview:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Handling concurrency</strong>: Concurrency is a<a id="_idIndexMarker711" class="calibre6 pcalibre pcalibre1"/> complex topic not only in Core Data but in any persistent store or local data. Several techniques and patterns exist for performing concurrency jobs in Core Data and avoiding data loss and exceptions.</li>
				<li class="calibre11"><strong class="bold">Designing a data model</strong>: Technically, setting up a data model with entities and attributes is a simple job as we perform most of the work in a model editor, a built-in Xcode editor. But the real challenge is to <em class="italic">design</em> the data model in a way that serves our app’s critical journeys and tasks. We need to master the primary terms such as <strong class="bold">to-many</strong> and <strong class="bold">to-one</strong> and fully understand the <strong class="bold">deletion rules</strong>.</li>
				<li class="calibre11"><strong class="bold">Understanding data migrations</strong>: We’ll have to modify our data model, adding, editing, and<a id="_idIndexMarker712" class="calibre6 pcalibre pcalibre1"/> removing entities and attributes over time. Changing the data model while there’s data in the persistent<a id="_idIndexMarker713" class="calibre6 pcalibre pcalibre1"/> store is called “data migrations,” which is also a critical topic we, as iOS developers, need to understand and know how to perform. Mistakes in this area may lead to data corruption and even crashes.</li>
			</ul>
			<p class="calibre3">Now, let’s transition to some Core Data-related questions specifically addressing<a id="_idTextAnchor273" class="calibre6 pcalibre pcalibre1"/> these topics.</p>
			<h2 id="_idParaDest-186" class="calibre7"><a id="_idTextAnchor274" class="calibre6 pcalibre pcalibre1"/>“How do you design a Core Data Stack that supports concurrency while ensuring thread safety, and how can you use NSManagedObjectIDs in a multi-threaded environment to fa<a id="_idTextAnchor275" class="calibre6 pcalibre pcalibre1"/>cilitate this?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Concurrency is an important top in <a id="_idIndexMarker714" class="calibre6 pcalibre pcalibre1"/>Core Data development, and handling concurrency well shows a deep understanding of how Core Data context works.</p>
			<p class="calibre3">If we understand how Core Data context works, we should also answer the second part of this question – the <code>NSManagedObjectID</code>, which can help us identify an object in dif<a id="_idTextAnchor276" class="calibre6 pcalibre pcalibre1"/>ferent contexts.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">First, let’s talk about two principles that are related to Core Data concurrency:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Considering a context as a sandbox</strong>: When working with contexts, we can create objects, update, and delete them. We do all that only in the context and not in the persistent store. When we call the <strong class="source-inline1">save()</strong> method, Core Data pushes the changes to the parent context and, if there isn’t any parent context, to the persistent store. We should think of context as a sandbox – we can perform changes and commit them only when ready.</li>
				<li class="calibre11"><strong class="bold">Accessing a context from the same thread that created it</strong>: In Core Data, a context belongs to a thread. Once we create a new background thread, we can’t access an object created or fetched in another thread. Each thread needs to have its context to allow it.</li>
			</ul>
			<p class="calibre3">After we understand<a id="_idIndexMarker715" class="calibre6 pcalibre pcalibre1"/> these two principles, we can try to define the different patterns for setting up our Core Data Stack. These patterns rely on our application needs and requirements.</p>
			<p class="calibre3">Let’s go over t<a id="_idTextAnchor277" class="calibre6 pcalibre pcalibre1"/>hem.</p>
			<h3 class="calibre9">Working with multiple contexts</h3>
			<p class="calibre3">We have several private <a id="_idIndexMarker716" class="calibre6 pcalibre pcalibre1"/>contexts in multiple context patterns, and each works directly with the persistent store. The multiple contexts are responsible for reading and writing and provide a flexible way to handle different concurrency operations across our app and do that even in a modular way.</p>
			<p class="calibre3">Here’s an example:</p>
			<pre class="source-code">
let persistentContainer = NSPersistentContainer(name: "MyApp")persistentContainer.loadPersistentStores(completionHandler: { (storeDescription, error) in
    if let error = error {
        fatalError("Failed to load persistent store: \(error)")
    }
})
let writeContext = NSManagedObjectContext(concurrencyType:
    .privateQueueConcurrencyType)
writeContext.persistentStoreCoordinator =
    persistentContainer.persistentStoreCoordinator
let readContext = NSManagedObjectContext(concurrencyType:
    .privateQueueConcurrencyType)
readContext.persistentStoreCoordinator =
    persistentContainer.persistentStoreCoordinator</pre>
			<p class="calibre3">In this example, we create two contexts for writing (<code>writeContext</code>) and reading (<code>readContext</code>). It is important to note that changes we make to the writing context don’t reflect on the read context until we perform saving and re-fetching.</p>
			<p class="calibre3">There are some significant <a id="_idIndexMarker717" class="calibre6 pcalibre pcalibre1"/>drawbacks to multiple contexts patterns. For example, this pattern can add complexity to our database and requires us to manage changes between contexts.</p>
			<p class="calibre3">Another drawback we may encounter is complexity with features such as batch changes and redo/undo, which can be critical in some application use cases.</p>
			<p class="calibre3">However, we have a decent alternative: the parent-child context. Let’s talk about it.</p>
			<h3 class="calibre9">Working with parent-child context</h3>
			<p class="calibre3">If the multiple <a id="_idIndexMarker718" class="calibre6 pcalibre pcalibre1"/>contexts pattern has a “flat” structure, the parent-child pattern is more hierarchical. The basic principle states that we have a root context (aka “parent”) dedicated to writing operations and child contexts dedicated to reading operations. The parent context is private, and the child contexts work with the main queue. Every change we make in the writing context is reflected in the child’s contexts.</p>
			<p class="calibre3">The parent-child pattern is excellent for background updates, offline editing, and undo-redo use cases.</p>
			<p class="calibre3">Here’s a code example for the parent-child pattern:</p>
			<pre class="source-code">
let parentContext = NSManagedObjectContext(concurrencyType:    .privateQueueConcurrencyType)
parentContext.persistentStoreCoordinator =
    persistentStoreCoordinator
let readContext1 = NSManagedObjectContext(concurrencyType:
    .mainQueueConcurrencyType)
readContext1.parent = parentContext
let readContext2 = NSManagedObjectContext(concurrencyType:
    .mainQueueConcurrencyType)
readContext2.parent = parentContext</pre>
			<p class="calibre3">We can see the parent <a id="_idIndexMarker719" class="calibre6 pcalibre pcalibre1"/>context is private, and the children are the main ones. Also, we can see how we linked the children to their parent directly and not to the persistent store.</p>
			<p class="callout-heading">What does a “private context” mean?</p>
			<p class="callout">A private context is typically used to <a id="_idIndexMarker720" class="calibre6 pcalibre pcalibre1"/>perform background tasks such as importing or exporting data, allowing those tasks to be performed asynchronously without blocking the main thread.</p>
			<p class="calibre3">Overall, both parent-child and multiple contexts serve different purposes and use cases. It is important to say they provide basic principles for managing concurrency with Core Data. Combining these patterns or even using their principles to create a new pattern is perfectly fine.</p>
			<h3 class="calibre9">And what about using NSManagedObjectID?</h3>
			<p class="calibre3">When working with contexts, we cannot take a managed object fetched in one context and use it in another. We need to<a id="_idIndexMarker721" class="calibre6 pcalibre pcalibre1"/> re-fetch it using <code>NSManagedObjectID</code>. That critical point may lead to an<a id="_idIndexMarker722" class="calibre6 pcalibre pcalibre1"/> exception if not done right.</p>
			<p class="calibre3">Here’s a code example of re-fetching the same object in another context using <code>NSManagedObjectID</code>:</p>
			<pre class="source-code">
var object: MyEntity?let fetchRequest: NSFetchRequest&lt;MyEntity&gt; = MyEntity.fetchRequest()
fetchRequest.predicate = NSPredicate (format: "id == %@", someID)
do {
    object = try mainContext.fetch(fetchRequest).first
} catch {
    print("Error fetching object: \(error)")
}
guard let objectID = object?.objectID else {
    return
}
Let backgroundContext = NSManagedObjectContext
    (concurrencyType: .privateQueueConcurrencyType)
backgroundContext.persistentStoreCoordinator =
    persistentStoreCoordinator
backgroundContext.perform {
    let backgroundObject = backgroundContext.object(with:objectID)
}</pre>
			<p class="calibre3">Each managed <a id="_idIndexMarker723" class="calibre6 pcalibre pcalibre1"/>object has a property named <code>objectID</code>, which is identical to the same object across different contexts. Its primary purpose is precisely that – to ensure working with the same object<a id="_idIndexMarker724" class="calibre6 pcalibre pcalibre1"/> when moving between contexts. <code>NSManagedObjectID</code> is an essential concept when performing concurrency operations in Core Data.</p>
			<h2 id="_idParaDest-187" class="calibre7"><a id="_idTextAnchor278" class="calibre6 pcalibre pcalibre1"/>“What would your Core Data data model look like for a recipe app that includes ingredients, cooking instru<a id="_idTextAnchor279" class="calibre6 pcalibre pcalibre1"/>ctions, and user ratings?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">We are iOS developers and not DBAs, but <a id="_idIndexMarker725" class="calibre6 pcalibre pcalibre1"/>we have significant weight in designing a data model that fits our app business needs. A bad data model design directly influences the app’s performance and stability. As developers, it is our responsibility to convert the requirements and workflows of an app into a technical design, and this question evaluates our proficiency i<a id="_idTextAnchor280" class="calibre6 pcalibre pcalibre1"/>n achieving that objective.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Creating a data model for a specific app usage require<a id="_idTextAnchor281" class="calibre6 pcalibre pcalibre1"/>s us to follow these steps:</p>
			<ol class="calibre15">
				<li class="calibre11">Understand the <em class="italic">app’s needs</em> and basic flows.</li>
				<li class="calibre11">Define the <em class="italic">different entities and their attributes</em>, including the data types, default values, and more.</li>
				<li class="calibre11">Create <em class="italic">indexes</em> for the relevant attributes.</li>
				<li class="calibre11">Understand the <em class="italic">relationships</em> between the different entities – one-to-one or one-to-many.</li>
				<li class="calibre11">Set the <em class="italic">deletion</em> rules.</li>
			</ol>
			<p class="calibre3">These steps are always relevant when approaching a data model design, and the use case described in the question is no exception.</p>
			<p class="calibre3">The first step is to identify the primary workflows of the app. It is important to remember that the data layer should support the business logic and UI and not exist independently. It's perfectly legitimate to ask the interviewer additional questions; it is even part of the task.</p>
			<p class="calibre3">Second, we can <a id="_idIndexMarker726" class="calibre6 pcalibre pcalibre1"/>define the basic entities:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">Recipe</strong>: This holds the essential details for a single recipe. Attributes: title, date of creation, desc<a id="_idTextAnchor282" class="calibre6 pcalibre pcalibre1"/>ription, level, and category.</li>
				<li class="calibre11"><strong class="source-inline1">Ingredient</strong>: This can be shared across recipes. Attributes: name.</li>
				<li class="calibre11"><strong class="source-inline1">Instruction</strong>: This is part of the steps required when using a recipe. Attributes: description, title.</li>
				<li class="calibre11"><strong class="source-inline1">User Rating</strong>: This is a review of a single recipe. Attributes: name, rating (<strong class="source-inline1">int</strong>), and description.</li>
			</ul>
			<p class="calibre3">While entities are a crucial aspect of the data model, they are often ineffective without clearly defining the relationships between them.</p>
			<p class="calibre3">So, let’s understand how the entities are linked and the main challenges (because there are some!).</p>
			<p class="calibre3">We understand that <code>Recipe</code> has a one-to-many relationship with <code>Instruction</code> and a one-to-many relationship with <code>User Rating</code>. That’s easy. What do we do with the ingredients? The naïve approach would be to define a one-to-many relationship with <code>Ingredient</code>, just as we did with <code>Instruction</code> and <code>User Rating</code>. The thing about <code>Ingredient</code> is that we can share it across recipes. For example, let’s say we have a feature that helps the user find all the recipes available based on ingredients.</p>
			<p class="calibre3">In this case, a many-to-many relationship is required here. So, here’s something we learn: to construct the data model effectively, it is important to communicate with the interviewer and evaluate the app’s various features. We should also discuss potential use cases for the data to determine the best approach.</p>
			<p class="calibre3">If we need to share ingredients between our recipes and create a many-to-many relationship, we will probably need to develop a different entity, and that’s <code>IngredientUsage</code>.</p>
			<p class="calibre3"><code>IngredientUsage</code> represents one usage of <code>Ingredient</code> for a recipe, and it links between <code>Recipe</code> and <code>Ingredient</code>. Besides that link, it also provides more information, such as the amount.</p>
			<p class="calibre3">To explore this further, let’s look at <em class="italic">Figure 9</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_9.1_B18653.jpg" alt="Figure 9﻿.1 – Relationships between Recipe, IngredientUsage, and Ingredient" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Relationships between Recipe, IngredientUsage, and Ingredient</p>
			<p class="calibre3">The main issue<a id="_idIndexMarker727" class="calibre6 pcalibre pcalibre1"/> we solve in <em class="italic">Figure 9</em><em class="italic">.1</em> is that we cannot put additional information about relationships in Core Data. We can define a to-many relationship between <code>Recipe</code> and <code>Ingredient</code>, but we cannot tell the amount. The amount can’t be part of <code>Ingredient</code> because we want to share the ingredient with other recipes, which probably have a different amount. That’s the role of <code>IngredientUsage</code>.</p>
			<p class="calibre3">Another helpful tip is to remember that a similar issue can arise during any many-to-many relationship. If it is necessary to load the relationship with more information, a dedicated entity for the relationship can effectively address this concern.</p>
			<p class="calibre3">Now that we have defined the relationships between the data models, we need to consider the deletion rules. Core Data has several deletion rules, and it is important to pick the right one so we can maintain our data over time.</p>
			<p class="calibre3">For example, if we delete <code>Recipe</code>, we want its <code>IngredientUsage</code>, <code>User Rating</code>, and <code>Instruction</code> data to be deleted. Therefore, we define the deletion rules between <code>Recipe</code> and the other <a id="_idIndexMarker728" class="calibre6 pcalibre pcalibre1"/>entities as <strong class="bold">Cascade</strong>. Cascade is a deletion rule that deletes the related objects if the source object is being deleted.</p>
			<p class="calibre3">However, that’s not the case between <code>IngredientUsage</code> and <code>Ingredient</code>. If we delete <code>IngredientUsage</code>, we don’t want to delete the ingredient as it is being shared with other <code>IngredientUsage</code> objects. In this case, we set the deletion rule for <strong class="bold">Nullify</strong>.</p>
			<p class="calibre3">What about the inverse relationships? Do we need to delete a <code>Recipe</code> object if we delete one of its <code>User Rating</code> objects? Probably not. We want to keep <code>Recipe</code> if we delete a <code>User Rating</code> object. That’s also the case with <code>Instruction</code>. In both cases, we set the deletion rule to <em class="italic">Nullify</em> as well.</p>
			<p class="calibre3">To recap our approach, I started by outlining five fundamental steps that form the process of defining a data model. It’s important to note that each step builds upon the previous one. To proceed with the answer, we can take a collaborative approach with our interviewer by walking through each step and discussing our thought process out loud. Doing that will ensure a<a id="_idIndexMarker729" class="calibre6 pcalibre pcalibre1"/> great answer, even though the solution may not be perfect or ideal. Remember that the interviewer wants to see our thinking and not solve a real problem.</p>
			<h2 id="_idParaDest-188" class="calibre7"><a id="_idTextAnchor283" class="calibre6 pcalibre pcalibre1"/>“How would you approach testing Core Data in an iOS app?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Core Data is an essential framework that plays a significant role in the app’s data layer. As such, it will be there when we <a id="_idIndexMarker730" class="calibre6 pcalibre pcalibre1"/>are testing our app. But what does it mean? How can we test a persistent store? This question checks our understanding of the different tests we can perform with Core Data and the tools to perform them effectively and consistently.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">We can perform three different types of tests with Core Data, and we already discussed tests earlier in this book. If you need to refresh, go back to <a href="B18653_06.xhtml#_idTextAnchor196" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 6</em></a> and ensure you are familiar with the different types of tests.</p>
			<p class="calibre3">The first type of testing we can perform is the unit test – in this case, we want to simulate a Core Data Stack and not use an actual persistent store file. To do that, we can create an <strong class="bold">in-memory</strong> persistent store. The<a id="_idIndexMarker731" class="calibre6 pcalibre pcalibre1"/> in-memory persistent store is lightweight, doesn’t use an actual database file, and performs all the I/O operations in RAM.</p>
			<p class="calibre3">Setting up an in-memory store is easy:</p>
			<pre class="source-code">
let managedObjectModel = NSManagedObjectModel.mergedModel    (from: [Bundle.main])!
let persistentStoreCoordinator =NSPersistentStoreCoordinator
    (managedObjectModel: managedObjectModel)
do {
    <strong class="bold1">try persistentStoreCoordinator.addPersistentStore(ofType: </strong>
   <strong class="bold1">NSInMemoryStoreType, configurationName: nil, at: nil, options: nil)</strong>
} catch {
    fatalError("Failed to create in-memory persistent store
        coordinator: \(error)")
}</pre>
			<p class="calibre3">In the preceding code, we are adding a persistent store of type <code>NSInMemoryStoreType</code>, which only creates an in-memory store.</p>
			<p class="calibre3">The second type of relevant test for Core Data is integration – in this case, we want to keep the Core Data store as it is and verify that actions we perform in the business logic or even the UI layers are being saved to the Core Data file. It is good practice to use a temporary database <a id="_idIndexMarker732" class="calibre6 pcalibre pcalibre1"/>file or clean the data store before and after each test case.</p>
			<p class="calibre3">The third test relevant to Core Data is the performance test. Core Data consists of I/O operations that can be heavy to perform, and it is a good idea to ensure we don’t have any bottlenecks in our app. We can use the <code>measure</code> function in <code>XCTestCase</code> to check I/O operations:</p>
			<pre class="source-code">
func testFetchPerformance() {    let context = persistentContainer.viewContext
    let request = NSFetchRequest&lt;MyEntity&gt;(entityName: "MyEntity")
    measure {
        do {
            for _ in 0..&lt;200 {
                let result = try context.fetch(request)
            }
            let result = try context.fetch(request)
            XCTAssertEqual(result.count, 1000)
        } catch {
            XCTFail("Failed to fetch objects:
                \(error.localizedDescription)")
        }
    }</pre>
			<p class="calibre3">In the preceding example, we perform Core Data fetching and measure its duration. To simulate a workload, we<a id="_idIndexMarker733" class="calibre6 pcalibre pcalibre1"/> perform the fetch operation <code>200</code> times. The test asserts when the duration exceeds a certain threshold.</p>
			<p class="calibre3">To summarize – we can test Core Data in unit tests and eliminate any I/O operations, integration tests to ensure our system works as expected, and performance tests to check the impact Core Data has on our app performance.</p>
			<h1 id="_idParaDest-189" class="calibre5"><a id="_idTextAnchor284" class="calibre6 pcalibre pcalibre1"/>Handling persistent state with UserDefaults</h1>
			<p class="calibre3"><code>UserDefaults</code> is a fundamental yet simple solution for iOS developers to store persistent information<a id="_idIndexMarker734" class="calibre6 pcalibre pcalibre1"/> in a key-value format. We can easily<a id="_idIndexMarker735" class="calibre6 pcalibre pcalibre1"/> store and fetch Boolean, int, string, arrays, and dictionary values with UserDefaults.</p>
			<p class="calibre3">For example, this is how we store a Boolean in UserDefaults:</p>
			<pre class="source-code">
let defaults = UserDefaults.standarddefaults.set(true, forKey: "isUserLoggedIn")</pre>
			<p class="calibre3">And this is how we read it:</p>
			<pre class="source-code">
let defaults = UserDefaults.standardlet isUserLoggedIn = defaults.bool(forKey: "isUserLoggedIn")</pre>
			<p class="calibre3">The UserDefaults goal is not to store and retrieve large datasets – UserDefaults is a slow and unsecured solution for that use case. If we want to manage a local data store, we should use Core Data or SQLite for this purpose.</p>
			<p class="calibre3">As mentioned earlier, UserDefaults is a<a id="_idIndexMarker736" class="calibre6 pcalibre pcalibre1"/> very simple and<a id="_idIndexMarker737" class="calibre6 pcalibre pcalibre1"/> straightforward tool. However, it still has some advanced capabilities we may need to know when preparing for our <a id="_idTextAnchor285" class="calibre6 pcalibre pcalibre1"/>interview. Let’s review some of them:</p>
			<h2 id="_idParaDest-190" class="calibre7"><a id="_idTextAnchor286" class="calibre6 pcalibre pcalibre1"/>“Explain how an iOS app and its extensions can share data using UserDefaults. What steps are involved in setting up and using UserDefaults to share da<a id="_idTextAnchor287" class="calibre6 pcalibre pcalibre1"/>ta between an app and its extensions?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Many apps live happily isolated during their lifetime. But once we add an extension or another app, we will probably need to share some data between them. For example, we might need to share keys, tokens, or profile information.</p>
			<p class="calibre3">Luckily, Apple provides us with a secure and easy way to d<a id="_idTextAnchor288" class="calibre6 pcalibre pcalibre1"/>o just that. Let’s look at the answer.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">These are the steps we need to do to share data between an iOS app and its extension:</p>
			<ol class="calibre15">
				<li class="calibre11"><strong class="bold">Setting up an App Group</strong>: The App Group feature allows us to combine and synchronize data between multiple extensions or apps. We create a new App Group using the Developer Portal and enable it for both our app and the extension.</li>
				<li class="calibre11"><strong class="bold">Configure the Xcode project settings</strong>: Once we’ve set up the App Group in the Developer Portal, we’ll need to configure the Xcode project settings for our app and extensions. We’ll need to specify the App Group Identifier and enable the App Group entitlement for our app and extensions.</li>
				<li class="calibre11"><strong class="bold">Use UserDefaults to share data</strong>: Once the Xcode project settings have been configured, we can use UserDefaults to share data between our app and extensions. To do this, we’ll need to create a new <strong class="source-inline1">UserDefaults</strong> object with the App Group Identifier as the suite name and then use the <strong class="source-inline1">set(_:forKey:)</strong> method to save data and the <strong class="source-inline1">object(forKey:</strong>) method to retrieve data.</li>
			</ol>
			<p class="calibre3">Here’s a code<a id="_idIndexMarker738" class="calibre6 pcalibre pcalibre1"/> example of how to set and read data from shared <code>UserDefaults</code>:</p>
			<pre class="source-code">
let defaults = UserDefaults(suiteName: "group.com.yourcompany.     yourapp")!
defaults.set(true, forKey: "myBoolValue")
let myBoolValue = defaults.bool(forKey: "myBoolValue")</pre>
			<p class="calibre3">In this code example, we are setting up a new <code>UserDefaults</code> and passing the App Group Identifier we defined in the Developer Portal.</p>
			<p class="calibre3">The rest of the code stays as before in this section: reading and writing using a key-value mechanism.</p>
			<p class="calibre3">As we can see – sharing data between an app and an extension is straightforward, but it is also something not many developers are familiar with. Sharing the Core Data store between the app and the extension is also a fundamental feature.</p>
			<h2 id="_idParaDest-191" class="calibre7">“Can you explain how to store a struct or <a id="_idTextAnchor289" class="calibre6 pcalibre pcalibre1"/>a class in UserDefaults in an iOS app?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Saving primitive dictionaries and arrays is probably the most common use case when working with <code>UserDefaults</code>. But there are many cases<a id="_idIndexMarker739" class="calibre6 pcalibre pcalibre1"/> where we need to store an entire object or a class. For example, we sometimes need to save a user object that contains full details, and Core Data is like using a sledgehammer to crack a nut.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">UserDefaults has two popular ways to store an object or a struct:</p>
			<ul class="calibre10">
				<li class="calibre11">The first option is to use <strong class="source-inline1">NSKeyedArchiver</strong>. One of the data types we can save in <strong class="source-inline1">UserDefaults</strong> is <strong class="source-inline1">Data</strong>. <strong class="source-inline1">NSKeyedArchiver</strong> can take a struct or an object and convert it into a <strong class="source-inline1">Data</strong> object, which can be<a id="_idIndexMarker740" class="calibre6 pcalibre pcalibre1"/> saved directly to <strong class="source-inline1">NSKeyedArchiver</strong>. To un-archive the object, we can use <strong class="source-inline1">NSKeyedUnarchiver</strong>. Let’s see a code example for that:<pre class="source-code">
struct Person {    var name: String    var age: Int}let person = Person(name: "John Smith", age: 30)let data = try? NSKeyedArchiver.archivedData(withRoot    Object: person, requiringSecureCoding: false)UserDefaults.standard.set(data, forKey: "person")let storedData = UserDefaults.standard.data(forKey:"person")if let storedPerson = try? NSKeyedUnarchiver.unarchivedObject    (ofClass: Person.self, from:storedData!) {}</pre></li>			</ul>
			<p class="calibre3">In this code example, we converted a <code>Person</code> struct into a <code>Data</code> object using <code>NSKeyedArchiver</code>. The data can be set and restored easily, like any other data type saved to <code>UserDefaults</code>. After we fetch the data, we can convert it into a <code>Person</code> object<a id="_idIndexMarker741" class="calibre6 pcalibre pcalibre1"/> again using <code>NSKeyedUnarchiver</code>.</p>
			<ul class="calibre10">
				<li class="calibre11">The second option is<a id="_idIndexMarker742" class="calibre6 pcalibre pcalibre1"/> to use <strong class="bold">JSONEncoder</strong>. With <strong class="source-inline1">JSONEncoder</strong>, we can<a id="_idIndexMarker743" class="calibre6 pcalibre pcalibre1"/> convert to a <strong class="source-inline1">Data</strong> object the same way we did with <strong class="source-inline1">NSKeyedArchiver</strong>. Once we have a data object, we can set and restore the <strong class="source-inline1">Person</strong> object from <strong class="source-inline1">UserDefaults</strong>.</li>
			</ul>
			<p class="calibre3">Let’s see how we save and restore the same <code>Person</code> struct, but now with <code>JSONEncoder</code>:</p>
			<pre class="source-code">
struct Person: Codable {    var name: String
    var age: Int
}
let person = Person(name: "John Smith", age: 30)
let encoder = JSONEncoder()
if let encoded = try? encoder.encode(person) {
    UserDefaults.standard.set(encoded, forKey: "person")
    if let storedData = UserDefaults.standard.data
        (forKey: "person") {
        let decoder = JSONDecoder()
        if let storedPerson = try? decoder.decode
            (Person.self, from: storedData) {
        }
    }
}</pre>
			<p class="calibre3">We use <code>JSONEncoder</code> to convert the struct into data and <code>JSONDecoder</code> to restore the data back to <code>Person</code>. Notice that in this case, <code>Person</code> needs to <em class="italic">conform to Codable</em>, which requires its properties to also conform to Codable.</p>
			<p class="calibre3">Which of the options is <a id="_idIndexMarker744" class="calibre6 pcalibre pcalibre1"/>better? There’s no clear <a id="_idIndexMarker745" class="calibre6 pcalibre pcalibre1"/>answer. Generally, it is a best practice for our structs and classes to conform to <strong class="bold">Codable</strong> as it provides more capabilities such as automatic parsing and encoding.</p>
			<p class="calibre3">On the other hand, <code>NSKeyedArchiver</code> is more efficient than <code>JSONEncoder</code> when working on large or complex datasets.</p>
			<p class="calibre3">Both APIs are good enough for most cases, and it depends on our app structure and requirements.</p>
			<h1 id="_idParaDest-192" class="calibre5"><a id="_idTextAnchor290" class="calibre6 pcalibre pcalibre1"/>Storing sensitive information in the Keychain</h1>
			<p class="calibre3"><code>UserDefaults</code> is an <a id="_idIndexMarker746" class="calibre6 pcalibre pcalibre1"/>excellent storing mechanism, but it is unsuitable for storing data such as passwords or tokens. <strong class="bold">Keychain</strong> is Apple’s solution for storing sensitive data, and it provides a higher level of security and is an essential tool for iOS developers to protect their data.</p>
			<p class="calibre3">Storing data in the keychain is much more complex than using other solutions. The keychain provides a particular API, based on the C function, to prevent malicious hackers from reverse-engineering calls to that API. The keychain also requires more information when saving, so it can save and index it more efficiently.</p>
			<p class="calibre3">Let’s see how to store a simple token in the keychain while wrapping it with a class for convenience:</p>
			<pre class="source-code">
import UIKitimport Security
class KeychainManager {
    private let serviceName = "MyAppTokenService"
    func saveToken(token: String) -&gt; Bool {
        guard let tokenData = token.data(using: .utf8) else {
            return false
        }
        let keychainItem = [
            <a id="_idTextAnchor291" class="pcalibre pcalibre1 calibre17"/>kSecClass: kSecClassGenericPassword,
            kSecAttrService: serviceName,
      <a id="_idTextAnchor292" class="pcalibre pcalibre1 calibre17"/>      kSecAttrAccount: "MyAppToken",
            kSecValueData: tokenData
        ] as CFDictionary
        let status = SecItemAdd(keychainItem, nil)
        return status == errSecSuccess
    }
}</pre>
			<p class="calibre3">The first thing we notice<a id="_idIndexMarker747" class="calibre6 pcalibre pcalibre1"/> from that code example is that we import the <code>Security</code> framework, which is also responsible for authentication, secure transport, and data protection.</p>
			<p class="calibre3">We can also see that the code is much more complex than working with <code>UserDefaults</code>. Instead of storing a simple value, we need t<a id="_idTextAnchor293" class="calibre6 pcalibre pcalibre1"/>o create a keychain item with several properties:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">kSecClass</strong>: This key specifies the level of security of the item. We can choose from several constants, such as <strong class="source-inline1">kSecClassGenericPassword</strong>, <strong class="source-inline1">kSecClassInternetPassword</strong>, and <strong class="source-inline1">kSecClassIdentity</strong>. Choosing the correct class ensures the right level of security for our data.</li>
				<li class="calibre11"><strong class="source-inline1">kSecAttrService</strong>: <strong class="source-inline1">kSecAttrService</strong> defines the service name for our item. We can group multiple items to increase security in case of compromising part of the app, to <a id="_idIndexMarker748" class="calibre6 pcalibre pcalibre1"/>share part of the keychain items, and for better organization.</li>
				<li class="calibre11"><strong class="source-inline1">kSecAttrAccount</strong>: This is used to add identification to the keychain item, such as a username or email.</li>
				<li class="calibre11"><strong class="source-inline1">kSecValueData</strong>: This is the actual data we want to save. It can be either <strong class="source-inline1">Data</strong> or <strong class="source-inline1">String</strong>.</li>
			</ul>
			<p class="calibre3">These four keys are not the only ones we can use for creating a keychain item, but they are the most common ones. Once we have <code>CFDictionary</code>, we can use <code>SecItemAdd</code> to push the keychain item into the keychain.</p>
			<p class="calibre3">Here’s how to read the token back from the keychain:</p>
			<pre class="source-code">
    func readToken() -&gt; String? {        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        var result: AnyObject?
        let status = SecItemCopyMatching(query as
            CFDictionary, &amp;result)
        if status == errSecSuccess, let tokenData =
            result as? Data, let token = String(data:
                tokenData, encoding: .utf8) {
            return token
        } else {
            return nil
        }
    }</pre>
			<p class="calibre3">To read the token, we create <code>CFDictionary</code> once again and use <code>SecItemCopyMatching</code> to query the keychain and retrieve the token. Afterward, we examine the results – if the status is <code>success</code> and we have <code>tokenData</code>, we can extract the token by converting it into a string and return it.</p>
			<p class="calibre3">As we can see, keychain<a id="_idIndexMarker749" class="calibre6 pcalibre pcalibre1"/> management is not as trivial as other storage tools and a keychain wrapper is a good solution that can help us simplify the process.</p>
			<h2 id="_idParaDest-193" class="calibre7"><a id="_idTextAnchor294" class="calibre6 pcalibre pcalibre1"/>“What is a Keychain Access Group, and how can it be used to securely share Keychain items between different components <a id="_idTextAnchor295" class="calibre6 pcalibre pcalibre1"/>of an iOS app, such as the app and its extensions?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">In the previous section, we discussed UserDefaults and how to share information between our app and our extensions (or other apps, for that matter). Now we are moving forward with that question and being asked how to share sensitive information between the different components. This way, our app extensions can be much more powerful and independent.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">A <strong class="bold">Keychain access group</strong> is a unique identifier that specifies which Keychain items can be accessed by a particular app <a id="_idIndexMarker750" class="calibre6 pcalibre pcalibre1"/>or extension.</p>
			<p class="calibre3">Access groups are defined in the app’s entitlements file and provide secure sharing of sensitive data between different components of an app, such as an app and its extensions.</p>
			<p class="calibre3">By specifying the same access group for multiple components of an app, those components can securely share Keychain items without compromising their integrity. This feature is important for iOS app developers because it enables them to provide a secure and reliable storage mechanism for sensitive data that is accessible across multiple components of an app.</p>
			<p class="calibre3">Here’s how to set up a Keychain access group and use it.</p>
			<p class="calibre3">First, we need to define a <a id="_idIndexMarker751" class="calibre6 pcalibre pcalibre1"/>new access group in the app’s entitlements file:</p>
			<pre class="source-code">
&lt;key&gt;com.example.myapp.shared-keychain&lt;/key&gt;&lt;array&gt;
    &lt;string&gt;$(AppIdentifierPrefix)com.example.myapp&lt;/string&gt;
&lt;/array&gt;</pre>
			<p class="calibre3">We must also define the same access group in the extension’s entitlement file.</p>
			<p class="calibre3">Now, we can use the access group we created in our code when saving and fetching keychain values:</p>
			<pre class="source-code">
func savePasswordToKeychain(password: String) -&gt; Bool {    guard let data = password.data(using: .utf8) else {
        return false
    }
    let query: [String: Any] = [
        kSecClass as String: kSecClassGenericPassword,
        <strong class="bold1">kSecAttrAccessGroup</strong> as String:
            <strong class="bold1">"com.example.myapp.shared-keychain",</strong>
        kSecAttrAccount as String: "myPassword",
        kSecValueData as String: data
    ]
    SecItemDelete(query as CFDictionary)
    let status = SecItemAdd(query as CFDictionary, nil)
    return status == errSecSuccess
}</pre>
			<p class="calibre3">Notice we added the <code>kSecAttrAccessGroup</code> key to our keychain item with our new keychain group.</p>
			<p class="calibre3">When working <a id="_idIndexMarker752" class="calibre6 pcalibre pcalibre1"/>with the keychain, we can see that most of our boilerplate is the different keychain values management, while setting up an access group is easy and simple.</p>
			<p class="calibre3">Generally speaking – working with the iOS keychain is not as straightforward as the other tools we have – it requires more code, using C functions, and providing additional keys and information. But iOS development requires us to work with sensitive information and even share it between our apps. Therefore, we must understand how the keychain works and how to approach it with its API.</p>
			<h1 id="_idParaDest-194" class="calibre5"><a id="_idTextAnchor296" class="calibre6 pcalibre pcalibre1"/>Working with the filesystem</h1>
			<p class="calibre3">There’s a common assumption<a id="_idIndexMarker753" class="calibre6 pcalibre pcalibre1"/> that iOS “doesn’t have a filesystem.” And even though there is a <strong class="bold">Files</strong> app, it is true that the filesystem is almost hidden for most standard users.</p>
			<p class="calibre3">That’s not the case for iOS developers.</p>
			<p class="calibre3">iOS developers use the iOS filesystem to store documents, images, cache files, and even database files.</p>
			<p class="calibre3">The filesystem allows us to store a large set of information, work with resources and even share data with other app components. Most interview questions focus on organizing our files and responding to different use cases. Understanding how the sandbox is built is crucial for us as developers.</p>
			<p class="calibre3">So, let’s review a question about our sandbox structure.</p>
			<h2 id="_idParaDest-195" class="calibre7"><a id="_idTextAnchor297" class="calibre6 pcalibre pcalibre1"/>“Can you explain the purpose of each of the following folders in an iOS app: Documents, Library, Cache, and Temp? How would you decide which folder to use for storing different types of files in your app?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">File operations in iOS for reading and writing are generally straightforward from a technical perspective. However, the key is to grasp the methodological concept of properly organizing files in the appropriate folder. Each folder serves a distinct purpose and possesses different characteristics, and the iOS system distinctly manages each folder.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">As mentioned, each folder has its distinct purpose and characteristics, so let’s go over them here:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">Documents</strong>: This folder is meant for storing data that can be created or edited by the user, such as documents, images, and videos. This folder is backed up by iCloud and is visible to the user through iTunes file sharing. We should use this folder for data that the user expects to be available even after the app is closed.</li>
				<li class="calibre11"><strong class="source-inline1">Library</strong>: This folder is intended for storing app-specific data not created by the user, such as downloaded content, cache files, and preferences. This folder is backed up by iCloud but is not visible to the user through iTunes file sharing. We should use this folder for important data for the app’s functionality, but it can be recreated if necessary.</li>
				<li class="calibre11"><strong class="source-inline1">Cache</strong>: This folder is designed for storing temporary files that can be regenerated or downloaded again. This folder is not backed up by iCloud and can be emptied by the system when the device runs low on storage. We should use this folder for data that is not critical of the app’s functionality and can be discarded if necessary.</li>
				<li class="calibre11"><strong class="source-inline1">Temp</strong>: iOS also<a id="_idIndexMarker754" class="calibre6 pcalibre pcalibre1"/> provides a temporary directory for storing temporary files, known as the <strong class="source-inline1">Temp</strong> folder. This folder is intended to hold only needed temporary files and can be deleted when the app is closed.</li>
			</ul>
			<p class="calibre3">The content type leads us to decide which folder to store our files. For example, we want to use the <code>Documents</code> folder for user-generated files. We can use the <code>Temp</code> folder if we need temporary files for generating information or calculations. The <code>Library</code> folder is suitable for storing the local data persistent store file.</p>
			<p class="calibre3">Storing a file in the wrong folder may lead to unexpected behavior, such as data loss, performance issues, and increasing the user backup size for no reason.</p>
			<h1 id="_idParaDest-196" class="calibre5"><a id="_idTextAnchor298" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we went over some critical topics in persistent memory. We discussed Core Data concurrency and data model design, advanced topics in <code>UserDefaults</code>, how to handle sensitive information with the Keychain, and the different folders in our app sandbox.</p>
			<p class="calibre3">By now, we should ultimately be ready for that topic in our interview!</p>
			<p class="calibre3">The next chapter will cover an essential topic that could hinder the scalability of an app for iOS developers who are unfamiliar with it: CocoaPods and the Swift Package Manager.</p>
		</div>
	</body></html>