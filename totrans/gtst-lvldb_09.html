<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. A Document Database</h1></div></div></div><p>This chapter is going to take some of the theory we just discussed in the previous chapters and show the use of richer record structures and multiple keys for a document database. It uses the extended APLevelDBSS framework for these searches and building keys, including a word index.</p><p>This is a fairly simple document database but would be enough to keep track of a range of books and publications as well as local PDF or other files. The process of building lists of each and entering their details is very similar to what we covered in the <code class="literal">Sample06</code> GUI used in the previous chapter. One GUI technique for OS X that is new to this application is how to get references to files by dragging and dropping them on our window, so the details behind that are discussed in this chapter.</p><p>The samples so far haven't covered how to handle more than one database. We used fixed paths to a known database location. Opening others is covered here including discussing the package idiom of iOS and OS X that treats folders as documents.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Key design for searching the document database</h1></div></div></div><p>We want to retrieve <a id="id265" class="indexterm"/>documents by title, keyword, and author so have keys for each as shown in the following diagram.</p><div><img src="img/1015OS_09_01.jpg" alt="Key design for searching the document database"/><div><p>Typical NoSQL-style data and relationships in the document database</p></div></div><p>In a relational database, more tables would be used to track the authors, making it easier to work out co-authoring, but that is not the only pattern that can be used.</p><p>Storing multiple values nested inside a JSON or other encoded value is a typical noSQL pattern and helps simplify the <a id="id266" class="indexterm"/>keys. This schema also simplifies a little by ignoring identical author names that are actually different people. Note that we don't have any explicit keys to track that people are co-authors.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec16"/>Defining the schema using APLevelDBSS</h2></div></div></div><p>The schema <a id="id267" class="indexterm"/>definition matching the previous diagram <a id="id268" class="indexterm"/>is shown in the following code, using a property for each key to define the parts of keys. The <code class="literal">docKey</code> also defines the <code class="literal">valueFields</code> which <a id="id269" class="indexterm"/>define the minimum content for the record to support keys and our GUI. Unlike classical relational schemas, there may be more fields in any individual record than we define:</p><div><pre class="programlisting">- (void)defineSchema {
  // define individual properties for keys to be easier to use
  self.authorKey = [ASDLevelDBKey key:@"Author name" withParts:@[
    @"A~",   
    [ASDLevelDBKey partFromPath:@"doc.authors.name"], 
    [ASDLevelDBKey partFromId:@"doc"]  ]];
  self.wordKey = [ASDLevelDBKey key:@"Words" withParts:@[
    @"W~", 
    [ASDLevelDBKey partFrom:@"doc.desc" 
      valueGenerator:^(NSString* source){ 
        return [Sample09_Model uniqueWordsFromString:source];
      }], 
    [ASDLevelDBKey partFromId:@"doc"]
  ]];
  self.docTitleKey = [ASDLevelDBKey key:@"Document" withParts:@[
    @"D~", [ASDLevelDBKey partFromPath:@"doc.title"], 
    [ASDLevelDBKey partFromId:@"doc"]  ]];
  self.docKey = [ASDLevelDBKey key:@"doc" withParts:@[
    @"i~", [ASDLevelDBKey partGeneratingId:@"doc"]  ]
    <strong>valueFields:@[</strong>
<strong>      @"title", @"desc", @"fileURL",</strong>
<strong>      [ASDLevelDBField multiple:@"authors" fields:@[@"name"]]</strong>
    ]  ];
  // now hook everything up so the key paths can reconcile
  self.schema = [ASDLevelDBSchema schemaWithKeys:@[
    self.authorKey, self.wordKey, self.docTitleKey, self.docKey
  ]];
}</pre></div><p>The schema handling of APLevelDBSS will reconcile the key definitions so anything with a <code class="literal">partFromPath</code> will use the path string to navigate to the original data, mapping <code class="literal">doc.desc</code> to the <code class="literal">doc</code> key and then a <code class="literal">desc</code> field within.</p><p>You can see the <code class="literal">wordKey</code> has a <a id="id270" class="indexterm"/>
<code class="literal">valueGenerator</code> block that generates multiple values, using the <code class="literal">uniqueWordsFromString</code> <a id="id271" class="indexterm"/>shown in the following code. We regard all keys as potentially generating zero or <a id="id272" class="indexterm"/>multiple <a id="id273" class="indexterm"/>values either from a block or as a side effect of their path such as <code class="literal">doc.authors.name</code> matching a list of names:</p><div><pre class="programlisting">+ (NSArray*) uniqueWordsFromString:(NSString*)src {
  static NSMutableCharacterSet* seps = Nil;
  if (seps==Nil) {
    seps=[NSMutableCharacterSet
      whitespaceAndNewlineCharacterSet];
    [seps formUnionWithCharacterSet:
      [NSMutableCharacterSet punctuationCharacterSet]];
  }
  NSArray* words=[src componentsSeparatedByCharactersInSet:seps];
  NSMutableSet* uw=[NSMutableSet setWithCapacity:[words count]];
  for (id w in words) {
     if ([w length]&gt;=3)
       [uw addObject:[w lowercaseString]];       
  }
  return [[uw allObjects] 
    sortedArrayUsingSelector:@selector(localizedCompare:)];
}</pre></div><p>The preceding word generator is vastly simpler than a production-quality generator that would use <strong>stemming</strong> to <a id="id274" class="indexterm"/>match words with the same base, such as plurals. It should also have a <strong>stop-word list</strong> to skip <a id="id275" class="indexterm"/>words rather than just checking <code class="literal">length &gt;=3</code> characters.</p><p>The field of extracting text for indexing has a huge body of work. You can read about stemming algorithms and download BSD-licensed source for the Snowball algorithm, successor to the classic <a id="id276" class="indexterm"/>Porter algorithm, at <a class="ulink" href="http://snowball.tartarus.org/index.php">http://snowball.tartarus.org/index.php</a>.</p><p>Two major open source <a id="id277" class="indexterm"/>projects that use text indexing are Sphinx and Solr; part of Lucene. Packt Publishing have <a id="id278" class="indexterm"/>many books covering them including: <a class="ulink" href="http://www.packtpub.com/sphinx-search-beginners-guide/book">http://www.packtpub.com/sphinx-search-beginners-guide/book</a> and <a class="ulink" href="http://www.packtpub.com/apache-solr-4-cookbook/book">http://www.packtpub.com/apache-solr-4-cookbook/book</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Database fields for tracking documents</h1></div></div></div><p>Documents are identified by a <a id="id279" class="indexterm"/>URL that might be referring externally to an Internet resource or to a local file. As far as the database is concerned, this <a id="id280" class="indexterm"/>is just another string value. The OS X sample allows you to drag a document and drop it on the window, by registering to handle the <code class="literal">NSURLPboardType</code> and adding two handler methods:</p><div><pre class="programlisting">- (void)awakeFromNib {
  [super awakeFromNib];
  [self.window <strong>registerForDraggedTypes</strong>:@[NSURLPboardType]];
}
- (BOOL)performDragOperation:(id &lt;NSDraggingInfo&gt;)sender {
  NSPasteboard *p = [sender draggingPasteboard];  
  if ( [[p types] containsObject:NSURLPboardType] ) {
    [self.docURL setStringValue:[NSURL URLFromPasteboard:p]path]];
    [self.docURL needsDisplay];
  }
  return YES;
}
- (NSDragOperation)draggingEntered:(id &lt;NSDraggingInfo&gt;)sender {
  NSDragOperation dragMask = [sender draggingSourceOperationMask];
  NSPasteboard *p = [sender draggingPasteboard];  
  if ( [[pboard types] containsObject:NSURLPboardType] ) {
    if (dragMask &amp; NSDragOperationGeneric) 
      return NSDragOperationGeneric;
  }
  return NSDragOperationNone;
}</pre></div><p>Once the preceding code sets the text field <code class="literal">docURL</code> we use it with the database as if it were a string value the user had typed <a id="id281" class="indexterm"/>into an entry field.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Databases as documents via packages</h1></div></div></div><p>Our previous database <a id="id282" class="indexterm"/>samples created a database in a temporary location. Most applications need a database that behaves more like a document itself, which <a id="id283" class="indexterm"/>allows us to copy it around and open multiple databases. <code class="literal">Sample09</code> is such an <code class="literal">NSDocument</code> application, supporting <a id="id284" class="indexterm"/>independent collections of authors and other documents. Remember, we use a property to track our database—nothing prevents an application having multiple such properties and open databases.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>Unlike a typical document-based app, we must have the database operating as soon as we have a new window—we will save continuously rather than on-demand. To ensure this happens, the <code class="literal">NSWindowController</code> can trigger the <strong>Save As</strong> panel with <code class="literal">[[self document] saveDocumentAs:self]</code> to  get to choose a location for the database.</p></div></div><p>The complication occurs in how to handle the fact that a database is really stored in a directory of many files. Apple's <em>Bundle Programming Guide</em> describes how to create a <strong>Document Package</strong> <a id="id285" class="indexterm"/>which is a way of treating a specially named directory as if it were a single document. We use <code class="literal">leveldb</code> as an extension but you can choose your own.</p><p>First edit the <code class="literal">xxx-info.plist</code> file <a id="id286" class="indexterm"/>and add two entries to <code class="literal">CFBundleDocumentTypes</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a <code class="literal">LSTypeIsPackage</code> set to <code class="literal">True</code>.</li><li class="listitem">Add a <code class="literal">CFBundleTypeExtensions</code> with the desired extension, <code class="literal">leveldb</code>.</li></ol></div><p>If you compile and run that program, you will find that any directory named with that extension, such as <code class="literal">blah.leveldb</code>, will now appear as a single item in the finder and you have to right-click and choose <strong>Show Package Contents</strong> to navigate within. Hooking up the <code class="literal">NSDocument</code> subclass to open a database within that directory needs two overrides:</p><div><pre class="programlisting">- (BOOL)readFromFileWrapper:(NSFileWrapper*)fileWrapper
   ofType:(NSString*)typeName error:(NSError**)outError {
  self.db = [APLevelDB levelDBWithPath:[fileWrapper filename] 
    error:outError];
  return outError == nil;
}

- (BOOL)writeToURL:(NSURL*)url ofType:(NSString*)typeName
  error:(NSError**)outError {
  if (self.db == nil) { // our initial saveDocumentAs
    self.db = [APLevelDB levelDBWithPath:[url path]
      error: outError];
    return outError == nil;
  }
  return NO; 
}</pre></div><p>In both of the preceding methods, we end up getting a full path from an OS X function that supplied the user with a GUI for selecting a file or <strong>Save as</strong> location. Inside OS X that may be a sandboxed location—we <a id="id287" class="indexterm"/>were just <a id="id288" class="indexterm"/>handed back a usable <a id="id289" class="indexterm"/>path as a string.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Summary</h1></div></div></div><p>We learnt another key design exercise with the schema including two sources of multiple keys—word indexing and multiple authors. Typical drag-and-drop desktop behavior was shown to add file links in OS X, so you could see how a file URL becomes just a string value in a database. We finally saw how to have multiple databases opened and treated as single document on desktop, rather than being in fixed locations. Now, we will delve deeper into LevelDB and learn more about design trade-offs and settings.</p></div></body></html>