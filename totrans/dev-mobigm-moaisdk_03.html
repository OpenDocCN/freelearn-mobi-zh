<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Basic Moai SDK Concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Basic Moai SDK Concepts</h1></div></div></div><p>Every game engine has its own concepts behind it that define its internal workings. In this chapter, we will take a quick tour of the different ideas that Moai SDK uses, in order to understand it better.</p><div class="section" title="The Moai SDK Runtime"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>The Moai SDK Runtime</h1></div></div></div><p>Moai's Runtime uses <a id="id16" class="indexterm"/>two important data structures, namely, a <span class="emphasis"><em>dependency graph of objects/nodes</em></span> and a <span class="emphasis"><em>tree of actions</em></span>. What you'll (mostly) do as a developer is modify those data structures (in Lua, using the Moai SDK API).</p><p>The Moai update <a id="id17" class="indexterm"/>
<a id="id18" class="indexterm"/>loop has three steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Process the Input Queue</li><li class="listitem" style="list-style-type: disc">Process the Action Tree</li><li class="listitem" style="list-style-type: disc">Process the Node Graph</li></ul></div><p>In Moai, <span class="emphasis"><em>rendering is detached from the game loop</em></span>, since we might want to have more than one update step for every rendered frame.</p><div class="section" title="Input Queue"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec10"/>Input Queue</h2></div></div></div><p>When you press a key, move the mouse, or <a id="id19" class="indexterm"/>
<a id="id20" class="indexterm"/>tap on your iPhone's screen, the system generates an input event that is passed to Moai by the <span class="strong"><strong>Host</strong></span> and put into a queue (Using AKUEnqueue* methods). In every step of the simulation, Moai handles all input callbacks, processes the Input Queue, and then continues with the game loop.</p><div class="mediaobject"><img src="graphics/5064_03_01.jpg" alt="Input Queue"/></div><p>All the events that occur during the <a id="id21" class="indexterm"/>
<a id="id22" class="indexterm"/>game loop are enqueued in the next simulation step.</p></div><div class="section" title="Action Tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Action Tree</h2></div></div></div><p>Nodes are basically all of the objects that <a id="id23" class="indexterm"/>have information for your game, for example, an <a id="id24" class="indexterm"/>instance of a bullet would be a node in Moai, specifically a node that can be rendered.</p><p>Actions are in charge of managing the node's variation over time.</p><p>For example, changes in position, rotation, or scale would create an animation.</p><p>The role of the the Action Tree is to create a hierarchy of actions. The main goal for this is to enable actions to be responsible for the execution of child actions. Moai has a main root action that will run all of the actions appended to it.</p><p>Actions are the only objects in Moai that receive time steps. This means that time-based changes to Moai objects may only occur while processing the Action Tree. The Node Graph or rendering processes should not perform any change to the state of nodes.</p></div><div class="section" title="Node Graph"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Node Graph</h2></div></div></div><p>So, as we saw before, nodes are <a id="id25" class="indexterm"/>basically the objects that are living in your game. These objects connect with one another forming a graph. In every update loop step, Moai processes the nodes that have different states than the previous step. This is achieved with a <a id="id26" class="indexterm"/>queue of modified nodes. Every time an action modifies a node (or the node is linked to another node that was modified, or when a node's property was set directly), it's scheduled (along with the nodes it's connected to, and so on) and processed in the next simulation step.</p><div class="mediaobject"><img src="graphics/5064_03_02.jpg" alt="Node Graph"/></div><p>This behavior defines a parent/child relationship that is built at a low level, and thus allows easily created scene and <a id="id27" class="indexterm"/>
<a id="id28" class="indexterm"/>animation hierarchies.</p></div></div></div>
<div class="section" title="Rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Rendering</h1></div></div></div><p>So, where does the rendering take place then? In Moai SDK, rendering is detached from the update loop. The Render <a id="id29" class="indexterm"/>Manager is a singleton that is in charge of rendering. It keeps a table of objects to be rendered, you can modify that table as you want, and it will render all of the objects in it. It is worth mentioning that subtables are also rendered, so you can create a hierarchy of objects to be rendered.</p></div>
<div class="section" title="Moai Hosts"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Moai Hosts</h1></div></div></div><p>One of the key concepts <a id="id30" class="indexterm"/>behind Moai SDK is that of <span class="strong"><strong>hosts</strong></span>.</p><p>This is a neat solution that the folks from Zipline proposed for Moai SDK and basically states that Moai SDK provides a Lua interpreter and a C++ interface to the outside world. This interface is called <span class="strong"><strong>AKU</strong></span>
<a id="id31" class="indexterm"/>, and can be found in the Moai SDK source code.</p><p>Whenever you want to create a game for a specific platform, your host is in charge of configuring the input and sending input events to Moai, solving any threading issues from that platform, and also providing all platform-specific logic and Lua extensions along with an OpenGL canvas for rendering.</p><p>In this way, a game built in Moai is potentially deployable to all platforms that support C++ and OpenGL (well, not all OpenGL, just a subset of it, such as OpenGL ES), and those being industry standards, there is hardly any limitation.</p><p>Moai SDK is shipped with sample hosts for Windows, Mac OS X, iOS, Android, and Google's Native Client. You should be able to modify these hosts, and with little tweaks, have your game working on them.</p><p>Again, you build your game once using Lua, and you'll get all of these platforms to run on.</p></div>
<div class="section" title="Lua and C++"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Lua and C++</h1></div></div></div><p>Another interesting feature behind Moai is <a id="id32" class="indexterm"/>
<a id="id33" class="indexterm"/>the that you have access to both Lua and C++ to develop your game.</p><p>After setting up your nodes and actions using Lua, Moai SDK runs the simulation using native code written in C++. This means that you get the best of both worlds—the flexibility of Lua and the speed of C++.</p><p>All the platform-specific stuff (for example, handling the accelerometer on a smartphone) should be handled natively and connected to Moai SDK using a Lua extension or input events (check how hosts configure AKU, search for the AKUSetInputDevice* family of methods).</p><p>This is a key concept for Moai SDK development, because you can see that there is no limit to what libraries you can use with Moai SDK. It's just a matter of taking the time to write a Lua extension for it, and Bam! It's available in the scripting environment; you can combine the library functionality with your already existing game.</p><p>Aside from this, there is always the interpreted versus compiled native code dilemma. You know that working with Lua is more productive than using C++ for all the coding, but there are times when you just can't do something in Lua because of performance requirements. (Although this is extremely rare, Lua is fairly fast and bottlenecks usually are to be found in <a id="id34" class="indexterm"/>
<a id="id35" class="indexterm"/>rendering, logic execution takes very little time). You can always port your code to C++ (you can decide whether this is needed using profiling tools), then create a Lua extension with the same API, and you won't need to modify the rest of your code.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we talked about the nuts and bolts of the Moai SDK update loop in order to understand its inner workings. We took a look at the three main steps in the update loop, namely, the Input Queue, processing of the Action Tree, and processing of the Node Graph. We talked about Moai's detached rendering nature, the importance of hosts, and the idea behind having the C++ and Lua worlds tied together, and how to make wise use of that.</p><p>Well, enough talk about what's going on behind the scenes. Get a coffee now, since in the next chapter, we'll finally start implementing our first game and your curiosity won't let you take a break then.</p></div></body></html>