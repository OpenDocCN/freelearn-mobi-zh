<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Working with Creational Patterns</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we'll cover how classical creational patterns are implemented in Kotlin. These patterns deal with <em class="calibre14">how</em> and <em class="calibre14">when</em> you create your objects. Mastering these patterns will allow you to manage your objects better, adapt well to changes, and write code that is easy to maintain.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Singleton</li>
<li class="calibre12">Factory Method</li>
<li class="calibre12">Abstract Factory</li>
<li class="calibre12">Builder</li>
<li class="calibre12">Prototype</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Singleton</h1>
                
            
            <article>
                
<p class="calibre2">This is the most popular single guy in the neighborhood. Everybody knows him, everybody talks about him, and anybody can find him easily.</p>
<p class="calibre2">Even people who will frown when other design patterns are mentioned will know it by name. At some point, it was even proclaimed an anti-pattern, but only because of its wide popularity. So, for those who are hearing about it for the first time, what is this pattern about? </p>
<p class="calibre2">Usually, if you have an object, you can create as many of its instances as you want. Say, for example, you have the <kbd class="calibre13">Cat</kbd> class:</p>
<pre class="calibre18">class Cat</pre>
<p class="calibre2">You can produce as many of its instances (cats, to be precise), as you want:</p>
<pre class="calibre18">val firstCat = Cat()<br class="title-page-name"/>val secondCat = Cat()<br class="title-page-name"/>val yetAnotherCat = Cat()</pre>
<p class="calibre2">And there's no problem with that. </p>
<p class="calibre2">What if we wanted to disallow such behavior? Clearly, we have to create an object in some way for the first time. But from the second time on, we need to recognize that this object was initialized once already, and returns its instance instead. That's the main idea behind being a Singleton.</p>
<p class="calibre2">In Java and some other languages, this task is quite complex. It's not enough to simply make the constructor private and <em class="calibre14">remember</em> that the object was initialized at least once already. We also need to prevent race conditions, where two separate threads try to initialize it exactly at the same time. If we allowed that, it would break the entire concept of a Singleton, as two threads would hold references to two instances of the same object.</p>
<p class="calibre2">Solving this problem in Java requires doing one of the following:</p>
<ul class="calibre11">
<li class="calibre12">Accepting that a Singleton will initialize eagerly when your application starts, and not when it is first accessed</li>
<li class="calibre12">Writing some smart code to prevent such race conditions and still stay performant</li>
<li class="calibre12">Using a framework that already solves it</li>
</ul>
<p class="calibre2">Kotlin just introduces a reserved keyword for that. Behold, an object as follows:</p>
<pre class="calibre18">object MySingelton{}</pre>
<div class="packt_tip">You don't need curly brackets there. They're just for visual consistency.</div>
<p class="calibre2">This combines declaration and initialization in one keyword. From now on, <kbd class="calibre13">MySingleton</kbd> can be accessed from anywhere in your code, and there'll be exactly one instance of it.</p>
<p class="calibre2">Of course, this object doesn't do anything interesting. Let's make it count the number of invocations instead:</p>
<pre class="calibre18"><span>object </span>CounterSingleton {<br class="title-page-name"/>    <span>private val </span><span>counter </span>= AtomicInteger(<span>0</span>)</pre>
<pre class="calibre18"><br class="title-page-name"/>    <span>fun </span><span>increment</span>() = <span>counter</span>.incrementAndGet()<br class="title-page-name"/>}</pre>
<p class="calibre2">We won't test it for thread safety yet this is a topic that will be covered in <span class="calibre7"><a href="part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 8</a>, <em class="calibre14">Threads and Coroutines</em>, which deals with threads</span>. For now, we test it only to see how we call our Singleton:</p>
<pre class="calibre18"><span>for </span>(i <span>in </span><span>1</span>..<span>10</span>) {<br class="title-page-name"/>    <span>println</span>(CounterSingleton.increment())<br class="title-page-name"/>}</pre>
<p class="calibre2">This will print numbers between 1 and 10, as expected. As you can see, we don't need the <kbd class="calibre13">getInstance()</kbd> method at all.</p>
<div class="packt_infobox">The <kbd class="calibre20">object</kbd> keyword is used for more than just creating Singletons. We'll discuss it in depth later.</div>
<p class="calibre2">Objects can't have constructors. If you want some kind of initialization logic for your Singleton, such as loading data from the database or over the network for the first time, you can use the <kbd class="calibre13">init</kbd> block instead:</p>
<pre class="calibre18"><span>object </span>CounterSingleton {<br class="title-page-name"/><br class="title-page-name"/>    <span>init </span>{<br class="title-page-name"/>        <span>println</span>(<span>"I was accessed for the first time"</span>)<br class="title-page-name"/>    }<br class="title-page-name"/>    // More code goes here<br class="title-page-name"/>}</pre>
<p class="calibre2">It is also demonstrated that Singletons in Kotlin are initialized lazily, and not eagerly, as some could suspect from the ease of their declaration. Just like regular classes, objects can extend other classes and implement interfaces. We'll come back to this in <a href="part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 10</a>, <em class="calibre14">Idioms and Anti-Patterns</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Factory Method</h1>
                
            
            <article>
                
<p class="calibre2">The Factory Method is all about creating objects. But why do we need a method to create objects? Isn't it what constructors are all about?</p>
<p class="calibre2">Well, constructors have their inherent limitations, which we're about to discuss. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Factory</h1>
                
            
            <article>
                
<p class="calibre2">We'll start with the Factory Method formalized in the book <em class="calibre14">Design Patterns</em> <span class="calibre7">by </span>Gang of Four.</p>
<p class="calibre2">This is one of the first patterns I teach my students. They're usually very anxious about the whole concept of design patterns, since it has an aura of mystery and complexity.  So, what I do is ask them the following question.</p>
<p class="calibre2">Assume you have some class declaration, for example:</p>
<pre class="calibre18">class Cat {<br class="title-page-name"/>    val name = "Cat"<br class="title-page-name"/>}</pre>
<p class="calibre2">Could you write a function that returns a new instance of the class? Most of them would succeed:</p>
<pre class="calibre18">fun catFactory() : Cat {<br class="title-page-name"/>    return Cat()<br class="title-page-name"/>}</pre>
<p class="calibre2">Check that everything works:</p>
<pre class="calibre18">val c = catFactory() <br class="title-page-name"/>println(c.name) // Indeed prints "Cat"</pre>
<p class="calibre2">Well, that's really simple, right? </p>
<p class="calibre2">Now, <span class="calibre7">based on the argument we provide it, </span>can this method create one of two objects?</p>
<p class="calibre2">Let's say we now have a <kbd class="calibre13">Dog</kbd>:</p>
<pre class="calibre18">class Dog {<br class="title-page-name"/>    val name = "Dog"<br class="title-page-name"/>}</pre>
<p class="calibre2">Choosing between two types of objects to instantiate would require only passing an argument:</p>
<pre class="calibre18">fun animalFactory(animalType: String) : Cat {<br class="title-page-name"/>    return Cat()<br class="title-page-name"/>}</pre>
<p class="calibre2">Of course, we can't always return a <kbd class="calibre13">Cat</kbd> now. So we create a common interface to be returned:</p>
<pre class="calibre18">interface Animal {<br class="title-page-name"/>   val name : String<br class="title-page-name"/>}</pre>
<p class="calibre2">What's left is to use the <kbd class="calibre13">when</kbd> expression to return an instance of the correct class:</p>
<pre class="calibre18">return when(animalType.toLowerCase()) {<br class="title-page-name"/>    "cat" -&gt; Cat()<br class="title-page-name"/>    "dog" -&gt; Dog()<br class="title-page-name"/>    else -&gt; throw RuntimeException("Unknown animal $animalType")<br class="title-page-name"/>}</pre>
<p class="calibre2">That's what Factory Method is all about:</p>
<ul class="calibre11">
<li class="calibre12"><span>Get some value.</span></li>
<li class="calibre12">Return one of the objects that implement the common interface.</li>
</ul>
<p class="calibre2">This pattern is very useful when creating objects from a configuration. Imagine we have a text file with the following contents that came from a veterinary clinic:</p>
<pre class="calibre18">dog, dog, cat, dog, cat, cat</pre>
<p class="calibre2">Now we would like to create an empty profile for each animal. Assuming we've already read the file contents and split them into a list, we can do the following:</p>
<pre class="calibre18">val animalTypes = listOf("dog", "dog", "cat", "dog", "cat", "cat")<br class="title-page-name"/>    <br class="title-page-name"/>for (t in animalTypes) {<br class="title-page-name"/>  val c = animalFactory(t) <br class="title-page-name"/>    println(c.name)<br class="title-page-name"/>} </pre>
<div class="packt_infobox"><kbd class="calibre20">listOf</kbd> is a function that comes from the Kotlin standard library that creates an immutable list of provided objects.</div>
<div class="title-page-name">If your Factory Method doesn't need to have a state, we can leave it as a function.</div>
<p class="calibre2">But what if we want to assign a unique sequential identifier for each animal? Take a look at the following code block:</p>
<pre class="calibre18">interface Animal {<br class="title-page-name"/>   val id : Int<br class="title-page-name"/>   // Same as before<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Cat(override val id: Int) : Animal { <br class="title-page-name"/>    // Same as before<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Dog(override val id: Int) : Animal {<br class="title-page-name"/>    // Same as before<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that we can override values inside the constructor.</p>
<p class="calibre2">Our factory becomes a proper class now:</p>
<pre class="calibre18">class AnimalFactory { <br class="title-page-name"/>    var counter = 0<br class="title-page-name"/>    <br class="title-page-name"/>    fun createAnimal(animalType: String) : Animal {<br class="title-page-name"/>        return when(animalType.trim().toLowerCase()) {<br class="title-page-name"/>            "cat" -&gt; Cat(++counter)<br class="title-page-name"/>            "dog" -&gt; Dog(++counter)<br class="title-page-name"/>            else -&gt; throw RuntimeException("Unknown animal $animalType")<br class="title-page-name"/>        }<br class="title-page-name"/>    } <br class="title-page-name"/>}</pre>
<p class="calibre2">So we'll have to initialize it:</p>
<pre class="calibre18">val factory = AnimalFactory()<br class="title-page-name"/>for (t in animalTypes) {<br class="title-page-name"/>    val c = factory.createAnimal(t) <br class="title-page-name"/>    println("${c.id} - ${c.name}")<br class="title-page-name"/>} </pre>
<p class="calibre2">Output for the preceding code is as follows:</p>
<pre class="calibre18"><strong class="calibre1"><span>1 - Dog <br class="title-page-name"/>2 - Dog <br class="title-page-name"/>3 - Cat <br class="title-page-name"/>4 - Dog <br class="title-page-name"/>5 - Cat <br class="title-page-name"/>6 - Cat</span></strong></pre>
<p class="calibre2">This was a pretty straightforward example. We provided a common interface for our objects (<kbd class="calibre13">Animal</kbd>, in this case), then based on some arguments, we decided which concrete class to instantiate. </p>
<p class="calibre2">What if we decided to support different breeds? Take a look at the following code:</p>
<pre class="calibre18">val animalTypes = listOf("dog" to "bulldog", <br class="title-page-name"/>                         "dog" to "beagle", <br class="title-page-name"/>                         "cat" to "persian", <br class="title-page-name"/>                         "dog" to "poodle", <br class="title-page-name"/>                         "cat" to "russian blue", <br class="title-page-name"/>                         "cat" to "siamese")</pre>
<div class="packt_infobox">Much like the <kbd class="calibre20">downTo</kbd> function we saw in <a href="part0020.html#J2B80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre19">Chapter 1</a>, <em class="calibre22">Getting Started with Kotlin</em>, it looks like an operator, but it's a function that creates a pair of objects: (<kbd class="calibre20">cat</kbd>, <kbd class="calibre20">siamese</kbd>, in our case). We'll come back to it when we discuss the <kbd class="calibre20">infix</kbd> function in depth.</div>
<div class="title-page-name">We can delegate the actual object instantiation to other factories:</div>
<pre class="calibre18"><span>class </span>AnimalFactory {<br class="title-page-name"/>    <span>var </span><span>counter </span>= <span>0<br class="title-page-name"/></span><span>    </span><span>private val </span><span>dogFactory </span>= DogFactory()<br class="title-page-name"/>    <span>private val </span><span>catFactory </span>= CatFactory()<br class="title-page-name"/><br class="title-page-name"/>    <span>fun </span><span>createAnimal</span>(animalType: String<span>, </span>animalBreed: String) : Animal {<br class="title-page-name"/>        <span>return when</span>(animalType.<span>trim</span>().<span>toLowerCase</span>()) {<br class="title-page-name"/>            <span>"cat" </span>-&gt; <span>catFactory</span>.createDog(animalBreed<span>, </span>++<span>counter</span>)<br class="title-page-name"/>            <span>"dog" </span>-&gt; <span>dogFactory</span>.createDog(animalBreed<span>, </span>++<span>counter</span>)<br class="title-page-name"/>            <span>else </span>-&gt; <span>throw </span>RuntimeException(<span>"Unknown animal </span><span>$</span>animalType<span>"</span>)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The factory repeats the same pattern again:</p>
<pre class="calibre18"><span>class </span>DogFactory {<br class="title-page-name"/>    <span>fun </span><span>createDog</span>(breed: String<span>, </span>id: Int) = <span>when</span>(breed.<span>trim</span>().<span>toLowerCase</span>()) {<br class="title-page-name"/>        <span>"beagle" </span>-&gt; Beagle(id)<br class="title-page-name"/>        <span>"bulldog" </span>-&gt; Bulldog(id)<br class="title-page-name"/>        <span>else </span>-&gt; <span>throw </span>RuntimeException(<span>"Unknown dog breed </span><span>$</span>breed<span>"</span>)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">You can make sure that you understand this example by implementing <kbd class="calibre13">Beagle</kbd>, <kbd class="calibre13">Bulldog</kbd>, <kbd class="calibre13">CatFactory</kbd>, and all the different breeds of cats by yourself.</p>
<p class="calibre2">The last point to note is how we're now calling our <kbd class="calibre13">AnimalFactory</kbd> with a pair of arguments:</p>
<pre class="calibre18"><span>for </span>((type<span>, </span>breed) <span>in </span>animalTypes) {<br class="title-page-name"/>    <span>val </span>c = factory.createAnimal(type<span>, </span>breed)<br class="title-page-name"/>    println(c.name)<br class="title-page-name"/>}</pre>
<p class="calibre2">This is called a <strong class="calibre5">destructuring declaration</strong>, and is <span class="calibre7">useful</span> especially when dealing with such pairs of data. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Static Factory Method</h1>
                
            
            <article>
                
<p class="calibre2">The Static Factory Method was popularized by Joshua Bloch in his book <em class="calibre14">Effective Java</em>. To understand it better, let's look at the examples from Java standard library itself, the <kbd class="calibre13">valueOf()</kbd> methods:</p>
<pre class="calibre18">Long l1 = <span>new </span>Long(<span>"1"</span>)<span>;<br class="title-page-name"/></span>Long l2 = Long.<span>valueOf</span>(<span>"1"</span>)<span>;</span></pre>
<p class="calibre2">Both the constructor and the <kbd class="calibre13">valueOf()</kbd> method receive <kbd class="calibre13">String</kbd> as input and produce <kbd class="calibre13">Long</kbd> as output.</p>
<p class="calibre2">So, why is the Static Factory Method sometimes better than a constructor? </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Advantages of the Static Factory Method</h1>
                
            
            <article>
                
<p class="calibre2">Here are some of the advantages of a Static Factory Method over constructors:</p>
<ul class="calibre11">
<li class="calibre12">It provides a better name for the constructor, what it expects, and, sometimes, what it produces.</li>
<li class="calibre12">We usually don't expect exceptions from a constructor. Exceptions from a regular method, on the other hand, are totally valid.</li>
<li class="calibre12">Speaking of expectations, we expect the constructor to be fast. </li>
</ul>
<p class="calibre2">But those are more psychological advantages. There are also some technological advantages to this approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Caching</h1>
                
            
            <article>
                
<p class="calibre2">The Static Factory Method may provide caching, as <kbd class="calibre13">Long</kbd> actually does. Instead of always returning a new instance for any value, <kbd class="calibre13">valueOf()</kbd> checks in-cache whether this value was already parsed. If it is, it returns a cached instance. Repeatedly calling the Static Factory Method with the same values may produce less garbage for collection than using constructors all the time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Subclassing</h1>
                
            
            <article>
                
<p class="calibre2">When calling the constructor, we always instantiate the class we specify. On the other hand, calling a Static Factory Method may produce either instance of the class, or one of its subclasses. We'll come to this after discussing the implementation of this design pattern in Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Static Factory Method in Kotlin</h1>
                
            
            <article>
                
<p class="calibre2">We've already discussed the <kbd class="calibre13">object</kbd> keyword earlier in the <em class="calibre14">Singleton</em> section. Now we'll see another use of it is a <kbd class="calibre13">companion</kbd> object.</p>
<p class="calibre2">In Java, Static Factory Methods are declared <kbd class="calibre13">static</kbd>. But in Kotlin, there's no such keyword. Instead, methods that don't belong to an instance of a class can be declared inside a <kbd class="calibre13">companion</kbd> object:</p>
<pre class="calibre18"><span>class </span>NumberMaster {<br class="title-page-name"/>    <span>companion object </span>{<br class="title-page-name"/>        <span>fun </span><span>valueOf</span>(hopefullyNumber: String) : Long {<br class="title-page-name"/>            <span>return </span>hopefullyNumber.<span>toLong</span>()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<div class="packt_tip">Companion objects may have a name: companion object Parser, for example. But this is only for clarity of what the goal of this object is.</div>
<p class="calibre2">Calling a <kbd class="calibre13">companion</kbd> object doesn't require instantiating a class:</p>
<pre class="calibre18"><span>println</span>(NumberMaster.valueOf(<span>"123"</span>)) // Prints 123</pre>
<p class="calibre2">Moreover, calling it on an instance of a class simply won't work, unlike Java:</p>
<pre class="calibre18">println(NumberMaster().valueOf(<span>"123"</span>)) // Won't compile</pre>
<div class="packt_infobox">The class may have only one companion object.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Companion object</h1>
                
            
            <article>
                
<p class="calibre2">In Java, Static Factory Methods are declared like this:</p>
<pre class="calibre18">private static class MyClass { 
  
 // Don't want anybody to use it but me 
  private MyClass() { 
  } 
  
 // This will replace the public constructor 
  public static MyClass create() { 
    return new MyClass(); 
  } 
} </pre>
<p class="calibre2">They are called like this:</p>
<pre class="calibre18">MyClass myClass = MyClass.create(); </pre>
<p class="calibre2">But in Kotlin, there's no such keyword as Static. Instead, methods that don't belong to an instance of a class can be declared inside a companion object.</p>
<p class="calibre2">We discussed the<span class="calibre7"> </span><kbd class="calibre13">object</kbd><span class="calibre7"> </span>keyword earlier, in the section<span class="calibre7"> </span><em class="calibre14">Singletons</em>. Now, we'll look at another use of this important keyword using the following example:</p>
<pre class="calibre18">   class NumberMaster { 
       companion object { 
           fun valueOf(hopefullyNumber: String) : Long { 
               return hopefullyNumber.toLong() 
           }  
       } 
   } </pre>
<p class="calibre2">As you can see, inside our class, we have declared an object that is prefixed by the keyword<span class="calibre7"> </span><kbd class="calibre13">companion</kbd>.</p>
<p class="calibre2">This object has its own set of functions. What's the benefit of this? You may wonder.</p>
<p class="calibre2">Just like a Java Static method, calling a<span class="calibre7"> </span><kbd class="calibre13">companion</kbd><span class="calibre7"> </span>object doesn't require the instantiation of a class:</p>
<pre class="calibre18">println(NumberMaster.valueOf("123")) // Prints 123 </pre>
<p class="calibre2">Moreover, calling it on an instance of a class simply won't work, which is not the case with Java:</p>
<pre class="calibre18">println(NumberMaster().valueOf("123")) // Won't compile </pre>
<div class="packt_tip">A<span class="calibre23"> </span><kbd class="calibre20">companion</kbd><span class="calibre23"> </span>object may have a name-Parser, for example. But this is only for clarity of what the goal of this object is.<br class="calibre21"/>
The class may have only one<span class="calibre23"> </span><kbd class="calibre20">companion</kbd><span class="calibre23"> </span>object.</div>
<p class="calibre2">By using a<span class="calibre7"> </span><kbd class="calibre13">companion</kbd><span class="calibre7"> </span>object, we can achieve exactly the same behavior that we see in Java:</p>
<pre class="calibre18">private class MyClass private constructor() { 
 
    companion object { 
        fun create(): MyClass { 
            return MyClass() 
        } 
    } 
} </pre>
<p class="calibre2">We can now instantiate our object, as shown in the following code:</p>
<pre class="calibre18">// This won't compile 
//val instance = MyClass() 
 
// But this works as it should 
val instance = MyClass.create() </pre>
<p class="calibre2">Kotlin proves itself a very practical language. Every keyword in it has a down-to-earth meaning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstract Factory</h1>
                
            
            <article>
                
<p class="calibre2">Abstract Factory is a greatly misunderstood pattern. It has a notorious reputation for being very complex and bizarre but actually, it's quite simple. If you understood the Factory Method, you'll understand this one in no time. This is because Abstract Factory is a factory of factories. That's all there is to it, really. The factory is a function or class that's able to create other classes. Abstract Factory is a class that creates factories.</p>
<p class="calibre2">You may understand that and still wonder what the usages of such a pattern may be. The main usage of Abstract Factory in the real world would probably be frameworks, most notably Spring Framework, which uses the notion of Abstract Factory to create its components out of annotations and XML files. But since creating our own framework may be quite tiresome, let's take another example where this pattern will be very useful—a strategy game.</p>
<p class="calibre2">We'll call it <em class="calibre14">CatsCraft 2: Revenge of the Dogs</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstract Factory in action</h1>
                
            
            <article>
                
<p class="calibre2">Our strategy game will consist of buildings and units. Let's start with declaring what all buildings share:</p>
<pre class="calibre18"><span>interface </span>Building&lt;<span>in </span><span>UnitType</span><span>, out </span><span>ProducedUnit</span>&gt; <br class="title-page-name"/>        <span>where </span><span>UnitType </span>: Enum&lt;*&gt;<span>, </span><span>ProducedUnit </span>: Unit {<br class="title-page-name"/>    <span>fun </span><span>build</span>(type: <span>UnitType</span>) : <span>ProducedUnit<br class="title-page-name"/></span>}</pre>
<p class="calibre2">All buildings should implement the <kbd class="calibre13">build()</kbd> function. Here we see generics in Kotlin for the first time, so let's discuss them a bit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to generics in Kotlin</h1>
                
            
            <article>
                
<p class="calibre2"> </p>
<p class="calibre2">Generics are a way to specify the relationships between types. Well, that didn't help explain much, did it? Let's try again. Generics are an abstraction of types. Nope, still awful.</p>
<p class="calibre2">We'll try an example, then:</p>
<pre class="calibre18">    val listOfStrings = mutableListOf("a", "b", "c") </pre>
<p class="calibre2">Ok, that's easy; we've covered it a lot of times. This code simply creates a list of strings. But what does it actually mean?</p>
<p class="calibre2">Let's try the following line of code:</p>
<pre class="calibre18">listOfStrings.add(1) </pre>
<p class="calibre2">This line doesn't compile. That's because the<span class="calibre7"> </span><kbd class="calibre13">mutableListOf()</kbd><span class="calibre7"> </span>function uses generics:</p>
<pre class="calibre18">public fun &lt;T&gt; mutableListOf(vararg elements: T): MutableList&lt;T&gt; </pre>
<p class="calibre2">Generics create an expectation. No matter which type we use to create our list, from now on we can only put that type in it. It's a great language feature because, on the one hand, we can generalize our data structures or algorithms. No matter what types they hold, they'll still work in exactly the same way.</p>
<p class="calibre2">On the other hand, we still have type safety. The<span class="calibre7"> </span><kbd class="calibre13">listOfStrings</kbd>. <kbd class="calibre13">first()</kbd><span class="calibre7"> </span>function is guaranteed to return a<span class="calibre7"> </span><kbd class="calibre13">String</kbd><span class="calibre7"> </span>(in this case) and nothing else.</p>
<p class="calibre2">In terms of generics, Kotlin uses an approach that is similar to, but slightly different from, Java. We won't cover all the aspects of generics in this section, but will only provide some guidance to better understand this example. As we go on, we'll encounter more uses of generics.</p>
<p class="calibre2">Let's look at another example.</p>
<p class="calibre2">We'll create a class called<span class="calibre7"> </span><kbd class="calibre13">Box</kbd>. Boring, I know:</p>
<pre class="calibre18">class Box&lt;T&gt; { 
    private var inside: T? = null 
 
    fun put(t: T) { 
        inside = t 
    }    
    fun get(): T? = inside 
} </pre>
<p class="calibre2">What's great about this box, though, is that by using generics, I can put just about anything in it, for example, a cat:</p>
<pre class="calibre18">class Cat </pre>
<p class="calibre2">When I create an instance of a box, I specify what it can hold:</p>
<pre class="calibre18">val box = Box&lt;Cat&gt;() </pre>
<p class="calibre2">At compile time, the generics will make sure that it will<span class="calibre7"> </span><span class="calibre7">only </span>hold objects of the correct type:</p>
<pre class="calibre18">box.put(Cat()) // This will work 
val cat = box.get() // This will always return a Cat, because that's what our box holds 
box.put("Cat") // This won't work, String is not a Cat </pre>
<p class="calibre2">As you may know, Java uses the<span class="calibre7"> </span>wildcards <kbd class="calibre13">?</kbd> extends, and super keywords to specify read-only and write-only types.</p>
<p class="calibre2">Kotlin uses the concepts of<span class="calibre7"> </span><kbd class="calibre13">in</kbd>,<span class="calibre7"> </span><kbd class="calibre13">out</kbd>, and<span class="calibre7"> </span><kbd class="calibre13">where</kbd>.</p>
<p class="calibre2">A type that is marked as<span class="calibre7"> </span><kbd class="calibre13">in</kbd><span class="calibre7"> </span>can be used as a parameter but not as a return value. This is also called covariance. In fact, it means that we can return<span class="calibre7"> </span><kbd class="calibre13">ProducedUnit</kbd><span class="calibre7"> </span>or something that inherits from it, but not something that is above<span class="calibre7"> </span><kbd class="calibre13">ProducedUnit</kbd><span class="calibre7"> </span>in the hierarchy.</p>
<p class="calibre2">Types that are marked as<span class="calibre7"> </span><kbd class="calibre13">out</kbd><span class="calibre7"> </span>can be used only as a return value, not as a parameter. This is called contravariance.</p>
<p class="calibre2">Furthermore, we may introduce constraints on types using the<span class="calibre7"> </span><kbd class="calibre13">where</kbd><span class="calibre7"> </span>keyword. In our case, we require that the first type implements the<span class="calibre7"> </span><kbd class="calibre13">Type</kbd><span class="calibre7"> </span>interface, while the second type implements the<span class="calibre7"> </span><kbd class="calibre13">Unit</kbd><span class="calibre7"> </span>interface.</p>
<p class="calibre2">The names of the types themselves,<span class="calibre7"> </span><kbd class="calibre13">UnitType</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">ProducedUnit</kbd>, could be anything we want,<span class="calibre7"> </span><kbd class="calibre13">T</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">P</kbd>, for example. But for the sake of clarity, we'll use more verbose names.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Back to our bases</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7">HQ is a special building that can produce other buildings. It keeps track of all the buildings it had built up until now. The s</span>ame type of building can be built more than once:</p>
<pre class="calibre18"><span>class </span>HQ {<br class="title-page-name"/>    <span>val </span><span>buildings </span>= <span>mutableListOf</span>&lt;Building&lt;*<span>, </span>Unit&gt;&gt;()<br class="title-page-name"/><br class="title-page-name"/>    <span>fun </span><span>buildBarracks</span>(): Barracks {<br class="title-page-name"/>        <span>val </span>b = Barracks()<br class="title-page-name"/>        <span>buildings</span>.add(b)<br class="title-page-name"/>        <span>return </span>b<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    <span>fun </span><span>buildVehicleFactory</span>(): VehicleFactory {<br class="title-page-name"/>        <span>val </span>vf = VehicleFactory()<br class="title-page-name"/>        <span>buildings</span>.add(vf)<br class="title-page-name"/>        <span>return </span>vf<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<div class="packt_infobox"><span class="calibre23">You may be wondering what the star (</span><kbd class="calibre20">*</kbd><span class="calibre23">) means as regards generics. It's called a star projection, and it means <em class="calibre22">I don't know anything about this type</em>. It's similar to Java's raw types, but it's type safe.</span></div>
<p class="calibre2">All other buildings produce units. Units can be either infantry or armored vehicle:</p>
<pre class="calibre18">interface Unit <br class="title-page-name"/><br class="title-page-name"/>interface Vehicle : Unit<br class="title-page-name"/><br class="title-page-name"/>interface Infantry : Unit</pre>
<p class="calibre2">Infantry can be either riflemen or rocket soldier:</p>
<pre class="calibre18"><span>class </span>Rifleman : Infantry<br class="title-page-name"/><br class="title-page-name"/><span>class </span>RocketSoldier : Infantry<br class="title-page-name"/><br class="title-page-name"/><span>enum class </span>InfantryUnits {<br class="title-page-name"/>    <span>RIFLEMEN</span><span>,<br class="title-page-name"/></span><span>    </span><span>ROCKET_SOLDIER<br class="title-page-name"/></span>}</pre>
<p class="calibre2">Here we see the <kbd class="calibre13">enum</kbd> keyword for the first time. Vehicles <span class="calibre7">are either t</span>anks <span class="calibre7">or <strong class="calibre5">armored personnel carriers</strong> (<strong class="calibre5">APCs</strong>):</span></p>
<pre class="calibre18"><span>class </span>APC : Vehicle<br class="title-page-name"/><br class="title-page-name"/><span>class </span>Tank : Vehicle<br class="title-page-name"/><br class="title-page-name"/><span>enum class </span>VehicleUnits {<br class="title-page-name"/>    <span>APC</span><span>,<br class="title-page-name"/></span><span>    </span><span>TANK<br class="title-page-name"/></span>}</pre>
<p class="calibre2">A barracks is a building that produces infantry:</p>
<pre class="calibre18"><span>class </span>Barracks : Building&lt;InfantryUnits<span>, </span>Infantry&gt; {<br class="title-page-name"/>    <span>override fun </span><span>build</span>(type: InfantryUnits): Infantry {<br class="title-page-name"/>        <span>return when </span>(type) {<br class="title-page-name"/>            <span>RIFLEMEN </span>-&gt; Rifleman()<br class="title-page-name"/>            <span>ROCKET_SOLDIER </span>-&gt; RocketSoldier()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<div class="packt_infobox">We don't need the <kbd class="calibre20">else</kbd> block in our <kbd class="calibre20">when</kbd>. That's because we use <kbd class="calibre20">enum</kbd>, and Kotlin makes sure that <kbd class="calibre20">when</kbd> on <kbd class="calibre20">enum</kbd> is exhaustive.</div>
<p class="calibre2">A vehicle factory is a building that produces different types of armored vehicles:</p>
<pre class="calibre18"><span>class </span>VehicleFactory : Building&lt;VehicleUnits<span>, </span>Vehicle&gt; {<br class="title-page-name"/>    <span>override fun </span><span>build</span>(type: VehicleUnits) = <span>when </span>(type) {<br class="title-page-name"/>        <span>APC </span>-&gt; APC()<br class="title-page-name"/>        <span>TANK </span>-&gt; Tank()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We can make sure that we can build different units now:</p>
<pre class="calibre18"><span>val </span>hq = HQ()<br class="title-page-name"/><span>val </span>barracks1 = hq.buildBarracks()<br class="title-page-name"/><span>val </span>barracks2 = hq.buildBarracks()<br class="title-page-name"/><span>val </span>vehicleFactory1 = hq.buildVehicleFactory()</pre>
<p class="calibre2">And now on to producing units:</p>
<pre class="calibre18"><span>val </span>units = <span>listOf</span>(<br class="title-page-name"/>        barracks1.build(InfantryUnits.<span>RIFLEMEN</span>)<span>,<br class="title-page-name"/></span><span>        </span>barracks2.build(InfantryUnits.<span>ROCKET_SOLDIER</span>)<span>,<br class="title-page-name"/></span><span>        </span>barracks2.build(InfantryUnits.<span>ROCKET_SOLDIER</span>)<span>,<br class="title-page-name"/></span><span>        </span>vehicleFactory1.build(VehicleUnits.<span>TANK</span>)<span>,<br class="title-page-name"/></span><span>        </span>vehicleFactory1.build(VehicleUnits.<span>APC</span>)<span>,<br class="title-page-name"/></span><span>        </span>vehicleFactory1.build(VehicleUnits.<span>APC</span>)<br class="title-page-name"/>)</pre>
<p class="calibre2">We've already seen the <kbd class="calibre13">listOf()</kbd> function from the standard library. It will create a read-only list of different units that our buildings produce. You can iterate over this list and make sure that those are indeed the units we require.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Making improvements</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7">One may claim that</span> having the <kbd class="calibre13">VehicleFactory</kbd> and <kbd class="calibre13">Barracks</kbd> classes is too cumbersome. They don't have any state, after all. Instead, we can replace them with objects.</p>
<p class="calibre2">Instead of the previous implementation of <kbd class="calibre13">buildBarracks()</kbd>, we can have the following:</p>
<pre class="calibre18"><span>fun </span><span>buildBarracks</span>(): Building&lt;InfantryUnits<span>, </span>Infantry&gt; {<br class="title-page-name"/>    <span>val </span>b = <span>object </span>: Building&lt;InfantryUnits<span>, </span>Infantry&gt; {<br class="title-page-name"/>        <span>override fun </span><span>build</span>(type: InfantryUnits): Infantry {<br class="title-page-name"/>            <span>return when </span>(type) {<br class="title-page-name"/>                InfantryUnits.<span>RIFLEMEN </span>-&gt; Rifleman()<br class="title-page-name"/>                InfantryUnits.<span>ROCKET_SOLDIER </span>-&gt; RocketSoldier()<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    <span>buildings</span>.add(b)<br class="title-page-name"/>    <span>return </span>b<br class="title-page-name"/>}</pre>
<p class="calibre2">We've already seen two different usages of the <kbd class="calibre13">object</kbd> keyword: once in the Singleton design pattern, and another time in the Factory Method design pattern. Here is the third way we can use it: for creating anonymous classes on the fly. After all, <kbd class="calibre13">Barracks</kbd> is a building that, given <kbd class="calibre13">InfantryUnitType</kbd>, produces <kbd class="calibre13">Infantry</kbd>.</p>
<p class="calibre2">If our logic is straightforward, we can even shorten the declaration a bit more:</p>
<pre class="calibre18"><span>fun </span><span>buildVehicleFactory</span>(): Building&lt;VehicleUnits<span>, </span>Vehicle&gt; {<br class="title-page-name"/>    <span>val </span>vf = <span>object </span>: Building&lt;VehicleUnits<span>, </span>Vehicle&gt; {<br class="title-page-name"/>        <span>override fun </span><span>build</span>(type: VehicleUnits) = <span>when </span>(type) {<br class="title-page-name"/>            VehicleUnits.<span>APC </span>-&gt; APC()<br class="title-page-name"/>            VehicleUnits.<span>TANK </span>-&gt; Tank()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    <span>buildings</span>.add(vf)<br class="title-page-name"/><br class="title-page-name"/>    <span>return </span>vf<br class="title-page-name"/>}</pre>
<p class="calibre2">Let's go to the beginning of this chapter. We said that Abstract Factory combines a number of related factories. So, what's common to all factories in our case? They're all buildings and they all produce units.</p>
<p class="calibre2">Having that principle in mind, you could apply it to many different cases. If you're familiar with strategy games, usually they have at least two different factions. Each may have different structures and units. To achieve that, you can repeat this pattern as many times as needed.</p>
<p class="calibre2">Let's assume we have two different factions now, cats and dogs, and Tanks and Rocket Infantry are only prerogatives of this faction. Dogs have Heavy Tanks and Grenadiers instead. What changes do we need to make in our system?</p>
<p class="calibre2">First, <kbd class="calibre13">HQ</kbd> becomes an interface:</p>
<pre class="calibre18"><span>interface </span>HQ {<br class="title-page-name"/>    <span>fun </span><span>buildBarracks</span>(): Building&lt;InfantryUnits<span>, </span>Infantry&gt;<br class="title-page-name"/>    <span>fun </span><span>buildVehicleFactory</span>(): Building&lt;VehicleUnits<span>, </span>Vehicle&gt;<br class="title-page-name"/>}</pre>
<p class="calibre2">What was <kbd class="calibre13">HQ</kbd> previously now becomes <kbd class="calibre13">CatHQ</kbd>:</p>
<pre class="calibre18"><span>class </span>CatHQ : HQ { <br class="title-page-name"/>// Remember to add override to your methods<br class="title-page-name"/>}</pre>
<p class="calibre2">And <kbd class="calibre13">DogHQ</kbd> will have to repeat the same steps, but with a different construction logic.</p>
<p class="calibre2">This ability to accommodate big changes is what makes Abstract Factory so powerful in some use cases. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Builder</h1>
                
            
            <article>
                
<p class="calibre2">Sometimes, our objects are very simple, and have only one constructor, be it an empty or non-empty one. But sometimes, their creation is very complex, and based on a lot of parameters. We've seen one pattern already that provides <em class="calibre14">a better constructor</em>—the Static Factory Method design pattern. Now, we'll discuss Builder design pattern, which is somewhat similar and somewhat different.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Composing an email</h1>
                
            
            <article>
                
<p class="calibre2">As a software architect, one of my main channels of communication is email. Probably this is true of most software development roles. </p>
<p class="calibre2">An email has the following:</p>
<ul class="calibre11">
<li class="calibre12">An address (at least one is mandatory)</li>
<li class="calibre12">CC (zero or more, optional)</li>
<li class="calibre12">Title (optional)</li>
<li class="calibre12">Body (optional)</li>
<li class="calibre12">Attachment (zero or more, optional)</li>
</ul>
<p class="calibre2">Let's assume I'm really lazy, and would like to schedule emails to be sent while I'm actually biking around the neighborhood.</p>
<p class="calibre2">The actual scheduling logic will be postponed to <span class="calibre7"><a href="part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 8</a>, <em class="calibre14">Threads and Coroutines</em>, and <a href="part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 9</a></span>, <em class="calibre14">Designed for Concurrency</em>, which discuss scheduling and concurrency. For now, let's see what our <kbd class="calibre13">Mail</kbd> class may look like:</p>
<pre class="calibre18">data class Mail(val to: String, <br class="title-page-name"/>           val cc: List&lt;String&gt;, <br class="title-page-name"/>           val bcc: List&lt;String&gt;,<br class="title-page-name"/>           val title: String?,<br class="title-page-name"/>           val message: String)</pre>
<p class="calibre2">So, we've already seen <kbd class="calibre13">data class</kbd> in action in the previous chapters. We've also discussed nullable and non-nullable types, such as <span class="calibre7"><kbd class="calibre13">String?</kbd> versus </span><kbd class="calibre13">String</kbd>.</p>
<p class="calibre2"><span class="calibre7">Now is a good time to discuss how collections work in Kotlin</span>, since this is the first time we have a class that deals with them directly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collection types in Kotlin</h1>
                
            
            <article>
                
<p class="calibre2">One of the main Kotlin goals is Java interoperability. So it's no wonder that Kotlin collections are interoperable with Java. When you specify that your functions receives <kbd class="calibre13">List&lt;T&gt;</kbd>, it is actually the same Java <kbd class="calibre13">List&lt;T&gt;</kbd> you're familiar with.</p>
<p class="calibre2">But Kotlin differentiates between mutable and immutable collections. The <kbd class="calibre13">listOf()</kbd> function is delegated to <kbd class="calibre13">Arrays.asList()</kbd>, and produces an immutable list, while <kbd class="calibre13">mutableListOf()</kbd> simply calls <kbd class="calibre13">ArrayList()</kbd>.</p>
<p class="calibre2">On top of data, Kotlin collection has many useful extension methods, which we'll discuss later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating an email – first attempt</h1>
                
            
            <article>
                
<p class="calibre2">So, at 10 A.M., I plan to drink a coffee in my local cafe. But I also want to contact my manager, since my payslip didn't arrive yesterday. I attempt to create my first email like so:</p>
<pre class="calibre18">val mail = Mail("manager@company.com", // TO<br class="title-page-name"/>    null,   // CC<br class="title-page-name"/>    null,   // BCC<br class="title-page-name"/>    "Ping", // Title<br class="title-page-name"/>    null    // Message)</pre>
<p class="calibre2">This may have worked in Java, but in Kotlin this wouldn't compile, since we cannot pass <kbd class="calibre13">null</kbd> to <kbd class="calibre13">List&lt;String&gt;</kbd>. <span class="calibre7">Null-safety is very important in Kotlin</span>:</p>
<pre class="calibre18">val mail = Mail("manager@company.com", // TO<br class="title-page-name"/>    listOf(),  // CC<br class="title-page-name"/>    listOf(),  // BCC<br class="title-page-name"/>    "Ping",    // Title<br class="title-page-name"/>    null       // Message) </pre>
<p class="calibre2">Note that since our constructor receives a lot of arguments, I had to put in some comments, so I wouldn't get lost.</p>
<div class="packt_infobox">The Kotlin compiler is smart enough to infer the type of list that we pass. Since our constructor receives <kbd class="calibre20">List&lt;String&gt;</kbd>, it's enough to pass <kbd class="calibre20">listOf()</kbd> for an empty list. We don't need to specify the type like so: <kbd class="calibre20">listOf&lt;String&gt;()</kbd>. In Java, Diamond Operator serves the same purpose.</div>
<p class="calibre2">Oh, but I forgot about attachments. Let's change our constructor:</p>
<pre class="calibre18">data class Mail(val to: String, <br class="title-page-name"/>           val cc: List&lt;String&gt;, <br class="title-page-name"/>           val bcc: List&lt;String&gt;,<br class="title-page-name"/>           val title: String?,<br class="title-page-name"/>           val message: String?,<br class="title-page-name"/>           val attachments: List&lt;java.io.File&gt;)</pre>
<p class="calibre2">But then our instantiation stops compiling again:</p>
<pre class="calibre18">val mail = Mail("manager@company.com", // TO<br class="title-page-name"/>    listOf(), listOf(),<br class="title-page-name"/>    "Ping",<br class="title-page-name"/>    null) // Compilation error, No value passed for for parameter 'attachments'</pre>
<p class="calibre2">This clearly becomes a mess.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating an email – second attempt</h1>
                
            
            <article>
                
<p class="calibre2">Let's try a fluent setter approach instead. We'll have only mandatory fields in our constructor, and all others will become setters, so the creation of a new email would look something like this:</p>
<pre class="calibre18">Mail("manager@company.com").title("Ping").cc(listOf&lt;String&gt;())</pre>
<p class="calibre2">That's a lot nicer for many reasons:</p>
<ul class="calibre11">
<li class="calibre12">The order of fields can now be arbitrary, unlike with the constructor.</li>
<li class="calibre12">It's clearer which field is being set, no need for comments anymore.</li>
<li class="calibre12">Optional fields don't need to be set at all. As an example, the CC field is set, while the BCC field is omitted.</li>
</ul>
<p class="calibre2">Let's see one way of implementing this approach. There are other convenient ways to do it, which we'll discuss in <a href="part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 10</a>, <em class="calibre14">Idioms and Anti-Patterns</em>:</p>
<pre class="calibre18"><span>data class </span>Mail(<span>// Stays the same<br class="title-page-name"/></span><span>                </span><span>private var _</span><span>message</span>: String = <span>""</span><span>,<br class="title-page-name"/></span><span>                </span><span>// ...) {<br class="title-page-name"/></span><span>    fun </span><span>message</span>(message: String) : Mail {<br class="title-page-name"/>        _<span>message </span>= message<br class="title-page-name"/>        <span>return this<br class="title-page-name"/></span>    }</pre>
<pre class="calibre18">    // Pattern repeats for every other variable<br class="title-page-name"/>}</pre>
<div class="packt_infobox">Using underscores for private variables is a common convention in Kotlin. It allows us to avoid repeating <kbd class="calibre20">this.message = message</kbd> and mistakes such as <kbd class="calibre20">message = message</kbd>.</div>
<p class="calibre2">This is nice, and very similar to what we may achieve in Java. Although we did have to make our message mutable now. But Kotlin provides two other ways that you may find even more useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating an email – the Kotlin way</h1>
                
            
            <article>
                
<p class="calibre2">Like some other modern languages, Kotlin provides us with the ability to set <em class="calibre14">default values</em> for function parameters:</p>
<pre class="calibre18">data class Mail(val to: String, <br class="title-page-name"/>    val title: String = "",<br class="title-page-name"/>    val message: String = "",<br class="title-page-name"/>    val cc: List&lt;String&gt; = listOf(), <br class="title-page-name"/>    val bcc: List&lt;String&gt; = listOf(), <br class="title-page-name"/>    val attachments: List&lt;java.io.File&gt; = listOf())</pre>
<p class="calibre2">So, if you would like to send an email without CC, you can do it like that now:</p>
<pre class="calibre18">val mail = Mail("one@recepient.org", "Hi", "How are you")</pre>
<p class="calibre2">But what about the case where you want to send an email with BCC? Also, not having to specify order with fluent setters was very handy. Kotlin has <em class="calibre14">named arguments</em> for that:</p>
<pre class="calibre18">val mail = Mail(title= "Hello", message="There", to="my@dear.cat")</pre>
<p class="calibre2">Combining default parameters with named arguments makes creating complex objects in Kotlin a lot easier than before. There's another way to achieve somewhat similar behavior: the <kbd class="calibre13">apply()</kbd> function. This is one of the extension functions that every object in Kotlin has. In order to use this approach, though, we'll need to make all the optional fields variables instead of values:</p>
<p class="calibre2">Then we can create our email like this:</p>
<pre class="calibre18"><span>val </span>mail = Mail(<span>"hello@mail.com"</span>).<span>apply </span><span>{<br class="title-page-name"/></span><span>    </span><span>message </span>= <span>"Something"<br class="title-page-name"/></span><span>    </span><span>title </span>= <span>"Apply"<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">The <kbd class="calibre13">apply()</kbd> function is the only one out of the family of <strong class="calibre5">scoping functions</strong>. We'll discuss how scoping functions work and are their uses in later chapters. Now, while my boss thinks I'm working hard sending all these emails, I can go back to my coffee. It's getting cold now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating an email – the Kotlin way – second attempt</h1>
                
            
            <article>
                
<p class="calibre2">Let's try a fluent setter approach, instead. We'll have only mandatory fields in our constructor, and all of the others will become setters. So to create a new email, we no longer need to do the following:</p>
<pre class="calibre18">   val mail = Mail("<a href="mailto:manager@company.com" class="calibre24">manager@company.com</a>") 
   mail.title("Ping") 
   mail.cc(listOf&lt;String&gt;()) </pre>
<p class="calibre2">Instead, we will do the following:</p>
<pre class="calibre18">Mail("<a href="mailto:manager@company.com" class="calibre24">manager@company.com</a>").title("Ping").cc(listOf&lt;String&gt;())</pre>
<p class="calibre2">Fluent setters allow us to chain one set call to another.</p>
<p class="calibre2">That's a lot nicer for a couple of reasons:</p>
<ul class="calibre11">
<li class="calibre12">The order of fields can now be arbitrary, unlike the order used with the constructor.</li>
<li class="calibre12">It's clearer which field is being set; no more need for comments.</li>
<li class="calibre12">Optional fields don't need to be set at all. As an example, the<span> </span><span>CC</span><span> </span>field is set while the<span> </span><span>BCC</span><span> </span>field is omitted.</li>
</ul>
<p class="calibre2">Let's look at one way of implementing this approach. There are other convenient ways to do this, which we'll discuss in<span class="calibre7"> </span><a href="part0236.html#7124O0-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10"><span>Chapter 10</span></a>,<span class="calibre7"> </span><em class="calibre14">Idioms and Anti-Patterns</em>:</p>
<pre class="calibre18">   data class Mail(// Stays the same 
                   private var _message: String = "", 
                   // ...) { 
       fun message(message: String) : Mail { 
           _message = message 
return this } 
       // Pattern repeats for every other variable 
   } </pre>
<p class="calibre2">Using underscores for private variables is a common convention in Kotlin. It allows us to avoid repeating the phrase<span class="calibre7"> </span><kbd class="calibre13">this.message = message</kbd><span class="calibre7"> </span>and mistakes, such as<span class="calibre7"> </span><kbd class="calibre13">message = message</kbd>.</p>
<p class="calibre2">This is nice and is very similar to what we may achieve in Java, although we did have to make our message mutable.</p>
<p class="calibre2">We can also implement a full-blown builder design pattern, of course:</p>
<pre class="calibre18">class MailBuilder(val to: String) { 
    private var mail: Mail = Mail(to) 
    fun title(title: String): MailBuilder { 
        mail.title = title 
        return this 
    }<br class="title-page-name"/>    // Repeated for other properties 
    fun build(): Mail { 
        return mail 
    } 
} </pre>
<p class="calibre2">You can use it to create your email in the following way:</p>
<pre class="calibre18">val email = MailBuilder("<a href="mailto:hello@hello.com" class="calibre24">hello@hello.com</a>").title("What's up?").build()</pre>
<p class="calibre2">But Kotlin provides two other ways that you may find even more useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Prototype</h1>
                
            
            <article>
                
<p class="calibre2">This design pattern is all about customization and creating objects that are similar but slightly different. To understand it better, we'll start with an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building your own PC</h1>
                
            
            <article>
                
<p class="calibre2">Imagine that you have a shop where you sell PCs.</p>
<p class="calibre2">Regular PC consists of the foll:</p>
<ul class="calibre11">
<li class="calibre12">Motherboard</li>
<li class="calibre12">CPU</li>
<li class="calibre12">Graphical card</li>
<li class="calibre12">RAM</li>
</ul>
<p class="calibre2">Most of your customers don't actually care what components you put in this PC. What they do care about is whether this PC will be able to run <em class="calibre14">Magnificent Pilfering Car 7</em> at 60fps (which is frame per second).</p>
<p class="calibre2">So, you decide to build it like that:</p>
<pre class="calibre18">data class PC(val motherboard: String = "Terasus XZ27",<br class="title-page-name"/>             val cpu: String = "Until Atom K500",<br class="title-page-name"/>             val ram: String = "8GB Microcend BBR5",<br class="title-page-name"/>             val graphicCard: String = "nKCF 8100TZ")</pre>
<p class="calibre2">So when a new customer comes in wanting to try out this game everybody is talking about in the neighborhood, you just do:</p>
<pre class="calibre18">val pc = PC()</pre>
<p class="calibre2">And they are already off toward home, ready to share their newest experiences from MPC7. Actually, your business goes so well that you have one PC just sitting there, ready for the next customer to come in.</p>
<p class="calibre2">But then another customer arrives. And this one is tech savvy. So, frankly, they think that for the games they play, a <em class="calibre14">nKCF 8100TZ graphic card</em> wouldn't be enough at all. They've also read that there's now <em class="calibre14">BBR6 RAM</em> available and they want <em class="calibre14">16 GB</em> of it. And of course, they want it right away. But they're willing to pay in cash.</p>
<p class="calibre2">That's the moment you wish that you could just modify this PC that's sitting in your warehouse a little, instead of assembling a new one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Starting from a prototype</h1>
                
            
            <article>
                
<p class="calibre2">The whole idea of a prototype is to be able to clone an object easily. There are a number of reasons you may want to do this:</p>
<ul class="calibre11">
<li class="calibre12">Creating your object is very expensive. You need to fetch it from the database.</li>
<li class="calibre12">You create objects that are similar but different from one another, and you don't want to repeat similar parts over and over again.</li>
</ul>
<div class="packt_infobox"><span class="calibre23">There are also more advanced reasons to use this pattern. JavaScript language, for example, uses prototypes to implement inheritance-like behavior without having classes.</span></div>
<p class="calibre2">Luckily, Kotlin fixes the <em class="calibre14">broken</em> Java <kbd class="calibre13">clone()</kbd> method. For data classes, there's the <kbd class="calibre13">copy()</kbd> method, which takes an existing data class, and creates a new copy of it, optionally changing some of its attributes in the process:</p>
<pre class="calibre18"><span>val </span>pcFromWarehouse = PC() <span>// Our boring PC<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>val </span>pwnerPC = pcFromWarehouse.copy(<span>graphicCard = </span><span>"nKCF 8999ZTXX"</span><span>,<br class="title-page-name"/></span><span>        </span><span>ram = </span><span>"16GB BBR6"</span>) <span>// Amazing PC<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>println</span>(pwnerPC) // Make sure that PC created correctly</pre>
<div class="packt_infobox"><span class="calibre23">By default, the </span><kbd class="calibre20">clone()</kbd><span class="calibre23"> method creates a shallow copy, which may be unexpected for less experienced developers. It's very hard to implement the </span><kbd class="calibre20">clone()</kbd><span class="calibre23"> method correctly in Java. You can read about the various pitfalls at </span><span class="calibre23"><a href="https://dzone.com/articles/shallow-and-deep-java-cloning" class="calibre19">https://dzone.com/articles/shallow-and-deep-java-cloning</a></span><span class="calibre23">.</span></div>
<p class="calibre2">Similar to what we've seen in the Builder design pattern, named arguments allow us to specify attributes that we can change in any order. </p>
<p class="calibre2">The only thing that's left is for you to count the cash and buy some more of those <em class="calibre14">nKCF graphic cards</em>. Just in case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we learned w<span class="calibre7">hen and how to use design patterns from the Creational family. We learned about d</span><span class="calibre7">ifferent usages of the</span> <kbd class="calibre13">object</kbd> <span class="calibre7">keyword: as Singleton, as a container for the S</span>tatic<span class="calibre7"> Factory Methods, and as an anonymous implementation of an interface. We then saw the workings of</span> the destructuring declaration and <span class="calibre7">generics in Kotlin with the use of the</span> <kbd class="calibre13">in</kbd><span class="calibre7">,</span> <kbd class="calibre13">out</kbd>, <span class="calibre7">and</span> <kbd class="calibre13">where</kbd> <span class="calibre7">keywords. We also learned about the d</span>efault parameter values <span class="calibre7">and</span> named arguments, followed by the <kbd class="calibre13">copy()</kbd> <span class="calibre7">function</span> <span class="calibre7">for</span> data classes.</p>
<p class="calibre2"><span class="calibre7">In the next chapter, we'll cover the second family of design patterns, Structural patterns. Those patterns help extend the functionality of our objects.</span></p>


            </article>

            
        </section>
    </body></html>