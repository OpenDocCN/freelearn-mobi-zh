- en: Chapter 4. Adding Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。添加控件
- en: 'Players control mobile games through a very limited number of interactions.
    Often, games feature only a single mechanic: tap anywhere on the screen to jump
    or fly. Contrast that to a console controller with dozens of button combinations.
    With so few actions, keeping users engaged with polished, fun controls is vital
    to the success of your game.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家通过非常有限的操作来控制移动游戏。通常，游戏只包含一个机制：在屏幕上任何地方轻触以跳跃或飞行。与此相对的是拥有数十种按钮组合的家用游戏机控制器。在如此少的动作下，保持用户通过光滑、有趣的控件保持兴趣对于游戏的成功至关重要。
- en: 'In this chapter, you will learn to implement several popular control schemes
    that have emerged from the App Store. First, we will experiment with tilt controls;
    the physical orientation of the device will determine where the player flies.
    Then, we will wire up the `onTap` events on our sprite nodes. Finally, we will
    implement and polish a simple control scheme for flying in our game: tap anywhere
    on the screen to fly higher. You can combine these techniques to create unique
    and enjoyable controls in your future games.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习实现从应用商店中出现的几种流行控制方案。首先，我们将尝试倾斜控制；设备的物理方向将决定玩家的飞行方向。然后，我们将连接我们的精灵节点上的
    `onTap` 事件。最后，我们将实现并完善我们游戏中飞行的简单控制方案：在屏幕上任何地方轻触以飞得更高。你可以结合这些技术，在你的未来游戏中创建独特且有趣的控件。
- en: 'The topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Retrofitting the `Player` class for flight
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `Player` 类进行飞行改造
- en: Polling for device movement with Core Motion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Core Motion 轮询设备移动
- en: Wiring up the sprite `onTap` events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接精灵 `onTap` 事件
- en: Teaching our penguin to fly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教导我们的企鹅学会飞行
- en: Improving the camera
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进相机
- en: Looping the ground as the player moves forward
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家向前移动时循环地面
- en: Retrofitting the Player class for flight
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为玩家类进行飞行改造
- en: We need to perform a few quick setup tasks before we can react to player input.
    We will remove some of our older testing code and add a physics body to the `Player`
    class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以对玩家输入做出反应之前，我们需要执行一些快速设置任务。我们将移除一些旧的测试代码，并为 `Player` 类添加一个物理体。
- en: The Beekeeper
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蜜蜂饲养者
- en: First, clean up the old bee physics tests from the last chapter. Open `GameScene.swift`,
    find `didMoveToView`, and locate the bottom two lines; one sets a mass for `bee2`,
    the other applies an impulse to `bee2`. Remove these lines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，清理上一章中旧的蜜蜂物理测试。打开 `GameScene.swift`，找到 `didMoveToView`，找到底部两行；一行设置了 `bee2`
    的质量，另一行对 `bee2` 应用了冲量。删除这些行。
- en: Updating the Player class
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新玩家类
- en: We need to give the `Player` class its own `update` function. We want to store
    player-related logic in `Player`, and we need it to run before every frame.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为 `Player` 类提供一个自己的 `update` 函数。我们希望在 `Player` 中存储与玩家相关的逻辑，并且我们需要它在每一帧之前运行。
- en: 'Open `Player.swift` and add the following function inside `Player`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Player.swift` 并在 `Player` 中添加以下函数：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `GameScene.swift`, add this code at the bottom of the `GameScene` class:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 中，在 `GameScene` 类的底部添加以下代码：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Perfect. The `GameScene` class will call the `player class update` function
    on every update.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。`GameScene` 类将在每次更新时调用 `player class update` 函数。
- en: Moving the ground
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动地面
- en: We initially placed the ground higher than necessary to make sure it displayed
    for all screen sizes in the previous chapter. We can now move the ground into
    its final position since the player will soon be moving around, bringing the camera
    wherever they go.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们最初将地面设置得比必要的位置更高，以确保它在所有屏幕尺寸上都能显示。现在，由于玩家将很快开始移动，将相机带到他们想去的地方，我们可以将地面移动到其最终位置。
- en: 'In `GameScene.swift`, locate the line that defines the `groundPosition` constant
    and change the `y` value from `100` to `30`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 中，找到定义 `groundPosition` 常量的行，并将 `y` 值从 `100` 更改为 `30`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Assigning a physics body to the player
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为玩家分配物理体
- en: We will use physics forces to move our player around the screen. To apply these
    forces, we must first add a physics body to the player sprite.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用物理力来移动屏幕上的玩家。要应用这些力，我们必须首先为玩家精灵添加一个物理体。
- en: Creating a physics body shape from a texture
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从纹理创建物理体形状
- en: When gameplay allows, you should use circles to define your physics bodies –
    they are the most efficient shape for the physics simulation and result in the
    highest frame rate. However, the accuracy of Pierre's shape is very important
    to our gameplay and a circle is not a great fit for his shape. Instead, we will
    assign a special type of physics body based on his texture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏玩法允许时，您应该使用圆形来定义您的物理体 - 它是物理模拟中最有效的形状，并产生最高的帧率。然而，皮埃尔形状的准确性对我们游戏玩法非常重要，而圆形并不是他的形状的理想选择。相反，我们将根据他的纹理分配一种特殊的物理体类型。
- en: Apple introduced the ability to define the shape of a physics body with opaque
    texture pixels in Xcode 6\. This is a convenient addition as it allows us to easily
    create extremely accurate shapes for our sprites. There is a performance penalty;
    it is computationally expensive to use these texture-driven physics bodies. You
    will want to use them sparingly, only on your most important sprites.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在Xcode 6中引入了使用不透明纹理像素定义物理体形状的能力。这是一个方便的补充，因为它允许我们轻松创建极其精确的精灵形状。使用这些由纹理驱动的物理体会有性能损失；使用这些纹理驱动的物理体计算成本很高。您应该谨慎使用，仅在对您最重要的精灵上使用。
- en: 'To create Pierre''s physics body, add this code in `Player.swift`, at the bottom
    of the `spawn` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建皮埃尔的物理体，在`Player.swift`的`spawn`函数底部添加以下代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the project and the ground will appear to rise up to Pierre. Since we have
    given him a physics body, he is now subject to gravity. Pierre is actually dropping
    down the grid, and the camera is adjusting to keep him centered. This is fine
    for now; later we will give him the tools to fly into the sky. Next, let's learn
    how to move a character, based on the tilt of the physical device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目后，地面看起来会上升至皮埃尔处。因为我们已经给他一个物理体，所以他现在受到重力的作用。皮埃尔实际上正在下降网格，而摄像头正在调整以保持他居中。现在这很好；稍后我们将给他飞向天空的工具。接下来，让我们学习如何根据物理设备的倾斜移动一个角色。
- en: Polling for device movement with Core Motion
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用核心运动轮询设备移动
- en: Apple provides the **Core Motion** framework to expose precise information on
    the iOS device's orientation in physical space. We can use this data to move our
    player on the screen when the user tilts their device in the direction they want
    to move. This unique style of input offers new game-play mechanics in mobile games.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果提供了**核心运动**框架，以暴露iOS设备在物理空间中的精确方向信息。我们可以使用这些数据，当用户将设备倾斜到他们想要移动的方向时，在屏幕上移动我们的玩家。这种独特的输入风格为移动游戏提供了新的游戏玩法机制。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need a physical iOS device for this Core Motion section. The iOS simulator
    in Xcode does not simulate device movement. However, this section is only a learning
    exercise and is not required to finish the game we are building. Our final game
    will not use Core Motion. Feel free to skip the Core Motion section if you cannot
    test with a physical device.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一台物理iOS设备来完成这个核心运动部分。Xcode中的iOS模拟器无法模拟设备移动。然而，这部分只是一个学习练习，并不是完成我们正在构建的游戏所必需的。我们的最终游戏将不会使用核心运动。如果您无法使用物理设备进行测试，请随意跳过核心运动部分。
- en: Implementing the Core Motion code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现核心运动代码
- en: 'It is very easy to poll for device orientation. We will check the device position
    during every update and apply the appropriate force to our player. Follow these
    steps to implement the Core Motion controls:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 检测设备方向非常简单。我们将在每次更新时检查设备位置，并给我们的玩家应用适当的力。按照以下步骤实现核心运动控制：
- en: 'In `GameScene.swift`, near the very top, add a new `import` statement below
    the `import SpriteKit` line:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene.swift`中，靠近顶部，在`import SpriteKit`行下方添加一个新的`import`语句：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the `GameScene` class, add a new constant named `motionManager` and
    instantiate an instance of `CMMotionManager`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene`类中，添加一个名为`motionManager`的新常量，并实例化一个`CMMotionManager`对象：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the `GameScene` function `didMoveToView`, add the following code at
    the bottom. This lets Core Motion know that we want to poll the orientation data,
    so it needs to start reporting data:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene`函数`didMoveToView`中，在底部添加以下代码。这会让核心运动知道我们想要轮询方向数据，因此它需要开始报告数据：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, add the following code to the bottom of the `update` function to poll
    the orientation, build an appropriate vector, and apply a physical force to the
    player''s character:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`update`函数的底部添加以下代码以轮询方向，构建适当的向量，并给玩家的角色应用物理力：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the project. You can slide Pierre across the ice by tilting your device
    in the direction you want to move. Great work – we have successfully implemented
    our first control system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你可以通过倾斜你的设备到你想要移动的方向来滑动 Pierre 横越冰面。干得好——我们成功实现了我们的第一个控制系统。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that Pierre falls through the ground when you move him too far in any
    direction. Later in the chapter, we will improve the ground, continuously repositioning
    it to cover the area beneath the player.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你将 Pierre 向任何方向移动得太远时，他会穿过地面。在本章的后面部分，我们将改进地面，使其不断重新定位以覆盖玩家下方的区域。
- en: This is a simple example of using Core Motion data for player movement; we are
    not going to use this method in our final game. Still, you can extrapolate this
    example into advanced control schemes in your own games.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 Core Motion 数据进行玩家移动的简单示例；我们不会在我们的最终游戏中使用这种方法。尽管如此，你仍然可以将这个示例扩展到你自己游戏中的高级控制方案。
- en: Checkpoint 4-A
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 4-A
- en: 'To download my project, including the Core Motion code, visit this address:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载我的项目，包括 Core Motion 代码，请访问此地址：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-4](http://www.thinkingswiftly.com/game-development-with-swift/chapter-4)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-4](http://www.thinkingswiftly.com/game-development-with-swift/chapter-4)'
- en: Wiring up the sprite onTap events
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接精灵的 onTap 事件
- en: Your games will often require the ability to run code when the player taps a
    specific sprite. I like to implement a system that includes all the sprites in
    your game so you can add tap events to each sprite without building an additional
    structure. We have already implemented `onTap` methods in all of our classes that
    adopt the `GameSprite` protocol; we still need to wire up the scene to call these
    methods when the player taps the sprites.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏通常会需要当玩家点击特定精灵时运行代码的能力。我喜欢实现一个包含你游戏中所有精灵的系统，这样你就可以为每个精灵添加点击事件，而无需构建额外的结构。我们已经在所有采用
    `GameSprite` 协议的类中实现了 `onTap` 方法；我们还需要将场景连接起来，以便在玩家点击精灵时调用这些方法。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we move on, we need to remove the Core Motion code since we will not
    be using it in the finished game. Once you finish exploring the Core Motion example,
    please remove it from the game by following the previous section's bullet points
    in reverse.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要移除 Core Motion 代码，因为我们不会在最终游戏中使用它。一旦你完成对 Core Motion 示例的探索，请按照上一节中的项目符号反向操作将其从游戏中移除。
- en: Implementing touchesBegan in the GameScene
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GameScene 中实现 touchesBegan
- en: 'SpriteKit calls our scene''s `touchesBegan` function every time the screen
    is touched. We will read the location of the touch and determine the sprite node
    in that position. We can check if the touched node adopts our `GameSprite` protocol.
    If it does, this means it must have an `onTap` function, which we can then invoke.
    Add the `touchesBegan` function below to the `GameScene` class – I like to place
    it just below the `didSimulatePhysics` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 每次屏幕被触摸时都会调用我们场景的 `touchesBegan` 函数。我们将读取触摸的位置并确定该位置的精灵节点。我们可以检查被触摸的节点是否采用我们的
    `GameSprite` 协议。如果是，这意味着它必须有一个 `onTap` 函数，然后我们可以调用它。将以下 `touchesBegan` 函数添加到 `GameScene`
    类中——我喜欢将其放置在 `didSimulatePhysics` 函数下方：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That is all we need to do to wire up all of the `onTap` functions we have implemented
    on the game object classes we have made. Of course, all of these `onTap` functions
    are empty at the moment; we will now add some functionality to illustrate the
    effect.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们连接我们在制作的游戏对象类上实现的全部 `onTap` 函数所需做的。当然，所有这些 `onTap` 函数目前都是空的；我们现在将添加一些功能来展示效果。
- en: Larger than life
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超乎生活
- en: 'Open your `Bee.swift` file and locate the `onTap` function. Temporarily, we
    will expand the bees to a giant size when tapped, to demonstrate that we have
    wired our `onTap` functions correctly. Add this code inside the bee''s `onTap`
    function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 `Bee.swift` 文件并定位到 `onTap` 函数。暂时地，当点击时我们将蜜蜂扩展到巨大的尺寸，以演示我们已经正确地连接了 `onTap`
    函数。在蜜蜂的 `onTap` 函数内添加以下代码：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the project and tap on the bees. They will expand to four times their original
    size, as shown in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并点击蜜蜂。它们将扩展到原来的四倍大小，如下面的截图所示：
- en: '![Larger than life](img/Image_B04532_04_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![超乎生活](img/Image_B04532_04_01.jpg)'
- en: Oh no – giant bees! This example shows that our `onTap` functions work. You
    can remove the scaling code you added to the `Bee` class. We will keep the `onTap`
    wire-up code in `GameScene` so that we can use tap events later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不——巨大的蜜蜂！这个例子表明我们的 `onTap` 函数是工作的。你可以从 `Bee` 类中移除你添加的缩放代码。我们将保留 `GameScene`
    中的 `onTap` 连接代码，这样我们就可以稍后使用点击事件。
- en: Teaching our penguin to fly
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教我们的企鹅飞翔
- en: 'Let''s implement the control scheme for our penguin. The player can tap anywhere
    on the screen to make Pierre fly higher and release to let him fall. We are going
    to make quite a few changes – if you need help, refer to the checkpoint at the
    end of this chapter. Start by modifying the `Player` class; follow these steps
    to prepare our `Player` for flight:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现企鹅的控制方案。玩家可以点击屏幕上的任何位置使皮埃尔飞得更高，松开手指让他落下。我们将进行相当多的更改——如果你需要帮助，请参考本章末尾的检查点。首先修改`Player`类；按照以下步骤为我们的`Player`准备飞行：
- en: 'In `Player.swift`, add some new properties directly to the `Player` class:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player.swift`中，直接向`Player`类添加一些新属性：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So far, Pierre has been flapping his wings by default. Instead, we want to
    display the soaring animation by default and only run the flap animation when
    the user presses the screen. In the `spawn` function, remove the line that runs
    `flyAnimation` and, instead, run `soarAnimation`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，皮埃尔默认一直在拍打翅膀。相反，我们想默认显示翱翔动画，只有在用户按下屏幕时才运行拍打动画。在`spawn`函数中，删除运行`flyAnimation`的行，而是运行`soarAnimation`：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the player touches the screen, we apply the upward force in the `Player`
    class `update` function. Remember that `GameScene` calls this `update` function
    once per frame. Add this code in `update`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家触摸屏幕时，我们在`Player`类的`update`函数中应用向上的力。记住`GameScene`每帧调用一次这个`update`函数。在`update`中添加以下代码：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we will provide two functions on `Player` to allow other classes to
    start and stop the flapping behavior. The `GameScene` class will call these functions
    when it detects touch input. Add the following functions to the `Player` class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在`Player`类中提供两个函数，以便其他类可以开始和停止拍打行为。当`GameScene`类检测到触摸输入时，将调用这些函数。将以下函数添加到`Player`类中：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Perfect, our `Player` is ready for flight. Now we will simply invoke the start
    and stop functions from the `GameScene` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，我们的`Player`已经准备好飞翔了。现在我们将简单地从`GameScene`类中调用开始和停止函数。
- en: Listening for touches in GameScene
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`GameScene`中监听触摸
- en: 'The `SKScene` class (that `GameScene` inherits from) includes handy functions
    we can use to monitor touch input. Follow these steps to wire up the `GameScene`
    class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKScene`类（`GameScene`从中继承）包含了一些方便的函数，我们可以使用这些函数来监控触摸输入。按照以下步骤连接`GameScene`类：'
- en: 'In `GameScene.swift`, in the `touchesBegan` function, add this code at the
    bottom to start the `Player` flapping when the user touches the screen:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene.swift`的`touchesBegan`函数中，在底部添加以下代码以在用户触摸屏幕时开始`Player`拍打：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Below `touchesBegan`, create two new functions in the `GameScene` class. These
    functions stop the flapping when the user lifts his or her finger from the screen,
    or when an iOS notification interrupts the touch:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`touchesBegan`下方，在`GameScene`类中创建两个新函数。这些函数在用户从屏幕上抬起手指或iOS通知中断触摸时停止拍打：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Fine-tuning gravity
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微调重力
- en: 'Before we test out our new flying code, we need to make one adjustment. The
    default gravity setting of -9.8 feels too real. Pierre lives in a cartoon world;
    real-world gravity is a bit of a drag. We can adjust gravity in the `GameScene`
    class; add this line at the bottom of the `didMoveToView` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们新的飞行代码之前，我们需要进行一项调整。默认的重力设置为-9.8感觉太真实了。皮埃尔生活在卡通世界里；现实世界的重力有点拖沓。我们可以在`GameScene`类中调整重力；在`didMoveToView`函数的底部添加以下行：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Spreading your wings
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展开翅膀
- en: 'Run the project. Tap the screen to make Pierre fly higher, release to let him
    fall. Play with the action; Pierre rotates towards his vector and builds or loses
    momentum as you tap and release. Terrific! You have successfully implemented the
    core mechanic of our game. Take a minute to enjoy flying up and down, as in this
    screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。点击屏幕使皮埃尔飞得更高，松开手指让他落下。玩这个动作；皮埃尔旋转向他的矢量，并在你点击和松开时积累或失去动力。太棒了！你已经成功实现了我们游戏的核心机制。花一分钟时间享受上下飞翔的感觉，就像这个截图所示：
- en: '![Spreading your wings](img/Image_B04532_04_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![展开翅膀](img/Image_B04532_04_02.jpg)'
- en: Improving the camera
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进相机
- en: 'Our camera code works well; it follows the player wherever they fly. However,
    we can improve the camera to enhance the flying experience. In this section, we
    will add two new features:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相机的代码运行良好；它跟随玩家飞行的任何地方。然而，我们可以改进相机以增强飞行体验。在本节中，我们将添加两个新功能：
- en: Zoom the camera out as Pierre Penguin flies higher, reinforcing the feeling
    of increasing height.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当皮埃尔企鹅飞得更高时，放大相机，增强增加高度的感觉。
- en: Suspend vertical centering when the player drops below the halfway point of
    the screen. This means the ground never fills too much of the screen, and adds
    the feeling of cutting upwards into the air when Pierre flies higher and the camera
    starts tracking him again.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家下降到屏幕下半部分时，暂停垂直居中。这意味着地面永远不会占据屏幕太多，当皮埃尔飞得更高，相机开始再次跟踪他时，增加了向上切割空气的感觉。
- en: 'Follow these steps to implement these two improvements:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现这两个改进：
- en: 'In `GameScene.swift`, create a new variable in the `GameScene` class to store
    the center point of the screen:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 中，在 `GameScene` 类中创建一个新变量以存储屏幕的中心点：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `didMoveToView` function, set this new variable with the calculated
    center of the screen''s height:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `didMoveToView` 函数中，使用计算出的屏幕高度的中间值设置这个新变量：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to rework the `didSimulatePhysics` function significantly. Remove the
    existing `didSimulatePhysics` function and replace it with this code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要显著重构 `didSimulatePhysics` 函数。删除现有的 `didSimulatePhysics` 函数，并用以下代码替换它：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the project, and then fly up. The world scales smaller as you gain height.
    The camera also now allows Pierre to dive below the center of the screen when
    you fly close to the ground. The following screenshot illustrates the two extremes.
    Notice the smaller sprites in the top screen, Pierre flies higher and the camera
    zooms out. In the bottom shot, the camera stops following Pierre vertically as
    he approaches the ground:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，然后飞起。随着高度的增加，世界会缩小。当飞近地面时，相机现在也允许皮埃尔潜入屏幕中心以下。以下截图说明了两种极端情况。注意顶部屏幕中的小精灵，皮埃尔飞得更高，相机也拉远。在底部画面中，当皮埃尔接近地面时，相机停止垂直跟随：
- en: '![Improving the camera](img/Image_B04532_04_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![改进相机](img/Image_B04532_04_03.jpg)'
- en: The combined effect adds a lot of polish to the game and increases the fun of
    flying. Our flying mechanic feels great. The next step is to move Pierre forward
    through the world.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种综合效果为游戏增添了大量光泽，并增加了飞行的乐趣。我们的飞行机制感觉很好。下一步是将皮埃尔推进世界。
- en: Pushing Pierre forward
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推进皮埃尔前进
- en: 'This style of game usually moves the world forward at a constant speed. Rather
    than applying force or impulse, we can manually set a constant velocity for Pierre
    during every `update`. Open the `Player.swift` file and add this code in the `update`
    function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种游戏风格通常以恒定速度推进世界。而不是应用力或冲量，我们可以在每次 `update` 中手动为皮埃尔设置一个恒定速度。打开 `Player.swift`
    文件，并在 `update` 函数中添加以下代码：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the project. Our protagonist penguin will move forward past the swarm of
    bees and through the world. This works well, but you will quickly notice that
    the ground runs out as Pierre moves forward, as shown in this screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。我们的主角企鹅会穿过蜜蜂群和世界向前移动。这很好，但你很快会发现，随着皮埃尔向前移动，地面会消失，如这个截图所示：
- en: '![Pushing Pierre forward](img/Image_B04532_04_04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![推进皮埃尔前进](img/Image_B04532_04_04.jpg)'
- en: Recall that our ground is only as wide as the screen width multiplied by three.
    Rather than extending the ground further, we will move the ground's position at
    well-timed intervals. Since the ground is made from repeating tiles, there are
    many opportunities to jump its position forward seamlessly. We simply need to
    figure out when the player travels the correct distance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的地面宽度只有屏幕宽度的三倍。而不是扩展地面，我们将在适时的间隔移动地面的位置。由于地面由重复的瓷砖组成，有许多机会可以无缝地跳过其位置向前移动。我们只需要找出玩家移动了正确的距离。
- en: Tracking the player's progress
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪玩家的进度
- en: 'First, we need to keep track of how far the player has flown. We will use this
    later as well, for keeping track of a high score. This is easy to implement. Follow
    these steps to track how far the player has flown:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要跟踪玩家飞行的距离。我们稍后会用到这个数据，用于记录高分。这很容易实现。按照以下步骤跟踪玩家飞行的距离：
- en: 'In the `GameScene.swift` file, add two new properties to the `GameScene` class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 文件中，向 `GameScene` 类添加两个新属性：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `didMoveToView` function, update the line that spawns the player to
    use the new `initialPlayerPosition` constant instead of the old hard-coded value:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `didMoveToView` 函数中，更新生成玩家的行，使用新的 `initialPlayerPosition` 常量而不是旧的硬编码值：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `didSimulatePhysics` function, update the new `playerProgress` property
    with the player''s new distance:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `didSimulatePhysics` 函数中，更新新的 `playerProgress` 属性以包含玩家的新距离：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Perfect – we now have access to the player's progress at all times in the `GameScene`
    class. We can use the distance traveled to reposition the ground at the correct
    time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完美 – 现在我们可以在 `GameScene` 类中随时访问玩家的进度。我们可以使用行进距离在正确的时间重新定位地面。
- en: Looping the ground
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地面循环
- en: There are many possible methods to create an endless ground loop. We will implement
    a straightforward solution that jumps the ground forward after the player travels
    over roughly one-third of its width. This method guarantees that the ground always
    covers the screen, given that our player starts in the middle third.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可能的方法来创建无限地面循环。我们将实现一个简单的解决方案，在玩家行进到大约三分之一的宽度后，将地面向前跳跃。这种方法保证了如果我们的玩家从中间三分之一开始，地面总是覆盖屏幕。
- en: 'We will create the jump logic on the `Ground` class. Follow these steps to
    implement endless ground:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `Ground` 类上创建跳跃逻辑。按照以下步骤实现无限地面：
- en: 'Open the `Ground.swift` file, and add two new properties to the `Ground` class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Ground.swift` 文件，并为 `Ground` 类添加两个新属性：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `createChildren` function, we find the total width from one-third of
    the children tiles and make it our `jumpWidth`. We will need to jump the ground
    forward every time the player travels this distance. You only need to add one
    line: near the bottom of the function, but inside the conditional that unwraps
    the texture. I will show the entire function in the following example, for context,
    with the new line in bold:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `createChildren` 函数中，我们找到从三分之一的孩子瓦片的总宽度，并将其作为我们的 `jumpWidth`。每次玩家行进这段距离时，我们都需要将地面向前跳跃。你只需要在函数底部附近添加一行：在展开纹理的条件下。以下示例中，我将展示整个函数，以提供上下文，新行将以粗体显示：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a new function named `checkForReposition` to the `Ground` class, below
    the `createChildren` function. The scene will call this function at every frame
    to check if we should jump the ground forward:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Ground` 类中添加一个名为 `checkForReposition` 的新函数，位于 `createChildren` 函数下方。场景将在每一帧调用此函数以检查我们是否应该将地面向前跳跃：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open `GameScene.swift` and add this line at the bottom of the `didSimulatePhysics`
    function to call the `Ground` class''s new logic:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GameScene.swift` 文件，并在 `didSimulatePhysics` 函数的底部添加以下行以调用 `Ground` 类的新逻辑：
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the project. The ground will seem to stretch on forever as Pierre flies
    forward. This looping ground is a big step towards the final game world. It may
    seem like a lot of work for a simple effect, but the looping ground is important,
    and our method will perform well on any screen size. Great work!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。当皮埃尔向前飞行时，地面看起来会无限延伸。这种循环地面是最终游戏世界的一大步。这可能看起来是为一个简单的效果而做的大量工作，但循环地面很重要，我们的方法将在任何屏幕尺寸上表现良好。干得好！
- en: Checkpoint 4-B
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 4-B
- en: 'To download my project up to this point, visit this address:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载到这一点的项目，请访问此地址：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-4](http://www.thinkingswiftly.com/game-development-with-swift/chapter-4)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-4](http://www.thinkingswiftly.com/game-development-with-swift/chapter-4)'
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have transformed a tech demo into the beginnings of a real
    game. We have added a great deal of new code. You learned how to implement three
    distinct mobile game control methods: physical device motion, sprite tap events,
    and flying higher when the screen is touched. We polished the flying mechanic
    for maximum fun and sent Pierre flying forward through the world.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将技术演示转变为真实游戏的开始。我们添加了大量新的代码。你学习了如何实现三种不同的移动游戏控制方法：物理设备运动、精灵点击事件以及当屏幕被触摸时飞得更高。我们为飞行机制进行了优化，让皮埃尔飞向世界的前方。
- en: 'You also learned how to implement two common mobile game requirements: looping
    the ground and a smarter camera system. Both of these features make a big impact
    in our game.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何实现两个常见的移动游戏需求：地面循环和更智能的摄像头系统。这两个功能对我们的游戏产生了重大影响。
- en: Next, we will add more content to our level. Flying is already fun, but traveling
    past the first few bees feels a little lonely. We will give Pierre Penguin some
    company in [Chapter 5](ch05.html "Chapter 5. Spawning Enemies, Coins, and Power-ups"),
    *Spawning Enemies, Coins, and Power-ups*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们关卡添加更多内容。飞行已经很有趣了，但穿过前几个蜜蜂时感觉有点孤单。我们将在 [第 5 章](ch05.html "第 5 章。生成敌人、金币和道具")
    *生成敌人、金币和道具* 中给皮埃尔企鹅一些同伴。
