- en: Chapter 4. Adding Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Players control mobile games through a very limited number of interactions.
    Often, games feature only a single mechanic: tap anywhere on the screen to jump
    or fly. Contrast that to a console controller with dozens of button combinations.
    With so few actions, keeping users engaged with polished, fun controls is vital
    to the success of your game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to implement several popular control schemes
    that have emerged from the App Store. First, we will experiment with tilt controls;
    the physical orientation of the device will determine where the player flies.
    Then, we will wire up the `onTap` events on our sprite nodes. Finally, we will
    implement and polish a simple control scheme for flying in our game: tap anywhere
    on the screen to fly higher. You can combine these techniques to create unique
    and enjoyable controls in your future games.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrofitting the `Player` class for flight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling for device movement with Core Motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring up the sprite `onTap` events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teaching our penguin to fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping the ground as the player moves forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrofitting the Player class for flight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to perform a few quick setup tasks before we can react to player input.
    We will remove some of our older testing code and add a physics body to the `Player`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The Beekeeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, clean up the old bee physics tests from the last chapter. Open `GameScene.swift`,
    find `didMoveToView`, and locate the bottom two lines; one sets a mass for `bee2`,
    the other applies an impulse to `bee2`. Remove these lines.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Player class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to give the `Player` class its own `update` function. We want to store
    player-related logic in `Player`, and we need it to run before every frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Player.swift` and add the following function inside `Player`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `GameScene.swift`, add this code at the bottom of the `GameScene` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Perfect. The `GameScene` class will call the `player class update` function
    on every update.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the ground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We initially placed the ground higher than necessary to make sure it displayed
    for all screen sizes in the previous chapter. We can now move the ground into
    its final position since the player will soon be moving around, bringing the camera
    wherever they go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GameScene.swift`, locate the line that defines the `groundPosition` constant
    and change the `y` value from `100` to `30`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Assigning a physics body to the player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use physics forces to move our player around the screen. To apply these
    forces, we must first add a physics body to the player sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a physics body shape from a texture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When gameplay allows, you should use circles to define your physics bodies –
    they are the most efficient shape for the physics simulation and result in the
    highest frame rate. However, the accuracy of Pierre's shape is very important
    to our gameplay and a circle is not a great fit for his shape. Instead, we will
    assign a special type of physics body based on his texture.
  prefs: []
  type: TYPE_NORMAL
- en: Apple introduced the ability to define the shape of a physics body with opaque
    texture pixels in Xcode 6\. This is a convenient addition as it allows us to easily
    create extremely accurate shapes for our sprites. There is a performance penalty;
    it is computationally expensive to use these texture-driven physics bodies. You
    will want to use them sparingly, only on your most important sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create Pierre''s physics body, add this code in `Player.swift`, at the bottom
    of the `spawn` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run the project and the ground will appear to rise up to Pierre. Since we have
    given him a physics body, he is now subject to gravity. Pierre is actually dropping
    down the grid, and the camera is adjusting to keep him centered. This is fine
    for now; later we will give him the tools to fly into the sky. Next, let's learn
    how to move a character, based on the tilt of the physical device.
  prefs: []
  type: TYPE_NORMAL
- en: Polling for device movement with Core Motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple provides the **Core Motion** framework to expose precise information on
    the iOS device's orientation in physical space. We can use this data to move our
    player on the screen when the user tilts their device in the direction they want
    to move. This unique style of input offers new game-play mechanics in mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need a physical iOS device for this Core Motion section. The iOS simulator
    in Xcode does not simulate device movement. However, this section is only a learning
    exercise and is not required to finish the game we are building. Our final game
    will not use Core Motion. Feel free to skip the Core Motion section if you cannot
    test with a physical device.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Core Motion code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very easy to poll for device orientation. We will check the device position
    during every update and apply the appropriate force to our player. Follow these
    steps to implement the Core Motion controls:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GameScene.swift`, near the very top, add a new `import` statement below
    the `import SpriteKit` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `GameScene` class, add a new constant named `motionManager` and
    instantiate an instance of `CMMotionManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `GameScene` function `didMoveToView`, add the following code at
    the bottom. This lets Core Motion know that we want to poll the orientation data,
    so it needs to start reporting data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following code to the bottom of the `update` function to poll
    the orientation, build an appropriate vector, and apply a physical force to the
    player''s character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project. You can slide Pierre across the ice by tilting your device
    in the direction you want to move. Great work – we have successfully implemented
    our first control system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that Pierre falls through the ground when you move him too far in any
    direction. Later in the chapter, we will improve the ground, continuously repositioning
    it to cover the area beneath the player.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example of using Core Motion data for player movement; we are
    not going to use this method in our final game. Still, you can extrapolate this
    example into advanced control schemes in your own games.
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoint 4-A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To download my project, including the Core Motion code, visit this address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-4](http://www.thinkingswiftly.com/game-development-with-swift/chapter-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the sprite onTap events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your games will often require the ability to run code when the player taps a
    specific sprite. I like to implement a system that includes all the sprites in
    your game so you can add tap events to each sprite without building an additional
    structure. We have already implemented `onTap` methods in all of our classes that
    adopt the `GameSprite` protocol; we still need to wire up the scene to call these
    methods when the player taps the sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we move on, we need to remove the Core Motion code since we will not
    be using it in the finished game. Once you finish exploring the Core Motion example,
    please remove it from the game by following the previous section's bullet points
    in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing touchesBegan in the GameScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SpriteKit calls our scene''s `touchesBegan` function every time the screen
    is touched. We will read the location of the touch and determine the sprite node
    in that position. We can check if the touched node adopts our `GameSprite` protocol.
    If it does, this means it must have an `onTap` function, which we can then invoke.
    Add the `touchesBegan` function below to the `GameScene` class – I like to place
    it just below the `didSimulatePhysics` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That is all we need to do to wire up all of the `onTap` functions we have implemented
    on the game object classes we have made. Of course, all of these `onTap` functions
    are empty at the moment; we will now add some functionality to illustrate the
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Larger than life
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your `Bee.swift` file and locate the `onTap` function. Temporarily, we
    will expand the bees to a giant size when tapped, to demonstrate that we have
    wired our `onTap` functions correctly. Add this code inside the bee''s `onTap`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project and tap on the bees. They will expand to four times their original
    size, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Larger than life](img/Image_B04532_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oh no – giant bees! This example shows that our `onTap` functions work. You
    can remove the scaling code you added to the `Bee` class. We will keep the `onTap`
    wire-up code in `GameScene` so that we can use tap events later.
  prefs: []
  type: TYPE_NORMAL
- en: Teaching our penguin to fly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement the control scheme for our penguin. The player can tap anywhere
    on the screen to make Pierre fly higher and release to let him fall. We are going
    to make quite a few changes – if you need help, refer to the checkpoint at the
    end of this chapter. Start by modifying the `Player` class; follow these steps
    to prepare our `Player` for flight:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Player.swift`, add some new properties directly to the `Player` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, Pierre has been flapping his wings by default. Instead, we want to
    display the soaring animation by default and only run the flap animation when
    the user presses the screen. In the `spawn` function, remove the line that runs
    `flyAnimation` and, instead, run `soarAnimation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the player touches the screen, we apply the upward force in the `Player`
    class `update` function. Remember that `GameScene` calls this `update` function
    once per frame. Add this code in `update`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will provide two functions on `Player` to allow other classes to
    start and stop the flapping behavior. The `GameScene` class will call these functions
    when it detects touch input. Add the following functions to the `Player` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Perfect, our `Player` is ready for flight. Now we will simply invoke the start
    and stop functions from the `GameScene` class.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for touches in GameScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SKScene` class (that `GameScene` inherits from) includes handy functions
    we can use to monitor touch input. Follow these steps to wire up the `GameScene`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GameScene.swift`, in the `touchesBegan` function, add this code at the
    bottom to start the `Player` flapping when the user touches the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below `touchesBegan`, create two new functions in the `GameScene` class. These
    functions stop the flapping when the user lifts his or her finger from the screen,
    or when an iOS notification interrupts the touch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fine-tuning gravity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we test out our new flying code, we need to make one adjustment. The
    default gravity setting of -9.8 feels too real. Pierre lives in a cartoon world;
    real-world gravity is a bit of a drag. We can adjust gravity in the `GameScene`
    class; add this line at the bottom of the `didMoveToView` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Spreading your wings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the project. Tap the screen to make Pierre fly higher, release to let him
    fall. Play with the action; Pierre rotates towards his vector and builds or loses
    momentum as you tap and release. Terrific! You have successfully implemented the
    core mechanic of our game. Take a minute to enjoy flying up and down, as in this
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spreading your wings](img/Image_B04532_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Improving the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our camera code works well; it follows the player wherever they fly. However,
    we can improve the camera to enhance the flying experience. In this section, we
    will add two new features:'
  prefs: []
  type: TYPE_NORMAL
- en: Zoom the camera out as Pierre Penguin flies higher, reinforcing the feeling
    of increasing height.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suspend vertical centering when the player drops below the halfway point of
    the screen. This means the ground never fills too much of the screen, and adds
    the feeling of cutting upwards into the air when Pierre flies higher and the camera
    starts tracking him again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to implement these two improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GameScene.swift`, create a new variable in the `GameScene` class to store
    the center point of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `didMoveToView` function, set this new variable with the calculated
    center of the screen''s height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to rework the `didSimulatePhysics` function significantly. Remove the
    existing `didSimulatePhysics` function and replace it with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the project, and then fly up. The world scales smaller as you gain height.
    The camera also now allows Pierre to dive below the center of the screen when
    you fly close to the ground. The following screenshot illustrates the two extremes.
    Notice the smaller sprites in the top screen, Pierre flies higher and the camera
    zooms out. In the bottom shot, the camera stops following Pierre vertically as
    he approaches the ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Improving the camera](img/Image_B04532_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The combined effect adds a lot of polish to the game and increases the fun of
    flying. Our flying mechanic feels great. The next step is to move Pierre forward
    through the world.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing Pierre forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This style of game usually moves the world forward at a constant speed. Rather
    than applying force or impulse, we can manually set a constant velocity for Pierre
    during every `update`. Open the `Player.swift` file and add this code in the `update`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project. Our protagonist penguin will move forward past the swarm of
    bees and through the world. This works well, but you will quickly notice that
    the ground runs out as Pierre moves forward, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pushing Pierre forward](img/Image_B04532_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Recall that our ground is only as wide as the screen width multiplied by three.
    Rather than extending the ground further, we will move the ground's position at
    well-timed intervals. Since the ground is made from repeating tiles, there are
    many opportunities to jump its position forward seamlessly. We simply need to
    figure out when the player travels the correct distance.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the player's progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to keep track of how far the player has flown. We will use this
    later as well, for keeping track of a high score. This is easy to implement. Follow
    these steps to track how far the player has flown:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `GameScene.swift` file, add two new properties to the `GameScene` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `didMoveToView` function, update the line that spawns the player to
    use the new `initialPlayerPosition` constant instead of the old hard-coded value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `didSimulatePhysics` function, update the new `playerProgress` property
    with the player''s new distance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Perfect – we now have access to the player's progress at all times in the `GameScene`
    class. We can use the distance traveled to reposition the ground at the correct
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Looping the ground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many possible methods to create an endless ground loop. We will implement
    a straightforward solution that jumps the ground forward after the player travels
    over roughly one-third of its width. This method guarantees that the ground always
    covers the screen, given that our player starts in the middle third.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the jump logic on the `Ground` class. Follow these steps to
    implement endless ground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Ground.swift` file, and add two new properties to the `Ground` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `createChildren` function, we find the total width from one-third of
    the children tiles and make it our `jumpWidth`. We will need to jump the ground
    forward every time the player travels this distance. You only need to add one
    line: near the bottom of the function, but inside the conditional that unwraps
    the texture. I will show the entire function in the following example, for context,
    with the new line in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new function named `checkForReposition` to the `Ground` class, below
    the `createChildren` function. The scene will call this function at every frame
    to check if we should jump the ground forward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `GameScene.swift` and add this line at the bottom of the `didSimulatePhysics`
    function to call the `Ground` class''s new logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project. The ground will seem to stretch on forever as Pierre flies
    forward. This looping ground is a big step towards the final game world. It may
    seem like a lot of work for a simple effect, but the looping ground is important,
    and our method will perform well on any screen size. Great work!
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoint 4-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To download my project up to this point, visit this address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-4](http://www.thinkingswiftly.com/game-development-with-swift/chapter-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have transformed a tech demo into the beginnings of a real
    game. We have added a great deal of new code. You learned how to implement three
    distinct mobile game control methods: physical device motion, sprite tap events,
    and flying higher when the screen is touched. We polished the flying mechanic
    for maximum fun and sent Pierre flying forward through the world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You also learned how to implement two common mobile game requirements: looping
    the ground and a smarter camera system. Both of these features make a big impact
    in our game.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add more content to our level. Flying is already fun, but traveling
    past the first few bees feels a little lonely. We will give Pierre Penguin some
    company in [Chapter 5](ch05.html "Chapter 5. Spawning Enemies, Coins, and Power-ups"),
    *Spawning Enemies, Coins, and Power-ups*.
  prefs: []
  type: TYPE_NORMAL
