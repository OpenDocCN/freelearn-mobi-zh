<html><head></head><body>
		<div><h1 id="_idParaDest-101"><em class="italic"><a id="_idTextAnchor249"/>Chapter 7</em>: Introducing Presentation Patterns in Android</h1>
			<p>In this chapter, we're continuing our journey of exploring ways to architect Android applications. More precisely, we will be making sure that our applications split responsibilities correctly with the introduction of presentation patterns.</p>
			<p>In the first section, <em class="italic">Introducing MVC, MVP, and MVVM as presentation patterns</em>, we will provide a short overview on why we need presentation patterns, and we will explore how most common patterns are implemented in Android projects.</p>
			<p>Next up, in the <em class="italic">Refactoring our Restaurants App to fit a presentation pattern</em> section, we will refactor our Restaurants App to fit the MVVM presentation pattern, while also understanding why MVVM is best suited for our Compose-based app.</p>
			<p>In the last section, <em class="italic">Improving state encapsulation in ViewModel</em>, we will see why it's important for the <code>ViewModel</code>, and we will explore how to achieve that. </p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>), <strong class="bold">Model-View-Presenter</strong> (<strong class="bold">MVP</strong>), and <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) as presentation patterns</li>
				<li>Refactoring our Restaurants app to a presentation pattern</li>
				<li>Improving state encapsulation in ViewModel</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor250"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds, but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio.</li>
				<li>The Restaurants app code from the previous chapter.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants app developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <code>Chapter_06</code> directory of the repository and importing the Android project entitled <code>chapter_6_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_07</code> directory at <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_07/chapter_7_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_07/chapter_7_restaurants_app</a>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor251"/>Introducing MVC, MVP, and MVVM as presentation patterns</h1>
			<p>In the beginning, most Android projects were designed as a bunch of <code>Activity</code> or <code>Fragment</code> classes <a id="_idIndexMarker519"/>that were setting content to their <a id="_idIndexMarker520"/>corresponding <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>) layouts.</p>
			<p>As projects grew and new features were requested, developers had to add more logic inside the <code>Activity</code> or <code>Fragment</code> class, development cycle after development cycle. This means that anything from a new feature, improvement, or bug fix for a particular screen would have to be done inside those <code>Activity</code> or <code>Fragment</code> classes.</p>
			<p>After some time, these classes became larger and larger, and at some point, adding an improvement or fixing a bug could become a nightmare. The reason for this would be that the <code>Activity</code> or <code>Fragment</code> classes were burdened with all the responsibilities from within a particular project. These classes would be doing the following:</p>
			<ul>
				<li>Defining the UI</li>
				<li>Preparing the data to be displayed and defining different UI states</li>
				<li>Obtaining data from different sources</li>
				<li>Applying different business rules to data</li>
			</ul>
			<p><em class="italic">This approach introduces coupling between distinct responsibilities and concerns of a project</em>. For such projects, if—for example—a portion of the UI must be changed, your changes could <a id="_idIndexMarker521"/>easily impact other concerns of the app: the way data is presented, the logic of obtaining that data, business rules, and so on.</p>
			<p>The worst part of this happening is that when you need to change only a part (say, part of the UI) and you end up changing other parts (say, the presentation, or data logic) you risk breaking unrelated things that worked, therefore possibly introducing new bugs.</p>
			<p>Having such an approach where all the code of a project is bundled inside the <code>Activity</code> or <code>Fragment</code> class, causes your <a id="_idIndexMarker522"/>project to develop the following issues:</p>
			<ul>
				<li><strong class="bold">Fragile and difficult to scale</strong>: Adding new features or improvements can break other parts of your app.</li>
				<li><strong class="bold">Difficult to test</strong>: Since all the logic of the app is bundled in one place, testing only one part of the logic is very difficult because all your logic is tangled and tied to platform-related dependencies.</li>
				<li><strong class="bold">Difficult to debug</strong>: When responsibilities are intertwined, then parts of your code base are also intertwined and coupled. Debugging one specific issue becomes extremely difficult because it's hard to track the exact culprit.</li>
			</ul>
			<p>To alleviate these issues, we can try to identify the core responsibilities of an app and then separate their corresponding logic and code into distinct components (or classes) that are part of specific layers. This way, we are trying to follow the principle of <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>), whereby <a id="_idIndexMarker523"/>each layer will contain classes whose responsibilities are tightly related only to their corresponding layer's concern.</p>
			<p>To make sure that our projects obey the SoC principle, we can split the app's responsibilities into two major ones and define a layer for each of them, as follows:</p>
			<ul>
				<li>The <strong class="bold">Presentation layer</strong> contains <a id="_idIndexMarker524"/>classes (or other components) responsible for defining the UI and preparing the data to be presented.</li>
				<li>The <strong class="bold">Model layer</strong> contains<a id="_idIndexMarker525"/> classes where the application's data is obtained, modeled, and updated.</li>
			</ul>
			<p>Even though the two layers seem to do more than one thing, all these actions define a broader dedicated responsibility that encapsulates a specific concern.</p>
			<p>In this chapter, while we will be mostly focusing on structuring the Presentation layer, we will also start working on the Model layer. We will continue refactoring the Model layer in <a href="B17788_08_ePub.xhtml#_idTextAnchor285"><em class="italic">Chapter 8</em></a>, <em class="italic">Getting Started with Clean Architecture in Android</em>.</p>
			<p>To separate concerns within the Presentation layer, you can make use of presentation design patterns. <strong class="bold">Presentation design patterns</strong> are <a id="_idIndexMarker526"/>architectural patterns that define how the Presentation layer is structured in our applications.</p>
			<p>The Presentation layer is <a id="_idIndexMarker527"/>a part of our project that is tied to what the user sees: the UI and the presentation of that UI. In other words, the Presentation layer handles two granular, yet related responsibilities associated with two types of logic, as outlined here:</p>
			<ul>
				<li><strong class="bold">UI logic</strong>: Defines <a id="_idIndexMarker528"/>the ability to display content on a device in a specific way for one screen or flow. For example, when building an XML layout or a composable hierarchy for a screen, we're defining the UI logic for that specific screen since we're defining its UI elements.</li>
				<li><strong class="bold">Presentation logic</strong>: The<a id="_idIndexMarker529"/> logic that defines the state of the UI (for one screen or flow) and how it mutates when the user interacts with our UI, therefore defining how the data is being presented to the UI. We're writing presentation logic when, for example, we must do the following:<ul><li>Ensure that the screen is in a loading state or error state at specific times</li><li>Present content for a screen in a specific manner by formatting it to some standards</li></ul></li>
			</ul>
			<p>For the Presentation layer to define UI logic and presentation logic, it needs some data to work with. That's why it must be connected to the Model layer, which provides it with raw data, be it from web services, local databases, or other sources. You can see an illustration of this in the following diagram:</p>
			<div><div><img src="img/B17788_07_1.jpg" alt="Figure 7.1 – Composition of the Presentation layer and its relation to the Model layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Composition of the Presentation layer and its relation to the Model layer</p>
			<p>For now, we will consider the Model layer a black box that just provides us with data.</p>
			<p>We <a id="_idIndexMarker530"/>can say that such separations allow the UI to become a representation of the model's data through transformations that happen inside the Presentation layer while having components whose responsibilities don't overlap.</p>
			<p>In Android, transformations from within the Presentation layer are modeled through three popular presentation patterns that are used in other technology stacks as well, as follows:</p>
			<ul>
				<li>MVC </li>
				<li>MVP </li>
				<li>MVVM <p class="callout-heading">Note</p><p class="callout">As Android developers, we have adjusted the implementation of these presentation patterns to the specific needs of Android. That's why the way we will exemplify or implement them may vary from their original definitions given by their founders—all this is in pursuit of observing their common usages in Android projects.</p></li>
			</ul>
			<p>These presentation patterns <a id="_idIndexMarker531"/>will allow us to separate UI logic from presentation logic for each screen or flow within our app. By doing so, we are ensuring that our Presentation layer has less coupled code that is easier to maintain, easier to scale with new features, and easier to test.</p>
			<p>Historically, most Android projects have transitioned from MVC to MVP and, nowadays, to MVVM. Regardless of their structure, though, it's important to mention that the SoC promoted by these presentation patterns often translates into each UI flow being broken into classes or components that are instructed to do something specific, tightly related to their responsibility.</p>
			<p>To see what I'm talking about, let's briefly cover them, starting out with MVC.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor252"/>MVC</h2>
			<p>A common implementation in<a id="_idIndexMarker532"/> Android projects of the MVC pattern defines<a id="_idIndexMarker533"/> its layers like so:</p>
			<ul>
				<li><strong class="bold">View</strong>: Views <a id="_idIndexMarker534"/>inflated from the XML layouts as a representation of the UI. This layer would only be rendering the content it receives from the Controller onto the screen.</li>
				<li><code>Activity</code> or <code>Fragment</code>. This component would define the state of the UI by preparing data received from the Model layer for presentation, or by intercepting UI events that in turn would mutate the state. Additionally, the Controller would be in charge of setting actual data to the View layer.</li>
				<li><strong class="bold">Model</strong>: The <a id="_idIndexMarker536"/>entry point of data. The actual structure doesn't depend on MVC, but we can think of it as the layer that obtains content needed by the Presentation layer, by querying a local database or remote <a id="_idIndexMarker537"/>sources such as web <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>).</li>
			</ul>
			<p>Let's visualize the actual separation brought by this pattern, as follows:</p>
			<div><div><img src="img/B17788_07_2.jpg" alt="Figure 7.2 – Presentation layer in the MVC pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Presentation layer in the MVC pattern</p>
			<p>This implementation<a id="_idIndexMarker538"/> of the MVC pattern achieves a proper separation between the Presentation layer and the Model layer, therefore liberating <code>Activity</code> and <code>Fragment</code> controllers from being the ones that obtain data <a id="_idIndexMarker539"/>from <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) APIs or local databases. Yet at least in this form factor, MVC doesn't shine where it should because the actual separation within the Presentation layer could be improved.</p>
			<p>Disadvantages<a id="_idIndexMarker540"/> of this pattern may include the following:</p>
			<ul>
				<li>High coupling between the Controller (<code>Activity</code> or <code>Fragment</code> controllers) and the View layer. Since the Controller is a component with a lifecycle and it also must provide the infrastructure of building and setting up Android views with content (such as building <code>Adapter</code> classes and passing data), testing it becomes difficult because it's tightly coupled with Android APIs.</li>
				<li>The Controller has two responsibilities: it handles the state of the UI (presentation logic) while also providing infrastructure for the View layer to function (UI logic). The two responsibilities become tangled up—when testing one, you would be testing the other too.</li>
			</ul>
			<p>Let's move on to another popular presentation pattern in Android.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor253"/>MVP</h2>
			<p>A common implementation in Android<a id="_idIndexMarker541"/> projects of the MVP pattern defines its layers like so:</p>
			<ul>
				<li><code>Activity</code> or <code>Fragment</code> class and their corresponding inflated views from XML. This layer now encapsulates the entire UI logic: it provides the infrastructure of building and setting up rendered Android views with content.</li>
				<li><code>Activity</code> or <code>Fragment</code>) is established. The interface allows the Presenter to pass data that is ready for presentation to the UI layer and to directly mutate the UI state at the UI level.</li>
			</ul>
			<p>Unlike the Controller in MVC, the Presenter is no longer coupled to lifecycle components or Android View APIs, so it becomes much easier to test the presentation logic that it contains.</p>
			<ul>
				<li><strong class="bold">Model</strong>: The same <a id="_idIndexMarker544"/>as in MVC.</li>
			</ul>
			<p>Let's visualize the actual separation brought by this pattern, as follows:</p>
			<div><div><img src="img/B17788_07_3.jpg" alt="Figure 7.3 – Presentation layer in the MVP pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Presentation layer in the MVP pattern</p>
			<p>Unlike MVC, <code>Activity</code> and <code>Fragment</code> are now part of the View layer, which seems more natural because they are both tightly related to the Android UI. This approach allows the Presenter to be the one that prepares data that must be presented, while imperatively mutating the UI.</p>
			<p>Since we now have a separate entity that is in charge of presenting data to the UI, we can say that, unlike MVC, MVP performs the SoC inside the Presentation layer somewhat better.</p>
			<p>However, there are still<a id="_idIndexMarker545"/> some issues with this approach, as outlined here:</p>
			<ul>
				<li>The imperative approach of having the Presenter manually update the UI directly in the <code>Activity</code> or <code>Fragment</code> class can be prone to bugs and can cause illegal UI states (such as showing an error message and a loading status at the same time) as a project grows and new features are added. This is similar to how a UI controller (such as <code>Activity</code>) also imperatively mutates XML views—an approach that we deemed as prone to issues when we introduced Compose with its declarative paradigm.</li>
				<li>If the interface contract between the Presenter and the View layer is not well designed or is missing entirely, the two would become coupled, and reusing the Presenter for other <code>Activity</code> or <code>Fragment</code> controllers might be difficult.</li>
			</ul>
			<p>Let's move on to another important presentation pattern.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor254"/>MVVM</h2>
			<p>MVVM is a <a id="_idIndexMarker546"/>very popular presentation pattern in Android, mostly because it addresses the concerns stated with the previously mentioned implementation of MVP.</p>
			<p>A common implementation<a id="_idIndexMarker547"/> in Android projects of MVVM defines its layers like so:</p>
			<div><div><img src="img/B17788_07_4.jpg" alt="Figure 7.4 – Presentation layer in the MVVM pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Presentation layer in the MVVM pattern</p>
			<p>Let's look at how the layers are defined:</p>
			<ul>
				<li><code>Activity</code> or <code>Fragment</code> class and its XML views, just as in MVP. Unlike in MVP, though, the View layer observes either an observable state or observable fields from the <code>ViewModel</code>, both containing UI data. Whenever new updates are received from those observable entities, the View layer updates the UI with the content received.</li>
				<li><code>ViewModel</code> defines the UI state as an observable property (or multiple observable fields) and is totally decoupled from the View layer as it has no reference to it.</li>
				<li><strong class="bold">Model</strong>: The same <a id="_idIndexMarker550"/>as in MVC or MVP.</li>
			</ul>
			<p>One advantage of the <code>ViewModel</code>, as opposed to the Presenter in MVP, is that it's no longer <a id="_idIndexMarker551"/>coupled to the View layer, so it can be reused much more easily. In contrast with MVP, the View layer is responsible for referencing the <code>ViewModel</code> for obtaining and observing the observable state, and so the <code>ViewModel</code> no longer needs to reference the View layer, becoming totally independent. </p>
			<p>In other words, the <code>ViewModel</code> in MVVM forces the View layer to subscribe to data, which is different from MVP, where the Presenter was manually setting up the View layer with data. This approach allows multiple Views to bind to the same <code>ViewModel</code>, therefore <em class="italic">sharing</em> the same UI state within the same <code>ViewModel</code>.</p>
			<p>Another advantage is<a id="_idIndexMarker552"/> that since the View layer observes the UI state from the <code>ViewModel</code> and binds the received data as an effect, the <code>ViewModel</code> doesn't imperatively update the UI as the Presenter did through an interface in MVP. In other words, the View layer obtains the UI state from the <code>ViewModel</code> and binds it to the UI—this results in a unidirectional flow of data that is less likely to introduce bugs or illegal states.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While considering the original definition of MVVM, the ViewModel shouldn't be confused with the Jetpack ViewModel component—the ViewModel can be a simple class that presents the data through an observable state. For us on Android, though, it's convenient to consider the Jetpack ViewModel as the actual ViewModel from MVVM because it brings some advantages out of the box.</p>
			<p>However, the pattern's implementation <a id="_idIndexMarker553"/>that is commonly used in Android considers the Jetpack ViewModel as the ViewModel from MVVM, and this brings both a set of advantages and disadvantages.</p>
			<p>Using the<a id="_idIndexMarker554"/> Jetpack ViewModel as the <code>ViewModel</code> from MVVM is beneficial for the following reasons:</p>
			<ul>
				<li>The Jetpack ViewModel is scoped to the lifetime of the View and provides convenient APIs for canceling work such as the <code>onCleared()</code> callback or the <code>viewModelScope</code> coroutine scope, therefore providing a convenient API for canceling asynchronous jobs and minimizing the risk of memory leaks.</li>
				<li>The Jetpack ViewModel survives configuration changes, therefore allowing you to preserve the UI state automatically if the user changes the orientation of the device, for example.</li>
				<li>You can easily restore the UI state after system-initiated process death because the Jetpack ViewModel is providing us with a <code>SavedStateHandle</code> object.</li>
			</ul>
			<p>Unfortunately, this approach <a id="_idIndexMarker555"/>comes with the following downsides:</p>
			<ul>
				<li>The <code>ViewModel</code> is now a library dependency (the Jetpack ViewModel) that introduces coupling with the Android platform (as it exposes APIs such as <code>SavedStateHandle</code>). This prevents us from reusing presentation components for cross-platform projects <a id="_idIndexMarker556"/>with <strong class="bold">Kotlin Multiplatform</strong> (<strong class="bold">KMP</strong>).</li>
				<li>Because the Jetpack ViewModel is a library dependency that handles other responsibilities apart from data presentation, such as restoring the UI state after system-initiated process death, we could argue that the Presentation layer concerns are not very well separated.</li>
			</ul>
			<p>Now that we have had a quick overview of presentation patterns, it's time for a practical example.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor255"/>Refactoring our Restaurants app to fit a presentation pattern</h1>
			<p>We plan to <a id="_idIndexMarker557"/>refactor our Restaurants app to fit a presentation pattern. From our previous comparison, we can consider<a id="_idIndexMarker558"/> that MVVM is best suited for our Compose-based app. Don't worry—we will talk about this decision in more detail a bit later.</p>
			<p>But before we do that, let's add more functionality inside the application to better highlight how mingling responsibilities can lead to unmaintainable code.</p>
			<p>To summarize, in this section, we're going to be doing the following:</p>
			<ul>
				<li>Adding more functionality inside our Restaurants app</li>
				<li>Refactoring our Restaurants app to MVVM</li>
			</ul>
			<p>Let's begin!</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor256"/>Adding more functionality inside our Restaurants app</h2>
			<p>When the <a id="_idIndexMarker559"/>Restaurants application is launched, the <code>RestaurantsScreen()</code> composable is rendered. Inside this screen, we are loading a bunch of restaurants from the server, and then we're displaying them to the user.</p>
			<p>Yet while our app waits for the network request to finish and for the local caching to Room to happen (in order for it to receive restaurants for the UI), the screen remains blank, and the user has no idea what's going on. To provide a better <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>), we should<a id="_idIndexMarker560"/> somehow suggest to the user the fact that we're waiting for content from the server.</p>
			<p>We could do that through a loading progress bar! Inside the <code>RestaurantsScreen()</code> composable, we could add a loading UI element that is displayed until the <code>LazyColumn</code> composable that renders a list of restaurants is populated. When the content arrives, we should hide it, thereby letting the user know that the application has loaded its content.</p>
			<p>Let's do that right now, as follows:</p>
			<ol>
				<li>First, inside the <code>RestaurantsScreen()</code> composable, save the restaurant list from the state (retrieved from <code>RestaurantsViewModel</code>) inside a <code>restaurants</code> variable, like this:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    val viewModel: R<a id="_idTextAnchor257"/>estaurantsViewModel = viewModel()
    <strong class="bold">val restaurants = viewModel.state.value</strong>
    LazyColumn(…){
        items(<strong class="bold">restaurants</strong>) { restaurant -&gt;
            RestaurantItem(…)
        }
    }
}</pre></li>
			</ol>
			<p>Make sure to also pass the <code>restaurants</code> variable<a id="_idIndexMarker561"/> to the <code>LazyColumn</code> composable's <code>items</code> <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) function.</p>
			<ol>
				<li value="2">We need<a id="_idIndexMarker562"/> to define a condition that lets us know when to show a loading indicator. As a first attempt, we could say that when the <code>restaurants</code> variable contains an empty <code>List&lt;Restaurant&gt;</code> as a value, which means that restaurants haven't arrived yet, the content is still loading. Add an <code>isLoading</code> variable that accounts for this, as follows:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    val viewModel: RestaurantsViewModel = viewModel()
    val <a id="_idTextAnchor258"/>restaurants = viewModel.state.value
    <strong class="bold">val isLoading = restaurants.isEmpty()</strong>
    LazyColumn(…){ … }
}</pre></li>
			</ol>
			<p>If, however, restaurants arrive from the server, the <code>state</code> variable is updated, and the <code>restaurants</code> variable no longer contains an empty list of restaurants. At this point, the <code>isLoading</code> variable becomes <code>false</code>.</p>
			<ol>
				<li value="3">We want t<a id="_idTextAnchor259"/>o display a loading indicator while the <code>isLoading</code> variable is <code>true</code>. To do that, wrap the <code>LazyColumn</code> composable in a <code>Box</code> composable, and below the <code>LazyColumn</code> code, check if th<a id="_idTextAnchor260"/>e <code>isLoading</code> variable is <code>true</code> and pass a <code>CircularProgressIndicator</code> composable. The code is illustrated in the <a id="_idIndexMarker563"/>following snippet:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    …
    v<a id="_idTextAnchor261"/>al isLoading = restaurants.isEmpty()
    <a id="_idTextAnchor262"/><strong class="bold">Box() {</strong>
        LazyColumn(…){…}
<strong class="bold">        if(isLoading)</strong>
<strong class="bold">            CircularProgressIndicator()</strong>
    <strong class="bold">}</strong>
}</pre></li>
			</ol>
			<p>The <code>Box</code> composable allows us to overlay two composables: <code>LazyColumn</code> and <code>CircularProgressIndicator</code>. Because of the <code>if</code> condition that we've added, we now have the following two cases:</p>
			<ul>
				<li><code>isLoading</code> is <code>true</code> (the app is waiting for restaurants), so both composables are composed. While the <code>CircularProgressIndicator</code> composable is displayed on top of the <code>LazyColumn</code> composable, the <code>LazyColumn</code> composable contains no elements, so it's not visible.</li>
				<li><code>isLoading</code> is <code>false</code> (the app now has restaurants to display), so only the <code>LazyColumn</code> composable is composed and visible.</li>
			</ul>
			<ol>
				<li value="4">To center the <code>CircularProgressIndicator</code> composable, add the <code>Alignment.Center</code> alignment to the <code>contentAlignment</code> parameter of the <code>Box</code> composable, while also passing a <code>Modifier.fillMaxSize()</code> modifier. The <a id="_idIndexMarker564"/>code is illustrated in the following snippet:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    …
    Box(<strong class="bold">contentAlignment = Alignment.Center</strong>,
<strong class="bold">        modifier = Modifier.fillMaxSize()</strong>) {
        …
    }
}</pre></li>
				<li>Build and run the app. For a moment (until restaurants are loaded), you should see a loading progress indicator. When restaurants are displayed, this should go away.</li>
			</ol>
			<p>Inside the UI layer, we have now added a loading indicator as well as the logic that decides when to display it. In this simple scenario, our logic works, but what happens if the server (or local database) returns an empty list of restaurants? Then the loading indicator will never go away.</p>
			<p>Or, what happens if an error occurs? Our <code>RestaurantsScreen</code> composable has no idea that an error was generated. This means that not only does it not know when to display the error, but it also doesn't know when to hide the loading indicator if such an error were to occur.</p>
			<p>These issues arise from the fact that we're trying to define presentation logic (when to show or hide a loading indicator; when to show an error message) inside the UI layer (where composables reside), thereby mixing UI logic with presentation logic.</p>
			<p>We can now see just some limitations that derive from mixing UI logic with presentation logic, yet there's also the fact that in the previous chapters, we've mixed the presentation logic with <a id="_idIndexMarker565"/>the data logic. The long-term implications for our current approach are scary: debugging will be difficult, and testing even more so.</p>
			<p>It's time to refactor our Restaurants app to MVVM so that we can better separate its responsibilities.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor263"/>Refactoring our Restaurants app to MVVM</h2>
			<p>To better<a id="_idIndexMarker566"/> separate responsibilities, we will choose the most popular presentation pattern: MVVM. Despite its flaws, when you compare it to MVC and <a id="_idIndexMarker567"/>MVP following the definition we previously gave them, it's the best candidate so far for the following reasons:</p>
			<ul>
				<li>It provides a pretty good separation between the UI logic and the presentation logic.</li>
				<li>Our UI layer (the composables) is designed to expect an observable state (more precisely, the Compose <code>State</code> object), just like the one the <code>ViewModel</code> in MVVM is set to expose.</li>
			</ul>
			<p>Now, our Restaurants app already uses the Jetpack ViewModel (that exposes a Compose <code>State</code> object that is observed and consumed inside the composables), so we can say that we unknowingly started implementing this modified version of the pattern, whereby the Jetpack ViewModel is the ViewModel from MVVM.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will consider for now that the advantages of using the Jetpack ViewModel as the <code>ViewModel</code> in MVVM are outweighing the disadvantages that it brings, so we will keep it as it is.</p>
			<p>However, just because we used a <code>ViewModel</code>, that doesn't mean we also implemented the MVVM presentation pattern correctly. Let's first have a look at how we structured our components and classes for the first screen displaying a list of restaurants. You can see how this looks here:</p>
			<div><div><img src="img/B17788_07_5.jpg" alt="Figure 7.5 – Components with poorly separated responsibilities per layer in the MVVM pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Components with poorly separated responsibilities per layer in the MVVM pattern</p>
			<p>For this<a id="_idIndexMarker568"/> screen, we notice two violations where layers<a id="_idIndexMarker569"/> contain more than one responsibility, as outlined here:</p>
			<ul>
				<li>The View layer (represented by the <code>RestaurantsScreen()</code> composable) performs both UI logic and presentation logic. While this composable should only contain UI logic (the stateless composables that consume the state content), some presentation logic lurked in when the <code>isLoading</code> variable was calculated, as illustrated in the following code snippet:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    …
    val isLoading = restaurants.isEmpty()
    …
}</pre></li>
			</ul>
			<p>The composables shouldn't be in charge of deciding their own state as in this case—the <code>RestaurantsScreen()</code> composable shouldn't hold presentation logic; instead, this should be moved inside the <code>ViewModel</code>.</p>
			<ul>
				<li>The <code>RestaurantsViewModel</code> class contains both presentation logic (such as holding and updating the state of the UI) and data logic (as it works with the Retrofit service <a id="_idIndexMarker570"/>Room <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) when it<a id="_idIndexMarker571"/> obtains and caches restaurants), as illustrated in the following code snippet:<pre>class RestaurantsViewModel() : ViewModel() {
    private var restInterface: RestaurantsApiService
    private var restaurantsDao = ...
    val state = mutableStateOf(emptyList&lt;Restaurant&gt;())
    private suspend fun getAllRestaurants(): … {…}
        ...
    private suspend fun refreshCache() {...}
}</pre></li>
			</ul>
			<p>It's clear <a id="_idIndexMarker572"/>that presentation logic occurs when the <code>state</code> variable is updated, but there's also a lot of data logic when restaurants are obtained from the <code>restInterface</code> variable, then cached and updated in the <code>restaurantsDao</code> variable, and so on.</p>
			<p>All this data logic shouldn't reside inside the <code>ViewModel</code> but instead inside the Model layer because the <code>ViewModel</code> should only present the data and not care to know about the data sources and how they are used—it only knows that it should receive some data.</p>
			<p>Now, let's have a look at how we should correctly structure our classes (to follow MVVM) for the first flow of displaying a list of restaurants. The components should look like this:</p>
			<div><div><img src="img/B17788_07_6.jpg" alt="Figure 7.6 – Components with well-separated responsibilities per layer in the MVVM pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Components with well-separated responsibilities per layer in the MVVM pattern</p>
			<p>In the <a id="_idIndexMarker573"/>previous diagram, each component handles its own <a id="_idIndexMarker574"/>responsibility, as follows:</p>
			<ul>
				<li>The View component contains only composables (<code>RestaurantsScreen</code>) with UI logic (consuming the UI state).</li>
				<li>The ViewModel component (<code>RestaurantsViewModel</code>) contains only presentation logic (holds the UI state and mutates it).</li>
				<li>The Model component (where we will create a <code>RestaurantsRepository</code> class—more on that soon) contains only data logic (obtains restaurants from remote sources, caches them into a local source, and so on).</li>
			</ul>
			<p>To achieve this separation, in this section, we will be doing the following:</p>
			<ul>
				<li>Separating UI logic from presentation logic</li>
				<li>Separating presentation logic from data logic</li>
			</ul>
			<p>Let's start!</p>
			<h3>Separating UI logic from presentation logic</h3>
			<p>The <a id="_idIndexMarker575"/>UI logic (rendering composables) is already at the UI level (Compose UI), so we don't have to do anything from this point of view. However, we need to extract the presentation logic from the UI layer to the <code>ViewModel</code>, where it should reside.</p>
			<p>More specifically, from within the <code>RestaurantsScreen()</code> composable, we want to move the calculation of the <code>isLoading</code> variable to the <code>RestaurantsViewModel</code> class, simply because the <code>ViewModel</code> should decide and also know better when the screen should be in a loading state.</p>
			<p>To do that, we<a id="_idIndexMarker576"/> will create a <code>state</code> class that will hold all the information the UI needs in order to render the correct state. This approach is much more efficient because the <code>ViewModel</code> is responsible for requesting data and therefore knows better when content arrives, and so on. Because of this, later on, it will be very simple for us to also allow the <code>ViewModel</code> to also dictate when the screen must show an error state. Proceed as follows:</p>
			<ol>
				<li value="1">Create a class that will model the UI state for the <code>RestaurantsScreen()</code> composable. Do that by clicking on the application packag<a id="_idTextAnchor264"/>e, selecting <code>RestaurantsScreenState</code> as the name and select <code>restaurants</code> list, and an <code>isLoading</code> flag<a id="_idTextAnchor265"/>. The code is illustrated in the following snippet:<pre>data class RestaurantsScreenState(
    val restaurants: List&lt;Restaurant&gt;,
    val isLoading: Boolean)</pre></li>
			</ol>
			<p>Since we've used a <code>data class</code> instead of a regular <code>class</code>, we will be able to easily perform mutation on this object with the <code>.copy()</code> function, thereby ensuring that since the Compose <code>state</code> object will receive a new object, it will know to trigger recomposition.</p>
			<ol>
				<li value="2">Inside the <code>RestaurantsViewModel</code> class, update the initial state value of the <code>state</code> variable and pass a <code>RestaurantsScreenState</code> object, as follows:<pre>class RestaurantsViewModel() : ViewMode<a id="_idTextAnchor266"/>l() {
    …
    val state = mutableStateOf(
<strong class="bold">        RestaurantsScreenState(</strong>
<strong class="bold">            restaurants = listOf(),</strong>
<strong class="bold">            isLoading = true)</strong>
    )
    …
}</pre></li>
			</ol>
			<p>We've marked the <code>restaurants</code> field as an empty list, and <code>isLoading</code> is <code>true</code> because from this point on, we're waiting for restaurants and the UI should render a loading state.</p>
			<ol>
				<li value="3">Still inside<a id="_idIndexMarker577"/> the <code>RestaurantsViewModel</code> class, find the <code>getRestaurants()</code> method and update the way we update the <code>state</code> variable, as follows:<pre>private fun getRestaurants(<a id="_idTextAnchor267"/>) {
    viewModelSco<a id="_idTextAnchor268"/>pe.launch(errorHandler) {
        <strong class="bold">val restaurants = </strong>getAllRestaurants()
        <strong class="bold">state.value = state.value.copy(</strong>
<strong class="bold">            restaurants = restaurants,</strong>
<strong class="bold">            isLoading = false)</strong>
    }
}</pre></li>
			</ol>
			<p>We first stored restaurants inside a <code>restaurants</code> variable. Then, we used the <code>copy()</code> function to pass a new restaurants list that we received to the <code>restaurants</code> field, and also marked the <code>isLoading</code> field to <code>false</code> because the data has arrived and the UI should no longer render a loading state.</p>
			<ol>
				<li value="4">Still i<a id="_idTextAnchor269"/>n the <code>RestaurantsViewModel</code> class, make sure that the <code>toggleFavorite()</code> method is correctly updating the <code>state</code> variable object using the <code>copy()</code> function, as follows:<pre>fun toggleFavorite(id: Int, oldValue: Boolean) {
    viewModelScope.launch(errorHan<a id="_idTextAnchor270"/>dler) {
        val updatedRestaurants = […]
        <strong class="bold">state.value = state.value.copy(restaurants =</strong>      
            <strong class="bold">updatedRestaurants)</strong>
    }
}</pre></li>
			</ol>
			<p>All right—we've added all the presentation logic within the <code>ViewModel</code>, and it's now time to update the UI (our composables) to render new possible UI states.</p>
			<ol>
				<li value="5">Refactor<a id="_idIndexMarker578"/> the <code>RestaurantsScreen()</code> composable to consume the new UI state content, as follows:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    <a id="_idTextAnchor271"/>val viewModel: RestaurantsViewModel = viewModel()
    <strong class="bold">val state = viewModel.state.value</strong>
  <a id="_idTextAnchor272"/>  Box(…) {
        LazyColumn(…) {
             i<a id="_idTextAnchor273"/>tems(<strong class="bold">state.restaurants</strong>) {…}
        }
        if (<strong class="bold">state.isLoading</strong>)
            CircularProgressIndicator()
    }
}</pre></li>
			</ol>
			<p>Let's break down what we've done, as follows:</p>
			<ul>
				<li>We renamed the <code>restaurants</code> variable as <code>state</code> to better suggest that this variable holds the state of this screen.</li>
				<li>We passed <code>state.restaurants</code> to the <code>LazyColumn</code> composable's <code>items</code> DSL function.</li>
				<li>We deleted this line: <code>val isLoading = restaurants.isEmpty()</code>.</li>
				<li>We updated the condition for when to show <code>CircularProgressIndicator()</code> based on the <code>state.isLoading</code> value—no more decision-making logic inside this composable.</li>
			</ul>
			<ol>
				<li value="6">Build and run the app. </li>
			</ol>
			<p>You should<a id="_idIndexMarker579"/> be able to see the loading indicator, just as before, yet the difference is that the presentation logic is better separated and held by the <code>ViewModel</code>. With our new approach, if for any reason we receive an empty list from our data sources (Retrofit and Room), the application won't misbehave and show a loading state because the UI is checking whether the list is empty or not.</p>
			<p>To see how simple it is to add a new state to our Compose-based UI, let's continue by setting an error state when any error is thrown inside the <code>View<a id="_idTextAnchor274"/>Model</code>.</p>
			<ol>
				<li value="7">Inside the <code>RestaurantsScreenState</code> class, add an <code>error: String</code> parameter that will hold an error message if any error occurs, as follows:<pre>data class RestaurantsScreenState(
    val restaura<a id="_idTextAnchor275"/>nts: List&lt;Restaurant&gt;,
    val isLoading: Boolean,
<strong class="bold">    val error: String? = null</strong>
)</pre></li>
			</ol>
			<p>To simplify our work with state handling inside the <code>ViewModel</code>, we've set a default value of <code>null</code> to the <code>error</code> field, since the initial state of <a id="_idTextAnchor276"/>the screen shouldn't ever contain an error.</p>
			<ol>
				<li value="8">Inside<a id="_idIndexMarker580"/> the <code>RestaurantsViewModel</code> class, find the <code>errorHandler</code> variable that we use to catch any exception that might be thrown by our coroutines, and update the <code>state</code> object by passing an <code>exception.message</code> error message to the <code>error</code> field. The code is illustrated in the following snippet:<pre>class RestaurantsViewModel() : ViewModel() {
    …
    private val errorHandler =
        CoroutineExceptionHandler { _, exception -&gt;
            exception.printStackTrace()
            <strong class="bold">state.value = state.value.copy(</strong>
<strong class="bold">                error = exception.message,</strong>
<strong class="bold">                isLoading = false</strong>
<strong class="bold">            )</strong>
        }
    ...
}</pre></li>
			</ol>
			<p>Additionally, we've set the <code>isLoading</code> field to <code>false</code> on the new state simply because if an error is thrown, we don't want the UI to be in a loading state.</p>
			<p>If, however, you want to add a retry button that is pressed after an error has occurred and was shown, you would have to set the <code>error</code> field to <code>null</code> when that button is pressed so that the UI won't remain in an error state indefinitely.</p>
			<ol>
				<li value="9">Inside the <code>RestaurantsScreen()</code> composable, add another <code>if</code> statement in the <code>Box</code> composable. This statement checks whether the <code>state</code> object contains an<a id="_idIndexMarker581"/> error message to be shown, and if that is <code>true</code>, add a <code>Text</code> composable that will display the error message. The code is illustrated in the following snippet:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    …
    Box(…) {
        LazyColumn(...) {…}
        if (state.is<a id="_idTextAnchor277"/>Loading)
            CircularProgressIndicator()
        <strong class="bold">if (state.error != null)</strong>
<strong class="bold">            Text(state.error)</strong>
    }
}</pre></li>
				<li>Build the project, and now, let's test the error scenario. Yet to see the error message, we need to simulate an error.</li>
			</ol>
			<p>If you remember, inside our <code>RestaurantsViewModel</code> class's <code>getAllRestaurants()</code> method, we check if we failed in retrieving restaurants from the server (Retrofit client), and if this happens while the Room DAO is also empty, we throw this error message: <code>"Something went wrong. We have no data."</code>. </p>
			<p>To reproduce this scenario, make sure that the following applies:</p>
			<ul>
				<li>You have cleared the cache of the application. To do that, inside your device or emulator, go to <strong class="bold">Settings</strong>, then <strong class="bold">Applications</strong>, and search for our Restaurants app and press on it. Then, press <strong class="bold">Storage and Cache</strong> and then <strong class="bold">Clear Storage</strong>.</li>
				<li>Your device/emulator is disconnected from the internet.</li>
			</ul>
			<ol>
				<li value="11">Run the <a id="_idIndexMarker582"/>application. You should see this message in the center of the screen: <code>"Something went wrong. We have no data."</code>.<p class="callout-heading">Note</p><p class="callout">For the sake of simplicity, we made sure that the UI logic is separated from the presentation logic only within the first screen of our app. When you're looking to move logic to corresponding classes, thereby ensuring SoC, you need to make sure to do so for all other screens within the app, together with their <code>ViewModel</code> classes, and so on.</p></li>
			</ol>
			<p>Now that we've separated UI logic from presentation logic, it's time to separate some data logic.</p>
			<h3>Separating presentation logic from data logic</h3>
			<p>While the <code>RestaurantsViewModel</code> class contains data logic because it interacts with the<a id="_idIndexMarker583"/> Retrofit service and the Room DAO to obtain and cache restaurants, it should only hold presentation logic because its core responsibility is to govern the UI state.</p>
			<p>Another sign that our <code>RestaurantsViewModel</code> has piled up a lot of logic is that it currently stands at around 90 lines of code—this might not seem much yet, remember that our application is pretty simple and we have little presentation logic, so 90 lines will definitely turn into thousands for production-ready applications.</p>
			<p>We want to move the data logic out of the <code>RestaurantsViewModel</code> into a different class. Since data logic is part of the Model layer of our application, in this section, we will start exploring how to define the Model layer with the help of Repository classes.</p>
			<p>The <strong class="bold">Repository</strong> pattern<a id="_idIndexMarker584"/> represents a strategy for abstracting data access inside your application. In other words, Repository classes hide away from the caller all the complexity associated with parsing data from the server, storing it in local databases, or performing any caching/refreshing mechanisms.</p>
			<p>In our app, the <code>RestaurantsViewModel</code> class must decide whether to get data from the <code>restInterface</code> (remote) source or from the <code>restaurantsDao</code> (local) source, while also making sure to refresh the cache. The following snippet shows the code that<a id="_idIndexMarker585"/> is executed:</p>
			<pre>class RestaurantsViewModel() : ViewModel() {
    private var restInterface: RestaurantsApiService
    private var restaurantsDao = [...]
        ...
    private suspend fun refreshCache() {...}
}</pre>
			<p>This is obviously wrong. The <code>ViewModel</code> shouldn't care which particular data source to call as it shouldn't need to be the one that initiates caching to local sources. The <code>ViewModel</code> should only care about receiving some content that it will prepare for presentation.</p>
			<p>Let's lift this burden from the <code>RestaurantsViewModel</code> class by creating a Repository class that will abstract all the data logic, as it will be interacting with the two data sources (web API and Room DAO) to do the following:</p>
			<ul>
				<li>Provide a <code>List&lt;Restaurant&gt;</code> object to the Presentation layer</li>
				<li>Handle any caching logic such as retrieving restaurants from the web API and caching them to the Room local database</li>
				<li>Define<a id="_idIndexMarker586"/> a <strong class="bold">single source of truth</strong> (<strong class="bold">SSOT</strong>) for data—the Room database</li>
			</ul>
			<p>To do that, we must only move the data logic out of the <code>ViewModel</code> and separate it in a Repository class. Let's begin, as follows:</p>
			<ol>
				<li value="1">Create a Repository class by clicking on the applicat<a id="_idTextAnchor278"/>ion package, selecting <code>RestaurantsRepository</code> as the name and select <strong class="bold">Class</strong> as the type:<pre>class RestaurantsRepository { }</pre></li>
			</ol>
			<p>Now, let's start moving some code!</p>
			<ol>
				<li value="2">From <a id="_idIndexMarker587"/>inside the <code>RestaurantsViewModel</code> class, cut the <code>restInterface</code> variable and its initialization logic from the <code>init</code> block and paste it inside <code>Restaur<a id="_idTextAnchor279"/>antsRepository</code>, as follows: <pre>class RestaurantsRepository {
    <strong class="bold">private var restInterface: RestaurantsApiService =</strong>
        <strong class="bold">Retrofit.Builder()</strong>
            .<strong class="bold">addConverterFactory(…)</strong>
            <strong class="bold">.baseUrl(…)</strong>
            <strong class="bold">.build()</strong>
            <strong class="bold">.create(RestaurantsApiService::class.java)</strong>
}</pre></li>
				<li>Do the same for the <code>restaurantsDao</code> variable, as follows:<pre>class RestaurantsRepository {
    private var restInterface: RestaurantsApiService = …
<strong class="bold">    private var restaurantsDao = RestaurantsDb</strong>
<strong class="bold">        .getDaoInstance(</strong>
<strong class="bold">            RestaurantsApplication.getAppContext())</strong>
}</pre></li>
				<li>Inside the <code>RestaurantsViewModel</code> class, add a <code>repository</code> variable and instantiate it with the <code>RestaurantsRepository()</code> constructo<a id="_idTextAnchor280"/>r, like this:<pre>class RestaurantsViewModel() : ViewModel() {
    <strong class="bold">private val repository = RestaurantsRepository()</strong>
    val state = mutableStateOf(…)
    private val errorHandler = CoroutineExceptionHandler { … } 
    init {
        getRestaurants()
    }
     […]
}</pre></li>
			</ol>
			<p>Make sure that the <code>RestaurantsViewModel</code> no longer contains the <code>restInterface</code> variable, the <code>restaurantsDao</code> variable, or their initialization code from within the <code>init</code> block.</p>
			<ol>
				<li value="5">Move<a id="_idIndexMarker588"/> the <code>toggleFavoriteRestaurant()</code>,  <code>getAllRestaurants()</code>, and <code>refreshCache()</code> methods of the <code>RestaurantsViewModel</code> class to the <code>RestaurantsRepository</code> class, as follows:<pre>class RestaurantsRepository {
    private var restInterface: RestaurantsApiService = …
    private var restaurantsDao = […]
<strong class="bold">    private suspend fun toggleFavoriteRestaurant(…) = […]</strong>
<strong class="bold">    private suspend fun getAllRestaurants(): […] { … }</strong>
<strong class="bold">    private suspend fun refreshCache() { … }</strong>
}</pre></li>
				<li>Make sure that apart from the <code>init { }</code> block, the <code>RestaurantsViewModel</code> class only contains the <code>toggleFavorite()</code> and <code>getRestaurants()</code> methods, as follows:<pre>class RestaurantsViewModel() : ViewModel() {
    […]
    init { getRestaurants() }
    fun toggleFavorite(id: Int, oldValue: Boolean) {…}
    private fun getRestaurants() {…}
}</pre></li>
				<li>Inside the <code>RestaurantsRepository</code> class, remove the <code>private</code> modifier for the <code>getAllRestaurants()</code> and <code>toggleFavoriteRestaurant()</code> methods as <code>RestaurantsViewModel</code> will need to call them, so they must be <a id="_idIndexMarker589"/>public. The code is illustrated in the following snippet:<pre>class RestaurantsRepository {
    […]
    <strong class="bold">suspend fun toggleFavoriteRestaurant(…)</strong> = […]
    <strong class="bold">suspend fun getAllRestaurants():</strong> […] { … }
    private suspend fun refreshCache() { … }
}</pre></li>
				<li>Going back inside the <code>RestaurantsViewModel</code> class, update the <code>getRestaurants()</code> method to now call <code>repository.getAllRestaurants()</code>, as follows:<pre>private fun getRestaurants() {
    viewModelScope.launch(errorHandler) {
        val restaurants = <strong class="bold">repository.</strong>getAllRestaurants()
        state.value = state.value.copy(…)
    }
}</pre></li>
				<li>Still inside the <code>RestaurantsViewModel</code> class, update the <code>toggleFavorite()</code> method<a id="_idIndexMarker590"/> to now call <code>repository.toggleFavoriteRestaurant()</code>, as follows:<pre>fun toggleFavorite(id: Int, oldValue: Boolean) {
    viewModelScope.launch(errorHandler) {
        val updatedRestaurants = <strong class="bold">repository</strong>
            .toggleFavoriteRestaurant(id, oldValue)
        state.value = state.value.copy(…)
    }
}</pre></li>
			</ol>
			<p>And we're done! While the functionality of the first screen should stay the same, we have now divided the responsibilities within this first flow not only within the Presentation layer but also between the Presentation layer and the Model layer.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">You can try to practice what we've learned in this section on the details screen of the Restaurants application.</p>
			<p>Next up, let's return for a while to the Presentation layer and inspect how the UI state is exposed from within our <code>ViewModel</code>.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor281"/>Improving state encapsulation in ViewModel</h1>
			<p>Let's <a id="_idIndexMarker591"/>have a look at how the UI state is defined in<a id="_idIndexMarker592"/> the <code>RestaurantsViewModel</code> class, as follows:</p>
			<pre>class RestaurantsViewModel() : ViewModel() {
    …
    val state = mutableStateOf(RestaurantsScreenState(
        restaurants = listOf(),
        isLoading = true))
    …
}</pre>
			<p>Inside the <code>RestaurantsViewModel</code>, we are holding the state within the <code>state</code> variable with the <code>MutableState&lt;RestaurantsScreenState&gt;</code> inferred type. This variable is public, so inside the UI layer, from within the <code>RestaurantsScreen()</code> composable, we can consume it by accessing the <code>viewModel</code> variable and directly obtaining the <code>state</code> object, as follows:</p>
			<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    val viewModel: RestaurantsViewModel = viewModel()
    val state = viewModel.state.value
    Box(…) {…}
}</pre>
			<p>The problem with this approach might not be obvious, but since the <code>state</code> variable is of type <code>MutableState</code>, not only can we read its value but we can also write its value. In other words, from within the composable UI layer, we have write access to the <code>state</code> variable through the <code>.value</code> accessor.</p>
			<p>The danger here is that then we (or other colleagues within our development team) could mistakenly update the UI state from within the UI layer, like so:</p>
			<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    val viewModel: RestaurantsViewModel = viewModel()
    val state = viewModel.state.value
    Box(…) {…}
<strong class="bold">    viewModel.state.value = viewModel.state.value.copy(</strong>
<strong class="bold">        isLoading = false)</strong>
}</pre>
			<p><em class="italic">You can try to add the previously highlighted line of code but remove it afterwards!</em></p>
			<p>This <a id="_idIndexMarker593"/>represents a violation of responsibilities <a id="_idIndexMarker594"/>within the Presentation layer: the UI layer shouldn't perform presentation logic. In other words, the UI layer shouldn't be able to mutate its own state that is stored inside the <code>ViewModel</code>; instead, only the <code>ViewModel</code> should have the right to do so.</p>
			<p>This way, the <code>ViewModel</code> is the only entity responsible for presentation logic such as defining or mutating the UI state. At the same time, the responsibilities within our presentation patterns would be properly divided and respected.</p>
			<p>To fix this, we must somehow force the <code>RestaurantsViewModel</code> class to expose a public <code>state</code> variable of type <code>State</code> instead of <code>MutableState</code>. This will prevent the UI layer from accidentally mutating its own state.</p>
			<p>We can do this by having the Kotlin <code>state</code> variable. This<a id="_idIndexMarker595"/> feature states that if a class has two properties that are conceptually the same, yet one of them is part of the public API and the other one is an implementation detail, we can use an underscore to prefix the private property.</p>
			<p>Let's see what thi<a id="_idTextAnchor282"/>s means by applying it directly in code, as follows:</p>
			<ol>
				<li value="1">First, within the <code>RestaurantsViewModel</code> class, let's prevent our <code>state</code> variable from being accessed because it's of type <code>MutableState</code>, as follows:<pre>class RestaurantsViewModel() : ViewModel() {
    …
    <strong class="bold">private</strong> val state = mutableStateOf(…)
    …
}</pre></li>
				<li>Then, still in the <code>RestaurantsViewModel</code> class, rename the <code>state</code> variable <code>_state</code>. You can do that by <a id="_idIndexMarker596"/>selecting the <code>state</code> variable, and then pressing <em class="italic">Shift</em> + <em class="italic">F6</em>. Make sure that all <a id="_idIndexMarker597"/>previous usages of <code>state</code> are now called <code>_state</code>. The code is illustrated in the following snippet:<pre>class RestaurantsViewModel() : ViewModel() {
    …
    private val <strong class="bold">_state</strong> = mutableStateOf(…)
    private val errorHandler =
        CoroutineExceptionHandler {
            …
            exception.printStackTrace()
            <strong class="bold">_state</strong>.value = <strong class="bold">_state</strong>.value.copy(…)
        }
    […]
    fun toggleFavorite(id: Int, oldValue: Boolean) {
        viewModelScope.launch(errorHandler) {
            val updatedRestaurants = …
            <strong class="bold">_state</strong>.value = <strong class="bold">_state</strong>.value.copy(…)
        }
    }
    private fun getRestaurants() {
        viewModelScope.launch(errorHandler) {
            val restaurants =
                repository.getAllRestaurants()
            <strong class="bold">_state</strong>.value = <strong class="bold">_state</strong>.value.copy(…)
        }
    }
}</pre></li>
			</ol>
			<p>The <code>_state</code> variable is now the private state of type <code>MutableState</code>, so it's the variable that we referred to as the implementation detail. This means that the <code>ViewModel</code> <a id="_idIndexMarker598"/>can mutate it, but it shouldn't <a id="_idIndexMarker599"/>be exposed to the outer world. Yet what should we expose to the UI layer?</p>
			<ol>
				<li value="3">Still inside the <code>RestaurantsViewModel</code>, create another <code>state</code> variable called <code>state</code> of type <code>State&lt;RestaurantsScreenState&gt;</code> and define its custom getter through the <code>get()</code> syntax, as follows: <pre>class RestaurantsViewMode<a id="_idTextAnchor283"/>l() : ViewModel() {
    …
    private val _state = mutableStateOf(...)
<strong class="bold">    val state: State&lt;RestaurantsScreenState&gt;</strong>
<strong class="bold">        get() = _state</strong>
    …
}</pre></li>
			</ol>
			<p>The <code>state</code> variable is now the public state of type <code>State</code> (so, it's part of the public API), and this means that when the UI layer will try to get its value, the <code>get()</code> syntax will be called and the content within the <code>_state</code> variable will be returned.</p>
			<p>Behind the scenes, the <code>_state</code> variable's type <code>MutableState</code> is downcasted to type <code>State</code> of the <code>state</code> variable. This means that composables won't be able to ever mutate the state within the <code>ViewModel</code>.</p>
			<p>Conceptually, both the <code>state</code> variable and the <code>_state</code> variable are the same, yet <code>state</code> is <a id="_idIndexMarker600"/>used as part of a public contract <a id="_idIndexMarker601"/>with the outside world (so that it can be consumed by the UI layer), and <code>_state</code> is used as an internal implementation detail (a <code>MutableState</code> object that can be updated by the <code>ViewModel</code>). </p>
			<ol>
				<li value="4">Finally, inside the <code>RestaurantsScreen()</code> composable, make sure that the <code>state</code> variable is consumed, like this:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    val viewModel: RestaurantsViewModel = viewModel()
    val state = viewModel.<strong class="bold">state</strong>.value
    Box(…) {…}
}</pre></li>
			</ol>
			<p>If you now try to mutate the <code>state</code> variable's value, as we did at the beginning of this section, then <a id="_idIndexMarker602"/>the <code>val</code> variable, as illustrated in the following code snippet:</p>
			<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    val viewModel: RestaurantsViewModel = viewModel()
    val state = viewModel.state.value
    Box(…) {…}
    viewModel.state.value = viewModel.state.value.copy(
        isLoading = false)
}</pre>
			<p>This<a id="_idIndexMarker603"/> effectively <a id="_idIndexMarker604"/>means that our UI can't mutate its own state by accident anymore.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">You can try to practice what we've learned in this section on the details screen of the Restaurants application.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor284"/>Summary</h1>
			<p>In this chapter, we had a first look at the SoC principle. We understood why we must split an application's responsibilities across several layers and explored how we can do that with the help of presentation design patterns.</p>
			<p>In the first part of this chapter, we had a quick look over the implementations for the most common presentation patterns in Android: MVC, MVP, and MVVM.</p>
			<p>After that, we established that MVVM might be an appropriate choice for our Compose-based Restaurants application. We understood in which layer each type of logic must reside, and then tried to achieve SoC as well as possible in our application.</p>
			<p>In the last part of this chapter, we noticed how easy it is for our UI layer to extend its responsibilities and start performing presentation logic by mutating the UI state within the <code>ViewModel</code>. To counter that, we learned how to better encapsulate the UI state by using backed properties.</p>
			<p>Let's continue our journey of improving our application's architecture in the next chapter where we will try to adopt some design decisions from the well-known Clean Architecture software design philosophy.</p>
		</div>
	</body></html>