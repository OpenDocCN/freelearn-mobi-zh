<html><head></head><body>
		<div id="_idContainer085">
			<h1 id="_idParaDest-101"><em class="italic"><a id="_idTextAnchor249"/>Chapter 7</em>: Introducing Presentation Patterns in Android</h1>
			<p>In this chapter, we're continuing our journey of exploring ways to architect Android applications. More precisely, we will be making sure that our applications split responsibilities correctly with the introduction of presentation patterns.</p>
			<p>In the first section, <em class="italic">Introducing MVC, MVP, and MVVM as presentation patterns</em>, we will provide a short overview on why we need presentation patterns, and we will explore how most common patterns are implemented in Android projects.</p>
			<p>Next up, in the <em class="italic">Refactoring our Restaurants App to fit a presentation pattern</em> section, we will refactor our Restaurants App to fit the MVVM presentation pattern, while also understanding why MVVM is best suited for our Compose-based app.</p>
			<p>In the last section, <em class="italic">Improving state encapsulation in ViewModel</em>, we will see why it's important for the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) state to be properly encapsulated inside the <strong class="source-inline">ViewModel</strong>, and we will explore how to achieve that. </p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>), <strong class="bold">Model-View-Presenter</strong> (<strong class="bold">MVP</strong>), and <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) as presentation patterns</li>
				<li>Refactoring our Restaurants app to a presentation pattern</li>
				<li>Improving state encapsulation in ViewModel</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor250"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds, but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio.</li>
				<li>The Restaurants app code from the previous chapter.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants app developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_06</strong> directory of the repository and importing the Android project entitled <strong class="source-inline">chapter_6_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_07</strong> directory at <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_07/chapter_7_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_07/chapter_7_restaurants_app</a>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor251"/>Introducing MVC, MVP, and MVVM as presentation patterns</h1>
			<p>In the beginning, most Android projects were designed as a bunch of <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> classes <a id="_idIndexMarker519"/>that were setting content to their <a id="_idIndexMarker520"/>corresponding <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>) layouts.</p>
			<p>As projects grew and new features were requested, developers had to add more logic inside the <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> class, development cycle after development cycle. This means that anything from a new feature, improvement, or bug fix for a particular screen would have to be done inside those <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> classes.</p>
			<p>After some time, these classes became larger and larger, and at some point, adding an improvement or fixing a bug could become a nightmare. The reason for this would be that the <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> classes were burdened with all the responsibilities from within a particular project. These classes would be doing the following:</p>
			<ul>
				<li>Defining the UI</li>
				<li>Preparing the data to be displayed and defining different UI states</li>
				<li>Obtaining data from different sources</li>
				<li>Applying different business rules to data</li>
			</ul>
			<p><em class="italic">This approach introduces coupling between distinct responsibilities and concerns of a project</em>. For such projects, if—for example—a portion of the UI must be changed, your changes could <a id="_idIndexMarker521"/>easily impact other concerns of the app: the way data is presented, the logic of obtaining that data, business rules, and so on.</p>
			<p>The worst part of this happening is that when you need to change only a part (say, part of the UI) and you end up changing other parts (say, the presentation, or data logic) you risk breaking unrelated things that worked, therefore possibly introducing new bugs.</p>
			<p>Having such an approach where all the code of a project is bundled inside the <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> class, causes your <a id="_idIndexMarker522"/>project to develop the following issues:</p>
			<ul>
				<li><strong class="bold">Fragile and difficult to scale</strong>: Adding new features or improvements can break other parts of your app.</li>
				<li><strong class="bold">Difficult to test</strong>: Since all the logic of the app is bundled in one place, testing only one part of the logic is very difficult because all your logic is tangled and tied to platform-related dependencies.</li>
				<li><strong class="bold">Difficult to debug</strong>: When responsibilities are intertwined, then parts of your code base are also intertwined and coupled. Debugging one specific issue becomes extremely difficult because it's hard to track the exact culprit.</li>
			</ul>
			<p>To alleviate these issues, we can try to identify the core responsibilities of an app and then separate their corresponding logic and code into distinct components (or classes) that are part of specific layers. This way, we are trying to follow the principle of <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>), whereby <a id="_idIndexMarker523"/>each layer will contain classes whose responsibilities are tightly related only to their corresponding layer's concern.</p>
			<p>To make sure that our projects obey the SoC principle, we can split the app's responsibilities into two major ones and define a layer for each of them, as follows:</p>
			<ul>
				<li>The <strong class="bold">Presentation layer</strong> contains <a id="_idIndexMarker524"/>classes (or other components) responsible for defining the UI and preparing the data to be presented.</li>
				<li>The <strong class="bold">Model layer</strong> contains<a id="_idIndexMarker525"/> classes where the application's data is obtained, modeled, and updated.</li>
			</ul>
			<p>Even though the two layers seem to do more than one thing, all these actions define a broader dedicated responsibility that encapsulates a specific concern.</p>
			<p>In this chapter, while we will be mostly focusing on structuring the Presentation layer, we will also start working on the Model layer. We will continue refactoring the Model layer in <a href="B17788_08_ePub.xhtml#_idTextAnchor285"><em class="italic">Chapter 8</em></a>, <em class="italic">Getting Started with Clean Architecture in Android</em>.</p>
			<p>To separate concerns within the Presentation layer, you can make use of presentation design patterns. <strong class="bold">Presentation design patterns</strong> are <a id="_idIndexMarker526"/>architectural patterns that define how the Presentation layer is structured in our applications.</p>
			<p>The Presentation layer is <a id="_idIndexMarker527"/>a part of our project that is tied to what the user sees: the UI and the presentation of that UI. In other words, the Presentation layer handles two granular, yet related responsibilities associated with two types of logic, as outlined here:</p>
			<ul>
				<li><strong class="bold">UI logic</strong>: Defines <a id="_idIndexMarker528"/>the ability to display content on a device in a specific way for one screen or flow. For example, when building an XML layout or a composable hierarchy for a screen, we're defining the UI logic for that specific screen since we're defining its UI elements.</li>
				<li><strong class="bold">Presentation logic</strong>: The<a id="_idIndexMarker529"/> logic that defines the state of the UI (for one screen or flow) and how it mutates when the user interacts with our UI, therefore defining how the data is being presented to the UI. We're writing presentation logic when, for example, we must do the following:<ul><li>Ensure that the screen is in a loading state or error state at specific times</li><li>Present content for a screen in a specific manner by formatting it to some standards</li></ul></li>
			</ul>
			<p>For the Presentation layer to define UI logic and presentation logic, it needs some data to work with. That's why it must be connected to the Model layer, which provides it with raw data, be it from web services, local databases, or other sources. You can see an illustration of this in the following diagram:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B17788_07_1.jpg" alt="Figure 7.1 – Composition of the Presentation layer and its relation to the Model layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Composition of the Presentation layer and its relation to the Model layer</p>
			<p>For now, we will consider the Model layer a black box that just provides us with data.</p>
			<p>We <a id="_idIndexMarker530"/>can say that such separations allow the UI to become a representation of the model's data through transformations that happen inside the Presentation layer while having components whose responsibilities don't overlap.</p>
			<p>In Android, transformations from within the Presentation layer are modeled through three popular presentation patterns that are used in other technology stacks as well, as follows:</p>
			<ul>
				<li>MVC </li>
				<li>MVP </li>
				<li>MVVM <p class="callout-heading">Note</p><p class="callout">As Android developers, we have adjusted the implementation of these presentation patterns to the specific needs of Android. That's why the way we will exemplify or implement them may vary from their original definitions given by their founders—all this is in pursuit of observing their common usages in Android projects.</p></li>
			</ul>
			<p>These presentation patterns <a id="_idIndexMarker531"/>will allow us to separate UI logic from presentation logic for each screen or flow within our app. By doing so, we are ensuring that our Presentation layer has less coupled code that is easier to maintain, easier to scale with new features, and easier to test.</p>
			<p>Historically, most Android projects have transitioned from MVC to MVP and, nowadays, to MVVM. Regardless of their structure, though, it's important to mention that the SoC promoted by these presentation patterns often translates into each UI flow being broken into classes or components that are instructed to do something specific, tightly related to their responsibility.</p>
			<p>To see what I'm talking about, let's briefly cover them, starting out with MVC.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor252"/>MVC</h2>
			<p>A common implementation in<a id="_idIndexMarker532"/> Android projects of the MVC pattern defines<a id="_idIndexMarker533"/> its layers like so:</p>
			<ul>
				<li><strong class="bold">View</strong>: Views <a id="_idIndexMarker534"/>inflated from the XML layouts as a representation of the UI. This layer would only be rendering the content it receives from the Controller onto the screen.</li>
				<li><strong class="bold">Controller</strong>: UI <a id="_idIndexMarker535"/>controllers such as <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong>. This component would define the state of the UI by preparing data received from the Model layer for presentation, or by intercepting UI events that in turn would mutate the state. Additionally, the Controller would be in charge of setting actual data to the View layer.</li>
				<li><strong class="bold">Model</strong>: The <a id="_idIndexMarker536"/>entry point of data. The actual structure doesn't depend on MVC, but we can think of it as the layer that obtains content needed by the Presentation layer, by querying a local database or remote <a id="_idIndexMarker537"/>sources such as web <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>).</li>
			</ul>
			<p>Let's visualize the actual separation brought by this pattern, as follows:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B17788_07_2.jpg" alt="Figure 7.2 – Presentation layer in the MVC pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Presentation layer in the MVC pattern</p>
			<p>This implementation<a id="_idIndexMarker538"/> of the MVC pattern achieves a proper separation between the Presentation layer and the Model layer, therefore liberating <strong class="source-inline">Activity</strong> and <strong class="source-inline">Fragment</strong> controllers from being the ones that obtain data <a id="_idIndexMarker539"/>from <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) APIs or local databases. Yet at least in this form factor, MVC doesn't shine where it should because the actual separation within the Presentation layer could be improved.</p>
			<p>Disadvantages<a id="_idIndexMarker540"/> of this pattern may include the following:</p>
			<ul>
				<li>High coupling between the Controller (<strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> controllers) and the View layer. Since the Controller is a component with a lifecycle and it also must provide the infrastructure of building and setting up Android views with content (such as building <strong class="source-inline">Adapter</strong> classes and passing data), testing it becomes difficult because it's tightly coupled with Android APIs.</li>
				<li>The Controller has two responsibilities: it handles the state of the UI (presentation logic) while also providing infrastructure for the View layer to function (UI logic). The two responsibilities become tangled up—when testing one, you would be testing the other too.</li>
			</ul>
			<p>Let's move on to another popular presentation pattern in Android.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor253"/>MVP</h2>
			<p>A common implementation in Android<a id="_idIndexMarker541"/> projects of the MVP pattern defines its layers like so:</p>
			<ul>
				<li><strong class="bold">View</strong>: The <a id="_idIndexMarker542"/>UI layer defined by the <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> class and their corresponding inflated views from XML. This layer now encapsulates the entire UI logic: it provides the infrastructure of building and setting up rendered Android views with content.</li>
				<li><strong class="bold">Presenter</strong>: Presents <a id="_idIndexMarker543"/>data to the UI by manipulating the View layer indirectly through an interface. With this approach, a one-to-one relationship between a Presenter and a View layer (be it <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong>) is established. The interface allows the Presenter to pass data that is ready for presentation to the UI layer and to directly mutate the UI state at the UI level.</li>
			</ul>
			<p>Unlike the Controller in MVC, the Presenter is no longer coupled to lifecycle components or Android View APIs, so it becomes much easier to test the presentation logic that it contains.</p>
			<ul>
				<li><strong class="bold">Model</strong>: The same <a id="_idIndexMarker544"/>as in MVC.</li>
			</ul>
			<p>Let's visualize the actual separation brought by this pattern, as follows:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B17788_07_3.jpg" alt="Figure 7.3 – Presentation layer in the MVP pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Presentation layer in the MVP pattern</p>
			<p>Unlike MVC, <strong class="source-inline">Activity</strong> and <strong class="source-inline">Fragment</strong> are now part of the View layer, which seems more natural because they are both tightly related to the Android UI. This approach allows the Presenter to be the one that prepares data that must be presented, while imperatively mutating the UI.</p>
			<p>Since we now have a separate entity that is in charge of presenting data to the UI, we can say that, unlike MVC, MVP performs the SoC inside the Presentation layer somewhat better.</p>
			<p>However, there are still<a id="_idIndexMarker545"/> some issues with this approach, as outlined here:</p>
			<ul>
				<li>The imperative approach of having the Presenter manually update the UI directly in the <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> class can be prone to bugs and can cause illegal UI states (such as showing an error message and a loading status at the same time) as a project grows and new features are added. This is similar to how a UI controller (such as <strong class="source-inline">Activity</strong>) also imperatively mutates XML views—an approach that we deemed as prone to issues when we introduced Compose with its declarative paradigm.</li>
				<li>If the interface contract between the Presenter and the View layer is not well designed or is missing entirely, the two would become coupled, and reusing the Presenter for other <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> controllers might be difficult.</li>
			</ul>
			<p>Let's move on to another important presentation pattern.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor254"/>MVVM</h2>
			<p>MVVM is a <a id="_idIndexMarker546"/>very popular presentation pattern in Android, mostly because it addresses the concerns stated with the previously mentioned implementation of MVP.</p>
			<p>A common implementation<a id="_idIndexMarker547"/> in Android projects of MVVM defines its layers like so:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B17788_07_4.jpg" alt="Figure 7.4 – Presentation layer in the MVVM pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Presentation layer in the MVVM pattern</p>
			<p>Let's look at how the layers are defined:</p>
			<ul>
				<li><strong class="bold">View</strong>: The UI layer<a id="_idIndexMarker548"/> is the <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> class and its XML views, just as in MVP. Unlike in MVP, though, the View layer observes either an observable state or observable fields from the <strong class="source-inline">ViewModel</strong>, both containing UI data. Whenever new updates are received from those observable entities, the View layer updates the UI with the content received.</li>
				<li><strong class="bold">ViewModel</strong>: This <a id="_idIndexMarker549"/>prepares the data received from the Model layer, just as the Presenter in MVP did. Unlike the Presenter, though, the <strong class="source-inline">ViewModel</strong> defines the UI state as an observable property (or multiple observable fields) and is totally decoupled from the View layer as it has no reference to it.</li>
				<li><strong class="bold">Model</strong>: The same <a id="_idIndexMarker550"/>as in MVC or MVP.</li>
			</ul>
			<p>One advantage of the <strong class="source-inline">ViewModel</strong>, as opposed to the Presenter in MVP, is that it's no longer <a id="_idIndexMarker551"/>coupled to the View layer, so it can be reused much more easily. In contrast with MVP, the View layer is responsible for referencing the <strong class="source-inline">ViewModel</strong> for obtaining and observing the observable state, and so the <strong class="source-inline">ViewModel</strong> no longer needs to reference the View layer, becoming totally independent. </p>
			<p>In other words, the <strong class="source-inline">ViewModel</strong> in MVVM forces the View layer to subscribe to data, which is different from MVP, where the Presenter was manually setting up the View layer with data. This approach allows multiple Views to bind to the same <strong class="source-inline">ViewModel</strong>, therefore <em class="italic">sharing</em> the same UI state within the same <strong class="source-inline">ViewModel</strong>.</p>
			<p>Another advantage is<a id="_idIndexMarker552"/> that since the View layer observes the UI state from the <strong class="source-inline">ViewModel</strong> and binds the received data as an effect, the <strong class="source-inline">ViewModel</strong> doesn't imperatively update the UI as the Presenter did through an interface in MVP. In other words, the View layer obtains the UI state from the <strong class="source-inline">ViewModel</strong> and binds it to the UI—this results in a unidirectional flow of data that is less likely to introduce bugs or illegal states.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While considering the original definition of MVVM, the ViewModel shouldn't be confused with the Jetpack ViewModel component—the ViewModel can be a simple class that presents the data through an observable state. For us on Android, though, it's convenient to consider the Jetpack ViewModel as the actual ViewModel from MVVM because it brings some advantages out of the box.</p>
			<p>However, the pattern's implementation <a id="_idIndexMarker553"/>that is commonly used in Android considers the Jetpack ViewModel as the ViewModel from MVVM, and this brings both a set of advantages and disadvantages.</p>
			<p>Using the<a id="_idIndexMarker554"/> Jetpack ViewModel as the <strong class="source-inline">ViewModel</strong> from MVVM is beneficial for the following reasons:</p>
			<ul>
				<li>The Jetpack ViewModel is scoped to the lifetime of the View and provides convenient APIs for canceling work such as the <strong class="source-inline">onCleared()</strong> callback or the <strong class="source-inline">viewModelScope</strong> coroutine scope, therefore providing a convenient API for canceling asynchronous jobs and minimizing the risk of memory leaks.</li>
				<li>The Jetpack ViewModel survives configuration changes, therefore allowing you to preserve the UI state automatically if the user changes the orientation of the device, for example.</li>
				<li>You can easily restore the UI state after system-initiated process death because the Jetpack ViewModel is providing us with a <strong class="source-inline">SavedStateHandle</strong> object.</li>
			</ul>
			<p>Unfortunately, this approach <a id="_idIndexMarker555"/>comes with the following downsides:</p>
			<ul>
				<li>The <strong class="source-inline">ViewModel</strong> is now a library dependency (the Jetpack ViewModel) that introduces coupling with the Android platform (as it exposes APIs such as <strong class="source-inline">SavedStateHandle</strong>). This prevents us from reusing presentation components for cross-platform projects <a id="_idIndexMarker556"/>with <strong class="bold">Kotlin Multiplatform</strong> (<strong class="bold">KMP</strong>).</li>
				<li>Because the Jetpack ViewModel is a library dependency that handles other responsibilities apart from data presentation, such as restoring the UI state after system-initiated process death, we could argue that the Presentation layer concerns are not very well separated.</li>
			</ul>
			<p>Now that we have had a quick overview of presentation patterns, it's time for a practical example.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor255"/>Refactoring our Restaurants app to fit a presentation pattern</h1>
			<p>We plan to <a id="_idIndexMarker557"/>refactor our Restaurants app to fit a presentation pattern. From our previous comparison, we can consider<a id="_idIndexMarker558"/> that MVVM is best suited for our Compose-based app. Don't worry—we will talk about this decision in more detail a bit later.</p>
			<p>But before we do that, let's add more functionality inside the application to better highlight how mingling responsibilities can lead to unmaintainable code.</p>
			<p>To summarize, in this section, we're going to be doing the following:</p>
			<ul>
				<li>Adding more functionality inside our Restaurants app</li>
				<li>Refactoring our Restaurants app to MVVM</li>
			</ul>
			<p>Let's begin!</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor256"/>Adding more functionality inside our Restaurants app</h2>
			<p>When the <a id="_idIndexMarker559"/>Restaurants application is launched, the <strong class="source-inline">RestaurantsScreen()</strong> composable is rendered. Inside this screen, we are loading a bunch of restaurants from the server, and then we're displaying them to the user.</p>
			<p>Yet while our app waits for the network request to finish and for the local caching to Room to happen (in order for it to receive restaurants for the UI), the screen remains blank, and the user has no idea what's going on. To provide a better <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>), we should<a id="_idIndexMarker560"/> somehow suggest to the user the fact that we're waiting for content from the server.</p>
			<p>We could do that through a loading progress bar! Inside the <strong class="source-inline">RestaurantsScreen()</strong> composable, we could add a loading UI element that is displayed until the <strong class="source-inline">LazyColumn</strong> composable that renders a list of restaurants is populated. When the content arrives, we should hide it, thereby letting the user know that the application has loaded its content.</p>
			<p>Let's do that right now, as follows:</p>
			<ol>
				<li>First, inside the <strong class="source-inline">RestaurantsScreen()</strong> composable, save the restaurant list from the state (retrieved from <strong class="source-inline">RestaurantsViewModel</strong>) inside a <strong class="source-inline">restaurants</strong> variable, like this:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    val viewModel: R<a id="_idTextAnchor257"/>estaurantsViewModel = viewModel()</p><p class="source-code">    <strong class="bold">val restaurants = viewModel.state.value</strong></p><p class="source-code">    LazyColumn(…){</p><p class="source-code">        items(<strong class="bold">restaurants</strong>) { restaurant -&gt;</p><p class="source-code">            RestaurantItem(…)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Make sure to also pass the <strong class="source-inline">restaurants</strong> variable<a id="_idIndexMarker561"/> to the <strong class="source-inline">LazyColumn</strong> composable's <strong class="source-inline">items</strong> <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) function.</p>
			<ol>
				<li value="2">We need<a id="_idIndexMarker562"/> to define a condition that lets us know when to show a loading indicator. As a first attempt, we could say that when the <strong class="source-inline">restaurants</strong> variable contains an empty <strong class="source-inline">List&lt;Restaurant&gt;</strong> as a value, which means that restaurants haven't arrived yet, the content is still loading. Add an <strong class="source-inline">isLoading</strong> variable that accounts for this, as follows:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code">    val <a id="_idTextAnchor258"/>restaurants = viewModel.state.value</p><p class="source-code">    <strong class="bold">val isLoading = restaurants.isEmpty()</strong></p><p class="source-code">    LazyColumn(…){ … }</p><p class="source-code">}</p></li>
			</ol>
			<p>If, however, restaurants arrive from the server, the <strong class="source-inline">state</strong> variable is updated, and the <strong class="source-inline">restaurants</strong> variable no longer contains an empty list of restaurants. At this point, the <strong class="source-inline">isLoading</strong> variable becomes <strong class="source-inline">false</strong>.</p>
			<ol>
				<li value="3">We want t<a id="_idTextAnchor259"/>o display a loading indicator while the <strong class="source-inline">isLoading</strong> variable is <strong class="source-inline">true</strong>. To do that, wrap the <strong class="source-inline">LazyColumn</strong> composable in a <strong class="source-inline">Box</strong> composable, and below the <strong class="source-inline">LazyColumn</strong> code, check if th<a id="_idTextAnchor260"/>e <strong class="source-inline">isLoading</strong> variable is <strong class="source-inline">true</strong> and pass a <strong class="source-inline">CircularProgressIndicator</strong> composable. The code is illustrated in the <a id="_idIndexMarker563"/>following snippet:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    …</p><p class="source-code">    v<a id="_idTextAnchor261"/>al isLoading = restaurants.isEmpty()</p><p class="source-code">    <a id="_idTextAnchor262"/><strong class="bold">Box() {</strong></p><p class="source-code">        LazyColumn(…){…}</p><p class="source-code"><strong class="bold">        if(isLoading)</strong></p><p class="source-code"><strong class="bold">            CircularProgressIndicator()</strong></p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">Box</strong> composable allows us to overlay two composables: <strong class="source-inline">LazyColumn</strong> and <strong class="source-inline">CircularProgressIndicator</strong>. Because of the <strong class="source-inline">if</strong> condition that we've added, we now have the following two cases:</p>
			<ul>
				<li><strong class="source-inline">isLoading</strong> is <strong class="source-inline">true</strong> (the app is waiting for restaurants), so both composables are composed. While the <strong class="source-inline">CircularProgressIndicator</strong> composable is displayed on top of the <strong class="source-inline">LazyColumn</strong> composable, the <strong class="source-inline">LazyColumn</strong> composable contains no elements, so it's not visible.</li>
				<li><strong class="source-inline">isLoading</strong> is <strong class="source-inline">false</strong> (the app now has restaurants to display), so only the <strong class="source-inline">LazyColumn</strong> composable is composed and visible.</li>
			</ul>
			<ol>
				<li value="4">To center the <strong class="source-inline">CircularProgressIndicator</strong> composable, add the <strong class="source-inline">Alignment.Center</strong> alignment to the <strong class="source-inline">contentAlignment</strong> parameter of the <strong class="source-inline">Box</strong> composable, while also passing a <strong class="source-inline">Modifier.fillMaxSize()</strong> modifier. The <a id="_idIndexMarker564"/>code is illustrated in the following snippet:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    …</p><p class="source-code">    Box(<strong class="bold">contentAlignment = Alignment.Center</strong>,</p><p class="source-code"><strong class="bold">        modifier = Modifier.fillMaxSize()</strong>) {</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Build and run the app. For a moment (until restaurants are loaded), you should see a loading progress indicator. When restaurants are displayed, this should go away.</li>
			</ol>
			<p>Inside the UI layer, we have now added a loading indicator as well as the logic that decides when to display it. In this simple scenario, our logic works, but what happens if the server (or local database) returns an empty list of restaurants? Then the loading indicator will never go away.</p>
			<p>Or, what happens if an error occurs? Our <strong class="source-inline">RestaurantsScreen</strong> composable has no idea that an error was generated. This means that not only does it not know when to display the error, but it also doesn't know when to hide the loading indicator if such an error were to occur.</p>
			<p>These issues arise from the fact that we're trying to define presentation logic (when to show or hide a loading indicator; when to show an error message) inside the UI layer (where composables reside), thereby mixing UI logic with presentation logic.</p>
			<p>We can now see just some limitations that derive from mixing UI logic with presentation logic, yet there's also the fact that in the previous chapters, we've mixed the presentation logic with <a id="_idIndexMarker565"/>the data logic. The long-term implications for our current approach are scary: debugging will be difficult, and testing even more so.</p>
			<p>It's time to refactor our Restaurants app to MVVM so that we can better separate its responsibilities.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor263"/>Refactoring our Restaurants app to MVVM</h2>
			<p>To better<a id="_idIndexMarker566"/> separate responsibilities, we will choose the most popular presentation pattern: MVVM. Despite its flaws, when you compare it to MVC and <a id="_idIndexMarker567"/>MVP following the definition we previously gave them, it's the best candidate so far for the following reasons:</p>
			<ul>
				<li>It provides a pretty good separation between the UI logic and the presentation logic.</li>
				<li>Our UI layer (the composables) is designed to expect an observable state (more precisely, the Compose <strong class="source-inline">State</strong> object), just like the one the <strong class="source-inline">ViewModel</strong> in MVVM is set to expose.</li>
			</ul>
			<p>Now, our Restaurants app already uses the Jetpack ViewModel (that exposes a Compose <strong class="source-inline">State</strong> object that is observed and consumed inside the composables), so we can say that we unknowingly started implementing this modified version of the pattern, whereby the Jetpack ViewModel is the ViewModel from MVVM.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will consider for now that the advantages of using the Jetpack ViewModel as the <strong class="source-inline">ViewModel</strong> in MVVM are outweighing the disadvantages that it brings, so we will keep it as it is.</p>
			<p>However, just because we used a <strong class="source-inline">ViewModel</strong>, that doesn't mean we also implemented the MVVM presentation pattern correctly. Let's first have a look at how we structured our components and classes for the first screen displaying a list of restaurants. You can see how this looks here:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B17788_07_5.jpg" alt="Figure 7.5 – Components with poorly separated responsibilities per layer in the MVVM pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Components with poorly separated responsibilities per layer in the MVVM pattern</p>
			<p>For this<a id="_idIndexMarker568"/> screen, we notice two violations where layers<a id="_idIndexMarker569"/> contain more than one responsibility, as outlined here:</p>
			<ul>
				<li>The View layer (represented by the <strong class="source-inline">RestaurantsScreen()</strong> composable) performs both UI logic and presentation logic. While this composable should only contain UI logic (the stateless composables that consume the state content), some presentation logic lurked in when the <strong class="source-inline">isLoading</strong> variable was calculated, as illustrated in the following code snippet:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    …</p><p class="source-code">    val isLoading = restaurants.isEmpty()</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ul>
			<p>The composables shouldn't be in charge of deciding their own state as in this case—the <strong class="source-inline">RestaurantsScreen()</strong> composable shouldn't hold presentation logic; instead, this should be moved inside the <strong class="source-inline">ViewModel</strong>.</p>
			<ul>
				<li>The <strong class="source-inline">RestaurantsViewModel</strong> class contains both presentation logic (such as holding and updating the state of the UI) and data logic (as it works with the Retrofit service <a id="_idIndexMarker570"/>Room <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) when it<a id="_idIndexMarker571"/> obtains and caches restaurants), as illustrated in the following code snippet:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">    private var restInterface: RestaurantsApiService</p><p class="source-code">    private var restaurantsDao = ...</p><p class="source-code">    val state = mutableStateOf(emptyList&lt;Restaurant&gt;())</p><p class="source-code">    private suspend fun getAllRestaurants(): … {…}</p><p class="source-code">        ...</p><p class="source-code">    private suspend fun refreshCache() {...}</p><p class="source-code">}</p></li>
			</ul>
			<p>It's clear <a id="_idIndexMarker572"/>that presentation logic occurs when the <strong class="source-inline">state</strong> variable is updated, but there's also a lot of data logic when restaurants are obtained from the <strong class="source-inline">restInterface</strong> variable, then cached and updated in the <strong class="source-inline">restaurantsDao</strong> variable, and so on.</p>
			<p>All this data logic shouldn't reside inside the <strong class="source-inline">ViewModel</strong> but instead inside the Model layer because the <strong class="source-inline">ViewModel</strong> should only present the data and not care to know about the data sources and how they are used—it only knows that it should receive some data.</p>
			<p>Now, let's have a look at how we should correctly structure our classes (to follow MVVM) for the first flow of displaying a list of restaurants. The components should look like this:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B17788_07_6.jpg" alt="Figure 7.6 – Components with well-separated responsibilities per layer in the MVVM pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Components with well-separated responsibilities per layer in the MVVM pattern</p>
			<p>In the <a id="_idIndexMarker573"/>previous diagram, each component handles its own <a id="_idIndexMarker574"/>responsibility, as follows:</p>
			<ul>
				<li>The View component contains only composables (<strong class="source-inline">RestaurantsScreen</strong>) with UI logic (consuming the UI state).</li>
				<li>The ViewModel component (<strong class="source-inline">RestaurantsViewModel</strong>) contains only presentation logic (holds the UI state and mutates it).</li>
				<li>The Model component (where we will create a <strong class="source-inline">RestaurantsRepository</strong> class—more on that soon) contains only data logic (obtains restaurants from remote sources, caches them into a local source, and so on).</li>
			</ul>
			<p>To achieve this separation, in this section, we will be doing the following:</p>
			<ul>
				<li>Separating UI logic from presentation logic</li>
				<li>Separating presentation logic from data logic</li>
			</ul>
			<p>Let's start!</p>
			<h3>Separating UI logic from presentation logic</h3>
			<p>The <a id="_idIndexMarker575"/>UI logic (rendering composables) is already at the UI level (Compose UI), so we don't have to do anything from this point of view. However, we need to extract the presentation logic from the UI layer to the <strong class="source-inline">ViewModel</strong>, where it should reside.</p>
			<p>More specifically, from within the <strong class="source-inline">RestaurantsScreen()</strong> composable, we want to move the calculation of the <strong class="source-inline">isLoading</strong> variable to the <strong class="source-inline">RestaurantsViewModel</strong> class, simply because the <strong class="source-inline">ViewModel</strong> should decide and also know better when the screen should be in a loading state.</p>
			<p>To do that, we<a id="_idIndexMarker576"/> will create a <strong class="source-inline">state</strong> class that will hold all the information the UI needs in order to render the correct state. This approach is much more efficient because the <strong class="source-inline">ViewModel</strong> is responsible for requesting data and therefore knows better when content arrives, and so on. Because of this, later on, it will be very simple for us to also allow the <strong class="source-inline">ViewModel</strong> to also dictate when the screen must show an error state. Proceed as follows:</p>
			<ol>
				<li value="1">Create a class that will model the UI state for the <strong class="source-inline">RestaurantsScreen()</strong> composable. Do that by clicking on the application packag<a id="_idTextAnchor264"/>e, selecting <strong class="bold">New</strong>, and then <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RestaurantsScreenState</strong> as the name and select <strong class="bold">Data class</strong> as the type. Inside the new file, add fields that define this screen's state, a <strong class="source-inline">restaurants</strong> list, and an <strong class="source-inline">isLoading</strong> flag<a id="_idTextAnchor265"/>. The code is illustrated in the following snippet:<p class="source-code">data class RestaurantsScreenState(</p><p class="source-code">    val restaurants: List&lt;Restaurant&gt;,</p><p class="source-code">    val isLoading: Boolean)</p></li>
			</ol>
			<p>Since we've used a <strong class="source-inline">data class</strong> instead of a regular <strong class="source-inline">class</strong>, we will be able to easily perform mutation on this object with the <strong class="source-inline">.copy()</strong> function, thereby ensuring that since the Compose <strong class="source-inline">state</strong> object will receive a new object, it will know to trigger recomposition.</p>
			<ol>
				<li value="2">Inside the <strong class="source-inline">RestaurantsViewModel</strong> class, update the initial state value of the <strong class="source-inline">state</strong> variable and pass a <strong class="source-inline">RestaurantsScreenState</strong> object, as follows:<p class="source-code">class RestaurantsViewModel() : ViewMode<a id="_idTextAnchor266"/>l() {</p><p class="source-code">    …</p><p class="source-code">    val state = mutableStateOf(</p><p class="source-code"><strong class="bold">        RestaurantsScreenState(</strong></p><p class="source-code"><strong class="bold">            restaurants = listOf(),</strong></p><p class="source-code"><strong class="bold">            isLoading = true)</strong></p><p class="source-code">    )</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>We've marked the <strong class="source-inline">restaurants</strong> field as an empty list, and <strong class="source-inline">isLoading</strong> is <strong class="source-inline">true</strong> because from this point on, we're waiting for restaurants and the UI should render a loading state.</p>
			<ol>
				<li value="3">Still inside<a id="_idIndexMarker577"/> the <strong class="source-inline">RestaurantsViewModel</strong> class, find the <strong class="source-inline">getRestaurants()</strong> method and update the way we update the <strong class="source-inline">state</strong> variable, as follows:<p class="source-code">private fun getRestaurants(<a id="_idTextAnchor267"/>) {</p><p class="source-code">    viewModelSco<a id="_idTextAnchor268"/>pe.launch(errorHandler) {</p><p class="source-code">        <strong class="bold">val restaurants = </strong>getAllRestaurants()</p><p class="source-code">        <strong class="bold">state.value = state.value.copy(</strong></p><p class="source-code"><strong class="bold">            restaurants = restaurants,</strong></p><p class="source-code"><strong class="bold">            isLoading = false)</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>We first stored restaurants inside a <strong class="source-inline">restaurants</strong> variable. Then, we used the <strong class="source-inline">copy()</strong> function to pass a new restaurants list that we received to the <strong class="source-inline">restaurants</strong> field, and also marked the <strong class="source-inline">isLoading</strong> field to <strong class="source-inline">false</strong> because the data has arrived and the UI should no longer render a loading state.</p>
			<ol>
				<li value="4">Still i<a id="_idTextAnchor269"/>n the <strong class="source-inline">RestaurantsViewModel</strong> class, make sure that the <strong class="source-inline">toggleFavorite()</strong> method is correctly updating the <strong class="source-inline">state</strong> variable object using the <strong class="source-inline">copy()</strong> function, as follows:<p class="source-code">fun toggleFavorite(id: Int, oldValue: Boolean) {</p><p class="source-code">    viewModelScope.launch(errorHan<a id="_idTextAnchor270"/>dler) {</p><p class="source-code">        val updatedRestaurants = […]</p><p class="source-code">        <strong class="bold">state.value = state.value.copy(restaurants =</strong>      </p><p class="source-code">            <strong class="bold">updatedRestaurants)</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>All right—we've added all the presentation logic within the <strong class="source-inline">ViewModel</strong>, and it's now time to update the UI (our composables) to render new possible UI states.</p>
			<ol>
				<li value="5">Refactor<a id="_idIndexMarker578"/> the <strong class="source-inline">RestaurantsScreen()</strong> composable to consume the new UI state content, as follows:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    <a id="_idTextAnchor271"/>val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code">    <strong class="bold">val state = viewModel.state.value</strong></p><p class="source-code">  <a id="_idTextAnchor272"/>  Box(…) {</p><p class="source-code">        LazyColumn(…) {</p><p class="source-code">             i<a id="_idTextAnchor273"/>tems(<strong class="bold">state.restaurants</strong>) {…}</p><p class="source-code">        }</p><p class="source-code">        if (<strong class="bold">state.isLoading</strong>)</p><p class="source-code">            CircularProgressIndicator()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Let's break down what we've done, as follows:</p>
			<ul>
				<li>We renamed the <strong class="source-inline">restaurants</strong> variable as <strong class="source-inline">state</strong> to better suggest that this variable holds the state of this screen.</li>
				<li>We passed <strong class="source-inline">state.restaurants</strong> to the <strong class="source-inline">LazyColumn</strong> composable's <strong class="source-inline">items</strong> DSL function.</li>
				<li>We deleted this line: <strong class="source-inline">val isLoading = restaurants.isEmpty()</strong>.</li>
				<li>We updated the condition for when to show <strong class="source-inline">CircularProgressIndicator()</strong> based on the <strong class="source-inline">state.isLoading</strong> value—no more decision-making logic inside this composable.</li>
			</ul>
			<ol>
				<li value="6">Build and run the app. </li>
			</ol>
			<p>You should<a id="_idIndexMarker579"/> be able to see the loading indicator, just as before, yet the difference is that the presentation logic is better separated and held by the <strong class="source-inline">ViewModel</strong>. With our new approach, if for any reason we receive an empty list from our data sources (Retrofit and Room), the application won't misbehave and show a loading state because the UI is checking whether the list is empty or not.</p>
			<p>To see how simple it is to add a new state to our Compose-based UI, let's continue by setting an error state when any error is thrown inside the <strong class="source-inline">View<a id="_idTextAnchor274"/>Model</strong>.</p>
			<ol>
				<li value="7">Inside the <strong class="source-inline">RestaurantsScreenState</strong> class, add an <strong class="source-inline">error: String</strong> parameter that will hold an error message if any error occurs, as follows:<p class="source-code">data class RestaurantsScreenState(</p><p class="source-code">    val restaura<a id="_idTextAnchor275"/>nts: List&lt;Restaurant&gt;,</p><p class="source-code">    val isLoading: Boolean,</p><p class="source-code"><strong class="bold">    val error: String? = null</strong></p><p class="source-code">)</p></li>
			</ol>
			<p>To simplify our work with state handling inside the <strong class="source-inline">ViewModel</strong>, we've set a default value of <strong class="source-inline">null</strong> to the <strong class="source-inline">error</strong> field, since the initial state of <a id="_idTextAnchor276"/>the screen shouldn't ever contain an error.</p>
			<ol>
				<li value="8">Inside<a id="_idIndexMarker580"/> the <strong class="source-inline">RestaurantsViewModel</strong> class, find the <strong class="source-inline">errorHandler</strong> variable that we use to catch any exception that might be thrown by our coroutines, and update the <strong class="source-inline">state</strong> object by passing an <strong class="source-inline">exception.message</strong> error message to the <strong class="source-inline">error</strong> field. The code is illustrated in the following snippet:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    private val errorHandler =</p><p class="source-code">        CoroutineExceptionHandler { _, exception -&gt;</p><p class="source-code">            exception.printStackTrace()</p><p class="source-code">            <strong class="bold">state.value = state.value.copy(</strong></p><p class="source-code"><strong class="bold">                error = exception.message,</strong></p><p class="source-code"><strong class="bold">                isLoading = false</strong></p><p class="source-code"><strong class="bold">            )</strong></p><p class="source-code">        }</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>Additionally, we've set the <strong class="source-inline">isLoading</strong> field to <strong class="source-inline">false</strong> on the new state simply because if an error is thrown, we don't want the UI to be in a loading state.</p>
			<p>If, however, you want to add a retry button that is pressed after an error has occurred and was shown, you would have to set the <strong class="source-inline">error</strong> field to <strong class="source-inline">null</strong> when that button is pressed so that the UI won't remain in an error state indefinitely.</p>
			<ol>
				<li value="9">Inside the <strong class="source-inline">RestaurantsScreen()</strong> composable, add another <strong class="source-inline">if</strong> statement in the <strong class="source-inline">Box</strong> composable. This statement checks whether the <strong class="source-inline">state</strong> object contains an<a id="_idIndexMarker581"/> error message to be shown, and if that is <strong class="source-inline">true</strong>, add a <strong class="source-inline">Text</strong> composable that will display the error message. The code is illustrated in the following snippet:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    …</p><p class="source-code">    Box(…) {</p><p class="source-code">        LazyColumn(...) {…}</p><p class="source-code">        if (state.is<a id="_idTextAnchor277"/>Loading)</p><p class="source-code">            CircularProgressIndicator()</p><p class="source-code">        <strong class="bold">if (state.error != null)</strong></p><p class="source-code"><strong class="bold">            Text(state.error)</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Build the project, and now, let's test the error scenario. Yet to see the error message, we need to simulate an error.</li>
			</ol>
			<p>If you remember, inside our <strong class="source-inline">RestaurantsViewModel</strong> class's <strong class="source-inline">getAllRestaurants()</strong> method, we check if we failed in retrieving restaurants from the server (Retrofit client), and if this happens while the Room DAO is also empty, we throw this error message: <strong class="source-inline">"Something went wrong. We have no data."</strong>. </p>
			<p>To reproduce this scenario, make sure that the following applies:</p>
			<ul>
				<li>You have cleared the cache of the application. To do that, inside your device or emulator, go to <strong class="bold">Settings</strong>, then <strong class="bold">Applications</strong>, and search for our Restaurants app and press on it. Then, press <strong class="bold">Storage and Cache</strong> and then <strong class="bold">Clear Storage</strong>.</li>
				<li>Your device/emulator is disconnected from the internet.</li>
			</ul>
			<ol>
				<li value="11">Run the <a id="_idIndexMarker582"/>application. You should see this message in the center of the screen: <strong class="source-inline">"Something went wrong. We have no data."</strong>.<p class="callout-heading">Note</p><p class="callout">For the sake of simplicity, we made sure that the UI logic is separated from the presentation logic only within the first screen of our app. When you're looking to move logic to corresponding classes, thereby ensuring SoC, you need to make sure to do so for all other screens within the app, together with their <strong class="source-inline">ViewModel</strong> classes, and so on.</p></li>
			</ol>
			<p>Now that we've separated UI logic from presentation logic, it's time to separate some data logic.</p>
			<h3>Separating presentation logic from data logic</h3>
			<p>While the <strong class="source-inline">RestaurantsViewModel</strong> class contains data logic because it interacts with the<a id="_idIndexMarker583"/> Retrofit service and the Room DAO to obtain and cache restaurants, it should only hold presentation logic because its core responsibility is to govern the UI state.</p>
			<p>Another sign that our <strong class="source-inline">RestaurantsViewModel</strong> has piled up a lot of logic is that it currently stands at around 90 lines of code—this might not seem much yet, remember that our application is pretty simple and we have little presentation logic, so 90 lines will definitely turn into thousands for production-ready applications.</p>
			<p>We want to move the data logic out of the <strong class="source-inline">RestaurantsViewModel</strong> into a different class. Since data logic is part of the Model layer of our application, in this section, we will start exploring how to define the Model layer with the help of Repository classes.</p>
			<p>The <strong class="bold">Repository</strong> pattern<a id="_idIndexMarker584"/> represents a strategy for abstracting data access inside your application. In other words, Repository classes hide away from the caller all the complexity associated with parsing data from the server, storing it in local databases, or performing any caching/refreshing mechanisms.</p>
			<p>In our app, the <strong class="source-inline">RestaurantsViewModel</strong> class must decide whether to get data from the <strong class="source-inline">restInterface</strong> (remote) source or from the <strong class="source-inline">restaurantsDao</strong> (local) source, while also making sure to refresh the cache. The following snippet shows the code that<a id="_idIndexMarker585"/> is executed:</p>
			<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p>
			<p class="source-code">    private var restInterface: RestaurantsApiService</p>
			<p class="source-code">    private var restaurantsDao = [...]</p>
			<p class="source-code">        ...</p>
			<p class="source-code">    private suspend fun refreshCache() {...}</p>
			<p class="source-code">}</p>
			<p>This is obviously wrong. The <strong class="source-inline">ViewModel</strong> shouldn't care which particular data source to call as it shouldn't need to be the one that initiates caching to local sources. The <strong class="source-inline">ViewModel</strong> should only care about receiving some content that it will prepare for presentation.</p>
			<p>Let's lift this burden from the <strong class="source-inline">RestaurantsViewModel</strong> class by creating a Repository class that will abstract all the data logic, as it will be interacting with the two data sources (web API and Room DAO) to do the following:</p>
			<ul>
				<li>Provide a <strong class="source-inline">List&lt;Restaurant&gt;</strong> object to the Presentation layer</li>
				<li>Handle any caching logic such as retrieving restaurants from the web API and caching them to the Room local database</li>
				<li>Define<a id="_idIndexMarker586"/> a <strong class="bold">single source of truth</strong> (<strong class="bold">SSOT</strong>) for data—the Room database</li>
			</ul>
			<p>To do that, we must only move the data logic out of the <strong class="source-inline">ViewModel</strong> and separate it in a Repository class. Let's begin, as follows:</p>
			<ol>
				<li value="1">Create a Repository class by clicking on the applicat<a id="_idTextAnchor278"/>ion package, selecting <strong class="bold">New</strong>, and then <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RestaurantsRepository</strong> as the name and select <strong class="bold">Class</strong> as the type:<p class="source-code">class RestaurantsRepository { }</p></li>
			</ol>
			<p>Now, let's start moving some code!</p>
			<ol>
				<li value="2">From <a id="_idIndexMarker587"/>inside the <strong class="source-inline">RestaurantsViewModel</strong> class, cut the <strong class="source-inline">restInterface</strong> variable and its initialization logic from the <strong class="source-inline">init</strong> block and paste it inside <strong class="source-inline">Restaur<a id="_idTextAnchor279"/>antsRepository</strong>, as follows: <p class="source-code">class RestaurantsRepository {</p><p class="source-code">    <strong class="bold">private var restInterface: RestaurantsApiService =</strong></p><p class="source-code">        <strong class="bold">Retrofit.Builder()</strong></p><p class="source-code">            .<strong class="bold">addConverterFactory(…)</strong></p><p class="source-code">            <strong class="bold">.baseUrl(…)</strong></p><p class="source-code">            <strong class="bold">.build()</strong></p><p class="source-code">            <strong class="bold">.create(RestaurantsApiService::class.java)</strong></p><p class="source-code">}</p></li>
				<li>Do the same for the <strong class="source-inline">restaurantsDao</strong> variable, as follows:<p class="source-code">class RestaurantsRepository {</p><p class="source-code">    private var restInterface: RestaurantsApiService = …</p><p class="source-code"><strong class="bold">    private var restaurantsDao = RestaurantsDb</strong></p><p class="source-code"><strong class="bold">        .getDaoInstance(</strong></p><p class="source-code"><strong class="bold">            RestaurantsApplication.getAppContext())</strong></p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">RestaurantsViewModel</strong> class, add a <strong class="source-inline">repository</strong> variable and instantiate it with the <strong class="source-inline">RestaurantsRepository()</strong> constructo<a id="_idTextAnchor280"/>r, like this:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">    <strong class="bold">private val repository = RestaurantsRepository()</strong></p><p class="source-code">    val state = mutableStateOf(…)</p><p class="source-code">    private val errorHandler = CoroutineExceptionHandler { … } </p><p class="source-code">    init {</p><p class="source-code">        getRestaurants()</p><p class="source-code">    }</p><p class="source-code">     […]</p><p class="source-code">}</p></li>
			</ol>
			<p>Make sure that the <strong class="source-inline">RestaurantsViewModel</strong> no longer contains the <strong class="source-inline">restInterface</strong> variable, the <strong class="source-inline">restaurantsDao</strong> variable, or their initialization code from within the <strong class="source-inline">init</strong> block.</p>
			<ol>
				<li value="5">Move<a id="_idIndexMarker588"/> the <strong class="source-inline">toggleFavoriteRestaurant()</strong>,  <strong class="source-inline">getAllRestaurants()</strong>, and <strong class="source-inline">refreshCache()</strong> methods of the <strong class="source-inline">RestaurantsViewModel</strong> class to the <strong class="source-inline">RestaurantsRepository</strong> class, as follows:<p class="source-code">class RestaurantsRepository {</p><p class="source-code">    private var restInterface: RestaurantsApiService = …</p><p class="source-code">    private var restaurantsDao = […]</p><p class="source-code"><strong class="bold">    private suspend fun toggleFavoriteRestaurant(…) = […]</strong></p><p class="source-code"><strong class="bold">    private suspend fun getAllRestaurants(): […] { … }</strong></p><p class="source-code"><strong class="bold">    private suspend fun refreshCache() { … }</strong></p><p class="source-code">}</p></li>
				<li>Make sure that apart from the <strong class="source-inline">init { }</strong> block, the <strong class="source-inline">RestaurantsViewModel</strong> class only contains the <strong class="source-inline">toggleFavorite()</strong> and <strong class="source-inline">getRestaurants()</strong> methods, as follows:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">    […]</p><p class="source-code">    init { getRestaurants() }</p><p class="source-code">    fun toggleFavorite(id: Int, oldValue: Boolean) {…}</p><p class="source-code">    private fun getRestaurants() {…}</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">RestaurantsRepository</strong> class, remove the <strong class="source-inline">private</strong> modifier for the <strong class="source-inline">getAllRestaurants()</strong> and <strong class="source-inline">toggleFavoriteRestaurant()</strong> methods as <strong class="source-inline">RestaurantsViewModel</strong> will need to call them, so they must be <a id="_idIndexMarker589"/>public. The code is illustrated in the following snippet:<p class="source-code">class RestaurantsRepository {</p><p class="source-code">    […]</p><p class="source-code">    <strong class="bold">suspend fun toggleFavoriteRestaurant(…)</strong> = […]</p><p class="source-code">    <strong class="bold">suspend fun getAllRestaurants():</strong> […] { … }</p><p class="source-code">    private suspend fun refreshCache() { … }</p><p class="source-code">}</p></li>
				<li>Going back inside the <strong class="source-inline">RestaurantsViewModel</strong> class, update the <strong class="source-inline">getRestaurants()</strong> method to now call <strong class="source-inline">repository.getAllRestaurants()</strong>, as follows:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        val restaurants = <strong class="bold">repository.</strong>getAllRestaurants()</p><p class="source-code">        state.value = state.value.copy(…)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Still inside the <strong class="source-inline">RestaurantsViewModel</strong> class, update the <strong class="source-inline">toggleFavorite()</strong> method<a id="_idIndexMarker590"/> to now call <strong class="source-inline">repository.toggleFavoriteRestaurant()</strong>, as follows:<p class="source-code">fun toggleFavorite(id: Int, oldValue: Boolean) {</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        val updatedRestaurants = <strong class="bold">repository</strong></p><p class="source-code">            .toggleFavoriteRestaurant(id, oldValue)</p><p class="source-code">        state.value = state.value.copy(…)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>And we're done! While the functionality of the first screen should stay the same, we have now divided the responsibilities within this first flow not only within the Presentation layer but also between the Presentation layer and the Model layer.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">You can try to practice what we've learned in this section on the details screen of the Restaurants application.</p>
			<p>Next up, let's return for a while to the Presentation layer and inspect how the UI state is exposed from within our <strong class="source-inline">ViewModel</strong>.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor281"/>Improving state encapsulation in ViewModel</h1>
			<p>Let's <a id="_idIndexMarker591"/>have a look at how the UI state is defined in<a id="_idIndexMarker592"/> the <strong class="source-inline">RestaurantsViewModel</strong> class, as follows:</p>
			<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    val state = mutableStateOf(RestaurantsScreenState(</p>
			<p class="source-code">        restaurants = listOf(),</p>
			<p class="source-code">        isLoading = true))</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>Inside the <strong class="source-inline">RestaurantsViewModel</strong>, we are holding the state within the <strong class="source-inline">state</strong> variable with the <strong class="source-inline">MutableState&lt;RestaurantsScreenState&gt;</strong> inferred type. This variable is public, so inside the UI layer, from within the <strong class="source-inline">RestaurantsScreen()</strong> composable, we can consume it by accessing the <strong class="source-inline">viewModel</strong> variable and directly obtaining the <strong class="source-inline">state</strong> object, as follows:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p>
			<p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p>
			<p class="source-code">    val state = viewModel.state.value</p>
			<p class="source-code">    Box(…) {…}</p>
			<p class="source-code">}</p>
			<p>The problem with this approach might not be obvious, but since the <strong class="source-inline">state</strong> variable is of type <strong class="source-inline">MutableState</strong>, not only can we read its value but we can also write its value. In other words, from within the composable UI layer, we have write access to the <strong class="source-inline">state</strong> variable through the <strong class="source-inline">.value</strong> accessor.</p>
			<p>The danger here is that then we (or other colleagues within our development team) could mistakenly update the UI state from within the UI layer, like so:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p>
			<p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p>
			<p class="source-code">    val state = viewModel.state.value</p>
			<p class="source-code">    Box(…) {…}</p>
			<p class="source-code"><strong class="bold">    viewModel.state.value = viewModel.state.value.copy(</strong></p>
			<p class="source-code"><strong class="bold">        isLoading = false)</strong></p>
			<p class="source-code">}</p>
			<p><em class="italic">You can try to add the previously highlighted line of code but remove it afterwards!</em></p>
			<p>This <a id="_idIndexMarker593"/>represents a violation of responsibilities <a id="_idIndexMarker594"/>within the Presentation layer: the UI layer shouldn't perform presentation logic. In other words, the UI layer shouldn't be able to mutate its own state that is stored inside the <strong class="source-inline">ViewModel</strong>; instead, only the <strong class="source-inline">ViewModel</strong> should have the right to do so.</p>
			<p>This way, the <strong class="source-inline">ViewModel</strong> is the only entity responsible for presentation logic such as defining or mutating the UI state. At the same time, the responsibilities within our presentation patterns would be properly divided and respected.</p>
			<p>To fix this, we must somehow force the <strong class="source-inline">RestaurantsViewModel</strong> class to expose a public <strong class="source-inline">state</strong> variable of type <strong class="source-inline">State</strong> instead of <strong class="source-inline">MutableState</strong>. This will prevent the UI layer from accidentally mutating its own state.</p>
			<p>We can do this by having the Kotlin <strong class="bold">backing property</strong> feature implemented for our <strong class="source-inline">state</strong> variable. This<a id="_idIndexMarker595"/> feature states that if a class has two properties that are conceptually the same, yet one of them is part of the public API and the other one is an implementation detail, we can use an underscore to prefix the private property.</p>
			<p>Let's see what thi<a id="_idTextAnchor282"/>s means by applying it directly in code, as follows:</p>
			<ol>
				<li value="1">First, within the <strong class="source-inline">RestaurantsViewModel</strong> class, let's prevent our <strong class="source-inline">state</strong> variable from being accessed because it's of type <strong class="source-inline">MutableState</strong>, as follows:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    <strong class="bold">private</strong> val state = mutableStateOf(…)</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>Then, still in the <strong class="source-inline">RestaurantsViewModel</strong> class, rename the <strong class="source-inline">state</strong> variable <strong class="source-inline">_state</strong>. You can do that by <a id="_idIndexMarker596"/>selecting the <strong class="source-inline">state</strong> variable, and then pressing <em class="italic">Shift</em> + <em class="italic">F6</em>. Make sure that all <a id="_idIndexMarker597"/>previous usages of <strong class="source-inline">state</strong> are now called <strong class="source-inline">_state</strong>. The code is illustrated in the following snippet:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    private val <strong class="bold">_state</strong> = mutableStateOf(…)</p><p class="source-code">    private val errorHandler =</p><p class="source-code">        CoroutineExceptionHandler {</p><p class="source-code">            …</p><p class="source-code">            exception.printStackTrace()</p><p class="source-code">            <strong class="bold">_state</strong>.value = <strong class="bold">_state</strong>.value.copy(…)</p><p class="source-code">        }</p><p class="source-code">    […]</p><p class="source-code">    fun toggleFavorite(id: Int, oldValue: Boolean) {</p><p class="source-code">        viewModelScope.launch(errorHandler) {</p><p class="source-code">            val updatedRestaurants = …</p><p class="source-code">            <strong class="bold">_state</strong>.value = <strong class="bold">_state</strong>.value.copy(…)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    private fun getRestaurants() {</p><p class="source-code">        viewModelScope.launch(errorHandler) {</p><p class="source-code">            val restaurants =</p><p class="source-code">                repository.getAllRestaurants()</p><p class="source-code">            <strong class="bold">_state</strong>.value = <strong class="bold">_state</strong>.value.copy(…)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">_state</strong> variable is now the private state of type <strong class="source-inline">MutableState</strong>, so it's the variable that we referred to as the implementation detail. This means that the <strong class="source-inline">ViewModel</strong> <a id="_idIndexMarker598"/>can mutate it, but it shouldn't <a id="_idIndexMarker599"/>be exposed to the outer world. Yet what should we expose to the UI layer?</p>
			<ol>
				<li value="3">Still inside the <strong class="source-inline">RestaurantsViewModel</strong>, create another <strong class="source-inline">state</strong> variable called <strong class="source-inline">state</strong> of type <strong class="source-inline">State&lt;RestaurantsScreenState&gt;</strong> and define its custom getter through the <strong class="source-inline">get()</strong> syntax, as follows: <p class="source-code">class RestaurantsViewMode<a id="_idTextAnchor283"/>l() : ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    private val _state = mutableStateOf(...)</p><p class="source-code"><strong class="bold">    val state: State&lt;RestaurantsScreenState&gt;</strong></p><p class="source-code"><strong class="bold">        get() = _state</strong></p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">state</strong> variable is now the public state of type <strong class="source-inline">State</strong> (so, it's part of the public API), and this means that when the UI layer will try to get its value, the <strong class="source-inline">get()</strong> syntax will be called and the content within the <strong class="source-inline">_state</strong> variable will be returned.</p>
			<p>Behind the scenes, the <strong class="source-inline">_state</strong> variable's type <strong class="source-inline">MutableState</strong> is downcasted to type <strong class="source-inline">State</strong> of the <strong class="source-inline">state</strong> variable. This means that composables won't be able to ever mutate the state within the <strong class="source-inline">ViewModel</strong>.</p>
			<p>Conceptually, both the <strong class="source-inline">state</strong> variable and the <strong class="source-inline">_state</strong> variable are the same, yet <strong class="source-inline">state</strong> is <a id="_idIndexMarker600"/>used as part of a public contract <a id="_idIndexMarker601"/>with the outside world (so that it can be consumed by the UI layer), and <strong class="source-inline">_state</strong> is used as an internal implementation detail (a <strong class="source-inline">MutableState</strong> object that can be updated by the <strong class="source-inline">ViewModel</strong>). </p>
			<ol>
				<li value="4">Finally, inside the <strong class="source-inline">RestaurantsScreen()</strong> composable, make sure that the <strong class="source-inline">state</strong> variable is consumed, like this:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code">    val state = viewModel.<strong class="bold">state</strong>.value</p><p class="source-code">    Box(…) {…}</p><p class="source-code">}</p></li>
			</ol>
			<p>If you now try to mutate the <strong class="source-inline">state</strong> variable's value, as we did at the beginning of this section, then <a id="_idIndexMarker602"/>the <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) will show you a compilation error telling you that you need to reassign a <strong class="source-inline">val</strong> variable, as illustrated in the following code snippet:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p>
			<p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p>
			<p class="source-code">    val state = viewModel.state.value</p>
			<p class="source-code">    Box(…) {…}</p>
			<p class="source-code">    viewModel.state.value = viewModel.state.value.copy(</p>
			<p class="source-code">        isLoading = false)</p>
			<p class="source-code">}</p>
			<p>This<a id="_idIndexMarker603"/> effectively <a id="_idIndexMarker604"/>means that our UI can't mutate its own state by accident anymore.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">You can try to practice what we've learned in this section on the details screen of the Restaurants application.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor284"/>Summary</h1>
			<p>In this chapter, we had a first look at the SoC principle. We understood why we must split an application's responsibilities across several layers and explored how we can do that with the help of presentation design patterns.</p>
			<p>In the first part of this chapter, we had a quick look over the implementations for the most common presentation patterns in Android: MVC, MVP, and MVVM.</p>
			<p>After that, we established that MVVM might be an appropriate choice for our Compose-based Restaurants application. We understood in which layer each type of logic must reside, and then tried to achieve SoC as well as possible in our application.</p>
			<p>In the last part of this chapter, we noticed how easy it is for our UI layer to extend its responsibilities and start performing presentation logic by mutating the UI state within the <strong class="source-inline">ViewModel</strong>. To counter that, we learned how to better encapsulate the UI state by using backed properties.</p>
			<p>Let's continue our journey of improving our application's architecture in the next chapter where we will try to adopt some design decisions from the well-known Clean Architecture software design philosophy.</p>
		</div>
	</body></html>