<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Scenes in Sprite Kit"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Scenes in Sprite Kit</h1></div></div></div><p>The <span class="emphasis"><em>Hello World</em></span> game, made in the previous chapter. was the first step to Sprite Kit. We also made acquaintance with the Swift programming language, which we are going to use for iOS game development using Sprite Kit.</p><p>In this chapter, we will dive deep into various fundamentals of the Sprite Kit project and also discuss in depth about scenes in a game. We are further going to continue the development of the game, <span class="emphasis"><em>Platformer</em></span>, and use it as a tool to learn Sprite Kit. We will be learning about different auto generated files in an Xcode project and about their importance. Only then will we be able to understand what scenes are, and their importance in game development. Further we will also learn how nodes play an important part in Sprite Kit and help us to improve optimization and control of our game. In this chapter, we will also learn how to add more than one scene in our game and successfully transit from one scene to another along with animating various transition effects.</p><p>We will be learning all of this and testing our progress with development of the game <span class="emphasis"><em>Platformer</em></span>, so that by the end of the book, you are able make your own 2D game from scratch. Let's get going!</p><div class="section" title="Device orientation in Sprite Kit"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Device orientation in Sprite Kit</h1></div></div></div><p>There <a id="id48" class="indexterm"/>are two types of <a id="id49" class="indexterm"/>modes, namely portrait and landscape; you can select the desired orientation for your game while setting up your project. Any time during the development of your game, you can change the orientation under the properties section of your Sprite Kit project. There are four types of orientations available:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Portrait</li><li class="listitem" style="list-style-type: disc">Upside Down</li><li class="listitem" style="list-style-type: disc">Landscape Left</li><li class="listitem" style="list-style-type: disc">Landscape Right</li></ul></div><p>You can <a id="id50" class="indexterm"/>select any of the orientations depending on your game. If <a id="id51" class="indexterm"/>you want to make your game scene in portrait mode, you can select either <span class="strong"><strong>Portrait</strong></span> or <span class="strong"><strong>Upside Down</strong></span> options. If want to make your game in landscape mode, you can select the <span class="strong"><strong>Landscape Left</strong></span> or <span class="strong"><strong>Landscape Right</strong></span> option. If you want to make your game in both portrait and landscape, then you can select both the options too. Caution, if you want to make your game in both portrait and landscape mode, make sure that you have to handle the positions of sprites in your game during runtime.</p></div></div>
<div class="section" title="Orientation in our project"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Orientation in our project</h1></div></div></div><p>As we are<a id="id52" class="indexterm"/> making a <span class="emphasis"><em>Platformer</em></span> game, it's better to opt for landscape mode. Although <a id="id53" class="indexterm"/>you can select both <span class="strong"><strong>Landscape Left</strong></span> and <span class="strong"><strong>Landscape Right</strong></span>, it is better to opt for one orientation for easier programming. Following are the steps to do the same:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Launch the <code class="literal">Platformer</code> project that we made in the last chapter, either by double-clicking <code class="literal">Platformer.xcodeproj</code> from the directory of project, or from your Xcode.</li><li class="listitem">Click on the <span class="strong"><strong>Project Navigator</strong></span> and then click <span class="strong"><strong>Platformer</strong></span>, which is just under it, on the left panel.</li><li class="listitem">Untick the <span class="strong"><strong>Portrait</strong></span> checkbox and tick <span class="strong"><strong>Landscape Left</strong></span> under the <span class="strong"><strong>Device Orientation</strong></span> section:<div class="mediaobject"><img src="graphics/B04201_02_01.jpg" alt="Orientation in our project"/></div></li></ol></div></div>
<div class="section" title="Revisiting project elements"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Revisiting project elements</h1></div></div></div><p>Now we are going to <a id="id54" class="indexterm"/>discuss about some auto-generated files in your Sprite Kit project. They can be found on the left panel in your Xcode.</p><div class="section" title="AppDelegate.swift"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>AppDelegate.swift</h2></div></div></div><p>This file is an entry point <a id="id55" class="indexterm"/>file to our game. Its existence is crucial when the game goes<a id="id56" class="indexterm"/> from an active state to inactive state (or background state), in simple terms, when there are some sorts of temporary interruptions (such as incoming phone calls or SMS messages), or when the user force quits the application. The essence of this file in a project comes when you have to perform any specific task between the transition of active and inactive states, such as saving game data when the game is moving into a background state due to a phone call.</p></div><div class="section" title="GameScene.sks"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>GameScene.sks</h2></div></div></div><p>This file is a<a id="id57" class="indexterm"/> static archive<a id="id58" class="indexterm"/> of your scene's content. This file presents a view in your editor, it is used to save static content of a game such as spawning the position of a player, level ending position, and so on. The main essence and importance of this file is that it has worked towards helping you to separate the dynamic and static part of a game. Now a developer does not <a id="id59" class="indexterm"/>need to write extra lines of code for specifying trivial elements of a<a id="id60" class="indexterm"/> game such as spawning position, and so on.</p></div><div class="section" title="GameScene.swift"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>GameScene.swift</h2></div></div></div><p>This file contains the <code class="literal">GameScene</code> class <a id="id61" class="indexterm"/>which is a type of <code class="literal">SKScene</code>. An <code class="literal">SKScene</code> class object is used to <a id="id62" class="indexterm"/>make a scene in a game. When we developed the "Hello World" sample game in the previous chapter, the logic part was present inside this file.</p></div><div class="section" title="GameViewController.swift"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>GameViewController.swift</h2></div></div></div><p>When a game starts, a default <a id="id63" class="indexterm"/>view is <a id="id64" class="indexterm"/>added to the game, which is controlled by the game view controller. If the user wants to add scenes to the game, then it is added on top of the view.</p></div><div class="section" title="Main.storyboard"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Main.storyboard</h2></div></div></div><p>This is responsible for displaying <a id="id65" class="indexterm"/>content on the screen. A storyboard with a view controller <a id="id66" class="indexterm"/>whose view is set to <code class="literal">SKView</code> is created, the scene then displays the content of the Sprite Kit game. You can create additional view controllers and storyboards along with applying transition between them.</p></div><div class="section" title="LaunchScreen.xib"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>LaunchScreen.xib</h2></div></div></div><p>New projects are created with this <a id="id67" class="indexterm"/>launch screen file. The Launch Screen uses size classes to adapt to different screen sizes and orientations.</p></div></div>
<div class="section" title="Adjusting the project"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Adjusting the project</h1></div></div></div><p>We are going to make some <a id="id68" class="indexterm"/>adjustments in the already-created project called <code class="literal">Platformer</code>. Please follow the steps listed, in order to customize the project according to our needs:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Delete the <code class="literal">GameScene.swift</code> and <code class="literal">GameScene.sks</code> files present in your project. We will be recreating these files as per our need. Don't worry about the error, we are going to fix it in the next step. <code class="literal">GameScene.swift</code> is the default scene given by Xcode; we are deleting the default ones as we are going to create the menu Scene before the game scene. Take a look at the next screenshot:<div class="mediaobject"><img src="graphics/B04201_02_02.jpg" alt="Adjusting the project"/></div></li><li class="listitem">Open<a id="id69" class="indexterm"/> <code class="literal">GameViewController.swift</code> and delete the code, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/B04201_02_03.jpg" alt="Adjusting the project"/></div></li><li class="listitem">Delete the <span class="strong"><strong>Spaceship</strong></span> image from <code class="literal">Images.xcassets</code>. Spaceship images are not required in this project.</li></ol></div><p>Now you will not see an error in your Xcode, and if you run <code class="literal">Platformer</code>, you will see nothing. Well, that is not what we desire. Now, before getting your feet wet in code, we need to know what <a id="id70" class="indexterm"/>we have done (almost nothing but deleting) so far:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Extension SKNode</strong></span>: This extension is inserted by Sprite Kit presuming that every game must have an initial scene, creating a GameScene.sks file. We do not need this initial scene at the start of our <span class="emphasis"><em>Platformer</em></span> game, as we will create our own menu screen on start.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>If statement within viewDidLoad</strong></span>: As <code class="literal">GameScene.sks</code> file created by extension <code class="literal">SKNode</code> is used in this statement.</li></ul></div><p>Now we are going to create our own custom scene for this game, but before that, let's now see what a scene really is.</p></div>
<div class="section" title="What is a scene?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>What is a scene?</h1></div></div></div><p>A scene <a id="id71" class="indexterm"/>is basically a collection of different elements such as sprites, sounds, and so on, in a logical way. Suppose we want to make a menu, we'll have to put some buttons, background, and sounds in a manner that is positioned according to our needs.</p><p>A <code class="literal">Scene</code> object is a collection of nodes, but a scene itself acts as a node. Imagine a tree of nodes having scene objects as its root. As all nodes in the scene are positioned in defined coordinates, their linkage can be shown as:</p><p>
<span class="emphasis"><em>Node (Content) → Descendant Node</em></span>
</p><p>This linkage of a node with its descendant(s) is very useful. Say, if you rotate a node on the top of the tree, all the nodes will be subsequently rotated.</p><p>In technical terms, <code class="literal">Scene</code> is an <code class="literal">SKScene</code> object, which holds an <code class="literal">SKNode</code> object (such as <code class="literal">SKSpriteNode</code> objects for sprites) inside a view (<code class="literal">SKView</code> object), so that we can render and use them. Scene is itself an <code class="literal">SKNode</code> object, which acts as a root node and attaches in an <code class="literal">SKView</code> object. Other objects required for that scene are added to this node as a child node. A scene runs different kinds of actions and simulates physics (if required), and then renders the node tree. A game consists of many scenes, and we can make as many scenes required by sub-classing <code class="literal">SKScene</code> class. An <code class="literal">SKView</code> object is required to display a scene.</p></div>
<div class="section" title="Coordinate system"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Coordinate system</h1></div></div></div><p>Everything in a game built in Sprite Kit is<a id="id72" class="indexterm"/> related to nodes, and it follows a node tree structure where a scene is a root node and other nodes are child nodes of it. When we put a node in the node tree, it uses its position property to place it within the coordinate system provided by its parent.</p><p>As a scene is also a node, it is placed inside the view provided by the <code class="literal">SKView</code> object. The code part which we deleted in <code class="literal">viewDidLoad</code>, <code class="literal">GameScene</code>, was added as a child in the <code class="literal">SKView</code> object. A scene uses its parent <code class="literal">SKView</code> object coordination system to render itself and the content within it. The coordinate system is the same as we learned in basic mathematics.</p><div class="mediaobject"><img src="graphics/B04201_02_04.jpg" alt="Coordinate system"/></div><p>As the preceding diagram shows, if we move right from <span class="strong"><strong>(0,0)</strong></span>, then <span class="strong"><strong>x</strong></span> will be positive, and negative if we move left from <span class="strong"><strong>(0,0)</strong></span>. If we move up from <span class="strong"><strong>(0,0)</strong></span>, then <span class="strong"><strong>y</strong></span> will be positive, and negative if we move down from <span class="strong"><strong>(0,0)</strong></span>. Coordinate values are measured in points and when the scene is rendered, it will be converted to pixels.</p><p>All the nodes in Sprite Kit will not draw the content. For example, <code class="literal">SKSpriteNode</code> is used to draw sprites in a game, but <code class="literal">SKNode</code> class does not draw anything as <code class="literal">SKNode</code> is a fundamental building <a id="id73" class="indexterm"/>block for most Sprite Kit content.</p></div>
<div class="section" title="Creating a scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Creating a scene</h1></div></div></div><p>When we create a scene, we <a id="id74" class="indexterm"/>can define many of its properties such as size, origin, and so on. as we require in our game. A scene size defines the visible area in the <a id="id75" class="indexterm"/>
<span class="strong"><strong>SKView</strong></span> object. Of course, we can put nodes outside this area, but they will be totally ignored by the renderer.</p><p>However, if we try to change the position property of a scene, it will be ignored by Sprite Kit because a scene is a root node in a node tree, its default value is <code class="literal">CGPointZero</code>. But we can move scene origin by the <code class="literal">anchorPoint</code> property. Default value for <code class="literal">anchorPoint</code> is <code class="literal">(0.5,0.5)</code>, which indicates the center point of the screen. By reassigning a new <code class="literal">anchorPoint</code> property, we can change the coordinate system for its child. For example, if we set <code class="literal">anchorPoint</code> to <code class="literal">(0,0)</code>, the child node of the scene will start from the bottom left of the scene.</p><p>If we make the <code class="literal">anchorPoint (0.5, 0.5)</code> or the middle of the screen, the child node of the scene will start from the middle of the screen. It totally depends on us and what <code class="literal">anchorPoint</code> we choose as per our requirement.</p></div>
<div class="section" title="Creating a node tree"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Creating a node tree</h1></div></div></div><p>A node tree<a id="id76" class="indexterm"/> for a scene is created as a parent child relation. As a scene acts similar to a root node, another node acts as a child to it. Following are some common methods used to make a node tree:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">addChild</code>: It adds a node to the end of the receiver's list of child nodes</li><li class="listitem" style="list-style-type: disc"><code class="literal">insertChild:atIndex</code>: It inserts a child at a specific position in the receiver's list of child nodes</li></ul></div><p>If you want to remove a node from a node tree, you can use the following method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">removeFromParent</code>: It removes the receiving node from its parent</li></ul></div></div>
<div class="section" title="Drawing order for a node tree"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Drawing order for a node tree</h1></div></div></div><p>When a node <a id="id77" class="indexterm"/>tree renders, all its children also render. First, the <a id="id78" class="indexterm"/>parent is rendered, and then, its children, in the order they are added to parent. If you have many nodes to render in a scene, it is a difficult task to maintain them in order. For this, Sprite Kit provides a solution using the <span class="emphasis"><em>z</em></span> position. You can set nodes to the <span class="emphasis"><em>z</em></span> position by using the <code class="literal">zPosition</code> property.</p><p>When you take the z position into account, the node tree will be rendered as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First of all, each node's global <span class="emphasis"><em>z</em></span> position is calculated</li><li class="listitem" style="list-style-type: disc">Then, nodes are drawn in order from smallest <span class="emphasis"><em>z</em></span> value to largest <span class="emphasis"><em>z</em></span> value</li><li class="listitem" style="list-style-type: disc">If two nodes share the same z value, ancestors are rendered first, and siblings are rendered in child order</li></ul></div><p>As you've just seen, Sprite Kit uses a deterministic rendering order, based on the height nodes and their positions in the node tree. But, because the rendering order is so deterministic, Sprite Kit may be unable to apply some rendering optimizations that it might otherwise apply. For example, it might be better if Sprite Kit could gather all of the nodes that share the same texture and drawing mode and draw them with a single drawing pass. To enable these sorts of optimizations, you have to set the view's <code class="literal">ignoresSiblingOrder</code> property to <code class="literal">true</code>.</p><p>When you ignore sibling order, Sprite Kit uses the graphics hardware to render the nodes so that they appear in z-axis order. It sorts nodes into a drawing order that reduces the number of draw calls needed to render the scene. But with this optimized drawing order, you cannot predict the rendering order for nodes that share the same z-axis index. The rendering order may change each time a new frame is rendered. In many cases, the drawing order of these nodes is not important. For example, if the nodes are at the same height but do not overlap on screen, they can be drawn in any order.</p><p>So, we can use node tree-based rendering or depth-based rendering, just by setting the <code class="literal">ignoresSiblingOrder</code> property to <code class="literal">false</code> or <code class="literal">true</code>. If we set it to true, we can set z position, but if set to false, we have to be careful about sequence when adding child node to parent node.</p><p>Following is a depiction of node-based rendering (parent child rendering):</p><div class="mediaobject"><img src="graphics/B04201_02_05.jpg" alt="Drawing order for a node tree"/></div><p>Next is a depiction of <a id="id79" class="indexterm"/>depth-based <a id="id80" class="indexterm"/>rendering (z position-based rendering):</p><div class="mediaobject"><img src="graphics/B04201_02_06.jpg" alt="Drawing order for a node tree"/></div></div>
<div class="section" title="Adding the first scene in our game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Adding the first scene in our game</h1></div></div></div><p>Now it is time to add a <a id="id81" class="indexterm"/>menu scene to our game. For this, select the <code class="literal">Platformer</code> <a id="id82" class="indexterm"/>folder and right-click on this folder, select <span class="strong"><strong>New File</strong></span>. Select <span class="strong"><strong>iOS</strong></span> | <span class="strong"><strong>Source</strong></span> | <span class="strong"><strong>Swift File</strong></span> and then <span class="strong"><strong>Next</strong></span>. Inside <span class="strong"><strong>Save As</strong></span>, give it the name <code class="literal">MenuScene</code>, and click on <span class="strong"><strong>Create</strong></span>.</p><p>Click on your <code class="literal">MenuScene.swift</code> file. Now it's time to do some code stuff:</p><div class="informalexample"><pre class="programlisting">import SpriteKit
class MenuScene: SKScene
{
  //#1
  let PlayButton: SKSpriteNode
  let Background: SKSpriteNode
  //#2
  init(size:CGSize, playbutton:String, background:String)
  {
    PlayButton = SKSpriteNode(imageNamed: playbutton)
    Background = SKSpriteNode(imageNamed: background)
    super.init(size:size)
  }
  //#3
  required init?(coder aDecoder: NSCoder)
  {
    fatalError("init(coder:) has not been implemented")
  }
  //#4
  override func didMoveToView(view: SKView)
  {
    addChildToScene();

  }
  //#5
  func addChildToScene()
  {
    PlayButton.zPosition = 1
    Background.zPosition = 0
    Background.size = CGSize(width:self.size.width, height:self.size.height)
    addChild(PlayButton)
    addChild(Background)
  }
  //#6
  override func update(currentTime: NSTimeInterval) {

  }
}</pre></div><p>In the preceding code, we <a id="id83" class="indexterm"/>created a class <code class="literal">MenuScene</code> type of <code class="literal">SKScene</code>. <code class="literal">SKScene</code> is a <a id="id84" class="indexterm"/>class used to create scene. Let's look out for some terminology used in this code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <code class="literal">#1</code> code block (refer to the preceding code), we define two <code class="literal">SKSpriteNode</code> references. One for play button and the other for background. The <code class="literal">let</code> keyword denotes that once we assign a value to this reference, we can't change it. If you want to change that, you should use the <code class="literal">var</code> keyword instead of <code class="literal">let</code>.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">#2</code> code block (refer to the preceding code), we define an initializer for this class. The initializer is used to create an instance of a particular type. Inside this, we initialize <code class="literal">PlayButton</code> and <code class="literal">Background</code>. We give background a full screen size by setting its <code class="literal">size</code> property. In the end, we call parent class <code class="literal">init</code> by <code class="literal">super.init</code>.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">#3</code> code block (refer to the preceding code), we remove errors at compile time. The required keyword denotes that every subclass of that class must implement that initializer.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">#4</code> code block (refer to the preceding code), we override its parent class method. The <code class="literal">didMoveToView</code> is called immediately after a scene is presented by a view. We have called our custom method <code class="literal">addChildToScene</code> here.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">#5</code> code <a id="id85" class="indexterm"/>block (refer to the preceding code), we define <a id="id86" class="indexterm"/>our <code class="literal">addChildToScene</code> method. Inside this we did nothing but give <code class="literal">z</code> position to <code class="literal">PlayButton</code> and defined <code class="literal">size</code> for <code class="literal">Background</code>. Remember, we can use <code class="literal">z</code> depth to control which layer will render above what. If you have <code class="literal">z</code> depth set to minimum, it will render first, and then to maximum. It means that the lower the <span class="emphasis"><em>z</em></span> depth, the lower it will be in a scene. That's why we put the <code class="literal">Background</code> <code class="literal">z</code> depth lower than <code class="literal">PlayButton</code>, so that <code class="literal">PlayButton</code> could render above <code class="literal">Background</code>. After that, we added <code class="literal">PlayButton</code> and <code class="literal">Background</code> to scene.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">#6</code> code block (refer to the preceding code), we just override the update method. The code for this method will be updated later.</li></ul></div><p>Whoa! We have created our first scene. Now it's time to see what we have done. But before that, we have to add this scene to the view, so that we can make it visible and live. Open your <code class="literal">GameViewController</code> class and paste the code inside <code class="literal">viewDidLoad</code> under <code class="literal">super.viewDidLoad()</code>:</p><div class="informalexample"><pre class="programlisting">  let menuscene = MenuScene(size: view.bounds.size, playbutton: "Play", background: "BG")
  let skview = view as SKView
  skview.showsFPS = true
  skview.showsNodeCount = true
  skview.ignoresSiblingOrder = true
  menuscene.scaleMode = .ResizeFill
  menuscene.anchorPoint = CGPoint(x: 0.5, y: 0.5)
  skview.presentScene(menuscene)</pre></div><p>In this code, we created the <code class="literal">menuscene</code> instance and added it to the view. <code class="literal">Play</code> and <code class="literal">BG</code> are the names of the PNG sprite, which we will add later. We have typecast view as <code class="literal">SKView</code> and set some of its properties. If we want to see frame per second rate, we set <code class="literal">showFPS</code> to <code class="literal">true</code>. Same goes for the counting node. If we set <code class="literal">ignoresSiblingOrder</code> property to <code class="literal">false</code>, then it means that the nodes that are sharing the same <code class="literal">z</code> depth will be rendered in parent to child preference.</p><p>This implies that the<a id="id87" class="indexterm"/> parent will render first and then its child. If we set it <code class="literal">true</code>, then<a id="id88" class="indexterm"/> it means that all the nodes with the same <code class="literal">z</code> depth will render at the same time, and not by some parent child preference. So to maximize the optimization, we will just set this value to true; in simple terms, it's better to set this to true if you want faster results.</p><p>
<code class="literal">.scaleMode</code> is used to fill the scene inside a view. <code class="literal">ResizeFill</code> means that it will resize itself to fill the whole view.</p><p>Now, for the <code class="literal">anchorPoint</code>. It decides what would be a child's coordinate system according to parent position. If we set it to <code class="literal">.5, .5</code>, that means that the nodes that will be added to these scenes, will have their coordinate system starting from the middle of the screen. You can choose whatever you are comfortable with.</p><p>In the last line, we just added <code class="literal">menuscene</code> to the view so that it could render.</p><p>Now, it's time to add some images to the project. The first question that comes to mind is, "How one can maintain the quality of an image on various screen sizes?"</p><p>To optimize the quality of an image on large screen devices, we add the same image in two different sizes, 1x—the original image—and 2x—double the size of the original image, for better display quality on larger devices. iOS will automatically select the appropriate image size.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Also, you can go for a 3x image size, for even larger devices.</p></div></div><p>Two sets of image sizes are sufficient to cover most commonly used screen sizes.</p><p>Following are the steps to add images in the project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Click on <code class="literal">Images.xcassets</code> | select <span class="strong"><strong>New Image Set</strong></span>:<div class="mediaobject"><img src="graphics/B04201_02_07.jpg" alt="Adding the first scene in our game"/></div></li><li class="listitem">After that, Name<a id="id89" class="indexterm"/> it <code class="literal">BG</code>, and drag and drop your background<a id="id90" class="indexterm"/> images according to size. As shown in the next image:<div class="mediaobject"><img src="graphics/B04201_02_08.jpg" alt="Adding the first scene in our game"/></div></li><li class="listitem">Repeat the process for the set of play images.</li><li class="listitem">Run it and see. You will see your background in full screen, with a <span class="strong"><strong>Play</strong></span> button in the <a id="id91" class="indexterm"/>middle of the screen. We can also <a id="id92" class="indexterm"/>control the <span class="strong"><strong>Play</strong></span> button size, as we did for <code class="literal">Background</code>.</li></ol></div><p>Congratulations, you made your first scene. Now it's time to make another scene, that is the <code class="literal">GameScene</code>, and also transition between <code class="literal">Menuscene</code> and <code class="literal">Gamescene</code>.</p></div>
<div class="section" title="Adding another scene to our game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Adding another scene to our game</h1></div></div></div><p>Create the<a id="id93" class="indexterm"/> <code class="literal">GameScene</code> file <a id="id94" class="indexterm"/>as we did for <code class="literal">MenuScene</code>:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

class GameScene: SKScene
{

  let backgroundNode = SKSpriteNode(imageNamed: "BG")


  override func didMoveToView(view: SKView) {
  addBackGround()
}

  func addBackGround()
  {
    backgroundNode.zPosition = 0
    backgroundNode.size = CGSize(width:self.size.width, height:self.size.height)
    addChild(backgroundNode)
  }

  override func update(currentTime: NSTimeInterval) {

  }

}</pre></div><p>The code is self-explanatory, we added only a background to the <code class="literal">GameScene</code>, the same as what we did for the <code class="literal">MenuScene</code>.</p></div>
<div class="section" title="A transition from one scene to another"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>A transition from one scene to another</h1></div></div></div><p>A transition is used to perform animation; while shifting from one scene to another, an object called <code class="literal">SKTransition</code> is used to perform this action. As we know, scenes are the basic building blocks of games. Transiting<a id="id95" class="indexterm"/> from one scene to another is often necessary in a game at various instances such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A loading scene, which is shown in a game while other objects are being loaded</li><li class="listitem" style="list-style-type: disc">A main menu scene, in which different options are shown to the user</li><li class="listitem" style="list-style-type: disc">A level selection menu scene, to select different levels available</li><li class="listitem" style="list-style-type: disc">A game play scene, which contains the main elements of the game</li><li class="listitem" style="list-style-type: disc">A game over scene, to represent ending of the game, and so on</li></ul></div><p>When you present a new scene in a view that is already presenting a scene, you have the option of using a transition to animate the change from the old scene into the new scene. Using a transition provides continuity, so that the scene change is not abrupt and doesn't disturb the UI of the game.</p><p>When the transition occurs, the scene property is immediately updated to point to the new scene. Then, the animation occurs. Finally, the strong reference to the old scene is removed. If you need to keep the scene around after the transition occurs, your game has to keep its own strong reference to the old scene.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div>
<div class="section" title="Setting animation play during transition"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Setting animation play during transition</h1></div></div></div><p>Generally, when a transition occurs <a id="id96" class="indexterm"/>between two scenes, both the scenes are<a id="id97" class="indexterm"/> paused. This implies that if any animation is being played in any one of the two scenes, it will be paused until the transition has been completed. Sometimes, it is required to complete the animation effect of one scene. The <code class="literal">pausesIncomingScene</code> and <code class="literal">pausesOutgoingScene</code> properties on the transition object define which animations are played during the transition.</p></div>
<div class="section" title="Creating transition objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Creating transition objects</h1></div></div></div><p>Transitions are used<a id="id98" class="indexterm"/> by making <code class="literal">SKTransition</code> an object; some of the methods to do that are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">class func crossFadeWithDuration(_ sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a cross fade transition; it takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func doorsCloseHorizontalWithDuration(_ sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the new scene appears as a pair of closing horizontal doors; it also takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func doorsCloseVerticalWithDuration(sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the new scene appears as a pair of closing vertical doors. It also takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func doorsOpenHorizontalWithDuration(_ sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the new scene appears as a pair of opening horizontal doors. It also takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func doorsOpenVerticalWithDuration(_ sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the new scene appears as a pair of opening vertical doors. It also takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func doorwayWithDuration(_ sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the previous scene disappears as a pair of opening doors. The new scene starts in the background and moves closer as the doors open. It also takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func fadeWithColor(_ color: UIColor, duration sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition that first fades to a constant color, and then fades to the new scene. It takes the fade color and the duration of transition as parameters, and returns the <code class="literal">SKTransition</code> as object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func fadeWithDuration(_ sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition that first fades to black and then fades to the new scene. It takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func flipHorizontalWithDuration(_ sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the two scenes are flipped across a horizontal line running through the center of the view. It takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func flipVerticalWithDuration(_ sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the two scenes are flipped across a vertical line running through the center of the view. It takes the duration of transition as its parameter and returns an <code class="literal">SKTransition</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func moveInWithDirection(_ direction: SKTransitionDirection, duration sec: NSTimeInterval) -&gt; SKTransition</code>: This <a id="id99" class="indexterm"/>creates a transition where the new scene moves on top of the old scene. It takes the direction of the move and the duration as its parameters, and returns an SKTransition object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func pushWithDirection(_ direction: SKTransitionDirection, duration sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the new scene moves in, pushing the old scene out of the view. It takes the direction of the push and the duration of transition as its parameters, and returns an SKTransition object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">class func revealWithDirection(_ direction: SKTransitionDirection, duration sec: NSTimeInterval) -&gt; SKTransition</code>: This creates a transition where the old scene moves out of the view, revealing the new scene underneath it. It takes the direction of the reveal and the duration of transition as its parameters, and returns an <code class="literal">SKTransition</code> object.</li></ul></div></div>
<div class="section" title="Adding transition in our game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Adding transition in our game</h1></div></div></div><p>Now, open<a id="id100" class="indexterm"/> <code class="literal">MenuScene</code>. First, define<a id="id101" class="indexterm"/> the <code class="literal">GameScene</code> reference inside the <code class="literal">MenuScene</code> class, before the init code block:</p><div class="informalexample"><pre class="programlisting">var gameScene : GameScene?
Add the following code below update function
override func touchesBegan(touches: NSSet, withEvent event: UIEvent)
{
  for touch: AnyObject in touches
  {
    let location = touch.locationInNode(self)
    let node = self.nodeAtPoint(location)
    if node.name == PlayButton.name
    {
      goToGameScene()
    }
  }
}

  func goToGameScene(){
  let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
  gameScene = GameScene(size: self.size)
  gameScene!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
  self.view?.presentScene(gameScene , transition:transitionEffect)

}</pre></div><p>Inside <code class="literal">didMoveToView</code>, place the following line just under <code class="literal">addChildToScene</code>:</p><div class="informalexample"><pre class="programlisting">PlayButton.name = "PLAY"</pre></div><p>If you run it now, you<a id="id102" class="indexterm"/> will see our menu scene with a play button and a <a id="id103" class="indexterm"/>background; if you click outside the play button, nothing will happen. When you click on the play button, you will see a smooth transition to the game scene.</p><p>In the preceding code, <code class="literal">var</code> is a keyword that means it can change its value. But what is this <code class="literal">?</code> symbol doing after <code class="literal">GameScene</code>?</p><p>The <code class="literal">?</code> symbol means that the reference is optional. It means it can either have a value, or it can be nil.</p><p>That's why we don't need to initialize it in the init code block.</p><p>In <code class="literal">PlayButton.name = "PLAY"</code> we are just giving the <code class="literal">SKSpriteNode</code> object a name, so that when we touch this sprite, we can verify it by name.</p><p>
<code class="literal">touchesBegan</code>, is an override method which is used to identify when a touch event is just beginning. In this method, we are getting a node at the touch position and checking if the desired node is there. If the play <code class="literal">SKSpriteNode</code> is there, it will be identified by its name and will call the <code class="literal">goToGameScene</code> method.</p><p>In <code class="literal">goToGameScene</code> method, we just added <code class="literal">GameScene</code> to the view with some transition effect. Transitions are an <code class="literal">SKTransition</code> class instance. Here, we used the <code class="literal">flipHorizontalWithDuration</code> transition effect.</p><p>You can also tweak and play with other transitions available.</p><p>In <code class="literal">gameScene!.anchorPoint = CGPoint(x: 0.5, y: 0.5)</code>, we have put an exclamation mark <a id="id104" class="indexterm"/>after <code class="literal">GameScene</code>. As we know that <code class="literal">GameScene</code> is <a id="id105" class="indexterm"/>optional, we have to tell the compiler that we know it has a value, and that we are forcing the it to unwrap its value. The <code class="literal">!</code> symbol is used for force unwrapping optional values.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we learned about device orientation and about the different auto generated files in a Sprite Kit project. Also, we studied scenes and saw how to create them in a Sprite Kit project. Furthermore, we discussed about transitions between scenes and their types.</p><p>In the next chapter, we will learn about sprites and texture atlases. Our <span class="emphasis"><em>Platformer</em></span> game will become much more exciting and interesting to play, as we move further.</p></div></body></html>