- en: '*Chapter 1*: What''s New in iOS 14?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*: iOS 14 的新功能是什么？'
- en: During WWDC 2020, Apple introduced the new features and improvements included
    in iOS 14\. Using the latest features in your apps can make a huge difference
    for users in terms of engagement, positive reviews, and overall user experience.
    It can also lead to other benefits, such as being featured by Apple in the App
    Store, and having an advantage over competitors' apps in the same category.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2020 年的 WWDC 上，苹果介绍了 iOS 14 中包含的新功能和改进。使用您应用的最新功能可以在用户参与度、正面评价和整体用户体验方面为用户带来巨大差异。它还可以带来其他好处，例如在
    App Store 中被苹果推荐，以及在同类竞品应用中具有优势。
- en: Apple made Swift 5.2 available for developers on March 24, 2020\. Later in the
    year, Apple released Swift 5.3\. These versions focus on quality and performance
    improvements, new language features, and increased support for Windows platforms
    and Linux distributions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果于 2020 年 3 月 24 日发布了 Swift 5.2，供开发者使用。同年晚些时候，苹果发布了 Swift 5.3。这些版本侧重于质量、性能改进，新语言特性，以及增加对
    Windows 平台和 Linux 发行版的支持。
- en: 'There was another big announcement during WWDC 2020: Apple Silicon. Apple introduced
    its own processors to the world. Developers can start building apps and ship them
    by the end of 2020, starting a transition that will last two years. This transition
    will establish a common architecture across all Apple products. With a common
    architecture, it will be easier to create apps for the entire Apple ecosystem.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2020 年的 WWDC 上还有另一个重大公告：苹果硅。苹果向世界推出了自己的处理器。开发者可以从 2020 年底开始构建应用并发布它们，这将开启一个为期两年的过渡。这个过渡将在所有苹果产品中建立统一的架构。有了统一的架构，将更容易为整个苹果生态系统创建应用。
- en: 'In this chapter, you will learn the basics of two of the most significant new
    features on iOS 14: App Clips and widgets. We will also cover the latest additions
    to augmented reality, machine learning, and user privacy. At the end of the chapter,
    you will learn about the new additions to the Swift language with some code examples.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习 iOS 14 中两个最重要的新功能的基础：App Clips 和小部件。我们还将介绍增强现实、机器学习和用户隐私的最新更新。在本章结束时，你将通过一些代码示例了解
    Swift 语言的最新更新。
- en: 'In this chapter, we''re going to cover the following main topics of iOS 14,
    Swift 5.2, and Swift 5.3:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 iOS 14、Swift 5.2 和 Swift 5.3 的以下主要主题：
- en: Introducing App Clips
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 App Clips
- en: Introducing WidgetKit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 WidgetKit
- en: Improvements in augmented reality
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强现实改进
- en: Improvements in machine learning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习改进
- en: Improvements in user privacy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户隐私改进
- en: Introducing Swift 5.2
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Swift 5.2
- en: Introducing Swift 5.3
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Swift 5.3
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New).
- en: 'If you want to try out Swift 5.2 features as you read through the chapter,
    you need to install Xcode version 11.4 or later: [https://itunes.apple.com/app/xcode/id497799835](https://itunes.apple.com/app/xcode/id497799835).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在阅读本章时尝试 Swift 5.2 的功能，你需要安装 Xcode 版本 11.4 或更高版本：[https://itunes.apple.com/app/xcode/id497799835](https://itunes.apple.com/app/xcode/id497799835).
- en: Introducing App Clips
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 App Clips
- en: '**App Clips** allow users to discover your app in a fast and lightweight manner.
    With App Clips, a user can quickly use a feature of your app even without having
    the app installed on their phone. Let''s see an example of what an App Clip looks
    like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**App Clips** 允许用户以快速和轻量级的方式发现您的应用。使用 App Clips，用户可以快速使用您应用的功能，即使没有在他们的手机上安装该应用。让我们看看一个
    App Clip 的例子：'
- en: '![Figure 1.1 − App Clip UI'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 − App Clip UI'
- en: '](img/Figure_1.01_B14717.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.01_B14717.jpg)'
- en: Figure 1.1 − App Clip UI
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 − App Clip UI
- en: 'App Clips should be lightweight, brief, and finish a user task in seconds.
    Let''s see some use cases of App Clips:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: App Clips 应该轻量级、简洁，并在几秒钟内完成用户任务。让我们看看一些 App Clips 的用例：
- en: An App Clip to order coffee when you pass by the coffee shop door and tap on
    an NFC tag.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你经过咖啡店门口并点击 NFC 标签时，可以订购咖啡的 App Clip。
- en: An App Clip to rent an electric bike parked in the street, just by scanning
    a QR code on it. Also, you can use Sign in with Apple and Apple Pay to avoid forms
    and interface complexities, allowing you to rent the bike in seconds.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扫描停在街上的电动自行车上的二维码，即可租用该电动自行车。此外，您还可以使用 Apple 登录和 Apple Pay 来避免填写表格和界面复杂性，让您能在几秒钟内租用自行车。
- en: An App Clip to pre-order from the menu in a restaurant and save time while you
    wait to be seated.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 App Clip，可以预先从餐厅菜单中订购，并在等待就座时节省时间。
- en: An App Clip that triggers when you tap around NFC spots in an art gallery or
    a museum and displays augmented reality scenes on your iPhone.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在艺术画廊或博物馆的 NFC 点周围轻触时触发的 App Clip，并在你的 iPhone 上显示增强现实场景。
- en: As you can see, the possibilities with App Clips are endless. Now that we have
    covered what an App Clip is, we are going to explain the user's journey using
    an App Clip (from the invocation to the end). We will cover the invocation methods
    (how to trigger an App Clip to appear). Finally, we will explore the recommended
    guidelines when building an App Clip.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，App Clips 的可能性是无限的。现在我们已经介绍了什么是 App Clip，我们将解释用户使用 App Clip 的旅程（从调用到结束）。我们将涵盖调用方法（如何触发
    App Clip 出现）。最后，我们将探讨构建 App Clip 时推荐的指南。
- en: App Clip user journey
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App Clip 用户旅程
- en: Let's now explore the whole process and steps in more detail, starting from
    when the user discovers your App Clip to when the user finishes the App Clip journey.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更详细地探索整个过程和步骤，从用户发现您的 App Clip 到用户完成 App Clip 之旅。
- en: 'Let''s imagine that we have an app to rent electric bikes on the street. There
    are several stages involved in the App Clip process:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们有一个在街头租用电动自行车的应用。App Clip 流程涉及几个阶段：
- en: '![Figure 1.2 − App Clip process and steps'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.2 − App Clip 流程和步骤'
- en: '](img/Figure_1.02_B14717.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.02_B14717.jpg]'
- en: Figure 1.2 − App Clip process and steps
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 − App Clip 流程和步骤
- en: 'The steps of an AppClip are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: AppClip 的步骤如下：
- en: '**Invocation method**: The App Clip invocation method is how the user can trigger
    and open an App Clip. For our example with the electric bike rental, a user scans
    a QR code placed in the bike with their device camera, and the App Clip opens
    on the home screen. The invocation method, in this case, is the QR code. We will
    explore more of them later in the chapter.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用方法**：App Clip 调用方法是用户如何触发和打开 App Clip 的方式。以我们电动自行车租赁的例子，用户使用设备摄像头扫描放置在自行车上的二维码，App
    Clip 就会在主屏幕上打开。在这种情况下，调用方法是二维码。我们将在本章后面进一步探讨更多调用方法。'
- en: '**User Journey**: After the invocation, the App Clip presents some options
    for the user to choose from (for example, 1-hour rental for $2 and 24-hour rental
    for $5). The user makes the desired selections inside the App Clip.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户旅程**：在调用后，App Clip 会向用户展示一些选项供其选择（例如，1 小时租赁费用为 2 美元，24 小时租赁费用为 5 美元）。用户在
    App Clip 内进行所需的选择。'
- en: '**Accounts and Payment**: In our rental bike example, our App Clip needs to
    identify which user is renting the bike, and the user needs to pay for the service.
    Some App Clips will not require a registered user account nor payment to work;
    this step is optional.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**账户和支付**：在我们的自行车租赁示例中，我们的 App Clip 需要识别哪个用户在租用自行车，并且用户需要为服务付费。一些 App Clip
    可能不需要注册用户账户或支付即可工作；这一步是可选的。'
- en: '**Full app recommendation**: When the rental of the bike is settled and ready,
    your App Clip can recommend the user to download your complete app, so the next
    time the user can use it instead of the App Clip. Suggesting the entire app is
    an optional step, but it is very much recommended.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完整应用推荐**：当自行车租赁完成并准备就绪时，您的 App Clip 可以推荐用户下载您的完整应用，这样用户下次就可以使用完整应用而不是 App
    Clip。建议整个应用是一个可选步骤，但非常推荐。'
- en: Now that we have an overview of the high-level steps of an App Clip, let's review
    some parts in more detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了 App Clip 的高级别步骤，让我们更详细地回顾一些部分。
- en: App Clips invocation methods
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App Clip 调用方法
- en: 'We have seen that in order to display an App Clip, the user needs to invoke
    it or discover it. We discussed before that it could be invoked by a QR code,
    an NFC tag, or a link in a message. Here is a summary of the options available:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，为了显示 App Clip，用户需要调用它或发现它。我们之前讨论过，它可以通过二维码、NFC 标签或消息中的链接来调用。以下是可用选项的总结：
- en: 'App Clip codes: Each App Clip code includes a QR code and an NFC tag so that
    a user can scan it with their camera or tap on it. It also works with individual
    NFC tags and QR codes.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Clip 代码：每个 App Clip 代码都包含一个二维码和一个 NFC 标签，以便用户可以使用他们的摄像头扫描它或轻触它。它也适用于单个 NFC
    标签和二维码。
- en: Safari App Banner
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari应用横幅
- en: Links in messages
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息中的链接
- en: Place cards in Maps
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图中放置卡片
- en: The recently used App Clips category in the new App Library on iOS 14
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 14新应用库中最近使用的App Clips类别
- en: Let's discuss now the recommended guidelines from Apple when designing and developing
    your App Clip.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下苹果在设计和开发您的App Clip时推荐的指南。
- en: App Clips guidelines
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App Clips指南
- en: 'In order to make App Clips effective, lightweight, and easy to use for the
    user, Apple has several guidelines:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使App Clips对用户来说有效、轻量且易于使用，苹果有几项指南：
- en: 'Focus on the essential task of your app: Suppose that you have a coffee shop
    app with lots of different features, including allowing the user to collect points,
    order coffee, save user preferences, buy coffee gift cards, and so on. Your app
    should not display such a big set of functionalities all at once. The App Clip
    should only provide the most important task (for this example, just the feature
    to order coffee). If the user needs more features, they can download the full
    app.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于您应用的核心任务：假设您有一个拥有许多不同功能的咖啡店应用，包括允许用户收集积分、订购咖啡、保存用户偏好、购买咖啡礼品卡等。您的应用不应一次性显示如此庞大的功能集。App
    Clip应仅提供最重要的任务（在本例中，仅为订购咖啡的功能）。如果用户需要更多功能，他们可以下载完整的应用。
- en: App Clips should be fast and easy to use from the start to the end of the process.
    Avoid using complex UIs, too many menus, detailed views, and other elements that
    can cause the user to spend too much time on it.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Clips应该从开始到结束整个过程都快速且易于使用。避免使用复杂的用户界面、过多的菜单、详细视图和其他可能导致用户花费过多时间的元素。
- en: App Clips should be small in size, so fast to download. Include all the assets
    necessary inside the App Clip but avoid big downloads.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Clips应该体积小，下载速度快。在App Clip内包含所有必要的资产，但避免大文件下载。
- en: Avoid complex user account creation processes in your App Clip. Just '**Sign
    in with Apple**'.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的App Clip中避免复杂的用户账户创建过程。只需“**使用Apple登录**”。
- en: Avoid requiring the user to enter complex and error-prone credit card forms
    and details. When necessary, try using Apple Pay.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免要求用户输入复杂且易出错的信用卡表单和详细信息。当需要时，尝试使用Apple Pay。
- en: When users finish with the App Clip task, they can't go back to it. Your App
    Clip can suggest the user install the full app to keep users engaged later on.
    But do it in a non-intrusive, polite way, for example, after the user journey
    finishes and without making it mandatory.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户完成App Clip任务后，他们无法返回。您的App Clip可以建议用户安装完整的应用以保持用户后续的参与度。但要以非侵入性和礼貌的方式进行，例如，在用户旅程结束后，不要使其成为强制性的。
- en: App Clips provide the option to send or schedule notifications up to 8 hours
    after launch in order to fulfil any required tasks. But it is not recommended
    to use this feature for purely marketing purposes.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Clips提供在启动后8小时内发送或安排通知的选项，以满足任何所需任务。但不建议将此功能用于纯粹的市场营销目的。
- en: In this section, you have learned what an App Clip is, the journey that a user
    will go through while using it, the different invocation methods, and the recommended
    guidelines when building an App Clip for your app. In [*Chapter 14*](B14717_14_Final_ASB_ePub.xhtml#_idTextAnchor457),
    *Creating an App Clip for Your App*, we will create an App Clip for an existing
    app to see a practical example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经了解了什么是App Clip，用户在使用它时会经历什么样的旅程，不同的调用方法，以及构建您的App Clip时推荐的指南。在[*第14章*](B14717_14_Final_ASB_ePub.xhtml#_idTextAnchor457)，“为您的应用创建App
    Clip”，我们将为现有应用创建一个App Clip，以查看一个实际示例。
- en: 'Now, let''s jump into another exciting new feature that comes with iOS 14:
    WidgetKit.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到iOS 14带来的另一个令人兴奋的新功能：WidgetKit。
- en: Introducing WidgetKit
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WidgetKit
- en: 'Users and developers have been requesting a particular feature for years: they
    all wanted to be able to have widgets on their home screen. Widgets allow users
    to configure, personalize, and consume little pieces of relevant data from their
    home screen. They also allow developers to offer users glanceable content and
    create added value for their apps.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和开发者已经多年以来一直在请求一个特定的功能：他们所有人都希望能够在他们的主屏幕上拥有小部件。小部件允许用户从主屏幕配置、个性化并消费相关数据的片段。它们还允许开发者向用户提供可快速查看的内容，并为他们的应用创造附加价值。
- en: 'Here is a preview of how a **widget** (in this case Calendar and Reminders
    widgets) looks on the home screen on the iPhone:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是**小部件**（在这种情况下是日历和提醒小部件）在iPhone主屏幕上的预览：
- en: '![Figure 1.3 − iOS Home screen with Widgets'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 − iOS Home screen with Widgets]'
- en: '](img/Figure_1.03_B14717.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.03_B14717.jpg]'
- en: Figure 1.3 − iOS Home screen with Widgets
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 − 带有小部件的iOS主屏幕
- en: Now it is possible on iOS 14, macOS 11, and later versions. Developers can create
    widgets across iOS, iPadOS and macOS using **WidgetKit** and the new **widget
    API** for SwiftUI.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 iOS 14、macOS 11 及更高版本上，这是可能的。开发者可以使用 **WidgetKit** 和 SwiftUI 的新 **小部件 API**
    在 iOS、iPadOS 和 macOS 上创建小部件。
- en: The **Smart Stack** on iOS 14 contains a set of different widgets, including
    the ones that the user opens frequently. If the user enables **Smart Rotate**,
    Siri can highlight relevant widgets within custom stacks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 14 中的 **智能堆叠** 包含一组不同的小部件，包括用户经常打开的小部件。如果用户启用了 **智能旋转**，Siri 可以突出显示自定义堆叠中的相关小部件。
- en: Widgets created on iOS 13 and earlier
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 13 及更早版本上创建的小部件
- en: Widgets created before iOS 14 can't be placed on the home screen, but they are
    still available on the Today View and macOS Notification Center.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 14 或 macOS 11 上创建的小部件不能放置在主屏幕上，但它们仍然可在 Today View 和 macOS 通知中心中查看。
- en: After this introduction to the new widgets, let's see what options we have when
    building a widget and look at the design guidelines from Apple.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完新小部件之后，让我们看看在构建小部件时有哪些选项，并查看苹果的设计指南。
- en: Widgets options
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件选项
- en: Users can place widgets on the home screen or the Today View on iOS, or the
    Today View on iPad and the Notification Center on macOS.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在 iOS 的主屏幕或 Today View 上，或在 iPad 的 Today View 和 macOS 的通知中心上放置小部件。
- en: 'Widgets come in three sizes: small, medium, and large. Each size should have
    a different purpose. This means that a bigger version of a widget should not be
    just the same as the small one but with bigger font and images. The idea of having
    different sizes for a widget is that the bigger the size, the more information
    it should contain. For example, a weather widget will provide just the current
    temperature in the small version, but it will also include a weekly forecast in
    the medium one.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件有三种尺寸：小、中、大。每种尺寸应有不同的用途。这意味着一个更大尺寸的小部件不应该只是小尺寸的字体和图像更大，而应该包含更多信息。例如，天气小部件在小尺寸版本中只提供当前温度，但在中尺寸版本中还会包括一周的天气预报。
- en: Users can arrange widgets in different parts of their screen, and even create
    stack widgets to group them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在屏幕的不同部分排列小部件，甚至创建堆叠小部件来分组它们。
- en: 'In order to develop a widget, developers need to create a new extension for
    their app: a **widget extension**. They can configure the widget with a timeline
    provider. A timeline provider updates the widget information when needed.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发小部件，开发者需要为他们的应用创建一个新的扩展：一个**小部件扩展**。他们可以使用时间线提供者来配置小部件。时间线提供者在需要时更新小部件信息。
- en: If a widget needs some configuration (for example, selecting a default city
    in a weather app, or multiple cities to display in a large weather widget), developers
    should add a custom Siri intent to the widget extension. Doing so automatically
    provides the widget with a customization interface for the user.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果小部件需要一些配置（例如，在天气应用中选择默认城市，或在大型天气小部件中显示多个城市），开发者应在小部件扩展中添加自定义 Siri 意图。这样做会自动为用户的小部件提供定制界面。
- en: Widget guidelines
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件指南
- en: 'When creating a widget for iOS 14 or macOS 11, take into account the following
    design guidelines:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当为 iOS 14 或 macOS 11 创建小部件时，请考虑以下设计指南：
- en: Focus your widget on the feature of your app. If your app is about the stock
    market, your widget can display the total value of the user's portfolio.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的小部件聚焦于你应用的功能。如果你的应用是关于股市的，你的小部件可以显示用户的投资组合总价值。
- en: Each widget size should display a different amount of information. If your cycling
    tracker widget displays the current calories burned today in the small widget,
    it can also display the calories per day of the week in the medium widget and
    add extra information such as km/miles traveled in the large widget.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种尺寸的小部件应显示不同数量的信息。如果你的骑行追踪小部件在小尺寸小部件中显示当天燃烧的卡路里，它也可以在中尺寸小部件中显示一周内每天的卡路里，并在大尺寸小部件中添加额外的信息，如行驶的公里数/英里数。
- en: Prefer dynamic information that changes during the day to fixed information;
    it will make your widget more appealing to the user.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更倾向于动态信息，这些信息在一天中会变化，而不是固定信息；这将使你的小部件对用户更具吸引力。
- en: Prefer simple widgets with fewer configuration options, compared to complex
    widgets with more options.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比于配置选项更多的复杂小部件，更倾向于简单的小部件，配置选项较少。
- en: Widgets offer tap target and detection, letting the user select and tap on them
    to open detailed information in the app. Small widgets support a single tap target,
    medium and large widgets support multiple targets. Try to keep it simple.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件提供点击目标和检测功能，允许用户选择并点击它们以在应用中打开详细信息。小型小部件支持单个点击目标，中型和大型小部件支持多个目标。尽量保持简单。
- en: Support dark mode. Also, consider using SF Pro as the font and SF Symbols if
    needed.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持暗黑模式。同时，考虑使用 SF Pro 作为字体，如果需要，使用 SF Symbols。
- en: In this section, we have had an introduction to the new widgets and WidgetKit.
    We have covered the different options available and the design guidelines when
    building a widget. In the next section, we are going to cover the new improvements
    and additions to augmented reality in iOS 14.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了新的小部件和 WidgetKit。我们涵盖了构建小部件时可用选项和设计指南。在下一节中，我们将介绍 iOS 14 中增强现实的新改进和新增功能。
- en: Improvements in augmented reality
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强现实改进
- en: 'In the new ARKit 4 for iOS 14 and iPadOS 14, there are four big new features:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 14 和 iPadOS 14 的新 ARKit 4 中，有四个主要的新特性：
- en: '**Location Anchors** allow developers to place AR scenes at geographic coordinates.
    Location Anchors enable users to display those AR experiences at specific locations,
    landmarks, and places around the world.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置锚点** 允许开发者将 AR 场景放置在地理坐标上。位置锚点使用户能够在全球特定位置、地标和地点显示这些 AR 体验。'
- en: '**Extended Face** tracking support allows AR experiences accessible via the
    front camera in devices with the A12 Bionic chip or a later version.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展人脸** 跟踪支持允许通过具有 A12 Bionic 芯片或更高版本的设备的正面摄像头访问 AR 体验。'
- en: '**RealityKit** will enable developers to add video textures to any part of
    the AR scene or AR object. Video textures also include spatialized audio.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RealityKit** 将使开发者能够将视频纹理添加到 AR 场景或 AR 对象的任何部分。视频纹理还包括空间化音频。'
- en: '`ARView` – `Environment` object. Scene Understanding contains four options:
    **Occlusion**, where real-world objects occlude virtual objects; **Receives Lighting**,
    which allows virtual objects to cast shadows on real-world objects; **Physics**,
    which enables virtual objects to interact with the real world physically; and
    **Collision**, which enables collisions between virtual objects and real-world
    objects.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARView` – `环境` 对象。场景理解包含四个选项：**遮挡**，其中现实世界对象遮挡虚拟对象；**接收光照**，允许虚拟对象在现实世界对象上投下阴影；**物理**，使虚拟对象能够以物理方式与真实世界交互；以及
    **碰撞**，使虚拟对象与现实世界对象之间发生碰撞。'
- en: Note
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Activating the **Receives Lighting** option automatically turns on **Occlusion**.
    Activating the **Physics** option automatically turns on **Collision**.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 激活 **接收光照** 选项会自动开启 **遮挡**。激活 **物理** 选项会自动开启 **碰撞**。
- en: In this section, we have seen the improvements in augmented reality. Let's now
    review what's new in machine learning.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了增强现实的改进。现在让我们回顾一下机器学习中的新内容。
- en: Improvements in machine learning
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习改进
- en: Improvements to Core ML presented during WWDC2020 will help developers with
    the development of their machine learning apps, with improvements that upgrade
    your app models, secure them, and group them in targeted collections. We are going
    to cover in this section the new Core ML Model Deployment, the new model collections
    with targeted deployments, and the new model encryption.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: WWDC2020 期间展示的 Core ML 改进将帮助开发者开发他们的机器学习应用，通过改进升级您的应用模型，确保它们的安全，并将它们分组到定向集合中。在本节中，我们将介绍新的
    Core ML 模型部署，新的具有定向部署的模型集合，以及新的模型加密。
- en: Core ML Model Deployment, collections, and targeted deployments
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Core ML 模型部署、集合和定向部署
- en: One of the most significant features introduced in WWDC 2020 for Core ML is
    `mlmodel` file from the cloud.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: WWDC 2020 为 Core ML 引入的最显著特性之一是来自云端的 `mlmodel` 文件。
- en: Developers will be able to create **machine learning model collections** on
    the cloud and update them on CloudKit. Apps will download those collections and
    stay up to date, with no version upgrading process in the middle. However, developers
    don't control the download process. The app will detect that there is a new model
    version available and will download it when the system decides it's appropriate
    (for example, in the background while the phone is locked and charging on a Wi-Fi
    connection). So, developers should take into account that the model update may
    or may not be fast or in real time. The operating system will have the last word.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者将能够在云上创建**机器学习模型集合**并使用 CloudKit 更新它们。应用将下载这些集合并保持更新，中间没有版本升级过程。然而，开发者不控制下载过程。应用将检测到有新的模型版本可用，并在系统决定合适的时机（例如，在手机锁定且在
    Wi-Fi 连接下充电的背景中）下载它。因此，开发者应该考虑到模型更新可能或可能不会快速或实时。操作系统将拥有最终决定权。
- en: 'A useful feature of model collections is that they can be targeted to different
    users (for example, users on devices with varying capabilities, such as iPhones
    vs iPads). Assigning different models to different users can be done with **targeted
    deployments** applied to collections. There are six options available to configure
    and target the model that the device will deploy: language code, device class,
    operating system, operating system version, region code, and app version.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模型集合的一个有用特性是它们可以被针对不同的用户（例如，在具有不同能力的设备上的用户，如 iPhone 与 iPad）。可以通过对集合应用**定向部署**来为不同的用户分配不同的模型。有六个选项可用于配置和针对设备将要部署的模型：语言代码、设备类别、操作系统、操作系统版本、区域代码和应用程序版本。
- en: Model encryption
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型加密
- en: Starting on iOS 14 and macOS 11, Core ML can automatically encrypt the Core
    ML models.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从 iOS 14 和 macOS 11 开始，Core ML 可以自动加密 Core ML 模型。
- en: Xcode will encrypt the compiled model, `mlmodelc` (not the original `mlmodel`).
    The decryption happens when the app is instantiated and occurs on the device.
    Moreover, the decryption result is not stored anywhere; it is just loaded into
    memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 将加密编译后的模型，`mlmodelc`（而不是原始的 `mlmodel`）。解密发生在应用实例化时，并在设备上发生。此外，解密结果不会存储在任何地方；它只是加载到内存中。
- en: 'More good news on this: Xcode will help you to create an encryption key, associate
    it with your developer account, and it will be stored in the Apple servers automatically.
    You can always download a local copy for yourself, but the process is not seamless.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个好消息：Xcode 将帮助你创建加密密钥，将其与你的开发者账户关联，并且它将自动存储在苹果服务器上。你可以随时下载一个本地副本，但这个过程并不流畅。
- en: When the encryption key is stored in Apple servers, the file is `.mlmodelkey.`
    When you want to encrypt your model, you just need to add `--encrypt {YourModel}.mlmodelkey`
    to the compiler flags. If you prefer using CloudKit, you just need to provide
    the encryption key when creating the model archive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当加密密钥存储在苹果服务器上时，文件是 `.mlmodelkey`。当你想加密你的模型时，你只需将 `--encrypt {YourModel}.mlmodelkey`
    添加到编译器标志中。如果你更喜欢使用 CloudKit，你只需在创建模型存档时提供加密密钥。
- en: 'The drawback of this process is this: when the app instantiates, it needs to
    have an internet connection with the Apple servers to download the encryption
    key and decrypt your model. If for any reason there is no connectivity, you need
    to implement your fallback process inside the completion errors of the new `{YourModel}.load()`
    method. The completion handler will throw a `modelKeyFetch` error if the encryption
    key is not available, and you can act accordingly.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的缺点是：当应用实例化时，它需要与苹果服务器建立互联网连接来下载加密密钥并解密你的模型。如果由于任何原因没有连接，你需要在新的 `{YourModel}.load()`
    方法的完成错误中实现你的回退流程。如果加密密钥不可用，完成处理程序将抛出 `modelKeyFetch` 错误，你可以相应地采取行动。
- en: Important note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should not include the encryption key in your app bundle. It is not necessary,
    and it can compromise your data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该在你的应用包中包含加密密钥。这并不是必要的，而且可能会危及你的数据。
- en: In this section, we have discovered how we can upgrade our machine learning
    models without updating our apps, how we can group models into collections and
    assign them to a different type of users/devices, and how we can have our models
    encrypted and keep our machine learning data safe with no effort. In the next
    section, we are going to cover the additions to user privacy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们发现了如何在不更新我们的app的情况下升级我们的机器学习模型，如何将模型分组到集合中并将它们分配给不同类型的用户/设备，以及如何通过加密我们的模型并无需努力来保护我们的机器学习数据。在下一节中，我们将介绍对用户隐私的改进。
- en: Improvements in user privacy
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户隐私改进
- en: 'With iOS 14, Apple is giving users more control over their privacy and personal
    data in different ways:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 14中，苹果以不同的方式让用户对他们的隐私和个人数据有更多的控制：
- en: The App Store will show the privacy practices of every app, so the user will
    be able to check them before downloading the app.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用商店将显示每个app的隐私实践，因此用户在下载app之前可以检查它们。
- en: When an app is using the camera or the microphone, an indicator will appear
    in the top-right corner of the phone indicating it. The Control Center will keep
    a history of which apps have used them recently.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个应用使用相机或麦克风时，手机右上角会出现一个指示器来表示。控制中心会记录最近使用过这些功能的app。
- en: Apps can offer users to keep the account they already have but integrate it
    with **Sign in with Apple**.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用可以提供用户保留他们已有的账户，但将其与**使用Apple ID登录**集成。
- en: '**Approximate Location** is a new option for location services that gives a
    less accurate location for apps that shouldn''t need your exact location.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**近似位置**是针对位置服务的新选项，为那些不需要精确位置的应用提供更不准确的位置。'
- en: 'Limited Photos library access: users can now grant access to selected photos
    only instead of to the entire library.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制照片库访问：用户现在可以仅授予对所选照片的访问权限，而不是整个库。
- en: In each new version of iOS, Apple is giving users and developers more and more
    control over the privacy settings. In this section, we have seen new additions
    that keep the user location and their photos more private, improvements on letting
    the user know when an app is using the camera or the microphone, and the addition
    of extra information about an app's usage of data and privacy on its App Store
    page. The next section focuses on the changes that Swift 5.2 introduces in the
    language.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS的每个新版本中，苹果都在给用户和开发者提供越来越多的隐私设置控制权。在本节中，我们看到了新的改进，这些改进使得用户的位置和照片更加私密，改进了让用户知道应用何时使用相机或麦克风的机制，以及在应用商店页面上添加了关于应用使用数据和隐私的额外信息。下一节将重点介绍Swift
    5.2在语言中引入的变化。
- en: Introducing Swift 5.2
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Swift 5.2
- en: Introduced by Apple (on March 24, 2020), Swift 5.2 has handy features focused
    on improving the developer experience and providing additional language features.
    Some of the new language features seem to be oriented toward enhancing the functional
    programming style. Let's review these new features with some code examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由苹果（2020年3月24日推出）引入的Swift 5.2具有针对改进开发者体验和提供额外语言特性的实用功能。一些新的语言特性似乎旨在增强函数式编程风格。让我们通过一些代码示例来回顾这些新特性。
- en: Key path expressions as functions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键路径表达式作为函数
- en: This new feature allows developers to use key path expressions such as `\Root.value`
    wherever `(Root) -> Value` functions are allowed. Let's see it in action.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新功能允许开发者使用键路径表达式，如`\Root.value`，在允许`(Root) -> Value`函数的任何地方使用。让我们看看它是如何工作的。
- en: 'Let''s create a `Car` struct with two properties, `brand` and `isElectric`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有两个属性`brand`和`isElectric`的`Car`结构体：
- en: '[PRE0]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, let''s instantiate an array of `Car` structs with two cars, one that''s
    electric and one that''s not electric:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们实例化一个包含两辆车的`Car`结构体数组，一辆是电动汽车，另一辆不是：
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if we want to filter this `cars` array and get only the electric cars
    in it, we used to do it like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想过滤这个`cars`数组并只获取其中的电动汽车，我们过去是这样做的：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We could also do it this way:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样做：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, with Swift 5.2, we are able to do this more briefly:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着Swift 5.2的推出，我们能够更简洁地做到这一点：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you print the results, you will see that the output is the same:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印结果，你会看到输出是相同的：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that this applies to more cases, such as `map`, `compactMap`, and wherever
    the `(Root) -> Value` function is allowed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这适用于更多的情况，例如`map`、`compactMap`以及允许`(Root) -> Value`函数的任何地方。
- en: The **SE-0249** proposal contains all the details behind this change. For additional
    reference and the motivation behind the proposal, you can check the original document
    at [https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md](https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**SE-0249** 提案包含了这次变化背后的所有细节。对于额外的参考和提案背后的动机，你可以查看原始文档[https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md](https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md)。'
- en: Callable values of user-defined nominal types
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义名义类型的可调用值
- en: This new feature allows values that have a method whose base name is `callAsFunction`
    to be called like a function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新特性允许具有以`callAsFunction`为基本名称的方法的值像函数一样被调用。
- en: 'It is easier to explain this concept with a simple example. Let''s create a
    struct called `MyPow` that helps us to calculate the power of a number, given
    the base number:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个简单的例子更容易解释这个概念。让我们创建一个名为`MyPow`的结构体，帮助我们计算给定基数的一个数的幂：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can calculate the `pow` of the `base` just by doing the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下方式计算`base`的`pow`：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This `print` statement will have the following result:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此`print`语句将产生以下结果：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, with Swift 5.2, we can calculate the `pow` of the base but using this
    method instead:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Swift 5.2，我们可以计算基数的`pow`，但使用这种方法：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the same output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了相同的输出：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Swift **SE-0253** proposal document contains all the details behind this
    change. For additional reference and the motivation behind the proposal, you can
    check the original document at [https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md](https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Swift **SE-0253** 提案文档包含了这次变化背后的所有细节。对于额外的参考和提案背后的动机，你可以查看原始文档[https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md](https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md)。
- en: Subscripts can now declare default arguments
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下标现在可以声明默认参数
- en: When declaring a subscript, we are now able to assign a default value for an
    argument.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明下标时，我们现在可以为参数分配一个默认值。
- en: 'Let''s see it in action with an example. We create a `Building` struct that
    contains an array of `String` representing floor names. We add a subscript to
    get the name of a floor with a given index. If the index doesn''t exist, we want
    to get the default value, `Unknown`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来看看它的实际效果。我们创建一个名为`Building`的结构体，它包含一个表示楼层名称的`String`数组。我们添加一个下标来获取给定索引的楼层名称。如果索引不存在，我们希望获取默认值，`Unknown`：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see in the following output that when we access index `0` with `building[0]`,
    we return the value `Ground Floor`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下输出中看到，当我们使用`building[0]`访问索引`0`时，我们返回值`Ground Floor`：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The console output is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出如下：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And in the following scenario, when we access the index `5` with `building[5]`,
    we return the value `Unknown`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下场景中，当我们使用`building[5]`访问索引`5`时，我们返回值`Unknown`：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The console output is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出如下：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code example shows how we can make use of default arguments when using
    subscripts and how it can be helpful to tackle edge cases.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例展示了在使用下标时如何使用默认参数，以及它如何有助于处理边缘情况。
- en: Lazy filtering order is now reversed
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒过滤顺序现在已反转
- en: 'When working with a lazy array and filter, there is a new change in the order
    of the operations applied to the filters chain. Take a look at the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当与懒数组一起使用过滤时，对过滤链中应用的运算顺序有新的变化。请看以下代码：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Swift 5.2, this code will print the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 5.2中，此代码将打印以下内容：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is because the `.filter { $0 % 2 == 0 }` statement is applied before the
    `.filter { print($0); return true }` statement.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`.filter { $0 % 2 == 0 }`语句是在`.filter { print($0); return true }`语句之前应用的。
- en: However, if we execute this code in a Swift version prior to 5.2, we will notice
    that the order will be the opposite. First, we will print all the numbers; then,
    we will filter and get only the even ones. The `.filter` statements will execute
    from bottom to top.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在这个5.2之前的Swift版本中执行此代码，我们会注意到顺序是相反的。首先，我们将打印所有数字；然后，我们将过滤并只获取偶数。`.filter`语句将从下到上执行。
- en: This behavior will change again if we remove `.lazy` from the code. Then, regardless
    of the Swift version, we will see the output as only `2` and `4`. The filters
    will be applied from top to bottom, as expected.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从代码中移除`.lazy`，这种行为将再次改变。然后，无论Swift版本如何，我们都会看到输出仅为`2`和`4`。过滤器将按预期从上到下应用。
- en: Important note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This change can break your code and the logic of your app. Make sure you review
    for any similar scenario when updating your code to Swift 5.2 or later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化可能会破坏您的代码和应用程序的逻辑。确保在将代码更新到Swift 5.2或更高版本时，审查任何类似的场景。
- en: New and improved diagnostics
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新增和改进的诊断
- en: In Swift 5.2, error messages have improved in quality and precision. In the
    previous version, the compiler tried to guess the exact location of an error by
    breaking down expressions into smaller pieces. But this method left some errors
    out there.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 5.2中，错误信息在质量和精度上都有所提高。在之前的版本中，编译器试图通过将表达式分解成更小的部分来猜测错误的精确位置。但这种方法遗漏了一些错误。
- en: Now the compiler, when encountering failures while trying to infer a type, records
    the location of those elements. These recordings allow the compiler to detect
    the exact error later on if needed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当编译器在尝试推断类型时遇到失败，它会记录这些元素的位置。这些记录允许编译器在需要时检测到确切的错误。
- en: 'Let''s see an example compiled in Swift 5.1 versus Swift 5.2 and the output
    on each version. Look at this code which contains an error:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Swift 5.1和Swift 5.2中编译的例子，以及每个版本上的输出。看看这个包含错误的代码：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In Swift 5.2, we get a clear error in the exact location where it happens,
    and with an accurate reason:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 5.2中，我们可以在错误发生的确切位置得到一个清晰的错误，并且有准确的原因：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the compiler is telling us that we are trying to use a member
    of the enum that doesn't exist, `c`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编译器告诉我们我们正在尝试使用一个不存在的枚举成员，`c`。
- en: 'If we try to compile the same code in Swift 5.1, we will see a different (and
    incorrect) error message:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在Swift 5.1中编译相同的代码，我们将看到不同的（并且是错误的）错误信息：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The improvements in the compiler errors make iOS developers' day-to-day debugging
    much more comfortable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器错误改进使得iOS开发者日常调试变得更加舒适。
- en: In this section, you have learned about the latest additions to the language
    and the improved diagnostics on Swift 5.2 with code examples. Now, let's jump
    into the features of Swift 5.3.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经了解了语言最新的添加内容以及Swift 5.2上的改进诊断，并伴随着代码示例。现在，让我们跳转到Swift 5.3的特性。
- en: Introducing Swift 5.3
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Swift 5.3
- en: Introduced by Apple during 2020, the main goal in Swift 5.3 is to enhance quality
    and performance and to expand the number of platforms on which Swift is available
    by adding support for Windows and additional Linux distributions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由苹果在2020年引入，Swift 5.3的主要目标是提升质量和性能，并通过添加对Windows和额外的Linux发行版的支持来扩展Swift可用的平台数量。
- en: Now, let's review some of the new language features.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一些新的语言特性。
- en: Multi-pattern catch clauses
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多模式`catch`子句
- en: With this new feature, Swift will allow multiple error-handling blocks inside
    a `do catch` clause. Take a look at the following example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新特性，Swift将允许在`do catch`子句内部有多个错误处理块。看看下面的例子。
- en: 'Imagine that we have a `performTask()` function that can throw different types
    of `TaskError` errors:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`performTask()`函数，它可以抛出不同类型的`TaskError`错误：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Prior to Swift 5.3, if we want to handle different `TaskError` cases inside
    a `do catch` block, we need to add a `switch` statement inside the `catch` clause,
    complicating the code, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 5.3之前，如果我们想在`do catch`块内部处理不同的`TaskError`情况，我们需要在`catch`子句中添加一个`switch`语句，这使得代码变得复杂，如下所示：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now Swift 5.3 allows us to define multiple `catch` blocks so we can make our
    code more readable, as in the following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Swift 5.3允许我们定义多个`catch`块，这样我们可以使我们的代码更易读，如下面的例子所示：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We no longer need the `switch` inside the `catch` block.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要在`catch`块内部使用`switch`。
- en: Multiple trailing closures
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个尾随闭包
- en: 'Since the beginning of Swift, it has supported trailing closures syntax. See
    this classic example when using the `UIView.animate` method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从Swift开始，它就支持尾随闭包语法。看看使用`UIView.animate`方法时的经典例子：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we were able to apply the trailing closure syntax to the `completion`
    block to make our code shorter and more readable by extracting `completion` from
    the parentheses and removing its label:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们能够将尾随闭包语法应用到`completion`块中，通过从括号中提取`completion`并移除其标签，使我们的代码更短、更易读：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This closure syntax has some side-effects too. It can make our code hard to
    read if a developer is not used to our methods (think about our own API library
    that is not as well known as UIKit methods). It also makes the code a bit unstructured.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种闭包语法也有一些副作用。如果开发者不习惯我们的方法，它可能会使我们的代码难以阅读（想想我们自己的 API 库，它不像 UIKit 方法那样广为人知）。它也使代码显得有些无结构。
- en: 'With Swift 5.3, when we have multiple closures in the same method, we can now
    extract and label all of them after the first unlabeled parameter:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 5.3 中，当我们同一个方法中有多个闭包时，我们现在可以在第一个未标记参数之后提取并标记所有这些闭包：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice how now we have both closures outside of the parentheses, `UIView.animate(withDuration:
    0.3)`. Also notice how labeling the `completion` method makes it easier to understand,
    and how the code now looks more symmetrical in terms of structure, with all the
    closures written in the same way.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '注意现在我们有了括号外的两个闭包，`UIView.animate(withDuration: 0.3)`。也请注意，标记 `completion` 方法使它更容易理解，并且代码在结构上现在看起来更加对称，所有闭包都以相同的方式编写。'
- en: Synthesized comparable conformance for enum types
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为枚举类型合成的可比较遵从
- en: 'Swift 5.3 allow `enum` types with no associated values or with only `Comparable`
    values to be eligible for synthetized conformance. Let''s see an example. Before
    Swift 5.3, if we wanted to compare the values of an `enum`, we needed to conform
    to `Comparable`, and we needed to implement `<` and `minimum` methods (among other
    ways to achieve this):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 5.3 允许没有关联值或只有 `Comparable` 值的 `enum` 类型有资格进行合成遵从。让我们看看一个例子。在 Swift 5.3
    之前，如果我们想要比较 `enum` 的值，我们需要遵从 `Comparable`，并且需要实现 `<` 和 `minimum` 方法（以及其他实现此目的的方法）：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code is hard to maintain; as soon as we add more values to the `enum`,
    we need to update the methods again and again.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码难以维护；一旦我们向 `enum` 添加更多值，我们就需要一次又一次地更新方法。
- en: 'With Swift 5.3, as long as the enum doesn''t have an associated value or it
    only has a `Comparable` associated value, the implementation is synthesized for
    us. Check out the following example, in which we define an enum called `Size`,
    and we are able to sort an array of `Size` instances (without any further implementation
    of `Comparable` methods):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 5.3 中，只要枚举没有关联值或者它只有 `Comparable` 关联值，实现就会为我们合成。查看以下例子，我们定义了一个名为 `Size`
    的枚举，并且我们能够对 `Size` 实例的数组进行排序（无需进一步实现 `Comparable` 方法）：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we print the array with `print(sizes.sorted())`, we will get this in the
    console:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `print(sizes.sorted())` 打印数组，我们将在控制台得到以下内容：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note how the order of sorting is the same as the order in which we define our
    cases, assuming it is an increasing order: `.small` appears before `.large` when
    we sort the values. For instances of the same case that contain associated values
    (such as `.small(Int)` and `.large(Int)`) we apply the same principle when ordering:
    `.small(1)` appears before `.small(2)`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意排序的顺序与定义我们的情况的顺序相同，假设它是递增顺序：当我们排序值时，`.small` 出现在 `.large` 之前。对于包含关联值（如 `.small(Int)`
    和 `.large(Int)`) 的相同情况的实例，我们在排序时应用相同的原则：`.small(1)` 出现在 `.small(2)` 之前。
- en: Increase availability of implicit self in escaping closures when reference cycles
    are unlikely to occur
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当不太可能发生引用循环时，增加逃逸闭包中隐式 `self` 的可用性
- en: 'Sometimes the rule that forced all uses of `self` in escaping closures to be
    explicit was adding boilerplate code. One example is when we are using closures
    within a `Struct` (where the reference cycle is unlikely to occur). With this
    new change in Swift 5.3, we can omit `self`, like in this example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，强制所有逃逸闭包中的 `self` 使用都是显式的规则增加了样板代码。一个例子是当我们在一个 `Struct` 中使用闭包时（在这种情况下，引用循环不太可能发生）。在
    Swift 5.3 的这个新变化中，我们可以省略 `self`，就像下面的例子一样：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is also a new way to use `self` in the capture list (just by adding `[self]
    in`) when needed so that we can avoid using `self` again and again inside the
    closures. See the following example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，还有一种新的方式在捕获列表中使用 `self`（只需添加 `[self] in`），这样我们就可以避免在闭包内部反复使用 `self`。请看以下例子：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This change reduces the use of `self` in many situations and omits it completely
    when it is not needed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化减少了在许多情况下使用 `self`，并在不需要时完全省略它。
- en: Type-based program entry points – @main
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于类型的程序入口点 – @main
- en: 'Up until now, when developing a Swift program (such as a terminal app), we
    needed to define the program startup point in a `main.swift` file. Now we are
    able to mark a struct or a base class (in any file) with `@main` and a `static
    func main()` method on it, and it will be triggered automatically when the program
    starts:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在开发 Swift 程序（如终端应用程序）时，我们需要在 `main.swift` 文件中定义程序的启动点。现在我们能够在一个结构体或基类（在任何文件中）上标记
    `@main` 并定义一个 `static func main()` 方法，程序启动时它将被自动触发：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Important note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Take into consideration the following about `@main`: it should not be used
    if a `main.swift` file already exists, it should be used in a base class (or struct),
    and it should only be defined once.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下关于 `@main` 的内容：如果已经存在 `main.swift` 文件，则不应使用它；它应在基类（或结构体）中使用，并且只能定义一次。
- en: Use where clauses on contextually generic declarations
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在上下文泛型声明中使用 where 子句
- en: 'We can use `where` clauses in functions with generic types and extensions.
    For example, look at the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在具有泛型类型和扩展的函数中使用 `where` 子句。例如，看看以下代码：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We constrained the `sorted()` method on the extension of this `Stack` struct
    to elements that are `Comparable`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个 `Stack` 结构体扩展中的 `sorted()` 方法限制为 `Comparable` 元素。
- en: Enum cases as protocol witnesses
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举案例作为协议见证
- en: 'This proposal aims to lift an existing restriction, which is that enum cases
    cannot participate in protocol witness matching. This was causing problems when
    conforming enums to protocol requirements. See the following example of a protocol
    that defines a `maxValue` variable:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提案旨在取消一个现有的限制，即枚举案例不能参与协议见证匹配。这在将枚举符合协议要求时引起了问题。请看以下定义 `maxValue` 变量的协议示例：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can make `Int` conform to `Maximizable` like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使 `Int` 符合 `Maximizable`：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But if we try the same with an enum, we will have compile issues. Now it is
    possible to do this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们尝试用枚举做同样的事情，我们会遇到编译问题。现在可以这样做：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code now compiles properly with Swift 5.3.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码现在可以与 Swift 5.3 正确编译。
- en: Refine didSet semantics
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精炼 didSet 语义
- en: 'This is a very straightforward change, according to the Swift proposal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Swift 提案，这是一个非常直接的变化：
- en: If a `didSet` observer does not reference the `oldValue` in its body, then the
    call to fetch the `oldValue` will be skipped. We refer to this as a "simple" `didSet`.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `didSet` 观察者在其主体中不引用 `oldValue`，则将跳过获取 `oldValue` 的调用。我们称这种 `didSet` 为“简单”的
    `didSet`。
- en: If we have a "simple" `didSet` and no `willSet`, then we could allow modifications
    to happen in-place.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个“简单”的 `didSet` 而没有 `willSet`，那么我们可以允许修改就地发生。
- en: Float16
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Float16
- en: Float16 has been added to the standard library. Float16 is a half-precision
    (16b) floating-point value type. Before Swift 5.3, we had Float32, Float64, and
    Float80.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Float16 已添加到标准库中。Float16 是一个半精度（16b）浮点值类型。在 Swift 5.3 之前，我们有 Float32、Float64
    和 Float80。
- en: In this section, you have learned about the latest additions to the language
    in Swift 5.3 with code examples. Now, let's finish with the chapter summary.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你通过代码示例学习了 Swift 5.3 中语言的新增功能。现在，让我们以本章总结结束。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered new features on iOS 14, Swift 5.2, and Swift
    5.3\. We started by introducing App Clips and the fantastic possibilities they
    bring to iOS and macOS. We listed some real-world examples and we have learned
    the different ways to invoke them. We looked at the design guidelines and the
    streamlined process by using Sign in with Apple and Apple Pay. Later, we jumped
    into widgets with WidgetKit. We have described how you can create widgets of three
    different sizes and looked at their design guidelines. We have discovered the
    new features and improvements in augmented reality and machine learning. Privacy
    also gets some updates, allowing end users to control what they share in more
    detail. Finally, we also learned about new language features of Swift 5.2 and
    Swift 5.3\.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了 iOS 14、Swift 5.2 和 Swift 5.3 的新功能。我们首先介绍了 App Clips 以及它们为 iOS 和 macOS
    带来的惊人可能性。我们列出了一些现实世界的例子，并学习了调用它们的不同方式。我们研究了设计指南，并通过使用 Apple 登录和 Apple Pay 简化了流程。后来，我们跳入了
    WidgetKit 中的小部件。我们描述了如何创建三种不同大小的小部件，并研究了它们的设计指南。我们发现了增强现实和机器学习的新功能和改进。隐私也得到了一些更新，允许最终用户更详细地控制他们分享的内容。最后，我们还学习了
    Swift 5.2 和 Swift 5.3 的新语言功能。
- en: In our next chapter, we'll take a look at Dark Mode in iOS 14, covering everything
    you need to know about it and putting it into practice.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们将探讨 iOS 14 的深色模式，涵盖你需要了解的所有内容，并将其付诸实践。
- en: Further reading
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Apple Human Interface Guidelines (App Clips): [https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '苹果人机界面指南（App Clips）: [https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)'
- en: 'Apple Human Interface Guidelines (Widgets): [https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/](https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '苹果人机界面指南（小部件）: [https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/](https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/)'
