- en: '*Chapter 1*: What''s New in iOS 14?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During WWDC 2020, Apple introduced the new features and improvements included
    in iOS 14\. Using the latest features in your apps can make a huge difference
    for users in terms of engagement, positive reviews, and overall user experience.
    It can also lead to other benefits, such as being featured by Apple in the App
    Store, and having an advantage over competitors' apps in the same category.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Apple made Swift 5.2 available for developers on March 24, 2020\. Later in the
    year, Apple released Swift 5.3\. These versions focus on quality and performance
    improvements, new language features, and increased support for Windows platforms
    and Linux distributions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'There was another big announcement during WWDC 2020: Apple Silicon. Apple introduced
    its own processors to the world. Developers can start building apps and ship them
    by the end of 2020, starting a transition that will last two years. This transition
    will establish a common architecture across all Apple products. With a common
    architecture, it will be easier to create apps for the entire Apple ecosystem.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the basics of two of the most significant new
    features on iOS 14: App Clips and widgets. We will also cover the latest additions
    to augmented reality, machine learning, and user privacy. At the end of the chapter,
    you will learn about the new additions to the Swift language with some code examples.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics of iOS 14,
    Swift 5.2, and Swift 5.3:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Introducing App Clips
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing WidgetKit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements in augmented reality
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements in machine learning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements in user privacy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Swift 5.2
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Swift 5.3
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%201%20-%20Whats%20New).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to try out Swift 5.2 features as you read through the chapter,
    you need to install Xcode version 11.4 or later: [https://itunes.apple.com/app/xcode/id497799835](https://itunes.apple.com/app/xcode/id497799835).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Introducing App Clips
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**App Clips** allow users to discover your app in a fast and lightweight manner.
    With App Clips, a user can quickly use a feature of your app even without having
    the app installed on their phone. Let''s see an example of what an App Clip looks
    like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 − App Clip UI'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.01_B14717.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 − App Clip UI
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'App Clips should be lightweight, brief, and finish a user task in seconds.
    Let''s see some use cases of App Clips:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: An App Clip to order coffee when you pass by the coffee shop door and tap on
    an NFC tag.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An App Clip to rent an electric bike parked in the street, just by scanning
    a QR code on it. Also, you can use Sign in with Apple and Apple Pay to avoid forms
    and interface complexities, allowing you to rent the bike in seconds.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An App Clip to pre-order from the menu in a restaurant and save time while you
    wait to be seated.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An App Clip that triggers when you tap around NFC spots in an art gallery or
    a museum and displays augmented reality scenes on your iPhone.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the possibilities with App Clips are endless. Now that we have
    covered what an App Clip is, we are going to explain the user's journey using
    an App Clip (from the invocation to the end). We will cover the invocation methods
    (how to trigger an App Clip to appear). Finally, we will explore the recommended
    guidelines when building an App Clip.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: App Clip user journey
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now explore the whole process and steps in more detail, starting from
    when the user discovers your App Clip to when the user finishes the App Clip journey.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we have an app to rent electric bikes on the street. There
    are several stages involved in the App Clip process:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 − App Clip process and steps'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.02_B14717.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 − App Clip process and steps
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps of an AppClip are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Invocation method**: The App Clip invocation method is how the user can trigger
    and open an App Clip. For our example with the electric bike rental, a user scans
    a QR code placed in the bike with their device camera, and the App Clip opens
    on the home screen. The invocation method, in this case, is the QR code. We will
    explore more of them later in the chapter.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**User Journey**: After the invocation, the App Clip presents some options
    for the user to choose from (for example, 1-hour rental for $2 and 24-hour rental
    for $5). The user makes the desired selections inside the App Clip.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Accounts and Payment**: In our rental bike example, our App Clip needs to
    identify which user is renting the bike, and the user needs to pay for the service.
    Some App Clips will not require a registered user account nor payment to work;
    this step is optional.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Full app recommendation**: When the rental of the bike is settled and ready,
    your App Clip can recommend the user to download your complete app, so the next
    time the user can use it instead of the App Clip. Suggesting the entire app is
    an optional step, but it is very much recommended.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have an overview of the high-level steps of an App Clip, let's review
    some parts in more detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: App Clips invocation methods
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that in order to display an App Clip, the user needs to invoke
    it or discover it. We discussed before that it could be invoked by a QR code,
    an NFC tag, or a link in a message. Here is a summary of the options available:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'App Clip codes: Each App Clip code includes a QR code and an NFC tag so that
    a user can scan it with their camera or tap on it. It also works with individual
    NFC tags and QR codes.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safari App Banner
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Links in messages
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place cards in Maps
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recently used App Clips category in the new App Library on iOS 14
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss now the recommended guidelines from Apple when designing and developing
    your App Clip.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: App Clips guidelines
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make App Clips effective, lightweight, and easy to use for the
    user, Apple has several guidelines:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Focus on the essential task of your app: Suppose that you have a coffee shop
    app with lots of different features, including allowing the user to collect points,
    order coffee, save user preferences, buy coffee gift cards, and so on. Your app
    should not display such a big set of functionalities all at once. The App Clip
    should only provide the most important task (for this example, just the feature
    to order coffee). If the user needs more features, they can download the full
    app.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App Clips should be fast and easy to use from the start to the end of the process.
    Avoid using complex UIs, too many menus, detailed views, and other elements that
    can cause the user to spend too much time on it.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App Clips should be small in size, so fast to download. Include all the assets
    necessary inside the App Clip but avoid big downloads.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid complex user account creation processes in your App Clip. Just '**Sign
    in with Apple**'.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid requiring the user to enter complex and error-prone credit card forms
    and details. When necessary, try using Apple Pay.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When users finish with the App Clip task, they can't go back to it. Your App
    Clip can suggest the user install the full app to keep users engaged later on.
    But do it in a non-intrusive, polite way, for example, after the user journey
    finishes and without making it mandatory.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App Clips provide the option to send or schedule notifications up to 8 hours
    after launch in order to fulfil any required tasks. But it is not recommended
    to use this feature for purely marketing purposes.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you have learned what an App Clip is, the journey that a user
    will go through while using it, the different invocation methods, and the recommended
    guidelines when building an App Clip for your app. In [*Chapter 14*](B14717_14_Final_ASB_ePub.xhtml#_idTextAnchor457),
    *Creating an App Clip for Your App*, we will create an App Clip for an existing
    app to see a practical example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s jump into another exciting new feature that comes with iOS 14:
    WidgetKit.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Introducing WidgetKit
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users and developers have been requesting a particular feature for years: they
    all wanted to be able to have widgets on their home screen. Widgets allow users
    to configure, personalize, and consume little pieces of relevant data from their
    home screen. They also allow developers to offer users glanceable content and
    create added value for their apps.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a preview of how a **widget** (in this case Calendar and Reminders
    widgets) looks on the home screen on the iPhone:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 − iOS Home screen with Widgets'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.03_B14717.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 − iOS Home screen with Widgets
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Now it is possible on iOS 14, macOS 11, and later versions. Developers can create
    widgets across iOS, iPadOS and macOS using **WidgetKit** and the new **widget
    API** for SwiftUI.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The **Smart Stack** on iOS 14 contains a set of different widgets, including
    the ones that the user opens frequently. If the user enables **Smart Rotate**,
    Siri can highlight relevant widgets within custom stacks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Widgets created on iOS 13 and earlier
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Widgets created before iOS 14 can't be placed on the home screen, but they are
    still available on the Today View and macOS Notification Center.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: After this introduction to the new widgets, let's see what options we have when
    building a widget and look at the design guidelines from Apple.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Widgets options
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Users can place widgets on the home screen or the Today View on iOS, or the
    Today View on iPad and the Notification Center on macOS.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Widgets come in three sizes: small, medium, and large. Each size should have
    a different purpose. This means that a bigger version of a widget should not be
    just the same as the small one but with bigger font and images. The idea of having
    different sizes for a widget is that the bigger the size, the more information
    it should contain. For example, a weather widget will provide just the current
    temperature in the small version, but it will also include a weekly forecast in
    the medium one.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Users can arrange widgets in different parts of their screen, and even create
    stack widgets to group them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to develop a widget, developers need to create a new extension for
    their app: a **widget extension**. They can configure the widget with a timeline
    provider. A timeline provider updates the widget information when needed.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: If a widget needs some configuration (for example, selecting a default city
    in a weather app, or multiple cities to display in a large weather widget), developers
    should add a custom Siri intent to the widget extension. Doing so automatically
    provides the widget with a customization interface for the user.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Widget guidelines
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a widget for iOS 14 or macOS 11, take into account the following
    design guidelines:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Focus your widget on the feature of your app. If your app is about the stock
    market, your widget can display the total value of the user's portfolio.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each widget size should display a different amount of information. If your cycling
    tracker widget displays the current calories burned today in the small widget,
    it can also display the calories per day of the week in the medium widget and
    add extra information such as km/miles traveled in the large widget.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer dynamic information that changes during the day to fixed information;
    it will make your widget more appealing to the user.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer simple widgets with fewer configuration options, compared to complex
    widgets with more options.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets offer tap target and detection, letting the user select and tap on them
    to open detailed information in the app. Small widgets support a single tap target,
    medium and large widgets support multiple targets. Try to keep it simple.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support dark mode. Also, consider using SF Pro as the font and SF Symbols if
    needed.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we have had an introduction to the new widgets and WidgetKit.
    We have covered the different options available and the design guidelines when
    building a widget. In the next section, we are going to cover the new improvements
    and additions to augmented reality in iOS 14.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Improvements in augmented reality
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the new ARKit 4 for iOS 14 and iPadOS 14, there are four big new features:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Location Anchors** allow developers to place AR scenes at geographic coordinates.
    Location Anchors enable users to display those AR experiences at specific locations,
    landmarks, and places around the world.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extended Face** tracking support allows AR experiences accessible via the
    front camera in devices with the A12 Bionic chip or a later version.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RealityKit** will enable developers to add video textures to any part of
    the AR scene or AR object. Video textures also include spatialized audio.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARView` – `Environment` object. Scene Understanding contains four options:
    **Occlusion**, where real-world objects occlude virtual objects; **Receives Lighting**,
    which allows virtual objects to cast shadows on real-world objects; **Physics**,
    which enables virtual objects to interact with the real world physically; and
    **Collision**, which enables collisions between virtual objects and real-world
    objects.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Activating the **Receives Lighting** option automatically turns on **Occlusion**.
    Activating the **Physics** option automatically turns on **Collision**.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we have seen the improvements in augmented reality. Let's now
    review what's new in machine learning.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Improvements in machine learning
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improvements to Core ML presented during WWDC2020 will help developers with
    the development of their machine learning apps, with improvements that upgrade
    your app models, secure them, and group them in targeted collections. We are going
    to cover in this section the new Core ML Model Deployment, the new model collections
    with targeted deployments, and the new model encryption.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Core ML Model Deployment, collections, and targeted deployments
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most significant features introduced in WWDC 2020 for Core ML is
    `mlmodel` file from the cloud.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Developers will be able to create **machine learning model collections** on
    the cloud and update them on CloudKit. Apps will download those collections and
    stay up to date, with no version upgrading process in the middle. However, developers
    don't control the download process. The app will detect that there is a new model
    version available and will download it when the system decides it's appropriate
    (for example, in the background while the phone is locked and charging on a Wi-Fi
    connection). So, developers should take into account that the model update may
    or may not be fast or in real time. The operating system will have the last word.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful feature of model collections is that they can be targeted to different
    users (for example, users on devices with varying capabilities, such as iPhones
    vs iPads). Assigning different models to different users can be done with **targeted
    deployments** applied to collections. There are six options available to configure
    and target the model that the device will deploy: language code, device class,
    operating system, operating system version, region code, and app version.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Model encryption
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting on iOS 14 and macOS 11, Core ML can automatically encrypt the Core
    ML models.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will encrypt the compiled model, `mlmodelc` (not the original `mlmodel`).
    The decryption happens when the app is instantiated and occurs on the device.
    Moreover, the decryption result is not stored anywhere; it is just loaded into
    memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'More good news on this: Xcode will help you to create an encryption key, associate
    it with your developer account, and it will be stored in the Apple servers automatically.
    You can always download a local copy for yourself, but the process is not seamless.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: When the encryption key is stored in Apple servers, the file is `.mlmodelkey.`
    When you want to encrypt your model, you just need to add `--encrypt {YourModel}.mlmodelkey`
    to the compiler flags. If you prefer using CloudKit, you just need to provide
    the encryption key when creating the model archive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The drawback of this process is this: when the app instantiates, it needs to
    have an internet connection with the Apple servers to download the encryption
    key and decrypt your model. If for any reason there is no connectivity, you need
    to implement your fallback process inside the completion errors of the new `{YourModel}.load()`
    method. The completion handler will throw a `modelKeyFetch` error if the encryption
    key is not available, and you can act accordingly.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: You should not include the encryption key in your app bundle. It is not necessary,
    and it can compromise your data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discovered how we can upgrade our machine learning
    models without updating our apps, how we can group models into collections and
    assign them to a different type of users/devices, and how we can have our models
    encrypted and keep our machine learning data safe with no effort. In the next
    section, we are going to cover the additions to user privacy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Improvements in user privacy
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With iOS 14, Apple is giving users more control over their privacy and personal
    data in different ways:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The App Store will show the privacy practices of every app, so the user will
    be able to check them before downloading the app.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an app is using the camera or the microphone, an indicator will appear
    in the top-right corner of the phone indicating it. The Control Center will keep
    a history of which apps have used them recently.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps can offer users to keep the account they already have but integrate it
    with **Sign in with Apple**.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Approximate Location** is a new option for location services that gives a
    less accurate location for apps that shouldn''t need your exact location.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limited Photos library access: users can now grant access to selected photos
    only instead of to the entire library.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each new version of iOS, Apple is giving users and developers more and more
    control over the privacy settings. In this section, we have seen new additions
    that keep the user location and their photos more private, improvements on letting
    the user know when an app is using the camera or the microphone, and the addition
    of extra information about an app's usage of data and privacy on its App Store
    page. The next section focuses on the changes that Swift 5.2 introduces in the
    language.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Swift 5.2
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced by Apple (on March 24, 2020), Swift 5.2 has handy features focused
    on improving the developer experience and providing additional language features.
    Some of the new language features seem to be oriented toward enhancing the functional
    programming style. Let's review these new features with some code examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Key path expressions as functions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This new feature allows developers to use key path expressions such as `\Root.value`
    wherever `(Root) -> Value` functions are allowed. Let's see it in action.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `Car` struct with two properties, `brand` and `isElectric`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, let''s instantiate an array of `Car` structs with two cars, one that''s
    electric and one that''s not electric:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if we want to filter this `cars` array and get only the electric cars
    in it, we used to do it like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We could also do it this way:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, with Swift 5.2, we are able to do this more briefly:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you print the results, you will see that the output is the same:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that this applies to more cases, such as `map`, `compactMap`, and wherever
    the `(Root) -> Value` function is allowed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The **SE-0249** proposal contains all the details behind this change. For additional
    reference and the motivation behind the proposal, you can check the original document
    at [https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md](https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Callable values of user-defined nominal types
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This new feature allows values that have a method whose base name is `callAsFunction`
    to be called like a function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easier to explain this concept with a simple example. Let''s create a
    struct called `MyPow` that helps us to calculate the power of a number, given
    the base number:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can calculate the `pow` of the `base` just by doing the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This `print` statement will have the following result:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, with Swift 5.2, we can calculate the `pow` of the base but using this
    method instead:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the same output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Swift **SE-0253** proposal document contains all the details behind this
    change. For additional reference and the motivation behind the proposal, you can
    check the original document at [https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md](https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Subscripts can now declare default arguments
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When declaring a subscript, we are now able to assign a default value for an
    argument.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see it in action with an example. We create a `Building` struct that
    contains an array of `String` representing floor names. We add a subscript to
    get the name of a floor with a given index. If the index doesn''t exist, we want
    to get the default value, `Unknown`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see in the following output that when we access index `0` with `building[0]`,
    we return the value `Ground Floor`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The console output is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And in the following scenario, when we access the index `5` with `building[5]`,
    we return the value `Unknown`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The console output is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code example shows how we can make use of default arguments when using
    subscripts and how it can be helpful to tackle edge cases.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Lazy filtering order is now reversed
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with a lazy array and filter, there is a new change in the order
    of the operations applied to the filters chain. Take a look at the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Swift 5.2, this code will print the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is because the `.filter { $0 % 2 == 0 }` statement is applied before the
    `.filter { print($0); return true }` statement.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: However, if we execute this code in a Swift version prior to 5.2, we will notice
    that the order will be the opposite. First, we will print all the numbers; then,
    we will filter and get only the even ones. The `.filter` statements will execute
    from bottom to top.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This behavior will change again if we remove `.lazy` from the code. Then, regardless
    of the Swift version, we will see the output as only `2` and `4`. The filters
    will be applied from top to bottom, as expected.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This change can break your code and the logic of your app. Make sure you review
    for any similar scenario when updating your code to Swift 5.2 or later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: New and improved diagnostics
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Swift 5.2, error messages have improved in quality and precision. In the
    previous version, the compiler tried to guess the exact location of an error by
    breaking down expressions into smaller pieces. But this method left some errors
    out there.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Now the compiler, when encountering failures while trying to infer a type, records
    the location of those elements. These recordings allow the compiler to detect
    the exact error later on if needed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example compiled in Swift 5.1 versus Swift 5.2 and the output
    on each version. Look at this code which contains an error:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In Swift 5.2, we get a clear error in the exact location where it happens,
    and with an accurate reason:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the compiler is telling us that we are trying to use a member
    of the enum that doesn't exist, `c`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to compile the same code in Swift 5.1, we will see a different (and
    incorrect) error message:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The improvements in the compiler errors make iOS developers' day-to-day debugging
    much more comfortable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned about the latest additions to the language
    and the improved diagnostics on Swift 5.2 with code examples. Now, let's jump
    into the features of Swift 5.3.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Swift 5.3
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced by Apple during 2020, the main goal in Swift 5.3 is to enhance quality
    and performance and to expand the number of platforms on which Swift is available
    by adding support for Windows and additional Linux distributions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's review some of the new language features.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Multi-pattern catch clauses
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this new feature, Swift will allow multiple error-handling blocks inside
    a `do catch` clause. Take a look at the following example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have a `performTask()` function that can throw different types
    of `TaskError` errors:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Prior to Swift 5.3, if we want to handle different `TaskError` cases inside
    a `do catch` block, we need to add a `switch` statement inside the `catch` clause,
    complicating the code, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now Swift 5.3 allows us to define multiple `catch` blocks so we can make our
    code more readable, as in the following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We no longer need the `switch` inside the `catch` block.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Multiple trailing closures
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the beginning of Swift, it has supported trailing closures syntax. See
    this classic example when using the `UIView.animate` method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we were able to apply the trailing closure syntax to the `completion`
    block to make our code shorter and more readable by extracting `completion` from
    the parentheses and removing its label:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This closure syntax has some side-effects too. It can make our code hard to
    read if a developer is not used to our methods (think about our own API library
    that is not as well known as UIKit methods). It also makes the code a bit unstructured.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'With Swift 5.3, when we have multiple closures in the same method, we can now
    extract and label all of them after the first unlabeled parameter:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice how now we have both closures outside of the parentheses, `UIView.animate(withDuration:
    0.3)`. Also notice how labeling the `completion` method makes it easier to understand,
    and how the code now looks more symmetrical in terms of structure, with all the
    closures written in the same way.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Synthesized comparable conformance for enum types
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift 5.3 allow `enum` types with no associated values or with only `Comparable`
    values to be eligible for synthetized conformance. Let''s see an example. Before
    Swift 5.3, if we wanted to compare the values of an `enum`, we needed to conform
    to `Comparable`, and we needed to implement `<` and `minimum` methods (among other
    ways to achieve this):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code is hard to maintain; as soon as we add more values to the `enum`,
    we need to update the methods again and again.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'With Swift 5.3, as long as the enum doesn''t have an associated value or it
    only has a `Comparable` associated value, the implementation is synthesized for
    us. Check out the following example, in which we define an enum called `Size`,
    and we are able to sort an array of `Size` instances (without any further implementation
    of `Comparable` methods):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we print the array with `print(sizes.sorted())`, we will get this in the
    console:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note how the order of sorting is the same as the order in which we define our
    cases, assuming it is an increasing order: `.small` appears before `.large` when
    we sort the values. For instances of the same case that contain associated values
    (such as `.small(Int)` and `.large(Int)`) we apply the same principle when ordering:
    `.small(1)` appears before `.small(2)`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Increase availability of implicit self in escaping closures when reference cycles
    are unlikely to occur
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes the rule that forced all uses of `self` in escaping closures to be
    explicit was adding boilerplate code. One example is when we are using closures
    within a `Struct` (where the reference cycle is unlikely to occur). With this
    new change in Swift 5.3, we can omit `self`, like in this example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is also a new way to use `self` in the capture list (just by adding `[self]
    in`) when needed so that we can avoid using `self` again and again inside the
    closures. See the following example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This change reduces the use of `self` in many situations and omits it completely
    when it is not needed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Type-based program entry points – @main
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until now, when developing a Swift program (such as a terminal app), we
    needed to define the program startup point in a `main.swift` file. Now we are
    able to mark a struct or a base class (in any file) with `@main` and a `static
    func main()` method on it, and it will be triggered automatically when the program
    starts:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Important note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Take into consideration the following about `@main`: it should not be used
    if a `main.swift` file already exists, it should be used in a base class (or struct),
    and it should only be defined once.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Use where clauses on contextually generic declarations
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `where` clauses in functions with generic types and extensions.
    For example, look at the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We constrained the `sorted()` method on the extension of this `Stack` struct
    to elements that are `Comparable`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Enum cases as protocol witnesses
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This proposal aims to lift an existing restriction, which is that enum cases
    cannot participate in protocol witness matching. This was causing problems when
    conforming enums to protocol requirements. See the following example of a protocol
    that defines a `maxValue` variable:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can make `Int` conform to `Maximizable` like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But if we try the same with an enum, we will have compile issues. Now it is
    possible to do this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code now compiles properly with Swift 5.3.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Refine didSet semantics
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a very straightforward change, according to the Swift proposal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: If a `didSet` observer does not reference the `oldValue` in its body, then the
    call to fetch the `oldValue` will be skipped. We refer to this as a "simple" `didSet`.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a "simple" `didSet` and no `willSet`, then we could allow modifications
    to happen in-place.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Float16
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Float16 has been added to the standard library. Float16 is a half-precision
    (16b) floating-point value type. Before Swift 5.3, we had Float32, Float64, and
    Float80.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned about the latest additions to the language
    in Swift 5.3 with code examples. Now, let's finish with the chapter summary.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered new features on iOS 14, Swift 5.2, and Swift
    5.3\. We started by introducing App Clips and the fantastic possibilities they
    bring to iOS and macOS. We listed some real-world examples and we have learned
    the different ways to invoke them. We looked at the design guidelines and the
    streamlined process by using Sign in with Apple and Apple Pay. Later, we jumped
    into widgets with WidgetKit. We have described how you can create widgets of three
    different sizes and looked at their design guidelines. We have discovered the
    new features and improvements in augmented reality and machine learning. Privacy
    also gets some updates, allowing end users to control what they share in more
    detail. Finally, we also learned about new language features of Swift 5.2 and
    Swift 5.3\.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll take a look at Dark Mode in iOS 14, covering everything
    you need to know about it and putting it into practice.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apple Human Interface Guidelines (App Clips): [https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '苹果人机界面指南（App Clips）: [https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)'
- en: 'Apple Human Interface Guidelines (Widgets): [https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/](https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '苹果人机界面指南（小部件）: [https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/](https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/)'
