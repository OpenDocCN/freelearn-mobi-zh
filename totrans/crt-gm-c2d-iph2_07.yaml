- en: Chapter 7. Playing Pool, Old School
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will be developing another project using the Box2D physics
    engine. Our emphasis in this chapter will be on how to easily implement multiple
    control methods, as well as alternate rule sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing multiple control schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a rules engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game is…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game in this chapter is an old-school, top-down pool game. While our goal
    is to have suitably realistic movements, our emphasis will be on a fun arcade-style
    game. The main reason for this is it is impossible to accurately simulate the
    physics of a physical pool table without using a full 3D environment. Since we
    are working in 2D, we will not have features such as backspin, putting "English"
    on the ball, and so forth. We will also be using "bar room" variations on the
    games we implement. We have made this choice because there are literally hundreds
    of variations of each established game, so we are opting for "more fun" rather
    than "official rules". The game will be a pass-and-play two player game.
  prefs: []
  type: TYPE_NORMAL
- en: Overall design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make a 2D pool game, there are really only a few objects we will need to
    render on the screen. The table will be made of the side rails and the pockets.
    The rest of the table, as far as we are concerned, is just graphic fluff. Of course,
    we will need to build the 15 numbered pool balls and the cue ball. We will also
    need a cue stick, which we will create as a sprite but it will not be a body in
    the Box2D physics simulation. Why not? If we were to create the pool cue as a
    physics-enabled body, then we would have to consider the "unintended hits" of
    the pool cue running into other (non-cue ball) balls on the table. While this
    might happen on a real table, it is generally undesirable. Instead, we will use
    the pool cue as a visual "marker" of the planned shot, with the distance from
    the ball acting as our measure of the strength of the shot. Most of the interactions
    on the pool table will be handled by the Box2D simulation itself, so that will
    be the easy part.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus more on the control mechanisms and the rules engine in this chapter.
    We will adopt two different touch-based control mechanisms, and we will build
    a rules engine that can play "bar style" Eight Ball as well as Nine Ball. As we
    said in the introduction, we are using "bar rules" as a baseline approach. Feel
    free to extend the rules engine however you see fit to play pool your way.
  prefs: []
  type: TYPE_NORMAL
- en: Building the table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first task at hand is to build the pool table. We will start by looking
    at our definitions, because we will be using these extensively throughout this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPDefinitions.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with `typedef` `enum` statements by now. We create the
    `BallID` type to represent the numbered balls for simplicity. To be able to easily
    convert from `NSInteger` values to `BallID` values, we set the numbered balls
    to equal the number on the balls. The cue is zero, and we also keep a reference
    for `kBallNone` as `-1` so we can cover our bases (useful when detecting a table
    scratch). We define two types of `RackLayoutType`, diamond and triangle. We also
    set our `GameMode` to be stripes, solids, ordered, or stripes versus solids. We
    use this last value to identify the game before anyone has pocketed any stripes
    or solids (also known as the table being "open"). We also have the `#define` statement
    to define the `kPocket` as `500`. We will use this in our collision detection
    to determine when a ball hits a pocket. Finally, there is also the `PTM_RATIO`
    , which you should be familiar with from [Chapter 5](ch05.html "Chapter 5. Brick
    Breaking Balls with Box2D"), *Brick Breaking Balls with Box2D*, which defines
    the Points-To-Meters ratio.
  prefs: []
  type: TYPE_NORMAL
- en: The Box2D world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With any Box2D simulation, we need to define a world for the bodies to inhabit.
    (If you need to brush up on the Box2D world and the structures inside it, please
    go back and re-read the *Box2D: a primer* section in [Chapter 5](ch05.html "Chapter 5. Brick
    Breaking Balls with Box2D"), *Brick Breaking Balls with Box2D*.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we did in [Chapter 5](ch05.html "Chapter 5. Brick Breaking Balls with Box2D"),
    we define our world with zero gravity, since we do not want any downward force
    on our environment. We allow bodies to sleep, and we allow the continuous physics
    to run, which will increase the accuracy of the simulation. Finally, we establish
    a contact listener. For this game, we use a nearly identical contact listener
    to the one in [Chapter 5](ch05.html "Chapter 5. Brick Breaking Balls with Box2D"),
    *Brick Breaking Balls with Box2D*. The only difference is we have changed the
    naming convention from BR… to OP… for all the elements in it. We will not repeat
    the code here, so please feel free to refer to that chapter or to the source code
    bundle for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building the rails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rails are one of the most interacted elements on the pool table, so we
    will build them first. Since the physical properties of all six rails are the
    same, we will build a single method to create a rail and pass parameters to that
    method to create each rail. We''ll look at the "core code" first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes three arguments: the name of the sprite image, the position
    for the sprite and body, and an array of `verts` to define the shape of the rail.
    The rails are defined using the `PhysicsSprite` class, which we also saw in [Chapter
    5](ch05.html "Chapter 5. Brick Breaking Balls with Box2D"), *Brick Breaking Balls
    with Box2D*. A `PhysicsSprite` object, as you may recall, is like a normal `CCSprite`,
    except it holds a reference to the body attached to it. Cocos2d will automatically
    keep the sprite''s position and rotation in sync with the underlying Box2D body.'
  prefs: []
  type: TYPE_NORMAL
- en: For the rails, we build the sprite using the passed image name, and then build
    the associated body. After the body is built, we attach the body to the sprite
    with the `setPhysicsBody` method. Next, we define the shape for the rail. Because
    the rails are very simple shapes, we know that we only need four `verts` to define
    each rail. When we define the fixture, we set a pretty high density of `50.0f`,
    a moderate friction of `0.3f`, and an in-the-middle value for restitution of `0.5f`.
    These have been tweaked during play testing to give a good "bounciness" to the
    rails that feels more like a real table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can look at how we call this method to define the six rails for the
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This looks like a lot of code to begin with, but it is the same pattern repeated
    six times to accommodate each rail.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each rail, we define the position based on the center point of the sprite,
    as we are using the default centered anchor point for the rails. We then define
    the array of four `verts` that define the four sides of each rail. You will notice
    that they are not square, as we need the tapered ends around the pockets to make
    a smoother "mouth" for each pocket. Finally, we call the `createRailWithImage`
    method we just reviewed. We now have our rails, which look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the rails](img/9007_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building pockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our rails built, we need to add the only other "interactive"
    elements of the table itself, the pockets. We will also use a similar two-method
    approach to build them, as the only difference in the pockets is their location.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we follow the same basic formula we used for the rails. We build a sprite,
    body, shape, and fixture. Even though we don't technically need a sprite for the
    pocket, we will use our trusty `whitespeck.png` that we used heavily in [Chapter
    6](ch06.html "Chapter 6. Cycles of Light"), *Cycles of Light*. In this case, we
    color it black, so that it disappears into the pocket. (For debugging, it is also
    helpful to change it to a brighter color, so that you can see where the pockets
    are.) So why use it at all? We like using a sprite here because it allows us to
    add a tag, `kPocket`, to the sprite. This makes the collisions a little simpler,
    as we will be able to use sprite tags for all objects whose collisions we care
    about (pockets and balls only).
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that, unlike the rails, we don't need this to be "physics enabled",
    so the pocket sprites are using normal `CCSprite` classes instead of `PhysicsSprite`
    classes. When we define the shape for the pocket, we use a circle with a radius
    of `7.0`. This is because we need a larger target to detect a ball in pocket.
    We made these circles a little smaller than the actual physical size of the pockets
    on the table, because we want to allow balls to hang on the edge of the pocket,
    just as they do on a real table.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we define the `pocketFixtureDef`, you will notice we did not use
    any of the usual values such as `density`, `friction`, or `restitution`. This
    is because we do not want the pockets to participate in the "bouncing around"
    of the physics simulation. Instead, we simply set `isSensor` to `YES`. A sensor
    is a physics object that registers in the collision handler, but does not actually
    have any physical "presence" in the world. We will register a contact when something
    touches the sensor, but other objects will be able to pass through the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can look at the second method used to drive the creation of the pocket
    sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the extra code we needed to build the rails in their second method,
    this one is really simple. We have six pockets, so we simply call the previous
    method and pass it the coordinates for the pocket, and we're done.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the cue stick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cue stick is purely cosmetic. We will be controlling the "hitting" of the
    cue ball programmatically, and the cue stick is used as an aiming point of reference
    only. Nevertheless, without a cue stick, the game wouldn''t "feel" like pool.
    The cue stick will be on the screen only during aiming, and will be faded out
    when we make the shot. Because the cue stick is deeply connected with the way
    the controls are built, we will save the discussion on how the cue stick will
    be used for later in the chapter. For now, let''s take a look at how we build
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As it is primarily cosmetic, we use a normal `CCSprite`. We set the `anchorPoint`
    property to the tip of the cue (centered at the top). As we rotate the cue stick,
    this will allow it to pivot on its tip. We also set the visible property to `NO`,
    because the stick will only be made visible when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We won''t be able to progress much farther without discussing the rules engine.
    Some of the configuration of the game, including what type of rack we use for
    the balls, is controlled by the rules. We will be using a separate "rules" class,
    `OPRulesBase`. Let''s look at the complete header for this class first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first five variables are all parameters we need to define the rules of the
    game. Because these will all be used from the `OPPlayfieldLayer` class, we must
    make them all properties as well. The other variables you see will be explained
    later in the discussion as we use them. The classes in this header give you a
    little bit of a "sneak preview" on how we will approach the full rules engine
    implementation later in the chapter. As you can see, most of the classes are "questioning"
    methods to "ask" the rules engine about the status of various conditions. These
    methods will vary based on the type of game, which is why these "question methods"
    are part of the rules engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we move to the implementation file, we will begin by looking at the custom
    `init` method we will use for the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty simple `init` method that calls the `loadRulesWith:gameName`
    method, and sets a couple of starting values for the table variables (`isTableScratch`
    and `isBreak`). Before we get to the `loadRulesWith` method, there are other methods
    we need to review first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `readPlist` and `getDictionaryFromPlist` methods we have seen before, also
    in the *Brick breaker* section in [Chapter 5](ch05.html "Chapter 5. Brick Breaking
    Balls with Box2D"), *Brick Breaking Balls with Box2D*. The `readPlist` method
    will load the named plist into memory, and return it as a general type `id`. The
    `getDictionaryFromPlist` method casts the result of `readPlist` as an `NSDictionary`,
    and returns it to the calling method. That's all it takes to get our plist into
    an `NSDictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: Rules.plist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go any further into the loader, we should see what the plist for
    our rules actually looks like. This is the plist itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rules.plist](img/9007_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the plist, the first level in the structure is the named
    game (**Eight Ball**, **Nine Ball**), and inside those Dictionaries are a set
    of Strings and Booleans that define the details of the game. Because we have chosen
    to represent the `RackStyle` and `GameMode` elements as strings, we will need
    to convert those into something more usable by the engine.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the pieces together to understand the `loadRulesWith` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We begin by loading in the `rules.plist` using the `getDictionaryFromPlist`
    method. We load the rules into the `ruleBook` dictionary, and then we create another
    dictionary, `theseRules`, which gets the named game dictionary from inside our
    `ruleBook` dictionary. From there, we begin populating our base rules properties
    from that "game level" dictionary. Because an `NSDictionary` stores objects only,
    we have to convert the values for several of the keys before we can insert them
    into the properties. For `LastBall`, we convert the object to the `integerValue`
    of the object (which is stored as an `NSNumber`). You will notice that we convert
    this to an integer, but then we cast it to a `BallID` type when we set the property's
    value. This is where the numeric representations we set in the `typedef` `enum`
    in the `OPDefinitions.h` file come in handy. Because, for example, `kBallNine`
    is internally represented as the integer `9`, we can freely bridge across these
    data types. Had we used other values for the `typedef` `enum`, we would have been
    forced to do some more complex conversions, probably with an extended `switch`
    statement. Similarly, we get the `boolValue` of both the `OrderedBalls` and `ReplaceBalls`
    keys, so they will "fit" into our Boolean properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two rule properties need special consideration. Because we have chosen
    to store those as strings in the `rules.plist`, we have to do string comparison
    to convert them into the values our game wants to use. Let''s look at the conversion
    methods now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For both of these methods, we pass it the string that comes from the dictionary,
    and compare the strings to our defined values. We can then return the `typedef`
    `enum` values that correspond to the chosen options. We could have avoided this
    by storing the rack types and game modes as numbers in the plist, but that makes
    the human reading (and writing) of the plist less easy to understand. Because
    we only perform these comparisons when loading the rules, there is no performance
    drawback on using this slower approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the final lines of the `loadRulesWith` method, we assign the current `gameMode`
    (that we just loaded) to the `player1Goal` and `player2Goal` properties. This
    identifies for the players what their goal in the game is going to be. Why is
    this at a player level? It really comes down to the inherent complexity in the
    game of Eight Ball, where one player will be shooting for stripes, and the other
    for solids. Before any balls are sunk, the table is "open", so all shots (except
    for the last ball) are legal. So, in this case, the starting game is "Stripes
    vs Solids" for both players, until the game progresses to the point where one
    is deemed to have a goal of "Stripes" and the other "Solids".
  prefs: []
  type: TYPE_NORMAL
- en: We also check if the `gameMode` is `kOrdered`. This means that balls will be
    sunk in numeric order. If this is the case, the `nextOrderedBall` variable is
    set to `kBallOne`. If the game is anything else, `nextOrderedBall` will be ignored.
    Finally, `currentPlayer` always starts as player 1.
  prefs: []
  type: TYPE_NORMAL
- en: Rack 'em up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what type of game we will be playing, we have enough information
    to build the rack on the table. First we need to know how to build the balls.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the builders we used to create the rails and pockets, with
    a few exceptions. We pass both the `BallID` and `startPos` variables to this method,
    so we know which ball to build, and where to build it. We use the class `OPBall`,
    which is a subclass of `PhysicsSprite`, to represent the balls. The `OPBall` class
    is a direct pass-through of the `PhysicsSprite`, with no added functionality.
    We do this because we gain the ability in the collision handler to use the `isMemberOfClass`
    method to determine if the object is a ball or not. If we designed the collision
    handler differently, we could have used `PhysicsSprite` for the balls instead.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the ball instantiation, we follow the pattern of building a
    body, assigning it to the sprite, creating the fixture, and attaching it to the
    body. We use a `density` of `1.0f`, a `friction` of `0.5f`, and a `restitution`
    of `0.9f` to give a good "pool ball feel" to the fixtures. We then use a few additional
    members of the body object that we haven't really used before. We turn off `SetFixedRotation`,
    so the balls will be able to rotate, rather than remaining at their original rotation.
    We set the linear damping to `0.7f`, and the angular damping to `0.5f`. Together,
    these will help simulate the effect of the balls rolling on the table felt. This
    is the one place in this game where we are "faking" the physics world, because
    we are not actually creating a table top object. Linear damping will slow the
    ball's forward progress, and angular damping will help slow the ball's rotation.
    Together with the fixture's settings, these provide a fairly realistic feel for
    a pool table.
  prefs: []
  type: TYPE_NORMAL
- en: Building the rack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can build the rack. Let''s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we first define the positions where the balls will be located.
    We use a shorthand notation for most of the `CGPoint` positions. The abbreviation
    means row and ball in row, so `r1b1` is the leftmost ball in the first row past
    the foot spot (the foot spot is the front "point" of the rack). We define all
    the positions first, and then check which rack we want. If we called for a triangle
    rack (as in Eight Ball), then we will fill in every position with a ball. If we
    need a triangle rack (used in Nine Ball), then we only use 9 of the 15 positions
    defined. The positions, you will notice, are actually a little too close together.
    This is intentional, because Box2D will nudge the balls a little bit so they all
    fit. The end result is that the balls are all touching, which is known as a "tight
    rack" in pool.
  prefs: []
  type: TYPE_NORMAL
- en: Player HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are building a two-player game, let''s take a quick look at how we build
    the Heads-Up Display to provide feedback to the players:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We build simple labels to identify player 1 and player 2, and we also create
    target labels, which we will use to identify "stripes" or "solids" for the player.
    We use our `whitespeck.png` image again, this time to make a nice green line that
    will identify which player''s turn it is, using the `markPlayer` variable to hold
    that sprite. Finally, if we are playing a game with ordered balls, we also add
    the legend **Next Ball** at the top of the display. As we have discussed the goals
    a few times, let''s see how they are identified for the players:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Referring back to our discussion in the rules about player goals, here we simply
    check each player''s goal. Depending on if it has been set to stripes or solids,
    we update the appropriate target labels to display to the users what they are
    shooting for. Then we check if it is a game with ordered balls. If it is, we check
    with the rules engine to determine what the lowest numbered ball on the table
    is, and we add an image of that ball to the top of the display, next to the **Next
    Ball** label. You will notice we call the `ballSpritesOnTable` method, so we should
    go there now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we iterate through all the bodies in the Box2D world, and find those that
    have sprites attached. You will notice we check to make sure the `tag` is lower
    than `100`. This is because the pockets also have sprites attached, but we set
    the `#define` for `kPocket` to be `500`, so we don't accidentally add a pocket
    sprite to the array. With all balls accounted for, we return an `NSArray` to the
    calling method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only significant player method we have left is the active player change:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is a short and sweet method. If it is currently player 1's turn, we change
    the `currentPlayer` to player 2, and vice versa. We move the `markPlayer` sprite
    to the appropriate side of the display (below the P1 or P2 labels), and we call
    the `displayMessage` method to give feedback to the players.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the game, there are many times we need to present messages to the
    player. Rather than building the same basic message display repeatedly, we have
    consolidated that functionality in the `displayMessage` and `dismissMessage` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we first check to make sure we are not already displaying a
    message. If we are (as indicated by the `isDisplayingMsg` Boolean variable), then
    we wait for `0.1` second and call it again with the same parameters. If there
    is no message displaying, we create a label with the requested message and display
    it on the screen. If the `userDismiss` is `NO`, then we set a 2 second timer and
    then call `dismissMessage`. If the `userDismiss` is `YES`, then the message will
    be displayed until the user touches the screen to dismiss it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `dismissMessage` method is simple. If we didn't need to have the user dismiss
    option, then we could have easily embedded this in a `CCCallBlock` action in the
    `displayMessage` method, but we wanted the extra flexibility here.
  prefs: []
  type: TYPE_NORMAL
- en: Collision handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get to the final stretch covering the controls and the rest of the
    rules engine, we now know enough about our game that we can implement the collision
    detection, which uses the same contact listener we used in [Chapter 5](ch05.html
    "Chapter 5. Brick Breaking Balls with Box2D"), *Brick Breaking Balls with Box2D*.
    We will look at the `update` method in pieces, so we can discuss it along the
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm` (`update`, part 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first important thing to see here is that we have really ramped up the number
    of iterations that the simulation uses in each step, to increase the accuracy
    of the simulation. As we only have a small number of bodies, it does not adversely
    affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: We step the world forward and then, using C++ vectors, we iterate through all
    the contacts that have been collected by the contact listener. For each contact,
    we get the bodies and their related sprites, which we store in `bodyA`, `bodyB`,
    `spriteA`, and `spriteB`. We hold the sprites as `CCSprite` objects, because we
    can't be sure which subclass of `CCSprite` the object will be.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm` (`update`, part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we compare `spriteA` and `spriteB` to see if one of them is
    an `OPBall` object, and the other has a tag of `kPocket`. If this is true, then
    a ball has landed in a pocket, so we add the ball to the `toDestroy` vector to
    deal with later. As you probably recall from [Chapter 5](ch05.html "Chapter 5. Brick
    Breaking Balls with Box2D"), *Brick Breaking Balls with Box2D*, we cannot guarantee
    in which order the bodies will be reported to us, so we have to check everything
    in both ways.
  prefs: []
  type: TYPE_NORMAL
- en: The next check is to determine if two balls collided with each other. If there
    are two balls, then we check to see if one of them is the cue ball. If it is,
    and this is the first contact of the cue ball with another ball since the cue
    ball was last hit, then we keep a reference to that tag in the variable `firstHit`.
    Why do we do this? Pool has a rule that requires you to hit your own ball first,
    before the cue ball touches any other balls. By storing the first ball touched
    in the `firstHit` variable, we will be able to properly track what the cue ball
    hit first. We will use this information later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm` (`update`, part 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this final section of the `update` method, we proceed to destroy any bodies
    (balls) that were added to the `toDestroy` vector, and we send the corresponding
    sprites to the `sinkBall` method.
  prefs: []
  type: TYPE_NORMAL
- en: We then check if the table is moving, that is, are any balls still rolling.
    If there are, we block any user input (with the `isTouchBlocked` Boolean variable),
    and then we call the `checkTable` method to see what happened. We use the `pendingTable`
    variable to allow us to only check the status of the table when everything is
    at rest. We will set `pendingTable` to `YES` when we take a shot, and this section
    will wait until everything is settled, and then check the table once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get to the `checkTable` method later, but for now let''s look at the
    `sinkBall` and `isTableMoving` methods to see how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to do something fancy with the balls that are sunk, this would
    be the place. For our game, we are quite content with simply having the balls
    added to the `ballsSunk` array and then remove the ball from the layer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To check if the table is moving, we could simply poll to see if all bodies are
    sleeping. The problem with this approach is that it takes a while for physics
    bodies to completely stop and go to sleep. Through testing, we determined that
    this was too long and boring. So instead, we check the velocity length of each
    body. If the value is greater than `0.005f`, then the ball is still noticeably
    moving. Below that speed, everything is crawling slowly enough for us to proceed
    with checking the table.
  prefs: []
  type: TYPE_NORMAL
- en: Building the control base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now to the point where we can build the controls for the player. As we
    said in the introduction, we will be building two control schemes. The first is
    what we call "one touch". This controller will track from the moment the touch
    is detected until it is released. While the touch is on the screen, we will update
    the cue stick to follow the touch, aiming at the cue ball. When the touch is ended
    (finger lifted) we will take the shot from the position of the cue stick, and
    the distance from the cue ball will determine the strength of the shot.
  prefs: []
  type: TYPE_NORMAL
- en: The second control scheme, which we call "two touch", will be similar in the
    way it tracks the shot, but it will not automatically take the shot when the touch
    is lifted. Instead, a button that says **Shoot!** will appear at the bottom of
    the screen, and touching that button will take the shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both control schemes share some code, so we have created the `OPControlBase`
    class, which we will then subclass with `OPControlOneTouch` and `OPControlTwoTouch`
    to handle the specifics of those two control schemes. We will start by looking
    at the `OPControlBase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPControlBase.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the header we can see the variables we need to track for both control schemes.
    We will keep a reference to the main playfield layer, since we need to interact
    with it. We keep track of the `shotLength` variable (used as the strength), the
    `plannedHit` variable (the point we will hit from), and the `aimAtPoint` variable,
    which will be the cue ball's position. We also have the `cueBallInHand` sprite.
    This will be used when we are positioning the cue ball on the table, as we really
    don't need or want an actual physics object to ram into other balls as the player
    is moving the cue ball around.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPControlBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is the primary method that is shared between the two control schemes. The
    input parameter, `convLoc`, is the converted location from the touch handler,
    which we will pass here after the necessary conversions to OpenGL space. We determine
    the `offset` as a subtraction of the `aimAtPoint` position (the cue ball) from
    the `convLoc` position (touch location). We then use the `ccpNormalize` function
    to convert that `offset` into the smallest possible coordinates that still represent
    the angle desired. This will allow us to control the power of the hit ourselves,
    without having to compensate for the distance in our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `mp` variable as a reference to the main playfield layer, we proceed
    to move the pool cue to the correct location, and we use the `ccpToAngle` function
    to convert the `approach` variable to something more useful. This creates a value
    in radians. We use `CC_RADIANS_TO_DEGREES()` to convert this to a degree-based
    angle, and add it to `90` (which we need to accommodate the rotation of our graphic
    for the cue stick), and multiply the whole thing by `-1`. This gives us the correct
    angle we need to make the cue stick point at the cue ball from the point we are
    currently touching.
  prefs: []
  type: TYPE_NORMAL
- en: We then calculate the `shotLength` value using some simple geometry. If the
    length is less than `4` (too close to the ball) or greater than `75` (too far
    away to be sensible), we reject the hit and hide the cue stick. Otherwise, we
    calculate the `hitPower` (the `shotLength` divided by `6`, to make it a more sensible
    power level), and we use that to determine the planned hit. This method does not
    actually make the shot. Rather, it updates the visuals and generates all the calculations
    we need to be ready to make the shot. The astute reader will also notice that
    we are setting the `shootButton` sprite to be visible. This is only in existence
    in our two touch control class, so in the case of the one touch control, this
    call will send a message to a `nil` object, which is completely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPControlBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `hideCue` method takes away the cue stick and resets all variables to baseline
    values because we don't have any shot to make. This is important to do here, because
    this will be called not only after the shot is made, but also when the shot is
    invalidated (stick too far away, and so on). We are again adjusting the `shootButton`
    sprite's visibility, if the button's sprite exists. If it doesn't exist, then
    this line is ignored automatically.
  prefs: []
  type: TYPE_NORMAL
- en: One-touch control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will look at the one touch control first. The class `OPControlOneTouch` is
    a subclass of `OPControlBase`, but does not have any additional variables needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPControlOneTouch.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We begin the `ccTouchBegan` method by checking for a couple of special cases.
    If `isTouchBlocked` is `YES` on the main playfield, then we reject the touch.
    We then check for any user-dismissed messages, to see if we need to clear those
    messages. If the main playfield has the `isGameOver` flag set, then the next touch
    will return to the main menu. We now convert the touch location to the `convLoc`
    variable using the standard coordinate transforms. If the player should have the
    cue ball in hand (after a scratch), then the touch will create a new `cueBallInHand`
    sprite. Finally, if the touch is inside the table, then we set the `aimAtPoint`
    position to be the cue ball's position, and we call the `updateCueAimFromLoc`
    method we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPControlOneTouch.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `ccTouchMoved` method follows the same approach as the `ccTouchBegan` method.
    If the ball is in hand, then the touch movement will move the `cueBallInHand`
    sprite to the touched location, so the ball will follow the touch. If the ball
    is not in hand, then we again call `updateCueAimFromLoc` to update the cue stick.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPControlTouchOne.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The final method of our control is `ccTouchEnded`, which makes the shot when
    the touch is lifted. For this controller, we want this to cause the shot to be
    made. As in the previous two touch methods, we first check if the ball is in hand.
    If it is, then we call the main playfield to create a new "real" cue ball at that
    location, and discard the `CCSprite` we were using to represent it. Here we also
    check the `shotLength` value to make sure it is not too long, to avoid a shot
    being made with an invisible cue stick. (Without this check, the shot will still
    be made, whether you can see the stick or not!) Finally, we call to the main playfield
    to actually make the shot. Before we move on to see the two touch controls, let''s
    go back to the main playfield and see what the `makeTheShot` method does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When we make the shot, we set our `aimPoint` to match the controller's `aimAtPoint`
    (that is, the cue ball). We create a sequence of actions to give the illusion
    of hitting the ball with the cue stick. First, we move the stick rapidly at the
    `aimPoint`, then we use a `CCCallBlock` action to apply a linear impulse on the
    ball, and then we fade the cue out. As we have seen before, the `CCCallBlock`
    action here is effectively used to avoid the need to build another method. Everything
    inside the `^{ }` will be executed when this block is called in the sequence.
    Here it simply sets the `pendingTable` variable to `YES`.
  prefs: []
  type: TYPE_NORMAL
- en: The linear impulse is set using the `plannedHit` variable from the control class,
    and it applies it directly at the center of the cue ball. (Yes, pool purists,
    we are aware of the effects of hitting the cue ball off-center. For this game,
    we have opted to not include any offset controls. It's arcade pool, not a true
    pool simulator, after all!) You will notice that we add an additional `CCDelayTime`
    action after we fade out the cue, and then set the `pendingTable` to `YES`. Why
    do we do this? We need the `pendingTable` variable set to `YES` so the `checkTable`
    in the `update` method will work correctly when the table comes to rest. However,
    if we set it as soon as this method is called, the table checking will happen
    before the shot is made, because the table will still technically be "at rest"
    for the first half second or so of the action. As we need the balls to be moving
    before we set this variable, embedding it into the action sequence seemed like
    a natural fit.
  prefs: []
  type: TYPE_NORMAL
- en: Two-touch control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our second control method will use two touches, but much of the "plumbing"
    is very similar to the one touch controller. Let''s take a look and then discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPControlTwoTouch.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first difference is that we are using our own `init` method for the two
    touch control. This `init`, as you can see, simply creates the **Shoot!** button,
    and positions it at the bottom center of the screen, and sets its `visible` property
    to `NO`. We could recreate it each time we need it, but that seems wasteful, so
    we build it once, and toggle the visible property when we need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two touch control scheme in action looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-touch control](img/9007_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Filename:** `OPControlTwoTouch.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In `ccTouchBegan`, we follow the same code structure up to and including the
    `isBallInHand` variable evaluation. It is after that point that we see the differences.
    We still set the `aimAtPoint` variable to the cue ball's position, but then we
    check to see if the shoot button was touched. If it was, then we call `makeTheShot`.
    If there was any other touch on the table, then we update the cue stick's position.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPControlTwoTouch.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This method is exactly the same as the one touch version of this method. It
    will track the touch, and keep updating the cue stick (and all the power and distance
    variables) as the touch moves.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPControlTwoTouch.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Because we are not causing any automatic shot to happen when you release your
    touch, the only handling we need in the `ccTouchEnded` method is the handling
    for the `ballInHand` situation.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need to do for both control schemes. Looking over the code, there
    are some similarities where it would be possible to refactor so that the two touch
    class is a subclass of the one touch class (or vice versa), but we wanted to keep
    the two separate to make it easier to add other control schemes later on without
    having too much tangled code.
  prefs: []
  type: TYPE_NORMAL
- en: The rules engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are nearing the end of our journey through the pool hall. There is still
    one gaping hole in our game: the logic of the rules engine and how we use it.
    Earlier, we saw how we load the rules into our `OPRulesBase` class, and we have
    done a little in the `OPPlayfieldLayer` class with using the player goals to update
    the player''s display. We will dig into the rules engine with the smaller, simpler
    methods first.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Because every rule in the game of pool will depend on which player is taking
    their turn (especially in the case of Eight Ball), this is our helper method to
    determine what the current player's goal really is. This will be used by several
    of the other methods in this class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is the first of the "asking" methods we talked about earlier. We pass this
    method a `ballArray`, and "ask" if it contains the ball that was identified as
    the `lastBall` in the `rules.plist`. In Eight Ball, this is the ball numbered
    8\. In Nine Ball, this is the ball numbered 9\. In other games of your own making,
    it could be anything. You might ask, what exactly is in the `ballArray`? When
    we call this method during the `checkTable` method (we'll see this soon), we will
    be passing the `ballsSunk` array to this method, so it knows what balls were sunk
    during this turn only.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is the same idea as the `didSinkLastBall` method, except this time we are
    strictly checking to see if the cue ball was sunk, which is a scratch. Now we
    can move on to the slightly larger, more complex methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we pass this method the `firstBall` variable, which is the ball identified
    as the first ball hit in the `update` method we saw earlier. This is the first
    ball that the cue ball impacted. If the `firstBall` variable is set to the default
    `kBallNone`, it means the cue ball didn't hit any other balls, so this is a table
    scratch. If it is, we store that in the `isTableScratch` variable so we can use
    it later.
  prefs: []
  type: TYPE_NORMAL
- en: We then run through a `switch` statement on the goal for the current player.
    If the game is still `kStripesVsSolids` (so the table is open), then any ball
    except the ball numbered 8 is legal. If the goal is stripes, the ball number must
    be above 8\. If the goal is solids, the ball number must be a lower number than
    the 8\. Finally, if the game is ordered, then the first ball must be the `nextOrderedBall`
    *or* `isBreak` must be true (that is, it is the break shot, so anything is legal
    to hit first).
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `didSinkValidBall` method is used to parse out whether the player sank a
    ball that was valid for them. We again receive the `ballsSunk` array as a parameter
    and iterate through all balls in the array. We go through a `switch` statement
    to determine what their current goal is, and go through a similar check to see
    if the ball was valid. Since we are iterating through the entire array of sunk
    balls, at least one ball sunk must be valid for the player, in order to return
    a `YES` to the calling method. The one major difference is that here we are also
    checking to see if the ball sunk has the same value as the `lastBall` variable.
    Unless we are trying to sink the last ball, that is not a valid play, so it will
    return `NO`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The last major method in this class is `isValidLastBall:withBallsOnTable:`.
    This again follows a similar pattern to the other classes we have reviewed. In
    this case, we are looking through the balls that are still on the table, rather
    than the balls that were sunk. This will only be evaluated if the `lastBall` was
    sunk, so we are more concerned with what's left on the table. If we are playing
    Eight Ball, for example, and the current player is playing solids, then there
    must not be any ball numbered lower than the `lastBall` left on the table. If
    we are playing an ordered game, then all of the balls on the table must be sunk
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one small but very useful method left in the `OPRulesBase` class,
    so let''s look at it before we return to the playfield:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPRulesBase.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When you're playing an ordered ball game, like Nine Ball, the player must always
    aim at the lowest numbered ball. Since balls can be sunk out of order, we can
    not simply increment the ball number as the next ball. Instead, we look for each
    ball, starting at number 1 and continuing to 15, and checking the `tableBalls`
    array to see what the lowest numbered ball on the table really is. When we find
    a ball, we set that value to the `nextOrderedBall` variable, and return control
    to the calling method.
  prefs: []
  type: TYPE_NORMAL
- en: Putting balls back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move to the `checkTable` method to tie it all together, we have one
    more method in the playfield to see. As we have a rule defined as `ReplaceBalls`,
    we need a way to put illegally sunk balls back on the table. This is defined in
    the plist, so you can set this to your favorite rules. Playing "bar style", this
    is usually not an option, as coin-operated tables do not allow you to retrieve
    balls once they are sunk.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We receive the `sunkBalls` array as the parameter passed as `ballArray` to this
    method. If the rules specify `replaceBalls` = `YES`, then we first look through
    the balls to make sure the cue ball is not in the array. If it is, we delete it
    from the `ballArray`. We then iterate through all balls in the `ballArray`, and
    put them back on the table following the same positioning we used when we first
    built the rack. If they are too close to other balls on the table, they will be
    nudged out of the way by Box2D. We have made the decision that there is probably
    very little likelihood of there being six or more balls that need to be replaced
    at the same time, so we have capped this method to only replace the first six
    balls. Realistically, three is probably the highest number of balls we have ever
    seen that need to be replaced, and that is a rare occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have finally reached the `checkTable` method. As you recall, this is called
    by the `update` method after the balls have come to rest after a shot. This is
    where the rest of the game interacts with the rules engine, so we will take this
    method in pieces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.m` (`checkTable`, part 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We begin by setting up a lot of Boolean variables to hold the "answers" from
    the method calls to the rules engine. We then go through each of the conditions
    from the rules engine and populate the Boolean variables with the returned values
    from those methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm` (`checkTable`, part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The entirety of the `checkTable` method has to be specifically ordered to make
    sure that the highest priority events are handled first. The first check we make
    is to see if the `lastBall` was sunk. If it was, we then check `isValidLastBall`
    to see if this was a legal sinking of the `lastBall`. Then we further check to
    see if the player scratched at the same time. If it is a valid last ball and the
    player did not scratch, then the game is over – the current player wins. Otherwise,
    the player has sunk the `lastBall` too early in the game, and they have lost.
    If the player loses, we display a disparaging message, and end the game, declaring
    their opponent a winner.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm` (`checkTable`, part 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If the player scratched (without the last ball being sunk), we let the player
    know they scratched, and the cue ball is now in hand for the other player. We
    also identify that we need to `replaceBalls` (if the option is set), and that
    we need to change players.
  prefs: []
  type: TYPE_NORMAL
- en: If the player did not scratch (cue ball in a pocket), but did table scratch
    (cue ball did not touch any other balls), then we simply change players. You will
    notice that this section is a chain of `if…else` statements, because these conditions
    are all mutually exclusive, and we don't need to check the remaining conditions
    if we have met an earlier one.
  prefs: []
  type: TYPE_NORMAL
- en: Next we check to see if the player did not hit a valid first ball (they hit
    an opponent's ball first), then we call `replaceBalls`, display a message, and
    indicate a player change.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm` (`checkTable`, part 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this final section of code, if `isValidSink` is `YES`, then we add the balls
    sunk by the player to their own `ballsSunk` array, and if their goal is still
    `kStripesVsSolids`, then we look at the first ball sunk, and that determines whether
    they are stripes or solids.
  prefs: []
  type: TYPE_NORMAL
- en: If nothing of interest happened, we simply change players.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining checks in this method are to handle the `isPlayerChange` and `replaceBalls`
    conditions we set earlier in the method, if needed. With that, the core gameplay
    is complete, and we're ready to play some pool!
  prefs: []
  type: TYPE_NORMAL
- en: The playfield init method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have omitted some small areas of code, specifically those related to the
    main menu itself. We have built convenience methods to start the game with a specified
    rule set and a specified control scheme. (If you want to see these in detail,
    please refer to the code bundle for this chapter.) There''s really nothing that
    we haven''t done before in earlier chapters, but we will briefly go over the `initWithControl:andRules:`
    method of the `OPPlayfieldLayer` class, so you can see how we have structured
    the initialization of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we call our custom `init` method with `NSString` representations
    of the control and rule names. We do this for clarity's sake more than for compact
    programming. As we discussed in the review of the `rules.plist` design, we sometimes
    need to sacrifice some small amount of optimizations in favor of readable code.
    Isn't it easier to know that the rule set we want is "Eight Ball" rather than
    game number 1? If these were checks that were happening repeatedly throughout
    the game, we would never make this performance trade-off. However, in all cases
    where we have used these strings, the code is run once per game, so the microseconds
    it takes does not impact performance at all.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have covered a lot of code in this chapter. We have come back to Box2D
    after being away from it for a while, and we have built a pretty fun pool game.
    Along the way, we have explored alternate control schemes, how to make the same
    engine run with different game rules with a minimum of messy code in the core
    class, and hopefully learned a few new approaches to coding issues, too. Did we
    build a world-class pool simulator? Absolutely not. We built a fun game that you,
    the reader, can expand on and explore on your own. There are many ways you could
    expand on this game. Add new rules to play pool your way. We kept arrays of each
    player's sunken balls, but we never did anything interesting with them. (That
    was intentional.) Perhaps you could draw images of the balls from those arrays
    on the screen to show who sank which balls? The possibilities are there, and by
    now you should be ready to hack and slash at the code and make it your own.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will be building a top-down shooter, using tile maps
    and onscreen joysticks. It also has a strange fruit versus vegetable theme, just
    for fun. See you there!
  prefs: []
  type: TYPE_NORMAL
