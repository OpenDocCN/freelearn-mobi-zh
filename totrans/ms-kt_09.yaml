- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Runtime Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we build our Android apps, there are some functionalities that require permissions
    to be granted for them to function properly. Due to privacy and data security
    policies, we as developers can not automatically grant permissions to the apps
    that we develop. We need to inform the users of the permissions that the apps
    need and why they need them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand runtime permissions and how to request them
    in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding runtime permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting permissions at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding runtime permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`requestPermissions()` and `checkSelfPermission()`. The user only needs to
    grant permission once during the lifetime of the app.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the features that need permission to be granted to work are camera,
    location, microphone and storage. Before using them, ensure that a user has permission
    to use them. If the user has not granted permission, you must request it from
    them. If the user has denied the permission, you must show a dialog explaining
    why you need it and ask the user to grant it from the settings. If the user has
    granted permission, you can use the feature. Failing to do these checks often
    results in an app crashing or a feature not working. If your app targets Android
    6.0 and above, you must request these permissions at runtime, and the user must
    grant the permission for the app to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow for requesting permissions is shown in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The runtime permissions flow](img/B19779_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The runtime permissions flow
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding diagram, this is the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial step is to *declare* the permission in the manifest file. This is
    done by adding the permission to the manifest file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding the permission to the manifest file, we must *design the UX* for
    the feature that needs the permission to be granted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is *waiting for the user to use* the feature that needs permission
    to be granted. At this point, we check whether the user has granted permission.
    If the user has granted permission, we proceed to use the feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user *has not granted permission*, we first check whether we need to
    *show a rationale* that explains why we need permission. If we need to show the
    rationale, we show it with explanations and then request permission from the user.
    If we do not need to show the rationale, we just request permission from the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the permission is requested, we wait for the *user to grant or deny* permission.
    If the user grants permission, we proceed to use the feature. If the user denies
    permission, we allow the app to work, but the user cannot use the feature that
    needs permission to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this flow in mind, let us look at how to implement it in code. We are going
    to request permission to access a location.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting permissions at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will follow the steps covered in *Figure 9**.1* to request runtime permissions
    for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by adding the permission to the manifest file. We will request
    permission to access the user’s location. To do this, we add the following permission
    to the manifest file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This specifies that our app will be using the `ACCESS_COARSE_LOCATION` permission.
    Declaring permissions in the manifests is crucial for enhancing security, user
    awareness, and overall app compatibility. By explicitly specifying the actions
    or resources apps require access to permissions informs users during installations,
    allowing them to make informed decisions about granting or denying access. This
    declaration ensures compatibility across different Android versions and devices,
    facilitates inter-app communication, and supports intent filtering to control
    component access. Permissions also play a role in runtime permission requests
    for dangerous permissions and help maintain platform compatibility. Additionally,
    Play Store reviews declare permissions as part of the submission process, contributing
    to adherence to policies and guidelines. In essence, manifest-based permission
    declarations are fundamental for creating secure, transparent, and user-controlled
    environments in our apps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next thing is to create the UX for the feature that needs permission. We
    will create a dialog to request permissions from the user. It will also have the
    logic that shows the rationale to the user if permission was previously denied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a new file in the `view` package named `PermissionDialog.kt` and
    add the utility functions to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first function checks whether the permission has been granted using the
    `ContextCompat.checkSelfPermission()` function. The second function checks whether
    we need to show the rationale to the user. This is done using the `ActivityCompat.shouldShowRequestPermissionRationale()`
    function. This function returns `true` if the app has requested this permission
    previously and the user denied the request. If the user turned down the permission
    request in the past and chose the `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, let us create a sealed class that will be used to represent the state
    of the permission request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file named `PermissionAction.kt` in the `data` package, and add
    the following code to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The class has two states, `PermissionGranted` and `PermissionDenied`. A user
    can either grant or deny permission.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us create the dialog that will be used to request permission from
    the user. Head back to the `PermissionDialog.kt` file and add the following code
    to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s break down the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have created a composable, `PermissionDialog`, which takes three parameters,
    `context`, `permission` string, and a `permissionAction` callback, which passed
    the option the user selected to the call site.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the composable, the first thing we do is check whether permission has
    been granted. If permission has been granted, we call the `permissionAction` callback
    with the `PermissionGranted` state and return.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we also created `permissionsLauncher`, which is used to request permission
    from the user. We use the `rememberLauncherForActivityResult()` function to create
    a launcher for the contract. We then use the launcher to request permission from
    the user. If the user grants the permission, we call the `permissionAction` callback
    with the `PermissionGranted` state. If the user denies the permission, we call
    the `permissionAction` callback with the `PermissionDenied` state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the permission has not been granted, we check whether we need to show the
    rationale to the user. If we need to, we show the rationale with explanations
    and then request permission from the user. If we do not need to show the rationale,
    we must request permission from the user. In our case, the rationale is `AlertDialog`,
    with two action items and a message explaining why we need the permission. The
    first action item is used to request permission from the user. The second action
    item is used to cancel the permission request. If we tap the `permissionAction`
    callback is called with the `PermissionDenied` state, and the dialog is dismissed.
    We also have two mutable states, `isDialogDismissed` and `isPristine`. The first
    is used to check whether the dialog has been dismissed. The second one let’s know
    whether the dialog was shown before. We use these states combined to know whether
    to show the dialog or not.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, if we do not need to show the rationale, we just request permission
    from the user. We use `SideEffect` to request permission from the user because
    we want to request permission from the user as soon as the dialog is shown.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we do not have an actual feature in our app currently that uses location,
    we are going to simulate permission flow with our `PetsScreen` composable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s head to the `PetsScreen.kt` file and modify it to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have only made a few changes to this file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we have added a `showContent` mutable state that is used to check whether
    we should show the content of the screen. We have also set the initial value of
    the state to `false`. We will use this state to show the content of the screen
    if the user grants permission. We also have the `context` variable used to get
    the screen’s context.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also added the `PermissionDialog` composable to the `PetsScreen` composable.
    We have passed the context and the permission – in this case, the `ACCESS_COARSE_LOCATION`
    permission – to the composable. We have also passed a callback to the composable
    that is used to get the state of the permission request. If the user grants the
    permission, we set the `showContent` state to `true` and show a toast with the
    `showContent` state to `false`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have added a check to see whether the `showContent` state is `true`.
    If the state is `true`, we show the content of the screen. If the state is `false`,
    we do not show the content of the screen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build and run the app. At first, we will see the permission dialog, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The permission dialog](img/B19779_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The permission dialog
  prefs: []
  type: TYPE_NORMAL
- en: Tap the **Don’t allow** option, which will show an empty white screen, since
    we don’t show any content when the user has not granted the app permission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The no permission screen](img/B19779_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The no permission screen
  prefs: []
  type: TYPE_NORMAL
- en: The next time we run the app, we will see the rationale dialog showing why the
    app needs permission.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The permission rationale](img/B19779_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The permission rationale
  prefs: []
  type: TYPE_NORMAL
- en: On this rationale dialog, we can either cancel the request or grant access.
    Tapping the **Grant Access** option should bring up the permission dialog shown
    in *Figure 9**.2*, and by tapping the **While using the app** option, we grant
    the app the location permission, and now, we should be able to see the list of
    cute cats once again. Running the app again does not show the dialogs, since we
    have already granted the app the location permission.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Cute cats](img/B19779_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Cute cats
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored what runtime permissions are and why we should
    declare and request permissions in our apps. Step by step, we learned how to request
    runtime permissions in our app and how to show permission rationale dialogs, explaining
    to users why we need access to runtime permissions in cases where they have denied
    apps access to permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn debugging tips and tricks, how to detect
    leaks using LeakCanary, how to inspect HTTPS requests/responses fired by our app
    using Chucker, and how to inspect the Room database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Code Analysis and Tests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will gain proficiency in debugging through a series of valuable
    tips and tricks. Unveiling the intricacies, you will discover techniques for detecting
    memory leaks within your app and adeptly inspecting HTTP requests triggered by
    your application. Our exploration extends to inspecting your local database, offering
    insights into its inner workings. Diving into Kotlin best practices, you will
    delve into code analysis for your application, addressing code smells for enhanced
    code quality. This part also includes a comprehensive exploration of testing methodologies,
    empowering you to seamlessly integrate tests across various layers of your MVVM
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19779_10.xhtml#_idTextAnchor121), *Debugging Your App*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19779_11.xhtml#_idTextAnchor135), *Enhancing Code Quality*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19779_12.xhtml#_idTextAnchor157), *Testing Your App*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
