<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Pulse Rate Sensor"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Pulse Rate Sensor</h1></div></div></div><p>In this chapter, we will start exploring the possibilities of using Arduino and Android in a health context. The most <a id="id516" class="indexterm"/>natural way to start off such an adventure is to create a project that involves an open source pulse rate sensor. This sensor will be connected to a BLE-equipped Arduino. The data will be displayed in an interesting way within the Android app to make the experience as seamless as possible.</p><p>The following will be the major takeaways from this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using a pulse rate sensor with Arduino to measure your heart rate</li><li class="listitem" style="list-style-type: disc">Connecting a BLE module to Arduino to transmit pulse rate data</li><li class="listitem" style="list-style-type: disc">Visualizing this data in an Android application</li></ul></div><div class="section" title="Hardware and software requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec41"/>Hardware and software requirements</h1></div></div></div><p>Let's first see<a id="id517" class="indexterm"/> what we need for this project. As usual, we will use an Arduino Uno board.</p><p>You will also <a id="id518" class="indexterm"/>need a heart rate sensor, which is the most important component of this chapter. We used a sensor that is compatible with Arduino, simply called the<a id="id519" class="indexterm"/> pulse sensor (<a class="ulink" href="http://pulsesensor.com/">http://pulsesensor.com/</a>).</p><p>The following is an image of the sensor we used:</p><div class="mediaobject"><img src="graphics/0389OS_10_01.jpg" alt="Hardware and software requirements"/></div><p>For wireless communications, we used the nRF8001 BLE breakout board that we<a id="id520" class="indexterm"/> used in previous chapters.</p><p>Finally, you will <a id="id521" class="indexterm"/>need a breadboard and some jumper wires to make the connections between the different parts.</p><p>This is the list of all of the hardware you will need for this project, along with links to find these parts on the web:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Arduino Uno board<a id="id522" class="indexterm"/> (<a class="ulink" href="https://www.adafruit.com/products/50">https://www.adafruit.com/products/50</a>)</li><li class="listitem" style="list-style-type: disc">nRF8001 breakout board<a id="id523" class="indexterm"/> (<a class="ulink" href="https://www.adafruit.com/products/1697">https://www.adafruit.com/products/1697</a>)</li><li class="listitem" style="list-style-type: disc">Heart rate sensor<a id="id524" class="indexterm"/> (<a class="ulink" href="http://pulsesensor.myshopify.com/products/pulse-sensor-amped">http://pulsesensor.myshopify.com/products/pulse-sensor-amped</a>)</li><li class="listitem" style="list-style-type: disc">Breadboard <a id="id525" class="indexterm"/>(<a class="ulink" href="https://www.adafruit.com/products/64">https://www.adafruit.com/products/64</a>)</li><li class="listitem" style="list-style-type: disc">Jumper wires<a id="id526" class="indexterm"/> (<a class="ulink" href="https://www.adafruit.com/products/1957">https://www.adafruit.com/products/1957</a>)</li></ul></div><p>On the software side, you will of course need the Arduino IDE. You will also need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The library<a id="id527" class="indexterm"/> for the nRF8001 chip, available at <a class="ulink" href="https://github.com/adafruit/Adafruit_nRF8001">https://github.com/adafruit/Adafruit_nRF8001</a></li><li class="listitem" style="list-style-type: disc">The <a id="id528" class="indexterm"/>aREST library to send commands to the robot, available at <a class="ulink" href="https://github.com/marcoschwartz/aREST">https://github.com/marcoschwartz/aREST</a></li></ul></div><div class="section" title="Configuring our hardware"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec67"/>Configuring our hardware</h2></div></div></div><p>We are <a id="id529" class="indexterm"/>now going to build the project by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, connect the BLE breakout board to the Arduino Uno board.</li><li class="listitem">Place the module on the breadboard.</li><li class="listitem">Connect the power supply of the module: <span class="strong"><strong>GND</strong></span> goes to prototyping shield <span class="strong"><strong>GND</strong></span> and <span class="strong"><strong>VIN</strong></span> goes to the prototyping shield +5V.</li><li class="listitem">Connect the different wires responsible for the SPI interface: <span class="strong"><strong>SCK</strong></span> to Arduino pin <span class="strong"><strong>13</strong></span>, <span class="strong"><strong>MISO</strong></span> to Arduino pin <span class="strong"><strong>12</strong></span>, and <span class="strong"><strong>MOSI</strong></span> to Arduino pin <span class="strong"><strong>11</strong></span>.</li><li class="listitem">Then connect the <span class="strong"><strong>REQ</strong></span> pin to Arduino pin 10.</li><li class="listitem">Finally, connect the <span class="strong"><strong>RDY</strong></span> pin to Arduino pin <span class="strong"><strong>2</strong></span> and the <span class="strong"><strong>RST</strong></span> pin to Arduino pin <span class="strong"><strong>9</strong></span>.<p>The following is a schematic diagram to help you out for this part:</p><div class="mediaobject"><img src="graphics/0389OS_10_02.jpg" alt="Configuring our hardware"/></div></li><li class="listitem">Now, connecting the pulse rate sensor is actually very simple. You simply need to connect the red wire to the Arduino +5V pin, the black cable to the Arduino GND pin, and the remaining pin to the Arduino A0 pin.</li></ol></div><p>This is an image of the fully assembled project:</p><div class="mediaobject"><img src="graphics/0389OS_10_03.jpg" alt="Configuring our hardware"/></div><p>If you want <a id="id530" class="indexterm"/>more details about the<a id="id531" class="indexterm"/> pulse rate sensor, you can visit the official documentation at <a class="ulink" href="http://pulsesensor.myshopify.com/pages/code-and-guide">http://pulsesensor.myshopify.com/pages/code-and-guide</a>.</p></div><div class="section" title="Testing the sensor"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec68"/>Testing the sensor</h2></div></div></div><p>We are now <a id="id532" class="indexterm"/>going to write some basic code to make sure that the pulse sensor is correctly wired and that it is not damaged. Thanks to the work done by the creator of the sensor, it is actually very easy to extract the heart pulse rate from the sensor readings. The following sketch starts by defining a lot of variables that are required for the calculation of the <a id="id533" class="indexterm"/>
<span class="strong"><strong>Beats Per Minute</strong></span> (<span class="strong"><strong>BPM</strong></span>):</p><div class="informalexample"><pre class="programlisting">// Sensor and pins variables
int pulsePin = 0;
int blinkPin = 13;

// Pulse rate variable
volatile int BPM;    

// Raw signal
volatile int Signal;

// Interval between beats
volatile int IBI = 600; // Default Inter Beats Interval

// Becomes true when the pulse is high
volatile boolean Pulse = false;

// Becomes true when Arduino finds a pulse (QS stands for Quantified Self here)
volatile boolean QS = false;</pre></div><p>In the <code class="literal">setup()</code> function<a id="id534" class="indexterm"/> of the sketch, we simply start the serial communications and initialize the readings from the pulse sensor:</p><div class="informalexample"><pre class="programlisting">// Start Serial
Serial.begin(115200);
  
// Sets up to read Pulse Sensor signal every 2mS
interruptSetup();</pre></div><p>Then, in the <code class="literal">loop()</code> function of the sketch, we constantly check to see if we found a heart beat, and we print it on the serial monitor if this is the case:</p><div class="informalexample"><pre class="programlisting">  // If heart beat is found
  if (QS == true) {
        
    // Print heart rate      
    Serial.print("Heart rate: ");            
    Serial.println(BPM);
        
    // Reset the Quantified Self flag for next time      
    QS = false;                       
   }
  
  // Wait 20 ms
  delay(20);
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Note that all of the code used <a id="id535" class="indexterm"/>in this chapter can be found in the GitHub repository of the book at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>.</p></div></div><p>It is now time to test the code. Before uploading the code to your board, it's recommended that you watch a video found at <a class="ulink" href="http://pulsesensor.myshopify.com/blogs/news/7406100-getting-started-video">http://pulsesensor.myshopify.com/blogs/news/7406100-getting-started-video</a> in order to understand how to put the sensor correctly on your finger.</p><p>You can now upload<a id="id536" class="indexterm"/> the code to your Arduino board and open the serial monitor. Then place the sensor on your finger. After a while (there can be strange readings at first), you should see your heart rate being displayed on the serial monitor. You will know that it is correct when the value is between 60 and 100 BPM (if you are in a resting state).</p></div></div></div>
<div class="section" title="Writing the Arduino sketch"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec42"/>Writing the Arduino sketch</h1></div></div></div><p>Now <a id="id537" class="indexterm"/>that we are sure that the sensor is working correctly, we can write the final Arduino sketch for this chapter. This sketch will <a id="id538" class="indexterm"/>perform the BPM measurements as before, and will also expose the BPM variable via the aREST API so that the measurements can be accessed via Bluetooth. As the sketch is really similar to the test sketch, we will only detail the changes here.</p><p>The sketch starts by importing the required libraries:</p><div class="informalexample"><pre class="programlisting">#include &lt;SPI.h&gt;
#include "Adafruit_BLE_UART.h"
#include &lt;aREST.h&gt;</pre></div><p>We also define the pins on which the BLE module is connected:</p><div class="informalexample"><pre class="programlisting">#define ADAFRUITBLE_REQ 10
#define ADAFRUITBLE_RDY 2     // This should be an interrupt pin, on Uno thats #2 or #3
#define ADAFRUITBLE_RST 9</pre></div><p>Then we create an instance of the aREST library and the BLE module:</p><div class="informalexample"><pre class="programlisting">aREST rest = aREST();

// BLE instance
Adafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);</pre></div><p>We also need to define a variable that will contain the BPM measurements and that will be exposed to the API:</p><div class="informalexample"><pre class="programlisting">int bpm = 0;</pre></div><p>In the <code class="literal">setup()</code> function, we need to initialize the BLE module:</p><div class="informalexample"><pre class="programlisting">BTLEserial.begin();</pre></div><p>We also give the project a name and ID:</p><div class="informalexample"><pre class="programlisting">rest.set_id("1");
rest.set_name("pulse_sensor");</pre></div><p>Still in the <code class="literal">setup()</code> function, we expose the BPM variable to the aREST API:</p><div class="informalexample"><pre class="programlisting">rest.variable("bpm",&amp;bpm);</pre></div><p>In the <code class="literal">loop()</code> function of the sketch, we assign the measured BPM to the variable that is exposed to the API:</p><div class="informalexample"><pre class="programlisting">bpm = BPM;</pre></div><p>Then, as <a id="id539" class="indexterm"/>usual, we <a id="id540" class="indexterm"/>process the incoming requests on the BLE module with the aREST API:</p><div class="informalexample"><pre class="programlisting">// Tell the nRF8001 to do whatever it should be working on.
BTLEserial.pollACI();
  
// Ask what is our current status
aci_evt_opcode_t status = BTLEserial.getState();
  
// Handle REST calls
if (status == ACI_EVT_CONNECTED) {
    rest.handle(BTLEserial);
  }
}</pre></div><p>Note that all the code for this chapter can be found in the GitHub repository of the bookat <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>. You can now upload the code <a id="id541" class="indexterm"/>to your Arduino board and move on to the development of the Android application.</p><div class="section" title="Setting up the Android app"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec69"/>Setting up the Android app</h2></div></div></div><p>The <a id="id542" class="indexterm"/>Android application that we will be creating will give us the ability to display the data that is measured by the pulse rate sensor within the Android app. In addition, it will show the BLE connection status, and there will be the <span class="strong"><strong>Refresh</strong></span> button to allow us to refresh the Bluetooth callback.</p><p>We will assume that you will have switched on the <code class="literal">Auto-Import</code> function within your preferences. If not, kindly activate it by going to the <span class="strong"><strong>Auto-Import</strong></span> preferences and selecting all available options. The <span class="strong"><strong>Auto-Import</strong></span> preferences are available on Mac and Windows as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On a Mac, navigate to <span class="strong"><strong>Android Studio</strong></span> &gt; <span class="strong"><strong>Preferences</strong></span> &gt; <span class="strong"><strong>Editor</strong></span> &gt; <span class="strong"><strong>Auto-Import</strong></span></li><li class="listitem" style="list-style-type: disc">On Windows, navigate to <span class="strong"><strong>File</strong></span> &gt; <span class="strong"><strong>Settings</strong></span> &gt; <span class="strong"><strong>Editor</strong></span> &gt; <span class="strong"><strong>Auto-Import</strong></span></li></ul></div><p>With all the necessary settings in place, we <a id="id543" class="indexterm"/>will start off by creating a new project where we will choose the following within the <span class="strong"><strong>New Project</strong></span> setup walkthrough:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Name</strong></span>: <code class="literal">Pulse Rate Sensor</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Minimum SDK</strong></span>: <code class="literal">18</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Project</strong></span>: <code class="literal">Blank Activity</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Activity Name</strong></span>: <code class="literal">PulseActivity</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Do</strong></span><span class="strong"><strong>main</strong></span>: <code class="literal">arduinoandroid.com</code></li></ul></div></div><div class="section" title="Laying out the Android user interface and setting permissions"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec70"/>Laying out the Android user interface and setting permissions</h2></div></div></div><p>In order<a id="id544" class="indexterm"/> to make this project work, we <a id="id545" class="indexterm"/>will need to first go to the Android <code class="literal">Manifest</code> file which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">AndroidManifest.xml</code>.</p><p>Since this Android application uses BLE to connect the Android physical device to the pulse rate sensor, we will need to add the following permissions to the Android <code class="literal">Manifest</code> file:</p><div class="informalexample"><pre class="programlisting">    &lt;uses-permission android:name="android.permission.BLUETOOTH"/&gt;
    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;</pre></div><p>The next step that we will be taking is setting up the very basic Android layout file so that we are able to implement the app functions.</p><p>In our project, we will navigate to the main layout file which can be accessed from <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">res</code> &gt; <code class="literal">layout</code> &gt; <code class="literal">activity_pulse.xml</code>.</p><p>There are a number of layout formats with Android user interface design, and in this particular case, we<a id="id546" class="indexterm"/> will be implementing two linear layouts: one will be <a id="id547" class="indexterm"/>designed to act as a placeholder for the graph view, and the other will support the different buttons and text views.</p><p>Replace the current code available in the layout file with the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;LinearLayout
    
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"&gt;

    &lt;LinearLayout
        android:id="@+id/rest"
        android:layout_width="fill_parent"
        android:layout_height="250dip"
        android:orientation="vertical"
        android:weightSum="1"&gt;

        &lt;TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textAppearance="?android:attr/textAppearanceLarge"
            android:id="@+id/pulseValueView"
            android:layout_gravity="center_horizontal"
            android:textSize="150dp"
            android:gravity="center"
            android:text="120"/&gt;
    &lt;/LinearLayout&gt;

    &lt;Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Refresh Connection"
        android:id="@+id/refreshBtn"
        android:layout_gravity="center_horizontal" /&gt;

    &lt;Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Get Pulse Rate"
        android:id="@+id/heartRateBtn"
        android:layout_gravity="center_horizontal" /&gt;

    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceLarge"
        android:text="Connection Status"
        android:id="@+id/connectionStsView"
        android:layout_gravity="center_horizontal" /&gt;
&lt;/LinearLayout&gt;</pre></div><p>The end <a id="id548" class="indexterm"/>result <a id="id549" class="indexterm"/>will look as follows within the IDE:</p><div class="mediaobject"><img src="graphics/0389OS_10_04.jpg" alt="Laying out the Android user interface and setting permissions"/></div><p>The text <span class="strong"><strong>120</strong></span> is <a id="id550" class="indexterm"/>meant to be a placeholder text to ensure that there is enough place within the user interface to <a id="id551" class="indexterm"/>accommodate the pulse rate readings. In the final implementation, you have the option of removing the placeholder text and leaving it blank.</p></div><div class="section" title="Coding the app's internals"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec71"/>Coding the app's internals</h2></div></div></div><p>We need to <a id="id552" class="indexterm"/>start off by declaring all the necessary variables that are needed to work with the Bluetooth logic, user interface, and for logging purposes:</p><div class="informalexample"><pre class="programlisting">    //Logging Variables
    private final String LOG_TAG = PulseActivity.class.getSimpleName();

    //User Interface Variables
    Button getPulseRate;
    Button refreshButton;
    TextView pulseRateView;
    TextView connectionStsView;

    //Data Output
    private String output;

    // UUIDs for UAT service and associated characteristics.
    public static UUID UART_UUID = UUID.fromString("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");
    public static UUID TX_UUID = UUID.fromString("6E400002-B5A3-F393-E0A9-E50E24DCCA9E");
    public static UUID RX_UUID = UUID.fromString("6E400003-B5A3-F393-E0A9-E50E24DCCA9E");

    // UUID for the BTLE client characteristic which is necessary for notifications.
    public static UUID CLIENT_UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");

    // BTLE stateta
    private BluetoothAdapter adapter;
    private BluetoothGatt gatt;
    private BluetoothGattCharacteristic tx;
    private BluetoothGattCharacteristic rx;

    private boolean areServicesAccessible = false;</pre></div><p>Following this, we will need to connect the user interface elements within the <code class="literal">onCreate()</code> method to the user interface, and set an <code class="literal">onClickListener</code> class to the <span class="strong"><strong>Get Pulse Rate</strong></span> and <span class="strong"><strong>Refresh</strong></span> buttons, which will allow us to request the pulse rate sensor data and refresh Bluetooth connections:</p><div class="informalexample"><pre class="programlisting">        //Connect U.I Elements
        getPulseRate = (Button) findViewById(R.id.heartRateBtn);
        pulseRateView = (TextView) findViewById(R.id.pulseValueView);
        connectionStsView = (TextView) findViewById(R.id.connectionStsView);
        refreshButton = (Button) findViewById(R.id.refreshBtn);


        getPulseRate.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                String setOutputMessage = "/bpm /";
                tx.setValue(setOutputMessage.getBytes(Charset.forName("UTF-8")));
                if (gatt.writeCharacteristic(tx)) {
                    writeConnectionData("Sent: " + setOutputMessage);
                } else {
                    writeConnectionData("Couldn't write TX characteristic!");
                }
            }
        });

        refreshButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                restartScan();
            }
        });
    }</pre></div><p>Since we are using Bluetooth <a id="id553" class="indexterm"/>in our projects, we need to implement the methods that allow us to take the character data sequences, convert them into string, and finally connect them to the user interface to display the data:</p><div class="informalexample"><pre class="programlisting">    private void writeConnectionData(final CharSequence text) {
        Log.e(LOG_TAG, text.toString());
        connectionStsView.setText(text.toString());
    }

    private void writeSensorData(final CharSequence text) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Log.e(LOG_TAG,text.toString());
                output=text.toString().trim();

                if (output.length() &gt; 0 &amp;&amp; output.length() &lt;=3) {
                    pulseRateView.setText(output);
                }
                else {
                    return;
                }
            }
        });
    }</pre></div><p>The following methods will <a id="id554" class="indexterm"/>allow us to do the necessary Bluetooth callback and send or receive data from the Arduino pulse rate sensor via the BLE module:</p><div class="informalexample"><pre class="programlisting">    // BTLE device scanning bluetoothGattCallback.

    // Main BTLE device bluetoothGattCallback where much of the logic occurs.
    private BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback() {
        // Called whenever the device connection state changes, i.e. from disconnected to connected.
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            super.onConnectionStateChange(gatt, status, newState);
            if (newState == BluetoothGatt.STATE_CONNECTED) {
                writeConnectionData("Connected!");
                // Discover services.
                if (!gatt.discoverServices()) {
                    writeConnectionData("Failed to start discovering services!");
                }
            } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
                writeConnectionData("Disconnected!");
            } else {
                writeConnectionData("Connection state changed.  New state: " + newState);
            }
        }

        // Called when services have been discovered on the remote device.
        // It seems to be necessary to wait for this discovery to occur before
        // manipulating any services or characteristics.
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            super.onServicesDiscovered(gatt, status);
            if (status == BluetoothGatt.GATT_SUCCESS) {
                writeConnectionData("Service discovery completed!");
            } else {
                writeConnectionData("Service discovery failed with status: " + status);
            }
            // Save reference to each characteristic.
            tx = gatt.getService(UART_UUID).getCharacteristic(TX_UUID);
            rx = gatt.getService(UART_UUID).getCharacteristic(RX_UUID);

            // Setup notifications on RX characteristic changes (i.e. data received).
            // First call setCharacteristicNotification to enable notification.
            if (!gatt.setCharacteristicNotification(rx, true)) {
                writeConnectionData("Couldn't set notifications for RX characteristic!");
            }

            // Next update the RX characteristic's client descriptor to enable notifications.
            if (rx.getDescriptor(CLIENT_UUID) != null) {
                BluetoothGattDescriptor desc = rx.getDescriptor(CLIENT_UUID);
                desc.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
                if (!gatt.writeDescriptor(desc)) {
                    writeConnectionData("Couldn't write RX client descriptor value!");
                }
            } else {
                writeConnectionData("Couldn't get RX client descriptor!");
            }
            areServicesAccessible = true;
        }
        // Called when a remote characteristic changes (like the RX characteristic).
        @Override
        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
            super.onCharacteristicChanged(gatt, characteristic);
            writeSensorData(characteristic.getStringValue(0));
        }
    };


private BluetoothAdapter.LeScanCallback scanCallback = new BluetoothAdapter.LeScanCallback() {
        // Called when a device is found.
        @Override
        public void onLeScan(BluetoothDevice bluetoothDevice, int i, byte[] bytes) {
            Log.d(LOG_TAG, bluetoothDevice.getAddress());

            writeConnectionData("Found device: " + bluetoothDevice.getAddress());

            // Check if the device has the UART service.
            if (BluetoothUtils.parseUUIDs(bytes).contains(UART_UUID)) {
                // Found a device, stop the scan.
                adapter.stopLeScan(scanCallback);
                writeConnectionData("Found UART service!");
                // Connect to the device.
                // Control flow will now go to the bluetoothGattCallback functions when BTLE events occur.
                gatt = bluetoothDevice.connectGatt(getApplicationContext(), false, bluetoothGattCallback);
            }
        }
    };
}</pre></div><p>The Android application life cycle allows us to implement methods at its different stages, so in the following <a id="id555" class="indexterm"/>code, we will be implementing two methods which allow us to start Bluetooth scanning when the application is activated, and stop Bluetooth scanning and other related activities when the user exits the application:</p><div class="informalexample"><pre class="programlisting">    protected void onStart() {
        Log.d(LOG_TAG,"onStart has been called");
        super.onStart();
        // / Scan for all BTLE devices.
        // The first one with the UART service will be chosen--see the code in the scanCallback.
        adapter = BluetoothAdapter.getDefaultAdapter();
        startScan();
    }

    //When this Activity isn't visible anymore
    protected void onStop() {
        Log.d(LOG_TAG,"onStop has been called");
        //disconnect and close Bluetooth Connection for better reliability
        if (gatt != null) {
            gatt.disconnect();
            gatt.close();
            gatt = null;
            tx = null;
            rx = null;
        }
        super.onStop();
    }</pre></div><p>We will also be including a number<a id="id556" class="indexterm"/> of methods that facilitate the BLE scan callback and enable us to refactor the code and keep our code clean:</p><div class="informalexample"><pre class="programlisting">    //BLUETOOTH METHODS
    private void startScan() {
        if (!adapter.isEnabled()) {
            adapter.enable();
        }
        if (!adapter.isDiscovering()) {
            adapter.startDiscovery();
        }
        writeConnectionData("Scanning for devices...");
        adapter.startLeScan(scanCallback);
    }

    private void stopScan() {
        if (adapter.isDiscovering()) {
            adapter.cancelDiscovery();
        }
        writeConnectionData("Stopping scan");
        adapter.stopLeScan(scanCallback);
    }

    private void restartScan() {
        stopScan();
        startScan();
    }</pre></div><p>UUID parsing, unlike the previous chapters, has been moved to a <code class="literal">utility</code> class in order to refactor the code and<a id="id557" class="indexterm"/> make it more readable. In order to create a <code class="literal">utility</code> class, we first need to right-click on our package name and create a new package called <code class="literal">Bluetooth</code>.</p><p>Then we will right-click on the new package, select <span class="strong"><strong>New</strong></span> &gt; <span class="strong"><strong>Java Class</strong></span>, and name the new class as <code class="literal">BluetoothUtils</code>.</p><p>After these two steps, we will replace the code within the class with the following code:</p><div class="informalexample"><pre class="programlisting">public class BluetoothUtils {

    // Filtering by custom UUID is broken in Android 4.3 and 4.4, see:
    //   http://stackoverflow.com/questions/18019161/startlescan-with-128-bit-uuids-doesnt-work-on-native-android-ble-implementation?noredirect=1#comment27879874_18019161
    // This is a workaround function from the SO thread to manually parse advertisement data.
    public static List&lt;UUID&gt; parseUUIDs(final byte[] advertisedData) {
        List&lt;UUID&gt; uuids = new ArrayList&lt;UUID&gt;();

        int offset = 0;
        while (offset &lt; (advertisedData.length - 2)) {
            int len = advertisedData[offset++];
            if (len == 0)
                break;

            int type = advertisedData[offset++];
            switch (type) {
                case 0x02: // Partial list of 16-bit UUIDs
                case 0x03: // Complete list of 16-bit UUIDs
                    while (len &gt; 1) {
                        int uuid16 = advertisedData[offset++];
                        uuid16 += (advertisedData[offset++] &lt;&lt; 8);
                        len -= 2;
                        uuids.add(UUID.fromString(String.format("%08x-0000-1000-8000-00805f9b34fb", uuid16)));
                    }
                    break;
                case 0x06:// Partial list of 128-bit UUIDs
                case 0x07:// Complete list of 128-bit UUIDs
                    // Loop through the advertised 128-bit UUID's.
                    while (len &gt;= 16) {
                        try {
                            // Wrap the advertised bits and order them.
                            ByteBuffer buffer = ByteBuffer.wrap(advertisedData, offset++, 16).order(ByteOrder.LITTLE_ENDIAN);
                            long mostSignificantBit = buffer.getLong();
                            long leastSignificantBit = buffer.getLong();
                            uuids.add(new UUID(leastSignificantBit,
                                    mostSignificantBit));
                        } catch (IndexOutOfBoundsException e) {
                            // Defensive programming.
                            //Log.e(LOG_TAG, e.toString());
                            continue;
                        } finally {
                            // Move the offset to read the next uuid.
                            offset += 15;
                            len -= 16;
                        }
                    }
                    break;
                default:
                    offset += (len - 1);
                    break;
            }
        }
        return uuids;
    }
}</pre></div><p>At this point, you could go ahead, build, and run the project on an Android physical device running on <a id="id558" class="indexterm"/>Android 4.3 with Bluetooth switched on. In order to get your pulse rate in this project, you will need to follow the instructions as mentioned previously and tap on the <span class="strong"><strong>Get Pulse Rate</strong></span> button.</p></div><div class="section" title="How to go further"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec72"/>How to go further</h2></div></div></div><p>We believe <a id="id559" class="indexterm"/>that this project can be taken further by possibly including other health-related sensors that are available from a number of online outlets and displaying the related data within a graph.</p><p>The Android graph view library supports multiple inputs using multiple series. Further information about this can<a id="id560" class="indexterm"/> be obtained at the official website for documentation at <a class="ulink" href="http://android-graphview.org/">http://android-graphview.org/</a>.</p><p>A screenshot of how this application could possibly look with Android graph view would be similar to the following:</p><div class="mediaobject"><img src="graphics/0389OS_10_05.jpg" alt="How to go further"/></div><p>Further improvements could also be done to the user interface and user experience where the data can be updated in real time via handler or timer implementations. Finally, one of the most advanced integrations <a id="id561" class="indexterm"/>that could be included in this kind of application is integration with the Google Fit SDK, which is Google's proprietary health data platform. Another option could be storage of health data using cloud storage APIs and local databases.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we integrated what we had learned from the previous chapters and created a baseline project to measure our own pulse rate.</p><p>We achieved this by creating an Android app which shows the data produced by the pulse rate sensor connected to the Arduino Uno. Communication between both devices is via BLE.</p><p>The baseline projects that we have introduced throughout this book are present to motivate you to be creative and solve your daily challenges. We have realized that the possibilities of combining Arduino and Android are endless, and we hope that you will stretch the limitations of what is possible.</p></div></body></html>