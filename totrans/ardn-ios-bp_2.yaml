- en: Chapter 2. Bluetooth Pet Door Locker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project is about a pet door controller that, by measuring external light
    and temperature, locks or unlocks your house's pet door. Through an iOS device
    you can check the status of the door (locked or unlocked) and overrun the logic
    implemented on Arduino for manually locking the door.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you will learn how to work with analog sensors, switches, 1-Wire
    sensors (to measure temperatures) and control a servo motor wired to Arduino.
    Moreover, you will wire a Bluetooth 4.0 board to Arduino to communicate with your
    iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will learn how to write a Bluetooth iOS application to send and receive
    data from Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of this chapter, we will discuss different types of sensors
    and their communication protocols with Arduino, in order to learn how to manage
    the most used technologies to measure quantities.
  prefs: []
  type: TYPE_NORMAL
- en: This project requires some DIY skills in order to mount the locker to the pet
    door and to link it to the servo motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is organized into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Door locker requirements**: We will briefly recap the project requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware**: We will describe the hardware and the electronic circuit needed
    for the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arduino code**: We will write the code for Arduino to control the latch and
    communicate with the iOS device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS code**: We will write the code for the iOS device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to go further**: More ideas to improve the project and learn more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Different types of sensors**: A quick overview of analog and digital sensors,
    low-level communication protocols, and their pros and cons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Door locker requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to build an automatic system that allows you to lock the pet door
    in the following different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: At night, when the outside light is less luminous than a predefined threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the external temperature is too low or too high for your beloved pet, that
    is, when the temperature is below a predefined threshold or above a predefined
    threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, we need to see the external temperature on our iOS device, we also
    need to know if the pet door is locked or unlocked, and override the automatic
    behavior, manually locking the door.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we have to build an electro-mechanical device, based on a latch
    and a servo motor to lock/unlock the pet door. Moreover, we need to build a simple
    electronic circuit to read sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Required materials and electronics components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build the locker you need little hardware that will be available at your
    local hardware store:'
  prefs: []
  type: TYPE_NORMAL
- en: A small door latch, which is best if flat and without any notch. Since it has
    to be operated by a servo motor it has to slide very smoothly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some nuts and bolts to mount the latch to the door.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few centimeters of metal wire (diameter of 2 mm or so).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other required components are:'
  prefs: []
  type: TYPE_NORMAL
- en: Mini servo motor powered at 5V.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally closed magnetic switch and a small magnet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A photoresistor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resistors: 2 × 10K, 1 × 4.7K.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A digital DS18B20 temperature sensor. It's more expensive than analog sensors
    (like TMP 35), but it's much more precise and the readings are almost insensitive
    to the voltage fluctuations and electric noise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adafruit Bluefruit LE nRF8001 breakout ([http://www.adafruit.com/product/1697](http://www.adafruit.com/product/1697)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly latch and servo motor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To assemble the latch, you can refer to the following picture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Assembly latch and servo motor](img/image00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The small magnet is glued on the latch, so that when it is completely retracted,
    the magnetic switch is open.
  prefs: []
  type: TYPE_NORMAL
- en: The photoresistor and the temperature sensor have to be placed outside the house
    and wired to Arduino. They need to be protected from humidity and dust, so it's
    better to set them inside a small plastic box. The box has to be drilled so that
    the air can freely circulate to help the temperature sensor to measure correctly.
    Moreover, the photoresistor should not be exposed to direct light to avoid blinding.
    A small plastic tube can do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following picture shows the electric diagram of the electronic circuit
    that we need for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows how to mount the circuit on a breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For quick reference, the following list recaps the **nRF8001** wiring:'
  prefs: []
  type: TYPE_NORMAL
- en: SCK to digital pin 13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MISO to digital pin 12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MOSI to digital pin 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REQ to digital pin 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RST to digital pin 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RDY to digital pin 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using **Arduino MEGA** instead of **UNO**, the wiring of **nRF8001**
    board has to be changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: SCK to digital pin 52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MISO to digital pin 50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MOSI to digital pin 51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REQ to digital pin 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RST to digital pin 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RDY to digital pin 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light is measured using the photoresistor and an analog input of Arduino (A0).
    A photoresistor is a device whose resistance decreases with the increasing of
    the incident light intensity. In the circuit, the photoresistor is in a voltage
    divider with R1\. Voltage across R1 increases if the light on the photoresistor
    increases, and it's measured using the analog pin A0 of Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: R1 forces to ground the Arduino input when the photoresistor is not lighted
    and its resistance is very high.
  prefs: []
  type: TYPE_NORMAL
- en: In the Arduino code, you can get the value of the voltage at an analog pin using
    the `analogRead` function. It returns a value in the range 0-1023 which is proportional
    to the voltage applied to the analog pin.
  prefs: []
  type: TYPE_NORMAL
- en: The latch position is determined using a magnetic switch and a digital input
    of Arduino (D4). The magnetic switch closes when the magnet on the latch is close
    to it. The switch is in a voltage divider with R2\. The voltage across R2 is almost
    5V when the switch is closed, or about 0V when the switch is open.
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Voltage divider
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The voltage divider is a simple circuit made of two resistors. Assuming that
    the current that flows outside the circuit is negligible, V2 is approximately
    *V1*R2/(R1+R2)*.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Arduino digital input you can determine if the switch is open or closed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Arduino code, you can get the value of a digital pin using the `digitalRead`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The temperature sensor is a digital sensor that uses the 1-Wire protocol, and
    it is read using a digital pin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To read the value of the temperature sensor you have to use the `OneWire` library
    and the `DallasTemperature` library through which a function directly returns
    the temperature in Celsius.
  prefs: []
  type: TYPE_NORMAL
- en: The servo motor requires a PWM signal to be controlled. Pulse width modulation
    is a technique for getting analog results with digital means. It is a square wave
    with a period of 2 ms. The width of the positive pulse determines the rotation
    of the servo (for example, a 1.5 ms pulse will make the motor turn to the 90-degree
    position). Fortunately, the servo library (already included in the IDE) hides
    the complexity and we can move the motor by just calling a function with the desired
    motor position.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The full code of this project can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
  prefs: []
  type: TYPE_NORMAL
- en: For a better understanding of the explanations in the next paragraphs, you should
    open the downloaded code while reading.
  prefs: []
  type: TYPE_NORMAL
- en: Each Arduino program almost always has the following structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The instruction `#include <library_1.h>` tells the compiler to use a library
    and the instruction `#define SOMETHING A_VALUE` tells the compiler to replace
    `SOMETHING` with `A_VALUE` all over the program. It's easier to make changes if
    you use defined values. If you need to replace `A_VALUE` with something else,
    you can do it at a single place instead of in all instances in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Function prototypes are generally used for functions, which are used during
    the code but their bodies are put at the end of the program source. Global variables
    are variables whose values have to be preserved across the execution of the program.
    The function `setup` is used for initializing libraries and variables; it's called
    only once, at the board's power up or reset. The function `loop` instead is called
    over and over again. Variables defined in the loop function lose their value across
    calls; this is why we need global variables. Callback functions are called from
    libraries when an event happens, or data are available for processing. Instead,
    functions that are called from the loop help to make the code easier to read,
    maintain, and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Installing additional required libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this project we need some libraries. Some are already available in the Arduino
    IDE and others have to be added ( for example, `OneWire`, `DallasTemperature`,
    and `Adafruit_BLE_UART`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To add them, follow this simple procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the menu item **Sketch** | **Include Library** | **Manage Libraries**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search field enter `OneWire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the row with **OneWire** and click **Install** (see picture below).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `DallasTemp` in the search field, click on **MAX31850** and then **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `nRF8001` in the search field, click **Adafruit nRF8001** and then **Install**.![Installing
    additional required libraries](img/image00164.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing global variables and libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The temperature sensor uses the 1-Wire protocol for communicating with Arduino,
    so we need the `OneWire` library. Fortunately another library (`DallasTemperature`)
    is available to make temperature readings very easy. We need to create global
    variables for the two libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And one for storing the sensor address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The global variables for the nRF8001 library are in a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you change the pins used in the previous line, you have to also change them
    in the circuit wiring.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the servo motor we need another global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need two more global Boolean variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first is true when the iOS device is connected to Arduino, the second is
    true when the user needs to keep the pet door closed regardless of the light and
    temperature values.
  prefs: []
  type: TYPE_NORMAL
- en: Setup code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start setting up the Serial communication library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is not strictly necessary but it is required for writing to the console,
    which may be useful for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we initialize the sensor library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also read the address of the device number 0 (the only one present in our
    circuit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The 1-Wire address**'
  prefs: []
  type: TYPE_NORMAL
- en: Each 1-Wire device has its own address defined at time of production and it
    cannot be changed. To perform any operation on the device you have to know its
    address. The `getAddress` and `search` library functions can help you to find
    the address of your devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sensor can provide readings with different levels of precision, but the
    more precision we ask for, the more the device is slow to answer. For our purposes,
    we don''t need a high precision, so we can set the precision to 9 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The library has to know the pin where the servo motor is wired on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the pins used for the photoresistor and the switch need to be configured
    as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For communicating with the nRF8001 board we need to set up a couple of callback
    functions; one, to know when the iOS device is connected or disconnected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The other callback function is for receiving data that are transmitted by the
    iOS device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The nRF8001 library calls the `rxCallback` when data from the iOS device are
    available for processing.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to take a look at the main part of the code, which implements
    the algorithm to control the pet door and the iOS communication.
  prefs: []
  type: TYPE_NORMAL
- en: Main program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the project''s requirements, we conclude that the Arduino program has
    to implement a simple logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Read light intensity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the light intensity is above `LIGHT_THRESHOLD`, at a temperature between
    `LOW_TEMPERATURE_THRESHOLD` and `HIGH_TEMPERATURE_THRESHOLD`, the servo motor
    has to move to the `UNLOCK_POSITION` (180 degree), otherwise to the `LOCK_POSITION`
    (65 degree)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, when the iOS device is connected, it has to receive information about
    the latch position (opened or closed) and the external temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main loop function we read the light intensity with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The temperature with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And the latch position with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Light is a value in the range 0-1023 (2^(10)) proportional to the light intensity,
    if the latch is opened, the `latchIsOpened` has value true (1), and `temperature`
    is the temperature measured by the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Voltage at the analog pin**:'
  prefs: []
  type: TYPE_NORMAL
- en: The **analog to digital converter** (**ADC**) inside Arduino, attached to an
    analog pin, transforms the voltage at the pin into an integer value using 10 bits,
    which is an integer value in the range 0-1023 (2^(10) values).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the voltage at the analog pin can be between 0 V and 5 V (the power voltage)
    each bit has a value that is 5 / 1024, then you can calculate the voltage at the
    analog pin using this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*voltage = analogRead(<ANALOG PIN>) * 5/1024*'
  prefs: []
  type: TYPE_NORMAL
- en: If you power on Arduino through the USB port of your computer, the power voltage
    is never exactly 5V but usually less. To get a better reading, you should measure
    the power voltage with a digital multimeter, and replace 5 with the actual power
    voltage in the previous formula.
  prefs: []
  type: TYPE_NORMAL
- en: In the loop function it's necessary to call the `pollACI` function so that the
    communication library can take the control for handling incoming data from the
    iOS connected device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**poolACI**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a long and complex program, you may need to add many `poolACI` calls
    across the code in order to frequently allow the library to take control to handle
    communication. Otherwise, you can experience data loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core algorithm is in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the door has not been manually locked, the light is above the `LIGHT_THRESHOLD`,
    the temperature is between `LOW_TEMPERATURE_THRESHOLD` and `HIGH_TEMPERATURE_THRESHOLD`,
    the servo motor can be moved to the `UNLOCKED_POSITION` with the instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, it is moved to the `LOCKED_POSITION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**DeMorgan''s theorem**'
  prefs: []
  type: TYPE_NORMAL
- en: This theorem is very useful for coding if-then-else statements in any programming
    language. Don't ever forget it!
  prefs: []
  type: TYPE_NORMAL
- en: not (A or B) = not A and not B
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: not (A and B) = not A or not B
  prefs: []
  type: TYPE_NORMAL
- en: The opposite condition of "A or B" is "not A **and** not B", the opposite condition
    of "A and B" is "not A **or** not B.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two functions are quite self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aboveThreshold`(…)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`betweenThresholds`(….)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at the downloaded code for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `manuallyLocked` is true, light and temperature readings are ignored. This
    variable is set by a message received from the iOS device in the `rxCallback`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the nRF8001 library automatically calls the `rxCallback` function
    when data sent from the iOS device are ready for processing.
  prefs: []
  type: TYPE_NORMAL
- en: The iOS device sends only one byte with the ASCII character 1 if the door has
    to be locked, or the ASCII character 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The ASCII character 0 has code 48, so to transform it to a Boolean value false
    (0) you need to subtract 48 (or the character '0' which is the same). Subtracting
    48 from the ASCII character 1, we get the Boolean value true (1).
  prefs: []
  type: TYPE_NORMAL
- en: Back to the main function. If `iOSConnected` is true, an iOS device is connected
    to Arduino, and some data has to be transferred to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data are sent to iOS with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `latch_position` informs the iOS device if the latch is opened or closed,
    whereas `temperature` is the external temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send data to iOS we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The function `snprintf` creates a buffer formatted as required, which is then
    sent to iOS with the function `uart.write((uint8_t *)buffer, strlen(buffer))`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**snprintf**'
  prefs: []
  type: TYPE_NORMAL
- en: This function never writes more characters than that indicated by the second
    parameter. This is very important to write safe code. In fact, if you write more
    characters than the buffer size, it is likely that you write somewhere in a memory
    location which is used for other purposes causing a microprocessor crash. After
    a crash, the microprocessor restarts the program execution from the setup function.
    For more details, visit [http://bit.ly/1E021no](http://bit.ly/1E021no) and [http://bit.ly/1LijDx5](http://bit.ly/1LijDx5).
  prefs: []
  type: TYPE_NORMAL
- en: '**dtostrf**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, on Arduino, `snprintf` doesn''t work with floating numbers,
    so we need to use `dtostrf` to transform the temperature (which is a float) to
    a string and then using it in the `snprintf`. The second parameter of `dtostrf`
    is the number of decimal digits to use in the conversion. For more details, visit:
    [http://bit.ly/1fmj9HV](http://bit.ly/1fmj9HV).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that we have to code is managing connections and disconnections
    of the iOS device. This is done in the `aciCallback` function. The nRF8001 library
    calls this function each time one of the following events happen: the device starts
    advertizing itself in order to be discovered by other Bluetooth devices, an external
    device connects, or a connected device disconnects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Testing and tuning the Arduino side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have uploaded the code to Arduino (for more details: [http://bit.ly/1JPNAn3](http://bit.ly/1JPNAn3)
    or [http://bit.ly/1KsUhqv](http://bit.ly/1KsUhqv)), you can start testing it.'
  prefs: []
  type: TYPE_NORMAL
- en: If enough light reaches the photoresistor and the temperature is between 2 degree
    Celsius and 33 degree Celsius, the servo should move to the open position and
    the latch should be completely retracted.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when you cover the photoresistor, the latch should close. In order to
    test the temperature sensor you can use a hairdryer to get the temperature over
    3 degree Celsius and an ice pack to get it below 2 degree Celsius. In both cases
    the latch should close.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily change the temperature thresholds by changing these defines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The light threshold likely requires some more tuning, since the values read
    by the photoresistor highly depend on the photoresistor characteristics, the mounting
    positioning and orientation. Anyway, change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to find the value that is right for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also need to adjust the servo motor positions for opening and closing
    the latch because of the way you have assembled everything. To adjust the positions
    you can change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This represents the position in degrees of the motor.
  prefs: []
  type: TYPE_NORMAL
- en: iOS code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to write the iOS application through which we
    can connect to the Arduino, know if the pet door is locked or not, read the external
    temperature, and eventually manually lock it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code of this project can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)'
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the explanations in the next paragraphs, you should open
    the downloaded code while reading.
  prefs: []
  type: TYPE_NORMAL
- en: The main tool for writing the application is Xcode provided by Apple. We can
    start it from Launchpad or entering the **Applications** folder in **Finder**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Start developing iOS apps today**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful guide to iOS developing provided by Apple can be found at this link:
    [http://apple.co/MtP2Aq](http://apple.co/MtP2Aq).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The language used for developing iOS applications is Objective-C. It is similar
    to C++ and you can find an introduction to this language at the following link:
    [http://apple.co/19FWxfQ](http://apple.co/19FWxfQ).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Xcode project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to create a new project. Xcode provides many different project
    templates; we are going to use the Tabbed Application, which has two tabs. We
    are going to use the first tab as the main application panel, and the second to
    scan the nRF8001 device. This operation is required only once, when the application
    is started for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Xcode overview**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find everything you need to work with Xcode at the following link:
    [http://apple.co/1UQnMtS](http://apple.co/1UQnMtS).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the new project we can follow these steps (see the following screenshots):'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New** | **Project …**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left panel, select **iOS** | **Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the right panel, select **Tabbed Application** and then click on **Next**.![Creating
    the Xcode project](img/image00165.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next screen, enter the required information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Product Name**: `PetDoorLocker`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organization Name**: `Your Name`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organization Identifier**: `yourname` (this information is relevant only
    for publishing the application to the iTunes Store and selling it. It can be ignored)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: **Objective-C**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: **Universal** (we are going to create an application that can
    run on an iPhone and iPad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Creating the Xcode project](img/image00166.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Click on the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a folder where you want to store the project (leave Source Control unchecked).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's all!
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to start writing the new application. The first thing to do
    is rename the two view controllers (FirstViewController and SecondViewController).
  prefs: []
  type: TYPE_NORMAL
- en: Select `FirstViewController.h` in the left panel, this will open the file in
    the right panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `FirstViewController` in the line `@interface FirstViewController :
    UIViewController`, by double clicking on `FirstViewController`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right Click and select **Refactor** | **Rename …**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the new name of the view controller: `PetDoorLockerViewController`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click preview and then save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `SecondViewController.h`, and with the same procedure rename it as `BLEConnectionViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What''s a View Controller? The Apple documentation says:'
  prefs: []
  type: TYPE_NORMAL
- en: '*View controllers are a vital link between an app''s data and its visual appearance.
    Whenever an iOS app displays a user interface, the displayed content is managed
    by a view controller or a group of view controllers coordinating with each other.
    Therefore, view controllers provide the skeletal framework on which you build
    your apps.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Design Patterns**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further, we suggest you read the information on the following
    link: [http://apple.co/1hkUDbU](http://apple.co/1hkUDbU).'
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to design the GUI of the new application.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the application user interface for BLEConnectionViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To design the app user interface, let''s open the `Main.storyboard`. This file
    contains everything about the GUI. Once opened, you should see something as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application user interface for BLEConnectionViewController](img/image00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's start from the `BLEConnectionViewController`, which will be used for scanning
    the nRF8001 device.
  prefs: []
  type: TYPE_NORMAL
- en: Double click on the view controller to select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the label **Second View** and delete it, then select **Loaded by the
    SecondViewController** and delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Utilities panel on the right: **View** | **Utilities** | **Show Utilities**.
    (To open this panel you can also use the green circled icon in the following screenshot).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Label** in the Tool Navigator and drop it to the free area (see the
    following screenshot).![Designing the application user interface for BLEConnectionViewController](img/image00168.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the label, by double clicking **Label** and entering `Device`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we have to set the Auto Layout constraints that will lock the label in
    the desired position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Auto Layout Pin icon (it's circled in red in the previous screenshot).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `20` for the Leading Space from Superview, and `30` for Top Space to Superview
    as shown in the following screenshot.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `53` as **Width**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add 3 Constraints**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Designing the application user interface for BLEConnectionViewController](img/image00169.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Drop a new instance of **Label** next to the previous and add Auto Layout Constraints
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select both labels (clicking on them with the *Command* button pressed).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Align icon (it's circled in green in the previous screenshot).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Vertical Centers** and then **Add 1 Constraint**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select only the new label and click on the Auto Layout Pin.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `20` for both the Leading Space and Trailing Space.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Update Frames**, select **All frames in Container**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add 2 Constraints**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the new label again, and select **View** | **Utilities** | **Show Attributes
    Inspector** (or click on the icon circled in red in the next screenshot).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the font size to `13` and **Alignment** to center (see area circled green
    in the next screenshot).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Designing the application user interface for BLEConnectionViewController](img/image00170.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The new label will show the UUID of the nRF8001 once detected. Now we have to
    add a button to start scanning for nRF8001 devices nearby.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Drag a button into the container, double click on it, and enter `Scan`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the button and click on the Auto Layout Pin.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `45` for **To Space** and click on **Add 1 Constraint**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the button, click on the Align icon, select Horizontal Center in the
    Container, for **Update Frames**, select **All frames in Container**, and then
    click on **Add 1 Constraint**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have to link the GUI components with the code in order to manipulate
    them programmatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **BLEConnectionViewController**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **View** | **Assistant Editor**. A new panel opens with the `BLEConnectionViewController.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the Utilities panel to have more space (click on **View** | **Utilities**
    | **Hide Utilities**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that in the red circled area of the following screenshot, you read
    **BLEConnectionViewController.m**, otherwise click on it and change to the desired
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the label **Label** and keeping the *Command* button pressed, drag the
    label to the code on the right between `@interface BLEConnectionViewController
    ()` and `@end` (see picture below).![Designing the application user interface
    for BLEConnectionViewController](img/image00171.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a dialog appears, enter the **Name** as `deviceUUIDLabel` (see picture
    below) and then click **Connect**.![Designing the application user interface for
    BLEConnectionViewController](img/image00172.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This creates a property (`deviceUUIDLabel`), which can be used for changing
    the label properties, such as its text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ARC and strong versus weak**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `strong` attribute indicates to the compiler that the memory associated
    to the property has to be kept allocated until the class in which it is defined
    is allocated. Properties that are not defined strong (but weak) are automatically
    deallocated as soon as the code block in which they are defined is completed.
    In short, as long as there is a strong reference pointer to the object, that object
    will not be deallocated. Memory management under iOS has been simplified since
    the introduction of **Automatic Counting Reference** (**ARC**) but is still an
    issue for most people. A good introduction can be found here: [http://apple.co/1MvuNgw](http://apple.co/1MvuNgw).
    It is for Swift (the last programming language that Apple has made available)
    but it is worth reading.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Atomic versus nonatomic**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `atomic` attribute will ensure that a whole value is always returned from
    the getter or set by the setter of the property, regardless of setter activity
    on any other thread. That is, if thread A is in the middle of the getter while
    thread B calls the setter, an actual viable value will be returned to the caller
    in A.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Apple documentation says: *Property atomicity is not synonymous with an
    object''s thread safety*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Accessing a strong property is slower than accessing a nonatomic one. More
    details here: [http://apple.co/1JeBIdb](http://apple.co/1JeBIdb).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now link the **Scan** button to have a method that is called when the button
    is tapped:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Scan** button and, keeping *Control* pressed, drop it to the right
    pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `startScanning` as the name and select **UIButton** for **Type** (see
    picture below). This creates a new method, which is called when the button is
    pressed.![Designing the application user interface for BLEConnectionViewController](img/image00173.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To complete the design, we have to set the name of the view controller, which
    appears in the toolbar:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the Tool Navigator again (**View** | **Utilities** | **Show Utilities**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the icon at the bottom side of the container (a small square with second
    label under it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show Attribute Inspector (**View** | **Utilities** | **Attribute Inspector**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Title** field, enter `Configuration`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could also choose an icon from the Image list box. To do that, you should
    add the icon to the project, dropping it into the Supporting Files group in the
    left panel. The icon should be 32 × 32 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: At the very end, your View Controller should look like the next picture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application user interface for BLEConnectionViewController](img/image00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Designing the application user interface for PetDoorLockerViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we will design the interface for the first view controller (PetDoorLockerViewController).
    We will only describe how to add components not shown in the previous chapter.
    Refer to the next picture for the global layout of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Add a label, rename it as `Door Status` and add to it the Auto Layout constraints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `UIView` in the search field of the right panel and drop the view near
    the label. You can resize the view dragging the small white squares on its borders.
    In the Attribute Inspector, select a light gray color for the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select both the label and the view and click on Align icon. Select **Vertical
    Centers** and click on **Add 1 Constraint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the view and click on the Align icon. Select **Horizontal Center** in
    the **Container** and click on **Add 1 Constraint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Pin icon, enter `48` for height and width, for **Update Frames**,
    select **All frames in Container** and then click on **Add 2 Constraints**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new label `Temperature`, and add to it the Auto Layout constraints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another label near **Temperature** and the Auto Layout constraints to vertically
    center it with **Temperature** and horizontally center it in the container's view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then add a label, `Lock`, and add Auto Layout constraints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a switch near **Lock** and the Auto Layout constraints to vertically center
    it with **Lock** and horizontally center it in the container's view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the container, add a button (called **Connect**) and the Auto
    Layout constraints to vertically center it with **Lock** and horizontally center
    it in the container's view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should end with something like what is shown in the following picture. The
    **Connect** button is useful in case you lose connection to the nRF8001 device,
    and you need to manually reconnect to it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application user interface for PetDoorLockerViewController](img/image00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once all the components have been added, you can link them to the code finishing
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And with the function `reconnect` to intercept when the **Connect** button is
    tapped.
  prefs: []
  type: TYPE_NORMAL
- en: In case of doubts, you can use the downloaded code as reference.
  prefs: []
  type: TYPE_NORMAL
- en: We are eventually ready to write the code for both the view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for BLEConnectionViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this controller is to get the unique identifier of the nRF8001
    device, so that it can be used to connect to the device as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle communication with a Bluetooth 4.0 device, we need to use the class
    `CBCentralManager` that we add to the interface of the view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Xcode class reference**'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to know more about a class, you can press *Option* + click the class
    name for direct access to the documentation. Conversely, *Command* + click will
    bring you to the source file.
  prefs: []
  type: TYPE_NORMAL
- en: The instantiation of the class is in the `viewDidAppear` method, which is called
    every time the view associated with the view controller is shown on the device
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To work with `CBCentralManager`, we need to implement a few delegate methods,
    but first we have to instruct the controller about that; we open the `BLEConnectionViewController.h`
    file and we change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we are ready to write two delegate methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`centralManagerDidUpdateState`: This method is called when the state of the
    iOS Bluetooth subsystem changes. This method has only an informative purpose in
    this view controller, but it is very useful in more complex projects where the
    status of the Bluetooth subsystem needs to be monitored. See the downloaded code
    to get more details about this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`didDiscoverPeripheral`: This method is called when a new peripheral is discovered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each time a new Bluetooth peripheral is discovered (the nRF8001 board hooked
    up to Arduino in our case) the method is called providing information on the peripheral.
    We will show the identifier of the peripheral on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And we store it in `userDefaults` with the key `PetDoorLockerDevice` so that
    we can retrieve it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**User preferences**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Preferences are information that you store persistently, and use to configure
    your app. They can be accessed using the `NSUserDefaults` class. More details
    can be found here: [http://apple.co/1qRYb3o](http://apple.co/1qRYb3o).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on, we''ll get back to explaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The **Scan** button activates the method `startScanning` when the user needs
    to detect the available device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If the state of the `centralManager` is not `CBCentralManagerStatePoweredOn`
    nothing can be done. Otherwise the scanning is started by calling `scanForPeripheralsWithServices`.
  prefs: []
  type: TYPE_NORMAL
- en: Each Bluetooth 4.0 device has one or more services uniquely identified; we look
    for the service identifier of the nRF8001 board (NRF8001BB_SERVICE_UUID).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**nRF8001 service and characteristics**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Bluetooth peripheral can provide more services and, for each service, more
    characteristics that the user can read and/or write. The nRF8001 board has only
    one service (UUID: 6E400001-B5A3-F393-E0A9-E50E24DCCA9E), one characteristic to
    receive data (UUID: 6E400002-B5A3-F393-E0A9-E50E24DCCA9E) and one for sending
    data (UUID: 6E400003-B5A3-F393-E0A9-E50E24DCCA9E).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value NRF8001BB_SERVICE_UUID is defined at the beginning of the view controller''s
    code: `#define NRF8001BB_SERVICE_UUID @"6E400001-B5A3-F393-E0A9-E50E24DCCA9E"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a device with that service has been found, the iOS calls `didDiscoverPeripheral`
    and the iOS device stops scanning. Unfortunately, the scanning process runs until
    a device is found. So in case the peripheral has not been found, the iOS device
    keeps draining the batteries. To overcome this issue, we need a timer. It is defined
    into the view controller interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And instantiated with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If not halted, the timer will call the method `scanningTimedOut` after 5 seconds.
    In this method we can stop `centralManager` from scanning and draining the batteries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If a peripheral, with the desired service, is found, the iOS calls the `didDiscoverPeripheral`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have to halt the `scanningTimer` that is the purpose of this line `[_scanningTimer
    invalidate];` and save the UUID of the peripheral in User Defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to run the app on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Run your app**'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the information for running your app both on the simulator and on the physical
    device can be found here: [https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Power on the Arduino board and start the app, then tap on the configuration
    tab and then on the **Scan** button. In a few seconds you should see a long string
    of letters and numbers near the device label. That is the UUID of the nRF8001
    device. The setup configuration has been completed!
  prefs: []
  type: TYPE_NORMAL
- en: 'If something goes wrong, the message **no device is in range** appears. In
    that case, double check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The nRF8001 is properly wired to Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have uploaded the correct code to Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Arduino board is powered up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IDE console shows the messages **Setup Completed** and **Advertising started**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bluetooth is activated on your iOS device (tap Settings and then Bluetooth to
    activate it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing code for PetDoorLockerViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will write the main part of the application, which allows
    you to monitor if the pet door is locked or unlocked, read the external temperature,
    and lock the pet door if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the code of this view controller is more complex and we want to save space
    for other subjects, we are going to explain the entire code but we are not going
    to guide you on writing it step-by-step. Please, refer to the downloaded code
    to see the code in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need three defines and some additional properties in the view controller''s
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add a delegate `@interface PetDoorLockerViewController : UIViewController
    <CBCentralManagerDelegate, CBPeripheralDelegate>` in the `PetDoorLockerViewController.h`.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the `CBCentralManager` instance is exactly like we did in the previous
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `centralManagerDidUpdateState` is quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the Bluetooth subsystem is ready (its state is `CBCentralManagerStatePoweredOn`)
    the app starts trying to connect to the nRF8001 board, calling `[self connect]`
    which is a method that we'll show you very soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection is also started from `viewDidAppear` each time the view controller
    is shown on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The connection is closed as soon as the view disappears from the screen to
    reduce draining of the batteries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now let's take a closer look at the connection method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If `arduinoDevice` is not initialized, we retrieve it using the UUID that has
    been stored in the user preferences during the scanning phase. It''s important
    that the peripheral delegate is set, because we have to discover the peripheral''s
    characteristics and they are returned through delegate methods. The method `connectPeripheral`
    actually connects to the peripheral. If the connection is successful, the delegate
    method `didConnectPeripheral` is called, and we can start discovering the service
    that the device provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Discovering all services**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In certain cases you may need to discover all the services that a peripheral
    provides. To do that, you use: `[peripheral discoverServices:nil];`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once iOS discovers the peripheral''s service, it calls the method `didDiscoverServices`
    and we can start discovering the characteristics of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For each service provided, the iOS calls the method `didDiscoverCharacteristicsForService`
    (please see downloaded code). In this method we store the characteristic for sending
    data to the nRF8001 device in the property `sendCharacteristic`, and we call this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll use the characteristic for receiving data as parameter. Now each
    time the characteristic changes (data are sent from the nRF80001 device), the
    method `didUpdateValueForCharacteristic` is called and the available data are
    received (please, see downloaded code).
  prefs: []
  type: TYPE_NORMAL
- en: 'When incoming data are available, the `dataReceived` method is called and received
    data can be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can receive two kinds of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: m:0|1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s:0|1; t:temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the iOS device connects to Arduino, it receives the first message, which
    informs you if the door has been manually locked (m:1) or not (m:0). With this
    information we can set the position of the manual switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The second message contains two types of information: if the latch is open
    (s:1) or closed (s:0) and the external temperature. The first is used to change
    the background color of the `doorStatus` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The temperature information is used to set the value of the `temperature` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When the switch `manualLockSwitch` is tapped, the method `switchChanged` is
    called and there we can transmit data to Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To send data to a Bluetooth device, we write to the appropriate characteristic
    using the method `writeValue`. Since it accepts `NSData` values, we have to convert
    the string `"0"` or `"1"` to `NSData` using the method `dataUsingEncoding`.
  prefs: []
  type: TYPE_NORMAL
- en: We have almost completed the application. Once the iOS application is connected
    to Arduino, we need that it disconnects when it is sent to the background (for
    saving batteries). When it is brought to the foreground again, it automatically
    reconnects to Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that we make the `connect` method public and we write a new `disconnect`
    public method. To make the methods public we add a couple of lines to `PetDoorLockerViewController.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `disconnect` method is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Setting the background color of the `doorStatus` view to light gray, we can
    visually know if the iOS is connected to Arduino or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very last method we have to write is `reconnect`, which doesn''t require
    any explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AppDelegate.m` file there are two methods, which are respectively called
    when the app enters in the background or gets back to the foreground:'
  prefs: []
  type: TYPE_NORMAL
- en: '`applicationDidEnterBackground`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`applicationWillEnterForeground`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these methods we need a reference to the `PetDoorLockerViewController`. We
    can get it through the main application window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Testing the iOS app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now the application is completed and we can run it again on our iOS device.
    As soon as it starts, it should connect to Arduino and the door status indicator
    should turn to red if the door is locked, or to green if it is unlocked and you
    should see the temperature measured from the Arduino sensor.
  prefs: []
  type: TYPE_NORMAL
- en: When you tap on the lock switch, the door should immediately close and ignore
    light and temperature.
  prefs: []
  type: TYPE_NORMAL
- en: How to go further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application we have developed can be improved in many ways; these are some
    suggested improvements that you can try yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the presence of your pet in the house by counting door openings and
    their directions. A couple of magnetic switches should do the job of detecting
    the opening direction of the pet door.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect your own pet using an RFID tag attached to their collar to avoid other
    pets being able to get into your house.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting light threshold and temperature thresholds directly from the iOS device
    using a slider (UISliderView).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the temperature numeric indication with a more appealing graphical indicator
    like a gauge or a thermometer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notify you when your pet goes through the pet door.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show temperature in Celsius and Fahrenheit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before ending this chapter we would like to give an overview of the existing
    type of sensors, their communication protocols with Arduino, and the pros and
    cons of using them.
  prefs: []
  type: TYPE_NORMAL
- en: Sensors can be categorized into two major families (analog and digital) based
    on the kind of signal they provide. An analog sensor usually provides a voltage,
    which is proportional to the quantity it is measuring. This voltage has to be
    converted in a number using an ADC. Arduino provides six analog pins and each
    of them has its own ADC. The photoresistor that we are using in our project is
    a typical analog sensor. Conversely, a digital sensor directly provides a numeric
    representation of the measured quantity, which can be directly used. The temperature
    sensor, which we are using in this project, is an example of a digital sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Analog sensors are easier to use and cheaper, but they are very sensitive to
    power voltage fluctuations and electrical noise in the circuit. For these reasons
    the readings change a lot and it is usually needed to implement digital filters
    in code to smooth out the readings.
  prefs: []
  type: TYPE_NORMAL
- en: Digital sensors instead provide very stable readings and they are usually more
    precise. Unfortunately, they communicate with the microprocessor using different
    low-level protocols, which are more complex to handle. In the majority of the
    cases, protocol complexities are hidden by software libraries specialized for
    each type of sensor, but this makes coding more complex and libraries usually
    lead to a greater memory consumption which is a very precious resource on a microprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: The most used low-level protocols are **Serial Peripheral Interface** (**SPI**)
    and **Inter-integrated Circuit** (**I2C**). Another low-level protocol largely
    used for temperature sensors is the 1-Wire, which has been adopted for this project.
  prefs: []
  type: TYPE_NORMAL
- en: A complete comparison between these protocols is out of the scope of this project,
    but you can get an idea of them by referring to the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Protocol | Architecture | Signals needed | Multi- master | Data rate | Full
    duplex |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SPI | Two shared uni-directional data signals and a shared clock | SCK, MISO,
    MOSI, and one CS for each device on the board | Possible, but not standard | 1
    Mbps | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| I2C | Shared data signal and a shared clock signal | SDA and SCL | Yes |
    100 kbps, 400 kbps, and 3.2 Mbps | No |'
  prefs: []
  type: TYPE_TB
- en: '| 1-Wire | One data signal | Data | No | 15 kbps | No |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well done! You made it to the end of the chapter and you have built a project
    from scratch!
  prefs: []
  type: TYPE_NORMAL
- en: You have built the hardware, along with the electronic circuit, and written
    the software for both Arduino and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: On Arduino, you have learned how to use analog and digital sensors (1-Wire),
    how to write the code for reading them, how to control a servo motor, and how
    to handle the communication with the iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, you have learned how to write an application with a simple user interface
    and that the application's communication with Arduino via Bluetooth 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: We eventually discussed analog and digital sensors and some of the most used
    low-level communication protocols for exchanging data with Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build another project, which uses Wi-Fi instead
    of Bluetooth to transfer data. In that project, Arduino will accept different
    commands and react to it. The iOS application will have a table view, which is
    one of the most useful components provided by the UIKit.
  prefs: []
  type: TYPE_NORMAL
