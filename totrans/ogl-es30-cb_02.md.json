["```java\n    # Get the current local of the working directory\n    MY_CUR_LOCAL_PATH := $(call my-dir)\n\n    # Initialize variables to store relative directories\n    FRAMEWORK_DIR      = ../../../../GLPIFramework\n    SCENE_DIR          = ../../Scene\n    GLM_SRC_PATH       = $(FRAMEWORK_DIR)/glm\n    ZLIB_DIR           = $(FRAMEWORK_DIR)/zlib\n\n    # Clear the any garbage variable and include ZLIB\n    include $(CLEAR_VARS)\n    include $(MY_CUR_LOCAL_PATH)/../../../../GLPIFramework/zlib/Android.mk\n\n    LOCAL_PATH := $(MY_CUR_LOCAL_PATH)\n    include $(CLEAR_VARS)\n\n    # Name of the library\n    LOCAL_MODULE     :=   glNative\n\n    # Include the library and GLPI framework files\n    LOCAL_C_INCLUDES :=   $(GLM_SRC_PATH)/core \\\n                          $(GLM_SRC_PATH)/gtc \\\n                          $(GLM_SRC_PATH)/gtx \\\n                          $(GLM_SRC_PATH)/virtrev \\\n                          $(ZLIB_DIR) \\\n                          $(FRAMEWORK_DIR) \\\n                          $(SCENE_DIR)\n\n    # Specify the source files to compile\n    LOCAL_SRC_FILES :=    $(FRAMEWORK_DIR)/GLutils.cpp \\\n                          $(FRAMEWORK_DIR)/Cache.cpp \\\n                          $(FRAMEWORK_DIR)/ShaderManager.cpp \\\n       $(FRAMEWORK_DIR)/ProgramManager.cpp \\\n       $(FRAMEWORK_DIR)/Transform.cpp \\\n       $(SCENE_DIR)/Model.cpp \\\n       $(SCENE_DIR)/Renderer.cpp \\\n       $(SCENE_DIR)/Triangle.cpp \\\n       ../../NativeTemplate.cpp\n\n    # include necessary libraries\n    LOCAL_SHARED_LIBRARIES    := zlib\n    LOCAL_LDLIBS              :=  -llog -lEGL -lGLESv3\n\n    # Build as shared library\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```java\n    APP_PLATFORM    := android-18\n    APP_STL         := gnustl_static\n    APP_CPPFLAGS    := -frtti â€“fexceptions\n    ```", "```java\n    setenv( \"FILESYSTEM\", argv[ 0 ], 1 );\n    ```", "```java\n    class Triangle : public Model{\n    private:\n        // variables for holding attribute values\n        GLuint positionAttribHandle,colorAttribHandle;\n        GLuint radianAngle;\n\n        float degree; // Rotation in degree form\n        float radian; // Rotation in radian form\n\n    public:\n        Triangle(Renderer* parent = 0); // Constructor\n        ~Triangle();                    // Destructor\n\n        void InitModel();  // Initialize the model here\n        void Render();    // Perform the rendering\n    };\n    ```", "```java\n    enum ModelType{\n       //! The Triangle Model identifier.\n       TriangleType    = 0,\n       CubeType        = 1\n    };\n    ```", "```java\n    Triangle::Triangle( Renderer* parent ){\n       if (!parent) return;\n\n       RenderHandler      = parent;\n       ProgramManagerObj  = parent->RendererProgramManager();\n       TransformObj       = parent->RendererTransform();\n       modelType          = TriangleType;\n       degree             = 0;\n    }\n    ```", "```java\n    #ifdef __APPLE__\n    #define VERTEX_SHADER_PRG \"BlueTriangleVertex.glsl\"\n    #define FRAGMENT_SHADER_PRG \"BlueTriangleFragment.glsl\"\n    #else\n    #define VERTEX_SHADER_PRG \"shader/BlueTriangleVertex.glsl\"\n    #define FRAGMENT_SHADER_PRG \"shader/BlueTriangleFragment.glsl\"\n    #endif\n    ```", "```java\n    void Triangle::InitModel(){\n    if(!(program = ProgramManagerObj->Program\n     ( ( char* )\"Triangle\") )){\n       program = ProgramManagerObj->ProgramInit\n    ( ( char * )\"Triangle\" );\n       ProgramManagerObj->AddProgram( program );\n     }\n     // Initialize Shader \n     program->VertexShader   = ShaderManager::ShaderInit\n                   (VERTEX_SHADER_PRG, GL_VERTEX_SHADER);\n     program->FragmentShader = ShaderManager::ShaderInit\n                   (FRAGMENT_SHADER_PRG, GL_FRAGMENT_SHADER);\n\n     // Allocate the buffer memory for shader source \n     CACHE *m = reserveCache( VERTEX_SHADER_PRG, true );\n     if( m ) {\n       if(!ShaderManager::ShaderCompile\n         (program->VertexShader,(char*)m->buffer, 1)) exit(1);\n          mclose( m );\n     }\n\n     m = reserveCache( FRAGMENT_SHADER_PRG, true );\n     if( m ) {\n       if(!ShaderManager::ShaderCompile\n          (program->FragmentShader,(char*)m->buffer,1))exit(2);\n           mclose( m );\n     }\n     // Link and Use the successfully compiled shader\n     if(!ProgramManagerObj->ProgramLink(program,1)) exit(3);\n     glUseProgram( program->ProgramID );\n    }\n    ```", "```java\n    void Triangle::Render(){\n       // Use the shader program for this render\n       glUseProgram( program->ProgramID );\n\n        radian = degree++/57.2957795;\n\n        // Query and send the uniform variable.\n        radianAngle = glGetUniformLocation\n                    (program->ProgramID, \"RadianAngle\");\n        glUniform1f(radianAngle, radian);\n\n        positionAttribHandle = ProgramManagerObj->\n                       ProgramGetVertexAttribLocation\n                       (program,(char*)\"VertexPosition\");\n        colorAttribHandle = ProgramManagerObj->\n                      ProgramGetVertexAttribLocation\n                      (program, (char*)\"VertexColor\");\n\n        // Send the data to the shader    \n        glVertexAttribPointer(positionAttribHandle, 2,\n              GL_FLOAT, GL_FALSE, 0, gTriangleVertices);\n        glVertexAttribPointer(colorAttribHandle, 3, \n              GL_FLOAT, GL_FALSE, 0, gTriangleColors);\n\n        // Enable the attribute and draw geometry \n        glEnableVertexAttribArray(positionAttribHandle);\n        glEnableVertexAttribArray(colorAttribHandle);\n        glDrawArrays(GL_TRIANGLES, 0, 3); \n      }\n    ```", "```java\n      Triangle::~Triangle(){\n        // Remove the shader in the destructor\n        if (program = ProgramManagerObj->Program\n                      ((char*) \"Triangle\"))\n        {   ProgramManagerObj->RemoveProgram(program); }\n      }\n    ```", "```java\n    void Renderer::createModels(){\n      clearModels();\n      addModel(new Triangle(this )); //Add custom models here\n    }\n    ```", "```java\n       // Declaration\n       void TouchEventDown(float x, float y);\n\n       // Definition\n       void Renderer::TouchEventDown( float x, float y ){\n       for( int i=0; i<RenderMemData.models.size(); i++ ){\n           RenderMemData.models.at(i)->TouchEventDown(x, y);\n       }\n    }\n    ```", "```java\n    void TouchEventDown( float x, float y ) // Declaration\n    void TouchEventDown( float x, float y ){ // Definition\n       Renderer::Instance().TouchEventDown( x, y );\n    }\n    ```", "```java\n    public static native void TouchEventStart(float x,float y);\n    ```", "```java\n    // Declaration of Tap event\n    JNIEXPORT void JNICALL \n    Java_cookbook_gles_GLESNativeLib_TouchEventStart \n                             (JNIEnv * env, jobject obj, float x, float y );\n\n    // Definition of Tap event\n    JNIEXPORT void JNICALL\n    Java_cookbook_gles_GLESNativeLib_TouchEventStart\n                             (JNIEnv * env, jobject obj, float x, float y )\n    {\n       TouchEventDown(x ,y);\n          }\n    ```", "```java\n    public boolean onTouchEvent( final MotionEvent e ){\n      switch( event.getAction() ){\n      case MotionEvent.ACTION_DOWN: // Tap event\n      GLESNativeLib.TouchEventStart(e.getX(0),e.getY(0));\n      break;\n\n      case MotionEvent.ACTION_MOVE: // Move event\n      GLESNativeLib.TouchEventMove (e.getX(0), e.getY(0)); \n      break;\n\n      case MotionEvent.ACTION_UP: // Release event\n      GLESNativeLib.TouchEventRelease(e.getX(0),e.getY(0));\n      break;\n      }\n      return true;\n    }\n    ```", "```java\n    - (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent *)event{\n       UITouch *touch; CGPoint pos;\n       for( touch in touches ){\n           pos = [ touch locationInView:self.view ];\n           TouchEventDown( pos.x, pos.y ); //The global wrapper\n       }\n    }\n\n    - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{\n       UITouch *touch; CGPoint pos;\n       for( touch in touches ){\n          pos = [ touch locationInView:self.view ];\n          TouchEventMove( pos.x, pos.y ); // The global wrapper\n       }\n    }\n\n    - (void)touchesEnded:(NSSet*)touches withEvent:(UIEvent*)event{\n       UITouch *touch; CGPoint pos;\n       for( touch in touches ){\n          pos = [ touch locationInView:self.view ];\n          TouchEventRelease(pos.x,pos.y); // The global wrapper\n       }\n    }\n    ```", "```java\nvoid Renderer::TouchEventMove( float x, float y ){\n   for( int i=0; i<RenderMemData.models.size(); i++ ){\n      // Handle the Touch events at model levels.\n      RenderMemData.models.at(i)->TouchEventMove(x, y);\n   }\n}\n```", "```java\n    // Source code PrimitiveVertex.glsl\n    #version 300 es\n    in vec4 VertexPosition, VertexColor;\n    out vec4 VarColor;\n    uniform mat4 ModelViewProjectMatrix;\n\n    void main(){\n      gl_Position = ModelViewProjectMatrix * VertexPosition;\n      VarColor    = VertexColor;\n    }\n\n    // Source code PrimitiveFragment.glsl\n    #version 300 es\n    precision mediump float;\n\n    in vec4 VarColor;\n    out vec4 FragColor;\n    void main() {\n      FragColor = vec4(VarColor.x,VarColor.y,VarColor.z,1.0);\n    }\n    ```", "```java\n      void Primitives::InitModel(){\n       // Shaders are compiled and linked successfully\n       // Many line skipped, please refer to the code\n       glUseProgram( program->ProgramID ); \n       attribVertex=ProgramManagerObj->ProgramGetVertexAttribLocation        \n                   (program, (char*)\"VertexPosition\");\n       attribColor=ProgramManagerObj->ProgramGetVertexAttribLocation\n                   (program, (char*)\"VertexColor\");\n      }\n    ```", "```java\n        char ProgramManager::ProgramGetVertexAttribLocation \n                                    (PROGRAM *program, char* name);\n        ```", "```java\n      mvp = ProgramManagerObj->ProgramGetUniformLocation \n                   (program,(char*)\"MODELVIEWPROJECTIONMATRIX\");\n    ```", "```java\n        GLint ProgramGetUniformLocation\n                          (PROGRAM *program, char* name);\n        ```", "```java\n      void RenderPrimitives(){\n        glDisable(GL_CULL_FACE); // Disable the culling\n        glLineWidth(10.0f);      // Set the line width \n\n        glUniformMatrix4fv( mvp, 1, GL_FALSE,( float * )\n         TransformObj->TransformGetModelViewProjectionMatrix() );\n\n        glVertexAttribPointer(attribVertex, 2, GL_FLOAT, \n        GL_FALSE, 0, vertices);\n        glVertexAttribPointer(attribColor, 3, GL_FLOAT, \n        GL_FALSE, 0, colors);\n       }\n    ```", "```java\n      glEnableVertexAttribArray(attribVertex);\n      glEnableVertexAttribArray(attribColor);\n      glDrawArrays(primitive, 0, numberOfElement);\n    ```", "```java\nvoid glDrawArrays( GLenum mode, GLint first, GLsizei count);\n```", "```java\n   GLfloat  square[6][3] = {\n      -1.0, -1.0, 1.0, /*Vertex0*/  1.0,-1.0, 1.0,  /*Vertex3*/\n      -1.0,  1.0, 1.0, /*Vertex1*/  1.0, -1.0, 1.0, /*Vertex3*/\n       1.0,  1.0, 1.0, /*Vertex2*/ -1.0,  1.0, 1.0, /*Vertex1*/\n   };\n  glDrawArrays(GL_TRIANGLES, 0, 18);\n```", "```java\nvoid glDrawElements( GLenum mode, GLsizei count, GLenum type, const GLvoid * indices);\n```", "```java\nGLfloat square[4][3] = {\n   -1.0, -1.0, 1.0, /*Vertex0*/  -1.0,  1.0, 1.0, /*Vertex1*/\n    1.0,  1.0, 1.0, /*Vertex2*/   1.0, -1.0, 1.0, /*Vertex3*/\n};\nGLushort squareIndices[] = {0,3,1, 3,2,1};   // 6 indices\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, squareIndices);\n```", "```java\n       void Cube::InitModel(){\n       . . . . . // Load shaders\n       glUseProgram( program->ProgramID );\n\n       MVP = ProgramManagerObj->ProgramGetUniformLocation\n                    (program, (char*)\"ModelViewProjectionMatrix\");\n       attribVertex=ProgramManagerObj->ProgramGetVertexAttribLocation \n                    (program, (char*)\"VertexPosition\");\n       attribColor = ProgramManagerObj->ProgramGetVertexAttribLocation\n                    (program, (char*)\"VertexColor\");\n       // Enable Vertex atrb\n    glEnableVertexAttribArray(attribVertex);\n       // Enable Color atrb\n    glEnableVertexAttribArray(attribColor);\n    }\n    ```", "```java\n         glUseProgram( program->ProgramID );\n         TransformObj->TransformRotate(k++, 1.0, 1.0, 1.0);\n         glUniformMatrix4fv( MVP, 1, GL_FALSE,(float*)TransformObj->\n\n          if ( useDrawElementAPI ){ //Toggle the flag by tap event\n    glVertexAttribPointer(attribColor, 3, GL_FLOAT, GL_FALSE, 0, cubeColors);\n    glVertexAttribPointer(attribVertex, 3, GL_FLOAT, GL_FALSE, 0, cubeVerts);\n    glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_SHORT, cubeIndices);\n          }\n          else{\n             glVertexAttribPointer(attribColor, 3, GL_FLOAT, \n             GL_FALSE, 0, colorBufferData);\n             glVertexAttribPointer (attribVertex, 3, GL_FLOAT, \n             GL_FALSE, 0, vertexBuffer);\n             glDrawArrays(GL_TRIANGLES, 0, 36);\n          }\n    ```", "```java\n        void glGenBuffers(GLsizei n, GLuint* buffers);\n        ```", "```java\n        void glBindBuffer(GLenum target, GLuint buffer);\n        ```", "```java\n        void glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);\n        ```", "```java\n        void glBufferSubData(GLenum target, GLintptr offset,GLsizeiptr size, const GLvoid * data);\n        ```", "```java\n    float size = 24*sizeof(float);\n    glGenBuffers(1, &vId);\n\n    glBindBuffer(GL_ARRAY_BUFFER, vId );;\n    glBufferData(GL_ARRAY_BUFFER,size+size,0,GL_STATIC_DRAW);;\n    glBufferSubData(GL_ARRAY_BUFFER, 0, size, cubeVerts);\n    glBufferSubData(GL_ARRAY_BUFFER, size,size,cubeColors);\n\n    unsigned short indexSize = sizeof( unsigned short )*36;\n    glGenBuffers(1, &iId);\n    glBindBuffer(GL_ARRAY_BUFFER, iId);\n    glBufferData(GL_ARRAY_BUFFER, indexSize,0,GL_STATIC_DRAW);\n    glBufferSubData(GL_ARRAY_BUFFER,0,indexSize,cubeIndices);\n    /* Once the VBO created and used, reset the array and element buffer array to its original state after use, this is done by binding 0 to array and element buffer*/ \n    glBindBuffer( GL_ARRAY_BUFFER, 0 );\n    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );\n    ```", "```java\n    // Specify VBO-ID for send attribute data \n    glBindBuffer( GL_ARRAY_BUFFER, vId );\n    glVertexAttribPointer\n       (attribVertex, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);glVertexAttribPointer\n       (attribColor, 3, GL_FLOAT, GL_FALSE, 0,(void*)size);\n\n    // Specify VBO for element index array \n    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iId );\n    glDrawElements(GL_TRIANGLES,36,GL_UNSIGNED_SHORT,(void*)0);\n    glBindBuffer( GL_ARRAY_BUFFER, 0 );\n    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );\n    ```", "```java\n(a, b , c, w) => (a/w, b/w, c/w, w/w) => (a/w, b/w, c/w, 1)\n```", "```java\n        void Transform::TransformSetMatrixMode( unsigned int mode )\n        ```", "```java\n    void Renderer::setUpProjection(){\n       Transform*   TransformObj = &RenderMemData.TransformObj;\n\n    //Set up the PROJECTION matrix.\n       TransformObj->TransformSetMatrixMode( PROJECTION_MATRIX );\n       TransformObj->TransformLoadIdentity();\n    // Many lines skipped. \n    // For more information refer to next recipe\n    }\n    ```", "```java\n    void Renderer::setUpView(){\n        Transform*  TransformObj = &RenderMemData.TransformObj;\n    //Set up the VIEW matrix.\n        TransformObj->TransformSetMatrixMode( VIEW_MATRIX );\n        TransformObj->TransformLoadIdentity();\n\n    // The viewer is -2 and -15 units away on y and z axis \n        TransformObj->TransformTranslate(0, -2, -15);\n    }\n    ```", "```java\n    void Renderer::setUpModel(){\n        Transform*    = &R TransformObj enderMemData.TransformObj;\n    //Set up the MODEL matrix.\n        TransformObj->TransformSetMatrixMode( MODEL_MATRIX );\n        TransformObj->TransformLoadIdentity();\n    }\n    ```", "```java\n        void Cube::Render(){ \n\n           static float k = 0;\n           Transform* TransformObj = MapRenderHandler->\n        RendererTransform();\n            // Rotate the whole Geometry along Y-Axis\n            TransformObj->TransformRotate(k++, 0, 1, 0);\n\n            // Render C1 Box at Vertical 2 Units Up\n            TransformObj->TransformPushMatrix();\n            TransformObj->TransformTranslate( 0, 2, 0);\n            RenderCubeVBO();\n            TransformObj->TransformPopMatrix();\n\n            // Render C2 Box at Vertical 4 Units Up\n            TransformObj->TransformPushMatrix();\n            TransformObj->TransformTranslate( 0, 4, 0);\n            RenderCubeVBO();\n            TransformObj->TransformPopMatrix();\n\n            // Similarly, Render C3 to C8 boxes\n        }\n        ```", "```java\n        void TransformTranslate(float Tx, float Ty, float Tz);\n        ```", "```java\n        void TransformScale(float Sx, float Sy, float Sz);\n        ```", "```java\n        void TransformRotate(float angle,float Rx,float Ry,float Rz);\n        ```", "```java\n        void Transform::TransformSetPerspective( float fovy, float aspect_ratio, float clip_start, float clip_end, float screen_orientation )\n        ```", "```java\n        void Transform::TransformOrtho( float left, float right, float bottom,float top,float clip_start,float clip_end )\n        ```", "```java\n    void Renderer::setUpProjection(){\n     RenderMemData.isPerspective   = true;\n     float span                    = 10.0;\n\n     //Set up the projection matrix.\n     TransformObj->TransformSetMatrixMode( PROJECTION_MATRIX );\n     TransformObj->TransformLoadIdentity();\n\n     //Set up the Perspective/Orthographic projection.\n     if (RenderMemData.isPerspective){\n      TransformObj->TransformSetPerspective(60.0f, 1, 1.0, 100,0);\n     }\n     else{\n      TransformObj->TransformOrtho( -span,span,-span,span,span,span);\n     }\n\n     // Set the camera 10 units away\n     TransformObj->TransformSetMatrixMode( VIEW_MATRIX );\n     TransformObj->TransformLoadIdentity();\n     TransformObj->TransformTranslate(0.0f, 0.0f, -10.0f);\n\n     // Make the scene ready to render models\n     TransformObj->TransformSetMatrixMode( MODEL_MATRIX );\n     TransformObj->TransformLoadIdentity();\n    }\n    ```", "```java\nvoid glCullFace(GLenum mode);\n```", "```java\nvoid Cube::Render(){\n  glEnable( GL_CULL_FACE  ); // Enable the culling\n  if (toogle){\n    glCullFace( GL_FRONT ); // Culls geometries front face\n  }\n  else{\n    glCullFace ( GL_BACK ); // Culls geometries back face\n  }\n . . . . . . .}\n```", "```java\nvoid Cube::Render(){\n   static float k,j,l = 0;\n  if (toogle){\n      glEnable( GL_DEPTH_TEST );\n    }\n    else{\n        glDisable( GL_DEPTH_TEST );\n    }\n\n    // Rotate Both Cube Models\n    TransformObj->TransformPushMatrix();\n    TransformObj->TransformRotate(k=k+1, 0, 1, 0);\n\n    // Render and Rotate Cube model\n    TransformObj->TransformPushMatrix();\n        TransformObj->TransformTranslate( 0, 0, -3);\n        TransformObj->TransformRotate(j=j+4, 0, 1, 0);\n        RenderCubeVBO();\n    TransformObj->TransformPopMatrix();\n\n    // Render and Rotate Second Cube model\n    TransformObj->TransformPushMatrix();\n        TransformObj->TransformTranslate( 0, 0, 3);\n        TransformObj->TransformRotate(l=l-2, 0, 1, 0);\n        RenderCubeVBO();\n    TransformObj->TransformPopMatrix();\n    TransformObj->TransformPopMatrix();\n}\n```", "```java\nVoid glDepthFunc(GLenum func);\n```"]