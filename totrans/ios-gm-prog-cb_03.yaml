- en: Chapter 3. Animations and Texture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0018_split_000.html#page "Chapter 2. SpriteKit"), *SpriteKit*,
    you learned about the basic structure of SpriteKit and its building blocks such
    as scenes, nodes, sprites, and so on. We got a flying spaceship in the sky by
    touching the screen, and now in this chapter we will be moving to a fully featured
    game play for the user.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about how the content of sprites are changed using animations,
    how textures (which store sprite data) are used to render the sprites, how to
    create a large image for all game assets using the texture atlas, some character
    (spaceship) animations, and last but the most beautiful will be creating a parallax
    background for the game full of animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be focusing on the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating your textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a texture atlas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding animations using a texture atlas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallax background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding animations into our games using SpriteKit is an easy task, as we did
    in the previous chapter, where we added some `SKAction` functions to get the spaceship
    to move. These were the animations related to their movement, orientations, and
    somewhat related to their transformations. However, now the animation that we
    are going to talk about is the content change of a sprite. Animations will be
    animating multiple images (that is, frames) of the same sprite multiple times
    per second, giving a feel of being alive for the sprite. This is somewhat similar
    to the way we capture the videos, it's just a sequence of the snapshots per second.
    These types of animations need a lot of images to be accomplished thereby increasing
    the memory size for these textures. The texture is represented by a `SKTexture`
    object created and attached with the sprite. Texture object automatically loads
    the sprite data (called Texture data) whenever it is visible and is used to render
    the sprite in the respective scene. And when the sprite is removed or not visible
    in the scene, it deletes the texture data, and as a result automatic memory management
    is simplified.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, all of this means that sprites have display frames, which have
    different textures that change by a fixed delay between each frame. And everything
    we are going to do in the starter and solution kit will be continued from where
    we left in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Animating your textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at how textures are created and attached to sprites.
    We will also do some content change (that is, frame changing animations) with
    the help of textures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with textures to be animated, we should know about scenes, nodes,
    and sprites. As sprites are created with an image and are added on scene, which
    occupies more memory, textures should be a solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, as memory management is more optimized with texture, we can start with
    the animations to change the frames of a sprite by a fixed time. For that, we
    will be showing a prop in the environment, which is a coin rotating 360 degrees
    horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps involved to make a coin look like it is rotating
    360 degrees horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, copy all the images (that is, frames) of the coin as provided
    in the `Project_Resources` folder with the kit. There are total six images of
    coins, each rotated at an angle horizontally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method to `FSMyScene` called `addCoin` in which we create a sprite for
    the coin with the initial image to be displayed on the sky background using texture
    (`Coin1.png`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To show the coin on the screen, specify its position; as of now, the position
    is set to the center of the screen, and then add it to the `FSMyScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, create textures for the remaining frames of the coin to add frame
    animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Combining all coin textures creates an array of texture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `SKAction` class for `coinAnimation` using a class method of `SKAction`
    and run the action on the coin sprite added on `FSMyScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adding all these lines of code makes our `addCoin` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a texture object using `SKTexture`, as we did in the preceding
    section, the texture stores the image (that is, frame) data into it which is further
    forwarded to create a sprite. This helps in memory management, because when the
    sprites are removed, the data associated with them (that is, texture) is also
    removed thereby releasing the memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the coin is also added using texture in the center of the screen
    with its initial frame, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we will see how animations of frames work using a number of textures. We
    have just created some textures using some coin images, which are visually designed
    in increasing order of horizontal rotation angle. So an array in the same order
    of textures is created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using a class method of `SKAction`, the coin animation textures array is given
    as an input with a frame delay of 0.2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function takes the textures and shows them with a delay of 0.2
    seconds in the order the textures are given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the overall `addCoin` method with the animation code written gives a
    feel that a coin has rotated horizontally once in the center of the screen, and
    this is what the scene looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a texture atlas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The texture atlas is a way of combining all the app assets (that is, images)
    into one or more larger images to improve the performance of the app so that the
    app can draw multiple images in a single draw call of the scene that is rendered.
    For example, if we have more than one image file to be loaded in the sprite, SpriteKit
    will perform one drawing call for each sprite. However, if we combine all the
    required images in one image file, then SpriteKit can render all the sprites in
    one draw call that uses very less memory to do so. It is recommended to create
    an atlas of all the required images for any game project.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode has the capability of building texture atlases for your collection of
    images to make it a larger image, thereby improving the performance. While creating
    texture atlases, there should be a balance of too many or very few textures, so
    that the memory load doesn't increase.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a texture atlas, we should be aware of what sprites and textures are,
    most importantly how the sprite is created using textures. We will take the *Animating
    your textures* recipe as a reference to start this. In this recipe, we will be
    learning how to create a texture atlas for a collection of images that are coin
    images used for animation and the spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to be performed for creating a texture atlas for
    a collection of images:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a system folder where your project is stored in the starter project of
    `FlyingSpaceship`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It should not be an Xcode group folder; it has to be a system folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In that folder, add all images of coins and the image of the spaceship added
    previously in the app bundle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Resources` folder and click on **Add Files to "FlyingSpaceship"**.![How
    to do it...](img/00029.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A finder view is opened. From there, select `FSGame.atlas` and click on the
    **Add** button. Whenever we build the project, the compiler looks for folders
    with a naming convention such as `name.atlas`. Hence, the folders are identified
    and all the images in that folder are combined to form one or more large images.![How
    to do it...](img/00030.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding the `FSGame.atlas` file to the project, the `Resources` folder
    looks like this:![How to do it...](img/00031.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, for enabling the generation of the Texture Atlas, go to the build settings
    of the project and search for type `Spritekit`; the search results will look like
    this:![How to do it...](img/00032.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can see the **Enable Texture Atlas Generation** field in the **SpriteKit
    Deployment Options** section. Set that bool to **Yes**.![How to do it...](img/00033.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, whenever we build the project, the compiler generates a property
    list to access the images of the texture atlas by its name, which we have given
    to the folder.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the creation of the texture atlas, the most important part is how we will
    be able to access images from the texture atlas. It's done by enabling the bool
    **Enable Texture Atlas Generation**. After this, whenever we build the project,
    the compiler looks for folders with a naming convention such as `name.atlas`.
    Hence, the folders are identified and all the images in that folder are combined
    to form one or more large images.
  prefs: []
  type: TYPE_NORMAL
- en: Here, Xcode generates a `.plist` file after setting the bool. After that, the
    texture atlas name is used to get the texture atlas in the code and from there
    we can get any image, which is put in that folder that is, texture atlas.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we create a texture atlas, there is always a trade-off between using
    too many textures or few images. When using few images SpriteKit still needs to
    make many drawing calls to render each frame. And for many textures, the images
    in quantity may increase the texture data thereby leading to a load on the memory.
    So it's up to us how we want to go; we can switch between both the alternatives
    with relative ease. Hence, different configurations can be tried out to have the
    best performance.
  prefs: []
  type: TYPE_NORMAL
- en: Adding animations using a texture atlas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned about animations even before learning how to use textures
    for loading images from `App Bundle`. As we have a texture atlas (that is, a larger
    combined image), we will be loading the images by that texture atlas. All sprites
    added in the `FSMyScene` file are loaded by the images from the `App Bundle`,
    so now we will be loading all the images by the texture atlas in the sprite. Lastly,
    some animations will be applied to them using the texture atlas to load the images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting with the animations using a texture atlas to load images, we
    should know the process of creating a texture atlas using a combination of images
    and doing some animations of changing frame after a fixed delay. So here we will
    be doing the same animation of coin rotation we did earlier, but now using a texture
    atlas. This recipe will be called *Adding animations using a texture atlas*. After
    that we will animate a bunch of coins from one end to another (right to left)
    in the `FSMyScene` in a random fashion giving a feel that coins are just moving
    in the sky.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we will be replacing the creation of textures using the image
    by the texture atlas images in `App Bundle`. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an object of `SKTextureAtlas` by specifying its name that is, `FSGame`
    (name of the texture atlas).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The images previously added to the project bundle should be removed to avoid
    redundancy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now create the texture using a texture atlas object by passing the spaceship
    image that has to be set to the sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `addCoin` method of FSMyScene, use the preceding process to create the
    textures using the t`extureAtlas` object for all coin textures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once all the textures are created, use the same code of `addCoin` to add and
    animate the coin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make the coin animation more live and natural. Feed the action formed
    for animating the texture with a fixed delay to another `SKAction` making it repeat
    forever giving a feel of continuous rotation of coin (never ending).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After a little tweaking, remove the last texture from the array so that when
    the `repeatForever` action is going to run, the first image will appear after
    the last image, so there is no need for the last texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now our forever rotating coin is built and can be used either as a prop or collectables
    in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps to make the coins collectables:'
  prefs: []
  type: TYPE_NORMAL
- en: For making a coin move from the left end to the right end of the screen, we
    have to calculate the initial and final positions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, set the initial position as the coin sprite position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The initial position of the coin is set and now we have to animate the coin
    from the initial position to the final position. This can be done by adding a
    move `SKAction` to the coin sprite specifying its final destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, our `addCoin` method has been fully prepared for the game. For moving
    the coins as collectables, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For making these coins move as collectables in the scene, a little bit of refactoring
    is required in the update method. Update the `diffTim`e and `lastUpdatedTime`
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now using `currentTime`, create a timer kind of functionality by declaring a
    property called `lastCoinAdded` in the private interface of FSMyScene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So this is the timer added in the update method and the diff of `currentTime`
    and `lastCoinAdded` is checked by 1\. Hence, after every 1.0 second, a coin will
    be added with animation moving from left to right on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, our update method is ready to animate multiple coins after a set delay.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we were creating the sprite using images from `App Bundle`, but now we
    will be using texture atlas to get the images and passing to the sprites. The
    preceding texture atlas named `FSGame.atlas` holds multiple images of coins and
    spaceship in it. The internal code loads the frames and stores them in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'SpriteKit first searches for the image file, if not found it searches inside
    the texture atlases build into the app bundle. If we want to work explicitly with
    texture atlases, use the `SKTextureAtlas` class. It fetches the texture atlas
    by specifying its name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then we can use the atlas object to get the required image for creation of sprites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we will understand how the coins are converted into collectables. For moving
    the coins, its initial and final positions are to be decided.
  prefs: []
  type: TYPE_NORMAL
- en: The initial position in *x* dimensions, is fixed to the width of the frame plus
    half of its coin so that it is added outside the screen and *y* dimensions are
    randomly chosen from 0 to 320 using the `arc4random()`function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the final position, the *x* dimension is set to negative of half of its
    own width and the *y* dimension is the same as the initial position *x*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How it works…](img/00034.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now the collectable is ready to be added to the scene. But for multiple coins
    to be added moving left to right on the scene, a timer has to be implemented.
    The timer looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After all these implementations, multiple coins are seen moving from left to
    right as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our game integrated with collectables. Let's see how the spaceship will
    collect these collectables that is, coins. In character animation, we will be
    doing the animations on the spaceship and the coins when they collide with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on to the complex animations to be applied on the entities of
    the scene, the understanding of actions (that is, `SKAction`) and update function
    of scene (`SKScene`) has to be there. This is so that during updation we can detect
    the collision between the coin and the spaceship and do some animations on both
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps involved in detecting the collision and animating
    both the entities (coin and spaceship):'
  prefs: []
  type: TYPE_NORMAL
- en: Write an `detectSpaceShipCollisionWithCoins` method in which we will enumerate
    the coin objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In that enumeration, determine that the frame of the spaceship and the frame
    of any coin intersects with the help of `CGRectIntersectsRect()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a collision is detected, inform the scene that a coin has collided with
    the spaceship by a function called `spaceShipCollidedWithCoin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After all this, the `detectSpaceShipCollisionWithCoins` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After detecting the collision, the `spaceShipCollidedWithCoin` function is
    invoked, which calls two other functions that implement animation methods for
    the spaceship and coin that have collided. The definition of this method looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The animation written for the spaceship is as if it is taking the coin into
    itself. There are two actions created for `scaleUp` and `scaleDown` with a scale
    factor 1.4 and 1.0 respectively to be played for 0.2 each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, these two animation arrays are formed to be used for creating a
    sequence action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly the sequence action formed runs on the spaceship.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the coin, the animation should be as if it is disappearing as it is taken
    by the spaceship. Thus, two core animations `fadeOut` and `scaleDown` are created
    with a 0.2 scale factor having a time interval of 0.4 each, forming an array of
    animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using these animations, a group animation is formed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As for the coin, when it collides with the spaceship, it has to be removed from
    the scene when its animation is over. So create an action using the block to remove
    the coin after the previously created group animation is completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the animations are ready, create the sequence action for it using an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hence, the coin looks as if it is disappearing when the preceding complex actions
    run on the coin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As all the code of the animation and collision detection is done, call the `detechSpaceShipCollisionWithCoins`
    method, so that in each frame the collision is detected and the coin is collected
    by the character of the game (that is, the spaceship).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important part of this section is the collision detection. It is done
    with the help of the `CGRectIntersectsRect` method in which the coins are enumerated
    and checked whether their frames intersect the spaceship frame. If they do, then
    two different animations are played on the coin and spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When detection happens, the game looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we come to animations. The animation of the spaceship is a simple one. Just
    to give a feel of collecting the coins, `scaleUp` and `scaleDown` animations are
    used in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for coins, a complex one with three actions is created, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FadeOutAction` to fade the coin for 0.4 seconds, which appears to be disappearing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ScaleDownAction` to scale down the coin to make it shrink into the spaceship
    in 0.4 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `CallBack` function that is used to remove the coin from the scene when the
    preceding animations are over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After creation of all these actions, a group of `fadeOut` and `scaleDown`, a
    sequence of animation with a sequence of group animation and callback action is
    created, which is applied on the coin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever there is a collision, the spaceship scales up and down with the coin
    fading out as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Parallax background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now our mini game FlyingSpaceship is about to finish. To give the feel of a
    game environment we will introduce a parallax scrolling background. A parallax
    scrolling background is composed of multiple background layers (that is, nodes);
    animating them simultaneously gives a feel of dynamic background. To add some
    cool flyers to the game we will add two layers of background: the `SpaceBlueSky`
    and the `SpaceWhiteMist` in the form of nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start with this cool feature, we should be aware of the scrolling background
    created in the previous chapter and have a basic knowledge of sprites, nodes,
    and math. We are going to cook the *Parallax background* recipe in the FlyingSpaceship
    game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create multiple scrolling backgrounds with varying speeds of scrolling,
    we will be creating a class for it to accomplish the parallax background. The
    steps involved in creating a class for parallax background named as `FSParallaxNode`
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file by right clicking on the **FlyingSpaceship** project.![How
    to do it…](img/00039.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Objective-C Class** in the **Cocoa Touch** section.![How to do it…](img/00040.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the class `FSParallaxNode` and click on **Next**.![How to do it…](img/00041.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now to create the class, select the `FlyingSpaceship` folder in which it has
    to be created and click on **Create**.![How to do it…](img/00042.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to add two methods in the header of `FSParallaxNode`. Firstly, in
    the `init` method, we need to specify `imageFiles`, which are the images to be
    scrolled, the canvas size, and the velocity with which the images will scroll.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Secondly, an update method called from the update of Scene in which the `FSParallaxNode`
    method is added so that the scrolling is made infinite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `FSParallaxNode.m`, declare some properties in its private interface to store
    all background nodes, counts of backgrounds, and velocity of that parallax node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In definition of the `init` method, first assign all the parameters passed in
    the function like `velocity`. Now we assign `noOfBackgrounds` using the `imageFiles`
    count and make an array of backgrounds with a capacity of `noOfBackgrounds`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `imageFiles`, enumerate them using the block. In enumeration, add
    background nodes using the `imageFiles` class, add them to the backgrounds array
    and on `FSParallaxNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, specify the `backgroundNode` size, which is passed in the `init` method,
    its `anchorPoint` to `CGPointZero`, its position according to the `idx` integer
    and a name of the node as `background`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After all this, our `init` method is ready as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's see how these backgrounds added on `FSParallaxNode` are to be scrolled;
    it will be done by an instance update method.
  prefs: []
  type: TYPE_NORMAL
- en: Some `cleanUp` has to be done or in other terms some code movement. Copy the
    two static methods used in the `FSMyScene` to `FSParallaxNode` class used for
    some math, remove the initialization of the `SpaceBackground` method and the call
    of moving background made in the update from `FSMyScene`. Cut the code of the
    method for moving the background from the `FSMyScene` file and paste in the `updateForDeltaTime`
    function of `FSParallaxNode`. Now we will be making some tweaks to the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SKParallax` node is the parent for all the other nodes of backgrounds added
    on it. So using the velocity, send in the `init` and `diffTime`, method which
    will be passed by the `FSMyScene` update methods, we calculate the position of
    the parent that is, `FSParallax` node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now enumerate the backgrounds that is, all nodes added to the parent. In this
    enumeration, find the position of an individual background with respect to the
    parent node. After this, check whether the position of a background is less than
    the negative of its width (that is, reached the left end), then change the position
    of that background to its right end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, our update method is constructed, which provides a functionality of
    multiple backgrounds scrolling infinitely.![How to do it…](img/00044.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As of now, the `FSParallaxNode` class, which provides the functionality of parallax
    scrolling background is created and it's time to create objects in `FSMyScene`
    to make a cool environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will be adding two background layers BlueSky and WhiteMist, so create two
    objects for each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a method called `addParallaxNodes` and call it in the first line of the
    `init` method of `FSMyScene`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For two parallax nodes, we have to add the following two constants for their
    relative speeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `addParallaxNodes,` make an array of `blueSkyParallaxBackgroundImages` and
    create an object of `FSParallax` by passing the size of the scene and velocity
    at which it is going to scroll.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the blue sky background, we have to implement the mist images as
    well. To add more reality to the game, we will add the `mistParallaxBackgroundImages`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the nodes have been added to the scene, they need to be updated for scrolling
    purposes. So call the `updateForDeltaTime` function of `FSMyScene` for both the
    nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After all these steps, the dynamic environment with a parallax scrolling background
    is ready for the game.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have done the scrolling of background in the previous chapter, it is
    time we made a separate class for it called `FSParallaxNode`. In this class, multiple
    backgrounds of the same image are placed and scrolled in each update of the scene.
    It means that the scrolling is done on the basis of the positions of all background
    nodes added to `FSParallaxNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this `FSParallaxNode`, two objects of it are created: `BlueSkyBackground`
    and `WhiteMistBackground`. All are added as normal nodes to the scene in the `init`
    method. For them to scroll, the update method calls the `updateForDeltaTime` function
    in which the class checks for the position of individual background positions
    reached at the left end of the screen and changes the position so that it again
    starts with the right-end side. This whole algorithm makes these individual backgrounds
    scroll making a full parallax scrolling background. The parallax scrolling background
    really looks cool as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
