- en: Classes and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Initializing body of constructor
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化构造函数的主体
- en: Converting one data type into another
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一种数据类型转换为另一种类型
- en: How to type check an object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检查一个对象的数据类型
- en: How to work with an abstract class in Kotlin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中使用抽象类
- en: How to iterate over a class's properties in Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中遍历类的属性
- en: How to work with inline properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用内联属性
- en: How to work with nested class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用嵌套类
- en: Getting class in Kotlin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中获取类
- en: Working with delegated properties
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用委托属性
- en: Working with enums
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用枚举
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, you will be introduced to recipes related to object-oriented
    programming in Kotlin. Using an OOP approach, you can divide complex problems
    into smaller problems by creating objects. There are a few differences in Kotlin''s
    style of OOP as compared to Java—for example, in Kotlin, all the classes are closed
    (final) by default, and if you want them to be extensible, you need to make them
    open by using an `open` keyword. Not only for classes—even the methods are final
    by default, and you need an `open` keyword for them as well. With Kotlin much
    less code is needed to work with classes and objects. Oh! By the way, did I tell
    you that we don''t even need to use the new keyword while creating the object?
    So, creating a new object in Kotlin is as simple as this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解与 Kotlin 面向对象编程相关的食谱。使用面向对象的方法，你可以通过创建对象将复杂问题分解为更小的问题。与 Java 相比，Kotlin
    的 OOP 风格有一些不同——例如，在 Kotlin 中，所有类默认都是封闭的（final），如果你想使它们可扩展，你需要使用`open`关键字。不仅对于类——默认情况下，方法也是final的，你需要使用`open`关键字。使用
    Kotlin，处理类和对象所需的代码更少。哦！顺便说一句，我告诉你我们甚至不需要使用`new`关键字来创建对象了吗？所以，在 Kotlin 中创建新对象就像这样：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code will create a mutable object of type `Person`, because we
    have used `var` as a modifier. A mutable object means that it can change its value.
    If you want to create an immutable object, you do it using the `val` keyword.
    So the same example will look as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个可变类型的`Person`对象，因为我们使用了`var`作为修饰符。可变对象意味着它可以改变其值。如果你想创建一个不可变对象，你可以使用`val`关键字。所以同样的例子将如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, let's begin looking at some recipes that will help you with object-oriented
    programming in Kotlin.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始查看一些有助于你在 Kotlin 中进行面向对象编程的食谱。
- en: Initializing body of constructor
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化构造函数的主体
- en: 'In the Java world, we used to initialize fields of the class in the constructor,
    as shown in this code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 世界中，我们通常在构造函数中初始化类的字段，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, if the argument's name was similar to that of the property (which was usually
    the case for making the code more readable), we needed to use this keyword. In
    this recipe, we will see how to implement the same thing in Kotlin (obviously
    with much less code).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果参数的名称与属性的名称相似（通常为了使代码更易读），我们需要使用`this`关键字。在这个食谱中，我们将看到如何在 Kotlin 中实现相同的功能（显然代码更少）。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need an IDE to write and execute your code. I'll be using IntelliJ IDEA.
    We will create a `Student` class with `name` and `roll_number` as properties.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个 IDE 来编写和执行你的代码。我将使用 IntelliJ IDEA。我们将创建一个具有`name`和`roll_number`属性的`Student`类。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s look at the mentioned steps to initialize a constructor:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看初始化构造函数的步骤：
- en: 'Kotlin provides a syntax that can initialize the properties with much less
    code. Here''s what class initialization looks like in Kotlin:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 提供了一种语法，可以用更少的代码初始化属性。以下是 Kotlin 中类初始化的示例：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You don''t even need to define the body of the class, and the initialization
    of properties takes place in the primary constructor only (the primary constructor
    is part of the class header). Obviously, you can either choose `var` or `val`,
    based on whether you need to keep your properties mutable or not. Now, if you
    try to create an object, you can do so with this:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你甚至不需要定义类的主体，属性的初始化仅在主构造函数中发生（主构造函数是类头的一部分）。显然，你可以根据是否需要保持属性可变来选择`var`或`val`。现在，如果你尝试创建一个对象，你可以用以下方式做到：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Just to confirm, let''s try to print its properties to see whether we were
    able to initialize it or not:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认，让我们尝试打印其属性以查看我们是否能够初始化它：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, if you want, you can also put default values in the constructor:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果你想的话，你还可以在构造函数中放置默认值：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, you can create objects such as this:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以创建如下对象：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the class has a primary constructor, each secondary constructor needs to
    be delegated to the primary constructor, either directly or indirectly through
    another secondary constructor(s).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有一个主构造函数，每个次级构造函数都需要委托给主构造函数，无论是直接还是通过另一个次级构造函数（s）间接地。
- en: 'We use this keyword to delegate to another constructor of the same class:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用此关键字来委托给同一类的另一个构造函数：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also have a situation where we have to initialize other things in the
    class, not necessarily just the class''s properties. That situation could be opening
    database connections, for example. In Java, that was done in the constructor itself,
    but in Kotlin, we have an `init` block. The initialization code can be put into
    an `init` block:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可能遇到需要在类中初始化其他事情的情况，而不仅仅是类的属性。这种情况可能是打开数据库连接，例如。在Java中，这是在构造函数中完成的，但在Kotlin中，我们有`init`块。初始化代码可以放入`init`块中：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Sometimes, we also initialize properties of a class by dependency injection.
    If you''ve worked with Dagger2, you must be familiar with objects being directly
    injected into the constructors of a class. To do so, we append the `@Inject` annotation
    before the constructor keyword. Whenever a constructor has an annotation or visibility
    modifier, we need to have the `constructor` keyword. An example of the constructor
    keyword is given below:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，我们也会通过依赖注入来初始化类的属性。如果你使用过Dagger2，你一定熟悉对象被直接注入到类的构造函数中。为此，我们在构造函数关键字之前添加`@Inject`注解。每当构造函数有一个注解或可见性修饰符时，我们都需要有`constructor`关键字。下面是一个`constructor`关键字的示例：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are injecting an object of the `CompositeDisposable` type into the
    constructor and, since we are using an annotation (`@Inject`) to do so, we need
    to apply the constructor keyword.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们正在将`CompositeDisposable`类型的对象注入到构造函数中，由于我们使用注解（`@Inject`）来这样做，我们需要应用构造函数关键字。
- en: 'When you extend a class, you need to initialize the superclass. This is also
    very simple in Kotlin. If your class has a primary constructor, the base type
    must be initialized there, using the parameters of the primary constructor. Here''s
    an example of the same:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你扩展一个类时，你需要初始化超类。在Kotlin中，这也非常简单。如果你的类有一个主构造函数，基类型必须在那里使用主构造函数的参数进行初始化。以下是一个相同的示例：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, sometimes a class may not have the primary constructor. In that case,
    each secondary constructor has to initialize the base type using the `super` keyword
    or can delegate to another constructor that does that. Also, different secondary
    constructors can call different constructors of the base type:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，有时一个类可能没有主构造函数。在这种情况下，每个次级构造函数必须使用`super`关键字初始化基类型，或者可以委托给另一个执行此操作的构造函数。此外，不同的次级构造函数可以调用基类型的不同构造函数：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Converting one data type into another
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一种数据类型转换为另一种类型
- en: 'In Java, we used to typecast by appending the desired type in front of variables
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们通常通过在变量前添加所需类型来进行类型转换，如下所示：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Also, in Java, numeric is directly converted to larger numeric types, but in
    Kotlin, this feature is not there for type safety—so how can we change one type
    of object to another in Kotlin? We will see it in this recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Java中，数值可以直接转换为更大的数值类型，但在Kotlin中，这个特性因为类型安全而不存在——那么在Kotlin中如何将一个类型的对象转换为另一个类型的对象呢？我们将在本食谱中看到。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using the online IDE available
    at [https://try.kotlinlang.org/](https://try.kotlinlang.org/) to compile and run
    my Kotlin code for this recipe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装一个首选的开发环境，该环境可以编译和运行Kotlin。你也可以使用命令行来完成这个任务，这需要安装Kotlin编译器和JDK。我正在使用[https://try.kotlinlang.org/](https://try.kotlinlang.org/)上的在线IDE来编译和运行我的Kotlin代码，用于本食谱。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s understand how to convert one data type into another by following the
    steps below:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤了解如何将一种数据类型转换为另一种类型：
- en: 'Let''s try a very basic example—trying to convert an `Int` to `Long` and `Float`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个非常基础的例子——尝试将`Int`转换为`Long`和`Float`：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, `Long` can be converted to `Float` and `Int`, like this:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，`Long`可以转换为`Float`和`Int`，如下所示：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of this code is as shown:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s try a more interesting conversion with `Byte`, `Int`, and `Strings`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个更有趣的转换，使用`Byte`、`Int`和`Strings`：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s a list of methods that can be used for type conversion in Kotlin:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可以使用于Kotlin中类型转换的方法列表：
- en: '`toByte()`: Byte'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toByte()`: Byte'
- en: '`toShort()`: Short'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toShort()`: Short'
- en: '`toInt()`: Int'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toInt()`: 整数'
- en: '`toLong()`: Long'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLong()`: 长整数'
- en: '`toFloat()`: Float'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toFloat()`: 浮点数'
- en: '`toDouble()`: Double'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toDouble()`: 双精度浮点数'
- en: '`toChar()`: Char'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toChar()`: 字符'
- en: '`toString()`: String'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`: 字符串'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Basically, Kotlin is a type-safe language and ensures that types cannot be directly
    converted in the language. Also, `String` is not the same as `String`? As expected,
    there is no method to convert a variable to a Boolean type. Conversion from a
    larger type to a smaller type is possible, but it might truncate the resulting
    values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Kotlin 是一种类型安全的语言，并确保类型不能在语言中直接转换。此外，`String` 和 `String` 不一样？正如预期的那样，没有方法可以将变量转换为布尔类型。从较大的类型转换为较小的类型是可能的，但可能会截断结果值。
- en: How to type check an object
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何检查对象的类型
- en: One often needs to check if an object is of a particular type at runtime. With
    Java, we used an instance of a keyword; with Kotlin, it is the `is` keyword.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要检查对象在运行时是否为特定类型。在 Java 中，我们使用 `instanceof` 关键字；在 Kotlin 中，它是 `is` 关键字。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    Kotlin compiler installed along with JDK. I am using online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，用于编译和运行 Kotlin。您也可以使用命令行，为此您需要安装 Kotlin 编译器和 JDK。我正在使用 [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    上的在线 IDE 来编译和运行我的 Kotlin 代码，以完成这个菜谱。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to type check an object in these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何按以下步骤检查对象的类型：
- en: 'Let''s try a very basic example, trying `is` with string and integer. In this
    example, we will type check a string and an integer:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个非常基础的例子，尝试使用 `is` 与字符串和整数。在这个例子中，我们将检查一个字符串和一个整数的类型：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, we can use `!is` to check whether the object is not of type `String`,
    like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `!is` 来检查对象是否不是 `String` 类型，如下所示：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you remember how `when` works in Kotlin, we do not need to put in the `is`
    keyword, because Kotlin has a feature of smart cast and throws an error if the
    compared objects are not of the same type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得 Kotlin 中 `when` 的用法，我们就不需要使用 `is` 关键字，因为 Kotlin 有智能转换的功能，如果比较的对象不是同一类型，则会抛出错误。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Basically, the `is` operator is used to check the type of the object in Kotlin
    and `!is` is the negation of the `is` operator.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`is` 操作符用于在 Kotlin 中检查对象的类型，而 `!is` 是 `is` 操作符的否定。
- en: Kotlin compiler tracks immutable values and safe casts them wherever needed.
    This is how smart casts work; `is` is a safe cast operator, whereas an unsafe
    cast operator is the `as` operator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 编译器跟踪不可变值，并在需要时安全地进行转换。这就是智能转换的工作原理；`is` 是一个安全转换操作符，而不安全的转换操作符是 `as`
    操作符。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s try an example with the `as` operator, which is used for casting in
    Kotlin. It is an unsafe cast operator. The following code example throws `ClassCastException`,
    because we cannot convert an integer to string:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个使用 `as` 操作符的例子，它是 Kotlin 中的类型转换操作符。这是一个不安全的转换操作符。以下代码示例会抛出 `ClassCastException`，因为我们不能将整数转换为字符串：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the other hand, the following code runs successfully because of variable
    `a`, which, being of `Any` type, can be cast to `String`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下代码由于变量 `a` 是 `Any` 类型，可以成功运行，因此可以被转换为 `String`：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to work with an abstract class in Kotlin
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中使用抽象类
- en: Abstract classes are classes that cannot be instantiated, which means that we cannot create
    objects of an abstract class. The main inspiration behind using abstract classes
    is that we can inherit from them. When a class inherits from an abstract class,
    it implements all abstract methods of the parent class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是不能实例化的类，这意味着我们不能创建抽象类的对象。使用抽象类的主要灵感是我们可以从它们继承。当一个类从抽象类继承时，它实现了父类的所有抽象方法。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    Kotlin compiler installed along with JDK. I am using online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，用于编译和运行 Kotlin。您也可以使用命令行，为此您需要安装 Kotlin 编译器和 JDK。我正在使用 [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    上的在线 IDE 来编译和运行我的 Kotlin 代码，以完成这个菜谱。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s now see how to work with an `abstract` class in these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何按以下步骤使用 `abstract` 类：
- en: 'The `abstract` keyword is used to declare an `abstract` class. Let''s create
    an abstract class and try to inherit from it:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`abstract` 关键字用于声明一个 `abstract` 类。让我们创建一个抽象类并尝试从它继承：'
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For a class to be a subclass of the `Mammal` class, we use the `:` operator,
    as in the following example. Pay attention to the `override` keyword used before
    the method implementation of the superclass:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使一个类成为 `Mammal` 类的子类，我们使用 `:` 操作符，如下例所示。请注意在超类方法实现之前使用的 `override` 关键字：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we do not want a method to be implemented by the subclass, we do not declare
    it as `abstract` or `open`, as demonstrated in this example:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不希望子类实现某个方法，我们不应将其声明为 `abstract` 或 `open`，如下例所示：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we declare `init` blocks in each class, as follows, we get an output where
    superclass’s `init` block is called first:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在每个类中声明 `init` 块，如下所示，我们将得到一个输出，其中超类的 `init` 块首先被调用：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the final program is this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最终程序的输出如下：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Dog` class is a subclass of `Mammal` and inherits all its methods. The
    methods declared `abstract` are supposed to be implemented by the `Dog` class.
    The `show()` method is in `Mammal` but can be called by the `Dog` object, because
    the object created is of the `Mammal` type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog` 类是 `Mammal` 类的子类，并继承其所有方法。声明为 `abstract` 的方法应由 `Dog` 类实现。`show()` 方法在
    `Mammal` 类中，但可以通过 `Dog` 对象调用，因为创建的对象是 `Mammal` 类型。'
- en: The `init` block of superclass is called before subclass.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 超类的 `init` 块在子类之前被调用。
- en: How to iterate over a class's properties in Kotlin
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中遍历类的属性
- en: Reflections in Kotlin allows us introspection of the structure of our program
    at runtime. This also enables us to introspect the class modifiers, methods, and
    properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的反射允许我们在运行时对程序的结构进行自省。这也使我们能够自省类修饰符、方法和属性。
- en: In this recipe, we will see how we can iterate over the properties of a Kotlin
    class. So let’s get started!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何遍历 Kotlin 类的属性。那么，让我们开始吧！
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We’ll be using IntelliJ IDEA IDE for coding purposes. We will create a `Student`
    class, which will have the `roll_number` and `name` properties. We will then see
    how we can iterate over its properties.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA IDE 进行编码。我们将创建一个 `Student` 类，它将具有 `roll_number` 和 `name`
    属性。然后我们将看到如何遍历其属性。
- en: If you are not using IntelliJ IDE or Android Studio, you might need to include
    reflection library in your classpath. Head on over to [https://kotlinlang.org/docs/reference/reflection.html](https://kotlinlang.org/docs/reference/reflection.html) to
    learn more about this.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用 IntelliJ IDE 或 Android Studio，您可能需要在类路径中包含反射库。前往 [https://kotlinlang.org/docs/reference/reflection.html](https://kotlinlang.org/docs/reference/reflection.html)
    了解更多关于反射的信息。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following steps, we will see how to iterate over a class''s properties:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将看到如何遍历一个类的属性：
- en: 'Here''s our `Student` class with the `roll_number` and `full_name` attributes:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们的 `Student` 类，具有 `roll_number` 和 `full_name` 属性：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we will be using a `for` statement, because we want to iterate over multiple
    properties that a class can have:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `for` 语句，因为我们想遍历一个类可以拥有的多个属性：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is the output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The implementation is quite straightforward. We are able to achieve the introspection
    into the class’s properties because we are using reflections and `memberProperties`
    is just one of the many functions of `KClass`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当简单。我们能够实现对类属性的检查，因为我们使用了反射，而 `memberProperties` 只是 `KClass` 的许多函数之一。
- en: 'One thing to note is that `memberProperties` returns all the non-extension
    properties declared in this class and all of its superclasses. Consider that we
    have a `Person` class, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，`memberProperties` 返回此类及其所有超类中声明的所有非扩展属性。假设我们有一个 `Person` 类，如下所示：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, we extend our `Student` class with the `Person` class, and then the same
    code used earlier with the `memberProperties` method will result in an output
    as shown:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过 `Person` 类扩展我们的 `Student` 类，然后使用 `memberProperties` 方法之前相同的代码将产生如下输出：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So, if you want to just iterate over the declared fields in the `Student` class,
    you will need the `declaredMemberProperties` method. Here''s an example with `declaredMemberProperties`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您只想遍历 `Student` 类中声明的字段，您将需要使用 `declaredMemberProperties` 方法。以下是一个使用 `declaredMemberProperties`
    的示例：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding examples were for Kotlin `KClass`. Suppose you want to iterate
    over properties for a `Java Class<T>`—you can use a Kotlin extension property
    to get the Kotlin `KClass<T>`, from which you can proceed, for example, `something.javaClass.kotlin.memberProperties`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是关于Kotlin的`KClass`。假设你想遍历`Java Class<T>`的属性——你可以使用Kotlin扩展属性来获取Kotlin的`KClass<T>`，然后你可以继续操作，例如`something.javaClass.kotlin.memberProperties`。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Check out the list ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html))
    of methods provided by Kotlin’s Reflection library, with the help of which you
    can perform a lot of introspection at runtime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Kotlin反射库提供的方法列表（[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)），借助它你可以在运行时执行许多内省操作。
- en: How to work with inline properties
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何处理内联属性
- en: A great thing about Kotlin is high-order functions that let us use functions
    as parameters to other functions. However, they are objects, so they present memory
    overhead (because every instance is allocated space in heap, and we need methods
    for calling the functions too). We can improve the situation using inline functions.
    Inline annotation means that the specific function, along with the function parameters,
    will be expanded at the call site; this helps reduce call overhead.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的一个优点是高阶函数，它允许我们将函数作为其他函数的参数使用。然而，它们是对象，因此它们会带来内存开销（因为每个实例都会在堆中分配空间，我们还需要方法来调用函数）。我们可以通过使用内联函数来改善这种情况。内联注解意味着特定的函数以及函数参数将在调用位置展开；这有助于减少调用开销。
- en: Similarly, the inline keyword can be used with properties and property accessors
    that do not have the backing field. Let's see how in this recipe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，内联关键字可以与没有后置字段的属性和属性访问器一起使用。让我们看看在这个菜谱中是如何做到这一点的。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    Kotlin compiler installed along with JDK. I am using online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    as the development environment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装一个首选的开发环境，用于编译和运行Kotlin。你也可以使用命令行，这需要安装Kotlin编译器和JDK。我正在使用[https://try.kotlinlang.org/](https://try.kotlinlang.org/)在线IDE来编译和运行我的Kotlin代码，以完成这个菜谱。你也可以使用IntelliJ
    IDEA作为开发环境。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how to work with inline properties in these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在这些步骤中处理内联属性：
- en: 'Let''s try an example where we `inline` an accessor of a property in Kotlin:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个例子，在Kotlin中内联一个属性的访问器：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, we just used the `inline` keyword with the `get` accessor.
    We can also declare both the `get` and `set` accessors as inline by making the
    whole property inline, as shown in this code snippet:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是使用了`inline`关键字与`get`访问器。我们也可以通过使整个属性内联来声明`get`和`set`访问器为内联，如这个代码片段所示：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding snippet, both accessors are inlined.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，两个访问器都被内联了。
- en: 'One thing to keep in mind, though, is that inline does not work with property
    or accessor if the property has a backing field or the assessor does not reference
    the backing field. The code here is an example of a scenario where we cannot use
    `inline`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，如果属性有一个后置字段或访问器不引用后置字段，内联就不会与属性或访问器一起工作。这里的代码是一个我们无法使用`inline`的场景的例子：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Another thing to keep in mind is that, although inline properties reduce call
    overhead by getting expanded only at the call site, they also increase the overall
    bytecode, so inline should not be used with large functions or accessors.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要记住的是，尽管内联属性通过仅在调用位置展开来减少调用开销，但它们也会增加整体字节码，因此内联不应与大型函数或访问器一起使用。
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: So, basically, we use inline when we wish to reduce memory overhead. Like the
    inline function, we can also declare properties as inline or the accessors of
    properties as inline. However, one thing to keep in mind is that inlining increases
    bytecode considerably, so it is suggested to not inline functions or accessors
    that have a large code logic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，当我们希望减少内存开销时，我们会使用内联。就像内联函数一样，我们也可以将属性声明为内联或属性的访问器作为内联。然而，需要注意的是，内联会增加字节码的量，因此建议不要内联具有大量代码逻辑的函数或访问器。
- en: How to work with nested class
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何处理嵌套类
- en: In this recipe, we will see how to use nested classes in Kotlin. A nested class
    is a member of its enclosing class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示如何在 Kotlin 中使用嵌套类。嵌套类是其封装类的成员。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    Kotlin compiler installed along with JDK. I am using online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行，为此您需要安装 Kotlin 编译器和 JDK。我正在使用在线 IDE
    [https://try.kotlinlang.org/](https://try.kotlinlang.org/) 来编译和运行我的 Kotlin 代码，以完成这个菜谱。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now we will see how to work with a nested class in the following steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将分步骤展示如何使用嵌套类：
- en: 'Let''s try an example of a nested class in Kotlin:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个 Kotlin 嵌套类的例子：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here''s the output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s try an example of the `inner` class. To declare a nested class
    as `inner`, we use the `inner` keyword. An `inner` class can access members of
    the outer class, as they carry a reference to the outer class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个 `inner` 类的例子。要将嵌套类声明为 `inner`，我们使用 `inner` 关键字。`inner` 类可以访问外部类的成员，因为它们携带指向外部类的引用：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of the preceding code is this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A nested class can be created by just declaring the nested class inside another
    class. In this case, to access the nested class, you make a static reference that
    is like `outerClass.innerClass()`, and you can also make an object of inner class
    using this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类可以通过在另一个类内部声明嵌套类来创建。在这种情况下，要访问嵌套类，您创建一个静态引用，类似于 `outerClass.innerClass()`，您还可以使用此方法创建内部类的对象。
- en: 'An `inner` class, on the other hand, is created by adding the `inner` keyword
    to a nested class. In that case, we access the inner class as though it was a
    member or the outer class, that is, using an object of the outer class like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`inner` 类是通过在嵌套类中添加 `inner` 关键字创建的。在这种情况下，我们像访问外部类的成员一样访问内部类，即使用外部类的对象，如下所示：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A nested class does not have access to members of the outer class, as it does
    not have any reference to an object of the outer class. On the other hand, the
    inner class can access all of the outer class’s members, as it has a reference
    to an object of outer class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类无法访问外部类的成员，因为它没有外部类对象的任何引用。另一方面，内部类可以访问外部类的所有成员，因为它有一个指向外部类对象的引用。
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can also create anonymous inner classes in Kotlin using the `object` keyword,
    like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 Kotlin 中使用 `object` 关键字创建匿名内部类，如下所示：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Getting class in Kotlin
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中获取类
- en: In this recipe, we will look into the ways by which we can get the class reference
    in Kotlin. Primarily, we will be working with reflection. Reflection is a library
    that provides the ability to inspect code at runtime instead of compile time.
    In Java, we can get a variable's class through `getClass()`, like `something.getClass()`.
    Let’s see how to resolve a variable’s class in Kotlin.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨在 Kotlin 中获取类引用的方法。主要，我们将使用反射。反射是一个库，它提供了在运行时而不是编译时检查代码的能力。在 Java
    中，我们可以通过 `getClass()` 获取变量的类，例如 `something.getClass()`。让我们看看如何在 Kotlin 中解析变量的类。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Java’s equivalent of resolving a variable's name is with the `.getClass()` method,
    for example, `something.getClass()`. In Kotlin, we can achieve the same thing
    with `something.javaClass`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 中解析变量名称的等效方法是使用 `.getClass()` 方法，例如，`something.getClass()`。在 Kotlin 中，我们可以通过
    `something.javaClass` 实现相同的功能。
- en: To get a reference to the reflection class, we used to do `something.class`
    in Java, whose Kotlin equivalent is `something::class`. This returns a `KClass`.
    The special features of this `KClass` is that it provides introspection capabilities
    quite similar to the abilities provided to Java’s reflection class.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取反射类的引用，我们以前在 Java 中使用 `something.class`，其 Kotlin 等价物是 `something::class`。这返回一个
    `KClass`。这个 `KClass` 的特殊之处在于它提供了与 Java 反射类提供的功能相当的自省能力。
- en: 'Note that the KClass is different from Java’s `Class` object. If you want to
    obtain a Java `Class` object from Kotlin''s `KClass`, use the `.java` extension
    property:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，KClass 与 Java 的 `Class` 对象不同。如果您想从 Kotlin 的 `KClass` 获取 Java 的 `Class` 对象，请使用
    `.java` 扩展属性：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The latter example will be optimized by the compiler to not allocate an intermediate
    KClass instance.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后者示例将被编译器优化，以避免分配中间的 KClass 实例。
- en: If you use Kotlin 1.0, you can convert the obtained Java class to a KClass instance
    by calling the `.kotlin` extension property, for example, `something.javaClass.kotlin`.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用 Kotlin 1.0，你可以通过调用 `.kotlin` 扩展属性将获得的 Java 类转换为 KClass 实例，例如，`something.javaClass.kotlin`。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As was just described, `KClass` provides you with introspection capabilities.
    Here are a few methods of `KClass`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚才所描述的，`KClass` 为你提供了反射能力。以下是一些 `KClass` 的方法：
- en: '`isAbstract`: True if this class is abstract'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAbstract`：如果此类是抽象的则为真'
- en: '`isCompanion`: True if this class is a companion object'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCompanion`：如果此类是伴随对象则为真'
- en: '`isData`: True if this class is a data class'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isData`：如果此类是数据类则为真'
- en: '`isFinal`: True if this class is final'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFinal`：如果此类是最终类则为真'
- en: '`isInner`: True if this class is an inner class'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isInner`：如果此类是内部类则为真'
- en: '`isOpen`: True if this class is open'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isOpen`：如果此类是公开的则为真'
- en: Follow this link ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/))
    for the complete list of functions provided by KClass.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅此链接以获取 KClass 提供的完整函数列表（[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/))。
- en: Working with delegated properties
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理属性进行操作
- en: 'Kotlin 1.1 brought many updates; one of the important ones was delegated properties.
    There are three types of delegated properties:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 1.1 带来了许多更新；其中之一是代理属性。有三种类型的代理属性：
- en: '`lazy`: Lazy properties are the ones evaluated first and the same instance
    is returned after them, much like a cache'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lazy`：懒加载属性是首先评估的，并在之后返回相同的实例，就像缓存一样'
- en: '`observable`: The listener is notified whenever a change is made'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observable`：每当发生更改时都会通知监听器'
- en: '`map`: Properties are stored in the map instead of in every field'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`：属性存储在映射中，而不是每个字段中'
- en: In this recipe, we will see how to work with these delegates. So let's get started.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用这些代理。那么，让我们开始吧。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: We will be working on Android code, so we will require Android Studio 3.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理 Android 代码，因此我们需要 Android Studio 3。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see a simple example of a delegated property:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代理属性的一个简单例子：
- en: 'First, we will work with the lazy delegate property. Simply put, this delegate
    can suspend the object creation until we first access it. This is really important
    when you are working with heavy objects; they take a long time to be created—for
    example, when creating a database instance or maybe dagger components. Not only
    this, the result is remembered and the same value is returned for subsequent calls
    for `getValue()` on this kind of delegated property. Let''s take a look at an
    example:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将处理懒加载代理属性。简单来说，这个代理可以延迟对象的创建，直到我们第一次访问它。当你处理重量级对象时，这非常重要；它们需要很长时间才能创建——例如，创建数据库实例或可能是
    dagger 组件。不仅如此，结果会被记住，并且对于此类代理属性的后续 `getValue()` 调用，将返回相同的值。让我们看一个例子：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding is a standard `onCreate` method of an activity. If you look carefully,
    we have set the `button` variable before the `setContentView(..)` method. When
    you run it, it runs perfectly. If you hadn''t used lazy, it would have given a
    `NullPointerException`, something like this:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述是活动的标准 `onCreate` 方法。如果你仔细观察，我们在 `setContentView(..)` 方法之前设置了 `button` 变量。当你运行它时，它运行得很好。如果你没有使用懒加载，它将给出一个
    `NullPointerException`，类似于这样：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The button variable was null, as we called it before the `setContentView`. However,
    this wasn't a problem with lazily created `button` object, because although we
    had declared it before `setContentView`, the `button` object wasn't created. It
    was created after its first access, that is, when we tried to set a property on
    it.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮变量为空，因为我们是在 `setContentView` 之前调用它的。然而，这对于懒创建的 `button` 对象来说并不是问题，因为尽管我们在
    `setContentView` 之前声明了它，但 `button` 对象是在第一次访问后创建的，即当我们尝试在它上设置属性时。
- en: So, with a lazy construct, you don't need to think about where to place your
    code for initialization, and initialization of an object is deferred till its
    first use.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，使用懒加载构造，你不需要考虑初始化代码放置的位置，对象的初始化将延迟到第一次使用时。
- en: 'Another key thing to note is that, by default, the evaluation of lazy properties
    will be synchronized, which means the value is computed in one thread, and the
    rest of the threads will see the same value. There are three types of initialization:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的关键点是，默认情况下，懒加载属性的评估将是同步的，这意味着值在一个线程中计算，其余的线程将看到相同的值。有三种初始化类型：
- en: '`LazyThreadSafetyMode.SYNCHRONIZED`: This is the default mode and ensures that
    only a single thread can initialize the instance.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyThreadSafetyMode.SYNCHRONIZED`：这是默认模式，确保只有一个线程可以初始化实例。'
- en: '`LazyThreadSafetyMode.PUBLICATION`: In this mode, multiple threads can execute
    the initialization.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyThreadSafetyMode.PUBLICATION`：在此模式下，多个线程可以执行初始化。'
- en: '`LazyThreadSafetyMode.NONE`: This mode is used when we are sure that initialization
    will happen only on one thread. For example, in the case of Android, we can be
    sure that views will be initialized by the UI thread only. Since this doesn''t
    guarantee thread-safety, it has much less overhead.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyThreadSafetyMode.NONE`：当我们确定初始化只会在一个线程上发生时，使用此模式。例如，在 Android 的案例中，我们可以确定视图将由
    UI 线程初始化。由于这并不保证线程安全，它具有更少的开销。'
- en: 'Another useful delegate is the observable delegate. This delegate helps us
    observe any changes to the property. For example, let''s take a look at a very
    basic implementation of the `observable` delegate:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的委托是可观察的委托。这个委托帮助我们观察属性的任何更改。例如，让我们看看 `observable` 委托的一个非常基本的实现：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is the output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we can see, the `observable` delegate takes in two things: a default value
    (which we specified as `<>`) and a handler, which gets called whenever that property
    is modified.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`observable` 委托接受两件事：一个默认值（我们指定为 `<>`）和一个处理程序，该处理程序在属性修改时被调用。
- en: 'Let''s now work with the `vetoable` delegate. It''s a lot like the `observable`
    delegate, but with it, we can "veto" the modification. Let''s look at an example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在处理 `vetoable` 委托。它与 `observable` 委托非常相似，但使用它可以“否决”修改。让我们看看一个例子：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is the output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see in the preceding example, if `newValue` isn't equal to `"Paris"`,
    we will return `false`, and the modification will be aborted. If you want the
    modification to take place, you need to return `true` from the construct.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，如果 `newValue` 不等于 `"Paris"`，我们将返回 `false`，并且修改将被中止。如果您想进行修改，您需要从构造函数中返回
    `true`。
- en: 'Sometimes, you create an object based on values dynamically, for example, in
    the case of parsing JSON. For those applications, we can use the `map` instance
    itself as the delegate for a delegated property. Let''s see an example here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会根据动态值创建一个对象，例如，在解析 JSON 的情况下。对于这些应用程序，我们可以使用 `map` 实例本身作为委托属性的委托。让我们在这里看看一个例子：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here''s the output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To make it work for `var` properties, you need to use a `MutableMap`, so the
    preceding example might look something like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其适用于 `var` 属性，您需要使用 `MutableMap`，因此前面的示例可能看起来像这样：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Of course, the output will be the same.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，输出将是相同的。
- en: There's more...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: The observable delegated property can be used extensively in adapters. Adapters
    are used to populate data in some sort of list. Usually, when data is updated,
    we just update the member variable list in the adapter and then call `notifyDatasetChanged()`.
    With the help of observable and `DiffUtils`, we can just update the things that
    are actually changed, rather than changing everything. This results in much more
    efficient performance.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察的委托属性在适配器中可以广泛使用。适配器用于在某种列表中填充数据。通常，当数据更新时，我们只需更新适配器中的成员变量列表，然后调用 `notifyDatasetChanged()`。借助可观察的和
    `DiffUtils`，我们只需更新实际更改的内容，而不是更改一切。这导致性能更加高效。
- en: Working with enums
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与枚举一起工作
- en: 'Enums are used when a variable can only take one of a small set of possible
    values. An example would be the case of type constants (direction: "North", "South",
    "East", and “West”). With the help of enums, you can avoid errors from passing
    in invalid constants, and you also document which values are acceptable for use.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举用于变量只能取一小组可能值的情况。一个例子是类型常量（方向："North"、"South"、"East" 和 "West"）。借助枚举，您可以避免传递无效常量的错误，并且还可以记录哪些值是可接受的。
- en: In this recipe, we will see how to use enums in Kotlin.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何在 Kotlin 中使用枚举。
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We’ll be using an IntelliJ IDEA for writing and running the code. First, we
    will be creating a simple type-safe enum, `Direction`, with the members NORTH,
    SOUTH, EAST, and WEST (representing four directions).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 来编写和运行代码。首先，我们将创建一个简单的类型安全的枚举 `Direction`，其成员包括 NORTH、SOUTH、EAST
    和 WEST（代表四个方向）。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see an example of the `enum` class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `enum` 类的一个例子：
- en: 'In this example, we will create an enum of directions. We will assume that
    there are only four of them:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个方向枚举。我们将假设只有四个方向：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, the variable (`north_direction`) can just take values among
    the predefined constants in the `enum` class.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所见，变量（`north_direction`）只需在`enum`类中预定义的常量中取值。
- en: 'We can also initialize enums with default values:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用默认值来初始化枚举：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There's more...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is strongly recommended that you don’t use enums in your Android projects.
    According to Google engineers, adding a single enum will increase the size to
    approximately 13 times that of the final DEX file. It also generates the problem
    of runtime overhead and your app will require more space.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你不在你的Android项目中使用枚举。根据谷歌工程师的说法，添加一个枚举将使最终DEX文件的大小增加大约13倍。它还会产生运行时开销的问题，你的应用将需要更多的空间。
- en: 'The Android documentation says this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Android文档中是这样说的：
- en: '"Enums often require more than twice as much memory as static constants. You
    should strictly avoid using enums on Android."'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '"枚举通常需要的内存是静态常量的两倍以上。你应该严格避免在Android中使用枚举。"'
- en: However, if you want the comfort of enums, you can use Android’s annotation
    library, which has `TypeDef` annotations—but sadly, this isn’t supported by Kotlin
    at the time of this book being written, so we hope it gets added in future versions
    of Kotlin.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想享受枚举的便利性，你可以使用Android的注解库，它有`TypeDef`注解——但是遗憾的是，在本书编写时，Kotlin不支持这一点，所以我们希望它能在Kotlin的未来版本中得到添加。
