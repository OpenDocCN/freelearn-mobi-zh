- en: Classes and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing body of constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting one data type into another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to type check an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with an abstract class in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to iterate over a class's properties in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with inline properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with nested class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting class in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with delegated properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will be introduced to recipes related to object-oriented
    programming in Kotlin. Using an OOP approach, you can divide complex problems
    into smaller problems by creating objects. There are a few differences in Kotlin''s
    style of OOP as compared to Java—for example, in Kotlin, all the classes are closed
    (final) by default, and if you want them to be extensible, you need to make them
    open by using an `open` keyword. Not only for classes—even the methods are final
    by default, and you need an `open` keyword for them as well. With Kotlin much
    less code is needed to work with classes and objects. Oh! By the way, did I tell
    you that we don''t even need to use the new keyword while creating the object?
    So, creating a new object in Kotlin is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create a mutable object of type `Person`, because we
    have used `var` as a modifier. A mutable object means that it can change its value.
    If you want to create an immutable object, you do it using the `val` keyword.
    So the same example will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, let's begin looking at some recipes that will help you with object-oriented
    programming in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing body of constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Java world, we used to initialize fields of the class in the constructor,
    as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, if the argument's name was similar to that of the property (which was usually
    the case for making the code more readable), we needed to use this keyword. In
    this recipe, we will see how to implement the same thing in Kotlin (obviously
    with much less code).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need an IDE to write and execute your code. I'll be using IntelliJ IDEA.
    We will create a `Student` class with `name` and `roll_number` as properties.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the mentioned steps to initialize a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin provides a syntax that can initialize the properties with much less
    code. Here''s what class initialization looks like in Kotlin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t even need to define the body of the class, and the initialization
    of properties takes place in the primary constructor only (the primary constructor
    is part of the class header). Obviously, you can either choose `var` or `val`,
    based on whether you need to keep your properties mutable or not. Now, if you
    try to create an object, you can do so with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to confirm, let''s try to print its properties to see whether we were
    able to initialize it or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want, you can also put default values in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can create objects such as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the class has a primary constructor, each secondary constructor needs to
    be delegated to the primary constructor, either directly or indirectly through
    another secondary constructor(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use this keyword to delegate to another constructor of the same class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also have a situation where we have to initialize other things in the
    class, not necessarily just the class''s properties. That situation could be opening
    database connections, for example. In Java, that was done in the constructor itself,
    but in Kotlin, we have an `init` block. The initialization code can be put into
    an `init` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we also initialize properties of a class by dependency injection.
    If you''ve worked with Dagger2, you must be familiar with objects being directly
    injected into the constructors of a class. To do so, we append the `@Inject` annotation
    before the constructor keyword. Whenever a constructor has an annotation or visibility
    modifier, we need to have the `constructor` keyword. An example of the constructor
    keyword is given below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are injecting an object of the `CompositeDisposable` type into the
    constructor and, since we are using an annotation (`@Inject`) to do so, we need
    to apply the constructor keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you extend a class, you need to initialize the superclass. This is also
    very simple in Kotlin. If your class has a primary constructor, the base type
    must be initialized there, using the parameters of the primary constructor. Here''s
    an example of the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, sometimes a class may not have the primary constructor. In that case,
    each secondary constructor has to initialize the base type using the `super` keyword
    or can delegate to another constructor that does that. Also, different secondary
    constructors can call different constructors of the base type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Converting one data type into another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, we used to typecast by appending the desired type in front of variables
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Also, in Java, numeric is directly converted to larger numeric types, but in
    Kotlin, this feature is not there for type safety—so how can we change one type
    of object to another in Kotlin? We will see it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using the online IDE available
    at [https://try.kotlinlang.org/](https://try.kotlinlang.org/) to compile and run
    my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand how to convert one data type into another by following the
    steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a very basic example—trying to convert an `Int` to `Long` and `Float`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `Long` can be converted to `Float` and `Int`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try a more interesting conversion with `Byte`, `Int`, and `Strings`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a list of methods that can be used for type conversion in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toByte()`: Byte'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toShort()`: Short'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toInt()`: Int'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLong()`: Long'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toFloat()`: Float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toDouble()`: Double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toChar()`: Char'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`: String'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basically, Kotlin is a type-safe language and ensures that types cannot be directly
    converted in the language. Also, `String` is not the same as `String`? As expected,
    there is no method to convert a variable to a Boolean type. Conversion from a
    larger type to a smaller type is possible, but it might truncate the resulting
    values.
  prefs: []
  type: TYPE_NORMAL
- en: How to type check an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One often needs to check if an object is of a particular type at runtime. With
    Java, we used an instance of a keyword; with Kotlin, it is the `is` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    Kotlin compiler installed along with JDK. I am using online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to type check an object in these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a very basic example, trying `is` with string and integer. In this
    example, we will type check a string and an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can use `!is` to check whether the object is not of type `String`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you remember how `when` works in Kotlin, we do not need to put in the `is`
    keyword, because Kotlin has a feature of smart cast and throws an error if the
    compared objects are not of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basically, the `is` operator is used to check the type of the object in Kotlin
    and `!is` is the negation of the `is` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin compiler tracks immutable values and safe casts them wherever needed.
    This is how smart casts work; `is` is a safe cast operator, whereas an unsafe
    cast operator is the `as` operator.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try an example with the `as` operator, which is used for casting in
    Kotlin. It is an unsafe cast operator. The following code example throws `ClassCastException`,
    because we cannot convert an integer to string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following code runs successfully because of variable
    `a`, which, being of `Any` type, can be cast to `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to work with an abstract class in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract classes are classes that cannot be instantiated, which means that we cannot create
    objects of an abstract class. The main inspiration behind using abstract classes
    is that we can inherit from them. When a class inherits from an abstract class,
    it implements all abstract methods of the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    Kotlin compiler installed along with JDK. I am using online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now see how to work with an `abstract` class in these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `abstract` keyword is used to declare an `abstract` class. Let''s create
    an abstract class and try to inherit from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For a class to be a subclass of the `Mammal` class, we use the `:` operator,
    as in the following example. Pay attention to the `override` keyword used before
    the method implementation of the superclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not want a method to be implemented by the subclass, we do not declare
    it as `abstract` or `open`, as demonstrated in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we declare `init` blocks in each class, as follows, we get an output where
    superclass’s `init` block is called first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the final program is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Dog` class is a subclass of `Mammal` and inherits all its methods. The
    methods declared `abstract` are supposed to be implemented by the `Dog` class.
    The `show()` method is in `Mammal` but can be called by the `Dog` object, because
    the object created is of the `Mammal` type.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` block of superclass is called before subclass.
  prefs: []
  type: TYPE_NORMAL
- en: How to iterate over a class's properties in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflections in Kotlin allows us introspection of the structure of our program
    at runtime. This also enables us to introspect the class modifiers, methods, and
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can iterate over the properties of a Kotlin
    class. So let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll be using IntelliJ IDEA IDE for coding purposes. We will create a `Student`
    class, which will have the `roll_number` and `name` properties. We will then see
    how we can iterate over its properties.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not using IntelliJ IDE or Android Studio, you might need to include
    reflection library in your classpath. Head on over to [https://kotlinlang.org/docs/reference/reflection.html](https://kotlinlang.org/docs/reference/reflection.html) to
    learn more about this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will see how to iterate over a class''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `Student` class with the `roll_number` and `full_name` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will be using a `for` statement, because we want to iterate over multiple
    properties that a class can have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation is quite straightforward. We are able to achieve the introspection
    into the class’s properties because we are using reflections and `memberProperties`
    is just one of the many functions of `KClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note is that `memberProperties` returns all the non-extension
    properties declared in this class and all of its superclasses. Consider that we
    have a `Person` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we extend our `Student` class with the `Person` class, and then the same
    code used earlier with the `memberProperties` method will result in an output
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if you want to just iterate over the declared fields in the `Student` class,
    you will need the `declaredMemberProperties` method. Here''s an example with `declaredMemberProperties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples were for Kotlin `KClass`. Suppose you want to iterate
    over properties for a `Java Class<T>`—you can use a Kotlin extension property
    to get the Kotlin `KClass<T>`, from which you can proceed, for example, `something.javaClass.kotlin.memberProperties`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check out the list ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html))
    of methods provided by Kotlin’s Reflection library, with the help of which you
    can perform a lot of introspection at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to work with inline properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great thing about Kotlin is high-order functions that let us use functions
    as parameters to other functions. However, they are objects, so they present memory
    overhead (because every instance is allocated space in heap, and we need methods
    for calling the functions too). We can improve the situation using inline functions.
    Inline annotation means that the specific function, along with the function parameters,
    will be expanded at the call site; this helps reduce call overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the inline keyword can be used with properties and property accessors
    that do not have the backing field. Let's see how in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    Kotlin compiler installed along with JDK. I am using online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    as the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to work with inline properties in these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an example where we `inline` an accessor of a property in Kotlin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we just used the `inline` keyword with the `get` accessor.
    We can also declare both the `get` and `set` accessors as inline by making the
    whole property inline, as shown in this code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, both accessors are inlined.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to keep in mind, though, is that inline does not work with property
    or accessor if the property has a backing field or the assessor does not reference
    the backing field. The code here is an example of a scenario where we cannot use
    `inline`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Another thing to keep in mind is that, although inline properties reduce call
    overhead by getting expanded only at the call site, they also increase the overall
    bytecode, so inline should not be used with large functions or accessors.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, basically, we use inline when we wish to reduce memory overhead. Like the
    inline function, we can also declare properties as inline or the accessors of
    properties as inline. However, one thing to keep in mind is that inlining increases
    bytecode considerably, so it is suggested to not inline functions or accessors
    that have a large code logic.
  prefs: []
  type: TYPE_NORMAL
- en: How to work with nested class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use nested classes in Kotlin. A nested class
    is a member of its enclosing class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    Kotlin compiler installed along with JDK. I am using online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will see how to work with a nested class in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an example of a nested class in Kotlin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try an example of the `inner` class. To declare a nested class
    as `inner`, we use the `inner` keyword. An `inner` class can access members of
    the outer class, as they carry a reference to the outer class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nested class can be created by just declaring the nested class inside another
    class. In this case, to access the nested class, you make a static reference that
    is like `outerClass.innerClass()`, and you can also make an object of inner class
    using this.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `inner` class, on the other hand, is created by adding the `inner` keyword
    to a nested class. In that case, we access the inner class as though it was a
    member or the outer class, that is, using an object of the outer class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: A nested class does not have access to members of the outer class, as it does
    not have any reference to an object of the outer class. On the other hand, the
    inner class can access all of the outer class’s members, as it has a reference
    to an object of outer class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also create anonymous inner classes in Kotlin using the `object` keyword,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Getting class in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look into the ways by which we can get the class reference
    in Kotlin. Primarily, we will be working with reflection. Reflection is a library
    that provides the ability to inspect code at runtime instead of compile time.
    In Java, we can get a variable's class through `getClass()`, like `something.getClass()`.
    Let’s see how to resolve a variable’s class in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java’s equivalent of resolving a variable's name is with the `.getClass()` method,
    for example, `something.getClass()`. In Kotlin, we can achieve the same thing
    with `something.javaClass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get a reference to the reflection class, we used to do `something.class`
    in Java, whose Kotlin equivalent is `something::class`. This returns a `KClass`.
    The special features of this `KClass` is that it provides introspection capabilities
    quite similar to the abilities provided to Java’s reflection class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the KClass is different from Java’s `Class` object. If you want to
    obtain a Java `Class` object from Kotlin''s `KClass`, use the `.java` extension
    property:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The latter example will be optimized by the compiler to not allocate an intermediate
    KClass instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use Kotlin 1.0, you can convert the obtained Java class to a KClass instance
    by calling the `.kotlin` extension property, for example, `something.javaClass.kotlin`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As was just described, `KClass` provides you with introspection capabilities.
    Here are a few methods of `KClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isAbstract`: True if this class is abstract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isCompanion`: True if this class is a companion object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isData`: True if this class is a data class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFinal`: True if this class is final'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isInner`: True if this class is an inner class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isOpen`: True if this class is open'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow this link ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/))
    for the complete list of functions provided by KClass.
  prefs: []
  type: TYPE_NORMAL
- en: Working with delegated properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin 1.1 brought many updates; one of the important ones was delegated properties.
    There are three types of delegated properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lazy`: Lazy properties are the ones evaluated first and the same instance
    is returned after them, much like a cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`observable`: The listener is notified whenever a change is made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`: Properties are stored in the map instead of in every field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will see how to work with these delegates. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be working on Android code, so we will require Android Studio 3.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see a simple example of a delegated property:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will work with the lazy delegate property. Simply put, this delegate
    can suspend the object creation until we first access it. This is really important
    when you are working with heavy objects; they take a long time to be created—for
    example, when creating a database instance or maybe dagger components. Not only
    this, the result is remembered and the same value is returned for subsequent calls
    for `getValue()` on this kind of delegated property. Let''s take a look at an
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is a standard `onCreate` method of an activity. If you look carefully,
    we have set the `button` variable before the `setContentView(..)` method. When
    you run it, it runs perfectly. If you hadn''t used lazy, it would have given a
    `NullPointerException`, something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The button variable was null, as we called it before the `setContentView`. However,
    this wasn't a problem with lazily created `button` object, because although we
    had declared it before `setContentView`, the `button` object wasn't created. It
    was created after its first access, that is, when we tried to set a property on
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, with a lazy construct, you don't need to think about where to place your
    code for initialization, and initialization of an object is deferred till its
    first use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another key thing to note is that, by default, the evaluation of lazy properties
    will be synchronized, which means the value is computed in one thread, and the
    rest of the threads will see the same value. There are three types of initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LazyThreadSafetyMode.SYNCHRONIZED`: This is the default mode and ensures that
    only a single thread can initialize the instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LazyThreadSafetyMode.PUBLICATION`: In this mode, multiple threads can execute
    the initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LazyThreadSafetyMode.NONE`: This mode is used when we are sure that initialization
    will happen only on one thread. For example, in the case of Android, we can be
    sure that views will be initialized by the UI thread only. Since this doesn''t
    guarantee thread-safety, it has much less overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another useful delegate is the observable delegate. This delegate helps us
    observe any changes to the property. For example, let''s take a look at a very
    basic implementation of the `observable` delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `observable` delegate takes in two things: a default value
    (which we specified as `<>`) and a handler, which gets called whenever that property
    is modified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now work with the `vetoable` delegate. It''s a lot like the `observable`
    delegate, but with it, we can "veto" the modification. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, if `newValue` isn't equal to `"Paris"`,
    we will return `false`, and the modification will be aborted. If you want the
    modification to take place, you need to return `true` from the construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you create an object based on values dynamically, for example, in
    the case of parsing JSON. For those applications, we can use the `map` instance
    itself as the delegate for a delegated property. Let''s see an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it work for `var` properties, you need to use a `MutableMap`, so the
    preceding example might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the output will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observable delegated property can be used extensively in adapters. Adapters
    are used to populate data in some sort of list. Usually, when data is updated,
    we just update the member variable list in the adapter and then call `notifyDatasetChanged()`.
    With the help of observable and `DiffUtils`, we can just update the things that
    are actually changed, rather than changing everything. This results in much more
    efficient performance.
  prefs: []
  type: TYPE_NORMAL
- en: Working with enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enums are used when a variable can only take one of a small set of possible
    values. An example would be the case of type constants (direction: "North", "South",
    "East", and “West”). With the help of enums, you can avoid errors from passing
    in invalid constants, and you also document which values are acceptable for use.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use enums in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll be using an IntelliJ IDEA for writing and running the code. First, we
    will be creating a simple type-safe enum, `Direction`, with the members NORTH,
    SOUTH, EAST, and WEST (representing four directions).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see an example of the `enum` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create an enum of directions. We will assume that
    there are only four of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the variable (`north_direction`) can just take values among
    the predefined constants in the `enum` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also initialize enums with default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is strongly recommended that you don’t use enums in your Android projects.
    According to Google engineers, adding a single enum will increase the size to
    approximately 13 times that of the final DEX file. It also generates the problem
    of runtime overhead and your app will require more space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android documentation says this:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Enums often require more than twice as much memory as static constants. You
    should strictly avoid using enums on Android."'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you want the comfort of enums, you can use Android’s annotation
    library, which has `TypeDef` annotations—but sadly, this isn’t supported by Kotlin
    at the time of this book being written, so we hope it gets added in future versions
    of Kotlin.
  prefs: []
  type: TYPE_NORMAL
