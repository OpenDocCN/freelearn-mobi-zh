<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Mandatory Access Controls and SELinux"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Mandatory Access Controls and SELinux</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Linux Access Controls">Chapter 1</a>, <span class="emphasis"><em>Linux Access Controls</em></span>, we introduced some of the shortcomings of a discretionary access control system. In these systems, the owner of an object has full control over its permissions flags and can demonstrate greater capabilities (for example, the ability to <code class="literal">chown</code>) when executing as <code class="literal">root</code> or with certain capabilities. In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Examine the fundamentals of MAC</li><li class="listitem" style="list-style-type: disc">Introduce some industry drivers for SELinux</li><li class="listitem" style="list-style-type: disc">Discuss labels, users, roles, and types</li><li class="listitem" style="list-style-type: disc">Explore the implementation of tangible policy to allow and constrain object interaction</li></ul></div><p>Ideal MAC systems maintain the property of providing definitive access controls on kernel resources, such as files, irrespective of an object's owner. For instance, with a MAC system, the owner of an object might not have full control of its permissions. In Linux, the MAC framework works orthogonally to the current DAC controls. This means that the MAC controls do not interfere with the DAC controls. In other words, to avoid potential conflicts between the MAC and DAC systems, the kernel validates access using the DAC permissions before checking the MAC permissions. If the DAC permissions result in a permissions violation, then the MAC permissions are never checked. The kernel will validate access against the MAC permissions provider only when the DAC permissions pass. Failure at either level will result in a return of <code class="literal">EACCESS</code>. If the DAC and the MAC permissions pass, then the kernel resource (for example, a file descriptor) is sent back to user space.</p><p>In Linux, a<a id="id28" class="indexterm"/> framework called the <span class="strong"><strong>Linux Security Module</strong></span> (<span class="strong"><strong>LSM</strong></span>) framework was merged during the Linux 2.6.x series of kernels. This framework allows you to enable the mandatory access control systems in a build time selection by tethering the LSM hooks to the security provider. <span class="strong"><strong>Security Enhanced Linux</strong></span> (<span class="strong"><strong>SELinux</strong></span>) is <a id="id29" class="indexterm"/>the first consumer of this MAC security framework within the kernel and is an implementation of a mandatory access control system. SELinux ships in a wide<a id="id30" class="indexterm"/> variety of Linux systems, such as <span class="strong"><strong>Red Hat Enterprise Linux</strong></span> (<span class="strong"><strong>RHEL</strong></span>) and consequently Fedora. Recently, it has begun shipping with Android. The source code for SELinux can be found in the Linux source code tree under <code class="literal">kernel/security/selinux</code> for those wishing to review it.</p><div class="section" title="Getting back to the basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Getting back to the basics</h1></div></div></div><p>SELinux<a id="id31" class="indexterm"/> is a reimplementation of a design engineered by the U.S. government and The University of Utah known as the <span class="strong"><strong>FLUX Advanced Security Kernel</strong></span> (<span class="strong"><strong>FLASK</strong></span>). The SELinux and FLASK architecture provide a <a id="id32" class="indexterm"/>central policy file utilized while determining the results of access control decisions. This central policy is in a whitelist form. This means that all access control rules must be defined explicitly by the policy file. This policy file is abstracted and served by a software component called a security server. When the Linux kernel needs to make an access control decision and SELinux is enabled, the kernel interacts with the security server by means of the LSM hooks.</p><p>In a running system, a process is the active entity that gets time on the CPU to perform tasks. The user merely invokes these processes to do the work on their behalf. This is an important concept. As we type this book, we trust that the word processors running on our machines with our credentials aren't opening our SSH keys and embedding them in the document metadata. Right now, the process is in control of the computing resources, not the user. The process is the running entity, it is the process that makes system calls to the kernel for resources, not the physical human being. With this in mind, the very first actor in this SELinux system is<a id="id33" class="indexterm"/> the process, typically referred to as the <span class="strong"><strong>subject</strong></span>. It is the subject that accesses files. It is the subject that the security server will use to make access decisions on.</p><p>Consequently, the<a id="id34" class="indexterm"/> subject utilizes kernel resources. This kind of kernel resource is an example of a <span class="strong"><strong>target</strong></span>. The subject performs actions on the target. Naturally, one should ask, "What actions does a subject perform?" These are known as access vectors and typically correlate to the name of the syscall performed. For example, the subject could perform an <code class="literal">open</code> on the target. It is important to note that targets could be processes as well. For instance, if the system call is <code class="literal">ptrace</code>, the subject could be something along the lines of a debugger, and the target would be the process you wish to debug. A subject is frequently a process, but a target could be a process, socket, file, or something else.</p></div></div>
<div class="section" title="Labels"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Labels</h1></div></div></div><p>SELinux<a id="id35" class="indexterm"/> provides semantics for describing policies related to the targets and subjects using labels. Labels are the metadata associated with an object that maintains the subject's and target's access information. The data associated with this object is a string. Returning to the debugger example, the <code class="literal">gdb</code> process might have a subject label string of <code class="literal">debugger</code>, and the target might have a label of <code class="literal">debugee</code>. Then in the security policy, some semantic could be used to express that processes with the subject label <code class="literal">debugger</code> are allowed to debug applications with target label <code class="literal">debugee</code>.</p><p>Fortunately, and perhaps unfortunately, SELinux does not use such simple labels. In fact, the labels are made up of four colon-delimited fields: user, role, type, and level. This additional complexity affords very flexible control options.</p><div class="section" title="Users"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Users</h2></div></div></div><p>The <a id="id36" class="indexterm"/>very first field in a label identifies the user. The user field is used as part<a id="id37" class="indexterm"/> of the design for <span class="strong"><strong>user-based access controls</strong></span> (<span class="strong"><strong>UBAC</strong></span>). However, this <a id="id38" class="indexterm"/>is not typically associated with human users as it is with the concept of users in DAC. SELinux users typically define a group of traditional users. A common example is to identify all normal users as the SELinux user, <code class="literal">user_u</code>. Perhaps a separate user for system processes, such as <code class="literal">system_u</code>. By convention in the desktop SELinux community, user portions of the string are suffixed with a <code class="literal">_u</code>.</p></div><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Roles</h2></div></div></div><p>The second<a id="id39" class="indexterm"/> field in a label is role. The role is used as part of the design <a id="id40" class="indexterm"/>for <span class="strong"><strong>role-based access controls</strong></span> (<span class="strong"><strong>RBAC</strong></span>). Roles are used to provide <a id="id41" class="indexterm"/>additional granularity to the user. For instance, suppose we have the user field, <code class="literal">sysadm_u</code>, reserved for administrators. The administrator might be in separate tasks, and depending on the tasks, the role (and therefore, privileges) of users in <code class="literal">sysadm_u</code> may change. For example, when an administrator needs to mount and unmount file systems, the role field might change to <code class="literal">mount_admin_r</code>. When an administrator is setting the <code class="literal">iptables</code> rules, the role might change to <code class="literal">net_admin_r</code>. Roles allow the isolation of privileges within the scope of the tasks being performed.</p></div><div class="section" title="Types"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Types</h2></div></div></div><p>Type is<a id="id42" class="indexterm"/> the third field of the colon-delimited label. The type field is evaluated <a id="id43" class="indexterm"/>during the <span class="strong"><strong>type enforcement</strong></span> (<span class="strong"><strong>TE</strong></span>) portion of SELinux's access<a id="id44" class="indexterm"/> control model. TE is the major component that drives SELinux's security capabilities, and it is at this point where the policy starts to take effect.</p><p>SELinux is based on a whitelist system where everything is denied by default and requires<a id="id45" class="indexterm"/> explicit approval from the policy for an interaction to occur. This approval<a id="id46" class="indexterm"/> is initially determined from the policy via an allow rule that references both the subject's and target's type. SELinux types can also be assigned attributes. Attributes allow you to give numerous types a common set of rules. Attributes can help minimize the amount of types, and can be used in fashion similar to that of an inheritance model.</p></div></div>
<div class="section" title="Access vectors"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Access vectors</h1></div></div></div><p>Data is<a id="id47" class="indexterm"/> accessed by processes via system calls and possible user defined access methods. The user defined access methods are usually controlled via a userspace object manager. These access paths, also known as vectors, make up a set of actions that can be applied to the object. For instance, if a process opens a file, writes some data into the file, and then reads it back, the access vectors exercised would be <code class="literal">open</code>, <code class="literal">read</code>, and <code class="literal">write</code>. If a process debugs another process, the access vector would be <code class="literal">ptrace</code>.</p></div>
<div class="section" title="Multilevel security"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Multilevel security</h1></div></div></div><p>SELinux <a id="id48" class="indexterm"/>also supports a <span class="strong"><strong>multilevel security</strong></span> (<span class="strong"><strong>MLS</strong></span>) model, which pays homage to the <span class="strong"><strong>Bell-LaPadula</strong></span> (<span class="strong"><strong>BLP</strong></span>) model, but alternate models<a id="id49" class="indexterm"/> could be used. The BLP model was created to formalize the Department of Defense's security policies. For example, a person with a secret clearance should not be able to read top-secret material. However, let's suppose this person has a brilliant idea that ultimately needs to be protected at the top-secret level; that data could then be "up-classified" to top-secret. This is referred to as "no read up or write down".</p><p>The SELinux<a id="id50" class="indexterm"/> implementation of this field has subfields. The first field is sensitivity, and will always be present. In the context of the previous example, pertinent sensitivities include secret and top secret. The second subfield is category, and might not be present. These fields also make sense in the context of government classification. The data itself might be compartmentalized, so while the sensitivity is the same, such as top secret, the data should only be disseminated to people within the same compartment or category. Sensitivities are defined in a hierarchical fashion via the dominance keyword. In a typical policy, <code class="literal">s0</code> is the lowest sensitivity and <code class="literal">sN</code> where <code class="literal">n &gt; 0</code> is the highest. Thus, <code class="literal">s1</code> has a greater sensitivity than <code class="literal">s0</code>. Categories are sets. The controls associated with the level, which is comprised of sensitivities and potentially categories, follow set theory concepts, such as dominance and equality. In MLS security, all interactions are allowed by default, unlike type enforcement. Both the sensitivity and the category can be ranged, and categories can be enumerated. Thus, a label might have some number of sensitivities and different number of categories.</p></div>
<div class="section" title="Putting it together"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Putting it together</h1></div></div></div><p>SELinux labels are quite flexible and sometimes complex. It's often beneficial to start with <a id="id51" class="indexterm"/>a contrived example that focuses on type enforcement. Later, we can add additional fields later as the need for finer granularity becomes more apparent. Conveniently, you can project this model to scenarios in everyday life to provide some sense of tangibility to the material. Dan Walsh, a prominent SELinux figure, posted a blog post using pets as an analogy. Let's continue on with that premise, but we will make some modifications as we go and define our own examples. It's best to start with simple type enforcement as it is the easiest to understand.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>You can<a id="id52" class="indexterm"/> read Dan Walsh's original blog post introducing the pet analogy at <a class="ulink" href="http://opensource.com/business/13/11/selinux-policy-guide">http://opensource.com/business/13/11/selinux-policy-guide</a>.</p></div></div><p>Suppose we own a cat and a dog. We don't want the cat to eat dog food. We don't want the dog to eat cat food. At this point, we have already identified two subjects, a cat and a dog, and two targets, cat food and dog food. We also have identified an access vector, eating. We can use allow rules to implement our policy. Possible rules could look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>allow cat cat_chow:food eat;</strong></span>
<span class="strong"><strong>allow dog dog_chow:food eat;</strong></span>
</pre></div><p>Let's use this example to start and define a basic syntax for expressing the access controls we would like to enforce. The first token is <code class="literal">allow</code>, stating we wish to allow an interaction between a subject and a target. The dog is assigned the type, <code class="literal">dog</code>, and the cat, <code class="literal">cat</code>. The cat food is assigned the type <code class="literal">cat_chow</code>, and the dog food, <code class="literal">dog_chow</code>. The access vector in this case is <code class="literal">eat</code>. With this basic syntax, which is also valid SELinux syntax, we restrict the animals to the food they should eat. Notice the <code class="literal">:food</code> annotation after the type. This is the class field of the target object. For<a id="id53" class="indexterm"/> instance, there might also be <code class="literal">dog_chow</code> <code class="literal">treat</code> and <code class="literal">cat_chow</code> classes that could indicate our desire to allow access to treats in a fashion that is potentially different from the way we allow access to foods that are not treats.</p><p>Let's say we get two more dogs, and our scenario has three dogs. The dogs are of different sizes: small, medium, and large. We want to make sure none of these new dogs eat others' food. We could do something like create a new type for each of the dogs and prevent dogs from eating the food of other dogs. It would look something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>allow cat cat_chow:food eat;</strong></span>
<span class="strong"><strong>allow dog_small dog_small_chow:food eat;</strong></span>
<span class="strong"><strong>allow dog_medium dog_medium_chow:food eat;</strong></span>
<span class="strong"><strong>allow dog_large dog_large chow:food eat;</strong></span>
</pre></div><p>This would <a id="id54" class="indexterm"/>work; however, the total number of types would be difficult to manage, and that would continue to grow if we allow the large dog to eat the smaller breeds' food. What we could do is use MLS support to assign a sensitivity to each target or dog food bowl. Let's assume the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The cat's food bowl has sensitivity, <code class="literal">tiny</code></li><li class="listitem" style="list-style-type: disc">The small dog's food bowl has sensitivity, <code class="literal">small</code></li><li class="listitem" style="list-style-type: disc">The medium-sized dog's food bowl has sensitivity, <code class="literal">medium</code></li><li class="listitem" style="list-style-type: disc">The large dog's food bowl has sensitivity, <code class="literal">large</code></li></ul></div><p>We also need to make sure that the subjects are labeled with the proper sensitivity as well:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The cat should have sensitivity, <code class="literal">tiny</code></li><li class="listitem" style="list-style-type: disc">The small dog should have sensitivity, <code class="literal">small</code></li><li class="listitem" style="list-style-type: disc">The medium-sized dog should have sensitivity, <code class="literal">medium</code></li><li class="listitem" style="list-style-type: disc">The large dog should have sensitivity, <code class="literal">large</code></li></ul></div><p>At this point, we need to introduce additional syntax to allow the interactions, since by default, MLS allows everything and TE denies everything. We'll use <code class="literal">mlsconstrain</code>, to restrict interactions within the system. The rule could look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mlsconstrain food eat (l1 eq l2);</strong></span>
</pre></div><p>This constraint only allows subjects to eat food with the same sensitivity level. SELinux defines the keywords <code class="literal">l1</code> and <code class="literal">l2</code>. The <code class="literal">l1</code> keyword is the level of the target and <code class="literal">l2</code> is the level of the source. Because the rules are part of a whitelist, this also prevents subjects from eating food that does not have the equivalent sensitivity level.</p><p>Now, let's say we get yet another large dog. Now we have two large breed dogs. However, they have different diets and need to access different foods. We could add a new type or modify an existing type, but this would have the same limitations that led us to use sensitivities to prevent access. We could add another sensitivity, but it might get confusing that there are <code class="literal">large1</code> and <code class="literal">large2</code> sensitivities. At this point, categories would allow us to get a bit more granular in our controls. Suppose we add a category denoting the breed. Our MLS portion of our label would look something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>large:golden_retriever</strong></span>
<span class="strong"><strong>large:black_lab</strong></span>
</pre></div><p>These could be used to prevent the black lab from eating the golden retriever's food. Now suppose you're<a id="id55" class="indexterm"/> surprised with another dog, a Saint Bernard. Let's say this new Bernard can eat any large dog's food, but the other large dogs can't eat his food. We could label the food bowls and the dogs.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Dog Breed</p>
</th><th style="text-align: left" valign="bottom">
<p>Subject label</p>
</th><th style="text-align: left" valign="bottom">
<p>Target label</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Golden Retriever</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Dog:large:golden_retriver</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">dog_chow:large:golden_retriver</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Black Lab</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Dog:large:black_lab</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">dog_chow:large:black_lab</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Saint Bernard</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Dog:large:saint_bernard, black_lab, golden_retriever</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">dog_chow:large:saint_bernard</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Cat</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Cat:tiny</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">cat_chow:tiny</code>
</p>
</td></tr></tbody></table></div><p>The existing <code class="literal">mlsconstraint</code> needs modification. If the Saint Bernard ran out of food and went to the Black Lab's dish, the Saint Bernard would not be able to eat from it since the levels are not equal (<code class="literal">Dog:large:saint_bernard, black_lab, golden_retriever</code> is not the same as <code class="literal">dog_chow:large:black_lab</code>). Remember, the levels are sets, so we need to introduce some notion that if the subjects set dominates the target set, that interaction should be allowed.</p><p>This could be accomplished with the <code class="literal">dom</code> keyword:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mlsconstrain food eat (l1 dom l2);</strong></span>
</pre></div><p>The dominate keyword, <code class="literal">dom</code>, differs from equality, indicating <code class="literal">l1</code> is a superset of <code class="literal">l2</code> In other words, the levels associated with the target, <code class="literal">l2</code>, are among the potentially larger set of levels associated with the subject, <code class="literal">l1</code>. At this point, we are able to keep all the food separated and used however we see fit.</p><p>After getting all these dogs, you realize it's time to feed them, so you get a bag of dog food and put some in each bowl. However, before you can add dog food to the bowls, we need some allow rules and labels that will let you. Remember, SELinux is a whitelist-based system, and everything must be explicitly allowed.</p><p>We will label the human with the <code class="literal">human</code> label and define some rules. Oh yeah... don't forget to feed the cat, as well:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>allow human dog_chow:food put;</strong></span>
<span class="strong"><strong>allow human cat_chow:food put;</strong></span>
</pre></div><p>We will also need to label <code class="literal">human</code> with all the sensitivities and categories, but this would become cumbersome when we need to add additional dogs, breeds, and breed sizes to our system. We could just bypass the constraint if the type is <code class="literal">human</code>. With this approach, we always trust <code class="literal">human</code> to put the correct food in the appropriate bowl:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mlsconstrain food eat (l1 dom l2);</strong></span>
<span class="strong"><strong>mlsconstrain food put (t1 == human);</strong></span>
</pre></div><p>Note the addition of <code class="literal">put</code> in the access vectors of the MLS constraint. Viola! The human can now feed his ever-growing pack of animals.</p><p>So your <a id="id56" class="indexterm"/>birthday rolls around, and you receive an automatic dog feeder as a present. You label the food dispenser, <code class="literal">dispenser</code> and modify the MLS constraints:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mlsconstrain food eat (l1 dom l2);</strong></span>
<span class="strong"><strong>mlsconstrain food put (t1 == human or t1 == dispenser);</strong></span>
</pre></div><p>Again, we see a need to condense the number of types and get organized to prevent having to duplicate lines. This is where attributes are quite handy. We can assign an attribute to our <code class="literal">human</code> and <code class="literal">dispenser</code> types by first defining the attribute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>attribute feeder;</strong></span>
</pre></div><p>Then we can add it to the type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>typeattribute human, feeder;</strong></span>
<span class="strong"><strong>typeattribute dispenser, feeder;</strong></span>
</pre></div><p>This could also be done at type declaration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>type human, feeder;</strong></span>
<span class="strong"><strong>type dispenser, feeder;</strong></span>
</pre></div><p>At this point, we could modify the MLS statements to look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mlsconstrain food eat (l1 dom l2);</strong></span>
<span class="strong"><strong>mlsconstrain food put (t1 == feeder);</strong></span>
</pre></div><p>Now let's suppose you hire a maid service. You want to ensure anyone sent by the maid service is able to feed your pets. For that matter, let's let your family members feed them, as well. This would be a good use case for the user capabilities. We will define the following users: <code class="literal">adults_u</code>, <code class="literal">kids_u</code>, and <code class="literal">maid_u</code>. Then we'll need to add a constraint statement to allow interactions by these users:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mlsconstrain food put (u1 == adults_u or u1 == maid_u);</strong></span>
</pre></div><p>This would prevent the kids from feeding the dogs, but let the maids and adults feed them. Now suppose you hire a gardener. You could create yet another user, <code class="literal">gardener_u</code>, or you could collapse the users into a few classes and use roles. Let's suppose we collapse <code class="literal">gardener_u</code> and <code class="literal">maid_u</code> into <code class="literal">staff_u</code>. There is no reason the gardener should be feeding the dog, so we could use role-based transitions to move the staff between their duties. For instance, suppose staff can perform more than one service, that is, the same person might garden and clean. In this case, they might take on the role of <code class="literal">gardener_r </code>or <code class="literal">maid_r</code>. We could use the role capability of SELinux to meet this need:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mlsconstrain food put (u1 == adults_u or (u1 == staff_u and r1 == animal_care_r);</strong></span>
</pre></div><a id="id57" class="indexterm"/><p>Staff may only feed the dogs when they're in the <code class="literal">animal_care_r</code> role. How to get into and back out of that role is really the only component missing. You need to have a well-defined system for how the staff can move into the animal care role and transition back out. These transitions in SELinux occur either automatically via dynamic role transitions or via source code modifications. We'll assume that any human entity (gardener, adults, kids) all start in the <code class="literal">human_r</code> role.</p><p>Dynamic role transitions work with a two-part rule, the first part allows the transition to occur via an allow rule:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>allow human_r animal_care_r;</strong></span>
</pre></div><p>The role transition statements are as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>role_transition human_r dog_chow animal_care_r;</strong></span>
<span class="strong"><strong>role_transition human_r cat_chow animal_care_r;</strong></span>
</pre></div><p>This would be a good case to attribute the <code class="literal">dog_chow</code> and <code class="literal">cat_chow</code> types to a new attribute, <code class="literal">animal_chow</code>, and rewrite the preceding role transitions to:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>typeattribute dog_chow, animal_chow;</strong></span>
<span class="strong"><strong>typeattribute cat_chow, animal_chow;</strong></span>
<span class="strong"><strong>role_transition human_r animal_chow animal_care_r;</strong></span>
</pre></div><p>With these role transitions, you can only go from the <code class="literal">human_r</code> role to <code class="literal">animal_care_r</code>. You would need to define transitions to get back as well. It's also important to note that you might define other roles. Suppose you define the role <code class="literal">gardener_r</code>, and when someone is in that role, they cannot transition to <code class="literal">animal_care_r</code>. Suppose your justification for this policy is that gardeners might work with chemicals unsafe for pets, so they would need to wash their hands before feeding pets. In such a situation, they should only be able to transition to <code class="literal">animal_care_r</code> from the <code class="literal">hand_wash_r</code> role.</p></div>
<div class="section" title="Complexities and best practices"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Complexities and best practices</h1></div></div></div><p>As you can now appreciate, SELinux is complex, and can be thought of as a general purpose "meta programming policy language". You're literally programming what interactions<a id="id58" class="indexterm"/> are allowed to occur in a very complex OS such as <a id="id59" class="indexterm"/>Linux, where the interactions themselves are often complex. Just like a programming language, you can do things with different styles and methods that will yield differing results. Perhaps using a <code class="literal">switch()</code> in that program will make it cleaner and easier to understand rather than an <code class="literal">else-if</code> block, even though functionally you will end up with the same thing. SELinux is the same; you can often accomplish things with one portion of the enforcement mechanisms that would be more appropriately accomplished using an alternate mechanism. In later chapters, we will cover the process of labeling the target and subject, one of the more difficult parts of the system.</p><p>When someone authors a program, they often have a set of requirements in place that the software should perform. These are the requirements of the software. In SELinux, you should do<a id="id60" class="indexterm"/> the same thing. You should gather the security requirements <a id="id61" class="indexterm"/>and understand the threat models you wish to protect yourself from. A well designed SELinux policy would meet these goals. A great design would do it in a way that is easy to extend. That's ultimately where careful and judicious use of the combination of UBAC, RBAC, TE, and MLS will help achieve the requirements and design goals.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we covered the major working portions of SELinux that include type enforcement, multilevel and multicategory security, as well as users and roles. Additionally, we saw how to apply these technologies to implement increasingly complex access policies to a tangible example. In the next chapter, we will move outside of the kernel and discover how Android works in its very unique user space.</p></div></body></html>