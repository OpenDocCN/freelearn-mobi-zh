["```kt\n$ ls -F\nboot.img*  file_contexts*  META-INF/  recovery/  system/  \n\n```", "```kt\nservice flash_recovery /system/bin/install-recovery.sh \n    class main \n    oneshot \n\n```", "```kt\n#!/system/bin/sh \nif ! applypatch -c EMMC:/dev/block/sda7:7757824:853301871de495db2b8c93f7a37779b9eeccb169; then \n  applypatch -b /system/etc/recovery-resource.dat EMMC:/dev/block/sda8:6877184:2f58cc1a4035176c8fefc19be70c00e625acc16b EMMC:/dev/block/sda7 853301871de495db2b8c93f7a37779b9eeccb169 7757824 2f58cc1a4035176c8fefc19be70c00e625acc16b:/system/recovery-from-boot.p && log -t recovery \"Installing new recovery image: succeeded\" || log -t recovery \"Installing new recovery image: failed\" \nelse \n  log -t recovery \"Recovery image already installed\" \nfi \n\n```", "```kt\n#include <stdio.h> \n#include <unistd.h> \n#include <stdlib.h> \n#include <string.h> \n\n#include \"edify/expr.h\" \n#include \"updater.h\" \n#include \"install.h\" \n#include \"blockimg.h\" \n#include \"minzip/Zip.h\" \n#include \"minzip/SysUtil.h\" \n\n#include \"register.inc\" \n\n#define SCRIPT_NAME \"META-INF/com/google/android/updater-script\" \n\nextern bool have_eio_error; \n\nstruct selabel_handle *sehandle; \n\nint main(int argc, char** argv) { \n    setbuf(stdout, NULL); \n    setbuf(stderr, NULL); \n\n    if (argc != 4 && argc != 5) { \n        printf(\"unexpected number of arguments (%d)\\n\", argc); \n        return 1; \n    } \n\n    char* version = argv[1]; \n    if ((version[0] != '1' && version[0] != '2' && version[0] != '3')  \n    || \n        version[1] != '\\0') { \n        // We support version 1, 2, or 3\\. \n        printf(\"wrong updater binary API; expected 1, 2, or 3; \" \n                        \"got %s\\n\", \n                argv[1]); \n        return 2; \n    } \n\n```", "```kt\n// Set up the pipe for sending commands back to the parent process. \n\nint fd = atoi(argv[2]); \nFILE* cmd_pipe = fdopen(fd, \"wb\"); \nsetlinebuf(cmd_pipe); \n\n// Extract the script from the package. \n\nconst char* package_filename = argv[3]; \nMemMapping map; \nif (sysMapFile(package_filename, &map) != 0) { \n    printf(\"failed to map package %s\\n\", argv[3]); \n    return 3; \n} \nZipArchive za; \nint err; \nerr = mzOpenZipArchive(map.addr, map.length, &za); \nif (err != 0) { \n    printf(\"failed to open package %s: %s\\n\", \n           argv[3], strerror(err)); \n    return 3; \n} \nota_io_init(&za); \n\nconst ZipEntry* script_entry = mzFindZipEntry(&za, SCRIPT_NAME); \nif (script_entry == NULL) { \n    printf(\"failed to find %s in %s\\n\", SCRIPT_NAME, package_filename); \n    return 4; \n} \n\nchar* script = reinterpret_cast<char*>(malloc(script_entry->uncompLen+1)); \nif (!mzReadZipEntry(&za, script_entry, script, script_entry->uncompLen)) { \n    printf(\"failed to read script from package\\n\"); \n    return 5; \n} \nscript[script_entry->uncompLen] = '\\0';     \n\n```", "```kt\n// Configure edify's functions. \n\nRegisterBuiltins(); \nRegisterInstallFunctions(); \nRegisterBlockImageFunctions(); \nRegisterDeviceExtensions(); \nFinishRegistration(); \n\n// Parse the script. \n\nExpr* root; \nint error_count = 0; \nint error = parse_string(script, &root, &error_count); \nif (error != 0 || error_count > 0) { \n    printf(\"%d parse errors\\n\", error_count); \n    return 6; \n} \n\nstruct selinux_opt seopts[] = { \n  { SELABEL_OPT_PATH, \"/file_contexts\" } \n}; \n\nsehandle = selabel_open(SELABEL_CTX_FILE, seopts, 1); \n\nif (!sehandle) { \n    fprintf(cmd_pipe, \"ui_print Warning: No file_contexts\\n\"); \n} \n\n// Evaluate the parsed script. \n\nUpdaterInfo updater_info; \nupdater_info.cmd_pipe = cmd_pipe; \nupdater_info.package_zip = &za; \nupdater_info.version = atoi(version); \nupdater_info.package_zip_addr = map.addr; \nupdater_info.package_zip_len = map.length; \n\nState state; \nstate.cookie = &updater_info; \nstate.script = script; \nstate.errmsg = NULL; \n\nif (argc == 5) { \n    if (strcmp(argv[4], \"retry\") == 0) { \n        state.is_retry = true; \n    } else { \n        printf(\"unexpected argument: %s\", argv[4]); \n    } \n} \n\nchar* result = Evaluate(&state, root); \n\nif (have_eio_error) { \n    fprintf(cmd_pipe, \"retry_update\\n\"); \n} \n\nif (result == NULL) { \n    if (state.errmsg == NULL) { \n        printf(\"script aborted (no error message)\\n\"); \n        fprintf(cmd_pipe, \"ui_print script aborted (no error \n        message)\\n\"); \n    } else { \n        printf(\"script aborted: %s\\n\", state.errmsg); \n        char* line = strtok(state.errmsg, \"\\n\"); \n        while (line) { \n            if (*line == 'E') { \n              if (sscanf(line, \"E%u: \", &state.error_code) != 1) { \n               printf(\"Failed to parse error code: [%s]\\n\", line); \n               } \n            } \n            fprintf(cmd_pipe, \"ui_print %s\\n\", line); \n            line = strtok(NULL, \"\\n\"); \n        } \n        fprintf(cmd_pipe, \"ui_print\\n\"); \n    } \n\n    if (state.error_code != kNoError) { \n        fprintf(cmd_pipe, \"log error: %d\\n\", state.error_code); \n        if (state.cause_code != kNoCause) { \n            fprintf(cmd_pipe, \"log cause: %d\\n\", state.cause_code); \n        } \n    } \n\n    free(state.errmsg); \n    return 7; \n} else { \n    fprintf(cmd_pipe, \"ui_print script succeeded: result was [%s]\\n\", \n    result); \n    free(result); \n} \n\nif (updater_info.package_zip) { \n    mzCloseZipArchive(updater_info.package_zip); \n} \nsysReleaseMap(&map); \nfree(script); \n\nreturn 0; \n} \n\n```", "```kt\nvoid RegisterBuiltins() { \n    RegisterFunction(\"ifelse\", IfElseFn); \n    RegisterFunction(\"abort\", AbortFn); \n    RegisterFunction(\"assert\", AssertFn); \n    RegisterFunction(\"concat\", ConcatFn); \n    RegisterFunction(\"is_substring\", SubstringFn); \n    RegisterFunction(\"stdout\", StdoutFn); \n    RegisterFunction(\"sleep\", SleepFn); \n\n    RegisterFunction(\"less_than_int\", LessThanIntFn); \n    RegisterFunction(\"greater_than_int\", GreaterThanIntFn); \n} \n\n```", "```kt\nvoid RegisterInstallFunctions() { \n    RegisterFunction(\"mount\", MountFn); \n    RegisterFunction(\"is_mounted\", IsMountedFn); \n    RegisterFunction(\"unmount\", UnmountFn); \n    RegisterFunction(\"format\", FormatFn); \n    RegisterFunction(\"show_progress\", ShowProgressFn); \n    RegisterFunction(\"set_progress\", SetProgressFn); \n    RegisterFunction(\"delete\", DeleteFn); \n    RegisterFunction(\"delete_recursive\", DeleteFn); \n    RegisterFunction(\"package_extract_dir\", PackageExtractDirFn); \n    RegisterFunction(\"package_extract_file\", PackageExtractFileFn); \n    RegisterFunction(\"symlink\", SymlinkFn); \n    RegisterFunction(\"set_metadata\", SetMetadataFn); \n    RegisterFunction(\"set_metadata_recursive\", SetMetadataFn); \n    RegisterFunction(\"getprop\", GetPropFn); \n    RegisterFunction(\"file_getprop\", FileGetPropFn); \n    RegisterFunction(\"write_raw_image\", WriteRawImageFn); \n    RegisterFunction(\"apply_patch\", ApplyPatchFn); \n    RegisterFunction(\"apply_patch_check\", ApplyPatchCheckFn); \n    RegisterFunction(\"apply_patch_space\", ApplyPatchSpaceFn); \n    RegisterFunction(\"wipe_block_device\", WipeBlockDeviceFn); \n    RegisterFunction(\"read_file\", ReadFileFn); \n    RegisterFunction(\"sha1_check\", Sha1CheckFn); \n    RegisterFunction(\"rename\", RenameFn); \n    RegisterFunction(\"wipe_cache\", WipeCacheFn); \n    RegisterFunction(\"ui_print\", UIPrintFn); \n    RegisterFunction(\"run_program\", RunProgramFn); \n    RegisterFunction(\"reboot_now\", RebootNowFn); \n    RegisterFunction(\"get_stage\", GetStageFn); \n    RegisterFunction(\"set_stage\", SetStageFn); \n    RegisterFunction(\"enable_reboot\", EnableRebootFn); \n    RegisterFunction(\"tune2fs\", Tune2FsFn); \n} \n\n```", "```kt\nvoid RegisterBlockImageFunctions() { \n    RegisterFunction(\"block_image_verify\", BlockImageVerifyFn); \n    RegisterFunction(\"block_image_update\", BlockImageUpdateFn); \n    RegisterFunction(\"range_sha1\", RangeSha1Fn); \n} \n\n```", "```kt\nRegisterDeviceExtensions();  \n\n```", "```kt\n$ mkdir -p dist_output\n$ make dist DIST_DIR=dist_output  \n\n```", "```kt\n$(INTERNAL_OTA_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(DISTTOOLS) \n        @echo \"Package OTA: $@\" \n        $(hide) PATH=$(foreach \n        p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH \n        MKBOOTIMG=$(MKBOOTIMG) \\ \n           ./build/tools/releasetools/ota_from_target_files -v \\ \n --block \\ \n           -p $(HOST_OUT) \\ \n           -k $(KEY_CERT_PAIR) \\ \n           $(if $(OEM_OTA_CONFIG), -o $(OEM_OTA_CONFIG)) \\ \n           $(BUILT_TARGET_FILES_PACKAGE) $@ \n\n```", "```kt\n$ ls dist_output/**-ota-*.zip\ndist_output/x86vbox-ota-eng.sgye.zip  \n\n```", "```kt\n(!less_than_int(1482376066, getprop(\"ro.build.date.utc\"))) || abort(\"Can't install this package (Thu Dec 22 11:07:46 CST 2016) over newer build (\" + getprop(\"ro.build.date\") + \").\"); \ngetprop(\"ro.product.device\") == \"x86vbox\" || abort(\"This package is for \\\"x86vbox\\\" devices; this is a \\\"\" + getprop(\"ro.product.device\") + \"\\\".\"); \nui_print(\"Target: Android-x86/x86vbox/x86vbox:7.1.1/MOB30Z/roger12221103:eng/test-keys\"); \nshow_progress(0.750000, 0); \nformat(\"ext4\", \"EMMC\", \"/dev/block/sda1\", \"0\", \"/system\"); \nmount(\"ext4\", \"EMMC\", \"/dev/block/sda1\", \"/system\", \"max_batch_time=0,commit=1,data=ordered,barrier=1,errors=panic,nodelalloc\"); \npackage_extract_dir(\"system\", \"/system\"); \nsymlink(\"../../gm200/acr/bl.bin\", \"/system/lib/firmware/nvidia/gm204/acr/bl.bin\", \n        \"/system/lib/firmware/nvidia/gm206/acr/bl.bin\"); \n... \nsymlink(\"wl127x-nvs.bin\", \"/system/lib/firmware/ti-connectivity/wl1271-nvs.bin\", \n        \"/system/lib/firmware/ti-connectivity/wl12xx-nvs.bin\"); \nset_metadata_recursive(\"/system\", \"uid\", 0, \"gid\", 0, \"dmode\", 0755, \"fmode\", 0644, \"capabilities\", 0x0, \"selabel\", \"u:object_r:system_file:s0\"); \nset_metadata_recursive(\"/system/bin\", \"uid\", 0, \"gid\", 2000, \"dmode\", 0755, \"fmode\", 0755, \"capabilities\", 0x0, \"selabel\", \"u:object_r:system_file:s0\"); \nset_metadata(\"/system/bin/app_process32\", \"uid\", 0, \"gid\", 2000, \"mode\", 0755, \"capabilities\", 0x0, \"selabel\", \"u:object_r:zygote_exec:s0\"); \n... \nset_metadata(\"/system/xbin/su\", \"uid\", 0, \"gid\", 2000, \"mode\", 04751, \"capabilities\", 0x0, \"selabel\", \"u:object_r:su_exec:s0\"); \nshow_progress(0.050000, 5); \npackage_extract_file(\"boot.img\", \"/dev/block/sda8\"); \nshow_progress(0.200000, 10); \nunmount(\"/system\"); \n\n```", "```kt\non init \n    exec -- /system/bin/logwrapper /system/bin/sh /system/etc/init.sh \n\n```", "```kt\non early-init \n    # for /bin/busybox \n    symlink /bin/ld-linux.so.2 /lib/ld-linux.so.2 \n    symlink /bin/busybox /bin/sh \n\non init \n    mkdir /vendor \n    exec -- /bin/sh /sbin/init.x86vbox.sh \n\nservice network_start /sbin/network_start.sh \n    user root \n    seclabel u:r:recovery:s0 \n    oneshot \n\nservice console /bin/sh \n    class core \n    console \n    group shell log \n    seclabel u:r:shell:s0 \n\non property:ro.debuggable=1 \n    start console \n\n```", "```kt\n#!/bin/busybox sh  \n\necho -n \"Initializing x86vbox hardware ...\" \nPATH=/bin:/sbin:/bin; export PATH \n\ncd /bin;busybox --install -s \n\ncd /x86vbox \ninsmod atkbd.ko \ninsmod cn.ko \ninsmod vboxguest.ko \ninsmod vboxsf.ko \ninsmod uvesafb.ko mode_option=${UVESA_MODE:-1024x768}-32 \n\n/sbin/mount.vboxsf sdcard /vendor \n\n```", "```kt\n$ ls -1 lib\nlibcrypt.so.1\nlibc.so.6\nlibdl.so.2\nlibm.so.6\nlibntfs-3g.so.31\nlibpthread.so.0\nlibrt.so.1\n$ ls -1 bin\nbusybox\nld-linux.so.2\nlndir  \n\n```", "```kt\n$ ls -1 recovery/root/system/lib\nlibc.so\nlibc++.so\nlibcutils.so\nlibext2_uuid.so\nliblog.so\nlibm.so\nlibpcre.so\nlibselinux.so \n\n```", "```kt\n$ readelf -d $OUT/recovery/root/sbin/v86d\n\nDynamic section at offset 0x3e68 contains 29 entries:\n Tag        Type                         Name/Value\n 0x00000003 (PLTGOT)                     0x4f7c\n0x00000002 (PLTRELSZ)                   240 (bytes)\n0x00000017 (JMPREL)                     0x5b0\n0x00000014 (PLTREL)                     REL\n0x00000011 (REL)                        0x5a8\n0x00000012 (RELSZ)                      8 (bytes)\n0x00000013 (RELENT)                     8 (bytes)\n0x00000015 (DEBUG)                      0x0\n0x00000006 (SYMTAB)                     0x1a0\n0x0000000b (SYMENT)                     16 (bytes)\n0x00000005 (STRTAB)                     0x3d0\n0x0000000a (STRSZ)                      324 (bytes)\n0x6ffffef5 (GNU_HASH)                   0x514\n0x00000001 (NEEDED)                     Shared library: [libc++.so]\n0x00000001 (NEEDED)                     Shared library: [libdl.so]\n0x00000001 (NEEDED)                     Shared library: [libc.so]\n0x00000001 (NEEDED)                     Shared library: [libm.so]\n0x00000020 (PREINIT_ARRAY)              0x4e50\n0x00000021 (PREINIT_ARRAYSZ)            0x8\n0x00000019 (INIT_ARRAY)                 0x4e58\n0x0000001b (INIT_ARRAYSZ)               8 (bytes)\n0x0000001a (FINI_ARRAY)                 0x4e60\n0x0000001c (FINI_ARRAYSZ)               8 (bytes)\n0x0000001e (FLAGS)                      BIND_NOW\n0x6ffffffb (FLAGS_1)                    Flags: NOW\n0x6ffffff0 (VERSYM)                     0x540\n0x6ffffffe (VERNEED)                    0x588\n0x6fffffff (VERNEEDNUM)                 1\n0x00000000 (NULL)                       0x0 \n\n```", "```kt\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<manifest> \n\n  <remote  name=\"github\" \n           revision=\"refs/tags/android-7.1.1_r4_x86vbox_ch13_r1\" \n           fetch=\".\" /> \n\n  <remote  name=\"aosp\" \n           fetch=\"https://android.googlesource.com/\" /> \n  <default revision=\"refs/tags/android-7.1.1_r4\" \n           remote=\"aosp\" \n           sync-c=\"true\" \n           sync-j=\"1\" /> \n\n  <!-- github/android-7.1.1_r4_ch13 --> \n  <project path=\"kernel\" name=\"goldfish\" remote=\"github\" /> \n  <project path=\"bootable/newinstaller\"  \n  name=\"platform_bootable_newinstaller\" remote=\"github\" /> \n  <project path=\"device/generic/common\" name=\"device_generic_common\"  \n  groups=\"pdk\" remote=\"github\" /> \n  <project path=\"device/generic/x86vbox\" name=\"x86vbox\" remote=\"github\" \n  /> \n  <project path=\"bootable/recovery\" name=\"android_bootable_recovery\" \n  remote=\"github\" groups=\"pdk\" /> \n...  \n\n```", "```kt\n$ repo init -u https://github.com/shugaoye/manifests -b android-7.1.1_r4_ch13_aosp\n$ repo sync  \n\n```", "```kt\n$ . build/envsetup.sh\n$ lunch x86vbox-eng\n$ make -j4  \n\n```", "```kt\n$ make initrd USE_SQUASHFS=0  \n\n```", "```kt\n$ mkdir -p dist_output\n$ make dist DIST_DIR=dist_output  \n\n```", "```kt\nlabel 3\\. Recovery - x86vbox\nmenu x86vbox_ramdisk_recovery\nkernel x86vbox/kernel\nappend ip=dhcp console=ttyS3,115200 initrd=x86vbox/ramdisk-recovery.img androidboot.hardware=x86vbox  \n\n```"]