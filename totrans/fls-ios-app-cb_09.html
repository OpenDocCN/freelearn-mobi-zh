<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Geolocation and Accelerometer APIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Geolocation and Accelerometer APIs</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Determining your current location</li><li class="listitem" style="list-style-type: disc">Determining your speed and heading</li><li class="listitem" style="list-style-type: disc">Checking for geolocation access</li><li class="listitem" style="list-style-type: disc">Responding to accelerometer changes</li><li class="listitem" style="list-style-type: disc">Detecting a shake</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec01"/>Introduction</h1></div></div></div><p>The iOS family makes use of many onboard sensors including the three-axis accelerometer, digital compass, camera, microphone, and global positioning system (GPS). Their inclusion has created a world of opportunity for developers, and has resulted in a slew of innovative, creative, and fun apps that have contributed to the overwhelming success of the App Store.<a id="id743" class="indexterm"/>
</p><p>This chapter will focus on two of the most popular sensors—the accelerometer and GPS; both of which are supported by AIR for iOS.</p><p>The accelerometer measures g-force, enabling the detection of physical orientation, motion, and vibration. While originally seen by many as a gimmick, its uses have become increasingly more sophisticated as the platform has evolved. From games to remote controls, paint packages to sound generation, the accelerometer has become the input method of choice for many apps.<a id="id744" class="indexterm"/>
</p><p>Devices such as the iPhone are also location-aware; its GPS receiver is able to determine its position anywhere in the world. Movement can be tracked, the current speed can be obtained, and even the direction the device is facing can be determined. In addition to mapping, location services are finding their way into all kinds of areas ranging from photography to messaging clients.</p><p>AIR provides APIs that allow access to both the accelerometer and location data collected by the device's sensors. Support for the accelerometer is provided by the<code class="literal"> flash.sensors.Accelerometer</code> class, while<code class="literal"> flash.sensors.Geolocation</code> is used when writing location-aware apps.<a id="id745" class="indexterm"/>
</p></div></div>
<div class="section" title="Determining your current location"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec02"/>Determining your current location</h1></div></div></div><p>The iOS family of devices are location-aware, allowing your approximate geographic position to be determined. How this is achieved depends on the hardware present in the device. For example, the original iPhone, all models of the iPod touch, and Wi-Fi-only iPads use Wi-Fi network triangulation to provide location information. The remaining devices can more accurately calculate their position using an on-board GPS chip or cell-phone tower triangulation.<a id="id746" class="indexterm"/>
</p><p>The AIR SDK provides a layer of abstraction that allows you to extract location information in a hardware-independent manner, meaning you can access the information on any iOS device using the same code.</p><p>This recipe will take you through the steps required to determine your current location.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec01"/>Getting ready</h2></div></div></div><p>An FLA has been provided as a starting point for this recipe.</p><p>From Flash Professional, open<code class="literal"> chapter9\recipe1\recipe.fla</code> from the book's accompanying code bundle.</p><p>You will find six dynamic text fields positioned on the stage. We will populate each of them with location data obtained from the device.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec02"/>How to do it...</h2></div></div></div><p>Perform the following steps to listen for and display geolocation data:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Import the following classes and add a member variable of type<code class="literal"> Geolocation:</code><div class="informalexample"><pre class="programlisting">package {
import flash.display.MovieClip;
<span class="strong"><strong>
import flash.events.GeolocationEvent;
import flash.sensors.Geolocation;
</strong></span>
public class Main extends MovieClip {
<span class="strong"><strong>
private var geo:Geolocation;
</strong></span>
public function Main() {
// constructor code
}
}
}
</pre></div></li><li class="listitem">Within the class' constructor, instantiate a<code class="literal"> Geolocation</code> object and listen for updates from it:<div class="informalexample"><pre class="programlisting">public function Main() {
if(Geolocation.isSupported)
{
geo = new Geolocation();
geo.setRequestedUpdateInterval(1000);
geo.addEventListener(GeolocationEvent.UPDATE, geoUpdated);
}
}
</pre></div></li><li class="listitem">Now, write an event handler that will obtain the updated geolocation data and populate the dynamic text fields with it:<a id="id747" class="indexterm"/><div class="informalexample"><pre class="programlisting">private function geoUpdated(e:GeolocationEvent):void {
latitudeField.text = e.latitude.toString();
longitudeField.text = e.longitude.toString();
altitudeField.text = e.altitude.toString();
hAccuracyField.text = e.horizontalAccuracy.toString();
vAccuracyField.text = e.verticalAccuracy.toString();
timestampField.text = e.timestamp.toString();
}
</pre></div></li><li class="listitem">Save the class file as<code class="literal"> Main.as</code> within the same folder as the FLA. Move back to the FLA and save it too.</li><li class="listitem">Publish and test the app on your device.</li><li class="listitem">When launched for the first time, a native iOS dialog will appear with the following prompt:<p><span class="strong"><strong>"c9 r1" Would Like to Use Your Current Location</strong></span>
</p><p>Tap the <span class="strong"><strong>OK </strong></span>button to grant your app access to the device's location data.
</p></li></ol></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip18"/>Tip</h3><p>Devices running iOS 4 or above will remember your choice, while devices running older versions of iOS will prompt you each time the app is launched.</p></div><p>The location data will be shown on screen and periodically updated. Take your device on the move and you will see changes in the data as your geographical location changes.<a id="id748" class="indexterm"/>
</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec03"/>How it works...</h2></div></div></div><p>AIR provides the<code class="literal"> Geolocation</code> class in the<code class="literal"> flash.sensors</code> package, allowing the location data to be retrieved from your device. To access the data, create a<code class="literal"> Geolocation</code> instance and listen for it dispatching<code class="literal"> GeolocationEvent.UPDATE</code> events.<a id="id749" class="indexterm"/>
</p><p>We did this within our document class' constructor, using the<code class="literal"> geo</code> member variable to hold a reference to the object:</p><div class="informalexample"><pre class="programlisting">geo = new Geolocation();
geo.setRequestedUpdateInterval(1000);
geo.addEventListener(GeolocationEvent.UPDATE, geoUpdated);
</pre></div><p>The frequency with which location data is retrieved can be set by calling the<code class="literal"> Geolocation.setRequestedUpdateInterval()</code> method. You can see this in the earlier code where we requested an update interval of 1000 milliseconds. This only acts as a hint to the device, meaning the actual time between updates may be greater or smaller than your request. Omitting this call will result in the device using a default update interval. The default interval can be anything ranging from milliseconds to seconds depending on the device's hardware capabilities.<a id="id750" class="indexterm"/>
</p><p>Each<code class="literal"> UPDATE</code> event dispatches a<code class="literal"> GeolocationEvent</code> object, which contains properties describing your current location. Our<code class="literal"> geoUpdated()</code> method handles this event by outputting several of the properties to the dynamic text fields sitting on the stage:<a id="id751" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">private function geoUpdated(e:GeolocationEvent):void {
latitudeField.text = e.latitude.toString();
longitudeField.text = e.longitude.toString();
altitudeField.text = e.altitude.toString();
hAccuracyField.text = e.horizontalAccuracy.toString();
vAccuracyField.text = e.verticalAccuracy.toString();
timestampField.text = e.timestamp.toString();
}
</pre></div><p>The following information was output:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Latitude and longitude</li><li class="listitem" style="list-style-type: disc">Altitude</li><li class="listitem" style="list-style-type: disc">Horizontal and vertical accuracy</li><li class="listitem" style="list-style-type: disc">Timestamp</li></ul></div><p>The latitude and longitude positions are used to identify your geographical location. Your altitude is also obtained and is measured in meters. As you move with the device, these values will update to reflect your new location.<a id="id752" class="indexterm"/>
</p><p>The accuracy of the location data is also shown and depends on the hardware capabilities of the device. Both the horizontal and vertical accuracy are measured in meters.</p><p>Finally, a timestamp is associated with every<code class="literal"> GeolocationEvent</code> object that is dispatched, allowing you to determine the actual time interval between each. The timestamp specifies the milliseconds that have passed since the app was launched.</p><p>Some older devices that do not include a GPS unit only dispatch<code class="literal"> UPDATE</code> events occasionally. Initially, one or two<code class="literal"> UPDATE</code> events are dispatched, with additional events only being dispatched when location information changes noticeably.</p><p>Also note the use of the static<code class="literal"> Geolocation.isSupported</code> property within the constructor. Although this will currently return<code class="literal"> true</code> for all iOS devices, it cannot be guaranteed for future devices. Checking for geolocation support is also advisable when writing cross-platform code.<a id="id753" class="indexterm"/>
</p><p>For more information, perform a search for<code class="literal"> flash.sensors.Geolocation</code> and<code class="literal"> flash.events.GeolocationEvent</code> within Adobe Community Help.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec04"/>There's more...</h2></div></div></div><p>The amount of information made available and the accuracy of that information depends on the capabilities of the device.</p><div class="section" title="Accuracy"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec01"/>Accuracy</h3></div></div></div><p>The accuracy of the location data depends on the method employed by the device to calculate your position. Typically, iOS devices with an on-board GPS chip will have a benefit over those that rely on Wi-Fi triangulation.<a id="id754" class="indexterm"/>
</p><p>For example, running this recipe's app on an iPhone 4, which contains a GPS unit, results in a horizontal accuracy of around 10 meters. The same app running on a third-generation iPod touch and relying on a Wi-Fi network, reports a horizontal accuracy of around 100 meters. Quite a difference!<a id="id755" class="indexterm"/>
</p></div><div class="section" title="Altitude support"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec02"/>Altitude support</h3></div></div></div><p>The current altitude can only be obtained from GPS-enabled devices. On devices without a GPS unit, the<code class="literal"> GeolocationEvent.verticalAccuracy</code> property will return<code class="literal"> -1</code> and<code class="literal"> GeolocationEvent.altitude</code> will return<code class="literal"> 0</code>. A vertical accuracy of<code class="literal"> -1</code> indicates that altitude cannot be detected.<a id="id756" class="indexterm"/>
</p><p>You should be aware of, and code for these restrictions when developing apps that provide location-based services. Do not make assumptions about a device's capabilities.</p><p>If your application relies on the presence of GPS hardware, then it is possible to state this within your application descriptor file. Doing so will prevent users without the necessary hardware from downloading your app from the App Store.</p><p>For more information, take a look at the<span class="emphasis"><em> Declaring device capabilities</em></span> recipe from<a class="link" href="ch13.html" title="Chapter 13. Connectivity, Persistence, and URI Schemes"> Chapter 13</a>.</p></div><div class="section" title="Mapping your location"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec03"/>Mapping your location</h3></div></div></div><p>The most obvious use for the retrieval of geolocation data is mapping. Typically, an app will obtain a geographic location and display a map of its surrounding area. There are several ways to achieve this, but launching and passing location data to the device's native maps application is possibly the easiest solution. Take a look at<span class="emphasis"><em> Launching the Maps application</em></span> from<a class="link" href="ch13.html" title="Chapter 13. Connectivity, Persistence, and URI Schemes"> Chapter 13</a> to see how this is done.<a id="id757" class="indexterm"/>
</p><p>If you would prefer an ActionScript solution, then there is the UMap ActionScript 3.0 API, which integrates with map data from a wide range of providers including Bing, Google, and Yahoo!. You can sign up and download the API from<a class="ulink" href="http://www.umapper.com"> www.umapper.com</a>. Also tutorials are available at<a class="ulink" href="http://www.afcomponents.com/tutorials/umap_as3"> www.afcomponents.com/tutorials/umap_as3</a>.</p></div><div class="section" title="Calculating distance between geolocations"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec04"/>Calculating distance between geolocations</h3></div></div></div><p>When the geographic coordinates of two separate locations are known, it is possible to determine the distance between them. AIR does not provide an API for this but an AS3 solution can be found on the Adobe Developer Connection website at:<a class="ulink" href="http://cookbooks.adobe.com/index.cfm?event=showdetails&amp;postId=5701"> http://cookbooks.adobe.com/index.cfm?event=showdetails&amp;postId=5701</a>.<a id="id758" class="indexterm"/>
</p><p>The UMap ActionScript 3.0 API can also be used to calculate distances. Refer to<a class="ulink" href="http://www.umapper.com"> www.umapper.com</a>.<a id="id759" class="indexterm"/>
</p></div><div class="section" title="Geocoding"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec05"/>Geocoding</h3></div></div></div><p>Mapping providers, such as Google and Yahoo!, provide geocoding and reverse-geocoding web services. Geocoding is the process of finding the latitude and longitude of an address, whereas reverse-geocoding converts a latitude-longitude pair into a readable address.<a id="id760" class="indexterm"/>
</p><p>You can make HTTP requests from your AIR for iOS application to any of these services. As an example, take a look at the Yahoo! PlaceFinder web service at<a class="ulink" href="http://developer.yahoo.com/geo/placefinder"> http://developer.yahoo.com/geo/placefinder</a>.</p><p>Alternatively, the UMap ActionScript 3.0 API integrates with many of these services to provide geocoding functionality directly within your Flash projects. Refer to the uMapper website.</p></div><div class="section" title="Gyroscope support"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec06"/>Gyroscope support</h3></div></div></div><p>Another popular sensor is the gyroscope, which is found in more recent iOS devices. While the AIR SDK does not directly support gyroscope access, Adobe has made available a native extension for AIR 3.0, which provides a<code class="literal"> Gyroscope</code> ActionScript class.<a id="id761" class="indexterm"/>
</p><p>A download link and usage examples can be found on the Adobe Developer Connection site at<a class="ulink" href="http://www.adobe.com/devnet/air/native-extensions-for-air/extensions/gyroscope.html"> www.adobe.com/devnet/air/native-extensions-for-air/extensions/gyroscope.html</a>.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec05"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Determining your speed and heading</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Launching the Maps application, <a class="link" href="ch13.html" title="Chapter 13. Connectivity, Persistence, and URI Schemes">Chapter 13</a></em></span></li></ul></div></div></div>
<div class="section" title="Determining your speed and heading"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec03"/>Determining your speed and heading</h1></div></div></div><p>The availability of an on-board GPS unit makes it possible to determine your speed and heading. In this recipe, we will write a simple app that uses the<code class="literal"> Geolocation</code> class to obtain and use this information. In addition, we will add compass functionality by utilizing the user's current heading.<a id="id762" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec06"/>Getting ready</h2></div></div></div><p>You will need a GPS-enabled iOS device. The iPhone has featured an on-board GPS unit since the release of the 3G. GPS hardware can also be found in all cellular network-enabled iPads.<a id="id763" class="indexterm"/>
</p><p>From Flash Professional, open<code class="literal"> chapter9\recipe2\recipe.fla</code> from the book's accompanying code bundle.</p><p>Sitting on the stage are three dynamic text fields. The first two <code class="literal">(speed1Field</code> and<code class="literal"> speed2Field)</code> will be used to display the current speed in meters per second and miles per hour respectively. We will write the device's current heading into the third<code class="literal">—headingField.</code></p><p>Also, a movie clip named<code class="literal"> compass</code> has been positioned near the bottom of the stage and represents a compass with north, south, east, and west clearly marked on it. We will update the rotation of this clip in response to heading changes to ensure that it always points towards true north.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec07"/>How to do it...</h2></div></div></div><p>To obtain the device's speed and heading, carry out the following steps:<a id="id764" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the necessary import statements, a constant, and a member variable of type<code class="literal"> Geolocation:</code><div class="informalexample"><pre class="programlisting">package {
import flash.display.MovieClip;
<span class="strong"><strong>
import flash.events.GeolocationEvent;
import flash.sensors.Geolocation;
</strong></span>
public class Main extends MovieClip {
<span class="strong"><strong>
private const CONVERSION_FACTOR:Number = 2.237;
private var geo:Geolocation;
</strong></span>
public function Main() {
// constructor code
}
}
}
</pre></div></li><li class="listitem">Within the constructor, instantiate a<code class="literal"> Geolocation</code> object and listen for updates:<div class="informalexample"><pre class="programlisting">public function Main() {
<span class="strong"><strong>
if(Geolocation.isSupported)
{
geo = new Geolocation();
geo.setRequestedUpdateInterval(50);
geo.addEventListener(GeolocationEvent.UPDATE, geoUpdated);
}
</strong></span>
}
</pre></div></li><li class="listitem">We will need an event listener for the<code class="literal"> Geolocation</code> object's<code class="literal"> UPDATE</code> event. This is where we will obtain and display the current speed and heading, and also update the<code class="literal"> compass</code> movie clip to ensure it points towards true north. Add the following method:<a id="id765" class="indexterm"/><div class="informalexample"><pre class="programlisting">private function geoUpdated(e:GeolocationEvent):void {
var metersPerSecond:Number = e.speed;
var milesPerHour:uint = getMilesPerHour(metersPerSecond);
speed1Field.text = String(metersPerSecond);
speed2Field.text = String(milesPerHour);
var heading:Number = e.heading;
compass.rotation = 360 - heading;
headingField.text = String(heading);
}
</pre></div></li><li class="listitem">Finally, add this support method to convert meters per second to miles per hour:<div class="informalexample"><pre class="programlisting">private function getMilesPerHour(metersPerSecond:Number):uint
{
return metersPerSecond * CONVERSION_FACTOR;
}

</pre></div></li><li class="listitem">Save the class file as<code class="literal"> Main.as</code>. Move back to the FLA and save it too.</li><li class="listitem">Compile the FLA and deploy the IPA to your device.</li><li class="listitem">Launch the app. When prompted, grant your app access to the GPS unit.</li></ol></div><p>Hold the device in front of you and start turning on the spot. The<span class="strong"><strong> heading (degrees)</strong></span> field will update to show the direction you are facing. The<code class="literal"> compass</code> movie clip will also update, showing you where true north is in relation to your current heading.</p><p>Take your device outside and start walking, or better still, start running. On average every 50 milliseconds you will see the top two text fields update and show your current speed, measured in both meters per second and miles per hour.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec08"/>How it works...</h2></div></div></div><p>In this recipe, we created a<code class="literal"> Geolocation</code> object and listened for it dispatching<code class="literal"> UPDATE</code> events. An update interval of 50 milliseconds was specified in an attempt to receive the speed and heading information frequently.<a id="id766" class="indexterm"/>
</p><p>Both the speed and heading information are obtained from the<code class="literal"> GeolocationEvent</code> object, which is dispatched on each<code class="literal"> UPDATE</code> event. The event is captured and handled by our<code class="literal"> geoUpdated()</code> handler, which displays the speed and heading information from the accelerometer.<a id="id767" class="indexterm"/>
</p><p>The current speed is measured in meters per second and is obtained by querying the<code class="literal"> GeolocationEvent.speed</code> property. Our handler also converts the speed to miles per hour before displaying each value within the appropriate text field. The following code does this:<a id="id768" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var metersPerSecond:Number = e.speed;
var milesPerHour:uint = getMilesPerHour(metersPerSecond);
speed1Field.text = String(metersPerSecond);
speed2Field.text = String(milesPerHour);
</pre></div><p>The heading, which represents the direction of movement (with respect to true north) in degrees, is retrieved from the<code class="literal"> GeolocationEvent.heading</code> property. The value is used to set the<code class="literal"> rotation</code> property of the<code class="literal"> compass</code> movie clip and is also written to the<code class="literal"> headingField</code> text field:<a id="id769" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var heading:Number = e.heading;
compass.rotation = 360 - heading;
headingField.text = String(heading);
</pre></div><p>The remaining method is<code class="literal"> getMilesPerHour()</code> and is used within<code class="literal"> geoUpdated()</code> to convert the current speed from meters per second into miles per hour. Notice the use of the<code class="literal"> CONVERSION_FACTOR</code> constant that was declared within your document class:</p><div class="informalexample"><pre class="programlisting">private function getMilesPerHour(metersPerSecond:Number):uint
{
return metersPerSecond * CONVERSION_FACTOR;
}
</pre></div><p>Although the speed and heading obtained from the GPS unit will suffice for most applications, the accuracy can vary across devices. Your surroundings can also have an affect; moving through streets with tall buildings or under tree coverage can impair the readings.</p><p>You can find more information regarding<code class="literal"> flash.sensors.Geolocation</code> and<code class="literal"> flash.events.GeolocationEvent</code> within Adobe Community Help.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec09"/>There's more...</h2></div></div></div><p>The following information provides some additional detail.<a id="id770" class="indexterm"/>
</p><div class="section" title="Determining support"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec07"/>Determining support</h3></div></div></div><p>Your current speed and heading can only be determined by devices that possess a GPS receiver.<a id="id771" class="indexterm"/>
</p><p>Although you can install this recipe's app on any iOS device, you won't receive valid readings from any model of iPod touch, the original iPhone, or W-Fi-only iPads. Instead the<code class="literal"> GeolocationEvent.speed</code> property will return<code class="literal"> -1</code> and<code class="literal"> GeolocationEvent.heading</code> will return<code class="literal"> NaN</code>.<a id="id772" class="indexterm"/>
</p><p>If your application relies on the presence of GPS hardware, then it is possible to state this within the application descriptor file. Doing so will prevent users without the necessary hardware from downloading your app from the App Store.</p><p>For more information, take a look at the<span class="emphasis"><em> Declaring device capabilities</em></span> recipe from<a class="link" href="ch13.html" title="Chapter 13. Connectivity, Persistence, and URI Schemes"> Chapter 13</a>.</p></div><div class="section" title="Simulating the GPS receiver"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec08"/>Simulating the GPS receiver</h3></div></div></div><p>During the development lifecycle it is not feasible to continually test your app in a live environment. Instead you will probably want to record live data from your device and re-use it during testing. There are various apps available that will log data from the sensors on your device.<a id="id773" class="indexterm"/>
</p><p>One such app is xSensor, which can be downloaded from iTunes or the App Store and is free. Its data sensor log is limited to 5KB but this restriction can be lifted by purchasing xSensor Pro.</p></div><div class="section" title="Preventing screen idle"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec09"/>Preventing screen idle</h3></div></div></div><p>Many of this chapter's apps don't require you to touch the screen that often. Therefore you will be likely to experience the backlight dimming or the screen locking while testing them. This can be inconvenient and can be prevented by disabling screen locking. For more details, see the<span class="emphasis"><em> Preventing screen idle</em></span> recipe in<a class="link" href="ch03.html" title="Chapter 3. Writing your First App"> Chapter 3</a>.<a id="id774" class="indexterm"/>
</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec10"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Determining your current location</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Checking for geolocation access</em></span></li></ul></div></div></div>
<div class="section" title="Checking for geolocation access"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec04"/>Checking for geolocation access</h1></div></div></div><p>Applications that make use of a device's location data must be granted permission by the user. The user is prompted when an app attempts to access location data for the first time. Devices running iOS 4 or above will remember this choice, whereas older versions of iOS will request access each time the app is launched. In addition, access privileges can be changed at any time from the device's settings.<a id="id775" class="indexterm"/>
</p><p>It is important that your app can detect the availability of geolocation data, and also respond to permission changes at runtime. Let us see how this is done.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec11"/>Getting ready</h2></div></div></div><p>An FLA has been provided as a starting point.<a id="id776" class="indexterm"/>
</p><p>From the book's accompanying code bundle, open<code class="literal"> chapter9\recipe3\recipe.fla</code> into Flash Professional.</p><p>A dynamic text field with an instance name of<code class="literal"> output</code> has been added to the stage.</p><p>We will write an app that listens for the availability of the geolocation data and reports any changes to the<code class="literal"> output</code> text field.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec12"/>How to do it...</h2></div></div></div><p>Carry out the following steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following import statements and a member variable of type<code class="literal"> Geolocation:</code><div class="informalexample"><pre class="programlisting">package {
import flash.display.MovieClip;
<span class="strong"><strong>
import flash.events.GeolocationEvent;
import flash.events.StatusEvent;
import flash.sensors.Geolocation;
</strong></span>
public class Main extends MovieClip {
<span class="strong"><strong>private var geo:Geolocation;
</strong></span>
public function Main() {
// constructor code
}
}
}
</pre></div></li><li class="listitem">Within the constructor, create a<code class="literal"> Geolocation</code> object and listen for it dispatching<code class="literal"> GeolocationEvent.UPDATE</code> and<code class="literal"> StatusEvent.STATUS:</code><a id="id777" class="indexterm"/><div class="informalexample"><pre class="programlisting">public function Main() {
<span class="strong"><strong>
output.text = "Obtaining location...";
if(Geolocation.isSupported)
{
geo = new Geolocation();
geo.setRequestedUpdateInterval(1000);
geo.addEventListener(GeolocationEvent.UPDATE, geoUpdated);
geo.addEventListener(StatusEvent.STATUS, statusUpdated);
}
else
{
output.text = "Geolocation is not supported.";
}
</strong></span>
}
</pre></div></li><li class="listitem">Finally, add a handler for each event:<div class="informalexample"><pre class="programlisting">private function geoUpdated(e:GeolocationEvent):void {
output.text = "Location received.";
}
private function statusUpdated(e:StatusEvent):void {
if(e.code == "Geolocation.Muted")
{
output.text = "Geolocation access denied.";
}
}
</pre></div></li><li class="listitem">Save the class file as<code class="literal"> Main.as</code>.</li><li class="listitem">Save the FLA and publish it. Install the IPA and launch it on your device.<p>A native iOS dialog will appear with the following prompt:
</p><p><span class="strong"><strong>"c9 r3" Would Like to Use Your Current Location
</strong></span>
</p></li><li class="listitem">Tap the<span class="strong"><strong> Don't Allow</strong></span> button to deny the app access to the device's location data.<p>The following text will appear on-screen:
</p><p><span class="strong"><strong>Obtaining location...
</strong></span>	
</p><p>And will quickly be replaced with:
</p><p><span class="strong"><strong>Geolocation access denied.
</strong></span>
</p></li><li class="listitem">Now re-launch the app. If you are using iOS 4 or above, your previous setting will be remembered and access to the geolocation data will once again be denied. If you are using an earlier version of iOS, then you will be prompted to grant access each time.<a id="id778" class="indexterm"/><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip19"/>Tip</h3><p>To re-launch an app in iOS 4 or above, you will first need to kill it using the fast app switcher. Refer to the<span class="emphasis"><em> Exiting gracefully from an app</em></span> recipe in<a class="link" href="ch03.html" title="Chapter 3. Writing your First App"> Chapter 3</a>, for details on how to do this.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">On devices running iOS 4 or above, an app's access privileges can be changed from the device's settings. Let us do this for our app.</li></ul></div></li><li class="listitem">Exit from the app by pressing the Home button. From the device's settings, move to<span class="strong"><strong> Location Services</strong></span>. You will be presented with a list of apps that have attempted to access location data. Scroll down until you find<span class="strong"><strong> c9 r3</strong></span>. Tap the button next to it to allow access to it.<div class="mediaobject"><img src="graphics/1383_09_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Now move back to the home screen and launch this recipe's app again.<a id="id779" class="indexterm"/><p>This time you will see the following text:
</p><p><span class="strong"><strong>Obtaining location...
</strong></span>
</p><p>And it will quickly be replaced with:
</p><p><span class="strong"><strong>Location received.
</strong></span>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec13"/>How it works...</h2></div></div></div><p>When the user prevents an AIR for iOS app from accessing location data,<code class="literal"> GeolocationEvent.UPDATE</code> events cease and<code class="literal"> StatusEvent.STATUS</code> is dispatched from the<code class="literal"> Geolocation</code> object. It is therefore possible to determine when access to location data has been revoked by simply listening for the<code class="literal"> STATUS</code> event:<a id="id780" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">geo = new Geolocation();
geo.setRequestedUpdateInterval(1000);
geo.addEventListener(GeolocationEvent.UPDATE, geoUpdated);
geo.addEventListener(StatusEvent.STATUS, statusUpdated);
</pre></div><p>A final check is performed within the<code class="literal"> statusUpdated()</code> handler:<a id="id781" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">private function statusUpdated(e:StatusEvent):void {
if(e.code == "Geolocation.Muted")
{
output.text = "Geolocation access denied.";
}
}
</pre></div><p>In this method, we query the<code class="literal"> StatusEvent</code> object's<code class="literal"> code</code> property. If it has a string value of<code class="literal"> Geolocation.Muted</code>, then we know that access to the geolocation data is no longer available.<a id="id782" class="indexterm"/>
</p><p>Finally, although it wasn't used in this recipe's example, you can also access the<code class="literal"> Geolocation.muted</code> property to determine if geolocation data is available. When a newly installed app is launched for the first time,<code class="literal"> muted</code> will be set to<code class="literal"> true</code> until the user grants permission from the native iOS dialog.<a id="id783" class="indexterm"/>
</p><p>More information regarding<code class="literal"> flash.events.StatusEvent</code> can be found in Adobe Community Help.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec14"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Determining your current location</em></span></li></ul></div></div></div>
<div class="section" title="Responding to accelerometer changes"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec05"/>Responding to accelerometer changes</h1></div></div></div><p>The accelerometer provides access to data that represents the device's location or movement along a three-dimensional axis. When motion is detected, it is returned as data, which can be accessed by ActionScript.<a id="id784" class="indexterm"/>
</p><p>This recipe will show you how to take advantage of the accelerometer found in iOS devices.<a id="id785" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec15"/>Getting ready</h2></div></div></div><p>An FLA has been provided as a starting point.</p><p>Open<code class="literal"> chapter9\recipe4\recipe.fla</code> from the book's accompanying code bundle into Flash Professional.</p><p>You will find five dynamic text fields positioned on the stage. Below them is a movie clip with an instance name of<code class="literal"> arrow</code>. We will populate each text field with data retrieved from the device's accelerometer and rotate the movie clip to reflect physical changes in the device's orientation.</p><p>Also notice the stage's dimensions are set to 480x320. For this recipe, landscape orientation will be used.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec16"/>How to do it...</h2></div></div></div><p>Perform these steps to listen for and respond to accelerometer changes:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following two import statements and a member variable of type<code class="literal"> Accelerometer:</code><div class="informalexample"><pre class="programlisting">package {
import flash.display.MovieClip;
<span class="strong"><strong>
import flash.events.AccelerometerEvent;
import flash.sensors.Accelerometer;
</strong></span>
public class Main extends MovieClip {
<span class="strong"><strong>private var acc:Accelerometer;
</strong></span>
public function Main() {
// constructor code
}
}
}
</pre></div></li><li class="listitem">Within the constructor, instantiate an<code class="literal"> Accelerometer</code> object and listen for updates from it:<div class="informalexample"><pre class="programlisting">public function Main() {
<span class="strong"><strong>
if(Accelerometer.isSupported)
{
acc = new Accelerometer();
acc.setRequestedUpdateInterval(50);
acc.addEventListener(AccelerometerEvent.UPDATE, accUpdated);
}
</strong></span>
}
</pre></div></li><li class="listitem">Finish by writing an event handler that will obtain and use the updated accelerometer data:<a id="id786" class="indexterm"/><div class="informalexample"><pre class="programlisting">private function accUpdated(e:AccelerometerEvent):void {
var radians:Number = Math.atan2(e.accelerationY, e.accelerationX);
var degrees:Number = (radians * (180 / Math.PI)) - 90;
arrow.rotation = -degrees;
accXField.text = e.accelerationX.toString();
accYField.text = e.accelerationY.toString();
accZField.text = e.accelerationZ.toString();
timeField.text = e.timestamp.toString();
rotField.text = degrees.toString();
}
</pre></div></li><li class="listitem">Save the class file as<code class="literal"> Main.as</code>.</li><li class="listitem">Also, save your FLA and then publish it. Install the app to your device and launch it.</li></ol></div><p>As the device's motion sensor detects activity, the text fields will update. Holding the device in front of yourself and tilting it clockwise and counter-clockwise will update the rotation of the<code class="literal"> arrow</code> movie clip, ensuring that it always points upwards.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec17"/>How it works...</h2></div></div></div><p>We accessed the accelerometer's data by creating an instance of the<code class="literal"> Accelerometer</code> class and listening for it dispatching the<code class="literal"> AccelerometerEvent.UPDATE</code> event:<a id="id787" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">acc = new Accelerometer();
acc.setRequestedUpdateInterval(50);
acc.addEventListener(AccelerometerEvent.UPDATE, accUpdated);
</pre></div><p>The frequency with which<code class="literal"> UPDATE</code> events are received can be set by calling the<code class="literal"> Accelerometer.setRequestedUpdateInterval()</code> method. You can see this in the earlier code where we requested an update every 50 milliseconds. This only acts as a hint to the device, meaning the actual time between updates may be greater or smaller than your request. Omitting this call will result in the device using a default update interval. The default interval can be anything ranging from milliseconds to seconds depending on the device's hardware capabilities.<a id="id788" class="indexterm"/>
</p><p>The<code class="literal"> UPDATE</code> event is an<code class="literal"> AccelerometerEvent</code> object and provides access to the following properties:<a id="id789" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationX</code> —Acceleration along the x-axis. When the device is upright, the x-axis runs from left to right. Acceleration is positive if the device is moved to the right.<a id="id790" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationY</code>—Acceleration along the y-axis. When the device is upright, the y-axis runs from bottom to top. Acceleration is positive if the device is moved upwards.<a id="id791" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationZ</code>—Acceleration along the z-axis. The acceleration is positive if the device is moved so that its face points upwards. Acceleration is negative if it faces towards the ground.<a id="id792" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">timestamp</code> —The number of milliseconds that have elapsed since the app was launched.<a id="id793" class="indexterm"/></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip20"/>Tip</h3><p>Acceleration is measured in "g" with 1g being the standard acceleration due to gravity, which is approximately 9.8 meters per second squared.</p></div><p>We obtain these properties within the<code class="literal"> accUpdated()</code> handler and write them to our dynamic text fields:<a id="id794" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">accXField.text = e.accelerationX.toString();
accYField.text = e.accelerationY.toString();
accZField.text = e.accelerationZ.toString();
timeField.text = e.timestamp.toString();
</pre></div><p>Additionally, the<code class="literal"> accelerometerX</code> and<code class="literal"> accelerometerY</code> properties are used to calculate the angle at which the device is being held (with the screen facing you). This is used to update the rotation of the<code class="literal"> arrow</code> movie clip. The following is the code that does this:</p><div class="informalexample"><pre class="programlisting">var radians:Number = Math.atan2(e.accelerationY, e.accelerationX);
var degrees:Number = (radians * (180 / Math.PI)) - 90;
arrow.rotation = -degrees;
</pre></div><p>Knowing the angle, at which the device is being tilted, is useful for many applications. In particular games, where tilting the device may be used to move a character along a platform or simulate the movement of a steering wheel.</p><p>Finally, within the constructor, note the use of the static read-only property<code class="literal"> Accelerometer.isSupported</code> to check for the availability of an accelerometer. The accelerometer is supported on all existing iOS devices but isn't guaranteed for future devices. It is therefore a good practice to check for support and is also beneficial when writing cross-platform code.<a id="id795" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec18"/>There's more...</h2></div></div></div><p>The following is some more information regarding the accelerometer and how to work with its data.</p><div class="section" title="Orientation and the accelerometer axes"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec10"/>Orientation and the accelerometer axes</h3></div></div></div><p>The accelerometer axes are re-oriented with the device's display rather than the physical orientation of the device itself. In other words, when auto-orientation is active, the y-axis will be vertical when the display's content is being viewed in a normal up-right position. This is true for both apps that default to a portrait aspect-ratio and apps that default to a landscape aspect-ratio. If however, auto-orientation is not active, then the accelerometer axes will not be re-oriented when the device is rotated.<a id="id796" class="indexterm"/>
</p></div><div class="section" title="Determining device orientation"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec11"/>Determining device orientation</h3></div></div></div><p>Data from the accelerometer is affected by gravity and can be useful to determine the device's current orientation. The following are the values to check for:<a id="id797" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationX</code>&gt; 0.5—Rotated 90 degrees counter clockwise</li><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationX</code>&lt; -0.5—Rotated 90 degrees clockwise</li><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationY</code>&gt; 0.5—Normal upright position</li><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationY</code>&lt; -0.5—Upside down</li><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationZ</code>&gt; 0.5—Face up</li><li class="listitem" style="list-style-type: disc"><code class="literal">accelerationZ</code>&lt; -0.5—Face down</li></ul></div><p>This provides an alternative to determining orientation by listening for<code class="literal"> StageOrientationEvent</code> objects being dispatched from the stage. In addition, using the acceleration data makes it possible to determine whether the device's screen display is facing upwards or towards the ground.</p></div><div class="section" title="Applying a low-pass filter"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec12"/>Applying a low-pass filter</h3></div></div></div><p>Data from the accelerometer is affected by both the effect of gravity and sudden changes in motion. If you are using this data to detect the device's orientation, then you should isolate the gravity component from the data by applying a low-pass filter.<a id="id798" class="indexterm"/>
</p><p>This can be achieved by smoothing out the data over time. To do this, start by creating a filtering factor and three member variables to store the previous value for each axis:</p><div class="informalexample"><pre class="programlisting">private const FACTOR:Number = 0.1;
private var accX:Number = 0;
private var accY:Number = 0;
private var accZ:Number = 0;
</pre></div><p>Now in response to each<code class="literal"> AccelerometerEvent.UPDATE</code>, apply a low-pass filter to keep only the gravity component from each axis:</p><div class="informalexample"><pre class="programlisting">accX = (e.accelerationX * FACTOR) + (accX * (1 - FACTOR));
accY = (e.accelerationY * FACTOR) + (accY * (1 - FACTOR));
accZ = (e.accelerationZ * FACTOR) + (accZ * (1 - FACTOR));
</pre></div><p>Essentially this code generates a value for each axis that uses 10 percent of its current data and 90 percent of the previously filtered data. This will ensure that data responds slowly to sudden and short-lived changes in motion.</p></div><div class="section" title="Applying a high-pass filter"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec13"/>Applying a high-pass filter</h3></div></div></div><p>Many types of applications use accelerometer data to detect sudden changes in motion. A high-pass filter can be used to isolate the portion of the data that is caused by sudden changes in motion.<a id="id799" class="indexterm"/>
</p><p>Similar to the implementation of a low-pass filter, use a filtering factor plus three member variables to store the previous value for each axis. Then in response to each<code class="literal"> AccelerometerEvent.UPDATE</code>, apply the filter:</p><div class="informalexample"><pre class="programlisting">accX = e.accelerationX - ((e.accelerationX * FACTOR) + (accX * (1 - FACTOR)));
accY = e.accelerationY - ((e.accelerationY * FACTOR) + (accY * (1 - FACTOR)));
accZ = e.accelerationZ - ((e.accelerationZ * FACTOR) + (accZ * (1 - FACTOR)));
</pre></div><p>In this example, a low-pass filter value is calculated for each axis and subtracted from the current value. Doing so keeps the sudden changes in motion while removing the gravity component.<a id="id800" class="indexterm"/>
</p></div><div class="section" title="The &quot;muted&quot; property"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec14"/>The "muted" property</h3></div></div></div><p>The<code class="literal"> Accelerometer</code> class has a static read-only property named<code class="literal"> muted.</code> It is used to determine if a user has granted the app permission to access accelerometer data. This property isn't required for iOS as there is no way, at present, to deny an app access to the accelerometer.<a id="id801" class="indexterm"/>
</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec19"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Setting the default aspect ratio, <a class="link" href="ch08.html" title="Chapter 8. Screen Resolution and Orientation Changes">Chapter 8</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Enabling auto-orientation, <a class="link" href="ch08.html" title="Chapter 8. Screen Resolution and Orientation Changes">Chapter 8</a></em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Responding to orientation changes, <a class="link" href="ch08.html" title="Chapter 8. Screen Resolution and Orientation Changes">Chapter 8</a></em></span></li></ul></div></div></div>
<div class="section" title="Detecting a shake"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec06"/>Detecting a shake</h1></div></div></div><p>A common use of the accelerometer is to detect a shake and this has become a popular method of interaction in games and applications. For example, many of the apps that come with iOS allow the user to perform an undo by shaking the device.<a id="id802" class="indexterm"/>
</p><p>This recipe will show you how to determine if the user is shaking their device by examining the data coming from the accelerometer.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec20"/>Getting ready</h2></div></div></div><p>From the book's accompanying code bundle, open<code class="literal"> chapter9\recipe5\recipe.fla</code> into Flash Professional.<a id="id803" class="indexterm"/>
</p><p>You will find a movie clip named<code class="literal"> shake</code> sitting in the center of the stage. Its timeline consists of two key-frames.</p><p>We will write some ActionScript that will move the clip in response to changes along the device's three axes. When the motion is pronounced, we will indicate to the user that a shake has been detected by jumping to the movie clip's second frame.</p><p>The stage uses a landscape aspect ratio for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec21"/>How to do it...</h2></div></div></div><p>Perform the following steps to detect a shake:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main.</code><a id="id804" class="indexterm"/></li><li class="listitem">Import the classes required to work with the accelerometer and add the following member variables:<div class="informalexample"><pre class="programlisting">package {
import flash.display.MovieClip;
<span class="strong"><strong>
import flash.events.AccelerometerEvent;
import flash.sensors.Accelerometer;
</strong></span>
public class Main extends MovieClip {
<span class="strong"><strong>
private const THRESHOLD:Number = 0.8;
private var acc:Accelerometer;
private var prevX:Number;
private var prevY:Number;
private var prevZ:Number;
private var startX:Number;
private var startY:Number;
</strong></span>
public function Main() {
// constructor code
}
}
}
</pre></div></li><li class="listitem">Initialize the member variables and the<code class="literal"> shake</code> movie clip. Also, instantiate an<code class="literal"> Accelerometer</code> object and listen for it dispatching<code class="literal"> UPDATE</code> events:<div class="informalexample"><pre class="programlisting">public function Main() {
<span class="strong"><strong>
prevX = prevY = prevZ = 0;
shake.gotoAndStop(1);
startX = shake.x;
startY = shake.y;
if(Accelerometer.isSupported)
{
acc = new Accelerometer();
acc.setRequestedUpdateInterval(50);
acc.addEventListener(AccelerometerEvent.UPDATE, accUpdated);
}
</strong></span>
}
</pre></div></li><li class="listitem">Add a handler for the<code class="literal"> UPDATE</code> event:<div class="informalexample"><pre class="programlisting">private function accUpdated(e:AccelerometerEvent):void {
var changeX:Number = prevX - e.accelerationX;
var changeY:Number = prevY - e.accelerationY;
var changeZ:Number = prevZ - e.accelerationZ;
prevX = e.accelerationX;
prevY = e.accelerationY;
prevZ = e.accelerationZ;
shake.x = startX + (changeX * 100);
shake.y = startY + (changeY * 100);
shake.z = (changeZ * 100);
if(Math.abs(changeX) &gt; THRESHOLD || Math.abs(changeY) &gt; THRESHOLD || Math.abs(changeZ) &gt; THRESHOLD)
{
shake.gotoAndStop(2);
}
else
{
shake.gotoAndStop(1);
}
}
</pre></div></li><li class="listitem">Save the class file and when prompted name it<code class="literal"> Main.as</code>.<a id="id805" class="indexterm"/></li><li class="listitem">Now save the FLA and publish it. Test the app on your device.</li></ol></div><p>Gently shaking the device will displace the movie clip from the center of the screen. A more violent motion will also change its appearance indicating that a sufficiently large shake has been detected.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec22"/>How it works...</h2></div></div></div><p>This example compares the current acceleration data with the previous to see if a sufficiently large change has occurred.<a id="id806" class="indexterm"/>
</p><p>The previous acceleration data is stored within the<code class="literal"> prevX, prevY</code>, and<code class="literal"> prevZ</code> member variables and is compared against the current data to determine the change for each axis:</p><div class="informalexample"><pre class="programlisting">var changeX:Number = prevX - e.accelerationX;
var changeY:Number = prevY - e.accelerationY;
var changeZ:Number = prevZ - e.accelerationZ;
prevX = e.accelerationX;
prevY = e.accelerationY;
prevZ = e.accelerationZ;
</pre></div><p>If the change in any one of the three axes is large enough, then it is safe to assume that the device is being shaken. This information is fed back to the user by moving to the second frame of the<code class="literal"> shake</code> movie clip. The following is the code that does this:<a id="id807" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">if(Math.abs(changeX) &gt; THRESHOLD || Math.abs(changeY) &gt; THRESHOLD || Math.abs(changeZ) &gt; THRESHOLD)
{
shake.gotoAndStop(2);
}
else
{
shake.gotoAndStop(1);
}
</pre></div><p>The<code class="literal"> THRESHOLD</code> constant simply dictates the amount of change that needs to take place in any of the axes for the motion to be deemed a shake. Lowering this value will reduce the effort required by the user to trigger a shake, while increasing it will make it more difficult.<a id="id808" class="indexterm"/>
</p><p>To provide greater visual feedback, we also update the<code class="literal"> x, y</code>, and<code class="literal"> z</code> positions of the<code class="literal"> shake</code> movie clip in response to changes from the accelerometer. The more violent the shaking motion, the more the clip is displaced from its original starting position:</p><div class="informalexample"><pre class="programlisting">shake.x = startX + (changeX * 100);
shake.y = startY + (changeY * 100);
shake.z = (changeZ * 100);
</pre></div><p>The<code class="literal"> startX</code> and<code class="literal"> startY</code> member variables used are initialized within the constructor and are set to the<code class="literal"> shake</code> movie clip's original position.<a id="id809" class="indexterm"/>
</p><p>The majority of the work in this example is performed within the<code class="literal"> accUpdated()</code> event handler, which is called each time<code class="literal"> AccelerometerEvent.UPDATE</code> is dispatched from the<code class="literal"> Accelerometer</code> object. To ensure the app is responsive, a call is made to the<code class="literal"> setRequestedUpdateInterval()</code> method requesting frequent updates.<a id="id810" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec23"/>There's more...</h2></div></div></div><p>Let us look at some options to further improve this recipe's example.</p><div class="section" title="Checking multiple axes"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec15"/>Checking multiple axes</h3></div></div></div><p>We checked for a large enough change in only one of the axes before deciding that the user was shaking the device. Another approach is to wait for a significant change in two of the three axes. The code for this would look as follows:<a id="id811" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var changeX:Number = Math.abs(e.accelerationX);
var changeY:Number = Math.abs(e.accelerationY);
var changeZ:Number = Math.abs(e.accelerationZ);
if((changeX &gt; THRESHOLD &amp;&amp; changeY &gt; THRESHOLD) || (changeX &gt; THRESHOLD &amp;&amp; changeZ &gt; THRESHOLD) || (changeY &gt; THRESHOLD &amp;&amp; changeZ &gt; THRESHOLD))
{
// Shake detected.
}
</pre></div><p>For multiple axes you may want to reduce the<code class="literal"> THRESHOLD</code> value slightly to compensate for the fact that the user must make a more exaggerated motion to initiate a shake.<a id="id812" class="indexterm"/>
</p></div><div class="section" title="Smoothing accelerometer data"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec16"/>Smoothing accelerometer data</h3></div></div></div><p>You may have noticed that even when holding the device still, the<code class="literal"> shake</code> movie clip shudders slightly. Accelerometers aren't perfectly accurate and the data returned will contain some noise.<a id="id813" class="indexterm"/>
</p><p>This noise can be reduced by applying a high-pass filter to your data over time and is detailed in the<span class="emphasis"><em> Responding to accelerometer changes</em></span> recipe. Try experimenting with the filtering factor and the threshold constant until you find values that give you a result you are happy with.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec24"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Responding to accelerometer changes</em></span></li></ul></div></div></div></body></html>