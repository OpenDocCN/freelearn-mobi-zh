<html><head></head><body>
		<div id="_idContainer052">
			<h1 id="_idParaDest-53"><em class="italic"><a id="_idTextAnchor094"/>Chapter 3</em>: Displaying Data from REST APIs with Retrofit</h1>
			<p>In this chapter, we'll be taking a break from the Jetpack libraries and focusing on adding real data within our Restaurants application by using a very popular networking<a id="_idIndexMarker178"/> library on Android called <strong class="bold">Retrofit</strong>.</p>
			<p>Retrofit is an HTTP client library that lets you create an HTTP client declaratively and abstracts most of the underlying complexity associated with handling network requests and responses. This library allows us to connect to a real web API and retrieve real data within our app.</p>
			<p>In the <em class="italic">Understanding how apps communicate with remote servers</em> section, we will focus on exploring how mobile applications retrieve and send data to remote web APIs. In the <em class="italic">Creating and populating your database with Firebase</em> section, we will create a database for our Restaurants application with the help of Firebase and fill it with JSON content.</p>
			<p>In the <em class="italic">Exploring Retrofit as an HTTP networking client for Android</em> section, we will learn what Retrofit is, and how it can help us create network requests within our Restaurants app.</p>
			<p>Lastly, in the <em class="italic">Improving the way our app handles network requests</em> section, we will tackle some common issues that occur when Android applications create async work to retrieve data from web APIs. We will identify those issues and fix them.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding how apps communicate with remote servers</li>
				<li>Creating and populating your database with Firebase</li>
				<li>Exploring Retrofit as an HTTP networking client for Android</li>
				<li>Improving the way our app handles network requests</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor095"/>Technical requirements</h1>
			<p>Building Compose-based Android projects with Retrofit usually requires just your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer installed in Android Studio.</li>
				<li>The Restaurants app code from the previous chapter.</li>
				<li>A Google account to create a Firebase project.</li>
			</ul>
			<p>The starting point for this chapter is the Restaurants application that we developed in the previous chapter. If you haven't followed the coding steps from the previous chapter, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_02</strong> directory of this book's GitHub repository and importing the Android project entitled <strong class="source-inline">chapter_2_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_03</strong> directory: </p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03</a>.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor096"/>Understanding how apps communicate with remote servers</h1>
			<p>Modern applications need to show real content<a id="_idIndexMarker179"/> that can change over time and need<a id="_idIndexMarker180"/> to avoid hardcoding data, as we did in the previous chapters. Let's briefly cover how they do that.</p>
			<p>Most network-connected apps use the HTTP protocol to send or receive data in the format of JSON from REST web services through a REST API. </p>
			<p>That's a lot of words we've just thrown at you, so let's break them down:</p>
			<ul>
				<li><strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) is a protocol for asynchronously fetching various resources<a id="_idIndexMarker181"/> from web servers. In our case, the resources are the data that our application needs to display.</li>
				<li><strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) is the data format of the content that's transferred in HTTP<a id="_idIndexMarker182"/> requests. It's structured, lightweight, and human-readable as it consists of key-value pairs that are easy to parse and commonly used as a suitable format for data exchange between apps and web servers. In our app, we will receive the data from the web server in such JSON format.</li>
				<li><strong class="bold">REST web services</strong> are those sources that contain the requested data<a id="_idIndexMarker183"/> and that conform to the <strong class="bold">representational state transfer</strong> (<strong class="bold">REST</strong>) architecture. REST means that the web server<a id="_idIndexMarker184"/> uses the HTTP protocol to communicate resources and that its resources are manipulated with the common HTTP methods: <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">DELETE</strong>, and so on.</li>
				<li>A <strong class="bold">REST API</strong> is an <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) that conforms to the constraints of the REST architecture<a id="_idIndexMarker185"/> and allows you to interact with REST<a id="_idIndexMarker186"/> web services. The REST API is the contract and the entry point that's used by apps to obtain or send data to and from the backend.</li>
			</ul>
			<p>Let's try to visualize<a id="_idIndexMarker187"/> the relationship<a id="_idIndexMarker188"/> between these entities:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B17788_03_01.jpg" alt="Figure 3.1 – Overview of HTTP communication between apps and web servers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Overview of HTTP communication between apps and web servers</p>
			<p>We want to implement something<a id="_idIndexMarker189"/> similar for our Restaurants<a id="_idIndexMarker190"/> application. For this to work, we will need a REST server. For the sake of simplicity, we will use the Firebase Realtime Database and create a database.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor097"/>Creating and populating your database with Firebase</h1>
			<p>So far, we've only used hardcoded data<a id="_idIndexMarker191"/> as the source of content for our Restaurants app. Since almost<a id="_idIndexMarker192"/> every real application uses dynamic<a id="_idIndexMarker193"/> data that comes from a backend server<a id="_idIndexMarker194"/> through a REST API, it's time to step up our game and create a database that simulates such a remote API.</p>
			<p>We can do this for free with the help of Firebase. Firebase is backed by Google and represents a <strong class="bold">Backend-as-a-Service</strong> (<strong class="bold">BaaS</strong>), which allows us to build a database<a id="_idIndexMarker195"/> very easily. We will use the Realtime Database service from Firebase without using the Firebase Android SDK. Even though such a database is not a proper REST web service, we can use its database URL as a REST endpoint and pretend that that is our REST interface, therefore simulating a real backend.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As we mentioned in the <em class="italic">Technical requirements</em> section, make sure that you have an existing Google account or that you create one beforehand.</p>
			<p>Let's start creating a database:</p>
			<ol>
				<li>Navigate to<a id="_idIndexMarker196"/> the Firebase<a id="_idIndexMarker197"/> console and log<a id="_idIndexMarker198"/> into your Google<a id="_idIndexMarker199"/> account<a id="_idIndexMarker200"/> by going to <a href="https://console.firebase.google.com/">https://console.firebase.google.com/</a>.</li>
				<li>Create a new Firebase project:</li>
			</ol>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B17788_03_02.jpg" alt="Figure 3.2 – Creating a new Firebase project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Creating a new Firebase project</p>
			<ol>
				<li value="3">Input the name of your project (it should be about restaurants!) and press <strong class="bold">Continue</strong>.</li>
				<li>Optionally, in the next dialog, you can opt out from Google Analytics since we won't be using the Firebase SDK. Press <strong class="bold">Continue</strong> again. At this point, the project should be created.</li>
				<li>From the left menu, expand the <strong class="bold">Build</strong> tab, search for <strong class="bold">Realtime Database</strong>, and then select it:</li>
			</ol>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B17788_03_03.jpg" alt="Figure 3.3 – Accessing Realtime Database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Accessing Realtime Database</p>
			<ol>
				<li value="6">On the newly displayed<a id="_idIndexMarker201"/> page, create a new database<a id="_idIndexMarker202"/> by clicking <strong class="bold">Create Database</strong>.</li>
				<li>In the <strong class="bold">Set up database</strong> dialog, select<a id="_idIndexMarker203"/> a location for your database<a id="_idIndexMarker204"/> and then click <strong class="bold">Next</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B17788_03_04.jpg" alt="Figure 3.4 – Setting up a Realtime Database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Setting up a Realtime Database</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If later on any network calls to your Firebase Database fail for no apparent reason, you might find yourself in a Firebase restricted location – as I am writing this chapter, because of the current situation caused by the eastern war, all internet providers from Romania are restricted and any network calls to Firebase Database are failing. If this happens to you, try selecting a different location for your Realtime Database instance.</p>
			<ol>
				<li value="8">In the same<a id="_idIndexMarker205"/> dialog, define your<a id="_idIndexMarker206"/> security<a id="_idIndexMarker207"/> rules by<a id="_idIndexMarker208"/> selecting <strong class="bold">Start in test mode</strong> and then clicking <strong class="bold">Enable</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B17788_03_05.jpg" alt="Figure 3.5 – Setting up the security rules of your database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Setting up the security rules of your database</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The default security rules<a id="_idIndexMarker209"/> for test mode allow anyone to view or modify the content within your database for the next 30 days since creation. After these 30 days, if you want to keep using the database in test mode, you will need to update the security rules by changing the timestamp values for the <strong class="source-inline">".read"</strong> and the <strong class="source-inline">".write"</strong> fields with greater timestamp values. To skip this, we will just set the <strong class="source-inline">".read"</strong> and the <strong class="source-inline">".write"</strong> fields to <strong class="source-inline">true</strong> in the next steps. However, Firebase might still restrict your access if you leave the database open for access without any rules indefinitely – that's why I recommend you visit the Firebase console and check the security rules for your database often to make sure that access was not revoked.</p>
			<p>At this point, you should be redirected to your database's main page in the <strong class="bold">Data</strong> tab:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B17788_03_06.jpg" alt="Figure 3.6 – Observing the Realtime Database main page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Observing the Realtime Database main page</p>
			<p>You will now notice your URL for this database: <a href="https://restaurants-db-default-rtdb.firebaseio.com/">https://restaurants-db-default-rtdb.firebaseio.com/</a>.</p>
			<p>Your URL<a id="_idIndexMarker210"/> should be similar<a id="_idIndexMarker211"/> but may differ, depending<a id="_idIndexMarker212"/> on the name you have chosen<a id="_idIndexMarker213"/> for your database.</p>
			<p>Note that the database seems to be empty; we only have an empty root node being called after our database: <strong class="source-inline">restaurants-db-default-rtdb</strong>. It's time to add data to our database.</p>
			<ol>
				<li value="9">Access the solution code for this chapter by navigating to the <strong class="source-inline">Chapter_03</strong> directory of this book's GitHub repository. Then, select the <strong class="source-inline">restaurants.json</strong> file. You can also access it by following this link: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json</a>.</li>
			</ol>
			<p>From here, download the <strong class="source-inline">restaurants.json</strong> file as we will need it shortly. To do that, press on the <strong class="bold">Raw</strong> button provided by the Github website and then right click the document that has been opened and download the JSON file by selecting <strong class="bold">Saves As</strong>.</p>
			<ol>
				<li value="10">Go back to the Firebase console, press on the three-dots menu to the right of the database URL, and select <strong class="bold">Import JSON</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B17788_03_07.jpg" alt="Figure 3.7 – Importing JSON content into Realtime Database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Importing JSON content into Realtime Database</p>
			<p>Make sure that you select the <strong class="source-inline">restaurants.json</strong> file that you've previously downloaded from the book's GitHub repository.</p>
			<ol>
				<li value="11">Wait for the<a id="_idIndexMarker214"/> page to refresh<a id="_idIndexMarker215"/> and check out the content<a id="_idIndexMarker216"/> that is populated<a id="_idIndexMarker217"/> in the database:</li>
			</ol>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B17788_03_08.jpg" alt="Figure 3.8 – Observing the content's structure in our database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Observing the content's structure in our database</p>
			<p>Here, we can see that our database contains a list of <strong class="bold">restaurants</strong>. Each restaurant has attributes that are similar to the ones in our <strong class="source-inline">Restaurant</strong> class: an ID, title, and description. The restaurants in our database also contain other fields that we will not need right now, so let's ignore them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you compare the structure of the content in our database with the one from the JSON file we've uploaded, we can see that it is very similar: we have a <strong class="source-inline">restaurants</strong> node that contains an array of objects, each containing consistent key-value pairs. The only exception is the presence of the indexes (0, 1, 2, and so on) for each restaurant, which were automatically created by Firebase. We should ignore these as they won't affect us.</p>
			<p>Now, even though we set the security rules to <strong class="bold">Test Mode</strong> previously, let's revisit them.</p>
			<ol>
				<li value="12">Move away from the <strong class="bold">Data</strong> tab<a id="_idIndexMarker218"/> and select the <strong class="bold">Rules</strong> tab. Here, to make<a id="_idIndexMarker219"/> sure that we can<a id="_idIndexMarker220"/> always read data from<a id="_idIndexMarker221"/> this database, change the <strong class="source-inline">".read"</strong> key's value to <strong class="source-inline">"true"</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B17788_03_09.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Updating security rules in Realtime Database</p>
			<ol>
				<li value="13">Press <strong class="bold">Publish</strong> to save the changes.<p class="callout-heading">Note</p><p class="callout">The security rules that we've set should not be used in a production application. We are hardcoding our security rules to <strong class="source-inline">true</strong> since we are testing and not publishing anything to production.</p></li>
			</ol>
			<p>Now, we can access the database URL as a simple REST endpoint, simulating a real REST server that we can connect to. To experiment, copy the URL of your newly created database, append <strong class="source-inline">restaurants.json</strong>, and paste it into your browser. </p>
			<p>Accessing this URL should return<a id="_idIndexMarker222"/> the JSON response<a id="_idIndexMarker223"/> of our restaurants, whose structure we will cover shortly. Until then, we need<a id="_idIndexMarker224"/> to instruct our application to create<a id="_idIndexMarker225"/> HTTP requests to obtain that data from our newly created database. So, let's do that next.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor098"/>Exploring Retrofit as an HTTP networking client for Android </h1>
			<p>For the application to obtain<a id="_idIndexMarker226"/> data from our database, we need<a id="_idIndexMarker227"/> to implement an HTTP client that will send network requests to the REST API of the database.</p>
			<p>Instead of working with the HTTP library provided by default by Android, we will use the <strong class="bold">Retrofit</strong> HTTP client library, which lets you create an HTTP client that is very easy to work with.</p>
			<p>If you plan to develop an HTTP client that interfaces with a REST API, you will have to take care of a lot of things – from making connections, retrying failed requests, or caching to response parsing and error handling. Retrofit saves you development time and potential headaches as it abstracts most of the underlying complexity associated with handling network requests and responses.</p>
			<p>In this section, we will cover the following topics:</p>
			<ul>
				<li>Using Retrofit</li>
				<li>Adding Retrofit to the Restaurants application</li>
				<li>Mapping JSON to model classes</li>
				<li>Executing GET requests to the Firebase REST API</li>
			</ul>
			<p>Let's start with some basics about Retrofit!</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor099"/>Using Retrofit</h2>
			<p>Retrofit makes networking<a id="_idIndexMarker228"/> simple in Android apps. It allows us to consume web services easily, create network requests, and receive responses while reducing the boilerplate code that's usually associated with their implementation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Retrofit also allows you to easily add custom headers and request types, file uploads, mocking responses, and more.</p>
			<p>To execute network requests with Retrofit, we need the following three components:</p>
			<ul>
				<li>An interface that defines the HTTP operations that need to be performed. Such an interface can specify request types such as <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">DELETE</strong>, and so on.</li>
				<li>A <strong class="source-inline">Retrofit.Builder</strong> instance that creates a concrete implementation of the interface we defined previously. The Builder API allows us to define networking parameters such as the HTTP client type, the URL endpoint for the HTTP operations, the converter to deserialize the JSON responses, and so on.</li>
				<li>Model classes that allow Retrofit to know how to map the deserialized JSON objects to regular data classes.</li>
			</ul>
			<p>Enough with the theory – let's try to implement Retrofit and use the components we introduced previously in our Restaurants application.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor100"/>Adding Retrofit to the Restaurants application</h2>
			<p>We want to connect our Restaurants application<a id="_idIndexMarker229"/> to the newly created Firebase database<a id="_idIndexMarker230"/> and send HTTP network requests to it. More specifically, when the Restaurants application is launched and the <strong class="source-inline">RestaurantsScreen</strong> composable is composed, we want to get the list of restaurants at runtime and not depend on hardcoded content within the app.</p>
			<p>Let's do that with the help of Retrofit:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">build.gradle</strong> file in the app module, add the dependency for Retrofit inside the <strong class="source-inline">dependencies</strong> block:<p class="source-code">implementation "com.squareup.retrofit2:retrofit:2.9.0"</p></li>
				<li>After updating the <strong class="source-inline">build.gradle</strong> file, make sure to sync your project with its Gradle files. You can do that by clicking on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</li>
				<li>Create an interface that defines the HTTP operations that are executed between our app and the database. Do so by clicking on the application package, selecting <strong class="bold">New</strong>, <a id="_idTextAnchor101"/>and then selecting <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RestaurantsApiService</strong> as the name and select <strong class="bold">Interface</strong> as the type. Inside the newly created file, add the following code:<p class="source-code">import retrofit2.Call</p><p class="source-code">import retrofit2.http.GET</p><p class="source-code">interface RestaurantsApiService {</p><p class="source-code">    @GET("restaurants.json")</p><p class="source-code">    fun getRestaurants(): Call&lt;Any&gt;</p><p class="source-code">}</p></li>
			</ol>
			<p>Let's break down the code we've just added into meaningful actions:</p>
			<ul>
				<li>Retrofit turns your HTTP API into a simple Java/Kotlin interface, so we've created a <strong class="source-inline">RestaurantsApiService</strong> interface that defines the HTTP actions we need.</li>
				<li>We've defined a <strong class="source-inline">getRestaurants</strong> method<a id="_idIndexMarker231"/> inside the interface<a id="_idIndexMarker232"/> that returns a <strong class="source-inline">Call</strong> object with an undefined response type marked by Kotlin's <strong class="source-inline">Any type</strong>. Each <strong class="source-inline">Call</strong> from <strong class="source-inline">RestaurantsApiService</strong> can make a synchronous or asynchronous HTTP request to the remote web server.</li>
				<li>We've annotated the <strong class="source-inline">getRestaurants</strong> method with the <strong class="source-inline">@GET</strong> annotation, thereby telling Retrofit that this method should execute a <strong class="source-inline">GET</strong> HTTP action to obtain data from our web server. Inside the <strong class="source-inline">@GET</strong> annotation, we passed the endpoint's path, which represents the <strong class="source-inline">restaurants</strong> node within our Firebase database. This means that when we execute this request, the <strong class="source-inline">restaurants.json</strong> endpoint will be appended to the base URL of the HTTP client.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">We mentioned that we can use our Firebase Realtime Database URL as a REST API. To access a specific node, such as the <strong class="source-inline">restaurants</strong> node of our database, we also appended the <strong class="source-inline">.json</strong> format to make sure that the Firebase database will behave like a REST API and return a JSON response.</p>
			<p>Later on, after we instantiate a Retrofit builder, the library will know how to turn our <strong class="source-inline">getRestaurants</strong> method into a proper HTTP call. </p>
			<p>But before that, you have probably noticed that the <strong class="source-inline">getRestaurants</strong> HTTP request from our interface has its response type defined as <strong class="source-inline">Any</strong>. We expect to receive the JSON content of our restaurants mapped to data classes that we can use in our code. So, let's work on that next.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor102"/>Mapping JSON to model classes</h2>
			<p>Retrofit lets you automatically serialize request<a id="_idIndexMarker233"/> bodies and deserialize response<a id="_idIndexMarker234"/> bodies. In our case, we're interested in deserializing the response body, from JSON into Java/Kotlin objects.</p>
			<p>To deserialize the JSON response, we will instruct Retrofit to use the GSON deserialization library, but until then, let's have a look at the JSON response that our database returns. Remember that we imported a JSON file called <strong class="source-inline">restaurants.json</strong> when we populated the Firebase database.</p>
			<p>Let's open that file with any text editor and observe its structure:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B17788_03_10.jpg" alt="Figure 3.10 – The JSON structure of the Firebase database's content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – The JSON structure of the Firebase database's content</p>
			<p>We can observe the following elements in the JSON response structure:</p>
			<ul>
				<li>It contains an array of JSON objects marked by the <strong class="source-inline">[</strong> and <strong class="source-inline">]</strong> identifiers.</li>
				<li>The contents of the JSON array's element are marked by the <strong class="source-inline">{</strong> and <strong class="source-inline">}</strong> identifiers and they enclose the JSON object structure of a restaurant.</li>
				<li>The restaurant JSON object contains four key-value pairs, separated by the <strong class="source-inline">, </strong>separator.</li>
			</ul>
			<p>The response from our database<a id="_idIndexMarker235"/> will be of type <strong class="source-inline">List&lt;?&gt;</strong> since the response<a id="_idIndexMarker236"/> holds an array of JSON objects. The main question that remains is, what data type should our application expect inside that list?</p>
			<p>To answer that, we must inspect the structure of the restaurant JSON object a bit closer:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B17788_03_11.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – The structure of the restaurant JSON object</p>
			<p>Here, we can see that the JSON restaurant has four key-value pairs that refer to the <strong class="source-inline">id</strong>, <strong class="source-inline">title</strong>, <strong class="source-inline">description</strong>, and <strong class="source-inline">shutdown</strong> statuses of the corresponding restaurant. This structure is similar to our <strong class="source-inline">Restaurant.kt</strong> data class within the project:</p>
			<p class="source-code">data class Restaurant(val id: Int,</p>
			<p class="source-code">                      val title: String,</p>
			<p class="source-code">                      val description: String,</p>
			<p class="source-code">                      var isFavorite: Boolean = false)</p>
			<p>Our <strong class="source-inline">Restaurant</strong> also contains the <strong class="source-inline">id</strong>, <strong class="source-inline">title</strong>, and <strong class="source-inline">description</strong> fields. We are not interested in the <strong class="source-inline">shutdown</strong> status for now, so it's tempting to use the <strong class="source-inline">Restaurant</strong> class as the model for our response, thus making our <strong class="source-inline">getRestaurants()</strong> method in <strong class="source-inline">RestaurantsApiService</strong> return <strong class="source-inline">List&lt;Restaurant&gt;</strong> as the response of the request.</p>
			<p>The issue with this approach is that we need to tell Retrofit to match the <strong class="source-inline">r_id</strong> key's value with our <strong class="source-inline">id</strong> field. The same goes for <strong class="source-inline">r_title</strong>, which should be matched with the <strong class="source-inline">title</strong> field and so on. We can approach this in two ways:</p>
			<ul>
				<li>Rename the <strong class="source-inline">Restaurant</strong> data class fields<a id="_idIndexMarker237"/> so that they match the response<a id="_idIndexMarker238"/> keys: <strong class="source-inline">r_id</strong>, <strong class="source-inline">r_title</strong>, and so on. In this case, the deserialization will automatically match our fields with the fields from the JSON objects since the JSON keys are identical to the fields' names.</li>
				<li>Annotate the <strong class="source-inline">Restaurant</strong> data class fields with special serialization matchers that tell Retrofit which keys should be matched with each field. This won't change the variable names.</li>
			</ul>
			<p>The first approach is bad because our <strong class="source-inline">Restaurant</strong> data class would end up with fields that contain underscore naming dictated by the server. It would also not comply with Kotlin's CamelCase guideline for defining field variables anymore.</p>
			<p>Let's choose the second approach, where we specify the serialization keys ourselves. To do that, we will tell Retrofit to deserialize the JSON with the GSON deserialization library, which is a powerful framework for converting JSON strings into Java/Kotlin objects and vice versa:</p>
			<ol>
				<li value="1">First, we need to add the GSON library dependency to mark our fields with custom serialization keys. Inside the <strong class="source-inline">build.gradle</strong> file in the app module, add the dependency for GSON inside the <strong class="source-inline">dependencies</strong> blo<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/>ck:<p class="source-code">implementation "com.google.code.gson:gson:2.8.6"</p></li>
				<li>After updating the <strong class="source-inline">build.gradle</strong> file, make sure to sync your project with its Gradle files. You can do that by clicking on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</li>
				<li>Inside <strong class="source-inline">Restaurant.kt</strong>, add the <strong class="source-inline">@SerializedName</strong> annotation for each field and specify the corresponding serialization keys from the JSON structure:<p class="source-code"><strong class="bold">import com.google.gson.annotations.SerializedName</strong></p><p class="source-code">data class Restaurant(</p><p class="source-code">    <strong class="bold">@SerializedName("r_id")</strong></p><p class="source-code">    val id: Int,</p><p class="source-code">    <strong class="bold">@SerializedName("r_title")</strong></p><p class="source-code">    val title: String,</p><p class="source-code">    <strong class="bold">@SerializedName("r_description")</strong></p><p class="source-code">    val description: String,</p><p class="source-code">    var isFavorite: Boolean = false)</p></li>
			</ol>
			<p>By doing so, we've made sure that Retrofit will correctly match each of the JSON key's values with our corresponding<a id="_idIndexMarker239"/> field inside the <strong class="source-inline">Restaurant</strong> data class while also matching<a id="_idIndexMarker240"/> the data type: </p>
			<ul>
				<li>The <strong class="source-inline">r_id</strong> key matches the <strong class="source-inline">id</strong> field. The <strong class="source-inline">r_id</strong> key has a whole number as its value in the JSON structure, so we stored this key's value in the <strong class="source-inline">id: Int</strong> field.</li>
				<li>The <strong class="source-inline">r_title</strong> key matches the <strong class="source-inline">title</strong> field. The <strong class="source-inline">r_title</strong> key has text as its value marked with the <strong class="source-inline">"</strong> and <strong class="source-inline">"</strong> identifiers, so we stored this key's value in the <strong class="source-inline">title: String</strong> field.</li>
				<li>The <strong class="source-inline">r_description</strong> key matches the <strong class="source-inline">description</strong> field. The <strong class="source-inline">r_description</strong> key has text as its value marked with the <strong class="source-inline">"</strong> and <strong class="source-inline">"</strong> identifiers, so we stored this key's value in the <strong class="source-inline">description: String</strong> field.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">For now, we are using the Restaurant data model both as the API response model and as the domain model that's used throughout the application. Architecturally, this practice is not recommended, and we will cover why this is the case and fix it in <a href="B17788_08_ePub.xhtml#_idTextAnchor285"><em class="italic">Chapter 8</em></a>, <em class="italic">Getting Started with Clean Architecture in Android</em>.</p>
			<ol>
				<li value="4">Update the <strong class="source-inline">getRestaurants()</strong> method inside <strong class="source-inline">RestaurantsApiService</strong> so that it returns a <strong class="source-inline">Call</strong> object from the server with the type parameter that matches the response that is expected. In our case, that would be <strong class="source-inline">List&lt;Restaurant&gt;</strong>:<p class="source-code">interface RestaurantsApiService {</p><p class="source-code">    @GET("restaurants.json")</p><p class="source-code">    fun getRestaurants(): <strong class="bold">Call&lt;List&lt;Restaurant&gt;&gt;</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>With that, our Retrofit API interface<a id="_idIndexMarker241"/> has been defined to receive the content<a id="_idIndexMarker242"/> of the Restaurants database from our Firebase database. The only step left is to configure a Retrofit builder instance and execute the request.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor105"/>Executing GET requests to the Firebase REST API</h2>
			<p>Let's configure the last component that's needed<a id="_idIndexMarker243"/> to perform requests with<a id="_idIndexMarker244"/> Retrofit – the <strong class="source-inline">Retrofit.builder</strong> object:</p>
			<ol>
				<li value="1">First, we need to add the GSON Converter library dependency for Retrofit so that Retrofit deserializes the JSON response while following the GSON serialization annotations we added previously. Inside the <strong class="source-inline">build.gradle</strong> file in the app module, add the dependency for the<a id="_idTextAnchor106"/> Retrofit GSON converter inside the <strong class="source-inline">dependencies</strong> block:<p class="source-code">implementation "com.squareup.retrofit2:converter-</p><p class="source-code">    gson:2.9.0"</p></li>
				<li>After updating the <strong class="source-inline">build.gradle</strong> file, make sure to sync your project with its Gradle files. You can do that by clicking on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</li>
				<li>Inside <strong class="source-inline">RestaurantsViewModel</strong>, add a <strong class="source-inline">restInterface</strong> variable<a id="_idIndexMarker245"/> of type <strong class="source-inline">RestaurantsApiService</strong> and create an <strong class="source-inline">init</strong> block where we will instantiate<a id="_idIndexMarker246"/> the <strong class="source-inline">Retrofit.builder<a id="_idTextAnchor107"/></strong> object:<p class="source-code">class RestaurantsViewModel(…) : ViewModel() {</p><p class="source-code">    <strong class="bold">private var restInterface: RestaurantsApiService</strong></p><p class="source-code">    val state = mutableStateOf(</p><p class="source-code">        dummyRestaurants.restoreSelections()</p><p class="source-code">    )</p><p class="source-code">    <strong class="bold">init {</strong></p><p class="source-code"><strong class="bold">        val retrofit: Retrofit = Retrofit.Builder()</strong></p><p class="source-code"><strong class="bold">            .addConverterFactory(</strong></p><p class="source-code"><strong class="bold">                GsonConverterFactory.create()</strong></p><p class="source-code"><strong class="bold">            )</strong></p><p class="source-code"><strong class="bold">            .baseUrl(</strong></p><p class="source-code"><strong class="bold">                "https://restaurants-db-default</strong></p><p class="source-code"><strong class="bold">                        -rtdb.firebaseio.com/"</strong></p><p class="source-code"><strong class="bold">            )</strong></p><p class="source-code"><strong class="bold">            .build()</strong></p><p class="source-code"><strong class="bold">        restInterface = retrofit.create(</strong></p><p class="source-code"><strong class="bold">            RestaurantsApiService::class.java</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    […]</p><p class="source-code">}</p></li>
			</ol>
			<p>We've added all the necessary pieces for our networking client. Let's break this code down:</p>
			<ul>
				<li>First, we've defined a <strong class="source-inline">restInterface</strong> variable of type <strong class="source-inline">RestaurantsApiService</strong> that we will call upon to execute the desired network requests. At this point, the <strong class="source-inline">restInterface</strong> variable holds no value.</li>
				<li>We've added an <strong class="source-inline">init</strong> block to instantiate<a id="_idIndexMarker247"/> the Retrofit builder object. As the primary<a id="_idIndexMarker248"/> constructor can't contain any code, we are placing the initialization code in an initializer block prefixed with the <strong class="source-inline">init</strong> keyword.</li>
				<li>We've instantiated a <strong class="source-inline">retrofit: Retrofit</strong> variable with the <strong class="source-inline">Retrofit.Builder</strong> accessor and specified the following:<a id="_idTextAnchor108"/></li>
				<li>A <strong class="source-inline">GsonConverterFactory</strong> to explicitly tell Retrofit that we want the JSON to be deserialized with the GSON converter, following the <strong class="source-inline">@Serialized</strong> annotations we specified in the <strong class="source-inline">Restaurant</strong> data class.</li>
				<li>A <strong class="source-inline">baseUrl</strong> for all the requests that are to be executed – in your case, replace this URL with the URL of your Firebase database.</li>
				<li>Finally, we called <strong class="source-inline">.create()</strong> on the previously obtained <strong class="source-inline">Retrofit</strong> object and passed our interface with the desired requests: <strong class="source-inline">RestaurantsApiService</strong>. Behind the scenes, Retrofit creates a concrete implementation of our interface that will handle all the networking logic, without us having to worry about it. We store this instance from Retrofit inside our <strong class="source-inline">restInterface</strong> variable.</li>
			</ul>
			<p>Now, we can execute requests – in our case, the request to get the list of restaurants.</p>
			<ol>
				<li value="4">Inside <strong class="source-inline">RestaurantsViewModel</strong>, add the <strong class="source-inline">getRestaurants</strong> method:<p class="source-code">fun getRestaurants() {</p><p class="source-code">    restInterface.getRestaurants().execute().body()</p><p class="source-code">        ?.let { restaurants -&gt;</p><p class="source-code">            state.value = restaurants.restoreSelections()</p><p class="source-code">        }</p><p class="source-code">}</p></li>
			</ol>
			<p>We've added all the necessary<a id="_idIndexMarker249"/> steps for our networking request<a id="_idIndexMarker250"/> to be executed. Let's break this code down:</p>
			<ol>
				<li value="1">We've obtained a <strong class="source-inline">Call</strong> object called <strong class="source-inline">Call&lt;List&lt;Restaurant&gt;&gt;</strong> from our Retrofit <strong class="source-inline">restInterface</strong> variable by calling the <strong class="source-inline">getRestaurants()</strong> interface method. The <strong class="source-inline">Call</strong> object represents the invocation of a Retrofit method that sends network requests and receives a response. The type parameter of the <strong class="source-inline">Call</strong> object matches the response type; that is, <strong class="source-inline">&lt;List&lt;Restaurant&gt;&gt;</strong>.</li>
				<li>On the previously obtained <strong class="source-inline">Call</strong> object, we called <strong class="source-inline">execute()</strong>. The <strong class="source-inline">execute()</strong> method is the most simple approach to starting a network request with Retrofit as it runs the request synchronously on the main thread (the UI thread) and blocks it until the response arrives. No network request should block the UI thread yet, though we will fix this soon.</li>
				<li>The <strong class="source-inline">execute()</strong> method returns a Retrofit <strong class="source-inline">Response</strong> object that allows us to see if the response was successful and obtain the resulting body.</li>
				<li>The <strong class="source-inline">body()</strong> accessor returns a nullable list of type <strong class="source-inline">List&lt;Restaurant&gt;&gt;?</strong>. We apply the Kotlin <strong class="source-inline">let</strong> extension function and name the list <strong class="source-inline">restaurants</strong>.</li>
				<li>We pass the resulting <strong class="source-inline">restaurants</strong> list to our <strong class="source-inline">state</strong> object after restoring the selections in case of system-initiated process death, similar to what we did for the initial state value.</li>
			</ol>
			<p>With that, we've instructed our <strong class="source-inline">ViewModel</strong> on how to obtain<a id="_idIndexMarker251"/> the list of restaurants from the database<a id="_idIndexMarker252"/> and to pass this result to our screen's state. One issue that we will have to address later is that we are not catching any errors that may be thrown by Retrofit if the request fails. Until then, let's focus on updating the state with the new result.</p>
			<p>5.	Inside <strong class="source-inline">RestaurantsViewModel</strong>, we need to update the state's initial value so that it contains an empty list. This is because, when the screen is first displayed, we no longer have restaurants to render – we will get them later in the network request. Update the initial value of the <strong class="source-inline">state</strong> object by rem<a id="_idTextAnchor109"/>oving <strong class="source-inline">dummyList</strong> and placing an <strong class="source-inline">emptyList()</strong> instead:</p>
			<p class="source-code">val state = mutableStateOf(<strong class="bold">emptyList&lt;Restaurant&gt;())</strong></p>
			<ol>
				<li value="6">Inside the <strong class="source-inline">Restaurant.kt</strong> file, remove the <strong class="source-inline">dummyRestaurants</strong> list since we will be obtaining the restaurants at runtime through the previously defined request.</li>
				<li>We want to trigger the network request to obtain the restaurants from the server. Inside <strong class="source-inline">RestaurantsScreen.kt</strong>, update the <strong class="source-inline">RestaurantsScreen</strong> composable function so that it calls the <strong class="source-inline">getRestaurants()</strong> method of <strong class="source-inline">viewModel</strong>, which will trigger the network request to obtain the restaurants from the server:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen() {</p><p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code">    <strong class="bold">viewModel.getRestaurants()</strong></p><p class="source-code">    LazyColumn( … ) { … }</p><p class="source-code">}</p></li>
			</ol>
			<p>By calling <strong class="source-inline">viewModel.getRestaurants()</strong>, we are trying to load the list of restaurants when the <strong class="source-inline">RestaurantsScreen</strong> composable is composed<a id="_idIndexMarker253"/> for the first time. This practice is not recommended and we will <a id="_idIndexMarker254"/>see in the following steps why that is and how we can fix it.</p>
			<ol>
				<li value="8">Add internet permission inside the <strong class="source-inline">AndroidManifest.xml</strong> file:<p class="source-code">&lt;manifest xmlns:android="…"</p><p class="source-code">    package="com.codingtroops.restaurantsapp"&gt;</p><p class="source-code">    <strong class="bold">&lt;uses-permission</strong>                                   <strong class="bold">android:name="android.permission.INTERNET" /&gt;</strong></p><p class="source-code">      &lt;application&gt; … &lt;/application&gt;</p><p class="source-code">&lt;/manifest&gt;</p></li>
				<li>Run the application by clicking the <strong class="bold">Run</strong> button.</li>
			</ol>
			<p>Unfortunately, the application<a id="_idIndexMarker255"/> will most likely crash. If we check <strong class="bold">Logcat</strong>, we will notice an exception stack similar to the following:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B17788_03_12.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Crash stack trace for executing a network request on the main thread</p>
			<p>The exception that's been thrown here is a <strong class="source-inline">NetworkOnMainThreadException</strong> and it's clear what's wrong with our code: we are executing a network request on the Main thread.</p>
			<p>This has happened because with the Android Honeycomb SDK, <em class="italic">executing network requests on the Main thread is forbidden</em> because the UI of the application will freeze until the response from the server<a id="_idIndexMarker256"/> arrives, making the app unusable<a id="_idIndexMarker257"/> in that timeframe. In other words, we can't and shouldn't use the <strong class="source-inline">.execute()</strong> method of a Retrofit <strong class="source-inline">Call</strong> object because the request will run synchronously on the Main thread. </p>
			<p>Instead, we can use an alternative that not only will execute the requests asynchronously and on a separate thread, but also allow us to handle any errors that are thrown by Retrofit.</p>
			<ol>
				<li value="10">In the <strong class="source-inline">getRestaurants()</strong> method of <strong class="source-inline">ViewModel</strong>, replace the <strong class="source-inline">.execute()</strong> call with <strong class="source-inline">.enqueue()</strong>:<p class="source-code">fun getRestaurants() {</p><p class="source-code">   restInterface.getRestaurants<strong class="bold">().enqueue(</strong></p><p class="source-code"><strong class="bold">    object : Callback&lt;List&lt;Restaurant&gt;&gt; {</strong></p><p class="source-code"><strong class="bold">        override fun onResponse(</strong></p><p class="source-code"><strong class="bold">            call: Call&lt;List&lt;Restaurant&gt;&gt;,</strong></p><p class="source-code"><strong class="bold">            response: Response&lt;List&lt;Restaurant&gt;&gt;</strong></p><p class="source-code"><strong class="bold">        ) {</strong></p><p class="source-code"><strong class="bold">            response.body()?.let { restaurants -&gt;</strong></p><p class="source-code"><strong class="bold">                state.value = </strong></p><p class="source-code"><strong class="bold">                    restaurants.restoreSelections()</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">        override fun onFailure(</strong></p><p class="source-code"><strong class="bold">            call: Call&lt;List&lt;Restaurant&gt;&gt;, t: Throwable</strong></p><p class="source-code"><strong class="bold">        ) {</strong></p><p class="source-code"><strong class="bold">            t.printStackTrace()</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    })</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>When adding the missing imports for the <strong class="source-inline">Call</strong>, <strong class="source-inline">Callback</strong> and <strong class="source-inline">Response</strong> classes, make sure<a id="_idIndexMarker258"/> that you're adding the Retrofit2 imports<a id="_idIndexMarker259"/> that start off like this: <strong class="source-inline">import retrofit2.*</strong>.</p>
			<p>Getting back to the code that we've added, let's look at it in more detail:</p>
			<ul>
				<li>On the <strong class="source-inline">Call</strong> object that we obtained from our <strong class="source-inline">restInterface.getRestaurants()</strong> method, we called the <strong class="source-inline">.enqueue()</strong> function. The <strong class="source-inline">enqueue()</strong> call is a better alternative to <strong class="source-inline">.execute()</strong> since it runs the network request asynchronously on a separate thread, so it will no longer run on the UI thread and it won't block the UI.</li>
				<li>The <strong class="source-inline">.enqueue()</strong> function receives a <strong class="source-inline">Callback</strong> object as an argument that allows us to listen for success or failure callbacks. The <strong class="source-inline">Callback</strong> object's type parameter defines the expected <strong class="source-inline">Response</strong> object. Since we expect a response of type <strong class="source-inline">&lt;List&lt;Restaurant&gt;&gt;</strong>, the returned <strong class="source-inline">Callback</strong> type is defined as <strong class="source-inline">Callback&lt;List&lt;Restaurant&gt;&gt;</strong>.</li>
				<li>We've implemented the required <strong class="source-inline">object : Callback&lt;List&lt;Restaurant&gt;&gt;</strong> and implemented its two callbacks:</li>
				<li><strong class="source-inline">onResponse()</strong>, which is the success callback that's invoked when the network request succeeds. It provides us with the initial <strong class="source-inline">Call</strong> object, but more importantly the <strong class="source-inline">Response</strong> object; that is, <strong class="source-inline">Response&lt;List&lt;Restaurant&gt;&gt;</strong>. Inside this callback, we get the body from the response and update the value of the <strong class="source-inline">state</strong> variable, just like we did with <strong class="source-inline">execute()</strong>.</li>
				<li><strong class="source-inline">onFailure()</strong>, which is the failure callback. It's invoked when a network exception occurs while talking to the server or when an unexpected exception occurs while creating the request or processing<a id="_idIndexMarker260"/> the response. This callback provides<a id="_idIndexMarker261"/> us with the initial <strong class="source-inline">Call</strong> object and the <strong class="source-inline">Throwable</strong> exception that was intercepted and whose stack trace we print.</li>
			</ul>
			<p>Now, you can run the application. It shouldn't crash anymore since calling <strong class="source-inline">enqueue()</strong> allowed the request to run on a separate thread so that we could safely wait for the response without blocking the UI.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a good practice, make sure that when you're making requests with Retrofit, you always call the <strong class="source-inline">enqueue()</strong> function and not <strong class="source-inline">execute()</strong>. You want your users to not experience crashes and to be able to interact with the app while they're waiting for the network response.</p>
			<p>Yet even with this addition, there are still two concerning issues with our code. Were you able to notice them? Let's try to identify them.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor110"/>Improving the way our app handles network requests</h1>
			<p>Our application now successfully obtains data from the server dynamically, at runtime. Unfortunately, we have made two major mistakes in our code, and both<a id="_idIndexMarker262"/> are related to how the app handles<a id="_idIndexMarker263"/> the requests. Let's identify them:</p>
			<ul>
				<li>First, we are not canceling our network request as a cleanup measure. If our UI component that is bound to <strong class="source-inline">RestaurantsViewModel</strong> – in our case, <strong class="source-inline">MainActivity</strong> – is destroyed before the response from the server can arrive (for example, if the user navigates to another activity), we could potentially create a memory leak. This is because our <strong class="source-inline">RestaurantsViewModel</strong> would still be tied to the <strong class="source-inline">Callback&lt;List&lt;Restaurant&gt;&gt;</strong> object, which waits for the server's response. Due to this, the garbage collector won't free up the memory associated with both of their instances.</li>
				<li>Secondly, we are not triggering<a id="_idIndexMarker264"/> the network request from a controll<a id="_idTextAnchor111"/>ed<a id="_idIndexMarker265"/> environment. The <strong class="source-inline">viewModel.getRestaurants()</strong> method is called inside the <strong class="source-inline">RestaurantsScreen()</strong> composable function without any special considerations. This means that every time the UI is recomposed, the composable will ask <strong class="source-inline">ViewModel</strong> to execute network requests, resulting in possible multiple and redundant requests.</li>
			</ul>
			<p>Let's focus on the first issue for now. </p>
			<h3>Canceling network requests as a cleanup measure</h3>
			<p>The main problem in our <strong class="source-inline">RestaurantsViewModel</strong> is that we are enqueueing a <strong class="source-inline">Call</strong> object and we're waiting<a id="_idIndexMarker266"/> for the response through the <strong class="source-inline">Callback</strong> object, but we are never canceling that enqueued <strong class="source-inline">Call</strong>. We should cancel it when the host <strong class="source-inline">Activity</strong> or <strong class="source-inline">ViewModel</strong> is cleared to prevent memory leaks. Let's do that here:</p>
			<ol>
				<li value="1">Inside <strong class="source-inline">RestaurantsViewModel</strong>, define a class variable of type <strong class="source-inline">Call</strong> with the <strong class="source-inline">List&lt;Restaurant&gt;&gt;</strong> type parameter. Call this variable <strong class="source-inline">restaurantsCall</strong> as we will use it to hold a reference to our enqueued <strong class="source-inline">Call</strong> object:<p class="source-code">class RestaurantsViewModel(…): ViewModel() {</p><p class="source-code">    private var restInterface: RestaurantsApiService</p><p class="source-code">    val state = […]</p><p class="source-code">    <strong class="bold">private lateinit var restaurantsCall: </strong></p><p class="source-code"><strong class="bold">        Call&lt;List&lt;Restaurant&gt;&gt;</strong></p><p class="source-code">    init {…}</p><p class="source-code">   […]</p><p class="source-code">}</p></li>
			</ol>
			<p>We've marked <strong class="source-inline">restaurantsCall</strong> as a <strong class="source-inline">lateinit</strong> variable to instantiate it later when we perform the network request.</p>
			<ol>
				<li value="2">Inside the <strong class="source-inline">getRestaurants()</strong> method of <strong class="source-inline">RestaurantsViewModel</strong>, assign the <strong class="source-inline">Call</strong> object that<a id="_idIndexMarker267"/> you obtained from the <strong class="source-inline">restInterface.getRestaurants()</strong> method call to the <strong class="source-inline">restaurantsCall</strong> member variable and call <strong class="source-inline">enqueue()</strong> on it:<p class="source-code">fun getRestaurants() {</p><p class="source-code">    <strong class="bold">restaurantsCall = restInterface.getRestaurants()</strong></p><p class="source-code">    <strong class="bold">restaurantsCall.enqueue</strong>(object : </p><p class="source-code"> Callback&lt;List&lt;Restaurant&gt;&gt; {…})</p><p class="source-code">}</p></li>
				<li>Inside <strong class="source-inline">RestaurantsViewModel</strong>, override the <strong class="source-inline">onCleared()</strong> method and call the <strong class="source-inline">cancel()</strong> method of the <strong class="source-inline">restaurantCall</strong> object:<p class="source-code">override fun onCleared() {</p><p class="source-code">    super.onCleared()</p><p class="source-code">    restaurantsCall.cancel()</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">onCleared()</strong> callback method is provided by the Jetpack <strong class="source-inline">ViewModel</strong> and is called just before <strong class="source-inline">ViewModel</strong> is destroyed as a consequence of the attached activity/fragment or composable being destroyed or removed from the composition.</p>
			<p>This callback represents the perfect opportunity for us to cancel any ongoing work – or in our case, to cancel the pending <strong class="source-inline">Call</strong> object that's enqueued in the <strong class="source-inline">restaurantCall</strong> object. This way, we prevent leaking memory and therefore fix the fi<a id="_idTextAnchor112"/>rst issue in our code.</p>
			<p>Now, it's time to focus<a id="_idIndexMarker268"/> on the second issue, where the <strong class="source-inline">RestaurantsScreen()</strong> composable calls the <strong class="source-inline">viewModel.getRestaurants()</strong> method without any special considerations. </p>
			<h3>Triggering network requests from a controlled environment</h3>
			<p>The <strong class="source-inline">viewModel.getRestaurants()</strong> method is called because we want to apply a <strong class="bold">side effect</strong> in our UI. A side effect is a change<a id="_idIndexMarker269"/> that's made to the state of the application that usually happens outside<a id="_idIndexMarker270"/> the scope of a composable function. In our case, the side effect<a id="_idIndexMarker271"/> is that we need to start loading the restaurants for the first time when the user enters the screen. </p>
			<p>As a rule of thumb, composables should be side-effect free, but in our application, we need to know when to trigger the network request, and what better place than the moment when our UI is initially composed?</p>
			<p>The problem with the existing approach of simply calling a method on <strong class="source-inline">ViewModel</strong> from the composable layer is that the Compose UI can be recomposed many times on the screen. For example, when an animation is rendered, the Compose UI is recomposed many times to execute the animation's keyframes. On every recomposition of the UI, our composable calls the <strong class="source-inline">getRestaurants()</strong> method on <strong class="source-inline">RestaurantsViewModel</strong>, which, in turn, executes network requests to obtain the restaurants from the server, which could result in multiple and redundant requests.</p>
			<p>To prevent this issue from happening, Compose has the right tool for us to handle side-effects<a id="_idIndexMarker272"/> efficiently: the <strong class="bold">Effects</strong> API.</p>
			<p>An <em class="italic">effect</em> is a composable function that, instead of emitting UI elements, causes side effects that run when a composition process completes. Such composables are based on the Kotlin Coroutine API, which allows you to run async work in their bodies. However, we will disregard coroutines for now as we will cover them in <a href="B17788_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Handling Async Operations with Coroutines</em>.</p>
			<p>In Compose, there are many types of effect composables that we can use but we will not go too deep into that. In our case, though, a suitable effect could be the <strong class="source-inline">LaunchedEffect</strong> composable since it allows us to run a task only once when it first enters composition.</p>
			<p>The signature of <strong class="source-inline">LaunchedEffect</strong> is simple – it contains a <strong class="source-inline">key1</strong> parameter and a <strong class="source-inline">block</strong> parameter where we can execute our code. For now, we should ignore the Coroutine terminology<a id="_idIndexMarker273"/> and just think of the <strong class="source-inline">block</strong> function parameter<a id="_idIndexMarker274"/> as a block of code that can be executed asynchronously:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B17788_03_13.jpg" alt="Figure 3.13 – The signature of the LaunchedEffect composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – The signature of the LaunchedEffect composable</p>
			<p>When <strong class="source-inline">LaunchedEffect</strong> enters the composition process, it runs the <strong class="source-inline">block</strong> parameter function, which is passed as an argument. The execution of the block will be canceled if <strong class="source-inline">LaunchedEffect</strong> leaves the composition. If <strong class="source-inline">LaunchedEffect</strong> is recomposed with different keys that have been passed to the <strong class="source-inline">key1</strong> parameter, the existing execution of the block of code will be canceled and a new iteration of execution will be launched.</p>
			<p>Now that we know how <strong class="source-inline">LaunchedEffect</strong> works, we can agree that it seems a viable solution for our issue, at least for now: we want to make sure that the call to <strong class="source-inline">ViewModel</strong> is only executed once on the initial composition, so <strong class="source-inline">LaunchedEffect</strong> seems to suffice our needs.</p>
			<p>Let's add a <strong class="source-inline">LaunchedEffect</strong> to prevent our UI from asking for restaurants from <strong class="source-inline">ViewModel</strong> repeatedly on every recomposition:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">RestaurantsScreen</strong> composable, wrap the <strong class="source-inline">viewModel.getRestaurants()</strong> call in a <strong class="source-inline">LaunchedEffect</strong> composable:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen() {</p><p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code">    <strong class="bold">LaunchedEffect(key1 = "request_restaurants") {</strong></p><p class="source-code">        viewModel.getRestaurants()</p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code">    LazyColumn(…) { … }</p><p class="source-code">}</p></li>
			</ol>
			<p>To implement the <strong class="source-inline">LaunchedEffect</strong> composable, we did the following:</p>
			<ul>
				<li>We passed a <strong class="source-inline">String</strong> hardcoded value of <strong class="source-inline">"request_restaurants"</strong> to the <strong class="source-inline">key1</strong> parameter. We passed a hardcoded<a id="_idIndexMarker275"/> value to the <strong class="source-inline">key1</strong> argument because we want<a id="_idIndexMarker276"/> the block of code passed inside the <strong class="source-inline">LaunchedEffect</strong> composable to not execute on every recomposition. We could have passed any constant to <strong class="source-inline">key1</strong>, yet what's important here is that the value shouldn't change over time. </li>
				<li>We passed our code that calls the <strong class="source-inline">getRestaurants()</strong> method on our <strong class="source-inline">ViewModel</strong> inside the <strong class="source-inline">block</strong> parameter of the effect. Since the <strong class="source-inline">block</strong> parameter is the last parameter of the <strong class="source-inline">LaunchedEffect</strong> composable and is a function, we used the trailing lambda syntax.</li>
			</ul>
			<ol>
				<li value="2">Run the application. Now, the code inside <strong class="source-inline">LaunchedEffect</strong> should only be executed once.</li>
			</ol>
			<p>Yet even with this addition, our code still has an issue. If you try rotating the emulator or device you're testing with, you will trigger a configuration change and another network will be executed. But we mentioned previously that <strong class="source-inline">LaunchedEffect</strong> will only execute the <strong class="source-inline">viewModel.getRestaurants()</strong> call once, so why is this happening?</p>
			<p><strong class="source-inline">LaunchedEffect</strong> works fine – the issue lies in the activity being destroyed on configuration change. If the activity is destroyed, the UI will be composed again from scratch, and for all it knows, <strong class="source-inline">LaunchedEffect</strong> will run the code inside the <strong class="source-inline">block</strong> parameter for the first time.</p>
			<p>Can you think of a better alternative to get around the issue of the activity being destroyed due to configuration changes?</p>
			<p>An alternative would be to use the <strong class="source-inline">ViewModel</strong> component because it survives configuration changes. If we trigger<a id="_idIndexMarker277"/> the request only once in <strong class="source-inline">RestaurantsViewModel</strong>, we no longer care<a id="_idIndexMarker278"/> if a configuration change occurs – the request will not be executed again. Follow these steps:</p>
			<ol>
				<li value="1">Inside <strong class="source-inline">RestaurantsViewModel</strong>, locate the <strong class="source-inline">init</strong> block and inside it, call <strong class="source-inline">getRestaurants()</strong>:<p class="source-code">init {</p><p class="source-code">    val retrofit: Retrofit = Retrofit.Builder().[…].build()</p><p class="source-code">    restInterface = retrofit.create(</p><p class="source-code">        RestaurantsApiService::class.java</p><p class="source-code">    )</p><p class="source-code">    <strong class="bold">getRestaurants()</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">init</strong> block is called once when an instance of <strong class="source-inline">ViewModel</strong> is created, so placing our network request here is a safer bet than at the UI level in any composable. Make sure you've placed the <strong class="source-inline">getRestaurants()</strong> call after the instantiation of the <strong class="source-inline">restInterface</strong> variable since the <strong class="source-inline">getRestaurants()</strong> method depends on that variable being ready to work.</p>
			<ol>
				<li value="2">Still inside <strong class="source-inline">RestaurantsViewModel</strong>, navigate to the <strong class="source-inline">getRestaurants()</strong> method and mark it as <strong class="source-inline">private</strong>:<p class="source-code"><strong class="bold">private</strong> fun getRestaurants() {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>We no longer need to expose this method publicly to the UI since it's now only called inside <strong class="source-inline">ViewModel</strong>.</p>
			<ol>
				<li value="3">Inside the <strong class="source-inline">RestaurantsScreen</strong> composable, remove the <strong class="source-inline">LaunchedEffect</strong> composable function with all the code inside it since we no longer need it.</li>
				<li>Run the application. The network request should not be executed again when a configuration change is made since the <strong class="source-inline">RestaurantsViewModel</strong> instance is preserved and the code inside its <strong class="source-inline">init</strong> block is not executed again.</li>
			</ol>
			<p>We've taken quite a few steps<a id="_idIndexMarker279"/> to make sure that our application handles<a id="_idIndexMarker280"/> network requests correctly, and this was a great first step toward creating a modern application.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor113"/>Summary</h1>
			<p>In this chapter, we learned how mobile apps communicate with remote web APIs using HTTP connections and REST APIs. Then, we created a database for our Restaurants application with the help of Firebase and populated it with content.</p>
			<p>After that, we explored what Retrofit is and how it abstracts the complexity associated with handling network requests and responses within HTTP connections between apps and web APIs. </p>
			<p>Then, we executed a network request with Retrofit in our Restaurants application and learned how the JSON content that is sent by the server can be parsed or deserialized by our Retrofit networking client. We also learned how to correctly wait for network responses and how to notify the application when responses arrive.</p>
			<p>Finally, we solved some common issues that occur when our applications communicate with web APIs asynchronously to retrieve data, especially in the context of Compose.</p>
			<p>In the next chapter, we'll explore a very efficient tool in Android for async work that comes bundled with Kotlin: coroutines!</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor114"/>Further reading</h1>
			<p>With the help of custom annotations inside the Retrofit interface, this library hides most of the complexity associated with handling network requests. We've seen that with simple <strong class="source-inline">GET</strong> requests in our <strong class="source-inline">RestaurantsApiService</strong> interface when we annotated our request with the <strong class="source-inline">@GET</strong> annotation:</p>
			<p class="source-code">interface RestaurantsApiService {</p>
			<p class="source-code">    @GET("restaurants.json")</p>
			<p class="source-code">    fun getRestaurants(): Call&lt;List&lt;Restaurant&gt;&gt;</p>
			<p class="source-code">}</p>
			<p>Yet apart from plain <strong class="source-inline">GET</strong> operations, such Retrofit interfaces can also handle other request types, such as <strong class="source-inline">PUT,</strong> <strong class="source-inline">POST</strong>, and <strong class="source-inline">DELETE</strong>.</p>
			<p>For example, if you need to define a request that passes some data to the server that is likely to be stored, you can use a <strong class="source-inline">POST</strong> request by adding the <strong class="source-inline">@POST</strong> annotation to your desired method:</p>
			<p class="source-code">@POST("user/edit")</p>
			<p class="source-code">fun updateUser(@Field("first_name") firstName: String): </p>
			<p class="source-code">    Call&lt;User&gt;</p>
			<p>To understand how to use Retrofit for such cases, or more advanced ones, check out the official documentation: https://square.github.io/retrofit/.</p>
		</div>
	</body></html>