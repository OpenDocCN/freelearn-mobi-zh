<html><head></head><body>
		<div><h1 id="_idParaDest-53"><em class="italic"><a id="_idTextAnchor094"/>Chapter 3</em>: Displaying Data from REST APIs with Retrofit</h1>
			<p>In this chapter, we'll be taking a break from the Jetpack libraries and focusing on adding real data within our Restaurants application by using a very popular networking<a id="_idIndexMarker178"/> library on Android called <strong class="bold">Retrofit</strong>.</p>
			<p>Retrofit is an HTTP client library that lets you create an HTTP client declaratively and abstracts most of the underlying complexity associated with handling network requests and responses. This library allows us to connect to a real web API and retrieve real data within our app.</p>
			<p>In the <em class="italic">Understanding how apps communicate with remote servers</em> section, we will focus on exploring how mobile applications retrieve and send data to remote web APIs. In the <em class="italic">Creating and populating your database with Firebase</em> section, we will create a database for our Restaurants application with the help of Firebase and fill it with JSON content.</p>
			<p>In the <em class="italic">Exploring Retrofit as an HTTP networking client for Android</em> section, we will learn what Retrofit is, and how it can help us create network requests within our Restaurants app.</p>
			<p>Lastly, in the <em class="italic">Improving the way our app handles network requests</em> section, we will tackle some common issues that occur when Android applications create async work to retrieve data from web APIs. We will identify those issues and fix them.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding how apps communicate with remote servers</li>
				<li>Creating and populating your database with Firebase</li>
				<li>Exploring Retrofit as an HTTP networking client for Android</li>
				<li>Improving the way our app handles network requests</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor095"/>Technical requirements</h1>
			<p>Building Compose-based Android projects with Retrofit usually requires just your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer installed in Android Studio.</li>
				<li>The Restaurants app code from the previous chapter.</li>
				<li>A Google account to create a Firebase project.</li>
			</ul>
			<p>The starting point for this chapter is the Restaurants application that we developed in the previous chapter. If you haven't followed the coding steps from the previous chapter, access the starting point for this chapter by navigating to the <code>Chapter_02</code> directory of this book's GitHub repository and importing the Android project entitled <code>chapter_2_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_03</code> directory: </p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_03</a>.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor096"/>Understanding how apps communicate with remote servers</h1>
			<p>Modern applications need to show real content<a id="_idIndexMarker179"/> that can change over time and need<a id="_idIndexMarker180"/> to avoid hardcoding data, as we did in the previous chapters. Let's briefly cover how they do that.</p>
			<p>Most network-connected apps use the HTTP protocol to send or receive data in the format of JSON from REST web services through a REST API. </p>
			<p>That's a lot of words we've just thrown at you, so let's break them down:</p>
			<ul>
				<li><strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) is a protocol for asynchronously fetching various resources<a id="_idIndexMarker181"/> from web servers. In our case, the resources are the data that our application needs to display.</li>
				<li><strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) is the data format of the content that's transferred in HTTP<a id="_idIndexMarker182"/> requests. It's structured, lightweight, and human-readable as it consists of key-value pairs that are easy to parse and commonly used as a suitable format for data exchange between apps and web servers. In our app, we will receive the data from the web server in such JSON format.</li>
				<li><code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code>, and so on.</li>
				<li>A <strong class="bold">REST API</strong> is an <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) that conforms to the constraints of the REST architecture<a id="_idIndexMarker185"/> and allows you to interact with REST<a id="_idIndexMarker186"/> web services. The REST API is the contract and the entry point that's used by apps to obtain or send data to and from the backend.</li>
			</ul>
			<p>Let's try to visualize<a id="_idIndexMarker187"/> the relationship<a id="_idIndexMarker188"/> between these entities:</p>
			<div><div><img src="img/B17788_03_01.jpg" alt="Figure 3.1 – Overview of HTTP communication between apps and web servers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Overview of HTTP communication between apps and web servers</p>
			<p>We want to implement something<a id="_idIndexMarker189"/> similar for our Restaurants<a id="_idIndexMarker190"/> application. For this to work, we will need a REST server. For the sake of simplicity, we will use the Firebase Realtime Database and create a database.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor097"/>Creating and populating your database with Firebase</h1>
			<p>So far, we've only used hardcoded data<a id="_idIndexMarker191"/> as the source of content for our Restaurants app. Since almost<a id="_idIndexMarker192"/> every real application uses dynamic<a id="_idIndexMarker193"/> data that comes from a backend server<a id="_idIndexMarker194"/> through a REST API, it's time to step up our game and create a database that simulates such a remote API.</p>
			<p>We can do this for free with the help of Firebase. Firebase is backed by Google and represents a <strong class="bold">Backend-as-a-Service</strong> (<strong class="bold">BaaS</strong>), which allows us to build a database<a id="_idIndexMarker195"/> very easily. We will use the Realtime Database service from Firebase without using the Firebase Android SDK. Even though such a database is not a proper REST web service, we can use its database URL as a REST endpoint and pretend that that is our REST interface, therefore simulating a real backend.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As we mentioned in the <em class="italic">Technical requirements</em> section, make sure that you have an existing Google account or that you create one beforehand.</p>
			<p>Let's start creating a database:</p>
			<ol>
				<li>Navigate to<a id="_idIndexMarker196"/> the Firebase<a id="_idIndexMarker197"/> console and log<a id="_idIndexMarker198"/> into your Google<a id="_idIndexMarker199"/> account<a id="_idIndexMarker200"/> by going to <a href="https://console.firebase.google.com/">https://console.firebase.google.com/</a>.</li>
				<li>Create a new Firebase project:</li>
			</ol>
			<div><div><img src="img/B17788_03_02.jpg" alt="Figure 3.2 – Creating a new Firebase project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Creating a new Firebase project</p>
			<ol>
				<li value="3">Input the name of your project (it should be about restaurants!) and press <strong class="bold">Continue</strong>.</li>
				<li>Optionally, in the next dialog, you can opt out from Google Analytics since we won't be using the Firebase SDK. Press <strong class="bold">Continue</strong> again. At this point, the project should be created.</li>
				<li>From the left menu, expand the <strong class="bold">Build</strong> tab, search for <strong class="bold">Realtime Database</strong>, and then select it:</li>
			</ol>
			<div><div><img src="img/B17788_03_03.jpg" alt="Figure 3.3 – Accessing Realtime Database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Accessing Realtime Database</p>
			<ol>
				<li value="6">On the newly displayed<a id="_idIndexMarker201"/> page, create a new database<a id="_idIndexMarker202"/> by clicking <strong class="bold">Create Database</strong>.</li>
				<li>In the <strong class="bold">Set up database</strong> dialog, select<a id="_idIndexMarker203"/> a location for your database<a id="_idIndexMarker204"/> and then click <strong class="bold">Next</strong>:</li>
			</ol>
			<div><div><img src="img/B17788_03_04.jpg" alt="Figure 3.4 – Setting up a Realtime Database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Setting up a Realtime Database</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If later on any network calls to your Firebase Database fail for no apparent reason, you might find yourself in a Firebase restricted location – as I am writing this chapter, because of the current situation caused by the eastern war, all internet providers from Romania are restricted and any network calls to Firebase Database are failing. If this happens to you, try selecting a different location for your Realtime Database instance.</p>
			<ol>
				<li value="8">In the same<a id="_idIndexMarker205"/> dialog, define your<a id="_idIndexMarker206"/> security<a id="_idIndexMarker207"/> rules by<a id="_idIndexMarker208"/> selecting <strong class="bold">Start in test mode</strong> and then clicking <strong class="bold">Enable</strong>.</li>
			</ol>
			<div><div><img src="img/B17788_03_05.jpg" alt="Figure 3.5 – Setting up the security rules of your database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Setting up the security rules of your database</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The default security rules<a id="_idIndexMarker209"/> for test mode allow anyone to view or modify the content within your database for the next 30 days since creation. After these 30 days, if you want to keep using the database in test mode, you will need to update the security rules by changing the timestamp values for the <code>".read"</code> and the <code>".write"</code> fields with greater timestamp values. To skip this, we will just set the <code>".read"</code> and the <code>".write"</code> fields to <code>true</code> in the next steps. However, Firebase might still restrict your access if you leave the database open for access without any rules indefinitely – that's why I recommend you visit the Firebase console and check the security rules for your database often to make sure that access was not revoked.</p>
			<p>At this point, you should be redirected to your database's main page in the <strong class="bold">Data</strong> tab:</p>
			<div><div><img src="img/B17788_03_06.jpg" alt="Figure 3.6 – Observing the Realtime Database main page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Observing the Realtime Database main page</p>
			<p>You will now notice your URL for this database: <a href="https://restaurants-db-default-rtdb.firebaseio.com/">https://restaurants-db-default-rtdb.firebaseio.com/</a>.</p>
			<p>Your URL<a id="_idIndexMarker210"/> should be similar<a id="_idIndexMarker211"/> but may differ, depending<a id="_idIndexMarker212"/> on the name you have chosen<a id="_idIndexMarker213"/> for your database.</p>
			<p>Note that the database seems to be empty; we only have an empty root node being called after our database: <code>restaurants-db-default-rtdb</code>. It's time to add data to our database.</p>
			<ol>
				<li value="9">Access the solution code for this chapter by navigating to the <code>Chapter_03</code> directory of this book's GitHub repository. Then, select the <code>restaurants.json</code> file. You can also access it by following this link: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_03/restaurants.json</a>.</li>
			</ol>
			<p>From here, download the <code>restaurants.json</code> file as we will need it shortly. To do that, press on the <strong class="bold">Raw</strong> button provided by the Github website and then right click the document that has been opened and download the JSON file by selecting <strong class="bold">Saves As</strong>.</p>
			<ol>
				<li value="10">Go back to the Firebase console, press on the three-dots menu to the right of the database URL, and select <strong class="bold">Import JSON</strong>:</li>
			</ol>
			<div><div><img src="img/B17788_03_07.jpg" alt="Figure 3.7 – Importing JSON content into Realtime Database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Importing JSON content into Realtime Database</p>
			<p>Make sure that you select the <code>restaurants.json</code> file that you've previously downloaded from the book's GitHub repository.</p>
			<ol>
				<li value="11">Wait for the<a id="_idIndexMarker214"/> page to refresh<a id="_idIndexMarker215"/> and check out the content<a id="_idIndexMarker216"/> that is populated<a id="_idIndexMarker217"/> in the database:</li>
			</ol>
			<div><div><img src="img/B17788_03_08.jpg" alt="Figure 3.8 – Observing the content's structure in our database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Observing the content's structure in our database</p>
			<p>Here, we can see that our database contains a list of <code>Restaurant</code> class: an ID, title, and description. The restaurants in our database also contain other fields that we will not need right now, so let's ignore them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you compare the structure of the content in our database with the one from the JSON file we've uploaded, we can see that it is very similar: we have a <code>restaurants</code> node that contains an array of objects, each containing consistent key-value pairs. The only exception is the presence of the indexes (0, 1, 2, and so on) for each restaurant, which were automatically created by Firebase. We should ignore these as they won't affect us.</p>
			<p>Now, even though we set the security rules to <strong class="bold">Test Mode</strong> previously, let's revisit them.</p>
			<ol>
				<li value="12">Move away from the <code>".read"</code> key's value to <code>"true"</code>:</li>
			</ol>
			<div><div><img src="img/B17788_03_09.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Updating security rules in Realtime Database</p>
			<ol>
				<li value="13">Press <code>true</code> since we are testing and not publishing anything to production.</p></li>
			</ol>
			<p>Now, we can access the database URL as a simple REST endpoint, simulating a real REST server that we can connect to. To experiment, copy the URL of your newly created database, append <code>restaurants.json</code>, and paste it into your browser. </p>
			<p>Accessing this URL should return<a id="_idIndexMarker222"/> the JSON response<a id="_idIndexMarker223"/> of our restaurants, whose structure we will cover shortly. Until then, we need<a id="_idIndexMarker224"/> to instruct our application to create<a id="_idIndexMarker225"/> HTTP requests to obtain that data from our newly created database. So, let's do that next.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor098"/>Exploring Retrofit as an HTTP networking client for Android </h1>
			<p>For the application to obtain<a id="_idIndexMarker226"/> data from our database, we need<a id="_idIndexMarker227"/> to implement an HTTP client that will send network requests to the REST API of the database.</p>
			<p>Instead of working with the HTTP library provided by default by Android, we will use the <strong class="bold">Retrofit</strong> HTTP client library, which lets you create an HTTP client that is very easy to work with.</p>
			<p>If you plan to develop an HTTP client that interfaces with a REST API, you will have to take care of a lot of things – from making connections, retrying failed requests, or caching to response parsing and error handling. Retrofit saves you development time and potential headaches as it abstracts most of the underlying complexity associated with handling network requests and responses.</p>
			<p>In this section, we will cover the following topics:</p>
			<ul>
				<li>Using Retrofit</li>
				<li>Adding Retrofit to the Restaurants application</li>
				<li>Mapping JSON to model classes</li>
				<li>Executing GET requests to the Firebase REST API</li>
			</ul>
			<p>Let's start with some basics about Retrofit!</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor099"/>Using Retrofit</h2>
			<p>Retrofit makes networking<a id="_idIndexMarker228"/> simple in Android apps. It allows us to consume web services easily, create network requests, and receive responses while reducing the boilerplate code that's usually associated with their implementation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Retrofit also allows you to easily add custom headers and request types, file uploads, mocking responses, and more.</p>
			<p>To execute network requests with Retrofit, we need the following three components:</p>
			<ul>
				<li>An interface that defines the HTTP operations that need to be performed. Such an interface can specify request types such as <code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code>, and so on.</li>
				<li>A <code>Retrofit.Builder</code> instance that creates a concrete implementation of the interface we defined previously. The Builder API allows us to define networking parameters such as the HTTP client type, the URL endpoint for the HTTP operations, the converter to deserialize the JSON responses, and so on.</li>
				<li>Model classes that allow Retrofit to know how to map the deserialized JSON objects to regular data classes.</li>
			</ul>
			<p>Enough with the theory – let's try to implement Retrofit and use the components we introduced previously in our Restaurants application.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor100"/>Adding Retrofit to the Restaurants application</h2>
			<p>We want to connect our Restaurants application<a id="_idIndexMarker229"/> to the newly created Firebase database<a id="_idIndexMarker230"/> and send HTTP network requests to it. More specifically, when the Restaurants application is launched and the <code>RestaurantsScreen</code> composable is composed, we want to get the list of restaurants at runtime and not depend on hardcoded content within the app.</p>
			<p>Let's do that with the help of Retrofit:</p>
			<ol>
				<li value="1">Inside the <code>build.gradle</code> file in the app module, add the dependency for Retrofit inside the <code>dependencies</code> block:<pre>implementation "com.squareup.retrofit2:retrofit:2.9.0"</pre></li>
				<li>After updating the <code>build.gradle</code> file, make sure to sync your project with its Gradle files. You can do that by clicking on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</li>
				<li>Create an interface that defines the HTTP operations that are executed between our app and the database. Do so by clicking on the application package, selecting <code>RestaurantsApiService</code> as the name and select <strong class="bold">Interface</strong> as the type. Inside the newly created file, add the following code:<pre>import retrofit2.Call
import retrofit2.http.GET
interface RestaurantsApiService {
    @GET("restaurants.json")
    fun getRestaurants(): Call&lt;Any&gt;
}</pre></li>
			</ol>
			<p>Let's break down the code we've just added into meaningful actions:</p>
			<ul>
				<li>Retrofit turns your HTTP API into a simple Java/Kotlin interface, so we've created a <code>RestaurantsApiService</code> interface that defines the HTTP actions we need.</li>
				<li>We've defined a <code>getRestaurants</code> method<a id="_idIndexMarker231"/> inside the interface<a id="_idIndexMarker232"/> that returns a <code>Call</code> object with an undefined response type marked by Kotlin's <code>Any type</code>. Each <code>Call</code> from <code>RestaurantsApiService</code> can make a synchronous or asynchronous HTTP request to the remote web server.</li>
				<li>We've annotated the <code>getRestaurants</code> method with the <code>@GET</code> annotation, thereby telling Retrofit that this method should execute a <code>GET</code> HTTP action to obtain data from our web server. Inside the <code>@GET</code> annotation, we passed the endpoint's path, which represents the <code>restaurants</code> node within our Firebase database. This means that when we execute this request, the <code>restaurants.json</code> endpoint will be appended to the base URL of the HTTP client.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">We mentioned that we can use our Firebase Realtime Database URL as a REST API. To access a specific node, such as the <code>restaurants</code> node of our database, we also appended the <code>.json</code> format to make sure that the Firebase database will behave like a REST API and return a JSON response.</p>
			<p>Later on, after we instantiate a Retrofit builder, the library will know how to turn our <code>getRestaurants</code> method into a proper HTTP call. </p>
			<p>But before that, you have probably noticed that the <code>getRestaurants</code> HTTP request from our interface has its response type defined as <code>Any</code>. We expect to receive the JSON content of our restaurants mapped to data classes that we can use in our code. So, let's work on that next.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor102"/>Mapping JSON to model classes</h2>
			<p>Retrofit lets you automatically serialize request<a id="_idIndexMarker233"/> bodies and deserialize response<a id="_idIndexMarker234"/> bodies. In our case, we're interested in deserializing the response body, from JSON into Java/Kotlin objects.</p>
			<p>To deserialize the JSON response, we will instruct Retrofit to use the GSON deserialization library, but until then, let's have a look at the JSON response that our database returns. Remember that we imported a JSON file called <code>restaurants.json</code> when we populated the Firebase database.</p>
			<p>Let's open that file with any text editor and observe its structure:</p>
			<div><div><img src="img/B17788_03_10.jpg" alt="Figure 3.10 – The JSON structure of the Firebase database's content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – The JSON structure of the Firebase database's content</p>
			<p>We can observe the following elements in the JSON response structure:</p>
			<ul>
				<li>It contains an array of JSON objects marked by the <code>[</code> and <code>]</code> identifiers.</li>
				<li>The contents of the JSON array's element are marked by the <code>{</code> and <code>}</code> identifiers and they enclose the JSON object structure of a restaurant.</li>
				<li>The restaurant JSON object contains four key-value pairs, separated by the <code>, </code>separator.</li>
			</ul>
			<p>The response from our database<a id="_idIndexMarker235"/> will be of type <code>List&lt;?&gt;</code> since the response<a id="_idIndexMarker236"/> holds an array of JSON objects. The main question that remains is, what data type should our application expect inside that list?</p>
			<p>To answer that, we must inspect the structure of the restaurant JSON object a bit closer:</p>
			<div><div><img src="img/B17788_03_11.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – The structure of the restaurant JSON object</p>
			<p>Here, we can see that the JSON restaurant has four key-value pairs that refer to the <code>id</code>, <code>title</code>, <code>description</code>, and <code>shutdown</code> statuses of the corresponding restaurant. This structure is similar to our <code>Restaurant.kt</code> data class within the project:</p>
			<pre>data class Restaurant(val id: Int,
                      val title: String,
                      val description: String,
                      var isFavorite: Boolean = false)</pre>
			<p>Our <code>Restaurant</code> also contains the <code>id</code>, <code>title</code>, and <code>description</code> fields. We are not interested in the <code>shutdown</code> status for now, so it's tempting to use the <code>Restaurant</code> class as the model for our response, thus making our <code>getRestaurants()</code> method in <code>RestaurantsApiService</code> return <code>List&lt;Restaurant&gt;</code> as the response of the request.</p>
			<p>The issue with this approach is that we need to tell Retrofit to match the <code>r_id</code> key's value with our <code>id</code> field. The same goes for <code>r_title</code>, which should be matched with the <code>title</code> field and so on. We can approach this in two ways:</p>
			<ul>
				<li>Rename the <code>Restaurant</code> data class fields<a id="_idIndexMarker237"/> so that they match the response<a id="_idIndexMarker238"/> keys: <code>r_id</code>, <code>r_title</code>, and so on. In this case, the deserialization will automatically match our fields with the fields from the JSON objects since the JSON keys are identical to the fields' names.</li>
				<li>Annotate the <code>Restaurant</code> data class fields with special serialization matchers that tell Retrofit which keys should be matched with each field. This won't change the variable names.</li>
			</ul>
			<p>The first approach is bad because our <code>Restaurant</code> data class would end up with fields that contain underscore naming dictated by the server. It would also not comply with Kotlin's CamelCase guideline for defining field variables anymore.</p>
			<p>Let's choose the second approach, where we specify the serialization keys ourselves. To do that, we will tell Retrofit to deserialize the JSON with the GSON deserialization library, which is a powerful framework for converting JSON strings into Java/Kotlin objects and vice versa:</p>
			<ol>
				<li value="1">First, we need to add the GSON library dependency to mark our fields with custom serialization keys. Inside the <code>build.gradle</code> file in the app module, add the dependency for GSON inside the <code>dependencies</code> blo<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/>ck:<pre>implementation "com.google.code.gson:gson:2.8.6"</pre></li>
				<li>After updating the <code>build.gradle</code> file, make sure to sync your project with its Gradle files. You can do that by clicking on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</li>
				<li>Inside <code>Restaurant.kt</code>, add the <code>@SerializedName</code> annotation for each field and specify the corresponding serialization keys from the JSON structure:<pre><strong class="bold">import com.google.gson.annotations.SerializedName</strong>
data class Restaurant(
    <strong class="bold">@SerializedName("r_id")</strong>
    val id: Int,
    <strong class="bold">@SerializedName("r_title")</strong>
    val title: String,
    <strong class="bold">@SerializedName("r_description")</strong>
    val description: String,
    var isFavorite: Boolean = false)</pre></li>
			</ol>
			<p>By doing so, we've made sure that Retrofit will correctly match each of the JSON key's values with our corresponding<a id="_idIndexMarker239"/> field inside the <code>Restaurant</code> data class while also matching<a id="_idIndexMarker240"/> the data type: </p>
			<ul>
				<li>The <code>r_id</code> key matches the <code>id</code> field. The <code>r_id</code> key has a whole number as its value in the JSON structure, so we stored this key's value in the <code>id: Int</code> field.</li>
				<li>The <code>r_title</code> key matches the <code>title</code> field. The <code>r_title</code> key has text as its value marked with the <code>"</code> and <code>"</code> identifiers, so we stored this key's value in the <code>title: String</code> field.</li>
				<li>The <code>r_description</code> key matches the <code>description</code> field. The <code>r_description</code> key has text as its value marked with the <code>"</code> and <code>"</code> identifiers, so we stored this key's value in the <code>description: String</code> field.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">For now, we are using the Restaurant data model both as the API response model and as the domain model that's used throughout the application. Architecturally, this practice is not recommended, and we will cover why this is the case and fix it in <a href="B17788_08_ePub.xhtml#_idTextAnchor285"><em class="italic">Chapter 8</em></a>, <em class="italic">Getting Started with Clean Architecture in Android</em>.</p>
			<ol>
				<li value="4">Update the <code>getRestaurants()</code> method inside <code>RestaurantsApiService</code> so that it returns a <code>Call</code> object from the server with the type parameter that matches the response that is expected. In our case, that would be <code>List&lt;Restaurant&gt;</code>:<pre>interface RestaurantsApiService {
    @GET("restaurants.json")
    fun getRestaurants(): <strong class="bold">Call&lt;List&lt;Restaurant&gt;&gt;</strong>
}</pre></li>
			</ol>
			<p>With that, our Retrofit API interface<a id="_idIndexMarker241"/> has been defined to receive the content<a id="_idIndexMarker242"/> of the Restaurants database from our Firebase database. The only step left is to configure a Retrofit builder instance and execute the request.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor105"/>Executing GET requests to the Firebase REST API</h2>
			<p>Let's configure the last component that's needed<a id="_idIndexMarker243"/> to perform requests with<a id="_idIndexMarker244"/> Retrofit – the <code>Retrofit.builder</code> object:</p>
			<ol>
				<li value="1">First, we need to add the GSON Converter library dependency for Retrofit so that Retrofit deserializes the JSON response while following the GSON serialization annotations we added previously. Inside the <code>build.gradle</code> file in the app module, add the dependency for the<a id="_idTextAnchor106"/> Retrofit GSON converter inside the <code>dependencies</code> block:<pre>implementation "com.squareup.retrofit2:converter-
    gson:2.9.0"</pre></li>
				<li>After updating the <code>build.gradle</code> file, make sure to sync your project with its Gradle files. You can do that by clicking on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</li>
				<li>Inside <code>RestaurantsViewModel</code>, add a <code>restInterface</code> variable<a id="_idIndexMarker245"/> of type <code>RestaurantsApiService</code> and create an <code>init</code> block where we will instantiate<a id="_idIndexMarker246"/> the <code>Retrofit.builder<a id="_idTextAnchor107"/></code> object:<pre>class RestaurantsViewModel(…) : ViewModel() {
    <strong class="bold">private var restInterface: RestaurantsApiService</strong>
    val state = mutableStateOf(
        dummyRestaurants.restoreSelections()
    )
    <strong class="bold">init {</strong>
<strong class="bold">        val retrofit: Retrofit = Retrofit.Builder()</strong>
<strong class="bold">            .addConverterFactory(</strong>
<strong class="bold">                GsonConverterFactory.create()</strong>
<strong class="bold">            )</strong>
<strong class="bold">            .baseUrl(</strong>
<strong class="bold">                "https://restaurants-db-default</strong>
<strong class="bold">                        -rtdb.firebaseio.com/"</strong>
<strong class="bold">            )</strong>
<strong class="bold">            .build()</strong>
<strong class="bold">        restInterface = retrofit.create(</strong>
<strong class="bold">            RestaurantsApiService::class.java</strong>
<strong class="bold">        )</strong>
<strong class="bold">    }</strong>
    […]
}</pre></li>
			</ol>
			<p>We've added all the necessary pieces for our networking client. Let's break this code down:</p>
			<ul>
				<li>First, we've defined a <code>restInterface</code> variable of type <code>RestaurantsApiService</code> that we will call upon to execute the desired network requests. At this point, the <code>restInterface</code> variable holds no value.</li>
				<li>We've added an <code>init</code> block to instantiate<a id="_idIndexMarker247"/> the Retrofit builder object. As the primary<a id="_idIndexMarker248"/> constructor can't contain any code, we are placing the initialization code in an initializer block prefixed with the <code>init</code> keyword.</li>
				<li>We've instantiated a <code>retrofit: Retrofit</code> variable with the <code>Retrofit.Builder</code> accessor and specified the following:<a id="_idTextAnchor108"/></li>
				<li>A <code>GsonConverterFactory</code> to explicitly tell Retrofit that we want the JSON to be deserialized with the GSON converter, following the <code>@Serialized</code> annotations we specified in the <code>Restaurant</code> data class.</li>
				<li>A <code>baseUrl</code> for all the requests that are to be executed – in your case, replace this URL with the URL of your Firebase database.</li>
				<li>Finally, we called <code>.create()</code> on the previously obtained <code>Retrofit</code> object and passed our interface with the desired requests: <code>RestaurantsApiService</code>. Behind the scenes, Retrofit creates a concrete implementation of our interface that will handle all the networking logic, without us having to worry about it. We store this instance from Retrofit inside our <code>restInterface</code> variable.</li>
			</ul>
			<p>Now, we can execute requests – in our case, the request to get the list of restaurants.</p>
			<ol>
				<li value="4">Inside <code>RestaurantsViewModel</code>, add the <code>getRestaurants</code> method:<pre>fun getRestaurants() {
    restInterface.getRestaurants().execute().body()
        ?.let { restaurants -&gt;
            state.value = restaurants.restoreSelections()
        }
}</pre></li>
			</ol>
			<p>We've added all the necessary<a id="_idIndexMarker249"/> steps for our networking request<a id="_idIndexMarker250"/> to be executed. Let's break this code down:</p>
			<ol>
				<li value="1">We've obtained a <code>Call</code> object called <code>Call&lt;List&lt;Restaurant&gt;&gt;</code> from our Retrofit <code>restInterface</code> variable by calling the <code>getRestaurants()</code> interface method. The <code>Call</code> object represents the invocation of a Retrofit method that sends network requests and receives a response. The type parameter of the <code>Call</code> object matches the response type; that is, <code>&lt;List&lt;Restaurant&gt;&gt;</code>.</li>
				<li>On the previously obtained <code>Call</code> object, we called <code>execute()</code>. The <code>execute()</code> method is the most simple approach to starting a network request with Retrofit as it runs the request synchronously on the main thread (the UI thread) and blocks it until the response arrives. No network request should block the UI thread yet, though we will fix this soon.</li>
				<li>The <code>execute()</code> method returns a Retrofit <code>Response</code> object that allows us to see if the response was successful and obtain the resulting body.</li>
				<li>The <code>body()</code> accessor returns a nullable list of type <code>List&lt;Restaurant&gt;&gt;?</code>. We apply the Kotlin <code>let</code> extension function and name the list <code>restaurants</code>.</li>
				<li>We pass the resulting <code>restaurants</code> list to our <code>state</code> object after restoring the selections in case of system-initiated process death, similar to what we did for the initial state value.</li>
			</ol>
			<p>With that, we've instructed our <code>ViewModel</code> on how to obtain<a id="_idIndexMarker251"/> the list of restaurants from the database<a id="_idIndexMarker252"/> and to pass this result to our screen's state. One issue that we will have to address later is that we are not catching any errors that may be thrown by Retrofit if the request fails. Until then, let's focus on updating the state with the new result.</p>
			<p>5.	Inside <code>RestaurantsViewModel</code>, we need to update the state's initial value so that it contains an empty list. This is because, when the screen is first displayed, we no longer have restaurants to render – we will get them later in the network request. Update the initial value of the <code>state</code> object by rem<a id="_idTextAnchor109"/>oving <code>dummyList</code> and placing an <code>emptyList()</code> instead:</p>
			<pre>val state = mutableStateOf(<strong class="bold">emptyList&lt;Restaurant&gt;())</strong></pre>
			<ol>
				<li value="6">Inside the <code>Restaurant.kt</code> file, remove the <code>dummyRestaurants</code> list since we will be obtaining the restaurants at runtime through the previously defined request.</li>
				<li>We want to trigger the network request to obtain the restaurants from the server. Inside <code>RestaurantsScreen.kt</code>, update the <code>RestaurantsScreen</code> composable function so that it calls the <code>getRestaurants()</code> method of <code>viewModel</code>, which will trigger the network request to obtain the restaurants from the server:<pre>@Composable
fun RestaurantsScreen() {
    val viewModel: RestaurantsViewModel = viewModel()
    <strong class="bold">viewModel.getRestaurants()</strong>
    LazyColumn( … ) { … }
}</pre></li>
			</ol>
			<p>By calling <code>viewModel.getRestaurants()</code>, we are trying to load the list of restaurants when the <code>RestaurantsScreen</code> composable is composed<a id="_idIndexMarker253"/> for the first time. This practice is not recommended and we will <a id="_idIndexMarker254"/>see in the following steps why that is and how we can fix it.</p>
			<ol>
				<li value="8">Add internet permission inside the <code>AndroidManifest.xml</code> file:<pre>&lt;manifest xmlns:android="…"
    package="com.codingtroops.restaurantsapp"&gt;
    <strong class="bold">&lt;uses-permission</strong>                                   <strong class="bold">android:name="android.permission.INTERNET" /&gt;</strong>
      &lt;application&gt; … &lt;/application&gt;
&lt;/manifest&gt;</pre></li>
				<li>Run the application by clicking the <strong class="bold">Run</strong> button.</li>
			</ol>
			<p>Unfortunately, the application<a id="_idIndexMarker255"/> will most likely crash. If we check <strong class="bold">Logcat</strong>, we will notice an exception stack similar to the following:</p>
			<div><div><img src="img/B17788_03_12.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Crash stack trace for executing a network request on the main thread</p>
			<p>The exception that's been thrown here is a <code>NetworkOnMainThreadException</code> and it's clear what's wrong with our code: we are executing a network request on the Main thread.</p>
			<p>This has happened because with the Android Honeycomb SDK, <em class="italic">executing network requests on the Main thread is forbidden</em> because the UI of the application will freeze until the response from the server<a id="_idIndexMarker256"/> arrives, making the app unusable<a id="_idIndexMarker257"/> in that timeframe. In other words, we can't and shouldn't use the <code>.execute()</code> method of a Retrofit <code>Call</code> object because the request will run synchronously on the Main thread. </p>
			<p>Instead, we can use an alternative that not only will execute the requests asynchronously and on a separate thread, but also allow us to handle any errors that are thrown by Retrofit.</p>
			<ol>
				<li value="10">In the <code>getRestaurants()</code> method of <code>ViewModel</code>, replace the <code>.execute()</code> call with <code>.enqueue()</code>:<pre>fun getRestaurants() {
   restInterface.getRestaurants<strong class="bold">().enqueue(</strong>
<strong class="bold">    object : Callback&lt;List&lt;Restaurant&gt;&gt; {</strong>
<strong class="bold">        override fun onResponse(</strong>
<strong class="bold">            call: Call&lt;List&lt;Restaurant&gt;&gt;,</strong>
<strong class="bold">            response: Response&lt;List&lt;Restaurant&gt;&gt;</strong>
<strong class="bold">        ) {</strong>
<strong class="bold">            response.body()?.let { restaurants -&gt;</strong>
<strong class="bold">                state.value = </strong>
<strong class="bold">                    restaurants.restoreSelections()</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
<strong class="bold">        override fun onFailure(</strong>
<strong class="bold">            call: Call&lt;List&lt;Restaurant&gt;&gt;, t: Throwable</strong>
<strong class="bold">        ) {</strong>
<strong class="bold">            t.printStackTrace()</strong>
<strong class="bold">        }</strong>
<strong class="bold">    })</strong>
}</pre></li>
			</ol>
			<p>When adding the missing imports for the <code>Call</code>, <code>Callback</code> and <code>Response</code> classes, make sure<a id="_idIndexMarker258"/> that you're adding the Retrofit2 imports<a id="_idIndexMarker259"/> that start off like this: <code>import retrofit2.*</code>.</p>
			<p>Getting back to the code that we've added, let's look at it in more detail:</p>
			<ul>
				<li>On the <code>Call</code> object that we obtained from our <code>restInterface.getRestaurants()</code> method, we called the <code>.enqueue()</code> function. The <code>enqueue()</code> call is a better alternative to <code>.execute()</code> since it runs the network request asynchronously on a separate thread, so it will no longer run on the UI thread and it won't block the UI.</li>
				<li>The <code>.enqueue()</code> function receives a <code>Callback</code> object as an argument that allows us to listen for success or failure callbacks. The <code>Callback</code> object's type parameter defines the expected <code>Response</code> object. Since we expect a response of type <code>&lt;List&lt;Restaurant&gt;&gt;</code>, the returned <code>Callback</code> type is defined as <code>Callback&lt;List&lt;Restaurant&gt;&gt;</code>.</li>
				<li>We've implemented the required <code>object : Callback&lt;List&lt;Restaurant&gt;&gt;</code> and implemented its two callbacks:</li>
				<li><code>onResponse()</code>, which is the success callback that's invoked when the network request succeeds. It provides us with the initial <code>Call</code> object, but more importantly the <code>Response</code> object; that is, <code>Response&lt;List&lt;Restaurant&gt;&gt;</code>. Inside this callback, we get the body from the response and update the value of the <code>state</code> variable, just like we did with <code>execute()</code>.</li>
				<li><code>onFailure()</code>, which is the failure callback. It's invoked when a network exception occurs while talking to the server or when an unexpected exception occurs while creating the request or processing<a id="_idIndexMarker260"/> the response. This callback provides<a id="_idIndexMarker261"/> us with the initial <code>Call</code> object and the <code>Throwable</code> exception that was intercepted and whose stack trace we print.</li>
			</ul>
			<p>Now, you can run the application. It shouldn't crash anymore since calling <code>enqueue()</code> allowed the request to run on a separate thread so that we could safely wait for the response without blocking the UI.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a good practice, make sure that when you're making requests with Retrofit, you always call the <code>enqueue()</code> function and not <code>execute()</code>. You want your users to not experience crashes and to be able to interact with the app while they're waiting for the network response.</p>
			<p>Yet even with this addition, there are still two concerning issues with our code. Were you able to notice them? Let's try to identify them.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor110"/>Improving the way our app handles network requests</h1>
			<p>Our application now successfully obtains data from the server dynamically, at runtime. Unfortunately, we have made two major mistakes in our code, and both<a id="_idIndexMarker262"/> are related to how the app handles<a id="_idIndexMarker263"/> the requests. Let's identify them:</p>
			<ul>
				<li>First, we are not canceling our network request as a cleanup measure. If our UI component that is bound to <code>RestaurantsViewModel</code> – in our case, <code>MainActivity</code> – is destroyed before the response from the server can arrive (for example, if the user navigates to another activity), we could potentially create a memory leak. This is because our <code>RestaurantsViewModel</code> would still be tied to the <code>Callback&lt;List&lt;Restaurant&gt;&gt;</code> object, which waits for the server's response. Due to this, the garbage collector won't free up the memory associated with both of their instances.</li>
				<li>Secondly, we are not triggering<a id="_idIndexMarker264"/> the network request from a controll<a id="_idTextAnchor111"/>ed<a id="_idIndexMarker265"/> environment. The <code>viewModel.getRestaurants()</code> method is called inside the <code>RestaurantsScreen()</code> composable function without any special considerations. This means that every time the UI is recomposed, the composable will ask <code>ViewModel</code> to execute network requests, resulting in possible multiple and redundant requests.</li>
			</ul>
			<p>Let's focus on the first issue for now. </p>
			<h3>Canceling network requests as a cleanup measure</h3>
			<p>The main problem in our <code>RestaurantsViewModel</code> is that we are enqueueing a <code>Call</code> object and we're waiting<a id="_idIndexMarker266"/> for the response through the <code>Callback</code> object, but we are never canceling that enqueued <code>Call</code>. We should cancel it when the host <code>Activity</code> or <code>ViewModel</code> is cleared to prevent memory leaks. Let's do that here:</p>
			<ol>
				<li value="1">Inside <code>RestaurantsViewModel</code>, define a class variable of type <code>Call</code> with the <code>List&lt;Restaurant&gt;&gt;</code> type parameter. Call this variable <code>restaurantsCall</code> as we will use it to hold a reference to our enqueued <code>Call</code> object:<pre>class RestaurantsViewModel(…): ViewModel() {
    private var restInterface: RestaurantsApiService
    val state = […]
    <strong class="bold">private lateinit var restaurantsCall: </strong>
<strong class="bold">        Call&lt;List&lt;Restaurant&gt;&gt;</strong>
    init {…}
   […]
}</pre></li>
			</ol>
			<p>We've marked <code>restaurantsCall</code> as a <code>lateinit</code> variable to instantiate it later when we perform the network request.</p>
			<ol>
				<li value="2">Inside the <code>getRestaurants()</code> method of <code>RestaurantsViewModel</code>, assign the <code>Call</code> object that<a id="_idIndexMarker267"/> you obtained from the <code>restInterface.getRestaurants()</code> method call to the <code>restaurantsCall</code> member variable and call <code>enqueue()</code> on it:<pre>fun getRestaurants() {
    <strong class="bold">restaurantsCall = restInterface.getRestaurants()</strong>
    <strong class="bold">restaurantsCall.enqueue</strong>(object : 
 Callback&lt;List&lt;Restaurant&gt;&gt; {…})
}</pre></li>
				<li>Inside <code>RestaurantsViewModel</code>, override the <code>onCleared()</code> method and call the <code>cancel()</code> method of the <code>restaurantCall</code> object:<pre>override fun onCleared() {
    super.onCleared()
    restaurantsCall.cancel()
}</pre></li>
			</ol>
			<p>The <code>onCleared()</code> callback method is provided by the Jetpack <code>ViewModel</code> and is called just before <code>ViewModel</code> is destroyed as a consequence of the attached activity/fragment or composable being destroyed or removed from the composition.</p>
			<p>This callback represents the perfect opportunity for us to cancel any ongoing work – or in our case, to cancel the pending <code>Call</code> object that's enqueued in the <code>restaurantCall</code> object. This way, we prevent leaking memory and therefore fix the fi<a id="_idTextAnchor112"/>rst issue in our code.</p>
			<p>Now, it's time to focus<a id="_idIndexMarker268"/> on the second issue, where the <code>RestaurantsScreen()</code> composable calls the <code>viewModel.getRestaurants()</code> method without any special considerations. </p>
			<h3>Triggering network requests from a controlled environment</h3>
			<p>The <code>viewModel.getRestaurants()</code> method is called because we want to apply a <strong class="bold">side effect</strong> in our UI. A side effect is a change<a id="_idIndexMarker269"/> that's made to the state of the application that usually happens outside<a id="_idIndexMarker270"/> the scope of a composable function. In our case, the side effect<a id="_idIndexMarker271"/> is that we need to start loading the restaurants for the first time when the user enters the screen. </p>
			<p>As a rule of thumb, composables should be side-effect free, but in our application, we need to know when to trigger the network request, and what better place than the moment when our UI is initially composed?</p>
			<p>The problem with the existing approach of simply calling a method on <code>ViewModel</code> from the composable layer is that the Compose UI can be recomposed many times on the screen. For example, when an animation is rendered, the Compose UI is recomposed many times to execute the animation's keyframes. On every recomposition of the UI, our composable calls the <code>getRestaurants()</code> method on <code>RestaurantsViewModel</code>, which, in turn, executes network requests to obtain the restaurants from the server, which could result in multiple and redundant requests.</p>
			<p>To prevent this issue from happening, Compose has the right tool for us to handle side-effects<a id="_idIndexMarker272"/> efficiently: the <strong class="bold">Effects</strong> API.</p>
			<p>An <em class="italic">effect</em> is a composable function that, instead of emitting UI elements, causes side effects that run when a composition process completes. Such composables are based on the Kotlin Coroutine API, which allows you to run async work in their bodies. However, we will disregard coroutines for now as we will cover them in <a href="B17788_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Handling Async Operations with Coroutines</em>.</p>
			<p>In Compose, there are many types of effect composables that we can use but we will not go too deep into that. In our case, though, a suitable effect could be the <code>LaunchedEffect</code> composable since it allows us to run a task only once when it first enters composition.</p>
			<p>The signature of <code>LaunchedEffect</code> is simple – it contains a <code>key1</code> parameter and a <code>block</code> parameter where we can execute our code. For now, we should ignore the Coroutine terminology<a id="_idIndexMarker273"/> and just think of the <code>block</code> function parameter<a id="_idIndexMarker274"/> as a block of code that can be executed asynchronously:</p>
			<div><div><img src="img/B17788_03_13.jpg" alt="Figure 3.13 – The signature of the LaunchedEffect composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – The signature of the LaunchedEffect composable</p>
			<p>When <code>LaunchedEffect</code> enters the composition process, it runs the <code>block</code> parameter function, which is passed as an argument. The execution of the block will be canceled if <code>LaunchedEffect</code> leaves the composition. If <code>LaunchedEffect</code> is recomposed with different keys that have been passed to the <code>key1</code> parameter, the existing execution of the block of code will be canceled and a new iteration of execution will be launched.</p>
			<p>Now that we know how <code>LaunchedEffect</code> works, we can agree that it seems a viable solution for our issue, at least for now: we want to make sure that the call to <code>ViewModel</code> is only executed once on the initial composition, so <code>LaunchedEffect</code> seems to suffice our needs.</p>
			<p>Let's add a <code>LaunchedEffect</code> to prevent our UI from asking for restaurants from <code>ViewModel</code> repeatedly on every recomposition:</p>
			<ol>
				<li value="1">Inside the <code>RestaurantsScreen</code> composable, wrap the <code>viewModel.getRestaurants()</code> call in a <code>LaunchedEffect</code> composable:<pre>@Composable
fun RestaurantsScreen() {
    val viewModel: RestaurantsViewModel = viewModel()
    <strong class="bold">LaunchedEffect(key1 = "request_restaurants") {</strong>
        viewModel.getRestaurants()
    <strong class="bold">}</strong>
    LazyColumn(…) { … }
}</pre></li>
			</ol>
			<p>To implement the <code>LaunchedEffect</code> composable, we did the following:</p>
			<ul>
				<li>We passed a <code>String</code> hardcoded value of <code>"request_restaurants"</code> to the <code>key1</code> parameter. We passed a hardcoded<a id="_idIndexMarker275"/> value to the <code>key1</code> argument because we want<a id="_idIndexMarker276"/> the block of code passed inside the <code>LaunchedEffect</code> composable to not execute on every recomposition. We could have passed any constant to <code>key1</code>, yet what's important here is that the value shouldn't change over time. </li>
				<li>We passed our code that calls the <code>getRestaurants()</code> method on our <code>ViewModel</code> inside the <code>block</code> parameter of the effect. Since the <code>block</code> parameter is the last parameter of the <code>LaunchedEffect</code> composable and is a function, we used the trailing lambda syntax.</li>
			</ul>
			<ol>
				<li value="2">Run the application. Now, the code inside <code>LaunchedEffect</code> should only be executed once.</li>
			</ol>
			<p>Yet even with this addition, our code still has an issue. If you try rotating the emulator or device you're testing with, you will trigger a configuration change and another network will be executed. But we mentioned previously that <code>LaunchedEffect</code> will only execute the <code>viewModel.getRestaurants()</code> call once, so why is this happening?</p>
			<p><code>LaunchedEffect</code> works fine – the issue lies in the activity being destroyed on configuration change. If the activity is destroyed, the UI will be composed again from scratch, and for all it knows, <code>LaunchedEffect</code> will run the code inside the <code>block</code> parameter for the first time.</p>
			<p>Can you think of a better alternative to get around the issue of the activity being destroyed due to configuration changes?</p>
			<p>An alternative would be to use the <code>ViewModel</code> component because it survives configuration changes. If we trigger<a id="_idIndexMarker277"/> the request only once in <code>RestaurantsViewModel</code>, we no longer care<a id="_idIndexMarker278"/> if a configuration change occurs – the request will not be executed again. Follow these steps:</p>
			<ol>
				<li value="1">Inside <code>RestaurantsViewModel</code>, locate the <code>init</code> block and inside it, call <code>getRestaurants()</code>:<pre>init {
    val retrofit: Retrofit = Retrofit.Builder().[…].build()
    restInterface = retrofit.create(
        RestaurantsApiService::class.java
    )
    <strong class="bold">getRestaurants()</strong>
}</pre></li>
			</ol>
			<p>The <code>init</code> block is called once when an instance of <code>ViewModel</code> is created, so placing our network request here is a safer bet than at the UI level in any composable. Make sure you've placed the <code>getRestaurants()</code> call after the instantiation of the <code>restInterface</code> variable since the <code>getRestaurants()</code> method depends on that variable being ready to work.</p>
			<ol>
				<li value="2">Still inside <code>RestaurantsViewModel</code>, navigate to the <code>getRestaurants()</code> method and mark it as <code>private</code>:<pre><strong class="bold">private</strong> fun getRestaurants() {
    …
}</pre></li>
			</ol>
			<p>We no longer need to expose this method publicly to the UI since it's now only called inside <code>ViewModel</code>.</p>
			<ol>
				<li value="3">Inside the <code>RestaurantsScreen</code> composable, remove the <code>LaunchedEffect</code> composable function with all the code inside it since we no longer need it.</li>
				<li>Run the application. The network request should not be executed again when a configuration change is made since the <code>RestaurantsViewModel</code> instance is preserved and the code inside its <code>init</code> block is not executed again.</li>
			</ol>
			<p>We've taken quite a few steps<a id="_idIndexMarker279"/> to make sure that our application handles<a id="_idIndexMarker280"/> network requests correctly, and this was a great first step toward creating a modern application.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor113"/>Summary</h1>
			<p>In this chapter, we learned how mobile apps communicate with remote web APIs using HTTP connections and REST APIs. Then, we created a database for our Restaurants application with the help of Firebase and populated it with content.</p>
			<p>After that, we explored what Retrofit is and how it abstracts the complexity associated with handling network requests and responses within HTTP connections between apps and web APIs. </p>
			<p>Then, we executed a network request with Retrofit in our Restaurants application and learned how the JSON content that is sent by the server can be parsed or deserialized by our Retrofit networking client. We also learned how to correctly wait for network responses and how to notify the application when responses arrive.</p>
			<p>Finally, we solved some common issues that occur when our applications communicate with web APIs asynchronously to retrieve data, especially in the context of Compose.</p>
			<p>In the next chapter, we'll explore a very efficient tool in Android for async work that comes bundled with Kotlin: coroutines!</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor114"/>Further reading</h1>
			<p>With the help of custom annotations inside the Retrofit interface, this library hides most of the complexity associated with handling network requests. We've seen that with simple <code>GET</code> requests in our <code>RestaurantsApiService</code> interface when we annotated our request with the <code>@GET</code> annotation:</p>
			<pre>interface RestaurantsApiService {
    @GET("restaurants.json")
    fun getRestaurants(): Call&lt;List&lt;Restaurant&gt;&gt;
}</pre>
			<p>Yet apart from plain <code>GET</code> operations, such Retrofit interfaces can also handle other request types, such as <code>PUT,</code> <code>POST</code>, and <code>DELETE</code>.</p>
			<p>For example, if you need to define a request that passes some data to the server that is likely to be stored, you can use a <code>POST</code> request by adding the <code>@POST</code> annotation to your desired method:</p>
			<pre>@POST("user/edit")
fun updateUser(@Field("first_name") firstName: String): 
    Call&lt;User&gt;</pre>
			<p>To understand how to use Retrofit for such cases, or more advanced ones, check out the official documentation: https://square.github.io/retrofit/.</p>
		</div>
	</body></html>