- en: Chapter 7. Dealing with Optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In day-to-day Swift application development, we need to deal with optionals
    as some of the methods that we need to call may return some values or none. This
    chapter explores the concept of optionals and provides different techniques to
    deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics with coding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Optional types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwrapping optionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coalescing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with optionals functionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmap` and `apply` for multiple functional mapping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our day-to-day application development, we encounter situations where we
    expect to receive a value but we do not receive it. For instance, suppose that
    we have a list of items and we need to search for a particular value in the list.
    The particular value that we are looking for might not be in the list. We have
    already encountered a lot of these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples can be calling a web service and receiving a JSON payload without
    the fields that we are looking for or querying a database and not receiving the
    expected values.
  prefs: []
  type: TYPE_NORMAL
- en: What are we going to receive when the value is not there and how will we handle
    it?
  prefs: []
  type: TYPE_NORMAL
- en: In programming languages such as C, it is possible to create a variable without
    giving it a value. If we try to use the variable before assigning a value, we
    would get an undefined value.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, we can define a variable without giving it a value, but we cannot
    use it without assigning some value to it. In other words, we need to initialize
    it before being able to use it. This feature of Swift ensures that we will not
    receive undefined values.
  prefs: []
  type: TYPE_NORMAL
- en: What about the scenarios where we need to define a variable and we do not know
    what is going to be the value?
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these kinds of scenarios, Swift provides `Optional` types that can
    have `Some` or `None` values and can be used in situations where a value may be
    absent.
  prefs: []
  type: TYPE_NORMAL
- en: 'A question mark ( `?` ) is used to define a variable as optional. The following
    example presents an example of optional definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have defined a variable that is of an optional type. The
    `String?` type is an optional type that may wrap a `String` value in it.
  prefs: []
  type: TYPE_NORMAL
- en: We were able to assign `nil` to `optionalString`. If we try to assign `nil`
    to any non-optional type in Swift, the compiler will complain about it unlike
    other languages such as Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the following example, the compiler will complain that `nil
    cannot be assigned to type ''String''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The compile time checking of non-existent values in Swift to prevent runtime
    errors is one of the features of type safety in Swift. Type safety makes it easier
    to catch problems in the earlier stages of development. Let''s examine an example
    in Objective-C to see the real value of optionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Suppose that we have a list for which we initiate a search by calling `searchItem`.
    In this case, our `searchItem` method takes `NSString` and returns `NSString`.
    The result of this call can be `nil`. If we use the returned `NSString` and try
    to append it to another `NSString`, it will compile but may crash the application
    if `searchItem` is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: We could remedy this problem by checking whether `searchedItem` is not `nil`
    before using it. However, there might be some cases where other developers forgot
    to do it or did not see the necessity of it.
  prefs: []
  type: TYPE_NORMAL
- en: For sure, it is safer to receive compile time complaints about these kinds of
    usages. As Swift is type-safe, we will not encounter any such surprises during
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have understood why we need an optional type, but what is it and how
    is it defined?
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, `Optional` is an `enum` with two cases in it—one is `None`
    and the other one is `Some` with its associated generic value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unwrapping optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we know that optionals wrap values in themselves. Wrapping means that
    the actual data is stored within an outer structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we print `optionalString` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `Optional("A String literal")`.
  prefs: []
  type: TYPE_NORMAL
- en: How will we unwrap optionals and use the values that we need? There are different
    methods to unwrap optionals that we will go through in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Force unwrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To unwrap optionals, the easiest and most dangerous method that we can use is
    force unwrapping. In short, `!` can be used to force unwrap the value from `Optional`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example forcefully unwraps `optionalString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Force unwrapping the optionals may cause errors if the optional does not have
    a value, so it is not recommended to use this approach as it is very hard to be
    sure if we are going to have values in optionals in different circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, force unwrapping eliminates the benefits of type safety and may cause
    our applications to crash during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: nil checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Force unwrapping an `Optional` could crash our applications; to eliminate the
    crashing problem, we can check whether the variable is not `nil` before unwrapping
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents a simple `nil` checking approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This approach is safe in compile and runtime but may cause problems during editing.
    For instance, if we accidentally move the `print` line outside the `if` block,
    the compiler is not going to complain and it may crash our application during
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The better approach would be to use the Optional binding technique to find out
    whether an `Optional` contains a value or not. If it contains a value, we will
    be able to unwrap it and put it into a temporary constant or variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents optional binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `if let familyName = nilName` statement will assign the `Optional` value
    to a new variable named `familyName`. The right-hand side of the assignment has
    to be an `Optional`, otherwise, the compiler will issue an error. Also, this approach
    ensures that we are using the unwrapped temporary version so it is safe.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is also called if-let binding and is useful to unwrap `Optionals`
    and access the underlying values, but if we get into a complex structure of nested
    objects such as a `JSON` payload, the syntax becomes cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to have lots of nested `if-let` expressions in these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To overcome this issue, we can use multiple Optional bindings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This syntax makes the code more readable but still is not the best approach
    when we need to bind multiple levels of optionals. In the following sections,
    we will look at different methods to further improve the readability and maintainability
    of our optional handlings.
  prefs: []
  type: TYPE_NORMAL
- en: Guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `guard` is another method provided in the Swift library to handle `Optionals`.
    The `guard` method differs from the `Optional if-let` binding in that the `guard`
    statement can be used for early exits. We can use a `guard` statement to require
    that a condition must be `true` in order for the code after the `guard` statement
    to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents the guard statement usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `greet` function requires a value for a person's name;
    therefore, it checks whether it is present with the `guard` statement. Otherwise,
    it will return and not continue to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Using `guard` statements, we can check for failure scenarios first and return
    if it fails. Unlike `if-let` statements, `guard` does not provide a new scope,
    so in the preceding example, we were able to use `name` in our `print` statement,
    which is not inside `{ }`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `if-let` statements, we can use multiple `guard` statements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Implicitly unwrapped optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define implicitly unwrapped optionals by appending an exclamation mark
    (`!`) to the end of the type. These types of optionals will unwrap themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents two ways to get a value from a dictionary. In
    the first example, the resulting value will be an optional. The second example
    will implicitly unwrap the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Like forcefully unwrapping, implicitly unwrapped `Optionals` may cause runtime
    crashes in our applications, so we need to be cautious when we use them.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling to avoid optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our day-to-day application development, we might need to develop some functions
    that return `Optionals`. For instance, suppose that we need to read a file and
    return the content of that file. Using optionals, we can develop it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `checkForPath` is an incomplete function that checks for file existence.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call the `readFile` function, we will need to check for the resulting
    optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using optionals in this scenario, we can use error handling to redirect
    the flow of control to eliminate errors and provide recoveries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call this function, we will need to wrap it inside a `do` block and
    `catch` the `exception`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: try!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `try!` if we know that there is no way a method call will fail, or
    if it fails then our code will be broken and we should crash the application.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `try!` keyword, we do not need to have `do` and `catch` around
    our code block because we promise it will never fail! It is a big promise that
    we should avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case we have to bypass error handling such as checking whether a database
    file exists, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: try?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `try?` to handle an error by converting it to an `Optional` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an error is thrown while evaluating the `try?` expression, the value of
    the expression is going to be `nil`. For instance, in the following example, the
    result is going to be `nil` if we cannot read the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Nil-coalescing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift provides the `??` operator for nil-coalescing. It unwraps `Optionals`
    and provides fallback or default values for the `nil` case. For instance, `a ??
    b` unwraps optional `a` if it has a value and returns a default value `b` if `a`
    is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, if `Optional` `a` is not `nil`, the expression after the nil-coalescing
    operator is not going to be evaluated. Nil-coalescing is proper for scenarios
    where we can provide a fallback or default value.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optional chaining is a process to query and call properties, methods, and subscripts
    on an optional that may currently be `nil`. Optional chaining in Swift is similar
    to messaging `nil` in Objective-C but in a way that works for any type and can
    be checked for success or failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents two different classes. One of the classes `Person` has
    a property of type of `Optional` (`residence`), which wraps the other class type
    `Residence`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create an instance of the `Person` class, `sangeeth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To check for `numberOfRooms`, we need to use the residence property of the
    `Person` class, which is an optional. Optional chaining enables us to go through
    optionals as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `roomCount` variable will be five, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: This can be used to call methods and subscripts through optional chaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add force unwrapping to any chain items by replacing the question mark
    with an exclamation mark as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Again, we need to be cautious when we use force unwrapping in optional chains.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with optionals functionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of different approaches and tools to deal with optionals
    so far. Let's examine if we can use functional programming paradigms to simplify
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: Optional mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mapping over an array would generate one element for each element in the array.
    Can we map over an optional to generate non-optional values? If we have `Some`,
    map it; otherwise, return `None`. Let''s examine this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `input` variable is a generic `optional` and we have a transform function
    that takes `input` and transforms it into a generic type. The end result will
    be a generic `optional` type. In the function body, we use pattern matching to
    return the respective values. Let''s test this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a dummy class named `User` with an `Optional` variable. We use the
    variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The end result will be a non-optional String. Our `mapOptionals` function is
    similar to the `fmap` function in Haskell, which is defined as the `<^>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert this function to the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just defined an infix operator and defined the respective function.
    Let''s try this function to see if it provides the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result is identical to our previous example, but the code is more readable,
    so we may prefer to use it instead.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple optional value mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our previous example demonstrated single `optional` value mapping using functional
    programming techniques. What if we need to map multiple optional values together?
    In the *Optional binding* section, we covered a non-functional way to handle multiple
    `Optional` value binding, and in this section, we will look at multiple optional
    value mapping. As optionals are instances of *applicative functors*, we will develop
    an `apply` function to use over optionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `apply` function is very similar to the `fmap` function. The `transform`
    function is optional and we use pattern matching to return `none` or `some` over
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Haskell, the `apply` function is represented as the `<*>` operator. This
    operator has been adopted by the Swift functional programming community as well,
    so we use it as the `apply` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test our `apply` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `extractFullUserName` function is a curried function that should be converted
    to return a closure explicitly because Apple deprecated function currying in Swift
    2.2 and removed it from Swift 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert it to the Swift 3.0 version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use this function to extract the full username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Combining `fmap` and `apply` functions, we were able to `map` two optionals.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the `Optional` type is a `monad`, so it implements the `map` and `flatMap`
    methods and we do not need to develop it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents calling the `map` method on an `optional` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be an `Optional String` with the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A String literal is mapped`.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can use `flatMap` to filter `nil` values and convert an array of optionals
    to an array of unwrapped values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, calling `flatMap` on our `optional Array` will eliminate
    the third element (index: 2) of our `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The result is going to be `["First", "Second", "Fourth"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got familiar with different techniques to deal with optionals.
    We talked about built-in techniques to deal with optionals such as optional binding,
    guard, coalescing, and optional chaining. Then we explored functional programming
    techniques to deal with optionals. We created `fmap` and `apply` functions and
    related operators to tackle multiple optional binding problems. Even though some
    developers may prefer to use built-in multiple optional binding, exploring functional
    programming techniques practically provides a better understanding of concepts
    that we will be able to apply to other problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will explore some examples of functional data structures
    such as Semigroup, Monoid, Binary Search Tree, Linked List, Stack, and Lazy List.
  prefs: []
  type: TYPE_NORMAL
