- en: Chapter 7. Dealing with Optionals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 处理可选值
- en: In day-to-day Swift application development, we need to deal with optionals
    as some of the methods that we need to call may return some values or none. This
    chapter explores the concept of optionals and provides different techniques to
    deal with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常 Swift 应用程序开发中，我们需要处理可选值，因为我们需要调用的某些方法可能返回一些值或没有返回值。本章探讨了可选值的概念，并提供了处理它们的多种技术。
- en: 'This chapter will cover the following topics with coding examples:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过代码示例涵盖以下主题：
- en: Optional types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选类型
- en: Unwrapping optionals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包可选值
- en: Optional binding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选绑定
- en: Guard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guard
- en: Coalescing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并
- en: Optional chaining
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选链
- en: Optional mapping
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选映射
- en: Dealing with optionals functionally
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数式方式处理可选值
- en: '`fmap` and `apply` for multiple functional mapping'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmap` 和 `apply` 用于多级函数映射'
- en: Optional types
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选类型
- en: In our day-to-day application development, we encounter situations where we
    expect to receive a value but we do not receive it. For instance, suppose that
    we have a list of items and we need to search for a particular value in the list.
    The particular value that we are looking for might not be in the list. We have
    already encountered a lot of these scenarios.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常应用程序开发中，我们会遇到期望收到值但实际没有收到值的情况。例如，假设我们有一个项目列表，我们需要在列表中搜索特定的值。我们正在寻找的特定值可能不在列表中。我们已经遇到了很多这样的场景。
- en: Other examples can be calling a web service and receiving a JSON payload without
    the fields that we are looking for or querying a database and not receiving the
    expected values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例子可以是调用一个网络服务并接收一个没有我们所需字段的 JSON 有效负载，或者查询数据库但没有收到预期的值。
- en: What are we going to receive when the value is not there and how will we handle
    it?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当值不存在时我们将收到什么，我们将如何处理它？
- en: In programming languages such as C, it is possible to create a variable without
    giving it a value. If we try to use the variable before assigning a value, we
    would get an undefined value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C 这样的编程语言中，我们可以在不赋予其值的情况下创建一个变量。如果我们尝试在赋值之前使用该变量，我们会得到一个未定义的值。
- en: In Swift, we can define a variable without giving it a value, but we cannot
    use it without assigning some value to it. In other words, we need to initialize
    it before being able to use it. This feature of Swift ensures that we will not
    receive undefined values.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们可以定义一个没有值的变量，但如果我们不为其赋值，则不能使用它。换句话说，在使用之前我们需要初始化它。Swift 的这个特性确保我们不会收到未定义的值。
- en: What about the scenarios where we need to define a variable and we do not know
    what is going to be the value?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当我们需要定义一个变量但不知道其值将是什么时怎么办？
- en: To overcome these kinds of scenarios, Swift provides `Optional` types that can
    have `Some` or `None` values and can be used in situations where a value may be
    absent.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些类型的场景，Swift 提供了 `Optional` 类型，它可以有 `Some` 或 `None` 值，并且可以在可能不存在值的情况下使用。
- en: 'A question mark ( `?` ) is used to define a variable as optional. The following
    example presents an example of optional definition:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 问号（`?`）用于定义一个可选变量。以下示例展示了可选定义的例子：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we have defined a variable that is of an optional type. The
    `String?` type is an optional type that may wrap a `String` value in it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个可选类型的变量。`String?` 类型是一个可选类型，它可能包含一个 `String` 值。
- en: We were able to assign `nil` to `optionalString`. If we try to assign `nil`
    to any non-optional type in Swift, the compiler will complain about it unlike
    other languages such as Objective-C.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够将 `nil` 赋值给 `optionalString`。如果我们尝试将 `nil` 赋值给 Swift 中的任何非可选类型，编译器将会对此提出警告，这与
    Objective-C 等其他语言不同。
- en: 'For instance, in the following example, the compiler will complain that `nil
    cannot be assigned to type ''String''`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的例子中，编译器会抱怨 `nil cannot be assigned to type 'String'`：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The compile time checking of non-existent values in Swift to prevent runtime
    errors is one of the features of type safety in Swift. Type safety makes it easier
    to catch problems in the earlier stages of development. Let''s examine an example
    in Objective-C to see the real value of optionals:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中对不存在值的编译时检查以防止运行时错误是 Swift 类型安全特性之一。类型安全使得在开发早期阶段更容易捕捉到问题。让我们通过一个 Objective-C
    的例子来查看可选值的实际价值：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Suppose that we have a list for which we initiate a search by calling `searchItem`.
    In this case, our `searchItem` method takes `NSString` and returns `NSString`.
    The result of this call can be `nil`. If we use the returned `NSString` and try
    to append it to another `NSString`, it will compile but may crash the application
    if `searchItem` is `nil`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个列表，我们通过调用 `searchItem` 来启动搜索。在这种情况下，我们的 `searchItem` 方法接受 `NSString`
    并返回 `NSString`。这个调用的结果可能是 `nil`。如果我们使用返回的 `NSString` 并尝试将其追加到另一个 `NSString` 上，它将能够编译，但如果
    `searchItem` 是 `nil`，则可能会使应用程序崩溃。
- en: We could remedy this problem by checking whether `searchedItem` is not `nil`
    before using it. However, there might be some cases where other developers forgot
    to do it or did not see the necessity of it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在使用之前检查 `searchedItem` 是否不是 `nil` 来解决这个问题。然而，可能存在一些情况，其他开发者忘记这样做或没有看到它的必要性。
- en: For sure, it is safer to receive compile time complaints about these kinds of
    usages. As Swift is type-safe, we will not encounter any such surprises during
    runtime.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，收到关于这类用法的编译时错误会更安全。由于 Swift 是类型安全的，我们将在运行时不会遇到任何这样的惊喜。
- en: So, we have understood why we need an optional type, but what is it and how
    is it defined?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经了解了为什么我们需要可选类型，但它是什么，又是如何定义的呢？
- en: 'Under the hood, `Optional` is an `enum` with two cases in it—one is `None`
    and the other one is `Some` with its associated generic value as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`Optional` 是一个包含两个情况的 `enum`——一个是 `None`，另一个是 `Some`，其关联的泛型值如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unwrapping optionals
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解包可选类型
- en: So far, we know that optionals wrap values in themselves. Wrapping means that
    the actual data is stored within an outer structure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道可选类型会将自己包裹在内部。包裹意味着实际数据存储在外部结构中。
- en: 'For instance, we print `optionalString` as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们这样打印 `optionalString`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result will be `Optional("A String literal")`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是 `Optional("A String literal")`。
- en: How will we unwrap optionals and use the values that we need? There are different
    methods to unwrap optionals that we will go through in the following sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何解包可选类型并使用我们需要的值？在接下来的章节中，我们将介绍不同的解包可选类型的方法。
- en: Force unwrapping
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制解包
- en: To unwrap optionals, the easiest and most dangerous method that we can use is
    force unwrapping. In short, `!` can be used to force unwrap the value from `Optional`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选类型最简单也是最危险的方法是强制解包。简而言之，`!` 可以用来强制从 `Optional` 中解包值。
- en: 'The following example forcefully unwraps `optionalString`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例强制解包 `optionalString`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Force unwrapping the optionals may cause errors if the optional does not have
    a value, so it is not recommended to use this approach as it is very hard to be
    sure if we are going to have values in optionals in different circumstances.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可选类型没有值，强制解包可选类型可能会导致错误，因此不建议使用这种方法，因为它很难确保在不同情况下可选类型中是否有值。
- en: In fact, force unwrapping eliminates the benefits of type safety and may cause
    our applications to crash during runtime.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，强制解包消除了类型安全的好处，并可能导致我们的应用程序在运行时崩溃。
- en: nil checking
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nil 检查
- en: Force unwrapping an `Optional` could crash our applications; to eliminate the
    crashing problem, we can check whether the variable is not `nil` before unwrapping
    it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解包一个 `Optional` 可能会使我们的应用程序崩溃；为了消除崩溃问题，我们可以在解包之前检查变量是否不是 `nil`。
- en: 'The following example presents a simple `nil` checking approach:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一种简单的 `nil` 检查方法：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This approach is safe in compile and runtime but may cause problems during editing.
    For instance, if we accidentally move the `print` line outside the `if` block,
    the compiler is not going to complain and it may crash our application during
    runtime.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在编译和运行时都是安全的，但在编辑时可能会引起问题。例如，如果我们不小心将 `print` 行移出 `if` 块之外，编译器不会抱怨，但在运行时可能会使我们的应用程序崩溃。
- en: Optional binding
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Optional 绑定
- en: The better approach would be to use the Optional binding technique to find out
    whether an `Optional` contains a value or not. If it contains a value, we will
    be able to unwrap it and put it into a temporary constant or variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法可能是使用 Optional 绑定技术来找出 `Optional` 是否包含一个值。如果它包含一个值，我们将能够解包它并将其放入一个临时常量或变量中。
- en: 'The following example presents optional binding:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了可选绑定：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `if let familyName = nilName` statement will assign the `Optional` value
    to a new variable named `familyName`. The right-hand side of the assignment has
    to be an `Optional`, otherwise, the compiler will issue an error. Also, this approach
    ensures that we are using the unwrapped temporary version so it is safe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`if let familyName = nilName` 语句将 `Optional` 值赋给一个名为 `familyName` 的新变量。赋值语句的右侧必须是一个
    `Optional`，否则编译器将报错。此外，这种方法确保我们使用的是未包装的临时版本，因此是安全的。'
- en: This approach is also called if-let binding and is useful to unwrap `Optionals`
    and access the underlying values, but if we get into a complex structure of nested
    objects such as a `JSON` payload, the syntax becomes cumbersome.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也称为 if-let 绑定，它对于解包 `Optionals` 并访问底层值非常有用，但如果遇到复杂的嵌套对象结构，例如 `JSON` 有效负载，语法会变得繁琐。
- en: 'We will need to have lots of nested `if-let` expressions in these cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要有很多嵌套的 `if-let` 表达式：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To overcome this issue, we can use multiple Optional bindings as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用多个可选绑定，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This syntax makes the code more readable but still is not the best approach
    when we need to bind multiple levels of optionals. In the following sections,
    we will look at different methods to further improve the readability and maintainability
    of our optional handlings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法使代码更易于阅读，但当我们需要绑定多级可选类型时，这仍然不是最佳方法。在接下来的章节中，我们将探讨不同的方法来进一步提高我们处理可选类型的可读性和可维护性。
- en: Guard
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`guard`'
- en: The `guard` is another method provided in the Swift library to handle `Optionals`.
    The `guard` method differs from the `Optional if-let` binding in that the `guard`
    statement can be used for early exits. We can use a `guard` statement to require
    that a condition must be `true` in order for the code after the `guard` statement
    to be executed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`guard` 是 Swift 库中提供的另一种处理 `Optionals` 的方法。`guard` 方法与 `Optional if-let` 绑定不同，因为
    `guard` 语句可以用于早期退出。我们可以使用 `guard` 语句要求在 `guard` 语句之后的代码执行之前，条件必须为 `true`。'
- en: 'The following example presents the guard statement usage:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 `guard` 语句的使用：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the `greet` function requires a value for a person's name;
    therefore, it checks whether it is present with the `guard` statement. Otherwise,
    it will return and not continue to execute.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`greet` 函数需要一个表示人名的值；因此，它使用 `guard` 语句检查其是否存在。否则，它将返回并停止执行。
- en: Using `guard` statements, we can check for failure scenarios first and return
    if it fails. Unlike `if-let` statements, `guard` does not provide a new scope,
    so in the preceding example, we were able to use `name` in our `print` statement,
    which is not inside `{ }`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `guard` 语句，我们可以首先检查失败场景，并在失败时返回。与 `if-let` 语句不同，`guard` 不提供新的作用域，因此在前面的例子中，我们能够在
    `{ }` 之外使用 `name` 在我们的 `print` 语句中，这是不可能的。
- en: 'Similar to `if-let` statements, we can use multiple `guard` statements as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `if-let` 语句类似，我们可以使用多个 `guard` 语句，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implicitly unwrapped optionals
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式解包的可选类型
- en: We can define implicitly unwrapped optionals by appending an exclamation mark
    (`!`) to the end of the type. These types of optionals will unwrap themselves.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在类型末尾附加一个感叹号 (`!`) 来定义隐式解包的可选类型。这些类型会自动解包。
- en: 'The following example presents two ways to get a value from a dictionary. In
    the first example, the resulting value will be an optional. The second example
    will implicitly unwrap the value:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了从字典中获取值两种方式。在第一个例子中，结果值将是一个可选类型。在第二个例子中，值将隐式解包：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Like forcefully unwrapping, implicitly unwrapped `Optionals` may cause runtime
    crashes in our applications, so we need to be cautious when we use them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与强制解包类似，隐式解包的可选类型可能会导致我们的应用程序在运行时崩溃，因此在使用它们时我们需要谨慎。
- en: Error handling to avoid optionals
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理以避免可选类型
- en: 'In our day-to-day application development, we might need to develop some functions
    that return `Optionals`. For instance, suppose that we need to read a file and
    return the content of that file. Using optionals, we can develop it as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常应用开发中，我们可能需要开发一些返回 `Optionals` 的函数。例如，假设我们需要读取一个文件并返回该文件的内容。使用可选类型，我们可以这样开发：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `checkForPath` is an incomplete function that checks for file existence.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`checkForPath` 是一个不完整的函数，用于检查文件是否存在。
- en: 'When we call the `readFile` function, we will need to check for the resulting
    optional:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `readFile` 函数时，我们需要检查结果的可选类型：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instead of using optionals in this scenario, we can use error handling to redirect
    the flow of control to eliminate errors and provide recoveries:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不是使用可选值，而是可以使用错误处理来重定向控制流以消除错误并提供恢复：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we call this function, we will need to wrap it inside a `do` block and
    `catch` the `exception`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，我们需要将其包裹在一个`do`块中并`catch`到`exception`：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: try!
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try!
- en: We can use `try!` if we know that there is no way a method call will fail, or
    if it fails then our code will be broken and we should crash the application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道方法调用不可能失败，或者如果它失败则我们的代码将损坏，我们应该崩溃应用程序，我们可以使用`try!`。
- en: When we use the `try!` keyword, we do not need to have `do` and `catch` around
    our code block because we promise it will never fail! It is a big promise that
    we should avoid.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`try!`关键字时，我们不需要在代码块周围有`do`和`catch`，因为我们承诺它永远不会失败！这是一个很大的承诺，我们应该避免。
- en: 'In case we have to bypass error handling such as checking whether a database
    file exists, we can do the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须绕过错误处理，例如检查数据库文件是否存在，我们可以这样做：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: try?
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try?
- en: We can use `try?` to handle an error by converting it to an `Optional` value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`try?`将错误转换为`Optional`值来处理错误。
- en: 'If an error is thrown while evaluating the `try?` expression, the value of
    the expression is going to be `nil`. For instance, in the following example, the
    result is going to be `nil` if we cannot read the file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在评估`try?`表达式时抛出错误，则表达式的值将是`nil`。例如，在以下示例中，如果我们无法读取文件，则结果将是`nil`：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Nil-coalescing
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空值合并
- en: Swift provides the `??` operator for nil-coalescing. It unwraps `Optionals`
    and provides fallback or default values for the `nil` case. For instance, `a ??
    b` unwraps optional `a` if it has a value and returns a default value `b` if `a`
    is `nil`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Swift提供了`??`运算符用于空值合并。它解包`Optionals`并为`nil`情况提供回退或默认值。例如，`a ?? b`如果`a`有值则解包可选`a`，如果`a`是`nil`则返回默认值`b`。
- en: In this example, if `Optional` `a` is not `nil`, the expression after the nil-coalescing
    operator is not going to be evaluated. Nil-coalescing is proper for scenarios
    where we can provide a fallback or default value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`Optional` `a`不是`nil`，则空值合并运算符后面的表达式将不会被评估。空值合并适用于我们可以提供回退或默认值的情况。
- en: Optional chaining
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选链
- en: Optional chaining is a process to query and call properties, methods, and subscripts
    on an optional that may currently be `nil`. Optional chaining in Swift is similar
    to messaging `nil` in Objective-C but in a way that works for any type and can
    be checked for success or failure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链是一个查询和调用可能当前为`nil`的可选属性、方法和下标的进程。Swift中的可选链类似于Objective-C中的`nil`消息，但以一种适用于任何类型并且可以检查成功或失败的方式工作。
- en: 'The following example presents two different classes. One of the classes `Person` has
    a property of type of `Optional` (`residence`), which wraps the other class type
    `Residence`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了两个不同的类。其中一个类`Person`有一个类型为`Optional`（`residence`）的属性，它包装了另一个类类型`Residence`：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will create an instance of the `Person` class, `sangeeth`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Person`类的实例，名为`sangeeth`：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To check for `numberOfRooms`, we need to use the residence property of the
    `Person` class, which is an optional. Optional chaining enables us to go through
    optionals as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`numberOfRooms`，我们需要使用`Person`类的居住属性，它是一个可选值。可选链使我们能够如下遍历可选值：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `roomCount` variable will be five, as expected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`roomCount`变量将如预期的那样是五个。'
- en: This can be used to call methods and subscripts through optional chaining.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来通过可选链调用方法和下标。
- en: 'We can add force unwrapping to any chain items by replacing the question mark
    with an exclamation mark as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将问号替换为感叹号来强制解包任何链项：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, we need to be cautious when we use force unwrapping in optional chains.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，当我们使用强制解包时，我们需要谨慎。
- en: Dealing with optionals functionally
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式处理可选值
- en: We have covered a lot of different approaches and tools to deal with optionals
    so far. Let's examine if we can use functional programming paradigms to simplify
    the process.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了许多不同的方法和工具来处理可选值。让我们看看我们是否可以使用函数式编程范式来简化这个过程。
- en: Optional mapping
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选映射
- en: 'Mapping over an array would generate one element for each element in the array.
    Can we map over an optional to generate non-optional values? If we have `Some`,
    map it; otherwise, return `None`. Let''s examine this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对数组进行映射将为数组中的每个元素生成一个元素。我们能否映射可选以生成非可选值？如果我们有`Some`，则映射它；否则，返回`None`。让我们看看这个例子：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our `input` variable is a generic `optional` and we have a transform function
    that takes `input` and transforms it into a generic type. The end result will
    be a generic `optional` type. In the function body, we use pattern matching to
    return the respective values. Let''s test this function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`input`变量是一个泛型`optional`，我们有一个转换函数，它接受`input`并将其转换为泛型类型。最终结果将是一个泛型`optional`类型。在函数体中，我们使用模式匹配来返回相应的值。让我们测试这个函数：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We create a dummy class named `User` with an `Optional` variable. We use the
    variable as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`User`的虚拟类，其中包含一个`Optional`变量。我们如下使用该变量：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The end result will be a non-optional String. Our `mapOptionals` function is
    similar to the `fmap` function in Haskell, which is defined as the `<^>` operator.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将是一个非可选的String。我们的`mapOptionals`函数与Haskell中的`fmap`函数类似，它定义为`<^>`运算符。
- en: 'Let''s convert this function to the operator:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个函数转换为运算符：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we just defined an infix operator and defined the respective function.
    Let''s try this function to see if it provides the same result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只定义了一个中缀运算符并定义了相应的函数。让我们尝试这个函数，看看它是否提供相同的结果：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result is identical to our previous example, but the code is more readable,
    so we may prefer to use it instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与我们的上一个例子相同，但代码更易读，所以我们可能更喜欢使用它。
- en: Multiple optional value mapping
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个可选值映射
- en: 'Our previous example demonstrated single `optional` value mapping using functional
    programming techniques. What if we need to map multiple optional values together?
    In the *Optional binding* section, we covered a non-functional way to handle multiple
    `Optional` value binding, and in this section, we will look at multiple optional
    value mapping. As optionals are instances of *applicative functors*, we will develop
    an `apply` function to use over optionals:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子展示了使用函数式编程技术对单个`optional`值进行映射。如果我们需要一起映射多个可选值怎么办？在*Optional绑定*部分，我们介绍了处理多个`Optional`值绑定的一种非函数式方法，在本节中，我们将探讨多个可选值映射。由于可选值是*applicative
    functors*的实例，我们将开发一个`apply`函数来在可选值上使用：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `apply` function is very similar to the `fmap` function. The `transform`
    function is optional and we use pattern matching to return `none` or `some` over
    it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数与`fmap`函数非常相似。`transform`函数是可选的，我们使用模式匹配来返回`none`或`some`。'
- en: 'In Haskell, the `apply` function is represented as the `<*>` operator. This
    operator has been adopted by the Swift functional programming community as well,
    so we use it as the `apply` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，`apply`函数表示为`<*>`运算符。这个运算符已经被Swift函数式编程社区采用，因此我们将其用作`apply`函数：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can test our `apply` function as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下测试我们的`apply`函数：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `extractFullUserName` function is a curried function that should be converted
    to return a closure explicitly because Apple deprecated function currying in Swift
    2.2 and removed it from Swift 3.0.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractFullUserName`函数是一个柯里化函数，应该显式地转换为返回闭包，因为Apple在Swift 2.2中弃用了函数柯里化，并在Swift
    3.0中将其移除。'
- en: 'Let''s convert it to the Swift 3.0 version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其转换为Swift 3.0版本：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can use this function to extract the full username:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个函数来提取完整的用户名：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Combining `fmap` and `apply` functions, we were able to `map` two optionals.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合`fmap`和`apply`函数，我们能够`map`两个可选值。
- en: In fact, the `Optional` type is a `monad`, so it implements the `map` and `flatMap`
    methods and we do not need to develop it ourselves.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`Optional`类型是一个`monad`，因此它实现了`map`和`flatMap`方法，我们不需要自己开发它。
- en: 'The following example presents calling the `map` method on an `optional` type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了在`optional`类型上调用`map`方法：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result will be an `Optional String` with the following value:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个包含以下值的`Optional String`：
- en: '`A String literal is mapped`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`A String literal is mapped`。'
- en: Also, we can use `flatMap` to filter `nil` values and convert an array of optionals
    to an array of unwrapped values.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`flatMap`来过滤`nil`值，并将可选值数组转换为未包装值数组。
- en: 'In the following example, calling `flatMap` on our `optional Array` will eliminate
    the third element (index: 2) of our `Array`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，在`optional Array`上调用`flatMap`将消除我们的`Array`中的第三个元素（索引：2）：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The result is going to be `["First", "Second", "Fourth"]`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是`["First", "Second", "Fourth"]`。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got familiar with different techniques to deal with optionals.
    We talked about built-in techniques to deal with optionals such as optional binding,
    guard, coalescing, and optional chaining. Then we explored functional programming
    techniques to deal with optionals. We created `fmap` and `apply` functions and
    related operators to tackle multiple optional binding problems. Even though some
    developers may prefer to use built-in multiple optional binding, exploring functional
    programming techniques practically provides a better understanding of concepts
    that we will be able to apply to other problems.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了处理可选值的不同技术。我们讨论了处理可选值的内置技术，例如可选绑定、守卫（guard）、合并（coalescing）和可选链（optional
    chaining）。然后我们探讨了函数式编程技术来处理可选值。我们创建了`fmap`和`apply`函数以及相关的运算符来解决多个可选绑定问题。尽管一些开发者可能更喜欢使用内置的多个可选绑定，但实际探索函数式编程技术可以更好地理解我们将能够应用于其他问题的概念。
- en: In the following chapter, we will explore some examples of functional data structures
    such as Semigroup, Monoid, Binary Search Tree, Linked List, Stack, and Lazy List.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨一些函数式数据结构的例子，例如半群（Semigroup）、幺半群（Monoid）、二叉搜索树（Binary Search Tree）、链表（Linked
    List）、栈（Stack）和惰性列表（Lazy List）。
