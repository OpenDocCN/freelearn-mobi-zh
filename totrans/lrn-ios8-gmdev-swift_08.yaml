- en: Chapter 8. SceneKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, this is it! Finally, we move from the 2D world to 3D. With SceneKit, we
    can make 3D games quite easily, especially since the syntax for SceneKit is quite
    similar to SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: When we say 3D games, we don't mean that you get to put on your 3D glasses to
    make the game. In 2D games, we mostly work in the x and y coordinates. In 3D games,
    we deal with all three axes *x*, *y*, and *z*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in 3D games, we have different types of lights that we can use.
    Also, SceneKit has an inbuilt physics engine that will take care of forces such
    as gravity and will also aid collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use SpriteKit in SceneKit for GUI and buttons so that we can add
    scores and interactivity to the game. So, there is a lot to cover in this chapter.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scene with SCNScene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding objects to a scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing scenes from external 3D applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding physics to the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an enemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a SpriteKit overlay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding touch interactivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finishing the gameloop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding wall and floor parallax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scene with SCNScene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a new SceneKit project. It is very similar to creating other
    projects. Only this time, make sure you select SceneKit from the **Game Technology**
    drop-down list. Don''t forget to select **Swift** for the language field. Choose
    **iPad** as the device and click on **Next** to create the project in the selected
    directory, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a scene with SCNScene](img/B04014_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the project is created, open it. Click on the `GameViewController` class,
    and delete all the contents in the `viewDidLoad` function, delete the `handleTap`
    function, as we will be creating a separate class, and add touch behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `GameSCNScene` and import the following headers.
    Inherit from the `SCNScene` class and add an `init` function that takes in a parameter
    called view of type `SCNView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Also, create two new constants `scnView` and `_size` of type `SCNView` and `CGSize`,
    respectively. Also, add a variable called `scene` of type `SCNScene`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are making a SceneKit game, we have to get the current view, which
    is the type `SCNView`, similar to how we got the view in SpriteKit where we typecasted
    the current view in SpriteKit to `SKView`.
  prefs: []
  type: TYPE_NORMAL
- en: We create a `_size` constant to get the current size of the view. We then create
    a new variable `scene` of type `SCNScene`. `SCNScene` is the class used to make
    scenes in SceneKit, similar to how we would use `SKScene` to create scenes in
    SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift would automatically ask to create the `required init` function, so we
    might as well include it in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, move to the `GameViewController` class and create a global variable called
    `gameSCNScene` of type `GameSCNScene` and assign it in the `viewDidLoad` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now we can add objects in the `GameSCNScene` class. It is better to move
    all the code to a single class so that we can keep the `GameSceneController` class
    clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `init` function of `GameSCNScene`, add the following after the `super.init`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first assign the current view to the `scnView` constant. Next, we set
    the `_size` constant to the dimensions of the current view.
  prefs: []
  type: TYPE_NORMAL
- en: Next we initialize the scene variable. Then, assign the scene to the scene of
    `scnView`. Next, enable `allowCameraControls` and `showStatistics`. This will
    enable us to control the camera and move it around to have a better look at the
    scene. Also, with statistics enabled, we will see the performance of the game
    to make sure that the FPS is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: The `backgroundColor` property of `scnView` enables us to set the color of the
    view. I have set it to yellow so that objects are easily visible in the scene,
    as shown in the following screenshot. With all this set we can run the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a scene with SCNScene](img/B04014_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, it is not all that awesome yet. One thing to notice is that we have still
    not added a camera or a light, but we still see the yellow scene. This is because
    while we have not added anything to the scene yet, SceneKit automatically provides
    a default light and camera for the scene created.
  prefs: []
  type: TYPE_NORMAL
- en: Adding objects to the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us next add geometry to the scene. We can create some basic geometry such
    as spheres, boxes, cones, tori, and so on in SceneKit with ease. Let us create
    a sphere first and add it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sphere to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a function called `addGeometryNode` in the class and add the following
    code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For creating geometry, we use the `SCNSphere` class to create a sphere shape.
    We can also call `SCNBox`, `SCNCone`, `SCNTorus`, and so on to create box, cone,
    or torus shapes respectively.
  prefs: []
  type: TYPE_NORMAL
- en: While creating the sphere, we have to provide the radius as a parameter, which
    will determine the size of the sphere. Although to place the shape, we have to
    attach it to a node so that we can place and add it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: So, create a new constant called `sphereNode` of type `SCNNode` and pass in
    the sphere geometry as a parameter. For positioning the node, we have to use the
    `SCNvector3Make` property to place our object in 3D space by providing the values
    for `x`, `y`, and `z`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to add the node to the scene, we have to call `scene.rootNode` to add
    the `sphereNode` to scene, unlike SpriteKit where we would simply use `addChild`
    to add objects to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: With the sphere added, let us run the scene. Don't forget to add `self.addGeometryNode()`
    in the `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: We did add a sphere, so why are we getting a circle (shown in the following
    screenshot)? Well, the basic light source used by SceneKit just enables to us
    to see objects in the scene. If we want to see the actual sphere, we have to improve
    the light source of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a sphere to the scene](img/B04014_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding light sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us create a new function called `addLightSourceNode` as follows so that
    we can add custom lights to our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can add some light sources to see some depth in our sphere object. Here we
    add two types of light source. The first is an omni light. Omni lights start at
    a point and then the light is scattered equally in all directions. We also add
    an ambient light source. An ambient light is the light that is reflected by other
    objects, such as moonlight.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two more types of light sources: directional and spotlight. Spotlight
    is easy to understand, and we usually use it if a certain object needs to be brought
    to attention like a singer on a stage. Directional lights are used if you want
    light to go in a single direction, such as sunlight. The Sun is so far from the
    Earth that the light rays are almost parallel to each other when we see them.'
  prefs: []
  type: TYPE_NORMAL
- en: For creating a light source, we create a node called `lightNode` of type `SCNNode`.
    We then assign `SCNLight` to the light property of `lightNode`. We assign the
    omni light type to be the type of the light. We assign position of the light source
    to be at 10 in all three *x*, *y*, and *z* coordinates. Then, we add it to the
    rootnode of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we add an ambient light to the scene. The first two steps of the process
    are the same as for creating any light source:'
  prefs: []
  type: TYPE_NORMAL
- en: For the type of light we have to assign `SCNLightTypeAmbient` to assign an ambient
    type light source. Since we don't want the light source to be very strong, as
    it is reflected, we assign a `darkGrayColor` to the color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the light source to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no need to add the ambient light source to the scene but it will make
    the scene have softer shadows. You can remove the ambient light source to see
    the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `addLightSourceNode` function in the `init` function. Now, build and
    run the scene to see an actual sphere with proper lighting, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding light sources](img/B04014_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can place a finger on the screen and move it to rotate the cameras as we
    have enabled camera control. You can use two fingers to pan the camera and you
    can double tap to reset the camera to its original position and direction.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a camera to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next let us add a camera to the scene, as the default camera is very close.
    Create a new function called `addCameraNode` to the class and add the following
    code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, again we create an empty node called `cameraNode`. We assign `SCNCamera`
    to the camera property of `cameraNode`. Next we position the camera such that
    we keep the `x` and `y` values at zero and move the camera back in the `z` direction
    by 15 units. Then we add the camera to the rootnode of the scene. Call the `addCameraNode`
    at the bottom of the `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: In this scene, the origin is at the center of the scene, unlike SpriteKit where
    the origin of a scene is always at bottom right of the scene. Here the positive
    *x* and *y* are to the right and up from the center. The positive *z* direction
    is toward you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a camera to the scene](img/B04014_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We didn't move the sphere back or reduce its size here. This is purely because
    we brought the camera backward in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Let us next create a floor so that we can have a better understanding of the
    depth in the scene. Also, in this way, we will learn how to create floors in the
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a floor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the class, add a new function called `addFloorNode` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For creating a floor, we create a variable called `floorNode` of type `SCNNode`.
    We then assign `SCNFloor` to the geometry property of `floorNode`. For the position,
    we assign the `y` value to `-1` as we want the sphere to appear above the floor.
    At the end, as usual, we assign the `floorNode` to the root node of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, I have rotated the camera to show the scene in
    full action. Here we can see the floor is gray in color and the sphere is casting
    its reflection on the floor, and we can also see the bright omni light at the
    top left of the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a floor](img/B04014_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Importing scenes from external 3D applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we can add objects, cameras, and lights through code, it will become
    very tedious and confusing when we have a lot of objects added to the scene. In
    SceneKit, this problem can be easily overcome by importing scenes prebuilt in
    other 3D applications.
  prefs: []
  type: TYPE_NORMAL
- en: All 3D applications such as 3D StudioMax, Maya, Cheetah 3D, and Blender have
    the ability to export scenes in Collada (`.dae`) and Alembic (`.abc`) format.
    We can import these scenes with lighting, camera, and textured objects into SceneKit
    directly, without the need for setting up the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will import a Collada file into the scene. In the resources
    folder for this chapter, you will find the `monsterScene.DAE` file. Drag this
    file into the current project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing scenes from external 3D applications](img/B04014_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Along with the DAE file, also add the `monster.png` file to the project, otherwise
    you will see only the untextured monster mesh in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `monsterScene.DAE` file. If the textured monster is not automatically
    loaded, drag the `monster.png` file from the project into the monster mesh in
    the preview window. Release the mouse button once you see a (**+**) sign while
    over the monster mesh. Now you will be able to see the monster properly textured.
  prefs: []
  type: TYPE_NORMAL
- en: The panel on the left shows the entities in the scene. Below the entities, the
    scene graph is shown and the view on the right is the preview pane.
  prefs: []
  type: TYPE_NORMAL
- en: Entities show all the objects in the scene and the scene graph shows the relation
    between these entities. If you have certain objects that are children to other
    objects, the scene graph will show them as a tree. For example, if you open the
    triangle next to **CATRigHub001**, you will see all the child objects under it.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the scene graph to move and rotate objects in the scene to fine-tune
    your scene. You can also add nodes, which can be accessed by code. You can see
    that we already have a camera and a spotlight in the scene. You can select each
    object and move it around using the arrow at the pivot point of the object.
  prefs: []
  type: TYPE_NORMAL
- en: You can also rotate the scene to get a better view by clicking and dragging
    the left mouse button on the preview scene. For zooming, scroll your mouse wheel
    up and down. To pan, hold the *Alt* button on the keyboard and left-click and
    drag on the preview pane.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to note is that rotating, zooming, and panning in the preview pane
    won't actually move your camera. The camera is still at the same position and
    angle. To view from the camera, again select the **Camera001** option from the
    drop-down list in the preview pane and the view will reset to the camera view.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the preview window, we can either choose to see the view through
    the camera or spotlight, or click-and-drag to rotate the free camera. If you have
    more than one camera in your scene, then you will have **Camera002**, **Camera003**,
    and so on in the drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: Below the view selection dropdown in the preview panel you also have a play
    button. If you click on the play button, you can look at the default animation
    of the monster getting played in the preview window.
  prefs: []
  type: TYPE_NORMAL
- en: The preview panel is just that; it is just to aid you in having a better understanding
    of the objects in the scene. In no way is it a replacement for a regular 3D package
    such as 3DSMax, Maya, or Blender.
  prefs: []
  type: TYPE_NORMAL
- en: You can create cameras, lights, and empty nodes in the scene graph, *but you
    can't add geometry such as boxes and spheres*. You can add an empty node and position
    it in the scene graph, and then add geometry in code and attach it to the node.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of the scene graph, let us see how we can
    run this scene in SceneKit.
  prefs: []
  type: TYPE_NORMAL
- en: In the `init` function, delete the line where we initialized the scene and add
    the following line instead. Also delete the objects, light, and camera we added
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the game to see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing scenes from external 3D applications](img/B04014_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will see the monster running and the yellow background that we initially
    assigned to the scene. While exporting the scene, if you export the animations
    as well, once the scene loads in SceneKit the animation starts playing automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you will notice that we have deleted the camera and light in the scene.
    So, how come the default camera and the light aren't loaded in the scene?
  prefs: []
  type: TYPE_NORMAL
- en: What is happening here is that while I exported the file, I inserted a camera
    in the scene and also added a spotlight. So, when we imported the file into the
    scene, SceneKit automatically understood that there is a camera already present,
    so it will use the camera as its default camera. Similarly, a spotlight is already
    added in the scene, which is taken as the default light source, and lighting is
    calculated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding objects and physics to the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now see how we can access each of the objects in the scene graph and
    add gravity to the monster. Later in this chapter, we will see how we can add
    a touch interface by which we will be able to make the hero character jump by
    applying an upward force.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the hero object and adding a physics body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, create a new function called `addColladaObjects` and call an `addHero`
    function in it. Create a global variable called `heroNode` of type `SCNNode`.
    We will use this node to access the hero object in the scene. In the `addHero`
    function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we call the `addColladaObjects` function in the `init` function, as highlighted.
    Then we create the `addHero` function. In it we initiate the `heroNode`. Then,
    to actually move the monster, we need access to the `CatRibHub001` node to move
    the monster. We gain access to it through the `ChildWithName` property of `scene.rootNode`.
    For each object that we wish to gain access to through code, we will have to use
    the `ChildWithName` property of the `rootNode` of the scene and pass in the name
    of the object.
  prefs: []
  type: TYPE_NORMAL
- en: If recursively is set to `true`, to get said object, SceneKit will go through
    all the child nodes to get access to the specific node. Since the node that we
    are looking for is right on top, we said `false` to save processing time.
  prefs: []
  type: TYPE_NORMAL
- en: We create a temporary variable called `monsterNode`. In the next step, we add
    the `monsterNode` variable to `heroNode`. We then set the position of the hero
    node to the origin.
  prefs: []
  type: TYPE_NORMAL
- en: For `heroNode` to interact with other physics bodies in the scene, we have to
    assign a shape to the physics body of `heroNode`. We could use the mesh of the
    monster, but the shape might not be calculated properly and a box is a much simpler
    shape than the mesh of the monster. For creating a box collider, we create a new
    box geometry roughly the width, height, and depth of the monster.
  prefs: []
  type: TYPE_NORMAL
- en: Then, using the `physicsBody.physicsShape` property of the `heroNode`, we assign
    the shape of the `collisionBox` we created for it. Since we want the body to be
    affected by gravity, we assign the physics body type to be dynamic. Later we will
    see other body types.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want the body to be highly responsive to gravity, we assign a value
    of `20` to the `mass` of the body. In the next step, we set the `angularVelocityFactor`
    to `0` in all three directions, as we want the body to move straight up and down
    when a vertical force is applied. If we don't do this, the body will flip-flop
    around.
  prefs: []
  type: TYPE_NORMAL
- en: We also assign the name `hero` to the monster to check if the collided object
    is the hero or not. This will come in handy when we check for collision with other
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add `heroNode` to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `addColladaObjects` to the `init` function and comment or delete the
    `self.addGeometryNode`, `self.addLightSourceNode`, `self.addCameraNode`, and `self.addFloorNode`
    functions if you haven't already. Then, run the game to see the monster slowly
    falling through.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a small patch of ground right underneath the monster so that
    it doesn't fall down.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new function called `addGround` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We create a new constant called `groundBox` of type `SCNBox,` with a width and
    length of `10`, and height of `2`. Chamfer is the rounding of the edges of the
    box. Since we didn't want any rounding of the corners, it is set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a `SCNNode` called `groundNode` and assign `groundBox` to it.
    We place it slightly below the origin. Since the height of the box is `2`, we
    place it at `–1.01` so that `heroNode` will be `(0, 0, 0)` when the monster rests
    on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Next we assign the physics body of type static body. Also, since we don't want
    the hero to bounce off the ground when he falls on it, we set the restitution
    to `0`. Finally, we then add the ground to the scene's rootnode.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we made this body static instead of dynamic is because a dynamic
    body gets affected by gravity and other forces but a static one doesn't. So, in
    this scene, even though gravity is acting downward, the hero will fall but `groundBox`
    won't as it is a static body.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the physics syntax is very similar to SpriteKit with static
    bodies and dynamic bodies, gravity, and so on. And once again, similar to SpriteKit,
    the physics simulation is automatically turned on when we run the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `addGround` function in the `addColladaObjects` functions and run the
    game to see the monster getting affected by gravity and stopping after coming
    in touch with the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the ground](img/B04014_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding an enemy node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To check collision in SceneKit, we can check for collision between the hero
    and the ground. But let us make it a little more interesting and also learn a
    new kind of body type: the kinematic body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will create a new box called `enemy` and make it move and collide
    with the hero. Create a new global `SCNNode` called `enemyNode` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create a new function called `addEnemy` to the class and add the following
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Nothing too fancy here! Just as when adding the `groundNode`, we have created
    a cube with all its sides four units long. We have also added a yellow color to
    its material. We then initialize `enemyNode` in the function. We position the
    node along the *x*, *y*, and **z** axes. Assign the body type as kinematic instead
    of static or dynamic. Then we add the body to the scene and finally name the `enemyNode`
    as `enemy`, which we will be needing while checking for collision. Before we forget,
    call the `addEnemy` function in the `addColladaObjects` function after where we
    called the `addHero` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between the kinematic body and other body types is that, like
    static, external forces cannot act on the body, but we can apply a force to a
    kinematic body to move it.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a static body, we saw that it is not affected by gravity and
    even if we apply a force to it, the body just won't move.
  prefs: []
  type: TYPE_NORMAL
- en: Here we won't be applying any force to move the enemy block but will simply
    move the object like we moved the enemy in the SpriteKit game. So, it is like
    making the same game, but in 3D instead of 2D, so that you can see that although
    we have a third dimension, the same principles of game development can be applied
    to both.
  prefs: []
  type: TYPE_NORMAL
- en: 'For moving the enemy, we need an `update` function for the enemy. So, let us
    add it to the scene by creating an `updateEnemy` function and adding the following
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `update` function, similar to how we moved the enemy in the SpriteKit
    game, we increment the `Z` position of the enemy node by 0.9\. The difference
    being that we are moving the *z* direction.
  prefs: []
  type: TYPE_NORMAL
- en: Once the enemy has gone beyond `–40` in the *z* direction, we reset the position
    of the enemy. To create an additional challenge to the player, when the enemy
    resets, a random number is chosen between `1` and `2`. If it is `1`, then the
    enemy is placed closer to the ground, otherwise it is placed at 15 units from
    the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will add a jump mechanic to the hero. So, when the enemy is closer
    to the ground, the hero has to jump over the enemy box, but when the enemy is
    spawned at a height, the hero shouldn't jump. If he jumps and hits the enemy box,
    then it is game over. Later we will also add a scoring mechanism to keep score.
  prefs: []
  type: TYPE_NORMAL
- en: 'For updating the enemy, we actually need an update function to add the `enemyUpdate`
    function to so that the enemy moves and his position resets. So, create a function
    called update in the class and call the `updateEnemy` function in it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Updating objects in the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In SceneKit, there is an update function that gets called after the scene is
    rendered. We will use this function to call the `update` function of our game.
    In the `GameViewController` class, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the `rendererUpdateAtTime` function, the `GameViewController` class
    needs to inherit from `SCNSceneRendererDelegate`. So, where the class is created,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `viewDidLoad` function, set the current delegate to self as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Delegates are a part of code design patterns. Using delegates, a class can let
    a different class gain access and perform some of its responsibilities. Here `SceneRenderer`
    is delegating to `scnView` by assigning the delegate as self.
  prefs: []
  type: TYPE_NORMAL
- en: The `rendererUpdateAtTime` function is a system function that gets called after
    all the objects are rendered in the scene. So, once the scene is rendered, the
    objects in the scene can be updated, otherwise it might result in artifacting.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we build and run the game, we see `enemyBox` getting updated.
  prefs: []
  type: TYPE_NORMAL
- en: But there is a problem, when the box hits the hero, the hero gets knocked off
    his pedestal and goes flying. This is because, firstly, the hero is a dynamic
    body, so external forces will affect him. Secondly, though we are moving the box
    manually without applying any force, e we are still moving the box and there is
    some inertial force calculated by SceneKit, so once the box hits the hero, the
    energy is transferred to the hero, and it acts like an external force applied
    on the hero so the hero starts moving.
  prefs: []
  type: TYPE_NORMAL
- en: Since we constrained the rotation of the hero using `heroNode.physicsBody?.angularVelocityFactor
    = SCNVector3Zero`, when the box hits him, he is not rotating. If we comment or
    delete the line, the hero will spin because of the box hitting him.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating objects in the scene](img/B04014_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will fix this issue when we check for collision. When the collision occurs,
    we will reset the position of the hero and box to their initial positions. So,
    let us next look at how to check for collision.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for contact between objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The physics engine of SceneKit has inbuilt functions that check for contact
    between objects when physics is enabled. A contact is triggered when two objects
    are just about to touch each other.
  prefs: []
  type: TYPE_NORMAL
- en: For checking contacts, we have to use the `didBeginContact` function of `physicsWorld`;
    so add the following code to the class. Also, we have to inherit from `SCNPhysicsContactDelegate`
    and set the `GameSCNScene` class as the contact delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to calling `RenderDelegate` in `GameViewController`, to be able to receive
    "contact" events in the provided `GameSCNScene` by the physics engine and be able
    to manipulate them, the `GameSCNScene` class inherits from `SCNPhysicsContactDelegate`
    and the scene's `contactDelegate` is set to `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at the top of the class, inherit from `SCNPhysicsContactDelegate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the `init` function, add the following to set the current class as
    contact delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `didBeginContact` function to the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When two physics objects collide, the nodes are stored in the contact variable.
    Since we already named our physics body objects, we check if the first body is
    of the hero's and the other body that the hero collided with is of the enemy.
    If true, we print out contact and also set the velocity of the first body to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Since ours is a small game, we can guess that body *A* would be the hero and
    body *B* will be the enemy. In bigger games with many collisions happening in
    a second, it might be hard to determine which is body *A* and which is body *B*.
    In such cases, we will have to check for both cases, that is, is body *A* of enemy
    or hero and vice versa for body *B*, then make the necessary conclusion.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have added a hero and an enemy and we have our collision set up.
    Next we will see how to implement a 2D overlay over our 3D scene so that we can
    display buttons and score and add a game over condition for our simple game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a SpriteKit overlay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For showing scores and buttons for the game, we will add 2D SpriteKit layer.
    For adding the overlay, create a class called `OverlaySKscene`. In this class,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To import SpriteKit we will have to create a subclass of SpriteKit. Create
    global variables of type `GameSCNScene`, `SKLabelNodes`, and `SpriteNodes`. Here
    we create two `LabelNodes`: one for displaying score and the other to show "game
    over" text. We also create two `spriteNodes`: one for the play button and the
    other for the jump button.'
  prefs: []
  type: TYPE_NORMAL
- en: We add the required `init` function and the default init function. The default
    `init` will take in the size of the scene and reference to the `GameSCNScene`
    class as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the `init` function, we initialize the super class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding labels and buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, in the `init` function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `init` function, first, we set the `gameScene` passed to the `_gameScene`
    property of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Next we initialize both the `scoreLabel` and `gameOverLabel`. We set the values
    for `text`, `color`, `textsize`, and `position` and add it to the scene. In `gameOverLabel`,
    we set hidden to `true`, as we only want the text to display once the game is
    over.
  prefs: []
  type: TYPE_NORMAL
- en: We then initialize the play and jump buttons that we made in SpriteKit. We set
    the jump button sprite to be hidden, as we want it to display only when the play
    button is clicked and the game starts. The images for the jump and play button
    are provided in the resources folder of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding touch interactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For adding touch interactivity, we will use the `touchesBegan` function similar
    to how we have always used it in SpriteKit. So, here we get the location of the
    touch and name of the sprite under the touch location. If the sprite name is `jumpBtn`
    and the `gameOver` Boolean is `false`, then we call the `heroJump` function in
    the `gameScene` class. If `gameOver` is `true` and if the play button is clicked,
    then we call the `startGame` function in the SceneKit class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, add the function as follows to detect touches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's all for the SpriteKit class. We will be adding the `gameOver` Boolean,
    and `heroJump` and `startGame` functions in the SceneKit class. The code will
    show some errors until we create it, so ignore the errors for now.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Move back to the SceneKit class and import SpriteKit at the top of the class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create a global variable called `skScene` of type `OverlaySKScene`. Add
    a new function called `addSpriteKitOverlay` and add the following code in the
    SceneKit class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here we initialize the `skScene` global variable we created earlier and pass
    in the size of the current scene and the current SceneKit class. Next we assign
    the `skScene` class to the `overlaySKScene` property of `scnView`. Finally, we
    set the `scaleMode` of the `skScene` variable to type `SKSceneScaleMode.ResizeFill`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, call the `addSpriteKitOverlay` function in the `addColladaObjects`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Making the hero jump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We still need to add the Boolean and functions to the class to make our game
    work. So, at the top of the class, create a global variable called `gameOver`
    and set it to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new function called `heroJump` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we apply an upward force of `1400` units in the *y* direction to `heroNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the `gameStart` function as follows and add it into the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `gameOver` Boolean is set to `false`. We set the jump button and `scoreLabel`
    to be visible and hide the play button and `gameOverlabel`.
  prefs: []
  type: TYPE_NORMAL
- en: For keeping track and displaying the score, we need a score variable, so create
    a global variable called `score` of type `int` and initialize it to `0` at the
    top of the class. Again, in the `startGame` function, set the value to `0` so
    that every time the function is called the value is reset. Also, we set the `scoreLabel`
    text to reflect the current score at the start of the game.
  prefs: []
  type: TYPE_NORMAL
- en: For scoring in the game, we will increment the score every time the enemy block
    goes beyond the screen and gets reset. If the block hits the hero, then it will
    be game over.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the `enemyUpdate` function, add the following highlighted line after
    we check if the enemy''s `Z` position is less than `–40` to update the score and
    `scoreLabel` text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Setting a game over condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `didBeginContact` function, add the following right after we reset the
    velocity of the player to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we set `gameOver` to `true` and call a `GameOver` function where we will
    set the visibility of the labels and buttons. So, add a new function called `GameOver`
    to the SceneKit class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, once the game is over, we hide the `jumpButton` and unhide the `playButton`
    and `gameOverLabel`. We then reset the position of the enemy and hero to their
    initial state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have to make sure that the `enemyUpdate` function is only called when
    `gameOver` is false. In the `update` function, enclose the `enemyUpdate` function
    in an `if` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to adjust the gravity in the scene, otherwise the hero will
    get tossed into the air since the gravity is currently so low. In the `addColladaObjects`
    function, add the following line at the end of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now our game loop is ready. If you press the play button, the game will start
    and the jump button will be visible, and the hero will jump when it is pressed.
    The score will increase each time the hero successfully avoids the enemy block,
    and the game will be over if he hits the enemy block. Once the game is over, the
    play button will be visible and jump button will be hidden. Tapping the play button
    again will reset everything and the game will start again.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the jump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is still one problem though. You can keep on tapping the jump button and
    the hero will keep on going up. We don't want that. We want the hero to jump only
    when he is grounded. For this, we will add a small counter and disable the jump
    when the hero is in the air.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, add a new global variable called `jumpCounter` of type `int` and
    initialize it to `0`. In the `update` function of the class, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here we decrement the value of `jumpCounter` and once it is less than zero,
    we set the value equal to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `heroJump` function, enclose where we apply force to the hero
    to jump in an if condition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, the hero will only jump when `jumpCounter` is equal to 0\. If it is equal
    to `0`, then the force is applied and the counter is set to `25`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The number was arrived at after trial and error to ensure that the jump button
    won't be pressed when the monster is in the air.
  prefs: []
  type: TYPE_NORMAL
- en: In the `update` function, we decrement this value, until then the force cannot
    be applied. Once `jumpCounter` is set to `0` again, the hero can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: So, finally, we can run and test the game. Make sure the `addSpriteKitOverlay`
    function is called in the `addColladaObjects` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing the jump](img/B04014_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding wall and floor parallax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a game without a parallax effect? In SpriteKit, we added parallax using
    sprites, while in SceneKit, we will use planes to add it to the scene. Apart from
    adding parallax, we will also see how to add diffuse, normal, and specular maps
    to the plane. Also, we will learn what those terms even mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as usual, we create a new function in which we will add all these planes.
    Add four global `SCNNodes` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add a function to the scene called `addWallandFloorParallax` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: OMG!! This is a whole lot of code. But don't panic. We will go through it systematically.
    Just look at the code where it says `preparing wall geometry`. First, we will
    see how the wall geometry is set up, and then once you have an understanding of
    it, we will see how to set up the floor geometry.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new constant called `wallGeometry` and assign a `SCNPlane` to it.
    The difference between an `SCNPlane` and `SCNFloor` is that here we can set the
    dimensions of the plane. So, very simply we set the width and height of the plane
    to be `250` by `120` units.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we assign a material to the plane. Until now, we have only seen how to
    assign a color to an object in SceneKit. Here we assign three kinds of maps to
    the plane. The first is a diffuse.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A diffuse material is an image or texture that you want to paste on to a plane.
  prefs: []
  type: TYPE_NORMAL
- en: Textures are like wallpapers on walls. Imagine an unpainted wall; now you can
    either color the wall or apply wallpaper. Adding paint is done in the digital
    world by applying a color, like we did for `enemyblock` where we assigned a yellow
    diffuse color to it. To apply a wallpaper in the digital world, we apply using
    textures or images. Here we apply the `wall.png` image to the wall plane geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the wall plane is pretty big in terms of width and height. If we
    let it be, the wall.png image will have to stretch to fit the dimension of the
    wall. So we use the `wrapt` and `wraps` functions so that the wall texture is
    repeated in both the *x* and *y* direction of the plane without stretching the
    wall texture. So this is what happens in the next two lines. We are just repeating
    the wall texture over in both the directions until it fills the whole plane.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we assign the `mipFiler` to `linear`. The filter will decide
    how much detail needs to be added to the texture. If the camera is far enough
    away, it will generate a lower resolution texture to reduce the burden on the
    CPU. If the camera comes closer, then a higher resolution image will be created
    so that all the details of the texture will be visible. This is purely used for
    optimization purposes. Linear filter mode is the most basic type of mode of filters.
    There are other modes called bilinear and trilinear, and so on that will give
    even better results but are computationally expensive. For our purposes, linear
    filtering will suffice. You can see the difference by changing the code and running
    the game on a device.
  prefs: []
  type: TYPE_NORMAL
- en: For the diffuse at the end, we scale down the texture of the image itself depending
    upon how big or small we want the texture to appear on the plane. While scaling,
    we have scaled it to the same proportion as the size of the geometry. So here
    in the *x* and *y* plane, we scale it down by a factor of 1/40 times the values
    of width and height of the geometry. Since we are not scaling in the *z* direction,
    we keep it at `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the image of the diffuse map of the wall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding wall and floor parallax](img/B04014_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the same five steps are repeated for the normal and the specular map.
    We saw that to add wallpaper to the plane we have to use a diffuse map. Now, what
    if this wallpaper has some bumps and holes in it? Not all walls are so smooth.
    So, to add this roughness to the wallpaper, we use what is called a normal map.
    The following is the image of the normal map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding wall and floor parallax](img/B04014_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It basically calculates how light should behave once it hits the normal surface.
    Depending on the direction of the light and if there is a dump or hole in the
    normal map, the lighting will be calculated automatically. All this is done using
    a normal map. A normal is nothing but an image. The code will take information
    from this image to create the desired effect. So, here we assign a normal map
    called `wall_NRM.png` and assign it as content. The next four steps are very similar
    to the ones we performed for diffuse maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us look at specular maps. This map will decide which parts of the
    texture are shiny and which parts are not. Imagine your wallpaper was made of
    stainless steel. To bring this effect, we assign the specular map, and to add
    this, we use the `wall_SPEC.png` file. The next four steps are the same, only
    now we do it separately for the specular map. The image of the specular map is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding wall and floor parallax](img/B04014_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same steps are repeated for the floor geometry as well, only this time we
    have flipped the width and height values.
  prefs: []
  type: TYPE_NORMAL
- en: Once the floor and wall geometries are ready, we assign them to the wall and
    floor nodes.
  prefs: []
  type: TYPE_NORMAL
- en: For the wall nodes, we assign the geometry to the node. Then we rotate the node
    so that the wall is vertical. We rotate the node by –90 degrees in the *y* direction.
    Then we place the first wall at `(15, 0, 0)`, and then add it to the scene. We
    place the second wall node at `(15, 0, 250)`, which will make it adjacent to the
    first plane.
  prefs: []
  type: TYPE_NORMAL
- en: For the floor nodes, we follow a similar process, but here we have to rotate
    it twice to be horizontal to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our wall and floor nodes ready, we can update the positions of the planes
    to create the parallax effect. So, in the `update` function, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will look very familiar to you now. Like we updated and reset the background
    sprites in the SpriteKit game, we are going update the positions of the four nodes
    and then reset the position of all of them if they have gone beyond 250 units
    in the *z* direction.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `addWallandFloorParallax` function to the `addColladaObjects` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this scene, I have also added an ambient light node using the scene graph,
    as otherwise the scene was looking very dark. Go to the `monsterScene.DAE` file,
    and under the scene graph, click on the plus sign and add a new node. Next, right-click
    on the node and select **addLight**. In the panel on the right, select the **Attributes**
    inspector, and under the **Type**, select **Ambient**. Below **Type**, select
    **Color** and choose a dark blue or purple color. Run the game now and you should
    see the result, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding wall and floor parallax](img/B04014_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the icing on the cake, we will include a rain particle effect. For creating
    a particle effect in SceneKit, go to **File** | **New**, and under **Resource**,
    select **SceneKit Particle system**. Click on **Next**, and on the next screen,
    select **Rain** from the **Particle System Template** drop-down list. Click on
    **Next** and give the file a name. I called it `rain`. So now you will have `rain.scnp`
    and `spark.png` files in the project.
  prefs: []
  type: TYPE_NORMAL
- en: To position the particle better, go to the scene graph and create a node called
    `particleNode`, and translate and rotate the node such that it is pointing toward
    the hero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `addRainParticle` to the class and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We create a new constant called `rain` and assign `SCNParticleSystem` to it,
    and provide the `rain` particle system we created in it.
  prefs: []
  type: TYPE_NORMAL
- en: A new `SCNNode` called `particleEmitterNode` is created and we assign the `particleNode`
    we created in the scene graph to it. Then we assign the rain particle system to
    it. Then we add the `particleEmitterNode` to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `warmupDuration` of the particle system and assign a value of `10`
    to it. This is done so that when the game starts, the rain particle effect is
    fast-forwarded to look as if it was already raining.
  prefs: []
  type: TYPE_NORMAL
- en: You can select the `rain.scnp` file and change the parameters to better suit
    your needs. Build and run to see our finished SceneKit game. Call the `addRainParticle`
    function at the end of `addColladaObjects` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding particles](img/B04014_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding audio to the game is exactly like how we added the main theme into the
    SpriteKit game. So, I will leave you guys to experiment with it to figure out
    how to add audio to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I didn't want to want to repeat again how to import the assets to the
    game as we have seen how to do that for over four chapters now. But make sure
    that while calling the files, you provide the correct folder locations. If not,
    then the assets won't be retrieved properly, causing build errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to make a 3D game in SceneKit. From making simple
    geometries to floors, we created a full-fledged game will a complete game loop.
    We added a scene already created in a 3D software package with animation and imported
    it into SceneKit. We didn't have to add a camera or a light source as it was already
    part of the 3D scene.
  prefs: []
  type: TYPE_NORMAL
- en: We imported the COLLADA object into the scene and saw how to access the objects
    through code. We added an enemy and physics to the scene. We used SceneKit's physics
    engine to calculate collision and also applied force to the hero object.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you also saw how to integrate SpriteKit into SceneKit to display
    the score and buttons on the scene. We also used SpriteKit's `touchBegan` function
    to detect touches on the screen and created the play and jump buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Parallax scrolling was also added to the scene using planes. Also, you saw different
    types of maps such as diffuse, normal, and specular maps, and the functionality
    of each. Finally, we added a rain particle system to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will dive deeper into graphics programming and see
    how objects are actually displayed on to the screen using the Metal Graphics library.
  prefs: []
  type: TYPE_NORMAL
