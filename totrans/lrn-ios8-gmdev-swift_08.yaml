- en: Chapter 8. SceneKit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. SceneKit
- en: So, this is it! Finally, we move from the 2D world to 3D. With SceneKit, we
    can make 3D games quite easily, especially since the syntax for SceneKit is quite
    similar to SpriteKit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是全部！最后，我们从2D世界过渡到3D。使用SceneKit，我们可以轻松地制作3D游戏，特别是由于SceneKit的语法与SpriteKit非常相似。
- en: When we say 3D games, we don't mean that you get to put on your 3D glasses to
    make the game. In 2D games, we mostly work in the x and y coordinates. In 3D games,
    we deal with all three axes *x*, *y*, and *z*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说3D游戏时，并不意味着你可以戴上3D眼镜来玩游戏。在2D游戏中，我们主要在x和y坐标上工作。在3D游戏中，我们处理所有三个轴*x*、*y*和*z*。
- en: Additionally, in 3D games, we have different types of lights that we can use.
    Also, SceneKit has an inbuilt physics engine that will take care of forces such
    as gravity and will also aid collision detection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在3D游戏中，我们有不同类型的灯光可以使用。SceneKit还内置了物理引擎，它将处理重力等力，并有助于碰撞检测。
- en: We can also use SpriteKit in SceneKit for GUI and buttons so that we can add
    scores and interactivity to the game. So, there is a lot to cover in this chapter.
    Let's get started.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在SceneKit中使用SpriteKit来添加GUI和按钮，以便我们可以添加分数和交互性。所以，本章有很多内容要介绍。让我们开始吧。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Creating a scene with SCNScene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SCNScene创建场景
- en: Adding objects to a scene
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加对象
- en: Importing scenes from external 3D applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部3D应用程序导入场景
- en: Adding physics to the scene
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加物理效果
- en: Adding an enemy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加敌人
- en: Checking collision detection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查碰撞检测
- en: Adding a SpriteKit overlay
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加SpriteKit叠加层
- en: Adding touch interactivity
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加触摸交互
- en: Finishing the gameloop
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成游戏循环
- en: Adding wall and floor parallax
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加墙壁和地板的视差效果
- en: Adding particles
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加粒子
- en: Creating a scene with SCNScene
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SCNScene创建场景
- en: 'First, we create a new SceneKit project. It is very similar to creating other
    projects. Only this time, make sure you select SceneKit from the **Game Technology**
    drop-down list. Don''t forget to select **Swift** for the language field. Choose
    **iPad** as the device and click on **Next** to create the project in the selected
    directory, as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的SceneKit项目。它与创建其他项目非常相似。但这次，请确保您从**游戏技术**下拉列表中选择SceneKit。不要忘记为语言字段选择**Swift**。选择**iPad**作为设备，然后点击**下一步**以在所选目录中创建项目，如下面的截图所示：
- en: '![Creating a scene with SCNScene](img/B04014_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![使用SCNScene创建场景](img/B04014_08_01.jpg)'
- en: Once the project is created, open it. Click on the `GameViewController` class,
    and delete all the contents in the `viewDidLoad` function, delete the `handleTap`
    function, as we will be creating a separate class, and add touch behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，打开它。点击`GameViewController`类，删除`viewDidLoad`函数中的所有内容，删除`handleTap`函数，因为我们将创建一个单独的类，并添加触摸行为。
- en: 'Create a new class called `GameSCNScene` and import the following headers.
    Inherit from the `SCNScene` class and add an `init` function that takes in a parameter
    called view of type `SCNView`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`GameSCNScene`的新类，并导入以下头文件。从`SCNScene`类继承，并添加一个名为`init`的函数，该函数接受一个名为`view`的参数，其类型为`SCNView`：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, create two new constants `scnView` and `_size` of type `SCNView` and `CGSize`,
    respectively. Also, add a variable called `scene` of type `SCNScene`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建两个新的常量`scnView`和`_size`，分别对应类型`SCNView`和`CGSize`。另外，添加一个名为`scene`的变量，其类型为`SCNScene`。
- en: Since we are making a SceneKit game, we have to get the current view, which
    is the type `SCNView`, similar to how we got the view in SpriteKit where we typecasted
    the current view in SpriteKit to `SKView`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在制作SceneKit游戏，我们必须获取当前视图，其类型为`SCNView`，类似于我们在SpriteKit中获取视图的方式，我们在SpriteKit中将当前视图类型转换为`SKView`。
- en: We create a `_size` constant to get the current size of the view. We then create
    a new variable `scene` of type `SCNScene`. `SCNScene` is the class used to make
    scenes in SceneKit, similar to how we would use `SKScene` to create scenes in
    SpriteKit.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`_size`常量来获取当前视图的大小。然后我们创建一个新的变量`scene`，其类型为`SCNScene`。`SCNScene`是SceneKit中用于创建场景的类，类似于我们使用`SKScene`在SpriteKit中创建场景的方式。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Swift would automatically ask to create the `required init` function, so we
    might as well include it in the class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Swift会自动提示创建`required init`函数，所以我们不妨将其包含在类中。
- en: 'Now, move to the `GameViewController` class and create a global variable called
    `gameSCNScene` of type `GameSCNScene` and assign it in the `viewDidLoad` function,
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到`GameViewController`类，创建一个名为`gameSCNScene`的全局变量，其类型为`GameSCNScene`，并在`viewDidLoad`函数中将其赋值，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Great! Now we can add objects in the `GameSCNScene` class. It is better to move
    all the code to a single class so that we can keep the `GameSceneController` class
    clean.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们可以在`GameSCNScene`类中添加对象。最好将所有代码移动到单个类中，这样我们可以保持`GameSceneController`类整洁。
- en: 'In the `init` function of `GameSCNScene`, add the following after the `super.init`
    function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameSCNScene`类的`init`函数中，在`super.init`函数之后添加以下代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we first assign the current view to the `scnView` constant. Next, we set
    the `_size` constant to the dimensions of the current view.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将当前视图分配给`scnView`常量。接下来，我们将`_size`常量设置为当前视图的尺寸。
- en: Next we initialize the scene variable. Then, assign the scene to the scene of
    `scnView`. Next, enable `allowCameraControls` and `showStatistics`. This will
    enable us to control the camera and move it around to have a better look at the
    scene. Also, with statistics enabled, we will see the performance of the game
    to make sure that the FPS is maintained.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化场景变量。然后，将场景分配给`scnView`的场景。接下来，启用`allowCameraControls`和`showStatistics`。这将使我们能够控制相机并在场景中移动它，以便更好地查看场景。此外，启用统计信息后，我们将看到游戏的表现，以确保帧率（FPS）保持稳定。
- en: The `backgroundColor` property of `scnView` enables us to set the color of the
    view. I have set it to yellow so that objects are easily visible in the scene,
    as shown in the following screenshot. With all this set we can run the scene.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`scnView`的`backgroundColor`属性使我们能够设置视图的颜色。我将其设置为黄色，以便在场景中更容易看到对象，如以下截图所示。设置好所有这些后，我们可以运行场景。'
- en: '![Creating a scene with SCNScene](img/B04014_08_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![使用SCNScene创建场景](img/B04014_08_02.jpg)'
- en: Well, it is not all that awesome yet. One thing to notice is that we have still
    not added a camera or a light, but we still see the yellow scene. This is because
    while we have not added anything to the scene yet, SceneKit automatically provides
    a default light and camera for the scene created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，目前还不是那么令人印象深刻。需要注意的一点是，我们还没有添加相机或灯光，但我们仍然看到了黄色的场景。这是因为虽然我们还没有向场景中添加任何内容，但SceneKit自动为创建的场景提供了默认的灯光和相机。
- en: Adding objects to the scene
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加场景中的对象
- en: Let us next add geometry to the scene. We can create some basic geometry such
    as spheres, boxes, cones, tori, and so on in SceneKit with ease. Let us create
    a sphere first and add it to the scene.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来向场景添加几何形状。在SceneKit中，我们可以轻松创建一些基本几何形状，如球体、盒子、圆锥体、环面等。让我们首先创建一个球体并将其添加到场景中。
- en: Adding a sphere to the scene
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将球体添加到场景中
- en: 'Create a function called `addGeometryNode` in the class and add the following
    code in it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中创建一个名为`addGeometryNode`的函数，并在其中添加以下代码：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For creating geometry, we use the `SCNSphere` class to create a sphere shape.
    We can also call `SCNBox`, `SCNCone`, `SCNTorus`, and so on to create box, cone,
    or torus shapes respectively.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建几何形状，我们使用`SCNSphere`类创建球体形状。我们还可以调用`SCNBox`、`SCNCone`、`SCNTorus`等来分别创建盒子、圆锥体或环面形状。
- en: While creating the sphere, we have to provide the radius as a parameter, which
    will determine the size of the sphere. Although to place the shape, we have to
    attach it to a node so that we can place and add it to the scene.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建球体时，我们必须提供一个半径作为参数，这将确定球体的大小。尽管为了放置形状，我们必须将其附加到一个节点上，这样我们就可以放置并添加它到场景中。
- en: So, create a new constant called `sphereNode` of type `SCNNode` and pass in
    the sphere geometry as a parameter. For positioning the node, we have to use the
    `SCNvector3Make` property to place our object in 3D space by providing the values
    for `x`, `y`, and `z`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个新的常量`sphereNode`，其类型为`SCNNode`，并将球体几何形状作为参数传递。为了定位节点，我们必须使用`SCNvector3Make`属性通过提供`x`、`y`和`z`的值在3D空间中放置我们的对象。
- en: Finally, to add the node to the scene, we have to call `scene.rootNode` to add
    the `sphereNode` to scene, unlike SpriteKit where we would simply use `addChild`
    to add objects to the scene.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要将节点添加到场景中，我们必须调用`scene.rootNode`将`sphereNode`添加到场景中，这与SpriteKit不同，在SpriteKit中我们只需使用`addChild`将对象添加到场景中。
- en: With the sphere added, let us run the scene. Don't forget to add `self.addGeometryNode()`
    in the `init` function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 球体添加后，让我们运行场景。别忘了在`init`函数中添加`self.addGeometryNode()`。
- en: We did add a sphere, so why are we getting a circle (shown in the following
    screenshot)? Well, the basic light source used by SceneKit just enables to us
    to see objects in the scene. If we want to see the actual sphere, we have to improve
    the light source of the scene.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实添加了一个球体，那么为什么我们会看到一个圆（如以下截图所示）呢？嗯，SceneKit使用的基灯光源只是使我们能够看到场景中的对象。如果我们想看到实际的球体，我们必须改进场景的光源。
- en: '![Adding a sphere to the scene](img/B04014_08_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![将球体添加到场景中](img/B04014_08_03.jpg)'
- en: Adding light sources
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加光源
- en: 'Let us create a new function called `addLightSourceNode` as follows so that
    we can add custom lights to our scene:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `addLightSourceNode` 的新函数，如下所示，以便我们可以向场景添加自定义灯光：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can add some light sources to see some depth in our sphere object. Here we
    add two types of light source. The first is an omni light. Omni lights start at
    a point and then the light is scattered equally in all directions. We also add
    an ambient light source. An ambient light is the light that is reflected by other
    objects, such as moonlight.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向球体对象添加一些光源，以便看到一些深度。在这里，我们添加两种类型的光源。第一种是泛光灯。泛光灯从一个点开始，然后光线均匀地向所有方向散射。我们还添加了一个环境光源。环境光是被其他物体反射的光，例如月光。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two more types of light sources: directional and spotlight. Spotlight
    is easy to understand, and we usually use it if a certain object needs to be brought
    to attention like a singer on a stage. Directional lights are used if you want
    light to go in a single direction, such as sunlight. The Sun is so far from the
    Earth that the light rays are almost parallel to each other when we see them.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种类型的灯光：方向光和聚光灯。聚光灯很容易理解，我们通常在需要将某个对象（如舞台上的歌手）吸引注意时使用它。如果你想使光线朝一个单一方向传播，例如阳光，则使用方向光。太阳离地球非常远，当我们看到光线时，光线几乎是平行的。
- en: For creating a light source, we create a node called `lightNode` of type `SCNNode`.
    We then assign `SCNLight` to the light property of `lightNode`. We assign the
    omni light type to be the type of the light. We assign position of the light source
    to be at 10 in all three *x*, *y*, and *z* coordinates. Then, we add it to the
    rootnode of the scene.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建光源时，我们创建一个名为 `lightNode` 的节点，其类型为 `SCNNode`。然后，我们将 `SCNLight` 分配给 `lightNode`
    的灯光属性。我们将泛光灯类型分配给灯光的类型。我们将光源的位置分配为在所有三个 *x*、*y* 和 *z* 坐标上的 10。然后，我们将它添加到场景的根节点。
- en: 'Next we add an ambient light to the scene. The first two steps of the process
    are the same as for creating any light source:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在场景中添加一个环境光。这个过程的前两个步骤与创建任何光源的步骤相同：
- en: For the type of light we have to assign `SCNLightTypeAmbient` to assign an ambient
    type light source. Since we don't want the light source to be very strong, as
    it is reflected, we assign a `darkGrayColor` to the color.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于灯光类型，我们必须将 `SCNLightTypeAmbient` 分配给环境类型的光源。由于我们不希望光源非常强烈，因为它会被反射，所以我们分配一个
    `darkGrayColor` 给颜色。
- en: Finally, we add the light source to the scene.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将光源添加到场景中。
- en: There is no need to add the ambient light source to the scene but it will make
    the scene have softer shadows. You can remove the ambient light source to see
    the difference.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要将环境光源添加到场景中，但它会使场景的阴影更柔和。你可以移除环境光源以查看差异。
- en: 'Call the `addLightSourceNode` function in the `init` function. Now, build and
    run the scene to see an actual sphere with proper lighting, as shown in the following
    screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init` 函数中调用 `addLightSourceNode` 函数。现在，构建并运行场景，以查看具有适当照明的实际球体，如下面的截图所示：
- en: '![Adding light sources](img/B04014_08_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![添加光源](img/B04014_08_04.jpg)'
- en: You can place a finger on the screen and move it to rotate the cameras as we
    have enabled camera control. You can use two fingers to pan the camera and you
    can double tap to reset the camera to its original position and direction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在屏幕上放置一个手指并移动它来旋转相机，因为我们已经启用了相机控制。你可以使用两个手指平移相机，你可以双击以将相机重置到其原始位置和方向。
- en: Adding a camera to the scene
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加相机到场景
- en: 'Next let us add a camera to the scene, as the default camera is very close.
    Create a new function called `addCameraNode` to the class and add the following
    code in it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向场景添加一个相机，因为默认相机非常靠近。在类中创建一个名为 `addCameraNode` 的新函数，并在其中添加以下代码：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, again we create an empty node called `cameraNode`. We assign `SCNCamera`
    to the camera property of `cameraNode`. Next we position the camera such that
    we keep the `x` and `y` values at zero and move the camera back in the `z` direction
    by 15 units. Then we add the camera to the rootnode of the scene. Call the `addCameraNode`
    at the bottom of the `init` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次创建一个名为 `cameraNode` 的空节点。我们将 `SCNCamera` 分配给 `cameraNode` 的相机属性。接下来，我们将相机定位，使
    `x` 和 `y` 值保持在零，并在 `z` 方向上将相机向后移动 15 个单位。然后，我们将相机添加到场景的根节点。在 `init` 函数的底部调用 `addCameraNode`。
- en: In this scene, the origin is at the center of the scene, unlike SpriteKit where
    the origin of a scene is always at bottom right of the scene. Here the positive
    *x* and *y* are to the right and up from the center. The positive *z* direction
    is toward you.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，原点位于场景中心，与SpriteKit中场景的原点始终位于场景右下角不同。在这里，正*x*和*y*是从中心向右和向上的。正*z*方向朝向你。
- en: '![Adding a camera to the scene](img/B04014_08_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![添加相机到场景](img/B04014_08_05.jpg)'
- en: We didn't move the sphere back or reduce its size here. This is purely because
    we brought the camera backward in the scene.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有将球体移回或缩小其大小，这纯粹是因为我们在场景中向后移动了相机。
- en: Let us next create a floor so that we can have a better understanding of the
    depth in the scene. Also, in this way, we will learn how to create floors in the
    scene.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来创建一个地板，这样我们就可以更好地理解场景中的深度。同时，通过这种方式，我们将学习如何在场景中创建地板。
- en: Adding a floor
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加地板
- en: 'In the class, add a new function called `addFloorNode` and add the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中添加一个名为`addFloorNode`的新函数，并添加以下代码：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For creating a floor, we create a variable called `floorNode` of type `SCNNode`.
    We then assign `SCNFloor` to the geometry property of `floorNode`. For the position,
    we assign the `y` value to `-1` as we want the sphere to appear above the floor.
    At the end, as usual, we assign the `floorNode` to the root node of the scene.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建地板，我们创建了一个名为`floorNode`的变量，其类型为`SCNNode`。然后我们将`SCNFloor`分配给`floorNode`的几何属性。对于位置，我们将`y`值设置为`-1`，因为我们希望球体出现在地板上方。最后，像往常一样，我们将`floorNode`分配给场景的根节点。
- en: In the following screenshot, I have rotated the camera to show the scene in
    full action. Here we can see the floor is gray in color and the sphere is casting
    its reflection on the floor, and we can also see the bright omni light at the
    top left of the sphere.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我已经旋转了相机以展示整个场景的动作。在这里，我们可以看到地板是灰色的，球体在地面上投射出它的反射，我们还可以看到球体顶部左边的明亮泛光灯。
- en: '![Adding a floor](img/B04014_08_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![添加地板](img/B04014_08_06.jpg)'
- en: Importing scenes from external 3D applications
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部3D应用程序导入场景
- en: Although we can add objects, cameras, and lights through code, it will become
    very tedious and confusing when we have a lot of objects added to the scene. In
    SceneKit, this problem can be easily overcome by importing scenes prebuilt in
    other 3D applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过代码添加对象、相机和灯光，但当场景中添加了很多对象时，这会变得非常繁琐和混乱。在SceneKit中，这个问题可以通过导入其他3D应用程序预先构建的场景来轻松解决。
- en: All 3D applications such as 3D StudioMax, Maya, Cheetah 3D, and Blender have
    the ability to export scenes in Collada (`.dae`) and Alembic (`.abc`) format.
    We can import these scenes with lighting, camera, and textured objects into SceneKit
    directly, without the need for setting up the scene.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有3D应用程序，如3D StudioMax、Maya、Cheetah 3D和Blender，都有导出Collada（`.dae`）和Alembic（`.abc`）格式场景的能力。我们可以直接将这些场景导入SceneKit，其中包含灯光、相机和纹理化对象，无需设置场景。
- en: In this section, we will import a Collada file into the scene. In the resources
    folder for this chapter, you will find the `monsterScene.DAE` file. Drag this
    file into the current project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将导入一个Collada文件到场景中。在本章的资源文件夹中，你可以找到`monsterScene.DAE`文件。将此文件拖动到当前项目中。
- en: '![Importing scenes from external 3D applications](img/B04014_08_07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![从外部3D应用程序导入场景](img/B04014_08_07.jpg)'
- en: Along with the DAE file, also add the `monster.png` file to the project, otherwise
    you will see only the untextured monster mesh in the scene.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了DAE文件外，还需要将`monster.png`文件添加到项目中，否则你将只看到场景中未纹理化的怪物网格。
- en: Click on the `monsterScene.DAE` file. If the textured monster is not automatically
    loaded, drag the `monster.png` file from the project into the monster mesh in
    the preview window. Release the mouse button once you see a (**+**) sign while
    over the monster mesh. Now you will be able to see the monster properly textured.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`monsterScene.DAE`文件。如果纹理化的怪物没有自动加载，请将`monster.png`文件从项目中拖动到预览窗口中的怪物网格。当鼠标悬停在怪物网格上并出现一个(**+**)符号时，释放鼠标按钮。现在你将能够正确地看到怪物被纹理化。
- en: The panel on the left shows the entities in the scene. Below the entities, the
    scene graph is shown and the view on the right is the preview pane.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的面板显示了场景中的实体。在实体下方显示场景图，右侧的视图是预览窗格。
- en: Entities show all the objects in the scene and the scene graph shows the relation
    between these entities. If you have certain objects that are children to other
    objects, the scene graph will show them as a tree. For example, if you open the
    triangle next to **CATRigHub001**, you will see all the child objects under it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实体显示场景中的所有对象，场景图显示了这些实体之间的关系。如果你有某些对象是其他对象的子对象，场景图将它们显示为树状结构。例如，如果你打开**CATRigHub001**旁边的三角形，你将看到其下的所有子对象。
- en: You can use the scene graph to move and rotate objects in the scene to fine-tune
    your scene. You can also add nodes, which can be accessed by code. You can see
    that we already have a camera and a spotlight in the scene. You can select each
    object and move it around using the arrow at the pivot point of the object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用场景图来移动和旋转场景中的对象以微调你的场景。你还可以添加节点，这些节点可以通过代码访问。你可以看到我们已经在场景中有一个相机和一个聚光灯。你可以选择每个对象，并使用对象的轴点上的箭头将其移动。
- en: You can also rotate the scene to get a better view by clicking and dragging
    the left mouse button on the preview scene. For zooming, scroll your mouse wheel
    up and down. To pan, hold the *Alt* button on the keyboard and left-click and
    drag on the preview pane.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在预览场景上点击并拖动左鼠标按钮来旋转场景以获得更好的视角。为了缩放，上下滚动鼠标滚轮。要平移，按住键盘上的*Alt*键，然后左键点击并拖动预览窗格。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing to note is that rotating, zooming, and panning in the preview pane
    won't actually move your camera. The camera is still at the same position and
    angle. To view from the camera, again select the **Camera001** option from the
    drop-down list in the preview pane and the view will reset to the camera view.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在预览窗格中进行旋转、缩放和平移实际上并不会移动你的相机。相机仍然处于相同的位置和角度。要从前视图查看，再次从预览窗格的下拉列表中选择**Camera001**选项，视图将重置为相机视图。
- en: At the bottom of the preview window, we can either choose to see the view through
    the camera or spotlight, or click-and-drag to rotate the free camera. If you have
    more than one camera in your scene, then you will have **Camera002**, **Camera003**,
    and so on in the drop-down list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览窗口的底部，我们可以选择通过相机或聚光灯查看视图，或者点击并拖动以旋转自由相机。如果你在场景中有多于一个相机，那么在下拉列表中你将看到**Camera002**、**Camera003**等等。
- en: Below the view selection dropdown in the preview panel you also have a play
    button. If you click on the play button, you can look at the default animation
    of the monster getting played in the preview window.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览面板中的视图选择下拉菜单下方，你还有一个播放按钮。如果你点击播放按钮，你可以在预览窗口中查看怪物的默认动画。
- en: The preview panel is just that; it is just to aid you in having a better understanding
    of the objects in the scene. In no way is it a replacement for a regular 3D package
    such as 3DSMax, Maya, or Blender.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 预览面板就是这样；它只是为了帮助你更好地理解场景中的对象。它绝不是3DSMax、Maya或Blender等常规3D软件的替代品。
- en: You can create cameras, lights, and empty nodes in the scene graph, *but you
    can't add geometry such as boxes and spheres*. You can add an empty node and position
    it in the scene graph, and then add geometry in code and attach it to the node.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在场景图中创建相机、灯光和空节点，*但无法添加如盒子或球体这样的几何形状*。你可以添加一个空节点并将其定位在场景图中，然后在代码中添加几何形状并将其附加到该节点上。
- en: Now that we have an understanding of the scene graph, let us see how we can
    run this scene in SceneKit.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了场景图，让我们看看我们如何在SceneKit中运行这个场景。
- en: In the `init` function, delete the line where we initialized the scene and add
    the following line instead. Also delete the objects, light, and camera we added
    earlier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，删除我们初始化场景的行，并添加以下行代替。同时删除我们之前添加的对象、灯光和相机。
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Build and run the game to see the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行游戏以查看以下截图：
- en: '![Importing scenes from external 3D applications](img/B04014_08_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![从外部3D应用程序导入场景](img/B04014_08_08.jpg)'
- en: You will see the monster running and the yellow background that we initially
    assigned to the scene. While exporting the scene, if you export the animations
    as well, once the scene loads in SceneKit the animation starts playing automatically.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到怪物在跑动，以及我们最初分配给场景的黄色背景。在导出场景时，如果你导出了动画，一旦场景在SceneKit中加载，动画就会自动播放。
- en: Also, you will notice that we have deleted the camera and light in the scene.
    So, how come the default camera and the light aren't loaded in the scene?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还会注意到我们已经删除了场景中的相机和灯光。那么，为什么默认的相机和灯光没有加载到场景中呢？
- en: What is happening here is that while I exported the file, I inserted a camera
    in the scene and also added a spotlight. So, when we imported the file into the
    scene, SceneKit automatically understood that there is a camera already present,
    so it will use the camera as its default camera. Similarly, a spotlight is already
    added in the scene, which is taken as the default light source, and lighting is
    calculated accordingly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，在我导出文件时，我在场景中插入了一个相机，并添加了一个聚光灯。因此，当我们将文件导入场景时，SceneKit自动理解场景中已经存在一个相机，因此它将使用该相机作为其默认相机。同样，场景中已经添加了一个聚光灯，它被视为默认光源，并且相应地计算照明。
- en: Adding objects and physics to the scene
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向场景添加对象和物理
- en: Let us now see how we can access each of the objects in the scene graph and
    add gravity to the monster. Later in this chapter, we will see how we can add
    a touch interface by which we will be able to make the hero character jump by
    applying an upward force.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何访问场景图中的每个对象，并为怪物添加重力。在本章的后面部分，我们将看到如何添加一个触摸界面，通过这个界面我们可以通过施加向上的力使英雄角色跳跃。
- en: Accessing the hero object and adding a physics body
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问英雄对象并添加物理身体
- en: 'So, create a new function called `addColladaObjects` and call an `addHero`
    function in it. Create a global variable called `heroNode` of type `SCNNode`.
    We will use this node to access the hero object in the scene. In the `addHero`
    function, add the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个名为`addColladaObjects`的新函数，并在其中调用一个`addHero`函数。创建一个名为`heroNode`的全局变量，其类型为`SCNNode`。我们将使用此节点来访问场景中的英雄对象。在`addHero`函数中，添加以下代码：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we call the `addColladaObjects` function in the `init` function, as highlighted.
    Then we create the `addHero` function. In it we initiate the `heroNode`. Then,
    to actually move the monster, we need access to the `CatRibHub001` node to move
    the monster. We gain access to it through the `ChildWithName` property of `scene.rootNode`.
    For each object that we wish to gain access to through code, we will have to use
    the `ChildWithName` property of the `rootNode` of the scene and pass in the name
    of the object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`init`函数中调用`addColladaObjects`函数，如高亮所示。然后我们创建`addHero`函数。在其中我们初始化`heroNode`。然后，为了实际移动怪物，我们需要访问`CatRibHub001`节点来移动怪物。我们通过`scene.rootNode.ChildWithName`属性来获取访问权限。对于我们希望通过代码访问的每个对象，我们都需要使用场景的`rootNode`的`ChildWithName`属性，并传入对象的名称。
- en: If recursively is set to `true`, to get said object, SceneKit will go through
    all the child nodes to get access to the specific node. Since the node that we
    are looking for is right on top, we said `false` to save processing time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归设置为`true`，SceneKit将通过所有子节点来获取该对象。由于我们正在寻找的节点就在顶部，所以我们将其设置为`false`以节省处理时间。
- en: We create a temporary variable called `monsterNode`. In the next step, we add
    the `monsterNode` variable to `heroNode`. We then set the position of the hero
    node to the origin.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个临时变量`monsterNode`。在下一步中，我们将`monsterNode`变量添加到`heroNode`中。然后我们将英雄节点的位置设置为原点。
- en: For `heroNode` to interact with other physics bodies in the scene, we have to
    assign a shape to the physics body of `heroNode`. We could use the mesh of the
    monster, but the shape might not be calculated properly and a box is a much simpler
    shape than the mesh of the monster. For creating a box collider, we create a new
    box geometry roughly the width, height, and depth of the monster.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`heroNode`能够与场景中的其他物理身体交互，我们必须为`heroNode`的物理身体分配一个形状。我们可以使用怪物的网格，但形状可能计算不正确，而一个盒子比怪物的网格简单得多。为了创建一个盒子碰撞器，我们创建了一个新的盒子几何体，其宽度、高度和深度大致与怪物的尺寸相匹配。
- en: Then, using the `physicsBody.physicsShape` property of the `heroNode`, we assign
    the shape of the `collisionBox` we created for it. Since we want the body to be
    affected by gravity, we assign the physics body type to be dynamic. Later we will
    see other body types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`heroNode.physicsBody.physicsShape`属性，我们为其分配了我们为其创建的`collisionBox`的形状。由于我们希望物体受到重力的影响，我们将物理身体类型设置为动态。稍后我们将看到其他身体类型。
- en: Since we want the body to be highly responsive to gravity, we assign a value
    of `20` to the `mass` of the body. In the next step, we set the `angularVelocityFactor`
    to `0` in all three directions, as we want the body to move straight up and down
    when a vertical force is applied. If we don't do this, the body will flip-flop
    around.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望物体对重力有高度的反应，我们将物体的质量值设置为`20`。在下一步中，我们将所有三个方向的`angularVelocityFactor`设置为`0`，因为我们希望当施加垂直力时，物体能够直接上下移动。如果我们不这样做，物体将会翻来覆去。
- en: We also assign the name `hero` to the monster to check if the collided object
    is the hero or not. This will come in handy when we check for collision with other
    objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add `heroNode` to the scene.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Add the `addColladaObjects` to the `init` function and comment or delete the
    `self.addGeometryNode`, `self.addLightSourceNode`, `self.addCameraNode`, and `self.addFloorNode`
    functions if you haven't already. Then, run the game to see the monster slowly
    falling through.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: We will create a small patch of ground right underneath the monster so that
    it doesn't fall down.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ground
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new function called `addGround` and add the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We create a new constant called `groundBox` of type `SCNBox,` with a width and
    length of `10`, and height of `2`. Chamfer is the rounding of the edges of the
    box. Since we didn't want any rounding of the corners, it is set to `0`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a `SCNNode` called `groundNode` and assign `groundBox` to it.
    We place it slightly below the origin. Since the height of the box is `2`, we
    place it at `–1.01` so that `heroNode` will be `(0, 0, 0)` when the monster rests
    on the ground.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Next we assign the physics body of type static body. Also, since we don't want
    the hero to bounce off the ground when he falls on it, we set the restitution
    to `0`. Finally, we then add the ground to the scene's rootnode.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The reason we made this body static instead of dynamic is because a dynamic
    body gets affected by gravity and other forces but a static one doesn't. So, in
    this scene, even though gravity is acting downward, the hero will fall but `groundBox`
    won't as it is a static body.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the physics syntax is very similar to SpriteKit with static
    bodies and dynamic bodies, gravity, and so on. And once again, similar to SpriteKit,
    the physics simulation is automatically turned on when we run the scene.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Add the `addGround` function in the `addColladaObjects` functions and run the
    game to see the monster getting affected by gravity and stopping after coming
    in touch with the ground.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the ground](img/B04014_08_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Adding an enemy node
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To check collision in SceneKit, we can check for collision between the hero
    and the ground. But let us make it a little more interesting and also learn a
    new kind of body type: the kinematic body.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will create a new box called `enemy` and make it move and collide
    with the hero. Create a new global `SCNNode` called `enemyNode` as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, create a new function called `addEnemy` to the class and add the following
    in it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Nothing too fancy here! Just as when adding the `groundNode`, we have created
    a cube with all its sides four units long. We have also added a yellow color to
    its material. We then initialize `enemyNode` in the function. We position the
    node along the *x*, *y*, and **z** axes. Assign the body type as kinematic instead
    of static or dynamic. Then we add the body to the scene and finally name the `enemyNode`
    as `enemy`, which we will be needing while checking for collision. Before we forget,
    call the `addEnemy` function in the `addColladaObjects` function after where we
    called the `addHero` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的地方！就像添加`groundNode`时，我们创建了一个所有边长为四单位的立方体。我们还为其材质添加了黄色。然后在函数中初始化`enemyNode`。我们将节点沿*x*、*y*和**z**轴定位。将身体类型设置为运动学而非静态或动态。然后我们将身体添加到场景中，并最终将`enemyNode`命名为`enemy`，这是我们检查碰撞时需要的。在我们忘记之前，在调用`addHero`函数之后，在`addColladaObjects`函数中调用`addEnemy`函数。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The difference between the kinematic body and other body types is that, like
    static, external forces cannot act on the body, but we can apply a force to a
    kinematic body to move it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运动学身体与其他身体类型的区别在于，就像静态一样，外部力不能作用于身体，但我们可以对运动学身体施加力来移动它。
- en: In the case of a static body, we saw that it is not affected by gravity and
    even if we apply a force to it, the body just won't move.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态身体的情况下，我们看到了它不受重力影响，即使我们对其施加力，身体也不会移动。
- en: Here we won't be applying any force to move the enemy block but will simply
    move the object like we moved the enemy in the SpriteKit game. So, it is like
    making the same game, but in 3D instead of 2D, so that you can see that although
    we have a third dimension, the same principles of game development can be applied
    to both.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不会应用任何力来移动敌人方块，而只是像我们在SpriteKit游戏中移动敌人一样移动对象。所以，这就像是制作同样的游戏，但是在3D而不是2D中，这样你就可以看到，尽管我们有第三维度，但游戏开发的原则同样适用于两者。
- en: 'For moving the enemy, we need an `update` function for the enemy. So, let us
    add it to the scene by creating an `updateEnemy` function and adding the following
    to it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动敌人，我们需要为敌人添加一个`update`函数。因此，让我们通过创建一个`updateEnemy`函数并将其添加到其中来将其添加到场景中：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `update` function, similar to how we moved the enemy in the SpriteKit
    game, we increment the `Z` position of the enemy node by 0.9\. The difference
    being that we are moving the *z* direction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`函数中，类似于我们在SpriteKit游戏中移动敌人的方式，我们将敌人节点的`Z`位置增加0.9。不同的是，我们是在移动*z*方向。
- en: Once the enemy has gone beyond `–40` in the *z* direction, we reset the position
    of the enemy. To create an additional challenge to the player, when the enemy
    resets, a random number is chosen between `1` and `2`. If it is `1`, then the
    enemy is placed closer to the ground, otherwise it is placed at 15 units from
    the ground.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人超过*z*方向的`-40`时，我们重置敌人的位置。为了给玩家创造额外的挑战，当敌人重置时，会随机选择`1`和`2`之间的一个数字。如果是`1`，则敌人放置得更靠近地面，否则它放置在离地面15个单位的位置。
- en: Later, we will add a jump mechanic to the hero. So, when the enemy is closer
    to the ground, the hero has to jump over the enemy box, but when the enemy is
    spawned at a height, the hero shouldn't jump. If he jumps and hits the enemy box,
    then it is game over. Later we will also add a scoring mechanism to keep score.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将为英雄添加一个跳跃机制。因此，当敌人靠近地面时，英雄必须跳过敌人盒子，但如果敌人以高度生成，英雄则不应该跳跃。如果他跳跃并击中敌人盒子，那么游戏就结束了。之后我们还将添加一个计分机制来记录分数。
- en: 'For updating the enemy, we actually need an update function to add the `enemyUpdate`
    function to so that the enemy moves and his position resets. So, create a function
    called update in the class and call the `updateEnemy` function in it as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新敌人，我们实际上需要一个更新函数来添加`enemyUpdate`函数，以便敌人移动并且其位置重置。因此，在类中创建一个名为`update`的函数，并在其中调用`updateEnemy`函数，如下所示：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Updating objects in the scene
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新场景中的对象
- en: 'In SceneKit, there is an update function that gets called after the scene is
    rendered. We will use this function to call the `update` function of our game.
    In the `GameViewController` class, add the following function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在SceneKit中，有一个在场景渲染后调用的更新函数。我们将使用此函数来调用我们游戏的`update`函数。在`GameViewController`类中，添加以下函数：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To call the `rendererUpdateAtTime` function, the `GameViewController` class
    needs to inherit from `SCNSceneRendererDelegate`. So, where the class is created,
    add the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`rendererUpdateAtTime`函数，`GameViewController`类需要继承自`SCNSceneRendererDelegate`。因此，在创建类的地方，添加以下代码：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, in the `viewDidLoad` function, set the current delegate to self as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`viewDidLoad`函数中，将当前代理设置为self，如下所示：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Delegates are a part of code design patterns. Using delegates, a class can let
    a different class gain access and perform some of its responsibilities. Here `SceneRenderer`
    is delegating to `scnView` by assigning the delegate as self.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是代码设计模式的一部分。使用代理，一个类可以让另一个类获得访问权限并执行其部分职责。在这里，`SceneRenderer`通过将代理设置为self来将`scnView`委托出去。
- en: The `rendererUpdateAtTime` function is a system function that gets called after
    all the objects are rendered in the scene. So, once the scene is rendered, the
    objects in the scene can be updated, otherwise it might result in artifacting.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`rendererUpdateAtTime`函数是一个系统函数，在场景中所有对象渲染完毕后被调用。因此，一旦场景渲染完毕，场景中的对象就可以更新，否则可能会导致伪影。'
- en: Now, if we build and run the game, we see `enemyBox` getting updated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们构建并运行游戏，我们会看到`enemyBox`被更新。
- en: But there is a problem, when the box hits the hero, the hero gets knocked off
    his pedestal and goes flying. This is because, firstly, the hero is a dynamic
    body, so external forces will affect him. Secondly, though we are moving the box
    manually without applying any force, e we are still moving the box and there is
    some inertial force calculated by SceneKit, so once the box hits the hero, the
    energy is transferred to the hero, and it acts like an external force applied
    on the hero so the hero starts moving.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但存在问题，当盒子击中英雄时，英雄从他的祭坛上被撞飞。这是因为，首先，英雄是一个动态体，所以外部力会影响他。其次，尽管我们手动移动盒子而没有施加任何力，但我们仍在移动盒子，并且SceneKit计算了一些惯性力，所以一旦盒子击中英雄，能量就转移到英雄身上，它就像施加在英雄身上的外部力一样，使英雄开始移动。
- en: Since we constrained the rotation of the hero using `heroNode.physicsBody?.angularVelocityFactor
    = SCNVector3Zero`, when the box hits him, he is not rotating. If we comment or
    delete the line, the hero will spin because of the box hitting him.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`heroNode.physicsBody?.angularVelocityFactor = SCNVector3Zero`限制了英雄的旋转，当盒子击中他时，他不会旋转。如果我们注释或删除该行，英雄会因为盒子的撞击而旋转。
- en: '![Updating objects in the scene](img/B04014_08_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![更新场景中的对象](img/B04014_08_10.jpg)'
- en: We will fix this issue when we check for collision. When the collision occurs,
    we will reset the position of the hero and box to their initial positions. So,
    let us next look at how to check for collision.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查碰撞时，我们将修复这个问题。当发生碰撞时，我们将英雄和盒子的位置重置到它们的初始位置。因此，让我们接下来看看如何检查碰撞。
- en: Checking for contact between objects
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查物体之间的接触
- en: The physics engine of SceneKit has inbuilt functions that check for contact
    between objects when physics is enabled. A contact is triggered when two objects
    are just about to touch each other.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: SceneKit的物理引擎具有内置的函数，当启用物理时检查物体之间的接触。当两个物体即将接触时，会触发接触。
- en: For checking contacts, we have to use the `didBeginContact` function of `physicsWorld`;
    so add the following code to the class. Also, we have to inherit from `SCNPhysicsContactDelegate`
    and set the `GameSCNScene` class as the contact delegate.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检查接触，我们必须使用`physicsWorld`的`didBeginContact`函数；因此，将以下代码添加到类中。同时，我们必须继承自`SCNPhysicsContactDelegate`并将`GameSCNScene`类设置为接触代理。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to calling `RenderDelegate` in `GameViewController`, to be able to receive
    "contact" events in the provided `GameSCNScene` by the physics engine and be able
    to manipulate them, the `GameSCNScene` class inherits from `SCNPhysicsContactDelegate`
    and the scene's `contactDelegate` is set to `self`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于在`GameViewController`中调用`RenderDelegate`，为了能够通过物理引擎在提供的`GameSCNScene`中接收“接触”事件并能够操作它们，`GameSCNScene`类继承自`SCNPhysicsContactDelegate`，并且场景的`contactDelegate`被设置为`self`。
- en: 'So, at the top of the class, inherit from `SCNPhysicsContactDelegate`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在类的顶部，继承自`SCNPhysicsContactDelegate`：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And, in the `init` function, add the following to set the current class as
    contact delegate:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，在`init`函数中，添加以下内容以设置当前类为接触代理：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add the `didBeginContact` function to the class as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`didBeginContact`函数添加到类中，如下所示：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When two physics objects collide, the nodes are stored in the contact variable.
    Since we already named our physics body objects, we check if the first body is
    of the hero's and the other body that the hero collided with is of the enemy.
    If true, we print out contact and also set the velocity of the first body to zero.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个物理对象发生碰撞时，节点存储在`contact`变量中。由于我们已经为我们的物理体对象命名，我们检查第一个物体是否是英雄的，而英雄碰撞的另一个物体是否是敌人的。如果是，我们将打印出`contact`并也将第一个物体的速度设置为零。
- en: Since ours is a small game, we can guess that body *A* would be the hero and
    body *B* will be the enemy. In bigger games with many collisions happening in
    a second, it might be hard to determine which is body *A* and which is body *B*.
    In such cases, we will have to check for both cases, that is, is body *A* of enemy
    or hero and vice versa for body *B*, then make the necessary conclusion.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏规模较小，我们可以推测身体**A**将是英雄，而身体**B**将是敌人。在更大型的游戏中，每秒发生许多碰撞，可能很难确定哪个是身体**A**，哪个是身体**B**。在这种情况下，我们将不得不检查两种情况，即身体**A**是否是敌人还是英雄，以及身体**B**的相反情况，然后做出必要的结论。
- en: So, now we have added a hero and an enemy and we have our collision set up.
    Next we will see how to implement a 2D overlay over our 3D scene so that we can
    display buttons and score and add a game over condition for our simple game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经添加了英雄和敌人，并且我们设置了碰撞。接下来，我们将看到如何在我们的3D场景上实现2D覆盖层，以便我们可以显示按钮和得分，并为我们的简单游戏添加游戏结束条件。
- en: Adding a SpriteKit overlay
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加SpriteKit覆盖层
- en: 'For showing scores and buttons for the game, we will add 2D SpriteKit layer.
    For adding the overlay, create a class called `OverlaySKscene`. In this class,
    add the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示游戏得分和按钮，我们将添加一个2D SpriteKit层。为了添加覆盖层，创建一个名为`OverlaySKscene`的类。在这个类中，添加以下内容：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To import SpriteKit we will have to create a subclass of SpriteKit. Create
    global variables of type `GameSCNScene`, `SKLabelNodes`, and `SpriteNodes`. Here
    we create two `LabelNodes`: one for displaying score and the other to show "game
    over" text. We also create two `spriteNodes`: one for the play button and the
    other for the jump button.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导入SpriteKit，我们必须创建一个SpriteKit的子类。创建全局变量`GameSCNScene`、`SKLabelNodes`和`SpriteNodes`类型。在这里，我们创建了两个`LabelNodes`：一个用于显示得分，另一个用于显示“游戏结束”文本。我们还创建了两个`spriteNodes`：一个用于播放按钮，另一个用于跳跃按钮。
- en: We add the required `init` function and the default init function. The default
    `init` will take in the size of the scene and reference to the `GameSCNScene`
    class as parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加所需的`init`函数和默认的`init`函数。默认的`init`将接受场景的大小和`GameSCNScene`类的引用作为参数。
- en: In the `init` function, we initialize the super class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，我们初始化超类。
- en: Adding labels and buttons
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标签和按钮
- en: 'Next, in the `init` function, add the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`init`函数中，添加以下代码：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `init` function, first, we set the `gameScene` passed to the `_gameScene`
    property of the scene.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，首先，我们将传递给`_gameScene`属性的`gameScene`设置为`gameScene`。
- en: Next we initialize both the `scoreLabel` and `gameOverLabel`. We set the values
    for `text`, `color`, `textsize`, and `position` and add it to the scene. In `gameOverLabel`,
    we set hidden to `true`, as we only want the text to display once the game is
    over.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化`scoreLabel`和`gameOverLabel`。我们设置`text`、`color`、`textsize`和`position`的值，并将其添加到场景中。在`gameOverLabel`中，我们将`hidden`设置为`true`，因为我们只想在游戏结束后显示文本。
- en: We then initialize the play and jump buttons that we made in SpriteKit. We set
    the jump button sprite to be hidden, as we want it to display only when the play
    button is clicked and the game starts. The images for the jump and play button
    are provided in the resources folder of the chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们初始化我们在SpriteKit中制作的播放和跳跃按钮。我们将跳跃按钮精灵设置为隐藏，因为我们希望它在播放按钮被点击并开始游戏时才显示。跳跃和播放按钮的图像在章节的资源文件夹中提供。
- en: Adding touch interactivity
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加触摸交互性
- en: For adding touch interactivity, we will use the `touchesBegan` function similar
    to how we have always used it in SpriteKit. So, here we get the location of the
    touch and name of the sprite under the touch location. If the sprite name is `jumpBtn`
    and the `gameOver` Boolean is `false`, then we call the `heroJump` function in
    the `gameScene` class. If `gameOver` is `true` and if the play button is clicked,
    then we call the `startGame` function in the SceneKit class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加触摸交互性，我们将使用与我们在SpriteKit中一直使用的类似方式的`touchesBegan`函数。因此，我们获取触摸位置和触摸下精灵的名称。如果精灵名称是`jumpBtn`且`gameOver`布尔值为`false`，则我们在`gameScene`类中调用`heroJump`函数。如果`gameOver`为`true`并且如果播放按钮被点击，则我们在SceneKit类中调用`startGame`函数。
- en: 'So, add the function as follows to detect touches:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，添加以下函数以检测触摸：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's all for the SpriteKit class. We will be adding the `gameOver` Boolean,
    and `heroJump` and `startGame` functions in the SceneKit class. The code will
    show some errors until we create it, so ignore the errors for now.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是SpriteKit类的全部内容。我们将在SceneKit类中添加`gameOver`布尔值、`heroJump`和`startGame`函数。代码在创建之前会显示一些错误，所以现在请忽略这些错误。
- en: Finishing the game loop
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成游戏循环
- en: 'Move back to the SceneKit class and import SpriteKit at the top of the class
    as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 SceneKit 类，并在类顶部导入 SpriteKit，如下所示：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, create a global variable called `skScene` of type `OverlaySKScene`. Add
    a new function called `addSpriteKitOverlay` and add the following code in the
    SceneKit class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建一个名为 `skScene` 的全局变量，类型为 `OverlaySKScene`。在 SceneKit 类中添加一个名为 `addSpriteKitOverlay`
    的新函数，并添加以下代码：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we initialize the `skScene` global variable we created earlier and pass
    in the size of the current scene and the current SceneKit class. Next we assign
    the `skScene` class to the `overlaySKScene` property of `scnView`. Finally, we
    set the `scaleMode` of the `skScene` variable to type `SKSceneScaleMode.ResizeFill`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化之前创建的 `skScene` 全局变量，并传入当前场景的大小和当前 SceneKit 类。接下来，我们将 `skScene` 类分配给
    `scnView` 的 `overlaySKScene` 属性。最后，我们将 `skScene` 变量的 `scaleMode` 设置为 `SKSceneScaleMode.ResizeFill`
    类型。
- en: 'Finally, call the `addSpriteKitOverlay` function in the `addColladaObjects`
    function as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `addColladaObjects` 函数中调用 `addSpriteKitOverlay` 函数，如下所示：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Making the hero jump
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使英雄跳跃
- en: We still need to add the Boolean and functions to the class to make our game
    work. So, at the top of the class, create a global variable called `gameOver`
    and set it to `true`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要向类中添加布尔值和函数，以便我们的游戏能够运行。因此，在类顶部创建一个名为 `gameOver` 的全局变量，并将其设置为 `true`。
- en: 'Next, create a new function called `heroJump` as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `heroJump` 的新函数，如下所示：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we apply an upward force of `1400` units in the *y* direction to `heroNode`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对 `heroNode` 应用一个向上的力 `1400` 单位在 *y* 方向上。
- en: 'Next, create the `gameStart` function as follows and add it into the class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 `gameStart` 函数，如下所示，并将其添加到类中：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `gameOver` Boolean is set to `false`. We set the jump button and `scoreLabel`
    to be visible and hide the play button and `gameOverlabel`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `gameOver` 布尔值设置为 `false`。我们将跳跃按钮和 `scoreLabel` 设置为可见，并隐藏播放按钮和 `gameOverlabel`。
- en: For keeping track and displaying the score, we need a score variable, so create
    a global variable called `score` of type `int` and initialize it to `0` at the
    top of the class. Again, in the `startGame` function, set the value to `0` so
    that every time the function is called the value is reset. Also, we set the `scoreLabel`
    text to reflect the current score at the start of the game.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪和显示得分，我们需要一个得分变量，因此创建一个名为 `score` 的全局变量，类型为 `int`，并在类顶部将其初始化为 `0`。同样，在 `startGame`
    函数中，将值设置为 `0`，以便每次函数被调用时值都会重置。此外，我们将 `scoreLabel` 文本设置为反映游戏开始时的当前得分。
- en: For scoring in the game, we will increment the score every time the enemy block
    goes beyond the screen and gets reset. If the block hits the hero, then it will
    be game over.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏中的得分，每次敌人方块超出屏幕并重置时，我们将增加分数。如果方块击中英雄，则游戏结束。
- en: 'So, in the `enemyUpdate` function, add the following highlighted line after
    we check if the enemy''s `Z` position is less than `–40` to update the score and
    `scoreLabel` text:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `enemyUpdate` 函数中，在我们检查敌人的 `Z` 位置是否小于 `-40` 后，添加以下突出显示的行以更新得分和 `scoreLabel`
    文本：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Setting a game over condition
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置游戏结束条件
- en: 'In the `didBeginContact` function, add the following right after we reset the
    velocity of the player to zero:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `didBeginContact` 函数中，在我们将玩家的速度重置为零后，添加以下代码：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here we set `gameOver` to `true` and call a `GameOver` function where we will
    set the visibility of the labels and buttons. So, add a new function called `GameOver`
    to the SceneKit class as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `gameOver` 设置为 `true` 并调用一个 `GameOver` 函数，我们将设置标签和按钮的可见性。因此，向 SceneKit
    类添加一个名为 `GameOver` 的新函数，如下所示：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, once the game is over, we hide the `jumpButton` and unhide the `playButton`
    and `gameOverLabel`. We then reset the position of the enemy and hero to their
    initial state.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一旦游戏结束，我们将隐藏 `jumpButton` 并显示 `playButton` 和 `gameOverLabel`。然后我们将敌人英雄的位置重置到初始状态。
- en: 'Next we have to make sure that the `enemyUpdate` function is only called when
    `gameOver` is false. In the `update` function, enclose the `enemyUpdate` function
    in an `if` statement as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须确保 `enemyUpdate` 函数仅在 `gameOver` 为 `false` 时被调用。在 `update` 函数中，将 `enemyUpdate`
    函数包含在一个 `if` 语句中，如下所示：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we have to adjust the gravity in the scene, otherwise the hero will
    get tossed into the air since the gravity is currently so low. In the `addColladaObjects`
    function, add the following line at the end of the function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须调整场景中的重力，否则英雄会被抛到空中，因为当前的重力非常低。在 `addColladaObjects` 函数中，在函数末尾添加以下行：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now our game loop is ready. If you press the play button, the game will start
    and the jump button will be visible, and the hero will jump when it is pressed.
    The score will increase each time the hero successfully avoids the enemy block,
    and the game will be over if he hits the enemy block. Once the game is over, the
    play button will be visible and jump button will be hidden. Tapping the play button
    again will reset everything and the game will start again.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的游戏循环已经准备好了。如果你按下播放按钮，游戏将开始，跳跃按钮将可见，并且当按下时英雄将跳跃。每次英雄成功避开敌人方块时，分数都会增加，如果英雄碰到敌人方块，游戏将结束。游戏结束后，播放按钮将可见，跳跃按钮将隐藏。再次轻触播放按钮将重置一切，游戏将再次开始。
- en: Fixing the jump
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复跳跃
- en: There is still one problem though. You can keep on tapping the jump button and
    the hero will keep on going up. We don't want that. We want the hero to jump only
    when he is grounded. For this, we will add a small counter and disable the jump
    when the hero is in the air.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然有一个问题。你可以一直按跳跃按钮，英雄会一直向上跳。我们不想这样。我们希望英雄只有在落地时才能跳跃。为此，我们将添加一个小计数器，并在英雄在空中时禁用跳跃。
- en: 'For this, add a new global variable called `jumpCounter` of type `int` and
    initialize it to `0`. In the `update` function of the class, add the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，添加一个名为`jumpCounter`的新全局变量，其类型为`int`，并将其初始化为`0`。在类的`update`函数中添加以下内容：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here we decrement the value of `jumpCounter` and once it is less than zero,
    we set the value equal to `0`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们减少`jumpCounter`的值，一旦它小于零，我们就将其值设置为`0`。
- en: 'Next, in the `heroJump` function, enclose where we apply force to the hero
    to jump in an if condition as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`heroJump`函数中，将我们对英雄施加跳跃力量的部分放在以下if条件中：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, the hero will only jump when `jumpCounter` is equal to 0\. If it is equal
    to `0`, then the force is applied and the counter is set to `25`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，英雄只有在`jumpCounter`等于0时才会跳跃。如果它等于`0`，那么就会施加力量，并将计数器设置为`25`。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The number was arrived at after trial and error to ensure that the jump button
    won't be pressed when the monster is in the air.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字是通过试错得出的，以确保怪物在空中时不会按下跳跃按钮。
- en: In the `update` function, we decrement this value, until then the force cannot
    be applied. Once `jumpCounter` is set to `0` again, the hero can jump again.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`函数中，我们减少这个值，直到那时不能施加力量。一旦`jumpCounter`再次设置为`0`，英雄就可以再次跳跃。
- en: So, finally, we can run and test the game. Make sure the `addSpriteKitOverlay`
    function is called in the `addColladaObjects` function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，我们可以运行并测试游戏。确保在`addColladaObjects`函数中调用`addSpriteKitOverlay`函数。
- en: '![Fixing the jump](img/B04014_08_11.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![修复跳跃](img/B04014_08_11.jpg)'
- en: Adding wall and floor parallax
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加墙壁和地板视差
- en: What is a game without a parallax effect? In SpriteKit, we added parallax using
    sprites, while in SceneKit, we will use planes to add it to the scene. Apart from
    adding parallax, we will also see how to add diffuse, normal, and specular maps
    to the plane. Also, we will learn what those terms even mean.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 没有视差效果的游戏是什么？在SpriteKit中，我们使用精灵添加了视差，而在SceneKit中，我们将使用平面将其添加到场景中。除了添加视差之外，我们还将了解如何向平面添加漫反射、法线和高光贴图。我们还将学习这些术语的含义。
- en: 'So, as usual, we create a new function in which we will add all these planes.
    Add four global `SCNNodes` as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，像往常一样，我们创建一个新的函数，在其中我们将添加所有这些平面。按照以下方式添加四个全局`SCNNodes`：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also, add a function to the scene called `addWallandFloorParallax` as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 还要向场景添加一个名为`addWallandFloorParallax`的函数，如下所示：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: OMG!! This is a whole lot of code. But don't panic. We will go through it systematically.
    Just look at the code where it says `preparing wall geometry`. First, we will
    see how the wall geometry is set up, and then once you have an understanding of
    it, we will see how to set up the floor geometry.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: OMG！！这是一大堆代码。但别慌。我们将系统地通过它。只需看看代码中写着`准备墙壁几何形状`的地方。首先，我们将看看墙壁几何形状是如何设置的，然后一旦你理解了它，我们将看看如何设置地板几何形状。
- en: We create a new constant called `wallGeometry` and assign a `SCNPlane` to it.
    The difference between an `SCNPlane` and `SCNFloor` is that here we can set the
    dimensions of the plane. So, very simply we set the width and height of the plane
    to be `250` by `120` units.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`wallGeometry`的新常量，并将其分配给`SCNPlane`。`SCNPlane`和`SCNFloor`之间的区别在于，在这里我们可以设置平面的尺寸。所以，非常简单，我们将平面的宽度和高度设置为`250`乘以`120`单位。
- en: Next, we assign a material to the plane. Until now, we have only seen how to
    assign a color to an object in SceneKit. Here we assign three kinds of maps to
    the plane. The first is a diffuse.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给平面分配一个材质。到目前为止，我们只看到了如何在SceneKit中给对象分配颜色。这里我们给平面分配了三种类型的贴图。第一种是漫反射。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A diffuse material is an image or texture that you want to paste on to a plane.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射材质是你想要粘贴到平面上的图像或纹理。
- en: Textures are like wallpapers on walls. Imagine an unpainted wall; now you can
    either color the wall or apply wallpaper. Adding paint is done in the digital
    world by applying a color, like we did for `enemyblock` where we assigned a yellow
    diffuse color to it. To apply a wallpaper in the digital world, we apply using
    textures or images. Here we apply the `wall.png` image to the wall plane geometry.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 文本纹理就像墙上的壁纸。想象一下未粉刷的墙面；现在你可以选择给墙面涂色或者贴上壁纸。在数字世界中添加油漆是通过应用颜色来完成的，就像我们在`enemyblock`上所做的那样，我们给它分配了一个黄色的漫反射颜色。要在数字世界中应用壁纸，我们使用纹理或图像。在这里，我们将`wall.png`图像应用到墙面平面几何上。
- en: Notice that the wall plane is pretty big in terms of width and height. If we
    let it be, the wall.png image will have to stretch to fit the dimension of the
    wall. So we use the `wrapt` and `wraps` functions so that the wall texture is
    repeated in both the *x* and *y* direction of the plane without stretching the
    wall texture. So this is what happens in the next two lines. We are just repeating
    the wall texture over in both the directions until it fills the whole plane.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，从宽度和高度的角度来看，墙面平面相当大。如果我们让它保持原样，`wall.png`图像将不得不拉伸以适应墙面的尺寸。所以，我们使用`wrapt`和`wraps`函数，使得墙面纹理在平面的*x*和*y*方向上重复，而不拉伸墙面纹理。所以这就是在接下来的两行中发生的事情。我们只是在两个方向上重复墙面纹理，直到它填满整个平面。
- en: In the next step, we assign the `mipFiler` to `linear`. The filter will decide
    how much detail needs to be added to the texture. If the camera is far enough
    away, it will generate a lower resolution texture to reduce the burden on the
    CPU. If the camera comes closer, then a higher resolution image will be created
    so that all the details of the texture will be visible. This is purely used for
    optimization purposes. Linear filter mode is the most basic type of mode of filters.
    There are other modes called bilinear and trilinear, and so on that will give
    even better results but are computationally expensive. For our purposes, linear
    filtering will suffice. You can see the difference by changing the code and running
    the game on a device.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将`mipFiler`分配给`linear`。过滤器将决定需要添加多少细节到纹理中。如果相机足够远，它将生成一个低分辨率的纹理以减少CPU的负担。如果相机靠近，则将创建一个更高分辨率的图像，以便纹理的所有细节都可见。这纯粹是用于优化目的。线性过滤器模式是过滤器最基本的一种模式。还有其他模式，如双线性、三线性等，将提供更好的结果，但计算成本较高。对于我们的目的，线性过滤就足够了。你可以通过更改代码并在设备上运行游戏来看到差异。
- en: For the diffuse at the end, we scale down the texture of the image itself depending
    upon how big or small we want the texture to appear on the plane. While scaling,
    we have scaled it to the same proportion as the size of the geometry. So here
    in the *x* and *y* plane, we scale it down by a factor of 1/40 times the values
    of width and height of the geometry. Since we are not scaling in the *z* direction,
    we keep it at `1`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后的漫反射，我们根据纹理在平面上看起来有多大或有多小来缩小图像本身的纹理。在缩放时，我们将其缩放到与几何尺寸相同的比例。所以在这里的*x*和*y*平面上，我们将其缩小到几何宽度和高度的1/40倍。由于我们不在*z*方向上缩放，我们将其保持在`1`。
- en: 'The following is the image of the diffuse map of the wall:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下就是墙面的漫反射贴图图像：
- en: '![Adding wall and floor parallax](img/B04014_08_12.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![添加墙面和地板的视差效果](img/B04014_08_12.jpg)'
- en: 'Now, the same five steps are repeated for the normal and the specular map.
    We saw that to add wallpaper to the plane we have to use a diffuse map. Now, what
    if this wallpaper has some bumps and holes in it? Not all walls are so smooth.
    So, to add this roughness to the wallpaper, we use what is called a normal map.
    The following is the image of the normal map:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，同样的五个步骤也重复用于法线贴图和镜面反射贴图。我们看到为了给平面添加壁纸，我们必须使用漫反射贴图。现在，如果这个壁纸有一些凹凸和孔洞怎么办？不是所有的墙面都这么光滑。所以，为了给壁纸添加这种粗糙感，我们使用所谓的法线贴图。以下就是法线贴图的图像：
- en: '![Adding wall and floor parallax](img/B04014_08_13.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![添加墙面和地板的视差效果](img/B04014_08_13.jpg)'
- en: It basically calculates how light should behave once it hits the normal surface.
    Depending on the direction of the light and if there is a dump or hole in the
    normal map, the lighting will be calculated automatically. All this is done using
    a normal map. A normal is nothing but an image. The code will take information
    from this image to create the desired effect. So, here we assign a normal map
    called `wall_NRM.png` and assign it as content. The next four steps are very similar
    to the ones we performed for diffuse maps.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上计算了光线一旦击中正常表面后应该如何行为。根据光线的方向以及正常图中是否有凹坑或孔洞，照明将自动计算。所有这些操作都使用正常图来完成。正常图不过是一张图片。代码将从这张图片中获取信息以创建所需的效果。因此，我们分配一个名为
    `wall_NRM.png` 的正常图，并将其作为内容。接下来的四个步骤与我们对漫反射图所做的步骤非常相似。
- en: 'Next, let us look at specular maps. This map will decide which parts of the
    texture are shiny and which parts are not. Imagine your wallpaper was made of
    stainless steel. To bring this effect, we assign the specular map, and to add
    this, we use the `wall_SPEC.png` file. The next four steps are the same, only
    now we do it separately for the specular map. The image of the specular map is
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看高光图。这张图将决定纹理的哪些部分是闪亮的，哪些部分不是。想象一下，如果你的壁纸是由不锈钢制成的。为了产生这种效果，我们分配高光图，并使用
    `wall_SPEC.png` 文件来添加它。接下来的四个步骤与之前相同，但现在我们分别对高光图进行操作。高光图的图像如下：
- en: '![Adding wall and floor parallax](img/B04014_08_14.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![添加墙壁和地板透视](img/B04014_08_14.jpg)'
- en: The same steps are repeated for the floor geometry as well, only this time we
    have flipped the width and height values.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地板几何形状，也重复相同的步骤，只是这次我们翻转了宽度和高度值。
- en: Once the floor and wall geometries are ready, we assign them to the wall and
    floor nodes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦地板和墙壁的几何形状准备就绪，我们将它们分配给墙壁和地板节点。
- en: For the wall nodes, we assign the geometry to the node. Then we rotate the node
    so that the wall is vertical. We rotate the node by –90 degrees in the *y* direction.
    Then we place the first wall at `(15, 0, 0)`, and then add it to the scene. We
    place the second wall node at `(15, 0, 250)`, which will make it adjacent to the
    first plane.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于墙壁节点，我们将几何形状分配给节点。然后我们旋转节点，使墙壁垂直。我们在 *y* 方向上旋转节点 -90 度。然后我们将第一面墙放置在 `(15,
    0, 0)`，然后将其添加到场景中。我们将第二面墙节点放置在 `(15, 0, 250)`，这将使其与第一个平面相邻。
- en: For the floor nodes, we follow a similar process, but here we have to rotate
    it twice to be horizontal to the ground.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地板节点，我们遵循类似的过程，但在这里我们必须旋转两次才能使其与地面水平。
- en: 'With our wall and floor nodes ready, we can update the positions of the planes
    to create the parallax effect. So, in the `update` function, add the following
    code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的墙壁和地板节点准备就绪后，我们可以更新平面的位置以创建透视效果。因此，在 `update` 函数中，添加以下代码：
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will look very familiar to you now. Like we updated and reset the background
    sprites in the SpriteKit game, we are going update the positions of the four nodes
    and then reset the position of all of them if they have gone beyond 250 units
    in the *z* direction.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对你来说这应该非常熟悉了。就像我们在 SpriteKit 游戏中更新和重置背景精灵一样，我们现在将更新四个节点的位置，然后如果它们在 *z* 方向上超过
    250 个单位，我们将重置所有节点的位置。
- en: Add the `addWallandFloorParallax` function to the `addColladaObjects` function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `addWallandFloorParallax` 函数添加到 `addColladaObjects` 函数中。
- en: 'For this scene, I have also added an ambient light node using the scene graph,
    as otherwise the scene was looking very dark. Go to the `monsterScene.DAE` file,
    and under the scene graph, click on the plus sign and add a new node. Next, right-click
    on the node and select **addLight**. In the panel on the right, select the **Attributes**
    inspector, and under the **Type**, select **Ambient**. Below **Type**, select
    **Color** and choose a dark blue or purple color. Run the game now and you should
    see the result, as shown in the following screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，我还使用场景图添加了一个环境光节点，否则场景看起来非常暗。转到 `monsterScene.DAE` 文件，在场景图中点击加号并添加一个新节点。然后，右键单击节点并选择
    **addLight**。在右侧面板中，选择 **Attributes** 检查器，在 **Type** 下选择 **Ambient**。在 **Type**
    下方选择 **Color** 并选择深蓝色或紫色。现在运行游戏，你应该会看到以下截图所示的结果：
- en: '![Adding wall and floor parallax](img/B04014_08_15.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![添加墙壁和地板透视](img/B04014_08_15.jpg)'
- en: Adding particles
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加粒子
- en: As the icing on the cake, we will include a rain particle effect. For creating
    a particle effect in SceneKit, go to **File** | **New**, and under **Resource**,
    select **SceneKit Particle system**. Click on **Next**, and on the next screen,
    select **Rain** from the **Particle System Template** drop-down list. Click on
    **Next** and give the file a name. I called it `rain`. So now you will have `rain.scnp`
    and `spark.png` files in the project.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 作为锦上添花的部分，我们将包括一个雨粒子效果。要在 SceneKit 中创建粒子效果，请转到 **文件** | **新建**，在 **资源** 下选择
    **SceneKit 粒子系统**。点击 **下一步**，在下一屏幕上，从 **粒子系统模板** 下拉列表中选择 **Rain**。点击 **下一步**，并为文件命名。我将其命名为
    `rain`。因此，现在你将在项目中拥有 `rain.scnp` 和 `spark.png` 文件。
- en: To position the particle better, go to the scene graph and create a node called
    `particleNode`, and translate and rotate the node such that it is pointing toward
    the hero.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地定位粒子，前往场景图并创建一个名为 `particleNode` 的节点，并将节点平移和旋转，使其指向英雄。
- en: 'Create a new function called `addRainParticle` to the class and add the following
    code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中创建一个名为 `addRainParticle` 的新函数，并添加以下代码：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We create a new constant called `rain` and assign `SCNParticleSystem` to it,
    and provide the `rain` particle system we created in it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `rain` 的新常量，并将其分配给 `SCNParticleSystem`，并在其中提供了我们创建的 `rain` 粒子系统。
- en: A new `SCNNode` called `particleEmitterNode` is created and we assign the `particleNode`
    we created in the scene graph to it. Then we assign the rain particle system to
    it. Then we add the `particleEmitterNode` to the scene.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个新的 `SCNNode` 被称为 `particleEmitterNode`，并将我们在场景图中创建的 `particleNode` 分配给它。然后我们将雨粒子系统分配给它。然后我们将
    `particleEmitterNode` 添加到场景中。
- en: We use the `warmupDuration` of the particle system and assign a value of `10`
    to it. This is done so that when the game starts, the rain particle effect is
    fast-forwarded to look as if it was already raining.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用粒子系统的 `warmupDuration` 并将其分配一个值为 `10` 的值。这样做是为了当游戏开始时，雨粒子效果被快速播放，看起来就像已经开始下雨了。
- en: You can select the `rain.scnp` file and change the parameters to better suit
    your needs. Build and run to see our finished SceneKit game. Call the `addRainParticle`
    function at the end of `addColladaObjects` function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择 `rain.scnp` 文件并更改参数以更好地满足你的需求。构建并运行以查看我们完成的 SceneKit 游戏。在 `addColladaObjects`
    函数的末尾调用 `addRainParticle` 函数。
- en: '![Adding particles](img/B04014_08_16.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![添加粒子](img/B04014_08_16.jpg)'
- en: Tip
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Adding audio to the game is exactly like how we added the main theme into the
    SpriteKit game. So, I will leave you guys to experiment with it to figure out
    how to add audio to the scene.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将音频添加到游戏中与我们将主旋律添加到 SpriteKit 游戏中的方式完全相同。所以，我将留给你大家去实验，找出如何将音频添加到场景中。
- en: Also, I didn't want to want to repeat again how to import the assets to the
    game as we have seen how to do that for over four chapters now. But make sure
    that while calling the files, you provide the correct folder locations. If not,
    then the assets won't be retrieved properly, causing build errors.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我不想再次重复如何将资产导入到游戏中，因为我们已经看到如何做这件事超过四章了。但请确保在调用文件时提供正确的文件夹位置。如果不这样做，则资产将无法正确检索，导致构建错误。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we saw how to make a 3D game in SceneKit. From making simple
    geometries to floors, we created a full-fledged game will a complete game loop.
    We added a scene already created in a 3D software package with animation and imported
    it into SceneKit. We didn't have to add a camera or a light source as it was already
    part of the 3D scene.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在 SceneKit 中制作 3D 游戏。从制作简单的几何形状到地板，我们创建了一个完整的游戏，包括完整的游戏循环。我们已将已在
    3D 软件包中创建并带有动画的场景添加到 SceneKit 中。由于它已经是 3D 场景的一部分，因此我们无需添加相机或光源。
- en: We imported the COLLADA object into the scene and saw how to access the objects
    through code. We added an enemy and physics to the scene. We used SceneKit's physics
    engine to calculate collision and also applied force to the hero object.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 COLLADA 对象导入到场景中，并看到了如何通过代码访问对象。我们在场景中添加了敌人并应用了物理。我们使用 SceneKit 的物理引擎来计算碰撞，并也对英雄对象应用了力。
- en: Additionally, you also saw how to integrate SpriteKit into SceneKit to display
    the score and buttons on the scene. We also used SpriteKit's `touchBegan` function
    to detect touches on the screen and created the play and jump buttons.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还看到了如何将 SpriteKit 集成到 SceneKit 中以在场景中显示分数和按钮。我们还使用了 SpriteKit 的 `touchBegan`
    函数来检测屏幕上的触摸，并创建了播放和跳跃按钮。
- en: Parallax scrolling was also added to the scene using planes. Also, you saw different
    types of maps such as diffuse, normal, and specular maps, and the functionality
    of each. Finally, we added a rain particle system to the scene.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中还添加了视差滚动效果，使用的是平面。此外，你还看到了不同类型的贴图，如漫反射贴图、法线贴图和镜面反射贴图，以及它们各自的功能。最后，我们还向场景中添加了一个雨粒子系统。
- en: In the next chapter, you will dive deeper into graphics programming and see
    how objects are actually displayed on to the screen using the Metal Graphics library.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将更深入地学习图形编程，并了解如何使用 Metal 图形库将对象实际显示在屏幕上。
