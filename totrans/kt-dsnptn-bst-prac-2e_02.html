<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer007">&#13;
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Getting Started with Kotlin</h1>&#13;
			<p>The bulk of this chapter will be dedicated to basic Kotlin syntax. It is important to be comfortable with a language before we start implementing any design patterns in it.</p>&#13;
			<p>We'll also briefly discuss what problems design patterns solve and why you should use them in Kotlin. This will be helpful to those who are less familiar with the concept of design patterns. But even for experienced engineers, it may provide an interesting perspective.</p>&#13;
			<p>This chapter doesn't aim to cover the entire language vocabulary but to get you familiar with some basic concepts and idioms. The following chapters will expose you to even more language features as they become relevant to the design patterns that we'll discuss.</p>&#13;
			<p>In this chapter, we will cover the following main topics:</p>&#13;
			<ul>&#13;
				<li>Basic language syntax and features</li>&#13;
				<li>Understanding Kotlin code structure</li>&#13;
				<li>Type system and <strong class="source-inline">null</strong> safety</li>&#13;
				<li>Reviewing Kotlin data structures</li>&#13;
				<li>Control flow</li>&#13;
				<li>Working with text and loops</li>&#13;
				<li>Classes and inheritance</li>&#13;
				<li>Extension functions</li>&#13;
				<li>Introduction to design patterns</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you'll have a knowledge of Kotlin's basics, which will be the foundation for the following chapters.</p>&#13;
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>&#13;
			<p>To follow the instructions in this chapter, you'll need the following:</p>&#13;
			<ul>&#13;
				<li>IntelliJ IDEA Community Edition (<a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a>)</li>&#13;
				<li>OpenJDK 11 or higher (<a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a>)</li>&#13;
			</ul>&#13;
			<p>The code files for this chapter are available at <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter01">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter01</a>.</p>&#13;
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Basic language syntax and features</h1>&#13;
			<p>Whether you<a id="_idIndexMarker000"/> come from <strong class="bold">Java</strong>, <strong class="bold">C#</strong>, <strong class="bold">Scala</strong>, or any other statically typed programming language, you'll find Kotlin syntax quite familiar. This is not by coincidence but to make the transition<a id="_idIndexMarker001"/> to this new language as smooth as possible for those with previous <a id="_idIndexMarker002"/>experience in other<a id="_idIndexMarker003"/> languages. Besides that familiarity, Kotlin brings a vast amount of features, such as better type safety. As we move ahead, you'll notice that all of them <a id="_idIndexMarker004"/>are attempting to solve real-world problems. That pragmatic approach is remarkably consistent across the language. For example, one of the strongest benefits of Kotlin is complete Java interoperability. You can have Java and Kotlin classes alongside each other and freely use any library that is available in Java for a Kotlin project.</p>&#13;
			<p>To summarize, the<a id="_idIndexMarker005"/> goals of the language are as follows:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Pragmatic</strong>: Makes things we do often easy to achieve</li>&#13;
				<li><strong class="bold">Readable</strong>: Keeps a balance between conciseness and clarity on what the code does</li>&#13;
				<li><strong class="bold">Easy to reuse</strong>: Supports adapting code to different situations</li>&#13;
				<li><strong class="bold">Safe</strong>: Makes it hard to write code that crashes</li>&#13;
				<li><strong class="bold">Interoperable</strong>: Allows the use of existing libraries and frameworks</li>&#13;
			</ul>&#13;
			<p>This chapter will discuss how these goals are achieved.</p>&#13;
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Multi-paradigm language</h2>&#13;
			<p>Some of the <a id="_idIndexMarker006"/>major paradigms in programming languages are procedural, object-oriented, and functional paradigms.</p>&#13;
			<p>Being pragmatic, Kotlin<a id="_idIndexMarker007"/> allows for any of these paradigms. It has classes and inheritance, coming from the object-oriented approach. It has higher-order functions from functional programming. You don't have to wrap everything in classes if you don't want to, though. Kotlin allows you to structure your entire code as just a set of procedures and structs if you need to. You will see how all these approaches come together, as different examples will combine different paradigms to solve the problems discussed.</p>&#13;
			<p>Instead of covering all aspects of a topic from start to finish, we will be building the knowledge as we go.</p>&#13;
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Understanding Kotlin code structure</h1>&#13;
			<p>The first<a id="_idIndexMarker008"/> thing you'll need to do when you start programming in Kotlin is to create a new file. Kotlin's file extension is usually <strong class="source-inline">.kt</strong>.</p>&#13;
			<p>Unlike Java, there's no strong relationship between the filename and class name. You can put as many public classes in your file as you want, as long as the classes are related to one another and your file doesn't grow too long to read.</p>&#13;
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Naming conventions</h2>&#13;
			<p>As a convention, if <a id="_idIndexMarker009"/>your file contains a single class, name your file the same as your class.</p>&#13;
			<p>If your file<a id="_idIndexMarker010"/> contains more than one class, then the filename should describe the common purpose of those classes. Use Camel case <a id="_idIndexMarker011"/>when naming your files, as per the Kotlin coding conventions: <a href="https://kotlinlang.org/docs/coding-conventions.html">https://kotlinlang.org/docs/coding-conventions.html</a>.</p>&#13;
			<p>The main file in your Kotlin project should usually be named <strong class="source-inline">Main.kt</strong>.</p>&#13;
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Packages</h2>&#13;
			<p>A <strong class="bold">package</strong> is a<a id="_idIndexMarker012"/> collection of files and classes that all share a similar<a id="_idIndexMarker013"/> purpose or domain. Packages are a convenient way to have all your classes and functions under the same namespace, and often in the same folder. That's the reason Kotlin, similar to many other languages, uses the notion of a package.</p>&#13;
			<p>The<a id="_idIndexMarker014"/> package that the file belongs to is declared using a <strong class="source-inline">package</strong> keyword:</p>&#13;
			<p class="source-code">package me.soshin</p>&#13;
			<p>Similar to placing classes in files, you can put any package in any directory or file, but if you're mixing Java and Kotlin, Kotlin files should follow Java package rules, as given at <a href="https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html">https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html</a>.</p>&#13;
			<p>In purely <a id="_idIndexMarker015"/>Kotlin projects, common package prefixes can be omitted from the folder structure. For example, if all your projects are under the <strong class="source-inline">me.soshin</strong> package, and part of your application deals with mortgages, you can place your files directly in the <strong class="source-inline">/mortgages</strong> folder and not in the <strong class="source-inline">/me/soshin/mortgages</strong> folder like Java requires.</p>&#13;
			<p>There is no need to declare a package for your <strong class="source-inline">Main.kt</strong> file.</p>&#13;
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Comments</h2>&#13;
			<p>Going <a id="_idIndexMarker016"/>forward, we <a id="_idIndexMarker017"/>will be documenting parts of the code using <strong class="bold">Kotlin comments</strong>. Similar to many other <a id="_idIndexMarker018"/>programming languages, Kotlin uses <strong class="source-inline">//</strong> for a single-line comment and <strong class="source-inline">/* */</strong> for multiline comments.</p>&#13;
			<p>Comments are a useful way to provide more context both to other developers and to your future self. Now, let's write our first Kotlin program and discuss how Kotlin's guiding principles are applied to it.</p>&#13;
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Hello Kotlin</h2>&#13;
			<p>There's no <a id="_idIndexMarker019"/>book dedicated to a programming language that <a id="_idIndexMarker020"/>can avoid the ubiquitous <em class="italic">Hello World</em> example. We're certainly not going to challenge that honored tradition.</p>&#13;
			<p>To begin learning how Kotlin works, let's put the following code in our <strong class="source-inline">Main.kt</strong> file and run it:</p>&#13;
			<p class="source-code">fun main() {</p>&#13;
			<p class="source-code">    println("Hello Kotlin")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>When your run<a id="_idIndexMarker021"/> this example, for example by pressing the <strong class="bold">Run</strong> button in your IntelliJ IDEA, it simply outputs the following:</p>&#13;
			<p class="source-code">&gt; Hello Kotlin</p>&#13;
			<p>There are some interesting attributes in that piece of code in comparison to the following Java code that does exactly the same:</p>&#13;
			<p class="source-code">class Main {</p>&#13;
			<p class="source-code">    public static void main(String[] args) {</p>&#13;
			<p class="source-code">        System.out.println("Hello Java");</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Let's focus on those attributes in the next sections.</p>&#13;
			<h3>No wrapping class</h3>&#13;
			<p>In Java, C#, Scala, and <a id="_idIndexMarker022"/>many other languages, it's necessary to wrap every function in a class for it to become executable.</p>&#13;
			<p>Kotlin, though, has the concept <a id="_idIndexMarker023"/>of <strong class="bold">package-level functions</strong>. If your function<a id="_idIndexMarker024"/> doesn't need to access properties of a class, you don't need to wrap it in a class. It's as simple as that.</p>&#13;
			<p>We'll discuss package-level functions in more detail in the following chapters.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">From here on, we'll use ellipsis notation (<em class="italic">three dots</em>) to indicate that some parts of the code were omitted to focus on the important bits. You can always find the full code examples at the GitHub link for this chapter.</p>&#13;
			<h3>No arguments</h3>&#13;
			<p>Arguments, supplied <a id="_idIndexMarker025"/>as an array of strings, are a way to configure your command-line application. In Java, you cannot have a runnable <strong class="source-inline">main()</strong> function that doesn't take this array of arguments:</p>&#13;
			<p class="source-code">public static void main(<strong class="bold">String[] args</strong>) { ... }</p>&#13;
			<p>But in Kotlin, those are entirely optional.</p>&#13;
			<h3>No static modifier</h3>&#13;
			<p>Some languages<a id="_idIndexMarker026"/> use the <strong class="source-inline">static</strong> keyword to indicate that a function in a class can be executed without the need to instantiate the class. The <strong class="source-inline">main()</strong> function is one such example. </p>&#13;
			<p>In Kotlin, there's no such limitation. If your function doesn't have any state, you can place it outside of a class, and there is no <strong class="source-inline">static</strong> keyword in Kotlin.</p>&#13;
			<h3>A less verbose print function</h3>&#13;
			<p>Instead <a id="_idIndexMarker027"/>of the verbose <strong class="source-inline">System.out.println</strong> method that outputs a string to the standard output, Kotlin provides us with an alias called <strong class="source-inline">println()</strong> that does exactly the same.</p>&#13;
			<h3>No semicolons</h3>&#13;
			<p>In Java, and <a id="_idIndexMarker028"/>many other languages, every statement or expression must be terminated with a semicolon, as shown in the following example:</p>&#13;
			<p class="source-code">System.out.println("Semicolon =&gt;")<strong class="bold">;</strong> </p>&#13;
			<p>Kotlin is a pragmatic language. So, instead, it infers during compilation where it should put the semicolons:</p>&#13;
			<p class="source-code">println("No semicolons! =&gt;")</p>&#13;
			<p>Most of the time, you won't need to put semicolons in your code. They're considered optional.</p>&#13;
			<p>This is an excellent example of how pragmatic and concise Kotlin is. It sheds lots of fluff and lets you focus on what's important.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">You don't have to write your code in a file for simple snippets. You can also play with the language online: try <a href="https://play.kotlinlang.org/">https://play.kotlinlang.org/</a> or use a REPL and an interactive shell after installing Kotlin and running <strong class="source-inline">kotlinc</strong>.</p>&#13;
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Understanding types</h1>&#13;
			<p>Previously, we <a id="_idIndexMarker029"/>said that Kotlin is a type-safe language. Let's examine the Kotlin type system and compare it to what Java provides.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">The Java examples are for familiarity and not to prove that Kotlin is superior to Java in any way.</p>&#13;
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Basic types</h2>&#13;
			<p>Some<a id="_idIndexMarker030"/> languages make a distinction between primitive types and objects. Taking Java as an example, there is the <strong class="source-inline">int</strong> type and <strong class="source-inline">Integer</strong> – the former being more memory-efficient and the latter more expressive by supporting a lack of value and having methods.</p>&#13;
			<p>There is no such distinction in Kotlin. From a developer's perspective, all the types are the same.</p>&#13;
			<p>But it doesn't mean that Kotlin is less efficient than Java in that aspect. The Kotlin compiler optimizes types. So, you don't need to worry about it much.</p>&#13;
			<p>Most of the Kotlin types are named similarly to Java, the exceptions being Java's <strong class="source-inline">Integer</strong> being called <strong class="source-inline">Int</strong> and Java's void being called <strong class="source-inline">Unit</strong>.</p>&#13;
			<p>It doesn't make much sense to<a id="_idIndexMarker031"/> list all the types, but here are some examples:</p>&#13;
			<div>&#13;
				<div id="_idContainer006" class="IMG---Figure">&#13;
					<img src="Images/B17816_01_Table01.jpg" alt="Table 1.1 - Kotlin types&#13;&#10;" width="1119" height="330"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Table 1.1 - Kotlin types</p>&#13;
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Type inference</h2>&#13;
			<p>Let's<a id="_idIndexMarker032"/> declare our first Kotlin variable by extracting the string from our <strong class="source-inline">Hello Kotlin</strong> example:</p>&#13;
			<p class="source-code">var greeting = "Hello Kotlin"</p>&#13;
			<p class="source-code">println(greeting)</p>&#13;
			<p>Note that nowhere in our code is it stated that <strong class="source-inline">greeting</strong> is of the <strong class="source-inline">String</strong> type. Instead, the compiler decides what type of variable should be used. Unlike interpreted languages, such as JavaScript, Python, or Ruby, the type of variable is defined only once.</p>&#13;
			<p>In Kotlin, this will produce an error:</p>&#13;
			<p class="source-code">var greeting = "Hello Kotlin"</p>&#13;
			<p class="source-code">greeting = 1 // &lt;- Greeting is a String</p>&#13;
			<p>If you'd like to define the type of variable explicitly, you may use the following notation:</p>&#13;
			<p class="source-code">var greeting<strong class="bold">: String</strong> = "Hello Kotlin"</p>&#13;
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Values</h2>&#13;
			<p>In Java, variables <a id="_idIndexMarker033"/>can be declared <strong class="source-inline">final</strong>. Final variables can be assigned only once and their reference is effectively immutable:</p>&#13;
			<p class="source-code">final String s = "Hi";</p>&#13;
			<p class="source-code">s = "Bye"; // Doesn't work</p>&#13;
			<p>Kotlin urges us to use immutable data as much as possible. Immutable variables in Kotlin are called <strong class="bold">values</strong> and use the <strong class="source-inline">val</strong> keyword:</p>&#13;
			<p class="source-code">val greeting = "Hi"</p>&#13;
			<p class="source-code">greeting = "Bye"// Doesn't work, "Val cannot be reassigned"</p>&#13;
			<p>Values are <a id="_idIndexMarker034"/>preferable over variables. Immutable data is easier to reason about, especially when writing concurrent code. We'll touch more on that in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>.</p>&#13;
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Comparison and equality</h2>&#13;
			<p>We were taught very early in Java that comparing objects using <strong class="source-inline">==</strong> won't produce the expected<a id="_idIndexMarker035"/> results, since it tests for reference equality – whether two <a id="_idIndexMarker036"/>pointers are the same, and not whether two objects are equal.</p>&#13;
			<p>Instead, in Java, we use <strong class="source-inline">equals()</strong> for objects and <strong class="source-inline">==</strong> to compare only primitives, which may cause some confusion.</p>&#13;
			<p>JVM does integer caching and string interning to prevent that in some basic cases, so for the sake of the example, we'll use a large integer:</p>&#13;
			<p class="source-code">Integer a = 1000;</p>&#13;
			<p class="source-code">Integer b = 1000;</p>&#13;
			<p class="source-code">System.out.println(a == b);      // false</p>&#13;
			<p class="source-code">System.out.println(a.equals(b)); // true</p>&#13;
			<p>This behavior is far from intuitive. Instead, Kotlin translates <strong class="source-inline">==</strong> to <strong class="source-inline">equals()</strong>:</p>&#13;
			<p class="source-code">val a = 1000</p>&#13;
			<p class="source-code">val b = 1000</p>&#13;
			<p class="source-code">println(a == b)      // true</p>&#13;
			<p class="source-code">println(a.equals(b)) // true</p>&#13;
			<p>If you do want to check for reference equality, use <strong class="source-inline">===</strong>. This won't work for some of the basic types, though:</p>&#13;
			<p class="source-code">println(a === b) // Still true</p>&#13;
			<p>We'll discuss referential equality more when we learn how to instantiate classes.</p>&#13;
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Declaring functions</h2>&#13;
			<p>In Java, every <a id="_idIndexMarker037"/>method must be wrapped by a class or interface, even if it doesn't rely on any information from it. You're probably familiar with many <strong class="source-inline">Util</strong> classes in Java that only have static methods, and their only purpose is to satisfy the language requirements and bundle those methods together.</p>&#13;
			<p>We already mentioned earlier that in Kotlin, a function can be declared outside of a class. We've seen it with the <strong class="source-inline">main()</strong> function. The keyword to declare a function is <strong class="source-inline">fun</strong>. The argument type comes after the argument name, and not before:</p>&#13;
			<p class="source-code">fun greet(<strong class="bold">greeting: String</strong>) {</p>&#13;
			<p class="source-code">    println(greeting)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If you need to return a result, its type will come after the function declaration:</p>&#13;
			<p class="source-code">fun getGreeting(): <strong class="bold">String </strong>{ </p>&#13;
			<p class="source-code">    return "Hello, Kotlin!"</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>You can try this out yourself:</p>&#13;
			<p class="source-code">fun main() {</p>&#13;
			<p class="source-code">    greet(getGreeting())</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If the function doesn't return anything, the return type can be omitted completely. There's no need to declare it as <strong class="source-inline">void</strong>, or its Kotlin counterpart, <strong class="source-inline">Unit</strong>.</p>&#13;
			<p>When a function is very short and consists of just a single expression, such as our <strong class="source-inline">getGreeting()</strong> function, we can remove the return type and the curly brackets, and use a shorter notation:</p>&#13;
			<p class="source-code">fun getGreeting() = "Hello, Kotlin!"</p>&#13;
			<p>Here, the Kotlin compiler will infer that we're returning a <strong class="source-inline">String</strong> type.</p>&#13;
			<p>Unlike some scripting languages, the order in which functions are declared is not important. Your <strong class="source-inline">main</strong> function will have access to all the other functions in its scope, even if those are declared after it in the code file. </p>&#13;
			<p>There are<a id="_idIndexMarker038"/> many other topics regarding function declarations, such as named arguments, default parameters, and variable numbers of arguments. We'll introduce them in the following chapters with relevant examples.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">Many examples in this book assume that the code we provide is wrapped in the <strong class="source-inline">main</strong> function. If you don't see a signature of the function, it probably should be part of the <strong class="source-inline">main</strong> function. As an alternative, you can also run the examples in an IntelliJ scratch file.</p>&#13;
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Null safety</h1>&#13;
			<p>Probably the most notorious exception in the Java world is <strong class="source-inline">NullPointerException</strong>. The reason behind this exception is that every object in Java can be <strong class="source-inline">null</strong>. The<a id="_idIndexMarker039"/> code here shows us why this is a problem:</p>&#13;
			<p class="source-code">final String s = null;</p>&#13;
			<p class="source-code">System.out.println(s.length()); </p>&#13;
			<p class="source-code">// Causes NullPointerException</p>&#13;
			<p>It's not like Java didn't attempt to solve<a id="_idIndexMarker040"/> that problem, though. Since <strong class="bold">Java 8</strong>, there has been an <strong class="source-inline">Optional</strong> construct that represents a value that may not be there:</p>&#13;
			<p class="source-code">var optional = Optional.of("I'm not null");</p>&#13;
			<p class="source-code">if (optional.isPresent()) { </p>&#13;
			<p class="source-code">    System.out.println(optional.get().length());</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>But it doesn't solve our problem. If our function receives <strong class="source-inline">Optional</strong> as an argument, we can still pass it a <strong class="source-inline">null</strong> value and crash the program at runtime: </p>&#13;
			<p class="source-code">void printLength(Optional&lt;String&gt; optional) {</p>&#13;
			<p class="source-code">    if (optional.isPresent()) { // &lt;- Missing null check </p>&#13;
			<p class="source-code">      here</p>&#13;
			<p class="source-code">        System.out.println(optional.get().length());</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">printLength (null); // Crashes!</p>&#13;
			<p>Kotlin checks <a id="_idIndexMarker041"/>for nulls during compile time:</p>&#13;
			<p class="source-code">val s: String = null // Won't compile</p>&#13;
			<p>Let's take a look at the <strong class="source-inline">printLength()</strong> function written in Kotlin:</p>&#13;
			<p class="source-code">fun printLength(s: String) { </p>&#13;
			<p class="source-code">    println(s.length)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Calling this function with <strong class="source-inline">null</strong> won't compile at all:</p>&#13;
			<p class="source-code">printLength(null) </p>&#13;
			<p class="source-code">// Null cannot be a value of a non-null type String</p>&#13;
			<p>If you specifically want your type to be able to receive nulls, you'll need to mark it as nullable using the question mark:</p>&#13;
			<p class="source-code">fun printLength(stringOrNull: String?) { ... }</p>&#13;
			<p>There are multiple techniques in Kotlin for dealing with nulls, such as smart casts, the Elvis operator, and so on. We'll discuss alternatives to nulls in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>. Let's now move on to data structures in Kotlin.</p>&#13;
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Reviewing Kotlin data structures</h1>&#13;
			<p>There are three<a id="_idIndexMarker042"/> important groups of data structures we should get familiar with in Kotlin: lists, sets, and maps. We'll cover each briefly, then<a id="_idIndexMarker043"/> discuss some other topics related to data structures, such as mutability and tuples.</p>&#13;
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Lists</h2>&#13;
			<p>A <strong class="bold">list</strong> represents <a id="_idIndexMarker044"/>an ordered collection of elements of the same type. To<a id="_idIndexMarker045"/> declare a list in Kotlin, we use the <strong class="source-inline">listOf()</strong> function:</p>&#13;
			<p class="source-code">val hobbits = listOf("Frodo", "Sam", "Pippin", "Merry")</p>&#13;
			<p>Note that we didn't specify the type of the list. The reason is that the type inference can also be used when constructing collections in Kotlin, the same as when initializing variables.</p>&#13;
			<p>If you want to provide the type of the list, you similarly do that for defining arguments for a function:</p>&#13;
			<p class="source-code">val hobbits: List&lt;String&gt; = listOf("Frodo", "Sam", "Pippin",   "Merry")</p>&#13;
			<p>To access an element in the list at a particular index, we use square brackets:</p>&#13;
			<p class="source-code">println(hobbits<strong class="bold">[1]</strong>) </p>&#13;
			<p>The preceding code will output this:</p>&#13;
			<p class="source-code">&gt; Sam</p>&#13;
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Sets</h2>&#13;
			<p>A <strong class="bold">set</strong> represents<a id="_idIndexMarker046"/> a collection of unique elements. Looking for<a id="_idIndexMarker047"/> the presence of an element in a set is much faster than looking it up in a list. But, unlike lists, sets don't provide indexes access.</p>&#13;
			<p>Let's create a set of football World Cup champions until after 1994:</p>&#13;
			<p class="source-code">val footballChampions = setOf("France", "Germany", "Spain",   "Italy", "Brazil", "France", "Brazil", "Germany")</p>&#13;
			<p class="source-code">println(footballChampions) // [France, Germany, Spain,   Italy, Brazil]</p>&#13;
			<p>You can see that each country exists in a set exactly once. To check whether an element is in a <strong class="source-inline">Set</strong> collection, you <a id="_idIndexMarker048"/>can use the <strong class="source-inline">in</strong> function: </p>&#13;
			<p class="source-code">println("Israel" in footballChampions)</p>&#13;
			<p class="source-code">println("Italy" in footballChampions) </p>&#13;
			<p>This gives us the following:</p>&#13;
			<p class="source-code">&gt; false</p>&#13;
			<p class="source-code">&gt; true</p>&#13;
			<p>Note that<a id="_idIndexMarker049"/> although sets, in general, do not guarantee the order of elements, the current implementation of a <strong class="source-inline">setOf()</strong> function returns <strong class="source-inline">LinkedHashSet</strong>, which preserves insertion order – <strong class="source-inline">France</strong> appears first in the output, since it was the first country in the input.</p>&#13;
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Maps</h2>&#13;
			<p>A <strong class="bold">map</strong> is a <a id="_idIndexMarker050"/>collection of key-value pairs, in which keys are<a id="_idIndexMarker051"/> unique. The keyword that creates a pair of two elements is <strong class="source-inline">to</strong>. In fact, this is not a real keyword but a special function. We'll learn about it more in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>.</p>&#13;
			<p>In the meantime, let's create a map of some of the Batman movies and the actors that played Bruce Wayne in them:</p>&#13;
			<p class="source-code">val movieBatmans = mapOf(</p>&#13;
			<p class="source-code">    "Batman Returns" to "Michael Keaton",</p>&#13;
			<p class="source-code">    "Batman Forever" to "Val Kilmer",</p>&#13;
			<p class="source-code">    "Batman &amp; Robin" to "George Clooney"</p>&#13;
			<p class="source-code">)</p>&#13;
			<p class="source-code">println(movieBatmans) </p>&#13;
			<p>This prints the following:</p>&#13;
			<p class="source-code">&gt; {Batman Returns=Michael Keaton, </p>&#13;
			<p class="source-code">&gt; Batman Forever=Val Kilmer, </p>&#13;
			<p class="source-code">&gt; Batman &amp; Robin=George Clooney}</p>&#13;
			<p>To<a id="_idIndexMarker052"/> access a<a id="_idIndexMarker053"/> value by its key, we use square brackets and provide the key:</p>&#13;
			<p class="source-code">println(movieBatmans["Batman Returns"])</p>&#13;
			<p>The preceding code will output this:</p>&#13;
			<p class="source-code">&gt; Michael Keaton</p>&#13;
			<p>Those data structures also support checking that an element doesn't exist:</p>&#13;
			<p class="source-code">println(" Batman Begins " <strong class="bold">!in</strong> movieBatmans)</p>&#13;
			<p>We get the following output:</p>&#13;
			<p class="source-code">&gt; true</p>&#13;
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Mutability</h2>&#13;
			<p>All of<a id="_idIndexMarker054"/> the data structures we have discussed so far are immutable or, more correctly, read-only.</p>&#13;
			<p>There <a id="_idIndexMarker055"/>are no methods to add new elements to a list we create with the <strong class="source-inline">listOf()</strong> function, and we also cannot replace any element:</p>&#13;
			<p class="source-code">hobbits[0] = "Bilbo " // Unresolved reference!</p>&#13;
			<p>Immutable data structures are great for writing concurrent code. But, sometimes, we still need a collection we can modify. In order to do that, we can use the mutable counterparts of the collection functions:</p>&#13;
			<p class="source-code">val editableHobbits = mutableListOf("Frodo", "Sam",   "Pippin", "Merry")</p>&#13;
			<p class="source-code">editableHobbits.add("Bilbo")</p>&#13;
			<p>Editable collection types have functions such as <strong class="source-inline">add()</strong> that allow us to modify or, in other words, mutate them.</p>&#13;
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Alternative implementations for collections</h2>&#13;
			<p>If you <a id="_idIndexMarker056"/>have worked with JVM before, you may know that there are other implementations of sets and maps. For example, <strong class="source-inline">TreeMap</strong> stores the keys in a sorted order.</p>&#13;
			<p>Here's how you can instantiate them in Kotlin:</p>&#13;
			<p class="source-code">import java.util.*</p>&#13;
			<p class="source-code">// Mutable map that is sorted by its keys </p>&#13;
			<p class="source-code">val treeMap = java.util.<strong class="bold">TreeMap</strong>( </p>&#13;
			<p class="source-code">    mapOf(</p>&#13;
			<p class="source-code">        "Practical Pig" to "bricks",</p>&#13;
			<p class="source-code">        "Fifer" to "straw",</p>&#13;
			<p class="source-code">        "Fiddler" to "sticks"</p>&#13;
			<p class="source-code">    )</p>&#13;
			<p class="source-code">)</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">println(treeMap.keys)</p>&#13;
			<p>We will get the following output:</p>&#13;
			<p class="source-code">&gt; [Fiddler, Fifer, Practical Pig]</p>&#13;
			<p>Note that the names of the <em class="italic">Three Little Pigs</em> are ordered alphabetically.</p>&#13;
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Arrays</h2>&#13;
			<p>There is one other<a id="_idIndexMarker057"/> data structure we should cover in this section – <strong class="bold">arrays</strong>. In <a id="_idIndexMarker058"/>Java, arrays have a special syntax that uses square brackets. For example, an array of strings is declared <strong class="source-inline">String[]</strong>, while a list of strings is declared as <strong class="source-inline">List&lt;String&gt;</strong>. An element in a Java array is accessed using square brackets, while an element in a list is accessed using the <strong class="source-inline">get()</strong> method.</p>&#13;
			<p>To get the number of elements in an array in Java, we use the <strong class="source-inline">length()</strong> method, and to do the <a id="_idIndexMarker059"/>same with a collection, we use the <strong class="source-inline">size()</strong> method. This is part of Java's legacy and its attempts to resemble C++.</p>&#13;
			<p>In Kotlin, array syntax is <a id="_idIndexMarker060"/>consistent with other types of collections. An array of strings is declared as <strong class="source-inline">Array&lt;String&gt;</strong>:</p>&#13;
			<p class="source-code">val musketeers: Array&lt;String&gt; = arrayOf("Athos", "Porthos",   "Aramis")</p>&#13;
			<p>This is the first time we see angle brackets in Kotlin code. Similar to Java or TypeScript, the type between them is<a id="_idIndexMarker061"/> called <strong class="bold">type argument</strong>. It indicates that this array contains strings. We'll discuss this topic in detail in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, while covering generics.</p>&#13;
			<p>If you already have a collection and would like to convert it into an array, use the <strong class="source-inline">toTypedArray</strong> function:</p>&#13;
			<p class="source-code">listOf(1, 2, 3, 5).toTypedArray()</p>&#13;
			<p>In terms of its abilities, a Kotlin array is very similar to a list. For example, to get the number of elements in a Kotlin array, we use the same <strong class="source-inline">size</strong> property as other collections.</p>&#13;
			<p><em class="italic">When would you need to use arrays then?</em> One example is accepting arguments in the <strong class="source-inline">main</strong> function. Previously, we've seen only main functions without arguments, but sometimes you want to pass them from a command line.</p>&#13;
			<p>Here's an example of a <strong class="source-inline">main</strong> function that accepts arguments from a command line and prints all of them, separated by commas:</p>&#13;
			<p class="source-code">fun main(args: Array&lt;String&gt;) { </p>&#13;
			<p class="source-code">    println(args.joinToString(", "))</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Other cases include invoking Java functions that expect arrays or using <strong class="source-inline">varargs</strong> syntax, which we will discuss in <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>.</p>&#13;
			<p>As we are now familiar with some basic data structures, it's time to discuss how we can apply logic to them using <strong class="source-inline">if</strong> and <strong class="source-inline">when</strong> expressions.</p>&#13;
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Control flow</h1>&#13;
			<p>You could <a id="_idIndexMarker062"/>say that the control flow is the bread and butter of writing programs. We'll start with two conditional expressions, <strong class="source-inline">if</strong> and <strong class="source-inline">when</strong>.</p>&#13;
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>The if expression</h2>&#13;
			<p>In Java, <strong class="source-inline">if</strong> is a <a id="_idIndexMarker063"/>statement. Statements do not return any value. Let's look<a id="_idIndexMarker064"/> at the following function, which returns one of two possible values:</p>&#13;
			<p class="source-code">public String getUnixSocketPolling(boolean isBsd) { </p>&#13;
			<p class="source-code">    if (isBsd) {</p>&#13;
			<p class="source-code">        return "kqueue"; </p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    else {</p>&#13;
			<p class="source-code">        return "epoll";</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>While this example is easy to follow, in general, having multiple <strong class="source-inline">return</strong> statements is considered bad practice because they often make the code harder to comprehend.</p>&#13;
			<p>We could rewrite this method using Java's <strong class="source-inline">var</strong> keyword:</p>&#13;
			<p class="source-code">public String getUnixSocketPolling(boolean isBsd) { </p>&#13;
			<p class="source-code">    var pollingType = "epoll";</p>&#13;
			<p class="source-code">    if (isBsd) {</p>&#13;
			<p class="source-code">        pollingType = "kqueue";</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    return pollingType;</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, we have a single <strong class="source-inline">return</strong> statement, but we had to introduce a mutable variable. Again, with such a simple example, this is not an issue. But, in general, you should try to avoid mutable shared <a id="_idIndexMarker065"/>state as much as possible, since such code is not thread-safe.</p>&#13;
			<p><em class="italic">Why are we having problems writing that in the first place, though? </em></p>&#13;
			<p>Contrary<a id="_idIndexMarker066"/> to Java, in Kotlin, <strong class="source-inline">if</strong> is an expression, meaning it returns a value. We could rewrite the previous function in Kotlin as follows:</p>&#13;
			<p class="source-code">fun getUnixSocketPolling(isBsd: Boolean): String {</p>&#13;
			<p class="source-code">    return if (isBsd) {</p>&#13;
			<p class="source-code">        "kqueue"</p>&#13;
			<p class="source-code">    } else {</p>&#13;
			<p class="source-code">        "epoll"</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Or we could use a shorter form:</p>&#13;
			<p class="source-code">fun getUnixSocketPolling(isBsd: Boolean): String     = if (isBsd) "kqueue" else "epoll"</p>&#13;
			<p>Due to the fact that <strong class="source-inline">if</strong> is an expression, we didn't need to introduce any local variables.</p>&#13;
			<p>Here, we're again making use of single-expression functions and type inference. The important part is that <strong class="source-inline">if</strong> returns a value of the <strong class="source-inline">String</strong> type. There's no need for multiple return statements or mutable variables whatsoever.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">Single-line functions in Kotlin are very cool and pragmatic, but you should make sure that somebody else other than you understands what they do. Use with care.</p>&#13;
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>The when expression</h2>&#13;
			<p><em class="italic">What if (no pun intended) we want to have more conditions in our </em><strong class="source-inline">if</strong><em class="italic"> statement?</em></p>&#13;
			<p>In Java, we use the <strong class="source-inline">switch</strong> statement. In Kotlin, there's a <strong class="source-inline">when</strong> expression, which is a lot more <a id="_idIndexMarker067"/>powerful, since it can embed some other Kotlin features. Let's <a id="_idIndexMarker068"/>create a method that's given a superhero and tells us who their archenemy is:</p>&#13;
			<p class="source-code">fun archenemy(heroName: String) = when (heroName) {</p>&#13;
			<p class="source-code">    "Batman" -&gt; "Joker"</p>&#13;
			<p class="source-code">    "Superman" -&gt; "Lex Luthor"</p>&#13;
			<p class="source-code">    "Spider-Man" -&gt; "Green Goblin"</p>&#13;
			<p class="source-code">    else -&gt; "Sorry, no idea"</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The <strong class="source-inline">when</strong> expression is very powerful. In the next chapters, we will elaborate on how we can combine it with ranges, <strong class="source-inline">enums</strong>, and <strong class="source-inline">sealed</strong> classes as well.</p>&#13;
			<p>As a general rule, use <strong class="source-inline">when</strong> if you have more than two conditions. Use <strong class="source-inline">if</strong> for simple cases.</p>&#13;
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Working with text</h1>&#13;
			<p>We've already <a id="_idIndexMarker069"/>seen many examples of working with text in the previous section. After all, it's not possible to print <strong class="source-inline">Hello Kotlin</strong> without using a string, or at least it would be very awkward and inconvenient.</p>&#13;
			<p>In this section, we'll discuss some of the more advanced features that allow you to manipulate text efficiently.</p>&#13;
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>String interpolation</h2>&#13;
			<p>Let's assume<a id="_idIndexMarker070"/> now we would like to actually print the results from the previous section.</p>&#13;
			<p>First, as you may have already noticed, in one of the previous examples, Kotlin provides a nifty <strong class="source-inline">println()</strong> standard function that wraps the bulkier <strong class="source-inline">System.out.println</strong> command from Java.</p>&#13;
			<p>But, more importantly, as in many other modern languages, Kotlin supports string interpolation <a id="_idIndexMarker071"/>using the <strong class="source-inline">${}</strong> syntax. Let's take the example from before:</p>&#13;
			<p class="source-code">val hero = "Batman"</p>&#13;
			<p class="source-code">println("Archenemy of $hero is ${archenemy(hero)}")</p>&#13;
			<p>The preceding code<a id="_idTextAnchor043"/> would print as follows:</p>&#13;
			<p class="source-code">&gt; Archenemy of Batman is Joker</p>&#13;
			<p>Note that if you're interpolating a value of a function, you need to wrap it in curly braces. If it's a variable, curly braces could be omitted.</p>&#13;
			<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>Multiline strings</h2>&#13;
			<p>Kotlin <a id="_idIndexMarker072"/>supports multiline strings, also<a id="_idIndexMarker073"/> known as <strong class="bold">raw strings</strong>. This<a id="_idIndexMarker074"/> feature <a id="_idIndexMarker075"/>exists in many modern languages, and was brought to <strong class="bold">Java 15</strong> as <strong class="bold">text blocks</strong>.</p>&#13;
			<p>The idea is quite simple. If we want to print a piece of text that spans multiple lines, let's say something from <em class="italic">Alice's Adventures in Wonderland</em> by Lewis Carroll, one way is to concatenate it:</p>&#13;
			<p class="source-code">println("Twinkle, Twinkle Little Bat\n" +</p>&#13;
			<p class="source-code">    "How I wonder what you're at!\n" +</p>&#13;
			<p class="source-code">    "Up above the world you fly,\n" +</p>&#13;
			<p class="source-code">    "Like a tea tray in the sky.\n" +</p>&#13;
			<p class="source-code">    "Twinkle, twinkle, little bat!\n" +</p>&#13;
			<p class="source-code">    "How I wonder what you're at!")</p>&#13;
			<p>While this approach certainly works, it's quite cumbersome.</p>&#13;
			<p>Instead, we could define the same string literal using triple quotes:</p>&#13;
			<p class="source-code">println("""Twinkle, Twinkle Little Bat </p>&#13;
			<p class="source-code">           How I wonder what you're at!</p>&#13;
			<p class="source-code">           Up above the world you fly,</p>&#13;
			<p class="source-code">           Like a tea tray in the sky.</p>&#13;
			<p class="source-code">           Twinkle, twinkle, little bat!</p>&#13;
			<p class="source-code">           How I wonder what you're at!""")</p>&#13;
			<p>This is a <a id="_idIndexMarker076"/>much cleaner way to achieve the same goal. If you execute this example, you may be surprised that the poem is not indented correctly. The reason is that multiline strings preserve whitespace characters, such as tabs.</p>&#13;
			<p>To print the results correctly, we need to add a <strong class="source-inline">trimIndent()</strong> invocation:</p>&#13;
			<p class="source-code">println("""</p>&#13;
			<p class="source-code">    Twinkle, Twinkle Little Bat</p>&#13;
			<p class="source-code">    How I wonder what you're at! </p>&#13;
			<p class="source-code">    """.<strong class="bold">trimIndent()</strong>)</p>&#13;
			<p>Multiline strings also have another benefit – there's no need to escape quotes in them. Let's look at the following example:</p>&#13;
			<p class="source-code">println("From <strong class="bold">\</strong>" Alice's Adventures in Wonderland<strong class="bold">\</strong>" ")</p>&#13;
			<p>Notice how the quote characters that are part of the text had to be escaped using the backslash character.</p>&#13;
			<p>Now, let's look at the same text using multiline syntax:</p>&#13;
			<p class="source-code">println(""" From " Alice's Adventures in Wonderland" """)</p>&#13;
			<p>Note that there's no need for escape characters anymore. </p>&#13;
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>Loops</h1>&#13;
			<p>Now, let's discuss <a id="_idIndexMarker077"/>another typical control structure – a <strong class="bold">loop</strong>. Loops are a very natural construct for most developers. Without loops, it would be tough to repeat the same code block more than once (although we will discuss how to do that without loops in later chapters).</p>&#13;
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>for-each loop</h2>&#13;
			<p>Probably the<a id="_idIndexMarker078"/> most helpful type of a loop in Kotlin is a <strong class="source-inline">for</strong>-<strong class="source-inline">each</strong> loop. This<a id="_idIndexMarker079"/> loop can iterate over strings, data structures, and basically everything that has an iterator. We'll learn more about iterators in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, so for now, let's demonstrate their use on a simple string:</p>&#13;
			<p class="source-code">for (c in "Word") {</p>&#13;
			<p class="source-code">    println(c)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This will print the following:</p>&#13;
			<p class="source-code">&gt;W</p>&#13;
			<p class="source-code">&gt;o</p>&#13;
			<p class="source-code">&gt;r</p>&#13;
			<p class="source-code">&gt;d</p>&#13;
			<p>The <strong class="source-inline">for</strong>-<strong class="source-inline">each</strong> loop works on all the types of data structures we already discussed as well, that is, lists, sets, and maps. Let's take a list as an example:</p>&#13;
			<p class="source-code">val jokers = listOf("Heath Ledger", "Joaquin Phoenix",   "Jack Nicholson")</p>&#13;
			<p class="source-code">for (j in jokers) {</p>&#13;
			<p class="source-code">    println(j)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We'll get the following output:</p>&#13;
			<p class="source-code">&gt; Heath Ledger</p>&#13;
			<p class="source-code">&gt; Joaquin Phoenix</p>&#13;
			<p class="source-code">&gt; Jack Nicholson</p>&#13;
			<p>You'll see this loop many more times in this book, as it's very useful.</p>&#13;
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>The for loop</h2>&#13;
			<p>While in<a id="_idIndexMarker080"/> some languages <strong class="source-inline">for</strong>-<strong class="source-inline">each</strong> and <strong class="source-inline">for</strong> loops are two completely different constructs, in Kotlin a <strong class="source-inline">for</strong> loop is simply a <strong class="source-inline">for</strong>-<strong class="source-inline">each</strong> loop over a range.</p>&#13;
			<p>To <a id="_idIndexMarker081"/>understand it better, let's look at a <strong class="source-inline">for</strong> loop that prints all the single-digit numbers:</p>&#13;
			<p class="source-code">for (i in 0..9) {</p>&#13;
			<p class="source-code">    println(i)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This doesn't look anything like a Java <strong class="source-inline">for</strong> loop and may remind you more of Python. The two dots are <a id="_idIndexMarker082"/>called a <strong class="bold">range operator</strong>.</p>&#13;
			<p>If you run this code, you will notice that this loop is inclusive. It prints all the numbers, including <strong class="source-inline">9</strong>. This is similar to the following Java code:</p>&#13;
			<p class="source-code">for (int i = 0; i &lt;= 9; i++) </p>&#13;
			<p>If you want your range to be exclusive and not to include the last element, you can use the <strong class="source-inline">until</strong> function:</p>&#13;
			<p class="source-code">for (i in 0 <strong class="bold">until </strong>10) {</p>&#13;
			<p class="source-code">    println("for until $i") </p>&#13;
			<p class="source-code">// Same output as the previous </p>&#13;
			<p class="source-code">        loop</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If you'd like to print the numbers in reverse order, you can use the <strong class="source-inline">downTo</strong> function:</p>&#13;
			<p class="source-code">for (i in 9 downTo 0) {</p>&#13;
			<p class="source-code">    println("for downTo $i") // 9, 8, 7...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>It may seem confusing that <strong class="source-inline">until</strong> and <strong class="source-inline">downTo</strong> are called functions, although they look more like operators. This is another interesting Kotlin<a id="_idIndexMarker083"/> feature called <strong class="bold">infix call</strong>, which will be discussed later.</p>&#13;
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>The while loop</h2>&#13;
			<p>There are<a id="_idIndexMarker084"/> no changes to the <strong class="source-inline">while</strong> loop functionality compared <a id="_idIndexMarker085"/>to some other languages, so we'll cover them very briefly:</p>&#13;
			<p class="source-code">var x = 0</p>&#13;
			<p class="source-code">while (x &lt; 10) {</p>&#13;
			<p class="source-code">    x++</p>&#13;
			<p class="source-code">    println("while $x")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This will print numbers from <strong class="source-inline">1</strong> to <strong class="source-inline">10</strong>. Note that we are forced to define <strong class="source-inline">x</strong> as <strong class="source-inline">var</strong>. The lesser-used <strong class="source-inline">do while</strong> loop is also present in the language:</p>&#13;
			<p class="source-code">var x = 5 </p>&#13;
			<p class="source-code">do {</p>&#13;
			<p class="source-code">    println("do while $x")</p>&#13;
			<p class="source-code">    x--</p>&#13;
			<p class="source-code">} while (x &gt; 0)</p>&#13;
			<p>Most probably, you won't be using the <strong class="source-inline">while</strong> loop and especially the <strong class="source-inline">do while</strong> loop much in Kotlin. In the following chapters, we'll discuss much more idiomatic ways to do this.</p>&#13;
			<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Classes and inheritance</h1>&#13;
			<p>Although Kotlin is a multi-paradigm language, it has a strong affinity to the Java programming language, which is based on classes. Keeping Java and JVM interoperability in mind, it's no<a id="_idIndexMarker086"/> wonder that Kotlin also has the notion of classes and <a id="_idIndexMarker087"/>classical inheritance.</p>&#13;
			<p>In this section, we'll cover the syntax for declaring classes, interfaces, abstract classes, and data classes.</p>&#13;
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>Classes</h2>&#13;
			<p>A <strong class="bold">class</strong> is a <a id="_idIndexMarker088"/>collection of data, called properties, and methods. To declare a class, we use the <strong class="source-inline">class</strong> keyword, exactly like Java.</p>&#13;
			<p>Let's imagine we're building a video game. We can define a class to represent the player as follows:</p>&#13;
			<p class="source-code">class Player {</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The instantiation of a class simply looks like this:</p>&#13;
			<p class="source-code">val player = Player()</p>&#13;
			<p>Note that there's no <strong class="source-inline">new</strong> keyword in Kotlin. The Kotlin compiler knows that we want to create a new instance of that class by<a id="_idIndexMarker089"/> the <strong class="bold">round brackets</strong> after the class name.</p>&#13;
			<p>If the class has no body, as in this simple example, we can omit the curly braces:</p>&#13;
			<p class="source-code">class Player // Totally fine</p>&#13;
			<p>Classes without any functions or properties aren't particularly useful, but we'll explore in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, why this syntax exists and how it is consistent with other language features.</p>&#13;
			<h3>Primary constructor</h3>&#13;
			<p>It would be <a id="_idIndexMarker090"/>useful for the player to be able to specify their name during creation. In order to do that, let's add a primary constructor to our class:</p>&#13;
			<p class="source-code">class Player<strong class="bold">(name: String)</strong> </p>&#13;
			<p>Now, this declaration won't work anymore:</p>&#13;
			<p class="source-code">val player = Player()</p>&#13;
			<p>Also, we'll have to provide a name for every new player we instantiate:</p>&#13;
			<p class="source-code">val player = Player("Roland")</p>&#13;
			<p>We'll return to constructors soon enough. But for now, let's discuss properties.</p>&#13;
			<h3>Properties</h3>&#13;
			<p>In Java, we are <a id="_idIndexMarker091"/>used to the concept of getters and setters. If we were to write a class representing a player in a game in Kotlin using Java idioms, it may have looked like this:</p>&#13;
			<p class="source-code">class Player(name: String) {</p>&#13;
			<p class="source-code">    private var name: String = name</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    fun getName(): String {</p>&#13;
			<p class="source-code">        return name</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    fun setName(name: String) {</p>&#13;
			<p class="source-code">        this.name = name;</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If we want to get a player's name, we invoke the <strong class="source-inline">getName()</strong> method. If we want to change a player's name, we invoke the <strong class="source-inline">setName()</strong> method. That's quite simple to follow but very verbose.</p>&#13;
			<p>It is the first time we see the <strong class="source-inline">this</strong> keyword in Kotlin, so let's quickly explain what it means. Similar to many other languages, <strong class="source-inline">this</strong> holds the reference to the current object of that class. In our case, it points to the instance of a <strong class="source-inline">Player</strong> class.</p>&#13;
			<p><em class="italic">Why don't we write our classes like that, though?</em></p>&#13;
			<p class="source-code">class Player {</p>&#13;
			<p class="source-code">    var name: String = ""</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Seems like this approach has lots of benefits. It is much less verbose for sure. Reading a person's name is now much shorter – <strong class="source-inline">player.name</strong>.</p>&#13;
			<p>Also, changing the name is much more intuitive – <strong class="source-inline">player.name = "Alex";</strong>.</p>&#13;
			<p>But by <a id="_idIndexMarker092"/>doing so, we lost a lot of control over our object. We cannot make <strong class="source-inline">Player</strong> immutable, for example. If we want everybody to be able to read the player's name, they'll also be able to change it at any point in time. This is a significant problem if we want to change that code later. With a setter, we can control that, but not with a public field.</p>&#13;
			<p>Kotlin properties provide a solution for all those problems. Let's look at the following class definition:</p>&#13;
			<p class="source-code">class Player(<strong class="bold">val</strong> name: String)</p>&#13;
			<p>Note that this is almost the same as the example from the <em class="italic">Primary constructor</em> section, but now <strong class="source-inline">name</strong> has a <strong class="source-inline">val</strong> modifier.</p>&#13;
			<p>This may look the same as the <strong class="source-inline">PublicPerson</strong> Java example, with all its problems. But actually, this implementation is similar to <strong class="source-inline">ImmutablePerson</strong>, with all its benefits.</p>&#13;
			<p><em class="italic">How is that possible?</em> Behind the scenes, Kotlin will generate a member and a getter with the same name for our convenience. We can set the property value in the constructor and then access it using its name:</p>&#13;
			<p class="source-code">val player = Player("Alex")</p>&#13;
			<p class="source-code">println(player.name)</p>&#13;
			<p>Trying to change the name of our <strong class="source-inline">Player</strong> will result in an error, though:</p>&#13;
			<p class="source-code">player.name = "Alexey" // value cannot be reassigned</p>&#13;
			<p>Since we defined this property as a value, it is read-only. To be able to change a property, we need to define it as mutable. Prefixing a constructor parameter with <strong class="source-inline">var</strong> will automatically generate both a getter and a setter:</p>&#13;
			<p class="source-code">class Player(val name: String, <strong class="bold">var score: Int</strong>)</p>&#13;
			<p>If we don't want the ability to provide the value at construction time, we can move the property inside the class body:</p>&#13;
			<p class="source-code">class Player(val name: String) { </p>&#13;
			<p class="source-code">    var score: Int = 0</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Note that now we must also provide a default value for that property, since it cannot be simply <strong class="source-inline">null</strong>.</p>&#13;
			<h3>Custom setters and getters</h3>&#13;
			<p>Although <a id="_idIndexMarker093"/>we can set a score now easily, its value may <a id="_idIndexMarker094"/>be invalid. Take the following example:</p>&#13;
			<p class="source-code">player.score = -10</p>&#13;
			<p>If we want to have a mutable property with some validations, we need to define an explicit setter for it, using <strong class="source-inline">set</strong> syntax:</p>&#13;
			<p class="source-code">class Player(val name: String) { </p>&#13;
			<p class="source-code">    var score: Int = 0</p>&#13;
			<p class="source-code">       <strong class="bold">set(value)</strong> {</p>&#13;
			<p class="source-code">             <strong class="bold">field </strong>= if (value &gt;= 0) {</p>&#13;
			<p class="source-code">                 value</p>&#13;
			<p class="source-code">             } else {</p>&#13;
			<p class="source-code">                 0</p>&#13;
			<p class="source-code">             }</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, <strong class="source-inline">value</strong> is the new value of the property and <strong class="source-inline">field</strong> is its current value. If our new value is negative, we decide to use a default value.</p>&#13;
			<p>Coming from Java, you may be tempted to write the following code in your setter instead:</p>&#13;
			<p class="source-code">set(value) {</p>&#13;
			<p class="source-code">    this.score = if (value &gt;= 0) value else 0</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>But, in Kotlin, this will create an infinite recursion. You must remember that Kotlin generates a <a id="_idIndexMarker095"/>setter for mutable properties. So, the previous code will be translated to something like this:</p>&#13;
			<p class="source-code">// This is a pseudocode, not real Kotlin code!</p>&#13;
			<p class="source-code">...</p>&#13;
			<p class="source-code">fun setValue(value: Int) {</p>&#13;
			<p class="source-code">    setValue(value) // Infinite recursion!</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">...</p>&#13;
			<p>For that reason, we use the <strong class="source-inline">field</strong> identifier, which is provided automatically.</p>&#13;
			<p>In a similar manner, we can declare a custom getter:</p>&#13;
			<p class="source-code"> class Player(name: String) {</p>&#13;
			<p class="source-code">    val name = name</p>&#13;
			<p class="source-code">        <strong class="bold">get() = field.toUpperCase()</strong></p>&#13;
			<p class="source-code">}</p>&#13;
			<p>First, we save<a id="_idIndexMarker096"/> a value received as a constructor argument into a field with the same name. Then, we define a custom getter that will convert all characters in this property to uppercase:</p>&#13;
			<p class="source-code">println(player.name)</p>&#13;
			<p>We'll get this as our output:</p>&#13;
			<p class="source-code">&gt; ALEX</p>&#13;
			<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>Interfaces</h2>&#13;
			<p>You are probably already familiar with the concept of <strong class="bold">interfaces</strong> from other languages. But let's quickly recap.</p>&#13;
			<p>In typed<a id="_idIndexMarker097"/> languages, interfaces provide a way to define behavior that some class will have to implement. The keyword to define an interface is simply <strong class="source-inline">interface</strong>.</p>&#13;
			<p>Let's now<a id="_idIndexMarker098"/> define an interface for rolling a die:</p>&#13;
			<p class="source-code">interface DiceRoller {</p>&#13;
			<p class="source-code">    fun rollDice(): Int</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>To implement <a id="_idIndexMarker099"/>the interface, a class specifies its name after a colon. There's no <strong class="source-inline">implement</strong> keyword in Kotlin.</p>&#13;
			<p class="source-code">import kotlin.random.*</p>&#13;
			<p class="source-code">class Player(...) : DiceRoller </p>&#13;
			<p class="source-code">{</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">    fun rollDice() = Random.nextInt(0, 6)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This is also the first time we see the <strong class="source-inline">import</strong> keyword. As the name implies, it allows us to import another package, such as <strong class="source-inline">kotlin.random</strong>, from the Kotlin standard library.</p>&#13;
			<p>Interfaces in Kotlin also support default functions. If a function doesn't rely on any state, such as this function that simply rolls a random number between <strong class="source-inline">0</strong> and <strong class="source-inline">5</strong>, we can move it into the interface:</p>&#13;
			<p class="source-code">interface DiceRoller {</p>&#13;
			<p class="source-code">    fun rollDice() = Random.nextInt(0, 6)</p>&#13;
			<p class="source-code">}</p>&#13;
			<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/>Abstract classes</h2>&#13;
			<p><strong class="bold">Abstract classes</strong>, another<a id="_idIndexMarker100"/> concept familiar to many, are similar to interfaces<a id="_idIndexMarker101"/> in that they cannot be instantiated directly. Another class must extend them first. The difference is that unlike <strong class="source-inline">interface</strong>, an abstract class can contain state. </p>&#13;
			<p>Let's create an<a id="_idIndexMarker102"/> abstract class that is able to move our player on the board or, for the sake of simplicity, just store the new coordinates:</p>&#13;
			<p class="source-code">abstract class Moveable() {</p>&#13;
			<p class="source-code">    private var x: Int = 0</p>&#13;
			<p class="source-code">    private var y: Int = 0</p>&#13;
			<p class="source-code">    fun move(x: Int, y: Int) {</p>&#13;
			<p class="source-code">        this.x = x</p>&#13;
			<p class="source-code">        this.y = y</p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Any class<a id="_idIndexMarker103"/> that implements <strong class="source-inline">Moveable</strong> will inherit a <strong class="source-inline">move()</strong> function as well. </p>&#13;
			<p>Now, let's discuss in some more detail the <strong class="source-inline">private</strong> keyword you see here for the first time.</p>&#13;
			<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Visibility modifiers</h2>&#13;
			<p>We <a id="_idIndexMarker104"/>mentioned the <strong class="source-inline">private</strong> keyword earlier in this chapter but didn't have a chance to explain it. The <strong class="source-inline">private</strong> properties or functions are only accessible to the class that declared them – <strong class="source-inline">Moveable</strong>, in this case.</p>&#13;
			<p>The default visibility of classes and properties is public, so there is no need to use the <strong class="source-inline">public</strong> keyword all the time.</p>&#13;
			<p>In order to extend an abstract class, we simply put its name after a colon. There's also no <strong class="source-inline">extends</strong> keyword in Kotlin.</p>&#13;
			<p class="source-code">class ActivePlayer(name: String) : <strong class="bold">Moveable()</strong>, DiceRoller {</p>&#13;
			<p class="source-code">...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p><em class="italic">How would you be able to differentiate between an abstract class and an interface, then?</em></p>&#13;
			<p>An abstract class has round brackets after its name to indicate that it has a constructor. In the upcoming chapters, we'll see some uses of that syntax.</p>&#13;
			<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>Inheritance</h2>&#13;
			<p>Apart from<a id="_idIndexMarker105"/> extending abstract classes, we can also extend regular classes as well.</p>&#13;
			<p>Let's try to extend our <strong class="source-inline">Player</strong> class using the same syntax we used for an abstract class. We will attempt to create a <strong class="source-inline">ConfusedPlayer</strong> class, that is, a player that when given (<em class="italic">x</em> and <em class="italic">y</em>) moves to (<em class="italic">y</em> and <em class="italic">x</em>) instead. </p>&#13;
			<p>First, let's just create a class that inherits from <strong class="source-inline">Player</strong>:</p>&#13;
			<p class="source-code">class ConfusedPlayer(name: String ): ActivePlayer(<strong class="bold">name</strong>)</p>&#13;
			<p>Here, you can see the reason for round brackets even in abstract classes. This allows passing arguments to the parent class constructor. This is similar to using the <strong class="source-inline">super</strong> keyword in Java.</p>&#13;
			<p>Surprisingly, this doesn't compile. The reason for this is that all classes in Kotlin are final by default and cannot be inherited from.</p>&#13;
			<p>To allow other classes to inherit from them, we need to declare them <strong class="source-inline">open</strong>:</p>&#13;
			<p class="source-code"><strong class="bold">open </strong>class ActivePlayer (...) : Moveable(), DiceRoller {</p>&#13;
			<p class="source-code">...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Let's now try and override the <strong class="source-inline">move</strong> method now:</p>&#13;
			<p class="source-code">class ConfusedPlayer(name : String): Player(name) {</p>&#13;
			<p class="source-code">    // move() must be declared open</p>&#13;
			<p class="source-code">    <strong class="bold">override </strong>fun move(x: Int, y: Int) {</p>&#13;
			<p class="source-code">        this.x = y // must be declared protected</p>&#13;
			<p class="source-code">        this.y = x // must be declared protected</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Overriding allows us to redefine the behavior of a function from a parent class. Whereas in Java, <strong class="source-inline">@Override</strong> is an optional annotation, in Kotlin <strong class="source-inline">override</strong> is a mandatory keyword. You cannot hide supertype methods, and code that doesn't use <strong class="source-inline">override</strong> explicitly won't compile.</p>&#13;
			<p>There are <a id="_idIndexMarker106"/>two other problems that we introduced in that piece of code. First, we cannot override a method that is not declared <strong class="source-inline">open</strong> as well. Second, we cannot modify the coordinates of our player from a child class since both coordinates are <strong class="source-inline">private</strong>.</p>&#13;
			<p>Let's use the <strong class="source-inline">protected</strong> visibility modifier the makes the properties accessible to child classes and mark the function as <strong class="source-inline">open</strong> to be able to override it:</p>&#13;
			<p class="source-code">abstract class Moveable() {</p>&#13;
			<p class="source-code"><strong class="bold">    protected </strong>var x: Int = 0</p>&#13;
			<p class="source-code"><strong class="bold">    protected </strong>var y: Int = 0</p>&#13;
			<p class="source-code"><strong class="bold">    open </strong>fun move(x: Int, y: Int) {</p>&#13;
			<p class="source-code">        this.x = x</p>&#13;
			<p class="source-code">        this.y = y</p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, both of the problems are fixed. You also see the <strong class="source-inline">protected</strong> keyword here for the first time. Similar to Java, this visibility modifier makes a property or a method visible only to the class itself and to its subclasses.</p>&#13;
			<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Data classes</h2>&#13;
			<p>Remember<a id="_idIndexMarker107"/> that Kotlin is all about productiveness. One of the most common tasks<a id="_idIndexMarker108"/> for Java developers is to create yet another <strong class="bold">Plain Old Java Object</strong> (<strong class="bold">POJO</strong>). If you're <a id="_idIndexMarker109"/>not familiar with POJO, it is basically an object that only has getters, setters, and implementation of <strong class="source-inline">equals</strong> or <strong class="source-inline">hashCode</strong> methods. This task is so common that Kotlin has it built into the language. It's called a <strong class="bold">data class</strong>.</p>&#13;
			<p>Let's take a look at the following example:</p>&#13;
			<p class="source-code">data class User(val username: String, private val </p>&#13;
			<p class="source-code">  password: String)</p>&#13;
			<p>This will generate us a class with two getters and no setters (note the <strong class="source-inline">val</strong> part), which will also implement <strong class="source-inline">equals</strong>, <strong class="source-inline">hashCode</strong>, and <strong class="source-inline">clone</strong> functions in the correct way.</p>&#13;
			<p>The<a id="_idIndexMarker110"/> introduction of <strong class="source-inline">data</strong> classes is one of the most significant improvements in reducing the amount of boilerplate in the Kotlin language. Just like the <a id="_idIndexMarker111"/>regular classes, <strong class="source-inline">data</strong> classes can have their own functions:</p>&#13;
			<p class="source-code">data class User(val username: String, private val </p>&#13;
			<p class="source-code">  password: String) {</p>&#13;
			<p class="source-code">    fun hidePassword() = "*".repeat(password.length)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">val user = User("Alexey", "abcd1234")</p>&#13;
			<p class="source-code">println(user.hidePassword()) // ********</p>&#13;
			<p>Compared to regular classes, the main limitation of <strong class="source-inline">data</strong> classes is that they are always <strong class="source-inline">final</strong>, meaning that no other class can inherit from them. But it's a small price to pay to have <strong class="source-inline">equals</strong> and <strong class="source-inline">hashCode</strong> functions generate automatically.</p>&#13;
			<h3>Kotlin data classes versus Java records</h3>&#13;
			<p>Learning<a id="_idIndexMarker112"/> from Kotlin, Java 15 introduced the notion <a id="_idIndexMarker113"/>of <strong class="bold">records</strong>. Here is how we can represent the same data as a Java <strong class="source-inline">record</strong>:</p>&#13;
			<p class="source-code">public record User(String username, String password) {}</p>&#13;
			<p>Both syntaxes are pretty concise. <em class="italic">Are there any differences, though?</em></p>&#13;
			<ul>&#13;
				<li>Kotlin <strong class="source-inline">data</strong> classes a have <strong class="source-inline">copy()</strong> function that records lack. We'll cover it in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>, while discussing the <strong class="bold">prototype</strong> design <a id="_idIndexMarker114"/>pattern.</li>&#13;
				<li>In a record, all properties must be <strong class="source-inline">final</strong>, or, in Kotlin terms, records support only values and not variables.</li>&#13;
				<li>The <strong class="source-inline">data</strong> classes can inherit from other classes, while records don't allow that.</li>&#13;
			</ul>&#13;
			<p>To summarize, <strong class="source-inline">data</strong> classes are superior to records in many ways. But both are great features of the respective languages. And since Kotlin is built with interoperability in mind, you can also <a id="_idIndexMarker115"/>easily mark a <strong class="source-inline">data</strong> class as a record to be accessible from Java:</p>&#13;
			<p class="source-code">@JvmRecord</p>&#13;
			<p class="source-code">data class User(val username: String, val password: String)</p>&#13;
			<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>Extension functions</h1>&#13;
			<p>The <a id="_idIndexMarker116"/>last feature we'll cover in this chapter before moving on is <strong class="bold">extension functions</strong>. Sometimes, you may want to extend the functionality of a class that is declared <strong class="source-inline">final</strong>. For example, you would like to have a string that has the <strong class="source-inline">hidePassword()</strong> function from the previous section.</p>&#13;
			<p>One way to achieve that is to declare a class that wraps the string for us:</p>&#13;
			<p class="source-code">data class Password(val password: String) {</p>&#13;
			<p class="source-code">    fun hidePassword() = "*".repeat(password.length)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This solution is quite wasteful, though. It adds another level of indirection.</p>&#13;
			<p>In Kotlin, there's a better way to implement this.</p>&#13;
			<p>To extend a class without inheriting from it, we can prefix the function name with the name of the class we'd like to extend:</p>&#13;
			<p class="source-code">fun <strong class="bold">String.</strong>hidePassword() = "*".repeat(<strong class="bold">this</strong>.length)</p>&#13;
			<p>This looks almost like a regular top-level function declaration, but with one crucial change – before the function name comes a class name. That class is <a id="_idIndexMarker117"/>called a <strong class="bold">method receiver</strong>.</p>&#13;
			<p>Inside the function body, <strong class="source-inline">this</strong> will refer to any <strong class="source-inline">String</strong> class that the function was invoked on.</p>&#13;
			<p>Now, let's declare a regular string and try to invoke this new function on it:</p>&#13;
			<p class="source-code">val password<strong class="bold">: String</strong> = "secretpassword"</p>&#13;
			<p class="source-code">println("Password: ${password.hidePassword()}")</p>&#13;
			<p>This prints the following:</p>&#13;
			<p class="source-code">&gt; Password: **************</p>&#13;
			<p><em class="italic">What black magic is this?</em> We managed to add a function to a <strong class="source-inline">final</strong> class, something that technically should be impossible.</p>&#13;
			<p>This is <a id="_idIndexMarker118"/>another feature of the Kotlin compiler, one among many. This extension function will be compiled to the following code:</p>&#13;
			<p class="source-code">// This is not real Kotlin</p>&#13;
			<p class="source-code">fun hidePassword(this: String) {</p>&#13;
			<p class="source-code">    "*".repeat(this.length)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>You can see that, in fact, this is a regular top-level function. Its first argument is an instance of the class that we extend. This also might remind you of how methods on structs<a id="_idIndexMarker119"/> in <strong class="bold">Go</strong> work.</p>&#13;
			<p>The code that prints the masked password will be adapted accordingly:</p>&#13;
			<p class="source-code">val password: String = "secretpassword"</p>&#13;
			<p class="source-code">println("Password: ${hidePassword(password)}")</p>&#13;
			<p>For that reason, the extension functions cannot override the member function of the class, or access its <strong class="source-inline">private</strong> or <strong class="source-inline">protected</strong> properties.</p>&#13;
			<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/>Introduction to design patterns</h1>&#13;
			<p>Now that we are a bit more familiar with basic Kotlin syntax, we can move on to discuss what design patterns are all about.</p>&#13;
			<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>What are design patterns?</h2>&#13;
			<p>There are <a id="_idIndexMarker120"/>different misconceptions surrounding design patterns. In general, they are as follows:</p>&#13;
			<ul>&#13;
				<li>Design patterns are just missing language features.</li>&#13;
				<li>Design patterns are not necessary in a dynamic language.</li>&#13;
				<li>Design patterns are only relevant to object-oriented languages.</li>&#13;
				<li>Design patterns are only used in enterprises.</li>&#13;
			</ul>&#13;
			<p>Actually, design patterns <a id="_idIndexMarker121"/>are just a proven way to solve a common problem. As a concept, they are not limited to a specific programming language (Java), nor to a family of languages (the C family, for example), nor are they limited to programming in general. You may have even heard of design patterns in software architecture, which discuss how different systems can efficiently communicate with each other. There <a id="_idIndexMarker122"/>are service-oriented architectural patterns, which you may know as <strong class="bold">Service-Oriented Architecture</strong> (<strong class="bold">SOA</strong>), and microservice design patterns that evolved from SOA and emerged over the past few years. The future will, for sure, bring us even more design pattern families.</p>&#13;
			<p>Even in the physical world, outside software development, we're surrounded by design patterns and commonly accepted solutions to a particular problem. Let's look at an example.</p>&#13;
			<h3>Design patterns in real life</h3>&#13;
			<p><em class="italic">Did you ride an elevator lately? Was there a mirror on the wall of the elevator? Why is that? How did you feel when you last rode an elevator that had no mirror and no glass walls?</em></p>&#13;
			<p>The <a id="_idIndexMarker123"/>main reason we commonly have mirrors in our elevators is to solve a frequent problem – riding in an elevator is boring. We could put in a picture. But a picture would also get boring after a while, if you rode the same elevator at least twice a day. Cheap, but not much of an improvement.</p>&#13;
			<p>We could put in a TV screen, as some do. But it makes the elevator more expensive. And it also requires a lot of maintenance. We need to put some content on the screen to make it not too repetitive. So, either there's a person whose responsibility is to renew the content once in a while or a third-party company that does it for us. We'll also have to handle different problems that may occur with screen hardware and the software behind it. Seeing the <em class="italic">blue screen of death</em> is amusing, of course, but only mildly.</p>&#13;
			<p>Some architects even go for putting elevator shafts on the building exterior and making part of the walls transparent. This may provide some exciting views. But this solution also requires maintenance (dirty windows don't make for the best view) and a lot of architectural planning.</p>&#13;
			<p>So, we put in a mirror. You get to watch an attractive person even if you ride alone. Some studies indicate that we find ourselves more attractive than we are, anyway. Maybe you<a id="_idIndexMarker124"/> get a chance to review your appearances one last time before that important meeting. Mirrors visually expand the visual space and make the entire trip less claustrophobic or less awkward if it's the start of a day and the elevator is really crowded.</p>&#13;
			<h3>Design process</h3>&#13;
			<p>Let's try and understand what we did just now.</p>&#13;
			<p>We didn't invent mirrors in elevators. We've seen them thousands of times. But we formalized the problem (riding in an elevator is boring) and discussed alternative solutions (TV screens and glass walls) and the benefits of the commonly used solution (solves the problem and is easy to implement). That's what design patterns are all about.</p>&#13;
			<p>The basic steps <a id="_idIndexMarker125"/>of the design process are as follows:</p>&#13;
			<ol>&#13;
				<li>Define exactly what the current problem is.</li>&#13;
				<li>Consider different alternatives, based on the pros and cons.</li>&#13;
				<li>Choose the solution that solves the problem while best fitting your specific constraints.</li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Why use design patterns in Kotlin?</h2>&#13;
			<p>Kotlin comes <a id="_idIndexMarker126"/>to solve the real-world problems of today. In the following chapters, we will discuss both the <em class="italic">design patterns</em> first introduced by the <em class="italic">Gang of Four</em> back in 1994, as well as design patterns that emerged from the functional programming paradigm and the design patterns that we use to handle concurrency in our applications.</p>&#13;
			<p>You'll find<a id="_idIndexMarker127"/> that some of the design patterns are so common or useful that they're already built into the language as reserved keywords or standard functions. Some of them will need to combine a set of language features. And some are not so useful anymore, since the world has moved forward, and other patterns are replacing them.</p>&#13;
			<p>But in any case, familiarity with design patterns and best practices expands your <em class="italic">developer toolbox</em> and creates a shared vocabulary between you and your colleagues.</p>&#13;
			<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Summary</h1>&#13;
			<p>In this chapter, we covered the main goals of the Kotlin programming language. We learned how variables are declared, the basic types, <strong class="source-inline">null</strong> safety, and type inference. We observed how program flow is controlled by commands such as <strong class="source-inline">if</strong>, <strong class="source-inline">when</strong>, <strong class="source-inline">for</strong>, and <strong class="source-inline">while</strong>, and we also took a look at the different keywords used to define classes and interfaces: class, interface, <strong class="source-inline">data</strong> class, and <strong class="source-inline">abstract</strong> class. We learned how to construct new classes and how to implement interfaces and inherit from other classes. Finally, we covered what design patterns are suitable for and why we need them in Kotlin.</p>&#13;
			<p>Now, you should be able to write simple programs in Kotlin that are pragmatic and type-safe. There are many more aspects of the language we need to discuss. We'll cover them in later chapters once we need to apply them.</p>&#13;
			<p>In the next chapter, we'll discuss the first of the three design pattern families – creation patterns.</p>&#13;
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What's the difference between <strong class="source-inline">var</strong> and <strong class="source-inline">val</strong> in Kotlin?</li>&#13;
				<li>How do you extend a class in Kotlin?</li>&#13;
				<li>How do you add functionality to a <strong class="source-inline">final</strong> class?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>