<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;Making a Good Application Architecture in Swift" id="J2B81-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Making a Good Application Architecture in Swift</h1></div></div></div><p class="calibre8">Swift is a <a id="id86" class="calibre1"/>high-performance programming language, as you learned in the previous chapter. You also learned that writing good code is even more important than making it high-performance code. In this chapter, we will put the all-powerful features of Swift together and create an application. We will do this by covering the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Writing clean code</li><li class="listitem">Immutability</li><li class="listitem">Value types and immutability</li><li class="listitem">Representing the state with classes</li><li class="listitem">Representing the absence of values with optionals</li><li class="listitem">Functional programming</li><li class="listitem">Generics</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Making a Good Application Architecture in Swift" id="J2B81-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Making a Swift application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec14" class="calibre1"/>Making a Swift application</h1></div></div></div><p class="calibre8">The first step in <a id="id87" class="calibre1"/>creating a good application architecture is to create the application itself. We will be creating an iOS journal application used to make daily notes. We are not going to cover any iOS-specific topics, so you can use the same code and create OS X applications as well.</p><p class="calibre8">Go ahead! Open Xcode and create a new iOS single-view project application. Now, we are ready for coding.</p><p class="calibre8">First, let's create a <code class="literal">Person</code> type, for the owner of the journal, and a journal entry type. We will use the <code class="literal">Class</code> type to create both <code class="literal">Person</code> and <code class="literal">JournalEntry</code>. Both classes are very simple—just a bunch of properties and an initializer:</p><div class="informalexample"><pre class="programlisting">class Person {
  var firstName: String
  var lastName: String

  init (firstName: String, lastName: String) {
    self.firstName = firstName
    self.lastName = lastName
  }
 }

class JournalEntry {
  var title: String
  var text: String
  var date: NSDate
  
  init (title: String, text: String) {
    self.title = title
    self.text = text
    date = NSDate()
  }
}</pre></div><p class="calibre8">This is the minimal <a id="id88" class="calibre1"/>setup that we need for the app. Before we move forward, let's make the code better.</p></div></div>
<div class="book" title="The differences between variables and constants" id="K0RQ1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>The differences between variables and constants</h1></div></div></div><p class="calibre8">Probably, the most <a id="id89" class="calibre1"/>often used feature in all programming languages is creating and storing a value. We create local variables in functions and declare<a id="id90" class="calibre1"/> them in classes and other data structures; that's why it's very important to do it properly.</p><p class="calibre8">In Swift, there are two ways of creating and storing a value, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Making it a variable:<div class="informalexample"><pre class="programlisting">var name = "Sara"</pre></div></li><li class="listitem">Making it a constant:<div class="informalexample"><pre class="programlisting">let name = "Sara"</pre></div></li></ul></div><p class="calibre8">The difference between variables and constants is that a constant value can be assigned only once and can't be changed after that. A variable value, on the other hand, can be changed anytime. Here's an example:</p><div class="informalexample"><pre class="programlisting">var name = "Sam"
name = "Jon"

let lastName = "Peterson"
lastName = "Jakson" //Error, can't change constant after assigning</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">The golden rule is to always declare your type as a constant (the <code class="literal">let</code> keyword in the <a id="id91" class="calibre1"/>previous example) first. Change it to a variable (the <code class="literal">var</code> keyword) only if you need it afterwards.</p><p class="calibre8">There are some exceptions when you can't declare it as a constant, for example, when making <code class="literal">@IBOutles</code> or <code class="literal">weak</code>. Also, optional values must be declared as variables.</p></div><p class="calibre8">Using constants <a id="id92" class="calibre1"/>has many benefits over using variables. A constant is an immutable type, and we will cover all the benefits of immutability later. The two most important benefits are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Safety (protection from unexpected value changes)</li><li class="listitem">Better performance</li></ul></div><p class="calibre8">You should use constants both when declaring properties and as local constants in functions. We should apply this rule and change our <code class="literal">Person</code> and <code class="literal">JournalEntry</code> classes as follows:</p><div class="informalexample"><pre class="programlisting">class Person {
  let name: String
  let lastName: String
...
}

class JournalEntry {
  let title: String
  let text: String
  let date: NSDate
...
}</pre></div><p class="calibre8">Usually, you will find yourself using constants more often than variables. Let's look at an example where you could think about using a variable but, in fact, a constant would be a better solution. Let's say you have created a new person in the application and now you want to display a full name with a gender prefix:</p><div class="informalexample"><pre class="programlisting">let person = Person(firstName: "Jon", lastName: "Bosh")
let man = true

var fullName: String
if man {
  fullName = "Mr "
} else {
  fullName = "Mrs "
}

fullName += person.firstName
fullName += " "
fullName += person.lastName</pre></div><p class="calibre8">If you think a<a id="id93" class="calibre1"/> bit more about the problem, you will realize that<a id="id94" class="calibre1"/> <code class="literal">fullName</code> of the person should be immutable; it's not going to change, and it should be declared as a constant:</p><div class="informalexample"><pre class="programlisting">let person = Person(firstName: "Jon", lastName: "Bosh")
let man = true

let gender: String = man ? "Mr": "Mrs"
let fullName = "\(gender) \(person.firstName) \(person.lastName)"</pre></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Immutability" id="KVCC1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Immutability</h1></div></div></div><p class="calibre8">In the previous <a id="id95" class="calibre1"/>section, you learned how important it is to use immutable constants. There are more immutable types in Swift, and you should take advantage of them and <a id="id96" class="calibre1"/>use them. The advantages of immutability are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It removes a bunch of issues related to unintentional value changes</li><li class="listitem">It is a safe multithreading access</li><li class="listitem">It makes reasoning about code easier</li><li class="listitem">There is an improvement in performance</li></ul></div><p class="calibre8">By making types immutable, you add an extra level of security. You deny access to mutating an instance. In our journal app, it's not possible to change a person's name after an instance has been created. If, by accident, someone decides to assign a new value to the person's <code class="literal">firstName</code>, the compiler will show an error:</p><div class="informalexample"><pre class="programlisting">var person = Person(firstName: "Jon", lastName: "Bosh")
p.firstName = "Sam" // Error</pre></div><p class="calibre8">However, there are situations when we need to update a variable. An example could be an array; suppose you need to add a new item to it. In our example, maybe the person wants to change a nickname in the app. There are two ways to do this, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Mutating an existing instance</li><li class="listitem">Creating a new instance with updated information</li></ul></div><p class="calibre8">Mutating an instance in place could lead to a dangerous, unpredictable effect, especially when you are mutating a reference instance type.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">Classes are reference types. "Reference type" means that many variables and constants can refer to the same instance data. Changes done to the instance data reflect in all variables.</p></div><p class="calibre8">Creating a new<a id="id97" class="calibre1"/> instance is a much safer operation. It doesn't have any impact on the existing instances in the system. After we have created a new instance, it may be necessary to notify other parts of the system about this change. This is a safer way of updating instance data. Let's look at how we can implement a nickname change in our <code class="literal">Person</code> class. First, let's add a nickname to the <code class="literal">Person</code> class:</p><div class="informalexample"><pre class="programlisting">class Person {
  let nickName: String
…

func changeNickName(nickName: String) -&gt; Person  {
    return Person(firstName: firstName, lastName: lastName,
                   nickName: nickName)
  }
}

let sam = Person(firstName: "Sam", lastName: "Bosh", 
  nickName:"sam")
let rockky = sam.changeNickName("Rockky")</pre></div><p class="calibre8">Because we made a <code class="literal">sam</code> instance a constant, we can't assign a new value to it after changing <code class="literal">nickName</code>. In this example, it would be better to make it a variable because we actually need to update it:</p><div class="informalexample"><pre class="programlisting">var sam = Person(firstName: "Sam", lastName: "Bosh", 
  nickName:"BigSam")
sam = sam.changeNickName("Rockky")</pre></div></div>

<div class="book" title="Immutability" id="KVCC1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Multithreading"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec20" class="calibre1"/>Multithreading</h2></div></div></div><p class="calibre8">We get more and<a id="id98" class="calibre1"/> more core processors nowadays, and working with multithreading is a part of our life. We have GCD and NSOperation for performing work on multiple threads.</p><p class="calibre8">The main issue with multithreading is synchronizing read-and-write access to data without corrupting that data. As an example, let's create an array of journal entries and try to modify it in the background and main thread. This will lead to an application crash:</p><div class="informalexample"><pre class="programlisting">class DangerousWorker {
  var entries: [JournalEntry]

  init() {
    //Add test entries
    let entry = JournalEntry(title: "Walking", text: "I was 
      walking in the loop")
    entries = Array(count: 100, repeatedValue: entry)
  }

  func dangerousMultithreading() {

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)) {
      sleep(1) //emulate work
      self.entries.removeAll()
    }
  
    print("Start Main")
    for _ in 0..&lt;entries.endIndex {
      entries.removeLast() //Crash
      sleep(1) //emulate work
    }
  }
}

let worker = DangerousWorker()
worker.dangerousMultithreading()</pre></div><p class="calibre8">These kinds of issues<a id="id99" class="calibre1"/> are really hard to find and debug. If you remove the <code class="literal">sleep(1)</code> delay, the crash might not occur on some devices, depending on which thread is run first.</p><p class="calibre8">When you make your data immutable, it becomes read-only and all threads can read it simultaneously without any problems:</p><div class="informalexample"><pre class="programlisting">let entries: [JournalEntry]

let entry = JournalEntry(title: "Walking", text: "I was walking")
entries = Array(count: 100, repeatedValue: entry)
// entries is immutable now, read-only

dispatch_async(dispatch_get_global_queue(
              DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)) {
 
  for entry in self.entries {
    print("\(entry) in BG")
  }
}

for entry in self.entries {
  print("\(entry) in BG")
}</pre></div><p class="calibre8">But we often need to <a id="id100" class="calibre1"/>make changes to the data. Instead of making changes directly to the source data, a better solution is to create new, updated data and pass the result to the caller thread. In this way, multiple threads can safely continue performing a read operation. We will take a look at multithreading data synchronization in <a class="calibre1" title="Chapter 6. Architecting Applications for High Performance" href="part0057_split_000.html#1MBG21-f05765b7b5914043830034430c83d0a0">Chapter 6</a>, <span class="strong"><em class="calibre10">Architecting Applications for High Performance</em></span>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Value types and immutability" id="LTSU1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Value types and immutability</h1></div></div></div><p class="calibre8">There are two<a id="id101" class="calibre1"/> different data types in Swift:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Reference types</li><li class="listitem">Value types</li></ul></div><p class="calibre8">Let's take a look at these.</p></div>

<div class="book" title="Value types and immutability" id="LTSU1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Reference types"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec21" class="calibre1"/>Reference types</h2></div></div></div><p class="calibre8">A class is a reference type. When<a id="id102" class="calibre1"/> you create an instance of a reference type and assign it to a variable or constant, you are not only assigning  a value but also a reference that points to the value, which is located somewhere else (actually it is located in the heap memory). When you pass that reference to other functions and assign it to other variables, you are creating multiple references that point to the same data. If one of those variables changes the data, that change will reflect in all other variables as well. Here's an example that shows this:</p><div class="informalexample"><pre class="programlisting">let person = Person(firstName: "Sam", lastName: "Jakson")
let a = person, b = person, c = person</pre></div><p class="calibre8">The following diagram shows what the memory for this code would look like:</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Reference types" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">All four constants would refer to the same object. The danger in this architecture is that if one of those<a id="id103" class="calibre1"/> constants updates a piece of instance data, every other constant would get updated as well. Here's an example that shows this:</p><div class="informalexample"><pre class="programlisting">a.firstName = "Jaky"
b.firstName // Jaky</pre></div><p class="calibre8">Sometimes, this can be desirable behavior, for example, when many variables are referencing the same window object. There should be only one window object, and changes made in one place should be reflected in others as well.</p></div></div>

<div class="book" title="Value types and immutability" id="LTSU1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Value types"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec22" class="calibre1"/>Value types</h2></div></div></div><p class="calibre8">A structure, on the<a id="id104" class="calibre1"/> other hand, is a value type. When you create an instance of a value type and assign it to a variable, you are assigning actual data. When<a id="id105" class="calibre1"/> you pass that instance to other functions and variables, you are passing a copy of that value. The copy is made automatically. You may think that copying values would have a negative impact on performance, but in reality, value types give higher performance than reference types. Value types are smart enough to optimize data copying only when it's required (when data is being modified).</p><p class="calibre8">If we make our <code class="literal">Person</code> type a <code class="literal">Structure</code> type, the same code example would look like this:</p><div class="informalexample"><pre class="programlisting">let person = Person(firstName: "Sam", lastName: "Jakson")
let a = person, b = person, c = person</pre></div><p class="calibre8">The memory for this structure's constants would look like this:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Value types" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The advantage of this architecture is that your code components are isolated and not dependent on each other.</p><p class="calibre8">One big difference<a id="id106" class="calibre1"/> between reference types and value types is explained as follows: when you create a constant as a reference type, you are making a constant reference (which means that you can't change it to point to another instance). But you can change the data in the instance itself, as we did in the example by updating the <code class="literal">firstName</code> of the person.</p><p class="calibre8">When you make a constant of a value type, you get a constant value that can't be changed.</p><div class="book" title="The power of structures"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec13" class="calibre1"/>The power of structures</h3></div></div></div><p class="calibre8">If you look more closely at the <a id="id107" class="calibre1"/>Swift standard library type definition, you will discover that most of the types are implemented as a structure, such as <code class="literal">struct</code> <code class="literal">Int</code>, <code class="literal">struct String</code>, <code class="literal">struct Array</code>, and others.</p><p class="calibre8">The structure is not only a simple and fast data structure, but also a very powerful one. Structures can have methods, properties, and initializers, and they can conform to protocols. When you're designing your entities in the application, try to use structures for your data model, and structures are preferred in general. Now we will apply this advice and change our types to use a structure instead of a class:</p><div class="informalexample"><pre class="programlisting">struct Person {
  let firstName: String
  let lastName: String
  let nickName: String

  func changeNickName(nickName: String) -&gt; Person  {
    return Person(firstName: firstName, lastName: lastName,nickName: nickName)
  }
}

extension Person {

  init(firstName: String, lastName: String) {
    self.init(firstName: firstName, lastName: lastName,       nickName:"")
  }
}</pre></div><p class="calibre8">The first difference is that we changed the <code class="literal">class</code> keyword to <code class="literal">struct</code>. The second one is more interesting—we removed the <code class="literal">init</code> method. If you don't define an initializer, a structure provides a <a id="id108" class="calibre1"/>default member-wise initializer. A member-wise initializer takes all the properties of the structure. If you need an extra initializer in addition to a default member-wise one, you can create it in an extension. In this way, you would have two initializers:</p><div class="informalexample"><pre class="programlisting">  Person(firstName: "Sam", lastName:"Niklson", nickName: "Bigsam")
  Person(firstName: "Petter", lastName: "Hanson")</pre></div></div><div class="book" title="Representing the state with classes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec14" class="calibre1"/>Representing the state with classes</h3></div></div></div><p class="calibre8">When designing <a id="id109" class="calibre1"/>a data model in the application, use value types. The value types should be:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Inert</li><li class="listitem">Isolated</li><li class="listitem">Interchangeable</li></ul></div><p class="calibre8">The value type shouldn't behave and it shouldn't have side effects. The operation on the data should go to the value layer. You can learn more about designing data models with value types in the<a id="id110" class="calibre1"/> presentation <span class="strong"><em class="calibre10">Controlling Complexity in Swift</em></span> by Andy Matuschak at <a class="calibre1" href="https://realm.io/news/andy-matuschak-controlling-complexity/">https://realm.io/news/andy-matuschak-controlling-complexity/</a>.</p><p class="calibre8">Classes, on the other hand, can have a behavior and a state. An action of creating a new <code class="literal">JournalEntry</code> is a behavior, for example, and it should implemented in the class type. The current user's <code class="literal">JournalEntry</code> list is a state, and this should also be stored in the class type:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, what we do is create a <code class="literal">Journal</code> data model as a value type. It contains data and operations to work with that data (it has the <code class="literal">addEntry</code> method, which creates and adds new entries to the journal):<div class="informalexample"><pre class="programlisting">struct Journal {
  let owner: Person
  var entries: [JournalEntry]

  mutating func addEntry(title: String, text: String) {
    let entry = JournalEntry(title: title, text: text)
    entries.append(entry)
  }
}

extension Journal {
  init(owner: Person) {
    self.owner = owner
    self.entries = []
  }
}</pre></div></li><li class="listitem" value="2">The next step is to create a controller entity as a reference type that will hold the current<a id="id111" class="calibre1"/> journal state in the application and handle the action of adding a new entry:<div class="informalexample"><pre class="programlisting">class JournalController  {
  var journal: Journal

  init(owner: Person) {
    self.journal = Journal(owner: owner)
  }

  func addEntry(title: String, text: String) {
    journal.addEntry(title, text: text);
  }
}</pre></div></li></ol><div class="calibre26"/></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Representing the absence of values with optionals"><div class="book" id="MSDG2-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Representing the absence of values with optionals</h1></div></div></div><p class="calibre8">Let's go back to the past <a id="id112" class="calibre1"/>and see how the absence of a value is represented in Objective-C, as an example. There isn't a standard solution for representing the absence of a value for both reference and simple value types. There are two different ways:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">nil</code></li><li class="listitem"><code class="literal">0</code>, <code class="literal">-1</code>, <code class="literal">INT_MAX</code>, <code class="literal">NSNotFound</code>, and so on</li></ul></div><p class="calibre8">For reference types, Objective-C uses the <code class="literal">nil</code> value to represent that a variable doesn't have a value. It points to nowhere.</p><p class="calibre8">For value types, there is no such value as <code class="literal">nil</code> and it is not possible to assign <code class="literal">nil</code> to an integer variable. To do that, Objective-C (and not only Objective-C but also C, Java, and many other languages) uses a few special values that are unlikely to be the result of a particular operation. For example, the <code class="literal">indexOfObject</code> method of <code class="literal">NSArray</code> would return <code class="literal">NSNotFound</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">
<code class="literal">NSNotFound</code> is just a constant and its value is equal to <code class="literal">NSIntegerMax</code>, whose value, in turn, is <code class="literal">2147483647</code>.</p></div><p class="calibre8">Swift uses an optional to represent the absence of a value in a common way for both value and reference types. An optional is a way of annotating that the value could be missing. You can<a id="id113" class="calibre1"/> declare a type as optional in two ways:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Using the optional keyword, that is, <code class="literal">Optional&lt;Type&gt;</code></li><li class="listitem">By adding a question mark to the end of the type, that is, <code class="literal">Type?</code><div class="note" title="Note"><h3 class="title2"><a id="tip10" class="calibre1"/>Tip</h3><p class="calibre8">
<code class="literal">Type?</code> is the preferred way to declare an optional type.</p></div></li></ul></div><p class="calibre8">To represent a missing value, you can simply assign <code class="literal">nil</code> to an optional, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var view: Optional&lt;UIView&gt;
var index: Int?

view = nil
view = UIView()

index = 10
index = nil</pre></div></div>

<div class="book" title="Representing the absence of values with optionals">
<div class="book" title="Optional and non-optional types"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec23" class="calibre1"/>Optional and non-optional types</h2></div></div></div><p class="calibre8">In Objective-C both <a id="id114" class="calibre1"/>optional and non-optional values are represented by the same type, for example, <code class="literal">NSInteger, NSSString *</code>. By looking at the source code and method<a id="id115" class="calibre1"/> definition, there is no way to say whether a method can return <code class="literal">nil</code> or <code class="literal">NSNotFound</code> or not:</p><div class="informalexample"><pre class="programlisting">- (NSUInteger)indexOfObject:(id)anObject;
+ (instancetype)stringWithString:(NSString *)string;</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8">In Xcode 6.3, we have new Objective-C annotations, <code class="literal">nullable</code> and <code class="literal">nonnull</code>, that allow us to specify whether <code class="literal">nil</code> can be passed or not. These annotations were added after Swift's release to provide better Objective-C integration with Swift.</p></div><p class="calibre8">Swift is stricter about this. It has both optional and non-optional types. Two examples of non-optional types are <code class="literal">Int</code> and <code class="literal">String</code>. This means that you can't assign <code class="literal">nil</code> to an <code class="literal">Int</code> variable or pass <code class="literal">nil</code> to a function with the <code class="literal">Int</code> parameter type. Optional types, on the other hand, allow you to use <code class="literal">nil</code>:</p><div class="informalexample"><pre class="programlisting">var index: Int?
var number: Int = 10

index = nil // Ok
number = nil // Error

func indexOfObject(object: Any) -&gt; Int?
func stringWithString(string: String?) -&gt; String?</pre></div><p class="calibre8">This strict rule <a id="id116" class="calibre1"/>makes the code's intention really clear. From the API, you see that to call an<a id="id117" class="calibre1"/> <code class="literal">indexOfObject</code> function, you need to pass a non-optional argument, and it could return <code class="literal">nil</code> as a result.</p></div></div>

<div class="book" title="Representing the absence of values with optionals">
<div class="book" title="Safe nil handling"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec24" class="calibre1"/>Safe nil handling</h2></div></div></div><p class="calibre8">The other <a id="id118" class="calibre1"/>problem is in trying to access <code class="literal">nil</code> values. If you have been programming in C, Java, or Objective-C, you must have faced one of the <code class="literal">NullPointerException</code> exception or the <code class="literal">NSInvalidArgumentException</code> exception.</p><p class="calibre8">In general, it is unsafe to access uninitialized memory. For example, passing <code class="literal">nil</code> to the <code class="literal">initWithString</code> method in Objective-C would result in an <code class="literal">NSInvalidArgumentException</code> exception, and maybe an application crash:</p><div class="informalexample"><pre class="programlisting">[NSString initWithString: nil] – crash</pre></div><p class="calibre8">The sad part is that Objective-C didn't check the difference between <code class="literal">String * type</code> and <code class="literal">nil</code>.</p><p class="calibre8">Optionals in Swift not only make it clear about the ability to use <code class="literal">nil</code>, but also make it very safe to work with and avoid crashes.</p></div></div>

<div class="book" title="Representing the absence of values with optionals">
<div class="book" title="Using optionals"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec25" class="calibre1"/>Using optionals</h2></div></div></div><p class="calibre8">Now that you've understood<a id="id119" class="calibre1"/> the background on why optionals were invented, let's go ahead and use them in our application. We have our <code class="literal">JournalEntry</code> entity, and let's say the user can add a location where this entry was created (this is an optional feature; some entries will have it and some will not). We need to create a new type to store the geographic location, and add a new <code class="literal">Optional</code> property to our <code class="literal">JournalEntry</code> entity:</p><div class="informalexample"><pre class="programlisting">struct Location {
  let latitude: Double
  let longitude: Double
}

struct JournalEntry {
  var location: Location?
...
}
var entry = JournalEntry(title: "Walking", text: "I was walking in the loop")
let location = Location(latitude: 37.331686, longitude: -122.030656)
entry.location = location</pre></div><p class="calibre8">Optional variables are assigned a <code class="literal">nil</code> value by default, and because of this, we don't need to make any more <a id="id120" class="calibre1"/>changes to our <code class="literal">init</code> methods (all the properties have been provided with a value).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip11" class="calibre1"/>Tip</h3><p class="calibre8">The <code class="literal">var: Int? = nil</code> is the same as <code class="literal">var: Int?</code>. Don't assign a nil value if you are declaring an optional variable.</p></div><p class="calibre8">This is much more interesting when you try to access an optional value. An optional is like a closed box with something inside. To get the value out of it, you have to open it first. To check whether an optional has a value inside it, use the <code class="literal">if and == nil</code> or <code class="literal">!= nil</code> comparison operator. To get actual data out of the box, you need to unwrap it using <code class="literal">! sign</code>:</p><div class="informalexample"><pre class="programlisting">if entry.location != nil {
  showLocation(entry.location!)
} else {
  //locationNotAvailable
}</pre></div><p class="calibre8">This, however, is not the optimal way of getting a value from an optional. A better way is to use the optional binding operator, which checks whether the optional has a value, and unwraps its value at once. The syntax is <code class="literal">if let unwrappedValue = optional</code>:</p><div class="informalexample"><pre class="programlisting">let location = entry.location
if let location = location {
  showLocation(location)
} else {
  //locationNotAvailable
}</pre></div><p class="calibre8">First, we extract the location to a local constant, and it has the <code class="literal">Optional&lt;Location&gt;</code> type. Next, we apply the optional binding operator and get a value from the options to a location constant. The constant name for an optional value is the same as the optional name (<code class="literal">location</code> in this example). This technique is called<a id="id121" class="calibre1"/> <span class="strong"><strong class="calibre9">name shadowing</strong></span>. When you use a location as an argument for the <code class="literal">showLocation</code> function, you are using the unwrapped constant value.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip12" class="calibre1"/>Tip</h3><p class="calibre8">When using the optional binding operator, use name shadowing. This makes the code much more readable. Here is how it would look without name shadowing:</p><div class="informalexample"><pre class="programlisting">if let location = maybeLocation {
  showLocation(location)
}</pre></div><p class="calibre8">Adding different names for the optional and its unwrapped value (<code class="literal">maybeLocation</code> and <code class="literal">location</code> in our example) makes the code more confusing.</p></div><p class="calibre8">There is also<a id="id122" class="calibre1"/> another type of optionals available in Swift—implicitly unwrapped optionals. You declare them with <code class="literal">Type!</code>, for example, <code class="literal">Int!</code>. An implicitly unwrapped option is one that does not require checking of whether values exist inside an option, but allows you to access the data as if it were not the optional type. Here is an example:</p><div class="informalexample"><pre class="programlisting">var name: String! = "Jon"
print("My name is" + name)

name = nil
print("My name is " + name) // Crash</pre></div><p class="calibre8">Using implicitly unwrapped optionals is unsafe and not recommended. There are very few situations where you should use them. They are mostly used to interact with the Objective-C API. This is because many types from Objective-C are transformed into Swift as implicitly unwrapped optionals.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre8">Avoid using implicitly unwrapped optionals.</p></div></div></div>

<div class="book" title="Representing the absence of values with optionals">
<div class="book" title="Wrapping up on optionals"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec26" class="calibre1"/>Wrapping up on optionals</h2></div></div></div><p class="calibre8">If the idea of<a id="id123" class="calibre1"/> optionals is new to you, don't be afraid; you will get used to working with them, and you will like them. Here are few small notes that you should remember from this topic:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Don't use implicitly unwrapped optionals wherever possible—almost never!</li><li class="listitem">Check whether an optional has a value before accessing it</li><li class="listitem">Use optional binding and shadowing of the optional variable name to access a value</li><li class="listitem">Design your API's intentions to be clear with optional and non-optional types</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Functional programming"><div class="book" id="NQU22-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Functional programming</h1></div></div></div><p class="calibre8">In the functional <a id="id124" class="calibre1"/>programming paradigm, a function has a type and it is treated in the same way as other types, such as <code class="literal">Int</code>, <code class="literal">String</code>, and <code class="literal">Class</code>. The function can be assigned to a variable, passed as an argument to another function, and returned from a function as a result type. The main goal is to split the code into small, standalone functions. The perfect function has no side effects and operates only with arguments that were passed to it.</p><p class="calibre8">In the functional programming style, you describe <span class="strong"><em class="calibre10">what you want to do</em></span> and not <span class="strong"><em class="calibre10">how you want to do it</em></span>.</p><p class="calibre8">Functional<a id="id125" class="calibre1"/> programming is great for data transformation and data manipulation. This is because you are able to split code into smaller parts. You can often reuse some routine boilerplate code.</p></div>

<div class="book" title="Functional programming">
<div class="book" title="Function types"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec27" class="calibre1"/>Function types</h2></div></div></div><p class="calibre8">Every function has a<a id="id126" class="calibre1"/> type. The type of a function consists of its parameter type and return type. Now, we will create a few functions with different types and perform some operations:</p><div class="informalexample"><pre class="programlisting">func hello() {
    print("Hello")
}

func add(x: Int, y: Int) -&gt; Int {
    return x + y
}

func subtract(x: Int, y: Int) -&gt; Int {
    return x - y
}

var hi: () -&gt; () = hello
var mathOperation: (Int, Int) -&gt; Int
 
mathOperation = add 
mathOperation(10, 11) // 21
mathOperation = subtract
mathOperation(10, 11) // -1

hi()
mathOperation = hello // Error, wrong types</pre></div><p class="calibre8">The <code class="literal">hello</code> function has the <code class="literal">() -&gt; ()</code> type. It takes nothing and returns nothing. The <code class="literal">add</code> and <code class="literal">subtract</code> functions have a different type: <code class="literal">(Int, Int) -&gt; Int</code>. In the preceding example code, we assigned functions to the <code class="literal">hi</code> and <code class="literal">mathOperation</code> local variables.</p><p class="calibre8">It is not possible to assign the <code class="literal">hello</code> function to the <code class="literal">mathOperation</code> variable because they have <a id="id127" class="calibre1"/>different types.</p></div></div>

<div class="book" title="Functional programming">
<div class="book" title="Splitting the code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec28" class="calibre1"/>Splitting the code</h2></div></div></div><p class="calibre8">Because we <a id="id128" class="calibre1"/>can pass one function to another, we can split the code into the actual logic and the routine work. Let's implement a very common operation. The task is to double every element in the array. In imperative programming, this task would translate into iterating over every element in the array, doubling every element, and saving the result in a new array. In the end, the result array is returned with all its elements doubled:</p><div class="informalexample"><pre class="programlisting">let numbers = [1, 2, 3]

func doubleNumbers(array: [Int]) -&gt; [Int] {

  var result = [Int]()
  for element in numbers {
    result.append(element * 2)
  }
  return result
}

let result = doubleNumbers(numbers) // [2, 4, 6]</pre></div><p class="calibre8">The problem with this code is that there is only one line that actually does the work, that is, <code class="literal">element * 2</code>. It can't be reused because this logic is hardcoded into the function body. What if we want to triple numbers or do some other transformation? Here is how this task is implemented in the functional way:</p><div class="informalexample"><pre class="programlisting">func transform(array: [Int], f: Int -&gt; Int) -&gt; [Int] {
  
  var result = [Int]()
  for element in array {
    result.append(f(element))
  }
  return result
}</pre></div><p class="calibre8">The only difference here is that the <code class="literal">transform</code> function takes a transformation function as an argument. The transformation function does all the routine work, iterating over an array, but it leaves the actual transformation logic to be performed by the function that you passed as an argument. In this way, you can pass different functions to the <code class="literal">transform</code> function:</p><div class="informalexample"><pre class="programlisting">func double(x: Int) -&gt; Int {
    return x * 2
}

func triple(x: Int) -&gt; Int {
    return x * 3
}

let result = transform(numbers, f: double)
let result = transform(numbers, f: triple)</pre></div></div></div>

<div class="book" title="Functional programming">
<div class="book" title="The closure expression"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec29" class="calibre1"/>The closure expression</h2></div></div></div><p class="calibre8">A closure expression is an<a id="id129" class="calibre1"/> inline, unnamed, and self-contained block of code. You can think of a closure expression as a function without <a id="id130" class="calibre1"/>a name; it also takes parameters and has a body and a return type. You can use a closure instead of a function if they have the same type.</p><p class="calibre8">The general syntax for a closure expression is as follows:</p><div class="informalexample"><pre class="programlisting">{ (parameter name: type) -&gt; return type in  body }</pre></div><p class="calibre8">Let's refactor our <code class="literal">transform</code> function to use a closure instead. Here is the result:</p><div class="informalexample"><pre class="programlisting">transform(numbers, f: { (x: Int) -&gt; Int in
  return x * 2
})</pre></div><p class="calibre8">Because closure expressions are designed to be used inline, they have many syntax optimizations for making them clean and clear. Here are some examples of these optimizations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Type inference</li><li class="listitem">Implicit return type</li><li class="listitem">Shorthand argument name</li><li class="listitem">Trailing closure syntax</li></ul></div><div class="book" title="Type inference"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec15" class="calibre1"/>Type inference</h3></div></div></div><p class="calibre8">Thanks to type<a id="id131" class="calibre1"/> inference, you don't need to specify the parameter type and return type, as shown here:</p><div class="informalexample"><pre class="programlisting">transform(numbers, f: { x in
  return x * 2
})</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre8">As a general rule, you should avoid specifying types whenever it is possible.</p></div></div><div class="book" title="Implicit return type"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec16" class="calibre1"/>Implicit return type</h3></div></div></div><p class="calibre8">A closure with a <a id="id132" class="calibre1"/>single-expression body implicitly returns the result of that expression. The <code class="literal">return</code> keyword can be omitted in such cases:</p><div class="informalexample"><pre class="programlisting">transform(numbers, f: { x in x * 2 })</pre></div><p class="calibre8">In this example, we can't omit the <code class="literal">return</code> keyword because there is more than one expression:</p><div class="informalexample"><pre class="programlisting">transform(numbers, f: { x in
  let result = x * 2
  return result + 10 
})</pre></div></div><div class="book" title="Shorthand argument names"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec17" class="calibre1"/>Shorthand argument names</h3></div></div></div><p class="calibre8">You can omit<a id="id133" class="calibre1"/> argument names from a closure expression. In such cases, Swift provides a default name for every argument. This name consists of the <code class="literal">$</code> sign and the argument index, for example, <code class="literal">$0</code>, <code class="literal">$1</code>, <code class="literal">$2</code>, and so on:</p><div class="informalexample"><pre class="programlisting">transform(numbers, f: { $0 * 2 })</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre8">Shorthand argument names are preferred for very short closure expressions in which an argument is used once or twice. In other cases, give your argument a descriptive name.</p></div></div><div class="book" title="Trailing closure syntax"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec18" class="calibre1"/>Trailing closure syntax</h3></div></div></div><p class="calibre8">When a function's last<a id="id134" class="calibre1"/> argument is a closure, you can write the closure expression outside the function call:</p><div class="informalexample"><pre class="programlisting">transform(numbers) { $0 * 2 }</pre></div><p class="calibre8">You can use all closure syntax with trailing closures:</p><div class="informalexample"><pre class="programlisting">transform(numbers) { x in x * 2 }</pre></div><p class="calibre8">If a function has only one argument and it is a closure, you don't need to specify empty parentheses for the function call:</p><div class="informalexample"><pre class="programlisting">func map(function: Int -&gt; Int) -&gt; [Int] {
  ...
}
map() { $0 * 2 }
map { $0 * 2 }</pre></div></div></div></div>

<div class="book" title="Functional programming">
<div class="book" title="The standard library"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec30" class="calibre1"/>The standard library</h2></div></div></div><p class="calibre8">Swift's standard library<a id="id135" class="calibre1"/> has many functions and methods<a id="id136" class="calibre1"/> that accept other functions. Here are a few methods of <code class="literal">SequenceType</code> that you should know and use:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">map</code></li><li class="listitem"><code class="literal">reduce</code></li><li class="listitem"><code class="literal">filter</code></li><li class="listitem"><code class="literal">sort</code></li></ul></div><div class="book" title="The map method"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec19" class="calibre1"/>The map method</h3></div></div></div><p class="calibre8">The <code class="literal">map</code> method applies<a id="id137" class="calibre1"/> a <code class="literal">transform</code> function to every item and returns<a id="id138" class="calibre1"/> the new resultant collection. This process is called mapping, where the values A to B are mapped:</p><div class="informalexample"><pre class="programlisting">func map(transform: (Int) -&gt; String) -&gt; [String]</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8">Swift's standard library uses the <code class="literal">generic</code> function, but in the following example, they have been changed to actual types to provide simpler examples. Here is the actual definition of the <code class="literal">map</code> function:</p><div class="informalexample"><pre class="programlisting">func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) -&gt; T) -&gt; [T]</pre></div></div><p class="calibre8">The <code class="literal">map</code> method does exactly the same job as our <code class="literal">transform</code> function. So, you should be using <code class="literal">map</code> instead:</p><div class="informalexample"><pre class="programlisting">let result = numbers.map(double)
let result = numbers.map { $0 * 2 }</pre></div><div class="book" title="map for optionals"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch02lvl4sec03" class="calibre1"/>map for optionals</h4></div></div></div><p class="calibre8">The <code class="literal">Optional</code> type<a id="id139" class="calibre1"/> also has the <code class="literal">map</code> method, but here it works differently. It takes a function that maps an optional value, if it exists, to another value:</p><div class="informalexample"><pre class="programlisting">func map&lt;U&gt;(@noescape f: (Wrapped) -&gt; U) -&gt; U?</pre></div><p class="calibre8">The body of this <code class="literal">map</code> method would look like this:</p><div class="informalexample"><pre class="programlisting">func map(f: (Wrapped) -&gt; Double) -&gt; Double? {
  switch self {
    case .None: return nil
    case .Some(let x): return f(x)
  }
} 

let number: Int? = 10
let res = number.map { Double($0) * 2.3 }</pre></div><p class="calibre8">Using <code class="literal">map</code> with optionals can make your code cleaner. Consider the following example, which uses the <code class="literal">map</code>
<a id="id140" class="calibre1"/> function and manual unwrapping optionals:</p><div class="informalexample"><pre class="programlisting">// Using the map function 
let doubled = number.map(double)

// Optional binding 
let doubled: Int?
if let number = number {
  doubled = double(number)
} else {
  doubled = nil
}</pre></div></div></div><div class="book" title="The reduce method"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec20" class="calibre1"/>The reduce method</h3></div></div></div><p class="calibre8">The <code class="literal">reduce</code> method<a id="id141" class="calibre1"/> takes the initial value and the <code class="literal">combine</code> function. It aggregates the result by calling the <code class="literal">combine</code> function for every element in the sequence. The <code class="literal">combine</code> function takes the returned value of a previous call of the <code class="literal">combine</code> function itself or an initial value of the first call and an element of a collection:</p><div class="informalexample"><pre class="programlisting">func reduce(initial: Double, combine: (Double, Int) -&gt; Double) -&gt; Double</pre></div><p class="calibre8">The simplest use case of a <code class="literal">reduce</code> function would be to calculate the sum of a few elements. Its implementation looks like this:</p><div class="informalexample"><pre class="programlisting">{
  var result = initial
  for item in self {
    result = combine(result, item)
  }
  return result
}

let sum = numbers.reduce(0) { acc, number in acc + number }</pre></div><p class="calibre8">You can make this code cleaner by using closures, shorthand argument names, or operator functions:</p><div class="informalexample"><pre class="programlisting">numbers.reduce(0) { $0 + $1 }
numbers.reduce(0, combine: +)</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">+</code> operator is defined <a id="id142" class="calibre1"/>as an operator function and can be used in every place where a function is expected.</p></div><div class="informalexample"><pre class="programlisting">infix operator + {
    associativity left
    precedence 140
}
func +(lhs: Int, rhs: Int) -&gt; Int</pre></div></div><div class="book" title="The filter method"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec21" class="calibre1"/>The filter method</h3></div></div></div><p class="calibre8">The <code class="literal">filter</code> method filters <a id="id143" class="calibre1"/>out elements from the source collection by asking the <code class="literal">includeElement</code> function what elements to keep. The <code class="literal">includeElement</code> function is called for every element in the source collection, and returns a boolean value that indicates whether the element should be kept or removed:</p><div class="informalexample"><pre class="programlisting">func filter(includeElement: (Int) -&gt; Bool) -&gt; [Int]</pre></div><p class="calibre8">The implementation looks like this:</p><div class="informalexample"><pre class="programlisting">{
  var filtered = [Int]()
  for item in self {
    if includeElement(item) {
      filtered.append(item)
    }
  }
  return filtered
}

let evenNumbers = numbers.filter { $0 % 2 == 0 }</pre></div><p class="calibre8">Functional programming is a very<a id="id144" class="calibre1"/> big topic. If you are interested, you can read more about it in <span class="strong"><em class="calibre10">Functional Programming in Swift</em></span> by Chris Eidhof, Florian Kugler, and Wouter Swierstra. You can get it from <a class="calibre1" href="http://www.objc.io/books/">http://www.objc.io/books/</a>.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Generics"><div class="book" id="OPEK2-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Generics</h1></div></div></div><p class="calibre8">Generics are a way <a id="id145" class="calibre1"/>of writing generic, reusable code without specifying a type. You can write a <code class="literal">generic</code> function that may not be limited to one type. It's possible to create <code class="literal">generic</code> functions as well as <code class="literal">generic</code> types that add type restrictions. You have used <code class="literal">generic</code> types in this book even without noticing it.</p><p class="calibre8">The main idea behind generics is that instead of specifying a type, you use a generic type placeholder. Generics are a great tool for removing code duplication and making code reusable.</p><p class="calibre8">The first step is to identify the code that can be generic. The best way to do this is by asking, "Is this functionality limited only to this type or not?" If you realize that it is not, you should consider <a id="id146" class="calibre1"/>making it generic.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip17" class="calibre1"/>Tip</h3><p class="calibre8">Make functions generic only if you need to do so and if you are going to use them with different types. Making them generic could have a slightly negative impact on performance.</p></div><p class="calibre8">Let's create our first simple generic function. Our <code class="literal">printMe</code> function can work only with integers as of now, but it will be great to make it work with all types:</p><div class="informalexample"><pre class="programlisting">func printMe(x: Int) {
  print("Me - \(x)")
}</pre></div><p class="calibre8">To get a generic function or type, you need to specify a generic type parameter in the angle brackets (<code class="literal">&lt;T&gt;</code>) and use that type instead of the actual type:</p><div class="informalexample"><pre class="programlisting">func printMe&lt;T&gt;(x: T) {
  print("Me - \(x)")
}

printMe(10.0)</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip18" class="calibre1"/>Tip</h3><p class="calibre8">The naming convention for type parameters is camel case. In simple cases, where the <code class="literal">generic</code> type doesn't have any special meaning, use the single-character name <code class="literal">T</code>. In complex situations, you can give descriptive names, such as <code class="literal">Key</code> or <code class="literal">Value</code>.</p></div></div>

<div class="book" title="Generics">
<div class="book" title="Generic functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec31" class="calibre1"/>Generic functions</h2></div></div></div><p class="calibre8">The <code class="literal">transform</code> function that we wrote is a great candidate for a <code class="literal">generic</code> function. It doesn't perform any<a id="id147" class="calibre1"/> computation that requires a specific type. The only thing we need to do is use a placeholder type name for the array type and the transform function instead of the <code class="literal">Int</code> type:</p><div class="informalexample"><pre class="programlisting">func transform&lt;T&gt;(array: [T], function: T -&gt; T) -&gt; [T] {
  
  var result = [T]()
  for element in array {
    result.append(function(element))
  }
  return result
}</pre></div><p class="calibre8">Now we can use <a id="id148" class="calibre1"/>our transform function with any type:</p><div class="informalexample"><pre class="programlisting">let numbers = [1, 2, 3]
let increasedNumbers = transform(numbers) { $0 + 1}

let names = ["Jon", "Sara", "Sam"]
let formattedNames = transform(names) { "Name: " + $0 }</pre></div></div></div>

<div class="book" title="Generics">
<div class="book" title="Type constraints"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec32" class="calibre1"/>Type constraints</h2></div></div></div><p class="calibre8">You can't perform any <a id="id149" class="calibre1"/>operations with the variable of the generic type <code class="literal">T</code> because Swift doesn't know anything about that type. If you try to compare two arguments of type <code class="literal">T</code>, Swift will show the following error: <span class="strong"><strong class="calibre9">Could not find and overload '&lt;' that accepts the supplied arguments</strong></span>:</p><div class="informalexample"><pre class="programlisting">func minElem&lt;T&gt;(x: T, _ y: T) -&gt; T {
  return x &lt; y ? x : y
}</pre></div><p class="calibre8">The comparison operator, <code class="literal">&lt;</code>, is defined in the comparable protocol. We need to specify that our generic type <code class="literal">T</code> should conform to the comparable protocol. With a type constraint, you can specify that a type must conform to a protocol or inherit from a class. To do that, you list constraints after the colon (<code class="literal">:</code>) in the generic name definition:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&lt;type parameter : constraint &gt;</strong></span>

func minElem&lt;T : Comparable&gt;(x: T, _ y: T) -&gt; T {
  return x &lt; y ? x : y
}</pre></div><p class="calibre8">Now our <code class="literal">minElem</code> function can work with any type that conforms to the comparable protocol, such as <code class="literal">Int</code> and <code class="literal">String</code>:</p><div class="informalexample"><pre class="programlisting">minElem(10, 20)
minElem("A", "B")</pre></div><p class="calibre8">The great thing about making <code class="literal">minElem</code> a generic function with the <code class="literal">constraint</code> protocol is that it is not limited to only working with existing types. We don't need to make any changes to make it work with a new type. Let's say we want to find the smallest <code class="literal">JournalEntry</code> entity. All that we need to do is make sure that it conforms to the comparable protocol.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre8">The comparable protocol requires two function operators to be implemented in your type: <code class="literal">==</code> and <code class="literal">&lt;</code>:</p><div class="informalexample"><pre class="programlisting">func ==(lhs: Self, rhs: Self) -&gt; Bool
func &lt;(lhs: Self, rhs: Self) -&gt; Bool</pre></div></div><p class="calibre8">Let's say we want to find the smallest <code class="literal">JournalEntry</code> entity. All that we need to do is make sure that it conforms to the comparable protocol:</p><div class="informalexample"><pre class="programlisting">extension JournalEntry : Comparable {
}

func == (lhs: JournalEntry, rhs: JournalEntry) -&gt; Bool {

  return lhs.title == rhs.title &amp;&amp;
    lhs.text == rhs.text &amp;&amp;
    lhs.date == rhs.date
}

func &lt; (lhs: JournalEntry, rhs: JournalEntry) -&gt; Bool {
  return lhs.text &lt; rhs.text
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip19" class="calibre1"/>Tip</h3><p class="calibre8">Conform to a<a id="id150" class="calibre1"/> protocol in a type extension. In this way, you can split the code into functional sections.</p><p class="calibre8">When you conform to protocols in the type declaration, the type declaration becomes hard to read and contains too much information:</p><div class="informalexample"><pre class="programlisting">struct JournalEntry : Comparable, Hashable, CustomStringConvertible { 
...
}</pre></div></div><p class="calibre8">Now, we can create two <code class="literal">JournalEntry</code> entities and call a <code class="literal">minElem</code> function. The <code class="literal">minElem</code> function will use the <code class="literal">&lt;</code> operator function to compare two journal entries:</p><div class="informalexample"><pre class="programlisting">let walking = JournalEntry(title: "Walking", text: "It was a great weather")
let goal = JournalEntry(title: "Read", text: "Read a book")
let smaller = minElem(walking, goal)</pre></div></div></div>

<div class="book" title="Generics">
<div class="book" title="The generic type and collections"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec33" class="calibre1"/>The generic type and collections</h2></div></div></div><p class="calibre8">Another great use case for <a id="id151" class="calibre1"/>generics is to make a generic type. <code class="literal">Array</code>, <code class="literal">Dictionary</code>, and <a id="id152" class="calibre1"/>
<code class="literal">Set</code> are implemented as generic types:</p><div class="informalexample"><pre class="programlisting">struct Array&lt;T&gt; ...
struct Dictionary&lt;Key : Hashable, Value&gt; ...
struct Set&lt;T : Hashable&gt; ...</pre></div><p class="calibre8">This gives us the ability to store any type in collections and make them single-type collections. This means that we can't store the wrong type in them:</p><div class="informalexample"><pre class="programlisting">var numbers = [1, 2, 3] // [Int]
numbers.append(10)
numbers.append("Name") //Error, Can't add String to [Int] array</pre></div><p class="calibre8">You can make your own your custom generic types. The rules are the same as for declaring a generic function; you specify a generic type in angular brackets, and use it everywhere as a type<a id="id153" class="calibre1"/> name. As an example, we can make our own simple generic stack<a id="id154" class="calibre1"/> like this:</p><div class="informalexample"><pre class="programlisting">struct Stack&lt;T&gt; {
  private var items: [T]
  
  mutating func push(item: T) {
    items.append(item)
  }
  
  mutating func pop() -&gt; T {
    return items.removeLast()
  }
  
  init() {
    items = []
  }
}

var s = Stack&lt;Int&gt;()
s.push(10) // 10
//s.push("Name") // Error
s.push(4)  // 10, 4
s.pop()    // 10</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Safety" id="PNV61-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>Safety</h1></div></div></div><p class="calibre8">Swift is designed for safety. It eliminates many issues of compile time. Here is a list of things that Swift <a id="id155" class="calibre1"/>handles for you:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Type safety</strong></span>: Swift is <a id="id156" class="calibre1"/>very strongly typed language. If a function has the <code class="literal">Int</code> parameter, you must pass <code class="literal">Int</code> as an argument when you call it. This rule also applies to operators. Swift doesn't allow use of the wrong type:<div class="informalexample"><pre class="programlisting">func increase(x: Int) -&gt; Int {
  return x + 1
}

let x = 10
let percent = 0.3
let name = "Sara"

x + name //Error, can't apply + operator for Int and String
x * percent //Error, can't apply * to Int and Double
Double(x) * percent // 3

increase(x) // 11
increase(percent) // Wrong type
increase(name) // Wrong type</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre9">Variables must always be initialized before use</strong></span>: Accessing non-initialized memory is a dangerous <a id="id157" class="calibre1"/>operation. Swift handles this problem in a very nice and safe way. It doesn't compile when you try to do that:<div class="informalexample"><pre class="programlisting">var y: Int
//y + 10 //Error, variable 'y' used before being initialized
y = 1
y + 10</pre></div><p class="calibre24">Constant values can't be changed after they have been set, but you can declare a constant without setting an initial value and set it later:</p><div class="informalexample"><pre class="programlisting">let z: Int

if y == 2 {
  z = 10
} else {
  z = 0
}
z + 10</pre></div><p class="calibre24">If you remove the <code class="literal">else</code> case, the Swift compiler will show an error, because in these cases, <code class="literal">z</code> won't be initialized when <code class="literal">y != 2</code>.</p></li><li class="listitem"><span class="strong"><strong class="calibre9">Safe nil handling</strong></span>: As <a id="id158" class="calibre1"/>you have seen already Swift has an optional type for safe nil handling and absence-of-value handling.</li></ul></div></div>

<div class="book" title="Safety" id="PNV61-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Dangerous operations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec34" class="calibre1"/>Dangerous operations</h2></div></div></div><p class="calibre8">There are still situations <a id="id159" class="calibre1"/>where we should be careful, because we could make an<a id="id160" class="calibre1"/> error and cause the application to crash. Here's a list of these situations:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Implicitly unwrapping optionals</strong></span>: Unwrapping<a id="id161" class="calibre1"/> an optional (the <code class="literal">!</code> operator) is a potentially dangerous operation. You should do it only when you have verified that the optional has a value. It is, in fact, better to use optional binding.<p class="calibre24">Using the implicitly unwrapped optional is also a very dangerous operation. They behave like non-optional types (which do not require unwrapping<a id="id162" class="calibre1"/> before accessing a value), but they cause a crash when used with the <code class="literal">nil</code> value:</p><div class="informalexample"><pre class="programlisting">var x: Int?
x! + 10 // Crash! Unwrapping optional that does not have value.

var y: Int!
y + 10 // Crash! Implicitly unwrapped optional has nil value.</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre9">Type casting</strong></span>: There are situations where you would like to store any object of a base class object <a id="id163" class="calibre1"/>and check later on whether that object actually has a specific type. You can safely check for the type of an object with the <code class="literal">is</code> keyword:<div class="informalexample"><pre class="programlisting">var view: UIView = UIImageView()
if view is UIImageView {
  print("yes")
} else {
  print("no")
}</pre></div><p class="calibre24">Often, you not only need to check whether the variable is of a certain type, but also need to cast it to the corresponding type. You can do this in two ways: safe and unsafe. You should always use the safe way.</p><p class="calibre24">Unsafe casting is very similar to unwrapping optionals. It tries to do casting without checking whether it's possible, and this could lead to a crash:</p><div class="informalexample"><pre class="programlisting">let imageView = view as! UIImageView</pre></div><p class="calibre24">Safe casting is like optional binding. First, it checks whether a view is actually a <code class="literal">UIImageView</code> type, and then it performs casting. Finally, it saves the cast result in a <code class="literal">view</code> constant:</p><div class="informalexample"><pre class="programlisting">if let view = view as? UIImageView {
  view.image = UIImage(named: "image")
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip20" class="calibre1"/>Tip</h3><p class="calibre8">Always use safe<a id="id164" class="calibre1"/> casting!</p></div></li><li class="listitem"><span class="strong"><strong class="calibre9">Unsafe types and operations</strong></span>: You will find many types and methods in Swift's standard library that start with the word<code class="literal"> Unsafe*</code>. Those are particularly<a id="id165" class="calibre1"/> dangerous operations, and you can understand this from their names. Usually, you would use unsafe types to work with C functions. Let's see an example of the <code class="literal">count</code> function in C, which takes the pointer to <code class="literal">Int</code> as an argument:<div class="informalexample"><pre class="programlisting">int count(int *a); // C function</pre></div><p class="calibre24">The count function in C would be available in Swift with this type:</p><div class="informalexample"><pre class="programlisting">count(a: UnsafeMutablePointer&lt;Int32&gt;)</pre></div><p class="calibre24">You don't need to make an <code class="literal">UnsafeMutablePointer&lt;32&gt;</code> variable. You can pass an <code class="literal">Int32</code> Swift variable as an in-out parameter by reference:</p><div class="informalexample"><pre class="programlisting">var x: Int32 = 10
count(&amp;x)</pre></div><p class="calibre24">You can also directly manipulate the pointer's memory, but this is a very dangerous operation and it should be avoided:</p><div class="informalexample"><pre class="programlisting">let pointer = UnsafeMutablePointer&lt;Int&gt;.alloc(1)
pointer.memory = 10
pointer.memory // store Int value - 10
pointer.dealloc(1)</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip21" class="calibre1"/>Tip</h3><p class="calibre8">Avoid using unsafe types. The only use case is for interacting with the C function and core foundation.</p></div></li><li class="listitem"><span class="strong"><strong class="calibre9">Accessing arrays' elements</strong></span>: Although working with arrays is safe, it has an unsafe operation<a id="id166" class="calibre1"/> that you should be aware of—accessing an element beyond its range. As an example, let's create an array with three elements. Swift still allows us to try to access an element at index 10, which will lead to a crash. Swift does check the array bounds and does not allow us to use or update the memory outside the array. This prevents memory corruption issues, but it does not prevent the application from crashing:<div class="informalexample"><pre class="programlisting">let numbers = [1, 2, 3]

numbers.count
numbers[1]
numbers[10] //Crash</pre></div><p class="calibre24">For safety, check<a id="id167" class="calibre1"/> bound arrays before accessing an element:</p><div class="informalexample"><pre class="programlisting">if numbers.count &gt; 10 {
  numbers[10]
}</pre></div></li></ul></div></div></div>
<div class="book" title="Summary" id="QMFO1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we covered some of the most important and powerful features of Swift. Now you should be confident to use them. Also, this chapter gave you some advice on how to use these features and create solid applications.</p><p class="calibre8">In the next chapter, you will learn different debugging techniques that will help identify slow code. As you have already learned, it's very important to identify what causes performance issues before doing any optimization.</p></div></body></html>