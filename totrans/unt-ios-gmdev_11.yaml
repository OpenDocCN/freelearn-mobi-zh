- en: Chapter 11. Debugging and Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a nearly completed project it's time to start working on getting
    as much performance out of the system as possible. While we would normally address
    performance throughout the development process, I felt it was important to look
    at the project further along, so that we could see how to reengineer the product
    based on some questionable decisions we might have made earlier in the project.
    By doing it this way it will be possible to see these decisions within the context
    of how we might normally build an application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about debugging options in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to profile a mobile application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about object pooling and why it's crucial on mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to optimize lighting with Beast Lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is where we will highlight some of the key differences between
    making a game for Unity and making one for Unity on a mobile device. This chapter
    will make the biggest difference between our application being a hit and it just
    bring a pretty showpiece that people uninstall a few hours after launching it.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity possesses a debugger that is a first-class citizen with the rest of the
    Unity platform. The debugger will allow you to put breakpoints directly in your
    Unity scripts, and while the game is running on the target device, allow you to
    pause the game's execution to enable observation or tweaking of variables. This
    is a very powerful approach that is often times missing when developing for a
    device. In the past, the best one could do is emit sounds or change screen colors
    when certain conditions were met. Today you can watch the values of variables
    change, make modifications to scripts that are executing on the device, and change
    the flow of execution of the game dynamically without much impact to the game's
    frame rate. So let's take a look at how we make this magic happen.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a running application on real hardware is something that you need
    to be very comfortable with. While Unity can do an admirable job of helping you
    simulate your content on your Mac, there is nothing that beats knowing how your
    application will perform in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: A breakpoint is a place in your game where you want to pause the execution of
    the application for debugging purposes. As the Unity scripting environment, MonoDevelop,
    is integrated with the Unity IDE, and consequently the runtime, we can insert
    breakpoints in our scripts, which will trigger the pause in execution.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Using breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Position the carat on the line that you want to pause execution on and use the
    hotkey combination **Apple-\** to create the breakpoint. For many keyboard-centric
    developers this is the preferred way of doing things.![Time for action — Using
    breakpoints](img/0409_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other method is to click on the spine area to the left of the code and line
    numbers. If you are more a mouse-centric developer, you will find this to be the
    more natural way for setting breakpoints.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Time for action — Using breakpoints](img/0409_11_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Observe that the line that you created the breakpoint on is highlighted with
    a red circle in the spine next to the code. This represents an active breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To deactivate a breakpoint, simply click on the red circle or press **Apple-\**
    again and the breakpoint will be removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It should be noted that if you create a breakpoint on a line that contains no
    actual code, the break point would actually execute on the next line of executable
    code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Using breakpoints](img/0409_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now observe that the application stops on the line where the breakpoint
    was located. This gives us an opportunity to observe the state of the application
    at the time when the breakpoint is reached. Many times it is useful to put a breakpoint
    inside of some control structure, such as an `if` statement, to see if the conditions
    which should trigger it are ever met.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have just created a breakpoint within your application and had your app
    stop on the line specified. When the application is in this state it is paused
    so that you can examine and/or change the state of any variables of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Debugging the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of getting the debugger to communicate with the running application
    and provide data to the user is known as attaching the debugger to the process.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy and run your game on your iOS device. Make sure that the device is on
    the same WiFi network as the machine that will be doing the debugging and then
    select the iOS device that you want to attach to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Debug** button in the toolbar:![Time for action — Debugging the
    application](img/0409_11_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'MonoDevelop will then launch the Unity editor and after some time start the
    execution of your application. Your application will begin running in the player
    and stop when the first breakpoint in your code is encountered:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Time for action — Debugging the application](img/0409_11_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Select the game that you want the Unity debugger to attach itself to. In this
    image we see the Unity Editor as one process we can attach to and another referred
    to as "null (mono)." This is your game running on your iOS device. Select this
    instance of your game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just attached our debugger to an instance of our game that is running
    on our iOS device. This is very useful as we can get real debugging information
    from our actual device. When testing an application it is important to do this,
    as there will be times when an application will run fine within Unity on the PC,
    yet fail on an actual device.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Stepping through the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have reached a breakpoint and examined variable values at that point,
    the next thing you will want to do is step forward in the application so you can
    watch the application change over time. There are several options available to
    you for stepping forward through the application depending on what your intentions
    are. The following screenshot shows these options: **Step Over, Step Into, Step
    Out, Pause**, and **Detach Debugger:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Stepping through the game](img/0409_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Press the Step into icon so that the application will start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see below, the application is paused at the breakpoint. The current
    line of execution is highlighted in yellow:![Time for action — Stepping through
    the game](img/0409_11_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned earlier, when the debugger is attached, you can get the value of
    any variable in your game. However, it would be cumbersome to have to constantly
    look for each individual variable, especially if there is a variable that we want
    to examine over time. You can accomplish this by setting up a watch for a variable
    of interest and observe its value as it changes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new watch by selecting the **Watch** tab in MonoDevelop. Enter the
    word **Screen** into the **Watch** tab to have MonoDevelop open an autocomplete
    dialog showing all of the attributes of the **Screen** object:![Time for action
    — Stepping through the game](img/0409_11_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see here that **Screen** has a **currentResolution** attribute attached
    to it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select **currentResolution** so that a watch is created for this variable.
    If the variable you''ve selected is an object, you will see a triangle to the
    left of it. Clicking on this triangle will display any attributes of the object
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Stepping through the game](img/0409_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we are able to see all of the attributes of the **Screen.currentResolution**
    object.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just stepped through our application using the attached debugger and
    added a watch so that we can observe a variable as it changes over time. Adding
    watches is a common way to examine variables as they change during the execution
    of the game. As you begin writing complex scripts, creating watches will help
    you determine whether or not the correct behaviors are happening at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been going along building our game and running it for sometime and it
    appears to be performing okay, but to really determine how our game is performing,
    we are going to have to profile. Profiling is the act of gathering information
    about how each part of our game is performing so that we can optimize the code
    or assets that are causing performance bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: We could make some assumptions about how the game is running and start blindly
    optimizing code because it should be faster to do it a certain way, but in reality,
    the biggest performance wins won't be obvious until you see what the profiler
    is telling you about the game. To successfully profile an application one has
    to really look at the data objectively as poor performance could result from texture
    sizes, shaders, scripts, physics, draw calls, or even something as simple as adding
    fog.
  prefs: []
  type: TYPE_NORMAL
- en: So let's go through our current application and walk through the process of
    profiling it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Fine tuning the application (Pro Versions)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're going to take our application and tune it so that it performs well,
    and has consistent behavior, regardless of where we are in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Start the Profiler by selecting it from the **Window** menu **(Window | Profiler):**![Time
    for action — Fine tuning the application (Pro Versions)](img/0409_11_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The profiler will start and display the profiling interface for Unity. If you
    are familiar with the XCode tool Instruments you will find many of the same design
    and interface concepts in the Unity profiler:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Time for action — Fine tuning the application (Pro Versions)](img/0409_11_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Profiler** will display metrics across a range of different settings:
    **CPU Usage, Rendering, Memory, Audio**, and **Physics**. You can remove profilers
    by clicking on the X in the upper-left corner of the **Profiler.**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the **Audio** profiler by clicking on the X in the upper-left corner
    of the **Profiler:**![Time for action — Fine tuning the application (Pro Versions)](img/0409_11_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **Audio** profiler back by clicking on the **Add Profiler** drop-down
    and selecting the **Audio** profiler:![Time for action — Fine tuning the application
    (Pro Versions)](img/0409_11_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The profilers that are already added will be greyed out. In this example both
    **Audio** and **Physics** can be added to the **Profiler.**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start the game by pressing the **Play** button. Immediately you will see the
    profiler fill with data from the profiling session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Fine tuning the application (Pro Versions)](img/0409_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the build in Unity profiler to examine the performance of our application
    and explore the different metrics that it is returning so that we can gain some
    insight to the bottlenecks in our application. Now that we've done this we can
    identify some hot spots and look at a few ways to fix the issues that we uncover.
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling — Into the pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have learned from our profiling session, one of the largest performance
    detriments on the mobile platforms is the constant creation and destruction of
    GameObjects. As you probably noticed earlier when we were testing out firing our
    weapons, there were noticeable pauses in the game every so often. Let's examine
    why this happens.
  prefs: []
  type: TYPE_NORMAL
- en: When an instance of the class `GameObject` is created in Unity on a mobile device,
    the device must allocate memory for this new instance of `GameObject` and potentially
    clear out memory that is used by some other object that may not be visible. This
    process, known as garbage collection, takes just enough time that it causes the
    pauses that you experience in the game. The reason this happens is due to the
    limited amount of memory available on the target devices and the time it takes
    to collect the old object. Java developers, particularly those that were brave
    enough to write games for the platform, are very familiar with the issues associated
    with garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, one will resolve some of the issues associated with garbage collection
    through the use of an object pool. An object pool allows one to allocate a number
    of objects up front and cycle through them such that new objects are never created.
    In the case of our weapon example we would allocate a number of objects in our
    game object pool that represent the max number of projectiles we want to be able
    to display at one time. As projectiles reach a certain distance from the player,
    we can remove them and free up a new object in the object pool for objects that
    are going to be visible next.
  prefs: []
  type: TYPE_NORMAL
- en: This particular implementation of an object pool was created by the Unity3D
    forum member and has an extension for particle systems as well as audio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `ObjectPool` code is very straight-forward. It exposes several public variables
    so that you can configure it from the Unity IDE itself. The `ObjectPool` implemented
    here is designed to pool a variety of classes of objects at once. You don't need
    an implementation for each type of `GameObject` you want to pool. The **ObjectPool**
    stores each of the object types you want to pool in the `ObjectPrefabs` array.
  prefs: []
  type: TYPE_NORMAL
- en: '![Object pooling — Into the pool](img/0409_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By default the pool will create a maximum of three objects of each type. If
    you want to configure the amount of objects that an individual object can have,
    expand the **Amount To Buffer** element and set that size.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Optimizing with the object pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a game object pool and the ability to profile our application
    we can look at how this optimization improves our application's performance. We
    will do this by replacing the `GameObject` instantiation approach that we took
    to creating projectiles when the player fires his weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the game to the profiler following the previous *Time for action —*
    and run it, firing a large number of projectiles:![Time for action — Optimizing
    with the object pool](img/0409_11_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we can see from this object profile is that performance dips considerably
    when the weapon is fired. The reason for this is because we are creating GameObjects
    on the fly. We can see here that when these objects are removed from view and
    collected, the performance of the application becomes more consistent. Things
    like this are a smoking gun and we have an optimization that can be made to improve
    performance of the game.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a **GameObject** called **PoolManager:**![Time for action — Optimizing
    with the object pool](img/0409_11_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **ObjectPool** script to the **PoolManager:**![Time for action — Optimizing
    with the object pool](img/0409_11_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the prefabs that you want to pool to the **Object Prefabs** array. You can
    accomplish this by dragging a prefab from the **Hierarchy** view onto the **Object
    Prefabs** array:![Time for action — Optimizing with the object pool](img/0409_11_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the existing `fireWeapon` script with the optimized `fireWeapon` script
    that uses the **Object Pool:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What we have done here is replace the `GameObject.Instantiate()` method that
    we were originally using for creating new bullets from our weapon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the game again and look at the **Profiler** profile. Fire a lot of projectiles
    and examine the performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just improved the performance of our application using object pooling.
    As you can see, the performance of the application is consistent now. This is
    what we are aiming for a consistent frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of paying the penalty for creating and deleting large numbers of `GameObject`
    instances, we are instead creating a pool of those objects and simply changing
    their position, rotation, state, and visibility. This is an old trick that was
    frequently employed in gaming that was lost in the age of modern computers and
    graphics capabilities, but is just what we need on mobile devices to ensure optimal
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Unleash the beast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So often when you're trying to improve the performance of your application you
    will have to make trade-offs between the visual presentation of your application
    and its performance. This time we will perform optimizations that will enhance
    both the performance and visual quality of our application is by using the integrated
    Beast lightmapping system from Illuminate Labs.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of lighting in our game is to provide a realistic depiction of our
    world. Normally the objects in the world would have some base material or texture
    that describes their natural surface. The lighting algorithms used by the engine
    would then compute the effects of the lights on the pixels or texels of the object's
    surface when it is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Lightmapping, as its name implies, is the process of utilizing lighting data
    (emissive properties, real lights, and so on) and casting rays from these lights
    as if they were active in the scene. The engine will then take the actual effect
    of these lights and store it in texture maps that will be mapped onto textures
    at run time (Unity refers to this process as baking the lights). As a result you
    can have a very complex lighting environment based upon a computationally intensive
    number of lights. You can also have all of this information baked into the texture
    maps of the scene, resulting in increased visual quality without the expense of
    having lights within your scene.
  prefs: []
  type: TYPE_NORMAL
- en: As lighting is one of the more expensive operations you can perform on mobile
    devices, using lightmaps represents a major performance win. While lightmapping
    will eventually be replaced with per pixel lighting in shaders, today's mobile
    hardware isn't quite up to the task.
  prefs: []
  type: TYPE_NORMAL
- en: So let's look at how we can make this work for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Generating Beast lightmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate how lightmapping can improve our application we're going to take
    our City level scene and add Beast lightmapping to it.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in preparing our scene for lightmapping is to ensure that any
    object that we want to have lightmaps generated for is declared static. Unity
    uses this declaration to make assumptions that the object won't move, scale, or
    change in any way during the scene. Remember, we only want to bake lightmaps on
    static geometry, as we're generating lighting based on the location of lights
    in the scene at a given time. If we tried to use this approach on objects that
    moved, for example, you'd find that even though an object changes its orientation
    with respect to a light, the lighting and shadow calculations would look as if
    the object were in a different place:![Time for action — Generating Beast lightmaps](img/0409_11_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we have specified that one of our birch tree prefabs is **Static**. Similarly
    we can add the same settings to the terrain.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a light to the scene using **Game Object | Create Other | Point Light**.
    Position this light in our scene. This is the light whose lighting effects we
    want to bake into our scene. Now that our objects are defined as being static,
    let's add a light to the scene that we want to bake to our objects:![Time for
    action — Generating Beast lightmaps](img/0409_11_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the scene to see what everything looks like when the lighting is rendering
    normally. This will give us an idea of what the lightmapped scene should look
    like if we perform the operation properly:![Time for action — Generating Beast
    lightmaps](img/0409_11_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've provided some lighting data for the lightmapper to work with,
    we can start the baking process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Window** menu select the **Lightmapping** option to bring up the Beast
    lightmapping interface:![Time for action — Generating Beast lightmaps](img/0409_11_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will open the Unity Lightmapping interface which allows us to configure
    the Beast lightmapping session:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Time for action — Generating Beast lightmaps](img/0409_11_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: With the interface is open, select the **Point light** we added to the scene
    and click on the **Bake** tab:![Time for action — Generating Beast lightmaps](img/0409_11_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can take our simple light and have it baked into the lightmaps of the scene.
    Press the **Bake** button and observe the debug output window:![Time for action
    — Generating Beast lightmaps](img/0409_11_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output window is telling us that it is unable to bake the lights because
    there is no UV data for the geometry in our scene. Remember that our lightmaps
    are texture maps that are being added as a texture map and, as such, if the geometry
    does not have UVs generated properly it cannot generate the lightmaps.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the geometry that Unity is reporting does not have UV data and select
    its **FBXImporter**. Click on the **Generate Lightmap UVs** button to ensure that
    Unity generates the UV information for this piece of geometry:![Time for action
    — Generating Beast lightmaps](img/0409_11_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when you bake the scene, Unity will be able to generate a properly lightmapped
    scene.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the **Point light** in the **Hierarchy** view and delete it from the
    scene. When you run the game you will note that the game looks exactly the same
    as it did before but it is now running without the performance overhead of the
    lights in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What Unity is doing behind the scenes is taking all of the assets and scripts
    from the Unity IDE and putting together a player that will be able to playback
    the content and all of its scenarios based on input from the user. This is a very
    important concept to understand as the content within the Unity IDE is largely
    platform agnostic and can be readily redeployed after a simple recompile within
    the Unity environment. This player is the the actual application that is deployed
    to the iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned a little bit about the topic of debugging, profiling
    and optimizing Unity projects. We've really only just scratched the surface on
    the subject, however, as game optimization can fill a book in its own right and
    much of it is related to the design of a particular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How to attach the Unity debugger to a running application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to profile a Unity application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using object pooling to improve mobile application performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Beast lightmapping to improve performance and visual quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've profiled our application and worked specifically to improve its
    performance it's time to investigate monetization of our game and publish it on
    the AppStore.
  prefs: []
  type: TYPE_NORMAL
