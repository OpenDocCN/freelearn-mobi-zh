- en: Chapter 4. Control Flow and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While I was learning BASIC programming on my Vic-20, every month I would read
    several of the early computer magazines such as *Byte Magazine*. I remember one
    particular review that I read; it was for a game called *Zork*. While *Zork* was
    not a game that was available for my Vic-20, the concept of the game fascinated
    me because I was really into Sci-Fi and fantasy. I remember thinking how cool
    it would be to write a game like that, so I decided to figure out how to do it.
    One of the biggest concepts that I had to grasp at that time was controlling the
    flow of the application depending on the user's actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are conditional statements and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are loops and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are control transfer statements and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create and use functions in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we have learned so far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have been laying the foundation for writing applications
    with Swift. While it is possible to write a very basic application with what we
    have learned so far, it would be really difficult to write a useful application
    using only what we covered in the first three chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with this chapter, we will begin to move away from the foundations
    of the Swift language, and begin to learn the building blocks of application development
    with Swift. In this chapter, we will go over control flow and functions. To become
    a master of the Swift programming language, it is important that you fully understand
    and comprehend the concepts discussed in this chapter and in [Chapter 5](ch05.html
    "Chapter 5. Classes and Structures"), *Classes and Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we cover control flow and functions, let's take a look at how curly brackets
    and parentheses are used in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Curly brackets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Swift, unlike other C-like languages, curly brackets are required for conditional
    statements and loops. In other C-like languages, if there is only one statement
    to execute for a conditional statement or a loop, the curly brackets around that
    line are optional. This has lead to numerous errors and bugs, such as Apple''s
    `goto fail` bug; therefore, when Apple was designing Swift, they decided to use
    curly brackets, even when there is only one line of code to execute. Let''s look
    at some code that illustrates this. This first example is not valid in Swift because
    it is missing the curly brackets; however, it will be valid in most other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, you are required to have the curly brackets, as illustrated in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Parentheses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike other C-like languages, the parentheses around conditional expressions
    in Swift are optional. In the preceding example, we put parentheses around the
    conditional expression, but they are not required. The following example would
    be valid in Swift, but not valid in most C-like languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control flow, also known as flow of control, refers to the order in which statements,
    instructions, or functions are executed within an application. Swift supports
    all of the familiar control flow statements that are in C-like languages. These
    include loops (including `for` and `while`), conditional statements (including
    `if` and `switch`) and the transfer of the control statements (including `break`
    and `continue`). In addition to the standard C control flow statements, Swift
    has also added additional statements, such as the `for-in` loop, and enhanced
    some of the existing statements, such as the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by looking at conditional statements in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A conditional statement will check a condition and execute a block of code only
    if the condition is true. Swift provides both the `if` and `if-else` conditional
    statements. Let's take a look at how to use these conditional statements to execute
    blocks of code if a specified condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if` statement will check the conditional statement and if it is true,
    it will execute the block of code. The `if` statement takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how to use the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we begin by setting the `teamOneScore` and `teamTwoScore`
    constants. We then use the `if` statement to check whether the value of `teamOneScore`
    is greater than the value of `teamTwoScore`. If the value is greater, we print
    `Team One Won` to the console. If we run this code, we will indeed see that `Team
    One Won` is printed to the console, but if the value of `teamTwoScore` was greater
    than the value of `teamOneScore`, nothing would be printed to the console. That
    would not be the best way to write an application because we would want the user
    to know which team actually won. The `if-else` statement can help us with this
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional code execution with the if-else statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if-else` statement will check the conditional statement and if it is true,
    it will execute a block of code. If the conditional statement is not true, it
    will execute a separate block of code. The `if-else` statement follows this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify the preceding example to use the `if-else` statement to tell
    the user which team won:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This new version will print out `Team One Won`, if the value of `teamOneScore`
    is greater than the value of `teamTwoScore`; otherwise, it will print out the
    message, `Team Two Won`. What do you think the code will do if the value of `teamOneScore`
    was equal to the value of `teamTwoScore`? In the real world, we will have a tie,
    but in the preceding code, we will print out `Team Two Won`; this would not be
    fair to team one. In cases like this, we can use multiple `else if` statements
    and a plain `else` statement, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if the value of `teamOneScore` is greater than the value
    of `teamTwoScore`, we print `Team One Won` to the console. We then have another
    `if` statement that checks to see whether the value of `teamTwoScore` is greater
    than the value of `teamOneScore`, but this `if` statement follows an `else` statement,
    which means the `if` statement is checked only if the previous conditional statement
    is false. Finally, if both the `if` statements were false, then we assume that
    the values are equal and print `We have a tie` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: A conditional statement checks the condition once, and if the condition is met,
    it executes the block of code. What if we wanted to continuously execute the block
    of code until a condition is met? For this, we would use one of the looping statements
    that are in Swift. Let's take a look at looping statements in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: The for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The for loop variants are probably the most widely used looping statements.
    Swift offers the standard C-based for loop and also an extra `for-in` loop. The
    standard C-based `for` loop executes a block of code until a condition is met,
    usually by incrementing or decrementing a counter. The `for-in` statement will
    execute a block of code for each item in a range, collection, or sequence. We
    usually use one of the for loop variants when we need to iterate over a collection,
    or have a set number of times we want to execute a block of code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the for loop variant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s begin by looking at the standard C-based `for` loop and how we would
    use it. The format for the `for` statement looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding format, the `for` loop has three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Initialization`: This is where we initialize any variables needed; this can
    contain multiple initializations, separated by commas, if needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Condition`: This is the condition to check; when the condition is false, the
    loop will exit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update-rule`: This is what needs to be updated at the end of each loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand the order in which the sections are called. When
    the execution of the code encounters a `for` loop, the initialization section
    of the `for` loop is called to initialize the variables. Next, the condition section
    is executed to verify whether the block of code should be executed, and, if so,
    it will execute the block of code. Finally, the update-rule is called to perform
    any updates before looping back and starting over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use the `for` loop to go through a range
    of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `index` variable is initialized to the number
    `1`. At the beginning of each loop, we check whether the `index` variable is equal
    to or less than number `4`. If the `index` variable is equal to or less than number
    `4`, the inner block of code is executed, and this prints the value of the `index`
    variable to the console. Finally, we increment the `index` variable before looping
    back and starting over. Once the index variable is greater than `4`, the `for`
    loop exits. If we run the preceding example, the numbers `1` through `4` will
    indeed be printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common uses of a `for` loop is to iterate through a collection
    and perform a block of code for each item in that collection. Let''s look at how
    to loop through an array, followed by an example of how to loop through a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we begin by initializing the `countries` array with
    the abbreviations of three countries. In the `for` loop, we initialize the `index`
    variable to `0` (the first index of the array), and in the condition statement
    of the `for` loop, we check whether the index variable is less than the number
    of elements in the `countries` array. Each time we loop, we retrieve and print
    the value from the `countries` array at the index specified by the `index` variable.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest mistakes that new programmers make when they use a `for`
    loop to iterate through an array is to use the less than or equal to (`<=`) operator
    rather than the less than (`<`) operator. Using a less than or equal to (`<=`)
    operator would cause one too many iterations through the loop and generate an
    `Index out of Bounds` exception when the code is run. In the preceding example,
    a less than or equal to operator will generate a count from 0 to 3 inclusively
    because there are three elements in the array; however, the elements in the array
    have indexes from 0 to 2 (0, 1, and 2). So, when we try to retrieve the value
    at index `3`, the `Index out of Bounds` exception will be thrown. It is recommended
    to use a `for-in` loop to iterate through an array rather than a standard `for`
    loop. We will look at the `for-in` loop a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would iterate through a dictionary with a standard C-based
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we begin by creating a dictionary object that contains
    country names as the values with their abbreviations as the keys. We then use
    the `keys` property of the dictionary to get an array of keys. In the `for` loop,
    we initialize the `index` variable to `0`, verify whether the `index` variable
    is less than the number of elements in the countries array, and increment the
    `index` variable at the end of each loop. Each time we loop, we print the country's
    name to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how to use the `for-in` statement and how it can help prevent
    common mistakes that occur when we use the standard `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using the for-in loop variant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the standard `for` loop, we provide an index and then loop until a condition
    is met. While this approach is very good, when we want to loop through a range
    of numbers, it can cause bugs, as mentioned earlier, if our conditional statements
    are not correct. The `for-in` loop is designed to prevent these types of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for-in` loop iterates over a collection of items or a range of numbers
    and executes a block of code for each item in the collection or range. The format
    for the `for-in` statement looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the `for-in` loop has two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Variable`: This variable will change each time the `for-in` loop executes
    and hold the current item from the collection or range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection/Range`: This is the collection or range to iterate through'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to use the `for-in` loop to iterate through a range
    of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we iterate over a range of numbers from `1` to `5`
    and print each of the numbers to the console. This particular `for-in` statement
    uses the closed range operator (`…`) to give the `for-in` loop a range to go through.
    Swift also provides a second range operation called the half-open range operator
    (`..<`). The half-open range operator iterates through the range of numbers, but
    does not include the last number. Let''s look at how to use the half-range operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the closed range operator example (`…`), we will see the numbers `1` though
    `5` printed to the console. In the half-range operator example, the last number
    (`5`) will be excluded; therefore, we will see the numbers `1` though `4` printed
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to iterate over an array with the `for-in` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we iterate through the `countries` array and print
    each element of the `counties` array to the console. As we can see, iterating
    through an array with the `for-in` loop is safer, cleaner, and a lot easier than
    using the standard C-based `for` loop. Using the `for-in` loop prevents us from
    making common mistakes, such as using the `<=` (less than or equal too) operator
    rather than the `<` (less than) operator in our conditional statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to iterate over a dictionary with the `for-in` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used the `for-in` loop to iterate through each
    key-value pair of a dictionary. In this example, each item in the dictionary is
    returned as a (key,value) tuple. We can decompose (key,value) tuple members as
    named constants within the body of the `for-in` loop. One thing to note is that
    since a dictionary does not guarantee the order that items are stored in, the
    order that they are iterated over may not be the same as the order they were inserted
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another type of loop, the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `while` loop executes a block of code until a condition is met. Swift provides
    two forms of `while` loops; these are the `while` and `repeat-while` loops. In
    Swift 2.0, Apple replaced the `do-while` loop with the `repeat-while` loop. The
    `repeat-while` loop functions exactly as what the `do-while` loop did. Apple now
    uses the `do` statement for error handling.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `while` loops when the number of iterations to perform is not known
    and is usually dependent on some business logic. A `while` loop is used when you
    want to run a loop zero or more times, while a `repeat-while` loop is used when
    you want to run the loop one or more times.
  prefs: []
  type: TYPE_NORMAL
- en: Using the while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop starts by evaluating a conditional statement and then repeatedly
    executes a block of code if the conditional statement is true. The format for
    the `while` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at how to use a `while` loop. In the following example, the `while`
    loop will continue to loop if a randomly-generated number is less than `4`. In
    this example, we are using the `arc4random()` function to generate a random number
    between `0` and `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we begin by initializing the `ran` variable to `0`.
    The `while` loop then checks the `ran` variable, and if its value is less than
    `4`, a new random number, between `0` and `4`, is generated. The `while` loop
    will continue to loop while the randomly-generated number is less than `4`. Once
    the randomly-generated number is equal to or greater than `4`, the `while` loop
    will exit.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `while` loop checks the conditional statement
    prior to generating a new random number. What if we did not want to check the
    conditional statement prior to generating a random number? We could generate a
    random number when we first initialize the `ran` variable, but that would mean
    we would need to duplicate the code that generates the random numbers, and duplicating
    code is never an ideal solution. It would be preferable to use the `repeat-while`
    loop for such instances.
  prefs: []
  type: TYPE_NORMAL
- en: Using the repeat-while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The difference between the `while` and `repeat-while` loops is that the `while`
    loops check the conditional statement prior to executing the block of code the
    first time; therefore, all the variables in the conditional statements need to
    be initialized prior to executing the `while` loop. The `repeat-while` loop will
    run through the loop block prior to checking the `conditional` statement for the
    first time; this means that we can initialize the variables in the conditional
    block of code. Use of the `repeat-while` loop is preferred when the conditional
    statement is dependent on the code in the loop block. The `repeat-while` loop
    takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at this specific example by creating a `repeat-while` loop
    where we initialize the variable we are checking, in the conditional `while` statement,
    within the loop block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we define the `ran` variable as an `Int`, but we do
    not initialize it until we enter the loop block and generate a random number.
    If we try to do this with the `while` loop (leaving the `ran` variable uninitialized),
    we will receive a `Variable used before being initialized` exception.
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` statement takes a value and then compares it to the several possible
    matches, and executes the appropriate block of code based on the first successful
    match. The `switch` statement is an alternative to using the `if-else` statement
    when there could be several possible matches. The `switch` statement takes the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the `switch` statements in most other languages, in Swift, it does not
    fall through to the next `case` statement; therefore, we do not need to use a
    `break` statement to prevent the fall through. This is another safety feature
    that is built into Swift since one of the most common programming mistakes, with
    the `switch` statement, made by beginner programmers is to forget the `break`
    statement at the end of the `case` statement. Let''s look at how to use the `switch`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `switch` statement takes the value of the `speed`
    variable and compares it to the two `case` statements, and if the value of speed
    matches either case, it will print out what the speed is. If the `switch` statement
    does not find a match, it will print out the `Unknown speed` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `switch` statement must have a match for all the possible values. This
    means that unless we are matching against an enum, each `switch` statement must
    have a `default` case. Let''s look at a case where we do not have a `default`
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we put the preceding code into a Playground and attempt to compile the code,
    we will receive a `switch must be exhaustive, consider adding a default clause`
    error. This is a compile time error; therefore, we will not be notified until
    we attempt to compile the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to include multiple items in a single case. To set multiple
    items within a single case, we would need to separate the items with a comma.
    Let''s look at how we would use the `switch` statement to tell us if a character
    was a vowel or a consonant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that each case has its multiple items. Commas
    separate these items and the `switch` statement will attempt to match the `char`
    variable to each item listed in the `case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to check the value of a `switch` statement to see whether
    it is included in a range. To do this, we would use a range operator in the `case`
    statement, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `switch` statement takes the `grade` variable
    and compares it with the `grade` ranges in each `case` statement, and prints out
    the appropriate grade.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, any `case` statement can contain an optional guard condition that
    can provide an additional condition to validate. The guard condition is defined
    with the `where` keyword. Let''s say, in our preceding example, we had students
    who were receiving special assistance in the class and we wanted to define a grade
    of `D` for them in the range of `55` to `69`. The following example shows how
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to keep in mind with the guard expression is that Swift will attempt
    to match the value starting with the first case statement and working its way
    down checking each case statement in order. This means that if we put the `case`
    statement with the guard expression after the Grade F `case` statement, then the
    `case` statement with the guard expression would never be reached. The following
    example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good rule of thumb is that if you are using guard expressions, always put
    the `case` statements with the guard condition before any similar `case` statements
    without guard expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`Switch` statements are also extremely useful for evaluating enumerations.
    Since an enumeration has a finite number of values, if we provide a `case` statement
    for all the values in the enumeration, we do not need to provide a default case.
    The following example shows how we can use a `switch` statement to evaluate an
    enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we begin by defining an enumeration named `Product` with two
    values each with the associated values. We then create an `order` variable of
    the product type and use the `switch` statement to evaluate it. Notice that we
    did not put a default case at the end of the `switch` statement. If we add additional
    values to the product enumeration at a later time, we would need to either put
    a default case at the end of the `switch` statement or add additional `case` statements
    to handle the additional values.
  prefs: []
  type: TYPE_NORMAL
- en: Using case and where statements with conditional statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the last section, the `case` and `where` statements within a `switch`
    statement can be very powerful. Starting with Swift 2, we are able to use these
    statements with other conditional statements such as the `if`, `for`, and `while`
    statements. Using the `case` and `where` statements within our conditional statements
    can make our code much smaller and easier to read. Let's look at some examples
    starting off with using the `where` statement to filter the results in a `for-in`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with the where statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will see how we can use the `where` statement to filter
    the results of a `for-in` loop. For the example, we will take an array of integers
    and print out only the even numbers; however, before we look at how we would filter
    the results with the `where` statement, let''s look at how we would do this without
    the `where` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we use a `for-in` loop to cycle through the numbers `1` to
    `30`. Within the `for-in` loop, we use an `if` conditional statement to filter
    out the odd numbers. In this simple example, the code is fairly easy to read,
    but let''s see how we can use the `where` statement to use less lines of code
    and make it easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We still have the same `for-in` loop as the previous example; however, now we
    put the `where` statement at the end, which, in this particular example, we only
    loop through the even numbers. Using the `where` statement shortens our example
    by two lines and also makes it easier to read because the filter statement is
    on the same line as the `for-in` loop rather than being embedded in the loop itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how we could filter with the `for-case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with the for-case statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this next example, we will use the `for-case` statement to filter through
    an array of tuples and print out only the results that match our criteria. The
    `for-case` example is very similar to using the `where` statement that we saw
    earlier where it is designed to eliminate the need for an `if` statement within
    a loop to filter the results. In this example, we will use the `for-case` statement
    to filter through a list of World Series winners and print out the year(s) a particular
    team won the World Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create an array of tuples named `worldSeriesWinners`, where
    each tuple in the array contains the name of the team and the year that they won
    the World Series. We then use the `for-case` statement to filter through the array
    and only print out the years that the Red Sox won the World Series. The filtering
    is done within the `case` statement where the `("Red Sox", year)` says that we
    want all the results that have the String, `"Red Sox"`, in the first item of the
    tuple and the value of the second item into the `year` constant. The `for` loop
    then loops through the results of the `case` statement, and we print out the value
    of the `year` constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for-case` statement also makes it very easy to filter out the nil values
    in an array of optionals. Let''s take a look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create an array of optionals named `myNumbers` that may
    contain an integer value or may contain nil. As we will see in [Chapter 10](ch10.html
    "Chapter 10. Using Optional Types"), *Using Optional Types*, an optional is defined
    as an enum internally, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If an optional is set to nil, it will have a value of `None`, but if it is not
    nil, then it will have a value of `Some` with an associate type of the actual
    value. In our example, when we filter for `.Some(num)` , we are looking for any
    optional that has the value of `.Some (non-nil value)`. As shorthand for `.Some()`,
    we could use the `?` (question mark) symbol, as we will see in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also combine `for-case` with a `where` statement to do additional filtering,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is the same as the previous example except that we added the additional
    filtering with the `where` statement. In the previous example, we looped through
    all of the non-nil values, but in this example, we loop through the non-nil values
    that are greater than 3\. Let''s see how we do this same filtering without the
    `case` or `where` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, using the `for-case` and `where` statements can greatly reduce
    the number of lines needed. It also makes our code much easier to read because
    all of the filtering statements are on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more filtering example. This time, we will look at the `if-case`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using the if-case statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `if-case` statement is very similar to using the `switch` statement.
    The majority of time the `switch` statement is preferred, but there are instances
    where the `if-case` statement is better. One of these times is when we are only
    looking for one or two possible matches, and we do not want to handle all of the
    possible matches. Let''s look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create an enumeration named `Identifier` that contains
    three possible values: `Name`, `Number`, and `NoIdentifier`. We create an instance
    of the `Identifier` enumeration named `playerIdentifier` with a value of `Number`
    and an associated value of `42`. We then use the `if-case` statement to see if
    the `playerIdentifier` has a value of `Number`, and if so, we print a message
    to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `for-case` statement, we are able to do additional filtering
    with the `where` statement. The following example uses the same `Identifier` enumeration
    as we used in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we still use the `if-case` statement to see if the `playerIdentifier`
    has a value of `Number`, but we added the `where` statement to see if the associate
    value is equal to `42`, and if so, we identify the player as either `Xander Bogarts
    or Derek Jeter`.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in our examples, using the `case` and `where` statements with our
    conditional statements can reduce the number of lines needed to do certain types
    of filtering. It can also make our code easier to read. Now let's take a look
    at control transfer statements.
  prefs: []
  type: TYPE_NORMAL
- en: Control transfer statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Control transfer statements are used to transfer control to another part of
    the code. Swift offers five control transfer statements; these are `continue`,
    `break`, `fallthrough`, `guard`, `throws`, and `return`. We will look at the `return`
    statement in the *Functions* section later in this chapter and will discuss the
    `throws` statement in [Chapter 7](ch07.html "Chapter 7. Writing Safer Code with
    Availability and Error Handling"), *Writing Safer Code with Availability and Error
    Handling*.
  prefs: []
  type: TYPE_NORMAL
- en: The continue statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `continue` statement tells a loop to stop executing the code block and
    go to the next iteration of the loop. The following example shows how to use a
    `continue` statement to print out only the odd numbers in a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we loop through a range of `1` through `10`. For
    each iteration of the `for-in` loop, we use the remainder (`%`) operator to see
    whether the number is odd or even. If the number is even, the `continue` statement
    tells the loop to immediately go to the next iteration of the loop. If the number
    is odd, we print out the number is odd and then move ahead. The output of the
    preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The break statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `break` statement immediately ends the execution of a code block within
    the control flow. The following example shows how to break out of a `for` loop
    when we encounter the first even number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we loop through the range of `1` through `10`. For
    each iteration of the `for` loop, we use the remainder (`%`) operator to see whether
    the number is odd or even. If the number is even, we use the `break` statement
    to immediately exit the loop. If the number is odd, we print out that the number
    is odd and then go to the next iteration of the loop. The preceding code has the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The fallthrough statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Swift, the `switch` statements do not fall through like other languages;
    however, we can use the `fallthrough` statement to force them to fall through.
    The `fallthrough` statement can be very dangerous because once a match is found,
    the next case defaults to true and that code block is executed. The following
    example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, since the first case, `Baseball`, matches the code
    and the remaining code blocks also execute, the output looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The guard statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Swift and most modern languages, our conditional statements tend to focus
    on testing if a condition is true. As an example, the following code tests to
    see whether the variable `x` is greater than `10`, and if so, we preform some
    function; otherwise, we handle the error condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This type of code leads us to having our functional code embedded within our
    checks and with the error conditions tucked away at the end of our functions,
    but what if that is not what we really want. Sometimes, it may be nice to take
    care of our error conditions at the beginning of the function. I know, in our
    simple example, we could easily check if `x` is less than or equal to `10`, and
    if so, we perform the error condition, but not all the conditional statements
    are that easy to rewrite, especially the items such as optional binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Swift 2, Apple introduced the new `guard` statement. The `guard` statement
    focuses on performing a function if a condition is false; this allows us to trap
    errors and perform the error conditions early in our functions. We could rewrite
    our previous example using the `guard` statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this new example, we check to see whether the variable `x` is greater than
    `10`, and if not, we perform our error condition. If the variable `x` is greater
    than `10`, our code continues. We notice that we have a `return` statement embedded
    within the error condition code. The code within the `guard` statement must contain
    a transfer of control statement; this is what prevents the rest of the code from
    executing. If we forget the transfer of `control` statement, Swift will show a
    compile time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some more examples of the `guard` statement. The following example
    shows how we would use the `guard` statement to verify that an optional contains
    a valid value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a function named `guardFunction()` that accepts an
    optional that contains a string or nil value. We then use the `guard` statement
    with optional binding to verify that the string optional does not contain a nil.
    If it does contain nil, then that code within the `guard` statement is executed
    and the `return` statement is used to exit the function. The really nice thing
    about using the guard statement with optional binding is the new variable is in
    scope for the rest of the function rather than just within the scope of the optional
    binding statement.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how the control flow statements work in Swift, let's give
    an introduction to functions and classes in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Swift, a function is a self-contained block of code that performs a specific
    task. Functions are generally used to logically break our code into reusable named
    blocks. We use the function's name to call the function.
  prefs: []
  type: TYPE_NORMAL
- en: When we define a function, we can also optionally define one or more parameters
    (also known as arguments). Parameters are named values that are passed into the
    function by the code that calls it. These parameters are generally used within
    the function to perform the task of the function. We can also define default values
    for the parameters to simplify how the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Every Swift function has a type associated with it. This type is referred to
    as the return type and it defines the type of data returned from the function
    to the code that called it. If a value is not returned from a function, the return
    type is `Void`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to define functions in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Using a single parameter function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax used to define a function in Swift is very flexible. This flexibility
    makes it easy for us to define simple C style functions or more complex Objective-C
    style functions, with local and external parameter names. Let''s look at some
    examples of how to define functions. The following example accepts one parameter
    and does not return any value back to the code that called it (return type—`void`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we defined a function named `sayHello` that accepts
    one variable that is named `name`. Inside the function, we print out a `Hello`
    greeting to the name of the person. Once the code within the function gets executed,
    the function exits and the control is returned back to the code that called it.
    Rather than printing out the greeting, if we want to return the greeting back
    to the code that called it, we can add a return type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `->` string defines that the return type associated with the function is
    a string. This means that the function must return a `string` variable back to
    the code that calls it. Inside the function, we build a `string` constant with
    the greeting message and then use the `return` keyword to return the `string`
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a Swift function is very similar to how we call functions or methods
    in other languages such as C or Java. The following example shows how to call
    the `sayHello()` function that prints the greeting message to the screen from
    within the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how to call the `sayHello2()` function that returns a value
    back to the code that called it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we call the `sayHello2()` function and put the value
    returned in the `message` variable. If a function defines a return type, such
    as the `sayHello2()` function does, it must return a value of that type to the
    code that called it. Therefore, every possible conditional path within the function
    must end by returning a value of the specified type. This does not mean that the
    code that called the function has to retrieve the returned value. As an example,
    both lines in the following examples are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you do not specify a variable for the return value to go into, the value
    is dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Using a multiparameter function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are not limited to just one parameter with our functions, we can also define
    multiple parameters. To create a multiparameter function, we list the parameters
    in the parentheses and separate the parameter definitions with commas. Let''s
    look at how to define multiple parameters in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the function accepts two arguments: `name` and `greeting`.
    We then print a `greeting` to the console using both the parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a multiparameter function is a little different from calling a single
    parameter function. When calling a multiparameter function, we separate the parameters
    with commas. We also need to include the parameter name for all the parameters
    except for the first one. The following example shows how to call a multiparameter
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We do not need to supply an argument for each parameter of the function if we
    define default values. Let's look at how to configure default values for our parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a parameter's default values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define default values for parameters by using the equal to operator
    (`=`) within the function definition when we declare the variables. The following
    example shows how to declare a function with parameter default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the function declaration, we define one parameter without a default value
    (`name: String`) and one parameter with a default value (`greeting: String = "Bonjour"`).
    When a parameter has a default value declared, we are able to call the function
    with or without setting a value for that parameter. The following example shows
    how to call the `sayHello()` function without setting the `greeting` parameter,
    and also how to call it with setting the `greeting` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `sayHello("Jon")` line, the `sayHello()` function will print out the
    message `Bonjour Jon` since it uses the default value for the `greeting` parameter.
    In the `sayHello("Jon", greeting: "Hello")` line, the `sayHello()` function will
    print out the message `Hello Jon` since we override the default value for the
    `greeting` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare multiple parameters with default values and override only the
    ones we want by using the parameter names. The following example shows how we
    would do this by overriding one of the default values when we call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we declare one parameter without a default value
    (`name: String`) and two parameters with default values (`name2: String = "Kim",
    greeting: String = "Bonjour"`). We then call the function leaving the `name2`
    parameter with its default value, but override the default value of the `greeting`
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example would print out the message, `Hello Jon and Kim`.
  prefs: []
  type: TYPE_NORMAL
- en: Returning multiple values from a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a couple of ways to return multiple values from a Swift function.
    One of the most common ways is to put the values into a collection type (array
    or dictionary) and return the collection. The following example shows how to return
    a collection type from a Swift function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declare the `getNames()` function with no parameters
    and a return type of `[String]`. The return type of `[String]` specifies the return
    type to be an array of string types.
  prefs: []
  type: TYPE_NORMAL
- en: One of the drawbacks of returning a collection type is that the values of the
    collection must be of the same type, or we must declare our collection type to
    be of the `AnyObject` type. In the preceding example, our array could only return
    string types. If we needed to return numbers with our strings, we could return
    an array of `AnyObjects` and then use typecasting to specify the object type.
    However, this would not be a very good design for our application since it would
    be very prone to errors. A better way to return values of different types would
    be to use a tuple type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we return a tuple from a function, it is recommended that we use a named
    tuple to allow us to use the dot syntax to access the returned values. The following
    example shows how to return a named tuple from a function and access the values
    from the named tuple that is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we define the `getTeam()` function that returns a
    named tuple that contains three values—`String`, `Int`, and `Double`. Within the
    function, we create the tuple that we are going to return. Notice that we do not
    need to define the tuple that we are going to return as a named tuple as long
    as the value types within the tuple match the value types in the function definition.
    We can then call the function, as we would any other function, and use the dot
    syntax to access the values of the tuple that is returned. In the preceding example,
    the code would print out the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Returning optional values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sections, we returned non-nil values from our function; however,
    that is not always what we need our code to do. What happens if we need to return
    a nil value from a function? The following code would throw an `expression does
    not conform to type ''NilLiteralConvertible''` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason this code throws an exception is we define the return type as a
    `string` value; however, we are attempting to return `nil`. If there is a reason
    to return `nil`, we need to define the return type as an optional type to let
    the code calling it know that the value may be `nil`. To define the return type
    as an optional type, we use the question mark(`?`) the same way that we did when
    we defined a variable as an optional type. The following example shows how to
    define an optional return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would not throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set a tuple as an optional type or any value within a tuple as
    an optional type. The following example shows how we would return a tuple as an
    optional type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we could return a tuple as defined within our function
    definition or a `nil`; either option is valid. If we needed an individual value
    within our tuple to be `nil`, we would need to add an optional type within our
    tuple. The following example shows how to return a `nil` within our tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can set the `percent` value to either a `Double`
    value or `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding external parameter names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding examples in this section, the parameters were defined similar
    to how we would define the parameters in C code, where we define the parameter
    names and value types. When we call the function, we also call the function similar
    to how we would call functions in C code, where we use the function name and specify
    the values we are passing to the function within parenthesis. In Swift, we are
    not limited to this syntax; we can also use external parameter names.
  prefs: []
  type: TYPE_NORMAL
- en: External parameter names are used when we call a function to indicate the purpose
    of each parameter. If we want to use external parameter names with our functions,
    we would need to define an external parameter name for each parameter in addition
    to its local parameter name. The external parameter name is added before the local
    parameter name in the function definition. The external and local parameter names
    are separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use external parameter names. But before we do so, let''s
    review how we have previously defined functions. In the next two examples, we
    will define a function without external parameter names and then we will redefine
    that function with external parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we define the `winPercentage()` function that accepts
    three parameters. These parameters are `team`, `wins`, and `loses`. The `team`
    parameter is a `String` type and the `wins` and `loses` parameters are `Int` types.
    The following line of code shows how to call the `winPercentage()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the same function with external parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we redefine the `winPercentage` function with external
    parameter names. In this redefinition, we have the same three parameters: `team`,
    `wins`, and `losses`. The difference is how we define the parameters. When using
    external parameters, we define each parameter with both an external parameter
    name and a local parameter name separated by a space. In the preceding example,
    the first parameter has an external parameter name of `BaseballTeam`, an internal
    parameter name of `team`, and a type of `String`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call a function with external parameter names, we need to include the
    external parameter names in the function call. The following code shows how to
    call the function in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: While using external parameter names requires more typing, it does make your
    code easier to read. In the preceding example, it is easy to see that the function
    is looking for the name of a baseball team, the second parameter is the number
    of wins, and the last parameter is the number of losses.
  prefs: []
  type: TYPE_NORMAL
- en: Using variadic parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variadic parameter is one that accepts zero or more values of a specified
    type. Within the functions definition, we define a variadic parameter by appending
    three periods(`...`) to the parameter''s type name. The values of a variadic parameter
    are made available to the function as an array of the specified type. The following
    example shows how we would use a variadic parameter with a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `sayHello()` function takes two parameters. The
    first parameter is a String type, which is the greeting to use. The second parameter
    is a variadic parameter of the String type, which are the names to send the greeting
    to. Within the function, a variadic parameter is an array that contains the type
    specified; therefore, in our example, the `names` parameter is an array of `String`
    values. In this example, we use a `for-in` loop to access the values within the
    `names` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code shows how to call the `sayHello()` function with
    a variadic parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code will print two greetings: `Hello Jon` and `Hello
    Kim`.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters as variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parameters are constants by default, which means they cannot be changed within
    the function. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If we try to run this example, we will get an exception because we will have
    attempted to change the value of the `count` parameter with the decrement operator
    (`--`). If we need to change the value of a parameter within our function, we
    need to specify that the parameter is a variable by using the `var` keyword in
    the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to declare the `count` parameter as a variable
    (rather than a constant) so that we can change the value within the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can see how we added the `var` keyword prior to the `count` parameter name
    in the preceding example. This specifies whether the parameter is a variable and
    not a constant; therefore, we can change the value of the `count` parameter in
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: Using inout parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variable parameters, as we just described, can only change the value of the
    parameter within the function; therefore, any changes are lost after the function
    ends. If we want the changes to a parameter to persist once the function ends,
    we need to define the parameter as an `inout` parameter. Any changes made to an
    `inout` parameter are passed back to the variable that was used in the function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Two items to keep in mind when we use `inout` parameters are that these parameters
    cannot have default values and they cannot be a variadic parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use the `inout` parameters to swap the values of two
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will accept two parameters and swap the values of the variables
    that are used in the function call. When we make the function call, we put an
    ampersand (`&`) in front of the variable name indicating that the function can
    modify its value. The following example shows how to call the reverse function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we set variable `one` to the value `One` and variable
    `two` to the value `Two`. We then call the reverse function with the `one` and
    `two` variables. Once the swap function returns, the variable named `one` will
    contain the value `Two`, while the variable named `two` will contain the value
    `One`.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the functions that we have shown so far are examples of global functions.
    Global functions are the ones that are defined at a global scope within the class
    or file that they are in. Swift also allows us to nest one function within another.
    Nested functions can only be called within the enclosed function; however, the
    enclosed function can return a nested function that allows it to be used outside
    the scope of the enclosed function. We will cover returning a function in [Chapter
    12](ch12.html "Chapter 12. Working with Closures"), *Working with Closures*, later
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to nest functions by creating a simple sort function that
    will take an array of integers and sort it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we begin by creating a global function named `sort` that
    accepts an `inout` parameter, that is, an array of `Ints`. Within the `sort` function,
    the first thing we do is define the nested function that is named `reverse`. A
    function needs to be defined in the code prior to calling it, so it is good practice
    to put all the nested functions at the start of the global function so that we
    know they are defined prior to calling them. The `reverse` function simply swaps
    the two values that are passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the body of the `sort` function, we implement the logic for the simple
    sort. Within that logic, we compare two numbers in the array, and if the numbers
    need to be reversed, we call the nested `reverse` function to swap the two numbers.
    This example shows how we can effectively use a nested function to organize our
    code to make it easy to maintain and read. Let''s look at how to call the global
    sort function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates an array of five integers and then passes the array
    to the `sort` function. When the `sort` function returns the `nums` array, it
    contains a sorted array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nested functions, when used properly, can be very useful. However, it is really
    easy to overuse them. Before creating a nested function, you might want to ask
    yourself why you want to use a nested function and what problem are you solving
    by using a nested function.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reinforce what we learned in this chapter, let''s look at one more example.
    For this example, we will create a function that will test to see if a string
    value contains a valid IPv4 address or not. An IPv4 address is the address assigned
    to a computer that uses the Internet Protocol to communicate. An IP address consists
    of four numeric values, ranging from 0-255, separated by a dot (period). An example
    of a valid IP address is 10.0.1.250:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Since the parameter for the `isValidIp()` function is an optional type, the
    first thing we do is verify that the `ipAddr` parameter is not nil. To do this,
    we used a `guard` statement with optional binding and if the optional binding
    fails, we return a Boolean `false` value because nil is not a valid IP address.
  prefs: []
  type: TYPE_NORMAL
- en: If the `ipAddr` parameter contains a non-nil value, we then split the string
    into an array of strings, at the dots. Since an IP address is suppose to contain
    four numbers separated by a dot, we use the `guard` statement to check whether
    the array contains four elements. If it does not, we return `false` because we
    know that the `ipAddr` parameter did not contain a valid IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a nested function named `validOctet()` that has one String parameter
    named `octet`. This nested function will verify that the `octet` parameter contains
    a numeric value between 0 and 255, and if so, it will return a Boolean `true`
    value, otherwise, it will return a `false` Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we loop through a values in the array that we created by splitting
    the original `ipAddr` parameter at the dots and pass the values to the `validOctet()`
    nested function. If all the four values get verified by the `validOctet()` function,
    we have a valid IP address and we return a Boolean `true` value; however, if any
    of the values fail the `validOctet()` function, we return a Boolean `false` value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered control flow and functions in Swift. It is essential
    to understand the concepts in this chapter before going on. Every application
    that we write, beyond the simple Hello World applications, will rely very heavily
    on the control flow statements and functions.
  prefs: []
  type: TYPE_NORMAL
- en: The control flow statements are used to make decisions within our application,
    and the functions will be used to group our code into the sections that are reusable
    and organized.
  prefs: []
  type: TYPE_NORMAL
