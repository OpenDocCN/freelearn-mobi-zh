- en: Chapter 6. Resource Manager
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 资源管理器
- en: If we start developing our game, we’ll eventually need to create an entity that
    handles all of our assets. We’ll call it `ResourceManager`. We’ll see how to create
    one that allows you to add images, fonts, and sounds to your games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们开始开发我们的游戏，我们最终需要创建一个处理所有我们资产的实体。我们将称之为`ResourceManager`。我们将看到如何创建一个允许你将图像、字体和声音添加到你的游戏中的实体。
- en: The main idea behind the resource manager is to cache assets that we’ll use
    more than once and to have a centralized and abstracted way to create assets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管理器背后的主要思想是缓存我们将多次使用的资产，并有一个集中化和抽象化的方式来创建资产。
- en: Resource definitions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源定义
- en: In order to be able to define resources, we need to create a module that will
    be in charge of handling this. The main idea is that before calling a certain
    asset through `ResourceManager`, it has to be defined in `ResourceDefinitions`.
    In this way, `ResourceManager` will always have access to some metadata it needs
    to create the asset (filenames, sizes, volumes, and so on).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够定义资源，我们需要创建一个负责处理此任务的模块。主要思想是在通过`ResourceManager`调用某个资产之前，它必须在`ResourceDefinitions`中定义。这样，`ResourceManager`将始终能够访问创建资产所需的某些元数据（文件名、大小、音量等）。
- en: 'In order to identify the asset types (sounds, images, tiles, and fonts), we
    will define some constants (note that the number values of these constants are
    arbitrary; you could use whatever you want here). Let’s call them `RESOURCE_TYPE_[type]`
    (feel free to use another convention if you want to). To make things easier, just
    follow this convention for now since it’s the one we’ll use in the rest of the
    book. You should enter them in `main.lua` as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别资产类型（声音、图像、瓦片和字体），我们将定义一些常量（请注意，这些常量的数值是任意的；你可以在这里使用任何你想要的）。让我们称它们为`RESOURCE_TYPE_[type]`（如果你想使用其他约定，请随意）。为了使事情更简单，现在就遵循这个约定，因为这是我们将在本书的其余部分使用的约定。你应该在`main.lua`中按如下方式输入它们：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you want to understand the actual reason behind these resource type constants,
    take a look at the `load` function of our `ResourceManager` entity in the next
    section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解这些资源类型常数的实际原因，请查看下一节中我们的`ResourceManager`实体的`load`函数。
- en: We need to create a file named `resource_definitions.lua` and add some simple
    methods that will handle it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`resource_definitions.lua`的文件，并添加一些简单的处理方法。
- en: 'Add the following line to it:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 向其中添加以下行：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding line indicates that all of the code in the file should be treated
    as a `module` function, being accessed through `ResourceDefinitions` in the code.
    This is one of many Lua patterns used to create modules.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行表示文件中的所有代码都应该被视为一个`module`函数，通过代码中的`ResourceDefinitions`来访问。这是Lua创建模块的许多模式之一。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re not used to the Lua’s `module` function, you can read about it in
    the modules tutorial at [http://lua-users.org/wiki/ModulesTutorial](http://lua-users.org/wiki/ModulesTutorial).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉Lua的`module`函数，你可以在模块教程中阅读有关它的内容，教程地址为[http://lua-users.org/wiki/ModulesTutorial](http://lua-users.org/wiki/ModulesTutorial)。
- en: 'Next, we will create a table that contains these definitions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个包含这些定义的表：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will be used internally and is not accessible through the module API, so
    we create it using the keyword `local`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在内部使用，并且无法通过模块API访问，因此我们使用关键字`local`来创建它。
- en: Now, we need to create the `setter`, `getter`, and `unload` methods for the
    definitions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为定义创建`setter`、`getter`和`unload`方法。
- en: 'The `setter` method (called `set`) stores the `definition` parameter (a table)
    in the `definitions` table, using the `name` parameter (a string) as the key,
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`setter`方法（称为`set`）将`definition`参数（一个表）存储在`definitions`表中，使用`name`参数（一个字符串）作为键，如下所示：'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `getter` method (called `get`, duh!) retrieves the definition that was
    previously stored (by use of `ResourceDefinitions:set ()`) using the `name` parameter
    as the key of the `definitions` table, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`getter`方法（称为`get`，当然！）使用`name`参数作为`definitions`表的键，检索之前存储的定义（通过使用`ResourceDefinitions:set
    ()`），如下所示：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `final` method that we’re creating is `remove`. We use it to clear the
    memory space used by the definition. In order to achieve this we assign `nil`
    to an entry in the `definitions` table indexed by the `name` parameter as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建的`final`方法是`remove`。我们用它来清除定义所使用的内存空间。为了实现这一点，我们将`nil`赋值给`definitions`表中由`name`参数索引的条目，如下所示：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this way, we remove the reference to the object, allowing the memory to be
    released by the garbage collector. This may seem useless here, but it’s a good
    example of how you should manage your objects to be removed from memory by the
    garbage collector. And besides this, we don’t know information comes in a resource
    definition; it may be huge, we just don’t know.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们消除了对对象的引用，允许垃圾收集器释放内存。这在这里可能看起来没有用，但它是一个很好的例子，说明了您应该如何管理对象以便让垃圾收集器从内存中移除。而且除此之外，我们不知道信息来自资源定义；它可能很大，我们只是不知道。
- en: This is all we need for the resource definitions. We’re making use of the dynamism
    that Lua provides. See how easy it was to create a repository for definitions
    that is abstracted from the content of each definition. We’ll define different
    fields for each asset type, and we don’t need to define them beforehand as we
    probably would have needed to do in C++.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是资源定义所需的所有内容。我们正在利用 Lua 提供的动态性。看看创建一个从每个定义的内容中抽象出来的定义存储库有多容易。我们将为每种资产类型定义不同的字段，而且我们不需要事先定义它们，就像我们可能在
    C++ 中需要做的那样。
- en: Resource manager
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理器
- en: We will now create our resource manager. This module will be in charge of creating
    and storing our decks and assets in general. We’ll retrieve the assets with one
    single command, and they’ll come from the cache or get created using the definition.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建我们的资源管理器。这个模块将负责创建和存储我们的牌组和一般资源。我们将使用一个单一的命令来检索资源，它们将来自缓存或根据定义创建。
- en: 'We need to create a file named `resource_manager.lua` and add the following
    line to it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为 `resource_manager.lua` 的文件，并将其添加以下行：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the same as in the resource definitions; we’re creating a module that
    will be accessed using `ResourceManager`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这与资源定义中的情况相同；我们正在创建一个模块，它将通过 `ResourceManager` 来访问。
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now create the `ASSETS_PATH` constant. This is the path where we will store
    our assets. You could have many paths for different kinds of assets, but in order
    to keep things simple, we’ll keep all of them in one single directory in this
    example. Using this constant will allow us to use just the filename instead of
    having to write the whole path when creating the actual resource definitions,
    saving us some phalanx injuries!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建一个名为 `ASSETS_PATH` 的常量。这是我们将存储我们的资源的地方。您可以为不同类型的资源设置多个路径，但为了保持简单，在这个例子中我们将它们全部保存在一个单独的目录中。使用这个常量将允许我们只使用文件名，而不是在创建实际资源定义时必须写出整个路径，这样可以节省我们一些麻烦！
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, we’re creating a `cache` table as a local variable. This will be the
    variable that will store our initialized assets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们正在创建一个作为局部变量的 `cache` 表。这将是我们存储初始化资源的变量。
- en: Now we should take care of implementing the important functionality. In order
    to make this more readable, I’ll be using methods that we define in the following
    pages. So, I recommend that you read the whole section before trying to run what
    we code now. The full source code can be downloaded from the book’s website, featuring
    inline comments. In the book, we removed the comments for brevity’s sake.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该注意实现重要的功能。为了使代码更易读，我将在以下页面中定义的方法中使用方法。因此，我建议您在尝试运行我们现在编写的代码之前阅读整个部分。完整的源代码可以从本书的网站上下载，其中包含内联注释。在书中，为了简洁起见，我们移除了注释。
- en: Getter
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取器
- en: 'The first thing we will implement is our `getter` method since it’s simple
    enough:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现我们的 `getter` 方法，因为它足够简单：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method receives a `name` parameter that is the identifier of the resource
    we’re working with. On the first line, we call `loaded` (a method that we will
    define soon) to see if the resource identified by `name` was already loaded. If
    it was, we just need to return the cached value, but if it was not we need to
    load it, and that’s what we do in the `if` statement. We use the internal `load`
    method (which we will define later as well) to take care of the loading. We will
    make this `load` method store the loaded object in the `cache` table. So after
    loading it, the only thing we have to do is return the object contained in the
    `cache` table indexed by `name`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接收一个 `name` 参数，它是我们正在处理的资源的标识符。在第一行，我们调用 `loaded`（我们很快将定义的方法）来查看由 `name`
    标识的资源是否已经被加载。如果是的话，我们只需要返回缓存的值，但如果没有，我们需要加载它，这就是我们在 `if` 语句中做的。我们使用内部的 `load`
    方法（我们稍后也将定义）来处理加载。我们将使这个 `load` 方法将加载的对象存储在 `cache` 表中。所以加载后，我们唯一要做的就是返回 `cache`
    表中按 `name` 索引的对象。
- en: 'One of the auxiliary functions that we use here is `loaded`. Let’s implement
    it since it’s really easy to do so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的辅助函数之一是 `loaded`。让我们来实现它，因为它真的很容易做：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we do here is check whether the `cache` table indexed by the `name` parameter
    is not equal to `nil`. If `cache` has an object under that key, this will return
    `true`, and that’s what we were looking for to decide whether the object represented
    by the `name` parameter was already loaded.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是检查由 `name` 参数索引的 `cache` 表是否不等于 `nil`。如果 `cache` 在该键下有一个对象，这将返回 `true`，这正是我们想要找到的，以决定由
    `name` 参数表示的对象是否已经被加载。
- en: Loader
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载器
- en: '`load` and its auxiliary functions are the most important methods of this module.
    They’ll be slightly more complex than what we’ve done so far since they make the
    magic happen. Pay special attention to this section. It’s not particularly hard,
    but it might get confusing. Like the previous methods, this one receives just
    the `name` parameter that represents the asset we’re loading as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`load` 及其辅助函数是这个模块最重要的方法。它们将比我们迄今为止所做的方法稍微复杂一些，因为它们实现了魔法。请特别注意这一部分。它并不特别困难，但可能会让人困惑。像之前的方法一样，这个方法只接收代表我们要加载的资源的
    `name` 参数，如下所示：'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First of all, we retrieve the definition for the resource associated to `name`.
    We make a call to the `get` method from `ResourceDefinitions`, which we defined
    earlier as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索与 `name` 关联的资源定义。我们调用之前定义的 `ResourceDefinitions` 中的 `get` 方法，如下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the resource definition does not exist (because we forgot to define it before),
    we print an error to the screen, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源定义不存在（因为我们忘记在之前定义它），我们将打印一个错误信息，如下所示：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the resource definition was retrieved successfully, we create a variable
    that will hold the resource and (pay attention) we call the correct `load` auxiliary
    function, depending on the asset type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功检索到资源定义，我们创建一个变量来保存资源，并且（请注意）根据资产类型调用正确的 `load` 辅助函数。
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Remember the `RESOURCE_TYPE_[type]` constants that we created in the `ResourceDefinitions`
    module? This is the reason for their existence. Thanks to the creation of the
    `RESOURCE_TYPE_[type]` constants, we now know how to load the resources correctly.
    When we define a resource, we must include a `type` key with one of the resource
    types. We’ll insist on this soon. What we do now is call the correct `load` method
    for images, tiled images, fonts, and sounds, using the value stored in `resourceDefinition.type`
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在 `ResourceDefinitions` 模块中创建的 `RESOURCE_TYPE_[type]` 常量吗？这就是它们存在的原因。多亏了
    `RESOURCE_TYPE_[type]` 常量的创建，我们现在知道如何正确地加载资源。当我们定义一个资源时，我们必须包含一个 `type` 键，并使用其中一个资源类型。我们很快就会坚持这一点。我们现在所做的是调用正确的
    `load` 方法，用于图像、平铺图像、字体和声音，使用存储在 `resourceDefinition.type` 中的值，如下所示：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After loading the current resource, we store it in the `cache` table, in an
    entry specified by the `name` parameter, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载当前资源后，我们将其存储在 `cache` 表中，使用 `name` 参数指定的条目，如下所示：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, let’s take a look at all of the different load methods. The expected definitions
    are explained before the actual functions so you have a reference when reading
    them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看所有不同的加载方法。实际的函数之前的预期定义是为了在阅读时提供参考。
- en: Images
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像
- en: Loading images is something that we’ve already done, so this is going to look
    somewhat familiar.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像是我们已经做过的事情，所以这看起来会有些熟悉。
- en: 'In this book, we’ll have two ways of defining images. Let’s take a look at
    them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将有两种定义图像的方法。让我们来看看它们：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you may have guessed, the `type` key is the one used in the `load` function.
    In this case, we need to make it of type `RESOURCE_TYPE_IMAGE`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`type` 键是在 `load` 函数中使用的。在这种情况下，我们需要将其设置为 `RESOURCE_TYPE_IMAGE` 类型。
- en: Here we are defining an image that has specific `width` and `height` values,
    and that is located at `assets/title_back.png`. Remember that we will use `ASSET_PATH`
    in order to avoid writing `assets/` a zillion times. That’s why we’re not writing
    it on the definition.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个具有特定 `width` 和 `height` 值的图像，并且它位于 `assets/title_back.png`。记住，我们将使用
    `ASSET_PATH` 以避免多次写入 `assets/`。这就是为什么我们在定义中不写它的原因。
- en: 'Another useful definition is:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的定义是：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is handy when you want a specific rectangle inside a bigger image. You
    can use the `cords` attribute to define this rectangle. For example, we get a
    square with 20 pixel long sides centered in the image by specifying `coords =
    { -10, -10, 10, 10 }`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在较大图像中特定矩形时，这很有用。你可以使用 `cords` 属性来定义这个矩形。例如，通过指定 `coords = { -10, -10, 10,
    10 }`，我们得到一个边长为 20 像素的正方形，其中心位于图像中。
- en: 'Now, let’s take a look at the actual `loadImage` method to see how this all
    falls into place:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实际的 `loadImage` 方法，看看这一切是如何结合在一起的：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First of all, we use the same technique of defining an empty variable that
    will hold our image:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用与之前相同的技术定义一个空变量，该变量将保存我们的图像：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We create the actual full path by appending the value of `fileName` in the
    definition to the value of the `ASSETS_PATH` constant. `if` checks whether the
    `coords` attribute is defined:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将定义中 `fileName` 的值附加到 `ASSETS_PATH` 常量的值来创建实际的全路径。`if` 检查 `coords` 属性是否已定义：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, we use another auxiliary function called `loadGfxQuad2D`. This will be
    in charge of creating the actual image. The reason why we’re using another auxiliary
    function is that the code used to create the image is the same for both definition
    styles, but the data in the definition needs to be processed differently. In this
    case, we just pass the coordinates of the rectangle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用另一个辅助函数，称为 `loadGfxQuad2D`。这个函数将负责创建实际图像。我们使用另一个辅助函数的原因是，用于创建图像的代码在两种定义风格中都是相同的，但定义中的数据需要以不同的方式处理。在这种情况下，我们只需传递矩形的坐标。
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If there were no `coords` attribute, we’d assume the image is defined using
    `width` and `height`. So what we do is to define a rectangle that covers the whole
    width and height for the image. We do this by calculating `halfWidth` and `halfHeight`
    and then passing these values to the `loadGfxQuad2D` method. Remember the discussion
    about the texture coordinates in Moai SDK; this is the reason why we need to divide
    the dimensions by 2 and pass them as negative and positive parameters for the
    rectangle. This allows it to be centered on (0, 0). After loading the image, we
    return it so it can be stored in the cache by the `load` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `coords` 属性，我们会假设图像是使用 `width` 和 `height` 定义的。所以我们做的是定义一个覆盖整个宽度和高度的矩形。我们通过计算
    `halfWidth` 和 `halfHeight` 并将这些值传递给 `loadGfxQuad2D` 方法来完成此操作。记住 Moai SDK 中关于纹理坐标的讨论；这就是为什么我们需要将维度除以
    2 并将它们作为负数和正数参数传递给矩形的原因。这允许它在 (0, 0) 上居中。在加载图像后，我们返回它，以便它可以通过 `load` 方法存储在缓存中：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now the last method we need to write is `loadGfxQuad2D`. This method is basically
    doing the same as what we did in the previous chapter to display an image as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写的最后一个方法是 `loadGfxQuad2D`。这个方法基本上与我们在上一章中用于显示图像的方法相同：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Lua’s `unpack` method is a nice tool that allows you to pass a table as separate
    parameters. You can use it to split a table into multiple variables as well:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 的 `unpack` 方法是一个很好的工具，它允许你将一个表作为单独的参数传递。你可以用它将一个表拆分成多个变量：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What we do here is instantiate the `MOAIGfxQuad2D` class, set the texture we
    defined in the previous function, and use the coordinates we constructed to set
    the rectangle this image will use from the original texture. Then we return it
    so `loadImage` can use it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是实例化 `MOAIGfxQuad2D` 类，设置我们在上一个函数中定义的纹理，并使用我们构建的坐标来设置图像将从原始纹理中使用的矩形。然后我们返回它，以便
    `loadImage` 可以使用它。
- en: Well! That was it for images. It may look complicated at first, but it’s not
    that complex.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！这就是关于图像的所有内容。一开始可能看起来很复杂，但实际上并不复杂。
- en: The rest of the assets will be simpler than this, so if you understood this
    one, the rest will be a piece of cake.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的资产将比这更简单，所以如果你理解了这个，其余的就会变得容易。
- en: Tiled images
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 瓦片图像
- en: Another useful type of asset is tiled images. In gaming, we usually use tiled
    images to load a single texture and use fragments of it for specific purposes
    (for example, animations can be achieved using this technique). This will be handy
    in our game *Concentration*, to define which tiles should be placed in the matrix.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的资产类型是瓦片图像。在游戏中，我们通常使用瓦片图像来加载单个纹理，并使用其片段来完成特定目的（例如，可以使用这种技术实现动画）。这将在我们的游戏
    *Concentration* 中很有用，用于定义哪些瓦片应该放置在矩阵中。
- en: 'The tiled image definition is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片图像定义如下：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is basically the same as the normal image, but we need to add `tileMapSize`
    and remove `width` and `height`. This table will be unpacked as the parameters
    for `MOAITileDeck2D:setRect` (check it out at [http://getmoai.com/docs/class_m_o_a_i_tile_deck2_d.html#a504da8814f74038af9d453ebbc7fd5ae](http://getmoai.com/docs/class_m_o_a_i_tile_deck2_d.html#a504da8814f74038af9d453ebbc7fd5ae)).
    In this case, it says that the tile map has three columns and two rows, giving
    a total of six tiles.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与正常图像相同，但我们需要添加 `tileMapSize` 并移除 `width` 和 `height`。这个表将被解包为 `MOAITileDeck2D:setRect`
    的参数（请参阅 [http://getmoai.com/docs/class_m_o_a_i_tile_deck2_d.html#a504da8814f74038af9d453ebbc7fd5ae](http://getmoai.com/docs/class_m_o_a_i_tile_deck2_d.html#a504da8814f74038af9d453ebbc7fd5ae)）。在这种情况下，它表示瓦片图有
    3 列和 2 行，总共 6 个瓦片。
- en: '`loadTiledImage` is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTiledImage` 的代码如下：'
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is essentially the same as what we did with the image. We append `fileName`
    to `ASSETS_PATH` to get the final texture `filePath`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与我们对图像所做的是相同的。我们将 `fileName` 添加到 `ASSETS_PATH` 以获取最终的纹理 `filePath`。
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only real difference is that we unpack the `tileMapSize` attribute to pass
    it to `setSize`. You may use all of the possible parameters that can be passed
    to `setSize`; these are explained in the Moai SDK API documentation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正的区别是我们将 `tileMapSize` 属性解包以传递给 `setSize`。您可以使用所有可以传递给 `setSize` 的可能参数；这些在
    Moai SDK API 文档中有解释。
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And this is pretty much the same as for the normal image. We return `tiledImage`
    to be used later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这与正常图像的处理方式基本相同。我们将 `tiledImage` 返回以供后续使用。
- en: Fonts
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字体
- en: 'Fonts are easier, and the definition is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 字体更容易，其定义如下：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The specific attributes that we have here, besides the type and the filename,
    are `glyphs` (these are the characters that we will use; in this example, we only
    use the numbers from 0 to 9), `fontSize`, and `dpi` for font.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型和文件名之外，我们这里的具体属性还包括 `glyphs`（这是我们将会使用的字符；在这个例子中，我们只使用了从 0 到 9 的数字）、`fontSize`
    和字体的大小 `dpi`。
- en: 'The `loadFont` method is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadFont` 方法的代码如下：'
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The whole method is basically the same as the other loaders; the differences
    are that we use `MOAIFont` as the class, and we use `loadFromTTF` with the necessary
    parameters to initialize it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 整个方法基本上与其他加载器相同；区别在于我们使用 `MOAIFont` 作为类，并使用 `loadFromTTF` 以及必要的参数来初始化它。
- en: Sounds
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声音
- en: 'The definition for sounds is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 声音的定义如下：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The specific attributes for sounds are `loop` (whether the sound should loop
    constantly or not) and `volume` (the initial volume for it).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 声音的具体属性包括 `loop`（是否应该持续循环播放）和 `volume`（初始音量）。
- en: Moai SDK comes with support for two different sound engines, **Untz**, an open
    source engine created specifically for Moai SDK, and **FMOD**, an industry standard
    sound library. It’s worth mentioning that FMOD costs money, while Untz is free.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Moai SDK 包含对两种不同声音引擎的支持，**Untz**，一个专门为 Moai SDK 创建的开源引擎，以及 **FMOD**，一个行业标准的声音库。值得一提的是，FMOD
    需要付费，而 Untz 是免费的。
- en: We’re going to show you how to use Untz in this book, but you can safely code
    `loadSound` to use FMOD instead (take a look at `MOAIFmodExSound` and `MOAIFmodExChannel`
    in the Moai SDK API documentation).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在本书中向您展示如何使用 Untz，但您可以将 `loadSound` 编码为使用 FMOD（请参阅 Moai SDK API 文档中的 `MOAIFmodExSound`
    和 `MOAIFmodExChannel`）。 '
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is basically the same logic as for the previous loaders, but we’re using
    `setVolume` and `setLooping` to use the attributes we chose on our resource definition.
    We’ve not initialized Untz yet; this will be done later, but this code has been
    explained here for the completeness of `ResourceManager`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与之前的加载器逻辑相同，但我们使用 `setVolume` 和 `setLooping` 来使用我们在资源定义中选择的属性。我们尚未初始化 Untz；这将在稍后完成，但这段代码已经在这里解释，以完善
    `ResourceManager`。
- en: Exercises
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Putting this together should be something you can achieve now. So, take the
    source code of the `main.lua` file we created previously and modify it in order
    to make use of our `ResourceManager` and `ResourceDefinitions` entities. You’ll
    need to include `resource_definition.lua` and `resource_manager.lua` in `main.lua`
    and then make good use of them. If you download the source code for this chapter
    from the website, `main.lua` has already been modified to work with `ResourceManager`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些组合起来应该是你现在可以实现的。所以，取我们之前创建的 `main.lua` 文件的源代码，并对其进行修改以使用我们的 `ResourceManager`
    和 `ResourceDefinitions` 实体。您需要在 `main.lua` 中包含 `resource_definition.lua` 和 `resource_manager.lua`，然后充分利用它们。如果您从网站上下载本章的源代码，`main.lua`
    已经被修改为与 `ResourceManager` 一起工作。
- en: Another exercise is to code a way to unload assets from `ResourceManager`. This
    has also been done in the code for this chapter, which you can download from the
    website.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个练习是编写一种方法，从`ResourceManager`中卸载资源。这一功能也在本章的代码中实现，您可以从网站上下载。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `unload` method is pretty important since it will be needed in order to
    actually free the memory reserved for assets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`unload`方法非常重要，因为实际上需要它来释放为资源保留的内存。'
- en: Another interesting topic to enhance our `ResourceManager` entity is the use
    of serialized fonts so font loading is faster at runtime.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的话题是增强我们的`ResourceManager`实体，即使用序列化字体，以便在运行时更快地加载字体。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we created a simple framework to work with assets. We created
    ways to define images, sounds, and fonts and coded the `ResourceDefinitions` class
    to store this data. We wrote our `ResourceManager` class, which is in charge of
    loading the different assets and caching them. We also went through the creation
    of loading functions for these different assets and explained a way to define
    them. Now we’re ready to start developing the gameplay for our game; how awesome
    is that!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个简单的框架来处理资源。我们创建了定义图像、声音和字体的方法，并编写了`ResourceDefinitions`类来存储这些数据。我们还编写了`ResourceManager`类，该类负责加载不同的资源并对其进行缓存。我们还介绍了为这些不同资源创建加载函数的方法，并解释了如何定义它们。现在，我们已准备好开始开发我们游戏的游戏玩法；这有多么酷啊！
