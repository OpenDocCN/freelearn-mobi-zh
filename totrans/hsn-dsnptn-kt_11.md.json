["```kt\ndependencies {\n    def $vertx_version = '3.5.1'\n    ...\n    compile group: 'io.vertx', name: 'vertx-core', version: $vertx_version\n    compile group: 'io.vertx', name: 'vertx-web', version: $vertx_version\n    compile group: 'io.vertx', name: 'vertx-lang-kotlin', version: $vertx_version\n    compile group: 'io.vertx', name: 'vertx-lang-kotlin-coroutines', version: $vertx_version\n}\n```", "```kt\nfun main(vararg args: String) {\n   val vertx = Vertx.vertx()\n\n   vertx.createHttpServer().requestHandler{ req ->\n            req.response().end(\"OK\")\n        }.listen(8080)\n}\n```", "```kt\napply plugin: 'application'\nmainClassName = \"com.gett.MainKt\"\n```", "```kt\n./gradlew run\n```", "```kt\nval vertx = Vertx.vertx() // Was here before\nval router = Router.router(vertx)\n...\n```", "```kt\nfun Route.asyncHandler(fn : suspend (RoutingContext) -> Unit) {\n    handler { ctx ->\n        launch(ctx.vertx().dispatcher()) {\n            try {\n                fn(ctx)\n            } catch(e: Exception) {\n                ctx.fail(e)\n            }\n        }\n    }\n}\n```", "```kt\nrouter.get(\"/alive\").asyncHandler {\n    // Some response comes here\n    // We now can use any suspending function in this context\n}\n```", "```kt\n...\nval json = json {\n    obj (\n       \"alive\" to true\n    )\n}\nit.respond(json.toString())\n...\n```", "```kt\nfun RoutingContext.respond(responseBody: String = \"\", status: Int = 200) {\n    this.response()\n            .setStatusCode(status)\n            .end(responseBody)\n}\n```", "```kt\nvertx.createHttpServer().\n   requestHandler(router::accept).listen(8080)\n```", "```kt\nrouter.route().handler(BodyHandler.create())\n```", "```kt\napi/v1/cats\n```", "```kt\nrouter.post(\"/api/v1/cats\").asyncHandler { ctx ->\n    // Some code of adding a cat comes here\n}\nrouter.get(\"/api/v1/cats\").asyncHandler { ctx ->\n    // Code for getting all the cats\n}\n\n```", "```kt\nrouter.get(\"/api/v1/cats/:id\").asyncHandler { ctx ->\n    // Fetches specific cat\n}\n```", "```kt\nclass ServerVerticle: CoroutineVerticle() {\n\n    override suspend fun start() {\n        val router = router()\n        vertx.createHttpServer().requestHandler(router::accept).listen(8080)\n    }\n\n    private fun router(): Router {\n        val router = Router.router(vertx)\n        // Our router code comes here now\n        ...\n        return router\n    }\n}\n```", "```kt\nvertx.deployVerticle(ServerVerticle())\n```", "```kt\nprivate fun apiRouter(): Router {\n    val router = Router.router(vertx)\n\n    router.post(\"/cats\").asyncHandler { ctx ->\n        ctx.respond(status=501)\n    }\n    router.get(\"/cats\").asyncHandler { ctx ->\n        ...\n    }\n    router.get(\"/cats/:id\").asyncHandler { ctx ->\n        ...\n    }\n    return router\n}\n```", "```kt\nrouter.mountSubRouter(\"/api/v1\", apiRouter())\n```", "```kt\ntestCompile group: 'org.testng', name: 'testng', version: '6.11'\n```", "```kt\nclass ServerVerticleTest {\n    // Usually one instance of VertX is more than enough\n    val vertx = Vertx.vertx()\n\n    @BeforeClass\n    fun setUp() {\n        // You want to start your server once\n        startServer()\n    }\n\n    @AfterClass\n    fun tearDown() {\n        // And you want to stop your server once\n        vertx.close()\n    }\n\n    @Test\n    fun testAlive() {\n        // Here you assert something\n    }\n\n    // More tests come here\n    ...\n}\n```", "```kt\n@Test\nfun testAlive() {\n    ...\n}\n```", "```kt\n@Test\nfun `Tests that alive works`() {\n    ...\n}\n```", "```kt\ncompile group: 'io.vertx', name: 'vertx-web-client', version: $vertx_version\n```", "```kt\nprivate fun get(path: String): HttpResponse<Buffer> {\n    val d1 = CompletableDeferred<HttpResponse<Buffer>>()\n\n    val client = WebClient.create(vertx)\n    client.get(8080, \"localhost\", path).send {\n        d1.complete(it.result())\n    }\n\n    return runBlocking {\n        d1.await()\n    }\n}\n```", "```kt\n\nprivate fun post(path: String, body: String = \"\"): HttpResponse<Buffer> {\n    val d1 = CompletableDeferred<HttpResponse<Buffer>>()\n\n    val client = WebClient.create(vertx)\n    client.post(8080, \"localhost\", path).sendBuffer(Buffer.buffer(body), { res ->\n        d1.complete(res.result())\n    })\n\n    return runBlocking {\n        d1.await()\n    }\n}\n```", "```kt\nprivate fun startServer() {\n    val d1 = CompletableDeferred<String>()\n    vertx.deployVerticle(ServerVerticle(), {\n        d1.complete(\"OK\")\n    })\n    runBlocking {\n        println(\"Server started\")\n        d1.await()\n    }\n}\n```", "```kt\nprivate fun <T> HttpResponse<T>.asJson(): JsonNode {\n    return this.bodyAsBuffer().asJson()\n}\n\nprivate fun Buffer.asJson(): JsonNode {\n    return ObjectMapper().readTree(this.toString())\n}\n```", "```kt\n@Test\nfun `Tests that alive works`() {\n    val response = get(\"/alive\")\n    assertEquals(response.statusCode(), 200)\n\n    val body = response.asJson()\n    assertEquals(body[\"alive\"].booleanValue(), true)\n}\n```", "```kt\n@Test\nfun `Makes sure cat can be created`() {\n   val response = post(\"/api/v1/cats\",\n                \"\"\"\n                {\n                    \"name\": \"Binky\",\n                    \"age\": 5\n                }\n                \"\"\")\n\n   assertEquals(response.statusCode(), 201)\n   val body = response.asJson()\n\n   assertNotNull(body[\"id\"])\n   assertEquals(body[\"name\"].textValue(), \"Binky\")\n   assertEquals(body[\"age\"].intValue(), 5)\n}\n```", "```kt\ncompile group: 'org.postgresql', name: 'postgresql', version: '42.2.2'\ncompile group: 'io.vertx', name: 'vertx-jdbc-client', version: $vertx_version\n```", "```kt\nobject Config {\n    object Db {\n        val username = System.getenv(\"DATABASE_USERNAME\") ?: \"postgres\"\n        val password = System.getenv(\"DATABASE_PASSWORD\") ?: \"\"\n        val database = System.getenv(\"DATABASE_NAME\") ?: \"cats_db\"\n        val host = System.getenv(\"DATABASE_HOST\") ?: \"\"\n\n        override fun toString(): String {\n            return mapOf(\"username\" to username,\n                    \"password\" to password,\n                    \"database\" to database,\n                    \"host\" to host).toString()\n        }\n    }\n\n    override fun toString(): String {\n        return mapOf(\n                \"Db\" to Db\n        ).toString()\n    }\n}\n```", "```kt\nfun CoroutineVerticle.getDbClient(): JDBCClient {\n    val postgreSQLClientConfig = JsonObject(\n            \"url\" to \"jdbc:postgresql://${Config.Db.host}:5432/${Config.Db.database}\",\n            \"username\" to Config.Db.username,\n            \"password\" to Config.Db.password)\n    return JDBCClient.createShared(vertx, postgreSQLClientConfig)\n}\n```", "```kt\nfun JDBCClient.query(q: String, vararg params: Any): Deferred<JsonObject> {\n    val deferred = CompletableDeferred<JsonObject>()\n    this.getConnection { conn ->\n        conn.handle({\n            result().queryWithParams(q, params.toJsonArray(), { res ->\n                res.handle({\n                    deferred.complete(res.result().toJson())\n                }, {\n                    deferred.completeExceptionally(res.cause())\n                })\n            })\n        }, {\n            deferred.completeExceptionally(conn.cause())\n        })\n    }\n\n    return deferred\n}\n```", "```kt\nprivate fun <T> Array<T>.toJsonArray(): JsonArray {\n    val json = JsonArray()\n\n    for (e in this) {\n        json.add(e)\n    }\n\n    return json\n}\n```", "```kt\ninline fun <T> AsyncResult<T>.handle(success: AsyncResult<T>.() -> Unit, failure: () -> Unit) {\n    if (this.succeeded()) {\n        success()\n    }\n    else {\n        this.cause().printStackTrace()\n        failure()\n    }\n}\n```", "```kt\nval router = Router.router(vertx)\nval dbClient = getDbClient()\n...\nrouter.get(\"/alive\").asyncHandler {\n    val dbAlive = dbClient.query(\"select true as alive\")\n    val json = json {\n        obj (\n                \"alive\" to true,\n                // This is JSON, but we can access it as an array\n                \"db\" to dbAlive.await()[\"rows\"]\n        )\n    }\n    it.respond(json)\n}\n```", "```kt\n{\"alive\":true, \"db\":[{\"alive\":true}]}\n```", "```kt\n$ createdb cats_db\n```", "```kt\nprivate val insert = \"\"\"insert into cats (name, age)\n            |values (?, ?::integer) RETURNING *\"\"\".trimMargin()\n```", "```kt\n...\nval db = getDbClient()\nrouter.post(\"/cats\").asyncHandler { ctx ->\n    db.queryWithParams(insert, ctx.bodyAsJson.toCat(), {\n       it.handle({\n          // We'll always have one result here, since it's our row\n          ctx.respond(it.result().rows[0].toString(), 201)\n       }, {\n          ctx.respond(status=500)\n       })\n   })\n}\n```", "```kt\nprivate fun JsonObject.toCat() = JsonArray().apply {\n   add(this@toCat.getString(\"name\"))\n   add(this@toCat.getInteger(\"age\"))\n}\n```", "```kt\npsql -c \"create table cats (id bigserial primary key, name varchar(20), age integer)\" cats_db\n```", "```kt\nconst val CATS = \"cats:get\"\n\nclass CatVerticle : CoroutineVerticle() {\n\n    override suspend fun start() {\n        val db = getDbClient()\n        vertx.eventBus().consumer<JsonObject>(CATS) { req ->\n            ...\n        }\n    }\n}\n```", "```kt\nconst val DOGS  = \"dogs:get\" // Just an example, don't copy it\n```", "```kt\nprivate const val QUERY_ALL = \"\"\"select * from cats\"\"\"\nclass CatVerticle : CoroutineVerticle() {\n\n    private val QUERY_WITH_ID = \"\"\"select * from cats\n                     where id = ?::integer\"\"\".trimIndent()\n...\n}\n```", "```kt\n...\ntry {\n    val body = req.body()\n    val id: Int? = body[\"id\"]\n    val result = if (id != null) {\n        db.query(QUERY_WITH_ID, id)\n    } else {\n        db.query(QUERY_ALL)\n    }\n    launch {\n        req.reply(result.await())\n    }\n}\ncatch (e: Exception) {\n    req.fail(0, e.message)\n}\n...\n```", "```kt\nfun <T> CoroutineVerticle.send(address: String,\n                               message: T,\n                               callback: (AsyncResult<Message<T>>) -> Unit) {\n    this.vertx.eventBus().send(address, message, callback)\n}\n```", "```kt\n...\nrouter.get(\"/cats\").asyncHandler { ctx ->\n    send(CATS, ctx.queryParams().toJson()) {\n        it.handle({\n            val responseBody = it.result().body()\n            ctx.respond(responseBody.get<JsonArray>(\"rows\").toString())\n        }, {\n            ctx.respond(status=500)\n        })\n    }\n}\n...\n```", "```kt\nprivate fun MultiMap.toJson(): JsonObject {\n    val json = JsonObject()\n\n    for (k in this.names()) {\n        json.put(k, this[k])\n    }\n\n    return json\n}\n```", "```kt\n...\nvertx.deployVerticle(CatVerticle())\n...\n```", "```kt\n@Test\nfun `Make sure that all cats are returned`() {\n    val response = get(\"/api/v1/cats\")\n    assertEquals(response.statusCode(), 200)\n\n    val body = response.asJson()\n\n    assertTrue(body.size() > 0)\n}\n```"]