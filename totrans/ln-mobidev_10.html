<html><head></head><body>
        

                            
                    <h1 class="header-title">There Is an API for That!</h1>
                
            
            
                
<p>In this chapter, we will see what we can do to prove our hypotheses by building a mash-up. It takes more effort than just a simple landing page but it takes less time than developing a full application. By combining apps or other resources, you can put a solution together for the problem that you are trying to solve with a minimum amount of effort. This is an interesting approach for at least a proof of concept. Once you have learned the lessons you wanted to learn you could always set up a more robust solution. On the other hand your strategy for your app can be just that- combining resources and launch it as your product or service itself. This applies in particular to apps that offer aggregated information. Alternatively, you can think of apps that require heavy integration with social networks, such as Facebook, Twitter, or YouTube. Social referring is always easier than building a user base completely by yourself, so integrating a social component into your app is always a smart thing to do, but it is particularly interesting if you create a mash-up solution with it.</p>
<p>You can combine various apps and services but there is also something else that could result in very interesting mash-up solutions. Data is available about almost everything and much of this data has been made publicly available through various API's. You can use that data, combine it with other data and visualize the outcome in a different way. For example, you can display the results on a Google map, instead of showing it in a list. The most popular mash-ups do exactly that. They visualize existing data in a different way.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Investigate how mash-ups can help us to prove hypotheses</li>
<li>Have a look at some popular mash-ups</li>
<li>Investigate what APIs and mobile SDKs are available</li>
<li>Prove our hypotheses by building a mobile mash-up solution</li>
<li>Prove our hypotheses using an IFTT recipe</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Succeed or fail fast</h1>
                
            
            
                
<p>A mash-up allows you to succeed or to fail fast. If you fail you can rephrase your hypotheses at an early stage. Using the feedback you get you can build a better app and find out what it takes to build an app that people actually want.</p>
<p>It is also true that, by using APIs or SDKs of third parties you can rely on much larger platforms than yours and since it is proven technology it is less error prone. For example, if you want to integrate payments other than In App purchases you will of course use the existing solution of a payment provider.</p>
<p>You can take advantage of social networks, by providing a single sign on for your app. You could, for example, provide a way for the user to sign up or to login with his Facebook or login account. It lowers the registration barrier, resulting in higher sign up conversions. Not only does the user have to take fewer actions to get on board but you also have access to additional data such as a name and profile photo. Right after the sign up this results in a more personalized experience of the app. We will elaborate on this in <a href="774e65d5-5ac0-4ade-9f9e-cffb2a911441.xhtml" target="_blank">Chapter 11</a>, <em>Onboarding and Registration</em>, about the process of on boarding new users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is in a mash-up solution?</h1>
                
            
            
                
<p>For now, let's have a closer look a mash-ups. What exactly are mash-ups and how does the phenomenon materialize? In general, mash-ups consume specific data from one or more sources, have an alternative presentation, and/or provide additional logic</p>
<p>A mash-up is typically a combination of consuming reusable data, specific complex functionality, presentation, and some new logic. It does not necessarily need to have all of these elements. A mash-up could be a solution that gathers and combines data from multiple sources. Through APIs anyone can consume various types of datasets. The added value of your app could just be the result of the fact that you aggregate data. For example, think of an app that displays all the available jobs for which otherwise you would have to visit over 10 different websites. Data mining and various other techniques can help you to further enrich data.</p>
<p>Mash-ups can also utilize APIs to perform complex functionality (data processing and payment handling) or they can be used to outsource various tasks in the nondigital world. This could be tasks such as 3D printing on demand, delivery of goods or the execution of small tasks performed by humans. Amazon's Mechanical Turk API is a good example of this. Through this API, you can dispatch small tasks to other people. You can think of writing reviews, validating or reviewing user input, or performing research. There are a huge amount of SaaS solutions available and most of them come with an <strong>application-programming interface</strong> (<strong>API</strong>). All this API can be tied together to create something new. They allow developers to test their hypotheses even faster.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Publishing an API</h1>
                
            
            
                
<p>On the other hand, you can also offer an API yourself if you have got some (enriched) data to share. If that is data that others can utilize to build something new, you might want to think of an API as a service that you can charge some money for. If your API is providing some real value, then you can probably make a profitable business out of it. It could have an interesting, recurring revenue model.</p>
<p>Since it may be hard to monetize your app the traditional way, it might be an interesting idea to think of publishing an API related to your app or your app eco system. Many companies, such as SalesForce or Expedia, already get most of their revenues from API subscriptions, so this is an interesting path to explore.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lego or Duplo?</h1>
                
            
            
                
<p>If you compare mash-up solutions with those that are created from scratch, it will be like comparing Duplo with Lego. If you use third-party solutions, then the development of your app will be faster, smarter, and probably cheaper. Small and reusable microservices can easily be assembled into a larger and more complex app. Obviously, playing with Lego is more fun, but you can build a tower much faster using Duplo.</p>
<p class="packt_figure">Instead of diving deeply into all kinds of technical challenges, you can focus on what matters the most. The implementation of the functionality that will result in the <strong>unique value proposition</strong> (<strong>UVP</strong>) for your solution.</p>
<p>There are many different types of mash-ups. Think of consumer mash-ups, business mash-ups, data mash-ups, and logical mash-ups. Do you need specific data? Do you want to offer flights or holidays? Do you need a payment solution? Alternatively, do you need to send bulk SMS, dim the lights, or want to outsource tasks? Guess what? There is an API for that!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">APIs versus SDKs</h1>
                
            
            
                
<p>APIs are interfaces, often made available as a REST service. A <strong>Software Development Kit</strong> (<strong>SDK</strong>) is meant specially for implementing the API on a particular platform, such as iOS or Android. It will make the integration process more smooth. We have already seen an example of this in <a href="0455b0c7-1234-4a39-a89c-b35deb8f92ed.xhtml" target="_blank">Chapter 4</a>, <em>An Agile Workflow In A Nutshell</em>, where we looked at an Android app using Firebase. In that example, you might have noticed a Gradle dependency for Firebase. It is a reference to the Android SDK, which will take care of the communication with the Firebase API. The API itself allows you to perform all operations, but the SDK will save you a lot of time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency management</h1>
                
            
            
                
<p>The nature of APIs and SDKs is that they will be updated often. For this reason, a smart dependency management plan is important. You do not want to update the modules or update the entire code everywhere in your app each time a new version of the SDK has been released.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Android</h1>
                
            
            
                
<p>For Android, you should use external Gradle dependencies, rather than adding library modules to your project. If you are using Android Studio, then you can start using Gradle right away. You will find the listing of dependencies for your app in the <kbd>build.gradle</kbd> file within the app folder of your project. The dependency section would look like this:</p>
<pre>dependencies { 
... 
    compile 'com.android.support:recyclerview-v7:23.1.1' 
    compile 'com.android.support:cardview-v7:23.1.1' 
    compile 'com.squareup.retrofit:retrofit:2.0.0-beta3' 
    compile 'com.squareup.picasso:picasso:2.5.2' 
    compile 'com.squareup.retrofit:converter-gson:2.0.0-beta2' 
    compile 'com.squareup.okhttp:okhttp:2.4.0' 
    compile 'net.hockeyapp.android:HockeySDK:3.6.2' 
} </pre>
<p>As you can see in this example, RetroFit, HockeyApp, and a couple of other dependencies are defined here. You might be familiar with them already. Retrofit and the Gson converter, for example, are solutions for consuming data over HTTP and deserializing the result into an object. While dependencies could also refer to local libraries, it is strongly recommended to use dependencies as illustrated earlier. For more information on Gradle, check the website at <a href="http://gradle.org">http://gradle.org</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">iOS</h1>
                
            
            
                
<p>For iOS (and many other languages and IDEs), you could use Gradle as well. This is particularly interesting and valuable if you work on both the Android and iOS platforms and if you wish to use the same tools for building your apps using build servers such as TeamCity or Jenkins. More on this in <a href="d8f75536-5799-4326-aea8-a187b809e758.xhtml" target="_blank">Chapter 18</a>, <em>Continuous Integration, Delivery and Deployment</em>, about Continuous Delivery.</p>
<p>Another well-known solution, but available to iOS development only, is CocoaPods. It is a dependency manager for iOS projects (Objective C or Swift). It manages third-party libraries by creating a workspace that, besides your own projects will contain a CocoaPods project, where our dependencies will reside.</p>
<p>The <kbd>pod</kbd> file contains the list of dependencies and it looks like this:</p>
<pre>platform :ios, '8.0' 
use_frameworks! 
target 'example-project' do 
    pod 'ZXingObjC', '~&gt;3.0' 
    pod 'JSONJoy-Swift', '~&gt; 1.0.0' 
    pod 'SwiftHTTP', '~&gt; 1.0.0' 
end </pre>
<p>As you can see in this example, the <kbd>pod</kbd> file is, among other pods, referring to the <kbd>Zxing</kbd> library. It is a perfect solution for creating and for scanning bar code images. Installing and configuring <kbd>cocoapods</kbd> is pretty easy. You just type <kbd>gem install cocoapods</kbd> in your terminal app to do so. The next thing to do is to define the <kbd>pod</kbd> file that will contain the references that your project will use. You need to do a <kbd>pod install</kbd> to actually get the dependency libraries. Running this command in your terminal app will add all the dependencies as listed in the <kbd>pod</kbd> file. We will have a closer look at this process in the paragraph where we build our MVP:</p>
<pre><strong>$ gem install cocoapods</strong>
<strong>$ pod install</strong> </pre>
<p>Also worth mentioning here is Carthage. It is an alternative solution to CocoaPods and it is the first dependency manager to work with Swift explicitly. CocoaPods is built with Ruby, where as Carthage is built with Swift. Carthage seems to be a bit more flexible but also more complex to use.</p>
<p>For more information on CocoaPods, you can look at <a href="https://cocoapods.org">https://cocoapods.org</a>. If you would like to know more about Carthage and the differences between CocoaPods and Carthage, you can check out <a href="https://github.com/Carthage/Carthage">https://github.com/Carthage/Carthage</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Available APIs</h1>
                
            
            
                
<p>Data about many different topics and from various sources can be gathered through (open) APIs. You will find them on the websites of many companies delivering SaaS or you can check them out on one of the sites that offers aggregated lists of almost all available APIs.</p>
<p>On <a href="https://www.programmableweb.com/" target="_blank">https://www.programmableweb.com/</a> or <a href="http://mashable.com/" target="_blank">http://mashable.com/</a>, you will find many APIs that you can use for inspiration. You will also find many mash-up solutions there. You can find many APIs that you can use for your app. Most of them are not explicitly intended for mobile apps but as long as the data can be consumed as JSON or as XML then that does not really have to be an issue. On the website, you can search for particular categories, particular data types, or just browse through the latest additions. As you can see, following the weather is always an interesting kind of data source and there are many apps using this data. One example is the app InstaWeather (See <a href="http://instaweather.me/">http://instaweather.me/</a>). In a later paragraph, we will see how we can use these APIs for our MVP:</p>
<div><img class=" image-border" height="453" src="img/51b086ea-f7d9-4438-a337-2c3d6380666e.png" width="467"/></div>
<p>The other places to look for APIs and examples of mash-ups are:</p>
<ul>
<li><a href="http://www.mashable.com">http://www.mashable.com</a></li>
<li><a href="https://www.data.gov">https://www.data.gov</a></li>
<li><a href="http://www.opendatanetwork.com">http://www.opendatanetwork.com</a></li>
<li><a href="https://data.sfgov.org">https://data.sfgov.org</a></li>
<li><a href="http://data.worldbank.org/developers">http://data.worldbank.org/developers</a></li>
<li><a href="https://dev.socrata.com">https://dev.socrata.com</a></li>
<li><a href="http://developer.nytimes.com">http://developer.nytimes.com</a></li>
</ul>
<p>If you know of a data source for which no API is available, then you can think of an alternative such as (site) scraping. It is an approach that many sites, offering aggregated content (jobs, real estate, and insurance), use. Site scraping can be tricky though. It could be very error prone, but sometimes it is the only way to get things done quickly or to obtain specific data. In particular for your first experiments (MVP) it is an interesting method to use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An iOS app proving our hypotheses, MoviUber</h1>
                
            
            
                
<p>So far for the theory. It is time to build our MVP. This MVP combines data from various sources to demonstrate how you can create a valuable app real quickly. In this section, we will build an app for iOS that can be used to explore locations of well-known movies. It will demonstrate the concept of using APIs and SDKs to prove our hypotheses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hypothesis</h1>
                
            
            
                
<p>We cannot get started without defining our hypothesis first. All people like movies. Some people like them more than others. Let's assume that movie freaks love to travel to cities such as San Francisco to explore the city and visit the locations where well-known movies have been filmed. Many locations cannot easily be reached by public transport. To get there, they will have to use Uber.</p>
<p>So this app is about traveling in San Francisco and visiting movie hotspots using Uber. It consumes data, provides a new representation of the corresponding data (maybe on a map even), and connects a real-life service, such as Uber, to it. Maybe we can even enrich the data a little by looking up the movie title from the <strong>Internet Movie DataBase</strong> (<strong>IMDB</strong>). Let's call this app MoviUber. For this app, we will not elaborate too much about the business model. We just want to figure out if we can connect the dots here. Would it not be cool if we can make this work? What do we need to do to make that happen?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Validating the idea through customer interviews</h1>
                
            
            
                
<p>We need to know first if it makes sense creating this mash-up. And maybe you want to give your own twist to the concept first and then, as an exercise, try to validate the idea. See if you can find someone, who loves movies and who is already using Uber.</p>
<p>Tell him or her about the concept and ask what he or she thinks about it. Ask open questions only. If you ask a friend, "Do you think this will be a fantastic idea?", you will probably get a positive answer anyway. While this is nice to hear, it will not help you to get the idea validated.</p>
<p>Anyway, if he or she is very enthusiastic about the concept, then perhaps some new ideas or features will come up or maybe you get some great insights why this whole app idea is actually a very bad plan. You never know.</p>
<p>Since this chapter is specifically about creating a mash-up solution, we will assume the idea has been validated thoroughly. It is a brilliant plan and we have gathered positive feedback through customer interviews. Let's build an app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Let's build an app</h1>
                
            
            
                
<p>To get started, let's define the ingredients for our MVP. Here it is:</p>
<ul>
<li>Movie locations (duh), shown as a list to browse through all movies and locations.</li>
<li>An Uber button, to call a driver to get us there.</li>
<li>The IMDB is an optional ingredient but it would be nice to have. We can use this to display some additional information about a particular movie.</li>
<li>A map will be a great feature that can be used for planning if the user wants to go from one site to another.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Movie locations</h1>
                
            
            
                
<p>Using the San Francisco data API, powered by Socrata, we can get movie locations in San Francisco. To get an impression, you can browse through the dataset you will find at this location: <a href="https://data.sfgov.org/Culture-and-Recreation/Film-Locations-in-San-Francisco/yitu-d5am">https://data.sfgov.org/Culture-and-Recreation/Film-Locations-in-San-Francisco/yitu-d5am</a>. You want to go where Sharon Stone went? You can look it up in this dataset.</p>
<p>But instead of downloading the dataset here, it would be more convenient to have access to the data through an API. That is something that can be found here: <a href="https://dev.socrata.com/foundry/data.sfgov.org/wwmu-gmzc">https://dev.socrata.com/foundry/data.sfgov.org/wwmu-gmzc</a>. After doing some research, it turns out that there is even an SDK. That is even better. Soda-Swift is a native Swift library that can access Socrata open data servers. You will find it on GitHub at: <a href="https://github.com/socrata/soda-swift">https://github.com/socrata/soda-swift</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Uber</h1>
                
            
            
                
<p>Uber offers an API and SDKs for various platforms, including an iOS Swift library, available on GitHub. Check it out at <a href="https://github.com/uber/rides-ios-sdk">https://github.com/uber/rides-ios-sdk</a> . The API is described at <a href="https://developer.uber.com/docs/tutorials-rides-api">https://developer.uber.com/docs/tutorials-rides-api</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">IMDB</h1>
                
            
            
                
<p>It seems there is no IMDb API yet, but there is the OMDb API. This API is a free web service for obtaining movie information. You can find it at <a href="http://www.omdbapi.com">http://www.omdbapi.com</a>.</p>
<p>Finally, for the map we will be using Apple maps. All you need for that is the MapKit framework. Awesome. What do we need to do next?</p>
<p>For this, we will download the SDK. Also, we will download the Socrata sample app from <a href="https://github.com/socrata/soda-swift">https://github.com/socrata/soda-swift</a>. We will use the sample app for our MVP. We will modify a few things such as the data token and dataset. To obtain a token, you need a developer's account at Socrata first. You can register for free at <a href="https://dev.socrata.com/foundry/data.sfgov.org/wwmu-gmzc">https://dev.socrata.com</a>. Next you need to create an app on their website. Open the Socrata-Swift project in Xcode and from the SODASample project open the QueryViewController. Modify the domain and token for the client:</p>
<pre><strong>let client = SODAClient(domain: "data.sfgov.org", token: "&lt;your token&gt;")</strong> </pre>
<p>In the <kbd>refesh</kbd> method, you need to modify the dataset for the query and change the order field to <kbd>title</kbd>:</p>
<pre>func refresh (sender: AnyObject!) { 
...         
        let cngQuery = client.queryDataset("wwmu-gmzc")         
        cngQuery.orderAscending("title").get { res in 
            switch res { 
            case .Dataset (let data): 
                self.data = data 
... 
        } 
    } </pre>
<p>In the <kbd>cellForRowAtIndexPath</kbd> function, change the fields of the item to <kbd>title</kbd> and <kbd>locations</kbd> as shown in the following code:</p>
<pre>  override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt;   
    UITableViewCell { 
 
        let c = tableView.dequeueReusableCellWithIdentifier(cellId) as UITableViewCell! 
         
        let item = data[indexPath.row] 
        let name = item["title"]! as! String         
        c.textLabel?.text = name 
 
        if (item["locations"] != nil){ 
            let street = item["locations"]! as! String 
            c.detailTextLabel?.text = street 
        }  
        return c 
    } </pre>
<p>Now, when you run the app, it will display a nice list of movies and locations on the first tab. To display them as well on the map on the second tab, we need to do a little extra:</p>
<div><img class=" image-border" height="294" src="img/4aed3958-bcc6-40d5-8d3a-258cf6080731.png" width="178"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying locations on a map</h1>
                
            
            
                
<p>To display the locations on the map as pin points, we need values for longitude and latitude, but unfortunately we have only a (vague) address description. We need to convert the address to an actual location. To do so, you need to open the MapViewController and find the <kbd>updateWithData</kbd> function that we will modify by using the <kbd>CLGeocoder</kbd>. This class is very smart at converting addresses to actual locations with longitude and latitude values.</p>
<p>For each location, we will determine what the longitude and latitude values are for a particular address. Once we have found one of these or placemarks for a given location, we will create a pin point for it and add to the map. Finally, we will navigate the user to San Francisco on the map, so we can actually see the pinpoints.</p>
<p>The code will look like this:</p>
<pre>func updateWithData(data: [[String: AnyObject]]!, animated: Bool) {         
    self.data = data         
     if (!isViewLoaded()) { 
       return 
     } 
  
     if mapView.annotations.count &gt; 0 { 
       let ex = mapView.annotations 
       mapView.removeAnnotations(ex) 
     } 
         
     var anns : [MKAnnotation] = [] 
     for item in data { 
        var location = item["locations"]  as? String 
        if (location != nil){  
           location  = location! + " San Fransisco, CA" 
           print(location)  
           let geocoder:CLGeocoder = CLGeocoder(); 
           geocoder.geocodeAddressString(location!) { (placemarks:       
             [CLPlacemark]?, error: NSError?) -&gt; Void in 
                     
           print(placemarks?.count)  
           if placemarks?.count &gt; 0 { 
           let topResult:CLPlacemark = placemarks![0]; 
           let placemark: MKPlacemark = MKPlacemark(placemark:  
             topResult); 
  
           let a = MKPointAnnotation() 
           a.coordinate = placemark.coordinate; 
           a.title = item["title"] as! NSString as String 
           a.title = a.title! + " " + (item["locations"] as!  
             NSString as String) 
           anns.append(a);  
                         
           if (error == nil &amp;&amp; a.coordinate.latitude != 0 &amp;&amp;       
             a.coordinate.longitude != 0){ 
                self.mapView.addAnnotation(a); 
           } 
                         
    } 
  }                 
        let w = 1.0  
        let r = MKCoordinateRegionMakeWithDistance(       
          CLLocationCoordinate2D(latitude: 37.79666680533*w,  
          longitude: -122.39826411049*w), 40000, 40000) 
        self.mapView.setRegion(r, animated: false) 
    } 
} </pre>
<p>This is what the map will look like:</p>
<div><img class=" image-border" height="393" src="img/86683e76-2dcc-4fe0-81f4-37bd892fa7ad.png" width="261"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Uber integration</h1>
                
            
            
                
<p>We have a map with pin points now. We can start with the integration of Uber functionality. We will keep it simple by just displaying an Uber ride request button in our app.</p>
<p>Create a new app at <a href="https://developer.uber.com">https://developer.uber.com</a>. Log in or sign up for Uber first, if you have not done so yet:</p>
<div><img class=" image-border" height="284" src="img/a2d5031f-9ec7-423f-97ce-ebb1bf3dcea5.png" width="381"/></div>
<p>Give a name and a description for your app and save the changes. It will reveal a client ID that you need for implementing Uber functionality in your app. You can find the Uber Swift SDK on GitHub at <a href="https://github.com/uber/rides-ios-sdk">https://github.com/uber/rides-ios-sdk</a>, but you can also use CocoaPods to include it with your app, which is the recommended way of integrating the Uber functionality with your app.</p>
<p>If you have not done this before, install CocoaPods first:</p>
<pre><strong>$ gem install cocoapods</strong></pre>
<p>In the console app, go to the folder where the Soda Swift project is. To create a new <kbd>pod</kbd> file type the following:</p>
<pre><strong>$ pod init</strong>  </pre>
<p>Open the <kbd>pod</kbd> file that has been created and modified for you, so it will load the UberRides project for us into the workspace:</p>
<pre>    <strong>use_frameworks!</strong>
    <strong>target 'SODAKit' do</strong>
    <strong>end</strong>
    <strong>target 'SODATests' do</strong>
    <strong>end</strong>
    <strong>target 'SODASample' do</strong>
    <strong>   pod 'UberRides'</strong>
    <strong>end</strong>
  </pre>
<p>Next, install the dependency using this command:</p>
<pre><strong>$ pod install</strong></pre>
<p>Modify the <kbd>info.plist</kbd> content by right-clicking on the file and choosing Open as, Source code. Add these key-value pairs to the dictionary and add your Uber client ID, which you can find on the Uber developers site:</p>
<pre>&lt;key&gt;UberClientID&lt;/key&gt; 
    &lt;string&gt;your uber client id&lt;/string&gt; 
    &lt;key&gt;UberCallbackURI&lt;/key&gt; 
    &lt;string&gt;&lt;/string&gt; 
    &lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt; 
    &lt;array&gt; 
        &lt;string&gt;uber&lt;/string&gt; 
    &lt;/array&gt; </pre>
<p>Modify the <kbd>AppDelegate</kbd> file in such a way that it will use the sandbox mode of Uber for testing. It probably will be somewhat inconvenient to be picked up at your location each time you test the app. Import <kbd>UberRides</kbd> and enable the sandbox mode in the <kbd>didFinishLaunchWithOptions</kbd> function:</p>
<pre>import UIKit 
import UberRides 
 
@UIApplicationMain 
class AppDelegate: UIResponder, UIApplicationDelegate { 
 
  var window: UIWindow?  
 
  func application(application: UIApplication,    
   didFinishLaunchingWithOptions launchOptions: [NSObject:  
    AnyObject]?) -&gt; Bool { 
                 
     // If true, all requests will hit the sandbox     
     Configuration.setSandboxEnabled(true)         
     return true 
   } </pre>
<p>In QueryViewController, add new imports for <kbd>MapKit</kbd> and <kbd>UberRides</kbd>, just below the import of UIKit:</p>
<pre>import MapKit 
import UberRides 
import CoreLocation </pre>
<p>We need to modify the <kbd>didSelectRowAtIndexPath</kbd> function a bit. If the user clicks on any of the rows, a button will be shown that can be clicked to initiate a ride. Both the code and the UI require some beautification, but that is beyond the scope of the MVP. For that purpose, the selected item's longitude and latitude value will be retrieved, this time to tell Uber where the user wants to go to (the drop-off location). We do not specify a pick up location. By default, the Uber SDK will use the user's current location. That may not always be sufficiently accurate, but for an MVP it is just fine.</p>
<p>The Uber Rides SDK checks the value of <kbd>locationServicesEnabled()</kbd> in <kbd>CLLocationManager</kbd>, which must be true to be able to retrieve the user's current location:</p>
<pre>override func tableView(tableView: UITableView!,    
  didSelectRowAtIndexPath indexPath: NSIndexPath!) { 
       
  let item = data[indexPath.row] 
  var location = item["locations"]  as? String; 
  if (location != nil){ 
 
      location  = location! + " San Fransisco, CA" 
      let geocoder:CLGeocoder = CLGeocoder(); 
 
      geocoder.geocodeAddressString(location!) { (placemarks:     
       [CLPlacemark]?, error: NSError?) -&gt; Void in 
 
        if placemarks?.count &gt; 0 { 
 
          let topResult:CLPlacemark = placemarks![0]; 
          let placemark: MKPlacemark = MKPlacemark(placemark: 
           topResult); 
                     
          if (error == nil &amp;&amp; placemark.coordinate.latitude != 0 &amp;&amp;  
           placemark.coordinate.longitude != 0){ 
                         
             let behavior = RideRequestViewRequestingBehavior(   
              presentingViewController: self) 
 
             let dropOffLocationlocation = CLLocation( 
              latitude: placemark.coordinate.latitude,  
              longitude: placemark.coordinate.longitude) 
 
             let parameters = RideParametersBuilder().  
               setDropoffLocation( dropOffLocationlocation).build() 
 
             let button = RideRequestButton(rideParameters:  
               parameters, requestingBehavior: behavior) 
 
             self.view.addSubview(button) 
           } 
        } 
     }         
} </pre>
<p>In the end, the method shown adds an Uber button to the view. This is including the knowledge of where the user currently is and where he wants to go. This allows the user to click on a button in the app to order a ride and it contains all the knowledge Uber needs to know.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enriching the data</h1>
                
            
            
                
<p>Finally, as an optional exercise and if you want to enrich the movie location data, you can get some extra movie info and an image of the movie from the OMDb API. Since we know the title of the movie, we can perform a query on the API. The response, nicely formatted as JSON, teaches us something about the plot, actors and it even gives us the URL to an IMDB image. We can show this in the app to inform the user what the movie is all about.</p>
<p>To obtain an API key go to <a href="http://www.omdbapi.com">http://www.omdbapi.com</a> and click on the API key link. You can get one for free if you register with your email address. You will receive an email with your own API-key and an activation link. After activation you can add your API key in the request.: <a href="http://www.omdbapi.com/?t=Basic+instinct&amp;y=&amp;plot=short&amp;r=json&amp;apikey=%3Capi%20key%3E">http://www.omdbapi.com/?t=Basic+instinct&amp;y=&amp;plot=short&amp;r=json&amp;apikey=&lt;api key&gt;</a>.</p>
<p>The response for this query looks like this:</p>
<pre><strong>"Title":"Basic Instinct","Year":"1992","Rated":"R","Released":"20 Mar 1992","Runtime":"127 min","Genre":"Drama, Mystery, Thriller","Director":"Paul Verhoeven","Writer":"Joe Eszterhas","Actors":"Michael Douglas, Sharon Stone, George Dzundza, Jeanne Tripplehorn","Plot":"A violent, suspended police detective investigates a brutal murder, in which a seductive woman could be involved.","Language":"English","Country":"France, USA","Awards":"Nominated for 2 Oscars. Another 5 wins &amp; 18 nominations.","Poster":"http://ia.media-imdb.com/images/M/MV5BMTcxMjY2NzcyMV5BMl5BanBnXkFtZTYwMjAxNTQ5._V1_SX300.jpg","Metascore":"41","imdbRating":"6.9","imdbVotes":"131,796","</strong>  </pre>
<p>By bundling data from multiple datasets, by displaying them in an alternative way (in a list and on a map on a mobile device), and by adding Uber functionality making traveling from one spot to another more convenient, we have created a really cool mash-up iOS app. To see where this could be going to, including the OMDb data integration, you can download and examine the full app code from Packt.</p>
<p>We had to do some coding to build this MVP. You might wonder if there is no way to get things proved without coding. And there is. We are not talking about user interviews or the analyzing metrics here. We can also use <strong>If This Then That</strong> (<strong>IFTT</strong>) to build an MVP. It allows us to automate simple but often interesting tasks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Look! No code. Prove your hypotheses with IFTT</h1>
                
            
            
                
<p>Services such as IFTT add a logical component to the possibilities of APIs. If something happens for a particular data feed (channel), then something else needs to be done. It works well for <strong>Internet of Things</strong> (<strong>IoT</strong>) related concepts in particular, but you can connect almost any service that you like. You can check it out for yourself at <a href="http://iftt.com/?reqp=1&amp;reqr=" target="_blank">http://iftt.com/?reqp=1&amp;reqr=</a>.</p>
<p>Using IFTT requires little to no coding, making it the perfect environment to automate small tasks (the so-called recipes). It could also help you to validate your hypotheses, before you actually build the thing. Let's try this. If you have not signed up for IFTT yet, then do so before you continue. We want to prove our hypotheses, which for the sake of simplicity narrows down to the following:</p>
<div><img class=" image-border" height="159" src="img/9fec1d0b-e167-4dcd-bfde-8dc01b635607.png" width="134"/></div>
<p>Users want to be reminded to put a towel in their bag. That is particularly important on #towel day (May 25) but also when they go to the airport, where UFOs can easily land. Just wave to the UFOs using your towel, if you want them to pick you up.</p>
<p>Eh, what did you just read? If you think this is a lame example, or if it does not make sense to you, I suggest you read the Hitchhikers Guide to Galaxy first. You can also check it out on <a href="http://www.towelday.org">http://www.towelday.org</a>. Anyway, let's examine what IFTT is about and how we can use it to prove this hypothesis:</p>
<div><img class=" image-border" height="273" src="img/8aa9a32e-f06b-4e7c-acf9-a69241dcfd53.png" width="264"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Recipes, channels, and triggers</h1>
                
            
            
                
<p>Creating a new recipe is simple. For our MVP, the user location will be the trigger. In this example, we will be using the IFTT Android app.</p>
<p>We choose the Android location as the channel and we choose You enter an area as the trigger:</p>
<div><img class=" image-border" height="420" src="img/7a776958-c0df-4ff7-8432-440438895d46.png" width="521"/></div>
<p>Next, you need to define the particular location, which is the nearest airport. In my case, it is Rotterdam Airport:</p>
<div><img class=" image-border" height="467" src="img/201814f9-4ceb-4895-9080-cfbb253e29c8.png" width="438"/></div>
<p>Whenever the user enters this area, we want to be notified. Let's use Twitter as the channel to send a message about the event. We will get a direct message from Twitter whenever this event happens:</p>
<div><img class=" image-border" height="240" src="img/1e4eee52-e4d0-4346-b7c1-c1c913c472e4.png" width="394"/></div>
<p>And we are done. It technically works for yourself or for others, if you share the recipe. It is that easy to set something up that could help to prove your hypotheses. If you have completed the validation process, you can always build a real app that can perform the same task.</p>
<p>There are many other recipes that you can think of. For example, if you have a smart thermostat, you can lower the temperature, since you are at the airport anyway. Alternatively, you can have a look at this recipe; for example, "Send an email when you land" at <kbd>https://ifttt.com/recipes/134835-send-an-email-when-you-land</kbd>. Without any extra effort, your relatives will know that you are safe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we saw how APIs and mash-ups can help us to prove our hypotheses. With a minimal amount of effort, we can create an MVP. Before we could use only APIs for consuming and combining data, but nowadays we can also use them to outsource tasks. You can think of image recognition, 3D printing, delivery or a task performed by humans.</p>
<p>We saw what mash-up solutions are and what types of mash-up exist. We created an iOS MVP app that demonstrates the idea of combining multiple API's.</p>
<p>Finally, we looked at the services provided by IFTT, which, depending on your needs, is probably the fastest way to prove your hypothesis first and then build the actual app later. There are plenty of recipes available at IFTT that you could use, or you can create your own. We also discussed the benefits from integrating the APIs and SDKs from social networks, such as Facebook and Twitter.</p>
<p>In the upcoming chapter, we will have a closer look at the integration of social networks and how this affects the on boarding process in particular. You will read more about this in the next chapter about the on boarding and registration process.</p>


            

            
        
    </body></html>