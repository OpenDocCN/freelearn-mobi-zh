- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Augmented Reality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Made popular with Niantic’s *Pokemon GO* and on Snapchat filters, **Augmented
    Reality** (**AR**) is a way of blending digital elements with the real world.
    Specifically, it is a technology that superimposes a computer-generated image
    on a user’s view of the real world, hence providing a composite view, meaning
    that both the real world and then digital elements put on top of it are displayed
    to the player.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how to set up our project to utilize AR for
    both Android and iOS devices and how we can customize them. This project will
    be a simple AR project in which the player can look at various surfaces in the
    game environment and spawn objects on top of them. The goal of this chapter will
    be to explore the basic concepts of AR and see how they can be used in a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be split into several topics. It will contain a simple, step-by-step
    process from beginning to end. Here is the outline of our tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project for AR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting surfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the AR environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning objects in AR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of AR technology
    and how to create a basic AR project. Whether you’re a beginner or an experienced
    developer, this chapter will provide you with a solid foundation for further exploration
    and experimentation with AR which should come useful not only for mobile development
    but also for those looking to get experience with the same technology used in
    headsets from Meta as well as Apple's Vision Pro.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the **Unity Editor system requirements** section. To deploy your project, you
    will need an Android or iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project for AR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start adding notifications to our project, we will need to add
    three packages that Unity makes available to enable AR for both iOS and Android
    devices. In our case, we are going to be utilizing both ARCore and ARKit to create
    our project, and the AR Foundation package to act as an intermediary so we can
    use both ARCore and ARKit while using a similar connection. Since this is a brand
    new way to create projects, we will actually create a new Unity project to demonstrate
    how to use it. Please follow the steps given here:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, open Unity Hub on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From startup, we’ll opt to create a new project by clicking on the **New** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, under `Mobile AR`), and under **Templates**, make sure that **3D** is
    selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Creating a 3D project](img/B18868_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Creating a 3D project
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, click on **Create Project** and wait for Unity to load up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Unity Editor, go to **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it hasn’t been set already, click on the **In Project** drop-down menu from
    the toolbar of the **Packages** menu and select **Unity Registry**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From here, go to the search bar in the top right and type in `XR`. From there,
    you will need to select either **ARKit XR Plugin** if you want to support iOS
    devices or **ARCore XR Plugin** for Android, and click **Install**. Afterward,
    scroll down the available options until you reach **AR Foundation** and select
    it. Once there, click the **Install** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Installing packages](img/B18868_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – Installing packages
  prefs: []
  type: TYPE_NORMAL
- en: We now have all of the packages we need so we can exit **Package Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While AR Foundation does most things that you’d want to do with AR, there are
    a few things that are for iOS or Android only. For more information on what AR
    Foundation can do and what ARCore and ARKit provide individually, check out [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html#platform-support](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html#platform-support).
  prefs: []
  type: TYPE_NORMAL
- en: Next, open up the **Build Settings** menu by going to **File** | **Build Settings**.
    From there, change your platform to either **iOS** or **Android** and click on
    the **Switch Platform** button. Afterward, click on the **Player** **Settings...**
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, complete *step 10* if you are planning on using iOS or *step 11* if you
    are planning on using Android, or complete both steps if you plan on using both
    iOS and Android.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using iOS, make sure that, in the iOS **Platform Settings** section,
    the **Requires ARKit support** option is checked as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For those using Android, go to the Android **Player Settings...** and under
    **Other Settings**, go to **Rendering** and uncheck the **Auto Graphics API**
    option. Then, under the **Graphics APIs** section, select the **Vulkan** option
    and press the **–** button to remove it from the list. Then, scroll down and uncheck
    the **Multithreaded** **Rendering** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Android Player Settings setup](img/B18868_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – Android Player Settings setup
  prefs: []
  type: TYPE_NORMAL
- en: The reason we have to disable this functionality is that, as of the time of
    writing, it is not compatible with ARCore. You’ll also want to set **Minimum API
    Level** to **Android 7.0 ‘Nougat’ (API level 24)** or higher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When working on ARCore projects in Unity, it’s recommended that you enable the
    ARM64 target architecture. If your app only supports the 32-bit ARMv7 architecture,
    it may not work properly on 64-bit devices, and it may not be available for download
    from the Google Play Store. This is because some 64-bit devices don’t support
    32-bit ARCore libraries. So, to avoid any issues, it’s best to enable the ARM64
    target architecture in your Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Under **Configuration**, set **Scripting Backend** to **IL2CPP**. Next, under
    **Target Architectures**, enable the **ARM64** option.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Changing Target Architectures](img/B18868_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – Changing Target Architectures
  prefs: []
  type: TYPE_NORMAL
- en: Now, from the **Player Settings...** menu, select the **XR Plugin Management**
    option, and then, under **Plug-in Providers**, check the **ARCore** field, and
    for iOS, check the **ARKit** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Enabling ARCore](img/B18868_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Enabling ARCore
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve taken care of all of the settings needed to support our project
    and have it export correctly!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have included AR Foundation, we can now create a basic scene for
    a VR project.
  prefs: []
  type: TYPE_NORMAL
- en: Basic setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the player can be anywhere when the game starts, we can’t use a camera
    in the traditional sense, so we will start by removing the original one. Follow
    the steps given here:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Hierarchy** panel, select the **Main Camera** object and delete it
    by right-clicking and selecting **Delete** or pressing the *Delete* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two key objects that we will need to create before we can start implementing
    our own features: **AR Session** and **AR** **Session Origin**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in the **Hierarchy** panel and select **XR** | **AR Session**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Creating an AR session](img/B18868_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – Creating an AR session
  prefs: []
  type: TYPE_NORMAL
- en: '**AR Session** is what controls the life cycle of any AR experience, which
    allows us to enable or disable AR features depending on the platform we are working
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**AR Session** is also responsible for telling you whether your device supports
    AR. For information on handling this, check out [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/index.html#checking-for-device-support](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/index.html#checking-for-device-support).'
  prefs: []
  type: TYPE_NORMAL
- en: Create an **AR Session Origin** object by right-clicking and selecting **XR**
    | **AR** **Session Origin**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**AR Session Origin** is used to scale and offset virtual content while the
    game itself is playing. You may notice that the object has a child, **AR Camera**,
    which is the camera that will follow the game as it is running.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we deploy to the device to ensure everything is working correctly, let’s
    add a cube to our scene so we can see that it is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the **Scene** view if you haven’t done so already. Then, from the
    top menu, click on **GameObject** | **3D Object** | **Cube**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 15.7 – Creat\uFEFFing a cube](img/B18868_15_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Creating a cube
  prefs: []
  type: TYPE_NORMAL
- en: Now, build your project and put the game on the device in the same manner as
    discussed in [*Chapter 2*](B18868_02.xhtml#_idTextAnchor087), *Project Setup for
    Android and* *iOS Development*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For iOS users, you may notice when you build the project, it will tell you that
    the project is lacking a `.xml` file. If this appears, click on the **Yes, fix
    and build** option when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: For Android users, you may need to install the Google Play Services for AR if
    it is not installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon running your project, give access to the camera if needed and open the
    game. Once the project shows your environment, step back as the game starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Our first AR result](img/B18868_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Our first AR result
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we have to step back to see the cube is that the position of
    all objects is based on the area the phone was physically at when the game started.
    The cube is also quite large because, at a default scale of 1,1,1, that means
    that it is 1 meter (or around 3.3 feet) wide on each side in relation to real-sized
    objects. We obviously don’t want to require the user to step back upon starting
    the game so we will need to keep track of where usable surfaces are in our environment,
    which is what we will be doing next.
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect surfaces within our real-world environment, we will need to make
    use of a new component, **AR Plane Manager**. This component allows us to create,
    remove, or update GameObjects in our scene based on the surfaces within the real-world
    environment. The following steps will automatically create invisible planes with
    colliders that we could possibly use for gameplay reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We no longer need the original cube we created, so we can delete it from the
    scene by right-clicking it and selecting **Delete** or by selecting it and pressing
    the *Delete* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** panel, select the **AR Session Origin** object. From
    there, add the **AR Plane Manager** component to it by clicking on the **Add Component**
    button at the bottom of the **Inspector** window and then typing in the name of
    the component and pressing *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we will have surfaces being generated to our scene while being
    run, but for things such as debugging, it would be a good idea to visually see
    the planes that are being generated. So, that’s what we will do next using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the top menu, go to **GameObject** | **XR** | **AR** **Default Plane**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This object has several different components that are used in creating a visual
    plane; of note, are the **AR Plane** and **AR Plane Mesh Visualizer** components.
    **AR Plane** represents a plane detected by the AR device, and **AR Plane Mesh
    Visualizer** is in charge of using the data from **AR Plane** to modify the **MeshFilter**
    and **MeshCollider** components to overlay the detected wall, and the **Line Renderer**
    component to display the boundaries. The **Mesh Renderer** component will draw
    the information displayed from these modifications.
  prefs: []
  type: TYPE_NORMAL
- en: From the `Prefabs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop the `Prefabs` folder to turn it into a Prefab. If it is done
    correctly, you should notice the GameObject’s text in the **Hierarchy** window
    is now blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Creating a Prefab](img/B18868_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Creating a Prefab
  prefs: []
  type: TYPE_NORMAL
- en: Once created, you can delete the **AR Default Plane** object in the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **AR Session Origin** object. Click the **Add Component** button
    and add an **AR Plane Manager** component. Afterward, drag and drop the **AR Default
    Plane** Prefab into the **Plane Prefab** property of the **AR Plane** **Manager**
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Assigning the Plane Prefab](img/B18868_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Assigning the Plane Prefab
  prefs: []
  type: TYPE_NORMAL
- en: This will tell **Plane Manager** that, any time it detects a new plane within
    the scene, it should spawn a Plane Prefab and have it draw the details for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your project and build your game again. Once it is running on your device,
    walk around your room, moving the camera as you do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Plane creation in AR](img/B18868_15_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – Plane creation in AR
  prefs: []
  type: TYPE_NORMAL
- en: The longer you stay within an area with movement, the longer the phone will
    have to build a more realistic depiction of the surfaces in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to open the Prefab we created and modify how your planes will be visualized!
  prefs: []
  type: TYPE_NORMAL
- en: It’s great that we can now see things happening in the game environment, but
    we currently have no way to actually interact with the world—that is what we will
    be looking into in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the AR environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the ways that we can have the player interact with the world is by allowing
    them to spawn objects within the scene to help players see where items will spawn.
    We can create an indicator to show where they will actually spawn to. Let’s look
    at the steps to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a quad using **GameObject** | **3D Object** | **Quad**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quads represent a plane, the simplest type of geometry. In our case, we will
    use the quad as an indicator to the player where they will be spawning an object
    if they tap on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: With the quad selected, go to the `(0,0,0)`, `90`, and `(0.2,0.2,1)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We made the quad smaller to be 20 centimeters long and rotated it so it could
    represent a floor better. We do not want these values to change but we will eventually
    want to move and rotate this object to follow our player when they move the camera.
    To protect this data, we can instead create a parent object for it. That way,
    whenever the parent moves or rotates, the child will move and rotate in the same
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty GameObject by selecting `Placement Indicator`. Then, go to the
    `(0,0,0)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Hierarchy** window, drag and drop the **Quad** GameObject on top
    of the **Placement Indicator** object to make it a child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 15.12 – Creating the Placement Indi\uFEFFcator object](img/B18868_15_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – Creating the Placement Indicator object
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an object to work with, we need some way to figure out where
    the player’s camera is facing so we can move the object. We can do this through
    the use of a new component, **AR** **Raycast Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: From the **Hierarchy** window, select the **AR Session Origin** object. From
    there, add the **AR Raycast Manager** component to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **AR Raycast Manager** component exposes the ability to raycast to AR Foundation.
    This will allow us to perform a Raycast within the physical environment that we
    are in. A Raycast, also known as hit testing, allows us to create a ray, which
    is an invisible line that allows us to check whether there is something that collides
    from its point of origin and direction. This is used oftentimes in games for things
    such as checking whether a bullet would hit the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this setup done, let’s see how we can work with these components
    in code and see how we can use the information to place AR objects within real-world
    spaces using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `Assets` folder. From there, create a new folder called `Scripts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go inside the `Scripts` folder and create a new C# script called `PlaceARObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the file, add the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following properties to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to initialize the properties in the `Start` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to replace our `Update` function and use `LateUpdate` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding snippet, we are using an `UpdateIndicator` function that currently
    doesn’t exist, so let’s add that next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and return to the Unity Editor. Attach the `PlaceARObject` script
    to the **Placement** **Indicator** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Export your game to your device of choice and verify that it is working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.13 – Placement Indicator in AR](img/B18868_15_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – Placement Indicator in AR
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the plane will now move and rotate so that it is always facing
    us! You may notice the plane has a flickery texture. This is due to the z-fighting
    concept we discussed previously in [*Chapter 4*](B18868_04.xhtml#_idTextAnchor165),
    *Resolution-Independent UI*. Basically, both objects have the same position so
    it’s up to Unity to decide what order to draw them in. We can fix this by placing
    the quad slightly above the plane’s position, which we will do now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `UpdateIndicator` function to use the following code at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the script and export the game again. As you can see, now the quad is
    placed cleanly above the given surface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.14 – Adjusted Placement Indicator](img/B18868_15_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14 – Adjusted Placement Indicator
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an indicator of sorts, let’s make it so we can actually spawn
    an object in AR.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning objects in AR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to spawn an object in AR would be to make it so that when the
    player taps on the screen, it will spawn an object where our **Placement Indicator**
    object is. But before we do that, we first need to make an object that we’d want
    to create within the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps given here:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a sphere by going to **GameObject** | **3D Object** | **Sphere**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `(0,0,0)` and set `(0.2,0.2,0.2)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Rigidbody** component to the sphere by going to **Component** | **Physics**
    | **Rigidbody**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By adding the **Rigidbody** component, we are letting Unity know that we want
    this object to be affected by things such as gravity and react to collision events
    and forces being applied to it. At this point, you could customize the object
    as much as you’d like, change the mesh and collider, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `Prefabs` folder. Create a Prefab of our sphere by dragging and dropping
    it from the **Hierarchy** window to the **Project** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 15.15 – Creatin\uFEFFg a 3D object to spawn](img/B18868_15_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15 – Creating a 3D object to spawn
  prefs: []
  type: TYPE_NORMAL
- en: Now that the object is a Prefab, we can delete it from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `PlaceARObject` script and add the following property to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update the `LateUpdate` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and return to the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Hierarchy** window, select the **Placement Indicator** object. From
    the **Inspector** window, set the **Object To Spawn** property to our **Sphere**
    Prefab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 15.16 – Se\uFEFFtting the object to spawn](img/B18868_15_16.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 – Setting the object to spawn
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your project and build it to your device, and tap the screen to have spheres
    spawn onto the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.17 – Objects spawning in our AR environment](img/B18868_15_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.17 – Objects spawning in our AR environment
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can now spawn objects into our scene, and we can see them
    interact with each other correctly! Taking this further, you can create whatever
    type of gameplay experience you’d like!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, you have learned how to utilize Unity’s AR toolsets
    to augment reality by adding artificial computer-generated objects into the real
    world. This new and growing technology is still being developed, and the skills
    gained from working in it will likely grow in importance in the future as things
    such as **Virtual Reality** (**VR**), **Mixed Reality** (**MR**), and other forms
    of **Extended Reality** (**XR**) become more and more commonplace.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to install ARKit for iOS, ARCore for Android,
    and AR Foundation for a multiplatform AR solution. Once installed, you learned
    how to set the platform settings for both iOS and Android AR development. Afterward,
    we did the basic setup to have Unity use its AR tools to allow users to add a
    simple mesh to the environment. We then built upon that to detect surfaces within
    the real world using the AR Plane Manager and learned how to visualize it by using
    the AR Default Plane object. We then learned how to interact with the AR environment
    using the AR Raycast Manager to detect when we hit the meshes within the real
    world and have objects in the computer- generated world react to it. Finally,
    we saw how to spawn objects in AR using this information.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In addition to AR Foundation, ARCore, and ARKit, there are several other frameworks
    and plugins available for adding AR to Unity apps.
  prefs: []
  type: TYPE_NORMAL
- en: If your project requires specific functionalities beyond what Unity provides,
    alternative frameworks can offer the necessary tools or better support and performance
    for your specific use case. For example, Vuforia ([https://www.ptc.com/en/products/vuforia](https://www.ptc.com/en/products/vuforia))
    is known for its robust marker-based tracking, while Wikitude ([https://www.wikitude.com/download-wikitude-sdk-for-unity/](https://www.wikitude.com/download-wikitude-sdk-for-unity/))
    specializes in location-based AR experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the choice of AR framework depends on factors such as platform support,
    required features, developer expertise, and project-specific needs. It’s essential
    to evaluate the strengths and limitations of each framework to select the one
    that best aligns with your goals and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This should give you all of the information you need to start experimenting
    on your own and see whether you can create your own games for both mobile devices
    and games within an AR environment. So, go forth and use the knowledge from this
    book to make your games the best they can be and I look forward to playing them!
  prefs: []
  type: TYPE_NORMAL
