- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Augmented Reality
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强现实
- en: Made popular with Niantic’s *Pokemon GO* and on Snapchat filters, **Augmented
    Reality** (**AR**) is a way of blending digital elements with the real world.
    Specifically, it is a technology that superimposes a computer-generated image
    on a user’s view of the real world, hence providing a composite view, meaning
    that both the real world and then digital elements put on top of it are displayed
    to the player.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着《精灵宝可梦GO》和Snapchat滤镜的流行，**增强现实**（**AR**）是将数字元素与真实世界融合的一种方式。具体来说，它是一种将计算机生成的图像叠加到用户对真实世界的视图上的技术，因此提供了一种组合视图，这意味着真实世界和叠加在其上的数字元素都显示给玩家。
- en: In this chapter, we will explore how to set up our project to utilize AR for
    both Android and iOS devices and how we can customize them. This project will
    be a simple AR project in which the player can look at various surfaces in the
    game environment and spawn objects on top of them. The goal of this chapter will
    be to explore the basic concepts of AR and see how they can be used in a project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何设置我们的项目以利用AR为Android和iOS设备服务，以及我们如何自定义它们。这个项目将是一个简单的AR项目，玩家可以在游戏环境中查看各种表面并在其上生成对象。本章的目标将是探索AR的基本概念，并了解它们如何在项目中使用。
- en: 'This chapter will be split into several topics. It will contain a simple, step-by-step
    process from beginning to end. Here is the outline of our tasks:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为几个主题。它将包含从开始到结束的简单、逐步过程。以下是我们的任务大纲：
- en: Setting up a project for AR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为AR设置项目
- en: Detecting surfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测表面
- en: Interacting with the AR environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与AR环境交互
- en: Spawning objects in AR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AR中生成对象
- en: By the end of this chapter, you will have a good understanding of AR technology
    and how to create a basic AR project. Whether you’re a beginner or an experienced
    developer, this chapter will provide you with a solid foundation for further exploration
    and experimentation with AR which should come useful not only for mobile development
    but also for those looking to get experience with the same technology used in
    headsets from Meta as well as Apple's Vision Pro.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解AR技术以及如何创建一个基本的AR项目。无论你是初学者还是有经验的开发者，本章都将为你提供一个坚实的基础，以便进一步探索和实验AR，这不仅对移动开发有用，对于那些希望获得与Meta的耳机以及苹果的Vision
    Pro中使用的相同技术经验的人来说也很有用。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the **Unity Editor system requirements** section. To deploy your project, you
    will need an Android or iOS device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Unity 2022.1.0b16和Unity Hub 3.3.1，但步骤应该在未来版本的编辑器中只需进行最小更改即可。如果你想下载本书中使用的确切版本，并且有新版本发布，你可以访问Unity的下载存档[https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive)。你还可以在**Unity编辑器系统要求**部分找到Unity的系统要求[https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)。要部署你的项目，你需要一个Android或iOS设备。
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter15).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中提供的代码文件，链接为[https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter15)。
- en: Setting up a project for AR
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为AR设置项目
- en: 'Before we can start adding notifications to our project, we will need to add
    three packages that Unity makes available to enable AR for both iOS and Android
    devices. In our case, we are going to be utilizing both ARCore and ARKit to create
    our project, and the AR Foundation package to act as an intermediary so we can
    use both ARCore and ARKit while using a similar connection. Since this is a brand
    new way to create projects, we will actually create a new Unity project to demonstrate
    how to use it. Please follow the steps given here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向我们的项目添加通知之前，我们需要添加三个Unity提供的包，以使iOS和Android设备都支持AR。在我们的案例中，我们将利用ARCore和ARKit来创建我们的项目，并使用AR
    Foundation包作为中介，以便我们可以在使用类似连接的同时使用ARCore和ARKit。由于这是一种全新的创建项目的方式，我们将实际创建一个新的Unity项目来演示如何使用它。请按照以下步骤操作：
- en: To get started, open Unity Hub on your computer.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，请在您的计算机上打开Unity Hub。
- en: From startup, we’ll opt to create a new project by clicking on the **New** button.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从启动开始，我们将通过点击**新建**按钮来创建一个新的项目。
- en: 'Next, under `Mobile AR`), and under **Templates**, make sure that **3D** is
    selected:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Mobile AR`下，并在**模板**下，确保**3D**被选中：
- en: '![Figure 15.1 – Creating a 3D project](img/B18868_15_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – 创建3D项目](img/B18868_15_01.jpg)'
- en: Figure 15.1 – Creating a 3D project
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 创建3D项目
- en: Afterward, click on **Create Project** and wait for Unity to load up.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，点击**创建项目**并等待Unity加载。
- en: From the Unity Editor, go to **Window** | **Package Manager**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity编辑器，转到**窗口** | **包管理器**。
- en: If it hasn’t been set already, click on the **In Project** drop-down menu from
    the toolbar of the **Packages** menu and select **Unity Registry**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未设置，请从**包**菜单的工具栏中点击**项目内**下拉菜单，并选择**Unity注册表**。
- en: 'From here, go to the search bar in the top right and type in `XR`. From there,
    you will need to select either **ARKit XR Plugin** if you want to support iOS
    devices or **ARCore XR Plugin** for Android, and click **Install**. Afterward,
    scroll down the available options until you reach **AR Foundation** and select
    it. Once there, click the **Install** button:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，转到右上角的搜索栏，并输入`XR`。从那里，您需要选择**ARKit XR插件**以支持iOS设备，或选择**ARCore XR插件**以支持Android，然后点击**安装**。之后，向下滚动可用的选项，直到找到**AR
    Foundation**并选择它。一旦到达那里，点击**安装**按钮：
- en: '![Figure 15.2 – Installing packages](img/B18868_15_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 – 安装包](img/B18868_15_02.jpg)'
- en: Figure 15.2 – Installing packages
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – 安装包
- en: We now have all of the packages we need so we can exit **Package Manager**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了所有需要的包，因此我们可以退出**包管理器**。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While AR Foundation does most things that you’d want to do with AR, there are
    a few things that are for iOS or Android only. For more information on what AR
    Foundation can do and what ARCore and ARKit provide individually, check out [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html#platform-support](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html#platform-support).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AR Foundation可以完成您想要在AR中做的几乎所有事情，但还有一些事情是仅适用于iOS或Android的。有关AR Foundation能做什么以及ARCore和ARKit各自提供的内容的更多信息，请查看[https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html#platform-support](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@5.0/manual/index.html#platform-support)。
- en: Next, open up the **Build Settings** menu by going to **File** | **Build Settings**.
    From there, change your platform to either **iOS** or **Android** and click on
    the **Switch Platform** button. Afterward, click on the **Player** **Settings...**
    option.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过访问**文件** | **构建设置**打开**构建设置**菜单。从那里，将您的平台更改为**iOS**或**Android**，然后点击**切换平台**按钮。之后，点击**玩家设置...**选项。
- en: Next, complete *step 10* if you are planning on using iOS or *step 11* if you
    are planning on using Android, or complete both steps if you plan on using both
    iOS and Android.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果您计划使用iOS，请完成*步骤10*；如果您计划使用Android，请完成*步骤11*；如果您计划同时使用iOS和Android，请完成这两个步骤。
- en: If you are using iOS, make sure that, in the iOS **Platform Settings** section,
    the **Requires ARKit support** option is checked as well.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用iOS，请确保在iOS的**平台设置**部分中，**需要ARKit支持**选项也被选中。
- en: For those using Android, go to the Android **Player Settings...** and under
    **Other Settings**, go to **Rendering** and uncheck the **Auto Graphics API**
    option. Then, under the **Graphics APIs** section, select the **Vulkan** option
    and press the **–** button to remove it from the list. Then, scroll down and uncheck
    the **Multithreaded** **Rendering** option.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于使用安卓的用户，转到安卓**玩家设置...**，在**其他设置**下，转到**渲染**并取消勾选**自动图形API**选项。然后，在**图形API**部分，选择**Vulkan**选项并按**–**按钮将其从列表中删除。然后，向下滚动并取消勾选**多线程****渲染**选项。
- en: '![Figure 15.3 – Android Player Settings setup](img/B18868_15_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 – 安卓玩家设置配置](img/B18868_15_03.jpg)'
- en: Figure 15.3 – Android Player Settings setup
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 安卓玩家设置配置
- en: The reason we have to disable this functionality is that, as of the time of
    writing, it is not compatible with ARCore. You’ll also want to set **Minimum API
    Level** to **Android 7.0 ‘Nougat’ (API level 24)** or higher.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须禁用此功能的原因是，截至写作时，它与ARCore不兼容。您还希望将**最小API级别**设置为**Android 7.0‘Nougat’（API级别24）**或更高。
- en: When working on ARCore projects in Unity, it’s recommended that you enable the
    ARM64 target architecture. If your app only supports the 32-bit ARMv7 architecture,
    it may not work properly on 64-bit devices, and it may not be available for download
    from the Google Play Store. This is because some 64-bit devices don’t support
    32-bit ARCore libraries. So, to avoid any issues, it’s best to enable the ARM64
    target architecture in your Unity project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Unity中处理ARCore项目时，建议您启用ARM64目标架构。如果您的应用程序仅支持32位ARMv7架构，它可能在64位设备上无法正常工作，并且可能无法从Google
    Play Store下载。这是因为一些64位设备不支持32位ARCore库。因此，为了避免任何问题，最好在Unity项目中启用ARM64目标架构。
- en: Under **Configuration**, set **Scripting Backend** to **IL2CPP**. Next, under
    **Target Architectures**, enable the **ARM64** option.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在**配置**下，将**脚本后端**设置为**IL2CPP**。接下来，在**目标架构**下，启用**ARM64**选项。
- en: '![Figure 15.4 – Changing Target Architectures](img/B18868_15_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4 – 更改目标架构](img/B18868_15_04.jpg)'
- en: Figure 15.4 – Changing Target Architectures
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 – 更改目标架构
- en: Now, from the **Player Settings...** menu, select the **XR Plugin Management**
    option, and then, under **Plug-in Providers**, check the **ARCore** field, and
    for iOS, check the **ARKit** option.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**玩家设置...**菜单中选择**XR插件管理**选项，然后，在**插件提供者**下，勾选**ARCore**字段，对于iOS，勾选**ARKit**选项。
- en: '![Figure 15.5 – Enabling ARCore](img/B18868_15_05.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 – 启用ARCore](img/B18868_15_05.jpg)'
- en: Figure 15.5 – Enabling ARCore
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 启用ARCore
- en: With that, we’ve taken care of all of the settings needed to support our project
    and have it export correctly!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经处理了所有支持我们的项目并正确导出的设置！
- en: Now that we have included AR Foundation, we can now create a basic scene for
    a VR project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经包含了AR Foundation，我们现在可以为VR项目创建一个基本场景。
- en: Basic setup
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本设置
- en: 'Since the player can be anywhere when the game starts, we can’t use a camera
    in the traditional sense, so we will start by removing the original one. Follow
    the steps given here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家在游戏开始时可能位于任何位置，我们无法使用传统意义上的摄像机，因此我们将首先删除原始的摄像机。按照以下步骤操作：
- en: From the **Hierarchy** panel, select the **Main Camera** object and delete it
    by right-clicking and selecting **Delete** or pressing the *Delete* key.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**面板中选择**主摄像机**对象，通过右键点击并选择**删除**或按*Delete*键来删除它。
- en: 'There are two key objects that we will need to create before we can start implementing
    our own features: **AR Session** and **AR** **Session Origin**.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现自己的功能之前，我们需要创建两个关键对象：**AR会话**和**AR会话原点**。
- en: 'Right-click in the **Hierarchy** panel and select **XR** | **AR Session**:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中右键点击并选择**XR** | **AR会话**：
- en: '![Figure 15.6 – Creating an AR session](img/B18868_15_06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6 – 创建AR会话](img/B18868_15_06.jpg)'
- en: Figure 15.6 – Creating an AR session
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – 创建AR会话
- en: '**AR Session** is what controls the life cycle of any AR experience, which
    allows us to enable or disable AR features depending on the platform we are working
    on.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR会话**是控制任何AR体验生命周期的，这允许我们根据我们正在工作的平台启用或禁用AR功能。'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**AR Session** is also responsible for telling you whether your device supports
    AR. For information on handling this, check out [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/index.html#checking-for-device-support](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/index.html#checking-for-device-support).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR Session**还负责告诉你你的设备是否支持AR。有关处理此问题的信息，请参阅[https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/index.html#checking-for-device-support](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/index.html#checking-for-device-support)。'
- en: Create an **AR Session Origin** object by right-clicking and selecting **XR**
    | **AR** **Session Origin**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择**XR** | **AR Session Origin**来创建一个**AR Session Origin**对象。
- en: '**AR Session Origin** is used to scale and offset virtual content while the
    game itself is playing. You may notice that the object has a child, **AR Camera**,
    which is the camera that will follow the game as it is running.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR Session Origin**用于在游戏本身播放时缩放和偏移虚拟内容。你可能注意到对象有一个子对象，**AR Camera**，这是在游戏运行时跟随游戏的相机。'
- en: Before we deploy to the device to ensure everything is working correctly, let’s
    add a cube to our scene so we can see that it is working correctly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将设备部署以确保一切正常工作之前，让我们在我们的场景中添加一个立方体，这样我们就可以看到它是否正常工作。
- en: 'Switch to the **Scene** view if you haven’t done so already. Then, from the
    top menu, click on **GameObject** | **3D Object** | **Cube**:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有切换到**场景**视图，请从顶部菜单点击**GameObject** | **3D Object** | **Cube**：
- en: "![Figure 15.7 – Creat\uFEFFing a cube](img/B18868_15_07.jpg)"
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7 – 创建立方体](img/B18868_15_07.jpg)'
- en: Figure 15.7 – Creating a cube
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 – 创建一个立方体
- en: Now, build your project and put the game on the device in the same manner as
    discussed in [*Chapter 2*](B18868_02.xhtml#_idTextAnchor087), *Project Setup for
    Android and* *iOS Development*.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建你的项目，并将游戏以与[*第2章*](B18868_02.xhtml#_idTextAnchor087)中讨论的相同方式部署到设备上，*Android和iOS开发的项目设置*。
- en: Tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: For iOS users, you may notice when you build the project, it will tell you that
    the project is lacking a `.xml` file. If this appears, click on the **Yes, fix
    and build** option when prompted.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS用户，当你构建项目时，可能会告诉你项目缺少`.xml`文件。如果出现这种情况，当被提示时，请点击**是，修复并构建**选项。
- en: For Android users, you may need to install the Google Play Services for AR if
    it is not installed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android用户，如果尚未安装，你可能需要安装Google Play Services for AR。
- en: 'Upon running your project, give access to the camera if needed and open the
    game. Once the project shows your environment, step back as the game starts:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的项目后，如果需要，请授予相机访问权限并打开游戏。一旦项目显示你的环境，当游戏开始时向后退：
- en: '![Figure 15.8 – Our first AR result](img/B18868_15_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8 – 我们的第一项AR结果](img/B18868_15_08.jpg)'
- en: Figure 15.8 – Our first AR result
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 我们的第一项AR结果
- en: The reason why we have to step back to see the cube is that the position of
    all objects is based on the area the phone was physically at when the game started.
    The cube is also quite large because, at a default scale of 1,1,1, that means
    that it is 1 meter (or around 3.3 feet) wide on each side in relation to real-sized
    objects. We obviously don’t want to require the user to step back upon starting
    the game so we will need to keep track of where usable surfaces are in our environment,
    which is what we will be doing next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须后退以看到立方体的原因是因为所有对象的位置都是基于游戏开始时手机物理所在的位置。立方体也相当大，因为在默认的1,1,1缩放下，这意味着它每边相对于真实尺寸的对象有1米（或大约3.3英尺）宽。显然，我们不希望用户在游戏开始时后退，因此我们需要跟踪我们环境中可用的表面位置，这正是我们将要做的下一件事。
- en: 'To detect surfaces within our real-world environment, we will need to make
    use of a new component, **AR Plane Manager**. This component allows us to create,
    remove, or update GameObjects in our scene based on the surfaces within the real-world
    environment. The following steps will automatically create invisible planes with
    colliders that we could possibly use for gameplay reasons:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测我们真实世界环境中的表面，我们需要使用一个新的组件，**AR Plane Manager**。这个组件允许我们根据真实世界环境中的表面创建、删除或更新场景中的GameObject。以下步骤将自动创建不可见的带有碰撞器的平面，我们可能可以用作游戏玩法的原因：
- en: We no longer need the original cube we created, so we can delete it from the
    scene by right-clicking it and selecting **Delete** or by selecting it and pressing
    the *Delete* key.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要我们创建的原始立方体，因此我们可以通过右键单击它并选择**删除**，或者通过选择它并按*Delete*键来从场景中删除它。
- en: From the **Hierarchy** panel, select the **AR Session Origin** object. From
    there, add the **AR Plane Manager** component to it by clicking on the **Add Component**
    button at the bottom of the **Inspector** window and then typing in the name of
    the component and pressing *Enter*.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次** 面板中选择 **AR 会话原点** 对象。从那里，通过在 **检查器** 窗口的底部点击 **添加组件** 按钮并输入组件名称然后按
    *Enter* 键，将其添加到 **AR 平面管理器** 组件中。
- en: 'At this point, we will have surfaces being generated to our scene while being
    run, but for things such as debugging, it would be a good idea to visually see
    the planes that are being generated. So, that’s what we will do next using the
    following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们将在运行时生成场景中的表面，但对于像调试这样的东西，能够直观地看到正在生成的平面会是个好主意。所以，我们将使用以下步骤来做这件事：
- en: From the top menu, go to **GameObject** | **XR** | **AR** **Default Plane**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部菜单，转到 **游戏对象** | **XR** | **AR 默认平面**。
- en: This object has several different components that are used in creating a visual
    plane; of note, are the **AR Plane** and **AR Plane Mesh Visualizer** components.
    **AR Plane** represents a plane detected by the AR device, and **AR Plane Mesh
    Visualizer** is in charge of using the data from **AR Plane** to modify the **MeshFilter**
    and **MeshCollider** components to overlay the detected wall, and the **Line Renderer**
    component to display the boundaries. The **Mesh Renderer** component will draw
    the information displayed from these modifications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象有几个不同的组件，用于创建视觉平面；值得注意的是，**AR 平面** 和 **AR 平面网格可视化器** 组件。**AR 平面** 代表由 AR
    设备检测到的平面，而 **AR 平面网格可视化器** 负责使用 **AR 平面** 的数据来修改 **MeshFilter** 和 **MeshCollider**
    组件，以叠加检测到的墙壁，并使用 **线条渲染器** 组件显示边界。**网格渲染器** 组件将绘制这些修改后显示的信息。
- en: From the `Prefabs`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `预制件`。
- en: 'Drag and drop the `Prefabs` folder to turn it into a Prefab. If it is done
    correctly, you should notice the GameObject’s text in the **Hierarchy** window
    is now blue:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `预制件` 文件夹拖动以将其转换为预制件。如果操作正确，你应该会注意到 **层次** 窗口中 GameObject 的文本现在变成了蓝色：
- en: '![Figure 15.9 – Creating a Prefab](img/B18868_15_09.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.9 – 创建预制件](img/B18868_15_09.jpg)'
- en: Figure 15.9 – Creating a Prefab
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.9 – 创建预制件
- en: Once created, you can delete the **AR Default Plane** object in the **Hierarchy**
    window.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建，你可以在 **层次** 窗口中删除 **AR 默认平面** 对象。
- en: 'Select the **AR Session Origin** object. Click the **Add Component** button
    and add an **AR Plane Manager** component. Afterward, drag and drop the **AR Default
    Plane** Prefab into the **Plane Prefab** property of the **AR Plane** **Manager**
    component:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **AR 会话原点** 对象。点击 **添加组件** 按钮，并添加一个 **AR 平面管理器** 组件。之后，将 **AR 默认平面** 预制件拖放到
    **AR 平面** **管理器** 组件的 **平面预制件** 属性中：
- en: '![Figure 15.10 – Assigning the Plane Prefab](img/B18868_15_10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.10 – 分配平面预制件](img/B18868_15_10.jpg)'
- en: Figure 15.10 – Assigning the Plane Prefab
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.10 – 分配平面预制件
- en: This will tell **Plane Manager** that, any time it detects a new plane within
    the scene, it should spawn a Plane Prefab and have it draw the details for it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 **平面管理器**，每次它检测到场景中的新平面时，它都应该生成一个平面预制件，并为其绘制细节。
- en: 'Save your project and build your game again. Once it is running on your device,
    walk around your room, moving the camera as you do so:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目并再次构建你的游戏。一旦它在你的设备上运行，你就可以在房间里四处走动，同时移动相机：
- en: '![Figure 15.11 – Plane creation in AR](img/B18868_15_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.11 – AR 中创建平面](img/B18868_15_11.jpg)'
- en: Figure 15.11 – Plane creation in AR
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.11 – AR 中创建平面
- en: The longer you stay within an area with movement, the longer the phone will
    have to build a more realistic depiction of the surfaces in your environment.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你在一个有移动的区域停留的时间越长，手机就需要更长时间来构建你环境中表面的更逼真的描绘。
- en: Feel free to open the Prefab we created and modify how your planes will be visualized!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 随意打开我们创建的预制件，并修改你的平面如何被可视化！
- en: It’s great that we can now see things happening in the game environment, but
    we currently have no way to actually interact with the world—that is what we will
    be looking into in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到游戏环境中的事情发生，这很好，但我们目前还没有实际与世界交互的方法——这就是我们将在下一节中探讨的内容。
- en: Interacting with the AR environment
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 AR 环境交互
- en: 'One of the ways that we can have the player interact with the world is by allowing
    them to spawn objects within the scene to help players see where items will spawn.
    We can create an indicator to show where they will actually spawn to. Let’s look
    at the steps to do just that:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让玩家与世界交互的一种方法是通过允许他们在场景中生成对象，以帮助玩家看到物品将生成在哪里。我们可以创建一个指示器来显示它们实际生成的地方。让我们看看完成这一点的步骤：
- en: Create a quad using **GameObject** | **3D Object** | **Quad**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject** | **3D Object** | **Quad**创建一个四边形。
- en: Quads represent a plane, the simplest type of geometry. In our case, we will
    use the quad as an indicator to the player where they will be spawning an object
    if they tap on the screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 四边形代表一个平面，这是最简单的几何类型。在我们的情况下，我们将使用四边形作为指示器，告诉玩家如果他们在屏幕上点击，他们将生成对象的位置。
- en: With the quad selected, go to the `(0,0,0)`, `90`, and `(0.2,0.2,1)`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择四边形后，前往`(0,0,0)`，`90`，和`(0.2,0.2,1)`。
- en: We made the quad smaller to be 20 centimeters long and rotated it so it could
    represent a floor better. We do not want these values to change but we will eventually
    want to move and rotate this object to follow our player when they move the camera.
    To protect this data, we can instead create a parent object for it. That way,
    whenever the parent moves or rotates, the child will move and rotate in the same
    manner.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将四边形缩小到20厘米长，并旋转它以更好地代表地板。我们不希望这些值改变，但最终我们希望移动和旋转这个对象以跟随玩家移动摄像头。为了保护这些数据，我们可以为它创建一个父对象。这样，每当父对象移动或旋转时，子对象也会以相同的方式移动和旋转。
- en: Create an empty GameObject by selecting `Placement Indicator`. Then, go to the
    `(0,0,0)`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择`放置指示器`创建一个空的游戏对象。然后，前往`(0,0,0)`。
- en: 'From the **Hierarchy** window, drag and drop the **Quad** GameObject on top
    of the **Placement Indicator** object to make it a child:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中，将**Quad**游戏对象拖放到**放置指示器**对象上，使其成为子对象：
- en: "![Figure 15.12 – Creating the Placement Indi\uFEFFcator object](img/B18868_15_12.jpg)"
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图15.12 – 创建放置指示器对象](img/B18868_15_12.jpg)'
- en: Figure 15.12 – Creating the Placement Indicator object
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 – 创建放置指示器对象
- en: Now that we have an object to work with, we need some way to figure out where
    the player’s camera is facing so we can move the object. We can do this through
    the use of a new component, **AR** **Raycast Manager**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以工作的对象，我们需要一种方法来确定玩家的摄像头朝向，以便我们可以移动该对象。我们可以通过使用一个新的组件，**AR** **射线投射管理器**来实现这一点。
- en: From the **Hierarchy** window, select the **AR Session Origin** object. From
    there, add the **AR Raycast Manager** component to it.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中选择**AR会话起源**对象。从那里，向其添加**AR射线投射管理器**组件。
- en: The **AR Raycast Manager** component exposes the ability to raycast to AR Foundation.
    This will allow us to perform a Raycast within the physical environment that we
    are in. A Raycast, also known as hit testing, allows us to create a ray, which
    is an invisible line that allows us to check whether there is something that collides
    from its point of origin and direction. This is used oftentimes in games for things
    such as checking whether a bullet would hit the player.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR射线投射管理器**组件提供了向AR Foundation进行射线投射的能力。这将允许我们在我们所在的物理环境中执行射线投射。射线投射，也称为碰撞检测，允许我们创建一条射线，这是一条无形的线，可以用来检查是否从其起点和方向有物体与之碰撞。这在游戏中经常用于检查子弹是否会击中玩家。'
- en: 'Now that we have this setup done, let’s see how we can work with these components
    in code and see how we can use the information to place AR objects within real-world
    spaces using the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个设置，让我们看看我们如何在代码中与这些组件一起工作，以及我们如何使用以下步骤的信息在现实世界空间中放置AR对象：
- en: Go to the `Assets` folder. From there, create a new folder called `Scripts`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Assets`文件夹。从那里，创建一个名为`Scripts`的新文件夹。
- en: Go inside the `Scripts` folder and create a new C# script called `PlaceARObject`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`Scripts`文件夹，创建一个名为`PlaceARObject`的新C#脚本。
- en: 'At the top of the file, add the following `using` statements:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部添加以下`using`语句：
- en: '[PRE0]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following properties to the class:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类中：
- en: '[PRE1]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we need to initialize the properties in the `Start` function:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在`Start`函数中初始化属性：
- en: '[PRE2]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we need to replace our `Update` function and use `LateUpdate` instead:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要替换我们的`Update`函数并使用`LateUpdate`代替：
- en: '[PRE3]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding snippet, we are using an `UpdateIndicator` function that currently
    doesn’t exist, so let’s add that next:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了一个当前不存在的`UpdateIndicator`函数，所以让我们添加它：
- en: '[PRE4]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save the script and return to the Unity Editor. Attach the `PlaceARObject` script
    to the **Placement** **Indicator** GameObject.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到Unity编辑器。将`PlaceARObject`脚本附加到**放置指示器**GameObject。
- en: 'Export your game to your device of choice and verify that it is working:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏导出到您选择的设备上并验证它是否正常工作：
- en: '![Figure 15.13 – Placement Indicator in AR](img/B18868_15_13.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图15.13 – AR中的放置指示器](img/B18868_15_13.jpg)'
- en: Figure 15.13 – Placement Indicator in AR
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13 – AR中的放置指示器
- en: As you can see, the plane will now move and rotate so that it is always facing
    us! You may notice the plane has a flickery texture. This is due to the z-fighting
    concept we discussed previously in [*Chapter 4*](B18868_04.xhtml#_idTextAnchor165),
    *Resolution-Independent UI*. Basically, both objects have the same position so
    it’s up to Unity to decide what order to draw them in. We can fix this by placing
    the quad slightly above the plane’s position, which we will do now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在平面将移动并旋转，始终面向我们！您可能会注意到飞机有一个闪烁的纹理。这是由于我们之前在[*第4章*](B18868_04.xhtml#_idTextAnchor165)中讨论的z-fighting概念，*分辨率无关UI*。基本上，两个对象具有相同的坐标，所以Unity需要决定它们的绘制顺序。我们可以通过将四边形稍微放置在平面的位置上方来解决这个问题，我们现在就这样做。
- en: 'Update the `UpdateIndicator` function to use the following code at the end:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`UpdateIndicator`函数，在末尾使用以下代码：
- en: '[PRE5]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save the script and export the game again. As you can see, now the quad is
    placed cleanly above the given surface:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并再次导出游戏。如您所见，现在四边形干净地放置在给定的表面上方：
- en: '![Figure 15.14 – Adjusted Placement Indicator](img/B18868_15_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图15.14 – 调整后的放置指示器](img/B18868_15_14.jpg)'
- en: Figure 15.14 – Adjusted Placement Indicator
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14 – 调整后的放置指示器
- en: Now that we have an indicator of sorts, let’s make it so we can actually spawn
    an object in AR.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一种指示器，让我们实际在AR中生成一个对象。
- en: Spawning objects in AR
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AR中生成对象
- en: The simplest way to spawn an object in AR would be to make it so that when the
    player taps on the screen, it will spawn an object where our **Placement Indicator**
    object is. But before we do that, we first need to make an object that we’d want
    to create within the scene.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在AR中创建对象的简单方法就是让玩家在屏幕上点击时，在**放置指示器**对象所在的位置生成对象。但在我们这样做之前，我们首先需要创建一个我们希望在场景中创建的对象。
- en: 'Follow the steps given here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这里给出的步骤进行：
- en: Create a sphere by going to **GameObject** | **3D Object** | **Sphere**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**GameObject** | **3D Object** | **Sphere**创建一个球体。
- en: From the `(0,0,0)` and set `(0.2,0.2,0.2)`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`(0,0,0)`设置到`(0.2,0.2,0.2)`。
- en: Add a **Rigidbody** component to the sphere by going to **Component** | **Physics**
    | **Rigidbody**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**Component** | **Physics** | **Rigidbody**为球体添加一个**Rigidbody**组件。
- en: By adding the **Rigidbody** component, we are letting Unity know that we want
    this object to be affected by things such as gravity and react to collision events
    and forces being applied to it. At this point, you could customize the object
    as much as you’d like, change the mesh and collider, and so on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加**Rigidbody**组件，我们让Unity知道我们希望这个对象受到重力、碰撞事件和施加到它上的力的作用。在这个阶段，您可以按需自定义对象，更改网格和碰撞器等。
- en: 'Go to the `Prefabs` folder. Create a Prefab of our sphere by dragging and dropping
    it from the **Hierarchy** window to the **Project** window:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Prefabs`文件夹。通过从**Hierarchy**窗口拖放到**Project**窗口创建我们的球体的Prefab：
- en: "![Figure 15.15 – Creatin\uFEFFg a 3D object to spawn](img/B18868_15_15.jpg)"
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图15.15 – 创建用于生成的3D对象](img/B18868_15_15.jpg)'
- en: Figure 15.15 – Creating a 3D object to spawn
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15 – 创建用于生成的3D对象
- en: Now that the object is a Prefab, we can delete it from the **Hierarchy** window.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这个对象是一个Prefab，我们可以从**Hierarchy**窗口中删除它。
- en: 'Open the `PlaceARObject` script and add the following property to it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PlaceARObject`脚本，并向其中添加以下属性：
- en: '[PRE6]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, update the `LateUpdate` function to the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新`LateUpdate`函数为以下内容：
- en: '[PRE7]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save the script and return to the Unity Editor.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到Unity编辑器。
- en: 'From the **Hierarchy** window, select the **Placement Indicator** object. From
    the **Inspector** window, set the **Object To Spawn** property to our **Sphere**
    Prefab:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Hierarchy**窗口中选择**放置指示器**对象。从**Inspector**窗口中，将**要生成的对象**属性设置为我们的**Sphere**Prefab：
- en: "![Figure 15.16 – Se\uFEFFtting the object to spawn](img/B18868_15_16.jpg)"
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图15.16 – 设置要生成的对象](img/B18868_15_16.jpg)'
- en: Figure 15.16 – Setting the object to spawn
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16 – 设置要生成的对象
- en: 'Save your project and build it to your device, and tap the screen to have spheres
    spawn onto the screen:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的项目并构建到您的设备上，然后点击屏幕以在屏幕上生成球体：
- en: '![Figure 15.17 – Objects spawning in our AR environment](img/B18868_15_17.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图15.17 – 在我们的AR环境中生成对象](img/B18868_15_17.jpg)'
- en: Figure 15.17 – Objects spawning in our AR environment
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17 – 在我们的AR环境中生成对象
- en: As you can see, we can now spawn objects into our scene, and we can see them
    interact with each other correctly! Taking this further, you can create whatever
    type of gameplay experience you’d like!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在可以将对象生成到场景中，并且可以看到它们正确地相互交互！更进一步，您可以创建任何类型的游戏体验！
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, you have learned how to utilize Unity’s AR toolsets
    to augment reality by adding artificial computer-generated objects into the real
    world. This new and growing technology is still being developed, and the skills
    gained from working in it will likely grow in importance in the future as things
    such as **Virtual Reality** (**VR**), **Mixed Reality** (**MR**), and other forms
    of **Extended Reality** (**XR**) become more and more commonplace.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了如何利用Unity的AR工具集，通过将人工计算机生成的对象添加到现实世界中来增强现实。这项新兴且不断发展的技术仍在开发中，从这项工作中获得的技能在未来可能会变得更加重要，因为像**虚拟现实**（**VR**）、**混合现实**（**MR**）和其他形式的**扩展现实**（**XR**）变得越来越普遍。
- en: In this chapter, you learned how to install ARKit for iOS, ARCore for Android,
    and AR Foundation for a multiplatform AR solution. Once installed, you learned
    how to set the platform settings for both iOS and Android AR development. Afterward,
    we did the basic setup to have Unity use its AR tools to allow users to add a
    simple mesh to the environment. We then built upon that to detect surfaces within
    the real world using the AR Plane Manager and learned how to visualize it by using
    the AR Default Plane object. We then learned how to interact with the AR environment
    using the AR Raycast Manager to detect when we hit the meshes within the real
    world and have objects in the computer- generated world react to it. Finally,
    we saw how to spawn objects in AR using this information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何为iOS安装ARKit、为Android安装ARCore以及为多平台AR解决方案安装AR Foundation。安装完成后，您学习了如何设置iOS和Android
    AR开发的平台设置。之后，我们进行了基本设置，让Unity使用其AR工具，使用户能够将简单的网格添加到环境中。然后，我们在此基础上使用AR Plane Manager检测现实世界中的表面，并学习了如何使用AR
    Default Plane对象来可视化它。然后，我们学习了如何使用AR Raycast Manager与AR环境交互，以检测我们何时击中现实世界中的网格，并让计算机生成的世界中的对象对其做出反应。最后，我们看到了如何使用这些信息在AR中生成对象。
- en: Tip
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In addition to AR Foundation, ARCore, and ARKit, there are several other frameworks
    and plugins available for adding AR to Unity apps.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了AR Foundation、ARCore和ARKit之外，还有几个其他框架和插件可用于将AR添加到Unity应用程序中。
- en: If your project requires specific functionalities beyond what Unity provides,
    alternative frameworks can offer the necessary tools or better support and performance
    for your specific use case. For example, Vuforia ([https://www.ptc.com/en/products/vuforia](https://www.ptc.com/en/products/vuforia))
    is known for its robust marker-based tracking, while Wikitude ([https://www.wikitude.com/download-wikitude-sdk-for-unity/](https://www.wikitude.com/download-wikitude-sdk-for-unity/))
    specializes in location-based AR experiences.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目需要Unity提供之外的具体功能，替代框架可以提供必要的工具或为您的特定用例提供更好的支持和性能。例如，Vuforia（[https://www.ptc.com/en/products/vuforia](https://www.ptc.com/en/products/vuforia)）以其强大的基于标记的跟踪而闻名，而Wikitude（[https://www.wikitude.com/download-wikitude-sdk-for-unity/](https://www.wikitude.com/download-wikitude-sdk-for-unity/)）则专注于基于位置的AR体验。
- en: Ultimately, the choice of AR framework depends on factors such as platform support,
    required features, developer expertise, and project-specific needs. It’s essential
    to evaluate the strengths and limitations of each framework to select the one
    that best aligns with your goals and requirements.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，选择AR框架取决于平台支持、所需功能、开发者专业知识以及项目特定需求等因素。评估每个框架的优势和局限性，选择与您的目标和需求最匹配的框架是至关重要的。
- en: This should give you all of the information you need to start experimenting
    on your own and see whether you can create your own games for both mobile devices
    and games within an AR environment. So, go forth and use the knowledge from this
    book to make your games the best they can be and I look forward to playing them!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该为您提供所有您需要的信息，以便开始自己进行实验，看看您是否可以创建自己的移动设备游戏和AR环境中的游戏。所以，勇敢地前进，利用这本书中的知识来使您的游戏达到最佳状态，我期待着玩它们！
