["```swift\nLevelDB* db = [[LevelDB alloc]\n  initWithPath:pathToSampleDB(sampleDBname) ];\n```", "```swift\nassert( [db getString:@\"Packt\"] == nil );\n[db putObject:@\"Getting Started\" forKey:@\"Packt\"];\n[db putObject:@\"with Leveldb\" forKey:@\"Packt2\"];\nassert( [[db getString:@\"Packt\"]\n  isEqualToString:@\"Getting Started\"] );\nassert( [db getString:@\"packt\"] == nil );\n```", "```swift\n[db putObject:@\"Is Started\" forKey:@\"Packt\"];\nassert( [[db getString:@\"Packt\"] isEqualToString:@\"Is Started\"] );\n```", "```swift\nconst char enBuf[] = {\"APrefix\\0Packt in a string\"};\nNSString* keyWithNull = [NSString stringWithCharacters:(const\n  unichar*)enBuf length:25];\n[db putObject:@\"Part Key with embedded null\" forKey:keyWithNull];\nassert( [[db getString:keyWithNull]\n  isEqualToString:@\"Part Key with embedded null\"] );\n```", "```swift\n[db deleteObject:@\"Packt\"];\nassert( [db getString:@\"Packt\"] == nil );\n```", "```swift\n  __block int count = 0; // updateable counter outside the block\n  [db iterateKeys:^(NSString* key) {\n    printStr( key );\n    return (++count < 3) ? YES : NO;  // block returns a BOOL\n  }];\n```", "```swift\n#ifdef __cplusplus // forward declaration\n  namespace leveldb { class DB; }\n  typedef leveldb::DB* leveldbDBPtr;\n#else\n  typedef void* leveldbDBPtr;\n#endif\n```", "```swift\n- (leveldbDBPtr) getDB;\n```", "```swift\n- (leveldbDBPtr) getDB   {  return _db; }\n```", "```swift\n@interface APLevelDB (APLevelDB_ADSearches)\n- (void)enumerateKeysWithPrefix:(NSString*)prefix\n  block:(void (^)(NSString *key, BOOL *stop))block;\n@end\n\n@implementation APLevelDB (APLevelDB_ADSearches)\n- (void) enumerateKeysWithPrefix:(NSString*)prefix\n  Keys:(void (^)(NSString* key, BOOL* stop))block\n{\n  BOOL stop = NO;\n  leveldb::Slice prefixSlice = SliceFromString(prefix);\n  std::unique_ptr<leveldb::Iterator> iter(\n    [self getDB]->NewIterator(leveldb::ReadOptions()) );\n  for (iter->Seek(prefixSlice);\n    iter->Valid() && iter->key().starts_with(prefixSlice);\n    iter->Next()) {\n  NSString *k = StringFromSlice( iter->key() );\n  block(k, &stop);\n  if (stop)\n    break;\n  } \n}\n```", "```swift\nNSString* pathToBundledData(NSString* filename)\n{\n  return [[NSBundle mainBundle]\n    pathForResource:filename ofType:@\"\"];\n}\n```", "```swift\nNSString* pathToBundledData(NSString* filename)\n{\n  return [@\"./SampleData/\" stringByAppendingString:filename];\n}\n```", "```swift\nNSString* tabSepStr = [NSString\n  stringWithContentsOfFile:pathToBundledData(@\"Sample500.txt\")\n  encoding:NSUTF8StringEncoding error:&openError];\nNSArray* tabbedLines = [tabSepStr\n  componentsSeparatedByCharactersInSet:\n    [NSCharacterSet newlineCharacterSet]];\n```", "```swift\nNSError* openError;\nAPLevelDB* db = [APLevelDB\n  levelDBWithPath:pathToSampleDB(@\"testImportAPLeveldb05\")\n  error:&openError];\n```", "```swift\nid tabSep = [NSCharacterSet   \n  characterSetWithCharactersInString:@\"\\t\"];\nid<APLevelDBWriteBatch> wb = [db beginWriteBatch];  \nfor (NSString* line in tabbedLines) {\n  NSArray* fields = [line\n    componentsSeparatedByCharactersInSet:tabSep];\n  NSString* nameKey = [NSString stringWithFormat:@\"%@|%@\",\n    fields[1], fields[0]];\n  NSError* encErr;\n  NSData* enc = [NSJSONSerialization dataWithJSONObject:fields\n    options:0 error:&encErr];\n  [wb setData:enc forKey:nameKey];  // main record\n  if ([fields[5] length] > 0)\n    [wb setString:nameKey forKey:fields[5];\n}\n[db commitWriteBatch:wb];\n```", "```swift\n[\"Prince\",\"Kauk\",\"Mckesson Drug Co\",\"AZ\",\"85027\",\"623-581-7435\",\"prince@kauk.com\"]\n```", "```swift\nNSData* jsonRec = [db2 dataForKey:@\"Bayer|Reva\"];\nNSError* decErr;\nNSArray* ja = [NSJSONSerialization\n  JSONObjectWithData:jsonRec options:0 error:&decErr];\n```"]