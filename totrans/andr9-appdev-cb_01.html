<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Activities</h1>
                </header>
            
            <article>
                
<p>This chapter covers the following recipes:</p>
<ul>
<li>Declaring an activity</li>
<li>Starting a new activity with an intent object</li>
<li>Switching between activities</li>
<li>Passing data to another activity</li>
<li>Returning a result from an activity</li>
<li>Saving an activity's state</li>
<li>Storing persistent activity data</li>
<li>Understanding the activity life cycle</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>The Android SDK provides a powerful tool to program mobile devices, and the best way to master such a tool is to jump right in. Although you can read this book from beginning to end, as it is a cookbook, it is specifically designed to allow you to jump to specific tasks and get the results immediately.</p>
<p><strong>Activities</strong> are the fundamental building block of most Android applications as the activity class provides the interface between the application and screen. Most Android applications will have at least one activity, if not several (but they are not required). A background service application will not necessarily require an activity if there is no user interface.</p>
<p>This chapter explains how to <em>declare</em> and <em>launch</em> activities within an application and how to manage several activities at once by sharing data between them, requesting results from them, and calling one activity from within another.</p>
<p>This chapter also briefly explores the <strong>intent</strong> object, which is often used in conjunction with activities. Intents can be used to transfer data between activities in your own application, as well as in external applications, such as those included with the Android operating system (a common example would be to use an intent to launch the default web browser).</p>
<div class="packt_infobox">To begin developing Android applications, head over to the <span class="packt_screen">Android Studio</span> page to download the new Android Studio IDE and the <strong>Android SDK</strong> bundle:<br/>
<a href="http://developer.android.com/sdk/index.html">http://developer.android.com/sdk/index.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring an activity</h1>
                </header>
            
            <article>
                
<p>Activities and other application components, such as <strong>services</strong>, are declared in the <kbd>AndroidManifest.xml</kbd> file. Declaring an activity node is how we tell the OS about our Activity class and how it can be requested. For example, an application will usually indicate that at least one activity should be visible as a desktop icon and serve as the main entry point to the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Android Studio, now at version 3.2, is used for all the code samples shown in this book. I<span>f you have not already installed it, visit the Android Studio website (see the link in the previous tip) to install the IDE and the SDK bundle for your platform.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>For this first example, we'll guide you through creating a new project. Android Studio provides a <span class="packt_screen">Quick Start</span> wizard, which makes the process extremely easy. Follow these steps to get started:</p>
<ol>
<li class="CDPAlignLeft CDPAlign">Launch Android Studio, which brings up the <span class="packt_screen">Welcome to Android Studio</span> dialog:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a4aaf584-2968-4a7c-a067-f13f9c71cb3a.png"/></p>
<ol start="2">
<li>Click on the <span class="packt_screen">Start a new Android Studio project</span> option.</li>
<li class="CDPAlignLeft CDPAlign">Enter an application name; for this example, we used <kbd>DeclareAnActivity</kbd>. Click on <span class="packt_screen">Next</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/83ee42a4-cfdd-403c-b627-c6c798a16d60.png"/></p>
<p class="mce-root"/>
<ol start="4">
<li>In the <span class="packt_screen">Target Android Devices</span> dialog, you can leave the <span class="packt_screen">Phone and Tablet</span> checkbox selected with the default <span class="packt_screen">API 21: Android 5.0 (Lollipop)</span> selection for the minimum SDK (for this example, it really doesn't matter which API level you choose, as activities have existed since API level 1). Click on <span class="packt_screen">Next</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d713d5e3-4cc9-4254-adf4-5566baab9bec.png"/></p>
<ol start="5">
<li>In the <span class="packt_screen">Add an</span> <span class="packt_screen">Activity to Mobile</span> dialog, select the <span class="packt_screen">Empty Activity</span> option. Click on <span class="packt_screen">Next</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/33f5a871-aaa5-4e9a-8046-779236d3d84b.png"/></p>
<ol start="6">
<li>In the <span class="packt_screen">Configure Activity</span> dialog, you can leave the defaults as provided, but note that the default activity name is <kbd>MainActivity</kbd><span>. Click on</span> <span class="packt_screen">Finish</span><span>:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ffb60187-d75d-483a-914f-cedf7b87f16e.png"/></p>
<p>After finishing the wizard, Android Studio will create the project files. For this recipe, the two files that we will examine are <kbd>MainActivity.java</kbd> (which corresponds to the activity name mentioned in step 6) and <kbd>AndroidManifest.xml</kbd>.</p>
<p>If you take a look at the <kbd>MainActivity.java</kbd> file, you will realize that it's pretty basic. This is because we chose the <span class="packt_screen">Empty Activity</span> option (in step 5). Now, look at the <kbd>AndroidManifest.xml</kbd> file. This is where we actually declare the activity. Within the <kbd>&lt;application&gt;</kbd> element is the <kbd>&lt;activity&gt;</kbd> element:</p>
<pre>&lt;activity android:name=".MainActivity" android:label="@string/app_name"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name=<br/> "android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;</pre>
<div class="packt_infobox">When viewing this <kbd>xml</kbd> in Android Studio, you may notice that the label element shows the actual text (<kbd>DeclareAnActivity</kbd> in this case) as defined in the <kbd>strings.xml</kbd> resource file.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Declaring an activity is a simple matter of declaring the <kbd>&lt;activity&gt;</kbd> element and specifying the name of the activity class with the <kbd>android:name</kbd> attribute. By adding the <kbd>&lt;activity&gt;</kbd> element to the <strong>Android Manifest</strong>, we are specifying our intention to include this component in our application. Any activities (or any other component for that matter) that are not declared in the manifest will not be available to the application. Attempting to access or utilize an undeclared component will result in an exception being thrown at runtime.</p>
<p>In the preceding code, there is another attribute: <kbd>android:label</kbd>. This attribute indicates the title shown on the screen, as well as the icon if this is the Launcher activity.</p>
<div class="packt_infobox">For a complete list of available Activity attributes, take a look at this resource:<br/>
<a href="http://developer.android.com/guide/topics/manifest/activity-element.html">http://developer.android.com/guide/topics/manifest/activity-element.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting a new activity with an intent object</h1>
                </header>
            
            <article>
                
<p>The Android application model can be seen as a service-oriented one, with activities as components and intents as the messages sent between them. Here, an intent is used to start an activity that displays the user's call log, but intents can be used to do many things and we will encounter them throughout this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To keep things simple, we are going to use an intent object to start one of Android's built-in applications rather than create a new one. This only requires a very basic application, so start a new Android project with Android Studio and call it <kbd>ActivityStarter</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Again, to keep the example simple so that we can focus on the task at hand, we will create a function to show an intent in action and call this function from a button on our activity.</p>
<p>Once your new project is created in Android Studio, follow these steps:</p>
<ol>
<li>Open the <kbd>MainActivity.java</kbd> class and add the following function:</li>
</ol>
<pre style="padding-left: 60px">public void launchIntent(View view) { 
    Intent intent = new Intent(Intent.ACTION_VIEW); 
    intent.setData(Uri.parse("https://www.packtpub.com/")); 
    startActivity(intent); 
} </pre>
<ul>
<li style="padding-left: 60px">While you are typing this code, Android Studio will give this warning on View and intent: <span class="packt_screen">Cannot resolve symbol 'Intent'</span>.</li>
<li style="padding-left: 60px">This means that you need to add the library reference to the project. You can do this manually by entering the following code in the <kbd>import</kbd> section:</li>
</ul>
<pre style="padding-left: 60px"><span>        import </span>android.content.Intent<span>;<br/></span><span>        import </span>android.net.Uri<span>;<br/></span><span>        import </span>android.support.v7.app.AppCompatActivity<span>;<br/></span><span>        import </span>android.os.Bundle<span>;<br/></span><span>        import </span>android.view.View<span>;</span></pre>
<div class="packt_tip">Alternatively, let Android Studio add the library reference for you: <span>just click on the code highlighted with a red font and press </span><em><span class="KeyPACKT">Alt</span><span> </span></em><span>+</span><em><span> </span><span class="KeyPACKT">Enter</span></em>.</div>
<ol start="2">
<li>Open the <kbd>activity_main.xml</kbd> file and replace the <kbd>&lt;TextView /&gt;</kbd> block with the following XML:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Launch Browser"<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/button"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"launchIntent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"</span><span>/&gt;</span></pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9b4364cb-0f0e-432a-b49d-84dc72f42ffd.png"/></div>
<ol start="3">
<li>Now, it's time to run the application and see the intent in action. You will need to either create an Android emulator (in Android Studio, go to <span class="packt_screen">Tools </span>| <span class="packt_screen">Android </span>| <span class="packt_screen">AVD</span><span class="packt_screen">Manager</span>) or connect a physical device to your computer.</li>
<li>When you press the <span class="packt_screen">Launch Browser</span> button, you will see the default web browser open with the URL specified.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Though simple, this app demonstrates much of the power behind the Android OS. An intent is a message object. Intents can be used to communicate across your application's components (such as services and broadcast receivers) as well as with other applications on the device. In this recipe, we asked the OS to start any app that could handle the data we specified with the <kbd>setData()</kbd> method. (If the user has multiple browsers installed and no default set, the OS will show a list of apps for the user to choose from.)</p>
<div class="packt_infobox">To test this on a physical device, you may need to install drivers for your device (the drivers are specific to the hardware manufacturer). You will also need to enable Developer Mode on your device. Enabling Developer Mode varies according to the Android OS version. If you do not see the Developer Mode option in your device settings, open the <span class="packt_screen">About Phone</span> option and begin tapping <span class="packt_screen">Build Number</span>. After three taps, you should see a <strong>Toast</strong> message telling you that you are on your way to being a developer. Four more taps will enable the option.</div>
<p>In this recipe, we created an intent object with the <kbd>ACTION_VIEW</kbd> . as what we want to do (our intention). You may have noticed that when you typed <kbd>Intent</kbd> and the period, Android Studio provided a pop-up list of possibilities (this is the autocomplete feature), like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/546a9d59-ea59-4c24-8eaa-68c2082ea760.png"/></div>
<p><kbd>ACTION_VIEW</kbd>, along with a URL in the data, indicates that the intention is to view the website, so the default browser is launched (different data could launch different apps). In this example, we just want to open a browser with the specified URL, so we call the <kbd>startActivity()</kbd> method. There are other ways to call the intent depending on our needs. In the <em>Returning a result from an activity</em> recipe, we will use the <kbd>startActivityForResult()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It's very common for Android users to download their favorite apps for web browsing, taking photos, text messaging, and so on. Using Intents, you allow your users to use their favorite apps instead of trying to reinvent all of this functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>To start an activity from a menu selection, refer to the <em>Handling menu selections</em> recipe in <a href="271b832c-648f-4a10-967e-aac99272e9a9.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Menus and Action Mode</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Switching between activities</h1>
                </header>
            
            <article>
                
<p>Often, we will want to activate one activity from within another activity. Although this is not a difficult task, it will require a little more setting up to be done than the previous recipes as it requires two activities. We will create two activity classes and declare them both in the manifest. We'll also create a button, as we did in the previous recipe, to switch to the activity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We'll create a new project in Android Studio, just as we did in the previous recipes, and call this one <kbd>ActivitySwitcher</kbd>. Android Studio will create the first activity, <kbd>ActivityMain</kbd>, and automatically declare it in the manifest.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Since the Android Studio New Project wizard has already created the first activity, we just need to create the second activity. Open the <span class="packt_screen">ActivitySwitcher</span> project and navigate to <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Activity</span> | <span class="packt_screen">Empty </span><span class="packt_screen">Activity</span>, as shown in this screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/133e7491-872e-4b22-81eb-c369e92163d5.png"/></div>
<ol start="2">
<li>In the <span class="packt_screen">New Android Activity</span> dialog, you can leave the default <span class="packt_screen">Activity Name</span> as is, or change it to <kbd>SecondActivity</kbd>, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/21eca820-853d-4f58-8b34-40c1951f17b1.png"/></div>
<ol start="3">
<li>Open the <kbd>MainActivity.java</kbd> file and add the following function:</li>
</ol>
<pre>    public void onClickSwitchActivity(View view) { 
        Intent intent = new Intent(this, SecondActivity.class); 
        startActivity(intent); 
    }</pre>
<ol start="4">
<li>Now, open the <kbd>activity_main.xml</kbd> file located in the <kbd>res/layout</kbd> folder and replace the <kbd>&lt;TextView /&gt;</kbd> with the following XML to create the button:</li>
</ol>
<pre><span>    &lt;Button<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/button"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_centerVertical=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_centerHorizontal=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"Launch Second Activity"<br/></span><span>        </span><span>android</span><span>:onClick=</span><span>"onClickSwitchActivity"<br/></span><span>        </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>        </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>        </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>        </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"</span><span>/&gt;</span></pre>
<ol start="5">
<li>You can run the code at this point and see the second activity open. We're going to go further and add a button to <kbd>SecondActivity</kbd> to close it, which will bring us back to the first activity. Open the <kbd>SecondActivity.java</kbd> file and<br/>
add this function:</li>
</ol>
<pre>    public void onClickClose(View view) { 
        finish(); 
    } </pre>
<ol start="6">
<li>Finally, add the <span class="packt_screen">Close</span> button to the <kbd>SecondActivity</kbd> layout. Open the <kbd>activity_second.xml</kbd> file and add the following <kbd>&lt;Button&gt;</kbd> element to the auto-generated <kbd>ConstraintLayout</kbd>: </li>
</ol>
<pre><span>    &lt;Button<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/buttonClose"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"Close"<br/></span><span>        </span><span>android</span><span>:layout_centerVertical=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:layout_centerHorizontal=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:onClick=</span><span>"onClickClose"<br/></span><span>        </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"<br/></span><span>        </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>        </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>        </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"</span><span>/&gt;</span></pre>
<ol start="7">
<li>Run the application on your device or emulator and see the buttons in action.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The real work of this exercise is in the <kbd>onClickSwitchActivity()</kbd> method from step 3. This is where we declare the second activity for the Intent using <kbd>SecondActivity.class</kbd>. We went one step further by adding the close button to the second activity to show a common real-world situation: launching a new activity, then returning to the original calling activity. This behavior is accomplished in the <kbd>onClickClose()</kbd> function. All it does is call <kbd>finish()</kbd>, but that tells the OS that we're done with the activity. Finish doesn't actually return us to the calling activity (or any specific activity for that matter); it just closes the current activity and relies on the application's <strong>back stack</strong> to show the last activity. If we want a specific activity, we can again use the Intent object and specify the activity class name when creating the Intent.</p>
<p>This activity switching does not make a very exciting application. Our activity does nothing but demonstrates how to switch from one activity to another, which of course will form a fundamental aspect of almost any application that we develop.</p>
<p>If we had manually created the activities, we would need to add them to the manifest. Using the New Android Activity wizard will automatically add the necessary elements to the Android Manifest file. To see what Android Studio did for you, open the <kbd>AndroidManifest.xml</kbd> file and look at the <kbd>&lt;application&gt;</kbd> element:</p>
<pre><span>&lt;activity </span><span>android</span><span>:name=</span><span>".MainActivity"</span><span>&gt;<br/></span><span>    &lt;intent-filter&gt;<br/></span><span>        &lt;action </span><span>android</span><span>:name=</span><span>"android.intent.action.MAIN" </span><span>/&gt;<br/></span><span><br/></span><span>        &lt;category </span><span>android</span><span>:name=</span><span>"android.intent.category.LAUNCHER" </span><span>/&gt;<br/></span><span>    &lt;/intent-filter&gt;<br/></span><span>&lt;/activity&gt;<br/></span><span>&lt;activity </span><span>android</span><span>:name=</span><span>".SecondActivity"</span><span>&gt;&lt;/activity&gt;</span></pre>
<p>One thing to note in the preceding auto-generated code is that the second activity does not have the <kbd>&lt;intent-filter&gt;</kbd> element. The main activity is generally the entry point when starting the application. That's why <kbd>MAIN</kbd> and <kbd>LAUNCHER</kbd> are defined so that the system will know which activity to launch when the application starts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>To learn more about embedding widgets such as the Button, visit <a href="3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml" target="_blank">Chapter 2</a>, <em>Views, Widgets, and Styles</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing data to another activity</h1>
                </header>
            
            <article>
                
<p>The intent object is defined as a messaging object. As a message object, its purpose is to communicate with other components of the application. In this recipe, we'll show you how to pass information with the intent and how to get it out again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe will pick up from where the previous one ended. We will call this project <kbd>SendData</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Since this recipe is building on the previous recipe, most of the work is already done.  We'll add an <kbd>EditText</kbd> element to the main activity so that we have something to send to <kbd>SecondActivity</kbd>. We'll use the (auto-generated) <kbd>TextView</kbd> view to display the message. The following are the complete steps:</p>
<ol>
<li>Open <kbd>activity_main.xml</kbd> and add the following <kbd>&lt;EditText&gt;</kbd> element above the button:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;EditText<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/editTextData"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toTopOf=</span><span>"@+id/button" </span><span>/&gt;</span></pre>
<p style="padding-left: 60px">The <kbd>&lt;Button&gt;</kbd> element that we created in the previous recipe doesn't change.</p>
<ol start="2">
<li>Now, open the <kbd>MainActivity.java</kbd> file and change the <kbd>onClickSwitchActivity()</kbd> method as follows:</li>
</ol>
<pre style="padding-left: 60px">public void onClickSwitchActivity(View view) { 
    EditText editText = (EditText)findViewById(R.id.editTextData); 
    String text = editText.getText().toString(); 
    Intent intent = new Intent(this, SecondActivity.class); 
    intent.putExtra(Intent.EXTRA_TEXT,text); 
    startActivity(intent); 
}</pre>
<ol start="3">
<li>Next, open the <kbd>activity_second.xml</kbd> file and add the following <kbd>&lt;TextView&gt;</kbd> element:</li>
</ol>
<pre style="padding-left: 60px"><span>&lt;TextView<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/textViewText"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toTopOf=</span><span>"@id/buttonClose"</span><span>/&gt;</span></pre>
<ol start="4">
<li>The last change is to edit the second activity to look for this new data and display it on the screen. Open <kbd>SecondActivity.java</kbd> and edit <kbd>onCreate()</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>protected void </span><span>onCreate</span>(Bundle savedInstanceState) {<br/>    <span>super</span>.onCreate(savedInstanceState)<span>;<br/></span><span>    </span>setContentView(R.layout.<span>activity_second</span>)<span>;<br/></span><span>    </span>TextView textView = (TextView) findViewById(R.id.<span>textViewText</span>)<span>;<br/></span><span>    if </span>(getIntent() != <span>null </span>&amp;&amp; getIntent().hasExtra(Intent.<span>EXTRA_TEXT</span>)) {<br/>        textView.setText(getIntent().getStringExtra(Intent.<span>EXTRA_TEXT</span>))<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="5">
<li>Now, run the project. Type some text in the main activity and press <span class="packt_screen">Launch Second Activity</span> to see it send the data.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As expected, the Intent object is doing all the work. We created an intent just as in the previous recipe and then added some extra data. Did you notice the <kbd>putExtra()</kbd> method call? In our example, we used the already defined <kbd>Intent.EXTRA_TEXT</kbd> as the identifier, but we didn't have to. We can use any key we want (you've seen this concept before if you're familiar with name/value pairs).</p>
<p>The key point about using name/value pairs is that you have to use the same name to get the data back out. That's why we used the same key identifier when we read the extra data with <kbd>getStringExtra()</kbd>.</p>
<p>The second activity was launched with the intent that we created, so it's simply a matter of getting the intent and checking for the data sent along with it. We do this in <kbd>onCreate()</kbd>:</p>
<pre>textView.setText(getIntent().getStringExtra(Intent.EXTRA_TEXT)); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We aren't limited to just sending <kbd>String</kbd> data. The intent object is very flexible and already supports basic data types. Go back to Android Studio and click on the <kbd>putExtra</kbd> method. Then, hit <em><span class="KeyPACKT">Ctrl</span></em> and the s<span class="KeyPACKT">pacebar</span>. Android Studio will bring up the auto-complete list so that you can see the different data types that you can store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Returning a result from an activity</h1>
                </header>
            
            <article>
                
<p>Being able to start one activity from another is very useful and commonly used, but there are times when we need to know the result from the called activity. The <kbd>startActivityForResult()</kbd> method provides the solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Returning a result from an activity is not very different from the way we just called the activity in the previous recipes. You can either use the project from the previous recipe or start a new project and call it <kbd>GettingResults</kbd>. Either way, once you have a project with two activities and the code needed to call the second activity, you're ready to begin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>There are only a few changes needed to get the results:</p>
<ol>
<li>First of all, open <kbd>MainActivity.java</kbd> and add the following constant to the class:</li>
</ol>
<pre style="padding-left: 60px">public static final String REQUEST_RESULT="REQUEST_RESULT"; </pre>
<ol start="2">
<li>Next, change the way the intent is called by modifying the <kbd>onClickSwitchActivity()</kbd> method to expect a result:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>onClickSwitchActivity</span>(View view) {<br/>    EditText editText = (EditText)findViewById(R.id.<span>editTextData</span>)<span>;<br/></span><span>    </span>String text = editText.getText().toString()<span>;<br/></span><span>    </span>Intent intent = <span>new </span>Intent(<span>this, </span>SecondActivity.<span>class</span>)<span>;<br/></span><span>    </span>intent.putExtra(Intent.<span>EXTRA_TEXT</span><span>,</span>text)<span>;<br/></span><span>    </span>startActivityForResult(intent<span>,</span><span>1</span>)<span>;<br/></span>}</pre>
<ol start="3">
<li>Then, add this new method to receive the result:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>protected void </span><span>onActivityResult</span>(<span>int </span>requestCode<span>, int </span>resultCode<span>, </span>Intent data) {<br/>    <span>super</span>.onActivityResult(requestCode<span>, </span>resultCode<span>, </span>data)<span>;<br/></span><span>    if </span>(resultCode==<span>RESULT_OK</span>) {<br/>        Toast.<span>makeText</span>(<span>this, </span>Integer.<span>toString</span>(data.getIntExtra(<span>REQUEST_RESULT</span><span>, <br/></span><span>                </span><span>0</span>))<span>, </span>Toast.<span>LENGTH_LONG</span>).show()<span>;<br/></span><span>    </span>}<br/>}</pre>
<ol start="4">
<li>Finally, modify <kbd>onClickClose</kbd> in <kbd>SecondActivity.java</kbd> to set the return value as follows:</li>
</ol>
<pre style="padding-left: 60px">public void onClickClose(View view) { 
    Intent returnIntent = new Intent(); 
    returnIntent.putExtra(MainActivity.REQUEST_RESULT,42); 
    setResult(RESULT_OK, returnIntent); 
    finish(); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you can see, getting the results back is relatively straightforward. We just call the intent with <kbd>startActivityForResult</kbd>, indicating we want a result back. We set up the <kbd>onActivityResult()</kbd> callback handler to receive the results. Finally, we make sure that the second activity returns a result with <kbd>setResult()</kbd> before closing the activity. In this example, we are just setting a result with a static value. We use a simple Toast to display the result back to the user.</p>
<p>It's good practice to check the result code to make sure that the user didn't cancel the action. It's technically an integer, but the system uses it as a Boolean value. Check for either <kbd>RESULT_OK</kbd> or <kbd>RESULT_CANCEL</kbd> and proceed accordingly. In our example, the second activity doesn't have a cancel button, so why bother to check? What if the user hits the back button? Android will set the result code to <kbd>RESULT_CANCEL</kbd> and the intent to null, which would cause our code to throw an exception if we attempt to access the null result.</p>
<p>We made use of the <strong>Toast</strong> object, which displays a convenient pop-up <strong>message </strong>to unobtrusively notify the user. It also functions as a handy method for debugging as it doesn't need a special layout or screen space.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Besides the result code, <kbd>onActivityResults()</kbd> also includes a <strong>Request Code</strong>. Are you wondering where that came from? It is simply the integer value that was passed with the <kbd>startActivityForResult()</kbd> call, which takes this form:</p>
<pre>startActivityForResult(Intent intent, int requestCode); </pre>
<p>We didn't check the request code because we knew we had only one result to handle, but in non-trivial applications with several activities, this value can be used to identify which Activity is returning a result.</p>
<div class="packt_tip">If <kbd>startActivityForResult()</kbd> is called with a negative request code, it will behave the same as if we used <kbd>startActivity()</kbd>, that is, it will not return a result.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>To learn more about creating new activity classes, refer to the <em>Switching between activities</em> recipe</li>
<li>For more information about Toasts, check out the <em>Making a Toast</em> recipe in <a href="3d708b9b-223b-493a-bf48-48fc306aa0a5.xhtml"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Alerts and Notifications</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving an activity's state</h1>
                </header>
            
            <article>
                
<p>The mobile environment is very dynamic, with users changing tasks much more often than on desktops. With generally fewer resources on a mobile device, it should be expected that your application will be interrupted at some point. It's also very possible that the system will shut down your app completely to give additional resources to the task at hand. It's the nature of mobiles.</p>
<p>A user might start typing something in your app, be interrupted by a phone call, or switch over to send a text message, and by the time they get back to your app, the OS may have closed your app completely to free up the memory. To provide the best user experience, you need to expect such behavior and make it easier for your user to resume from where they left off. The good thing is that the Android OS makes this easier by providing callbacks to notify your app of state changes.</p>
<div class="packt_infobox">Simply rotating your device will cause the OS to destroy and recreate your activity. This might seem a bit heavy-handed, but it's done for a good reason: it's very common to have different layouts for portrait and landscape, so this ensures that your app is using the correct resources.</div>
<p>In this recipe, you'll see how to handle the <kbd>onSaveInstanceState()</kbd> and <kbd>onRestoreInstanceState()</kbd> callbacks to save your application's state. We will demonstrate this by creating a counter variable and increment it each time the <span class="packt_screen">Count</span><br/>
button is pressed. We will also have an <kbd>EditText</kbd> and a <kbd>TextView</kbd> widget to see their default behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio and name it <kbd>StateSaver</kbd>. We need only a single activity, so the auto-generated main activity is sufficient. However, we will need a few widgets, including <kbd>EditText</kbd>, <kbd>Button</kbd>, and <kbd>TextView</kbd>. Their layout (in <kbd>activity_main.xml</kbd>) will be as follows:</p>
<pre><span>&lt;EditText<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/editText"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_alignParentTop=</span><span>"true"<br/></span><span>    </span><span>android</span><span>:layout_alignParentStart=</span><span>"true"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toTopOf=</span><span>"@+id/button"</span><span>/&gt;<br/></span><span><br/></span><span>&lt;Button<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/button"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_centerInParent=</span><span>"true"<br/></span><span>    </span><span>android</span><span>:text=</span><span>"Count"<br/></span><span>    </span><span>android</span><span>:onClick=</span><span>"onClickCounter"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toTopOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"</span><span>/&gt;<br/></span><span><br/></span><span>&lt;TextView<br/></span><span>    </span><span>android</span><span>:id=</span><span>"@+id/textViewCounter"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>    </span><span>android</span><span>:layout_below=</span><span>"@id/button"<br/></span><span>    </span><span>app</span><span>:layout_constraintLeft_toLeftOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintRight_toRightOf=</span><span>"parent"<br/></span><span>    </span><span>app</span><span>:layout_constraintTop_toBottomOf=</span><span>"@id/button"<br/></span><span>    </span><span>app</span><span>:layout_constraintBottom_toBottomOf=</span><span>"parent"</span><span>/&gt;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Perform the following set of steps:</p>
<ol>
<li>To keep track of the counter, we need to add a global variable to the project, along with a key for saving and restoring. Add the following code to the <kbd>MainActivity.java</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">static final String KEY_COUNTER = "COUNTER"; 
private int mCounter=0; </pre>
<ol start="2">
<li>Then, add the code needed to handle the button press; it increments the counter and displays the result in the <kbd>TextView</kbd> widget:</li>
</ol>
<pre style="padding-left: 60px"><span>public void </span><span>onClickCounter</span>(View view) {<br/>    <span>mCounter</span>++<span>;<br/></span><span>    </span>((TextView)findViewById(R.id.<span>textViewCounter</span>))<br/>            .setText(<span>"Counter: " </span>+ Integer.<span>toString</span>(<span>mCounter</span>))<span>;<br/></span>}</pre>
<ol start="3">
<li>To receive notifications of application state change, we need to add the <kbd>onSaveInstanceState()</kbd> and <kbd>onRestoreInstanceState()</kbd> methods to our application. Open <kbd>MainActivity.java</kbd> and add the following:</li>
</ol>
<pre style="padding-left: 60px">@Override 
protected void onSaveInstanceState(Bundle outState) { 
    super.onSaveInstanceState(outState); 
    outState.putInt(KEY_COUNTER,mCounter); 
} 
 
@Override 
protected void onRestoreInstanceState(Bundle savedInstanceState) { 
    super.onRestoreInstanceState(savedInstanceState); 
    mCounter=savedInstanceState.getInt(KEY_COUNTER); 
} </pre>
<ol start="4">
<li>Run the program and try changing the orientation to see how it behaves (if you're using the emulator, <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">F11</span></em> will rotate the device).</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>All activities go through multiple states during their lifetime. By setting up callbacks to handle the events, we can have our code save important information before the activity is destroyed.</p>
<p>Step 3 is where the actual saving and restoring occurs. The OS sends a <strong>Bundle</strong> (a data object that also uses name/value pairs) to the methods. We use the <kbd>onSaveInstanceState()</kbd> callback to save the data and pull it out in the <kbd>onRestoreInstanceState()</kbd> callback.</p>
<p>But wait! Did you try typing text in the <kbd>EditText</kbd> view before rotating the device? If so, you'd have noticed that the text was also restored, but we don't have any code to handle that view. By default, the system will automatically save the state, provided it has a unique ID.</p>
<div class="packt_tip">Note that if you want Android to automatically save and restore the state of a view, it must have a unique ID (specified with the <kbd>android:id=</kbd> attribute in the layout). Bur beware: not all view types automatically save and restore the state of a view.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The <kbd>onRestoreInstanceState()</kbd> callback is not the only place where the state can be restored. Look at the signature of <kbd>onCreate()</kbd>:</p>
<pre>onCreate(Bundle savedInstanceState) </pre>
<p>Both methods receive the same <kbd>Bundle</kbd> instance named <kbd>savedInstanceState</kbd>. You could move the restore code to the <kbd>onCreate()</kbd> method and it would work the same. But one catch is that the <kbd>savedInstanceState</kbd> bundle will be null if there is no data, such as during the initial creation of the activity. If you want to move the code from the <kbd>onRestoreInstanceState()</kbd> callback, just check to make sure that the data is not null. Here's how that code would look:</p>
<pre>if (savedInstanceState!=null) { 
    mCounter = savedInstanceState.getInt(KEY_COUNTER); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Storing persistent activity data</em> recipe will introduce persistent storage</li>
<li>Take a look at <a href="2bf1b0ac-516b-48e1-95f6-ce76f2046d20.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label">Data Storage,</span></span> for more examples on how to persist data</li>
<li>The <em>Understanding the activity life cycle</em> recipe explains the Android Activity life cycle</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Storing persistent activity data</h1>
                </header>
            
            <article>
                
<p>Being able to store information about our activities on a temporary basis is very useful, but more often than not, we will want our application to remember information across multiple sessions.</p>
<p>Android supports SQLite, but that could be a lot of overhead for simple data, such as the user's name or a high score. Fortunately, Android also provides a lightweight option for these scenarios with <kbd>SharedPreferences</kbd>. <span>(In a real-world application, you'll likely use both options for saving data.)</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You can either use the project from the previous recipe or start a new project and call it <kbd>PersistentData</kbd>. In the previous recipe, we saved <kbd>mCounter</kbd> in the session state. In this recipe, we'll add a new method to handle <kbd>onPause()</kbd> and save <kbd>mCounter</kbd> to <kbd>SharedPreferences</kbd>. We'll restore the value in <kbd>onCreate()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We have only two changes to make, and both are in <kbd>MainActivity.java</kbd>:</p>
<ol>
<li>Add the following <kbd>onPause()</kbd> method to save the data before the activity closes:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>protected void </span><span>onPause</span>() {<br/>    <span>super</span>.onPause()<span>;<br/></span><span>    </span>SharedPreferences settings = getPreferences(<span>MODE_PRIVATE</span>)<span>;<br/></span><span>    </span>SharedPreferences.Editor editor = settings.edit()<span>;<br/></span><span>    </span>editor.putInt(<span>KEY_COUNTER</span><span>, </span><span>mCounter</span>)<span>;<br/></span><span>    </span>editor.commit()<span>;<br/></span>}</pre>
<ol start="2">
<li>Then, add the following code at the end of <kbd>onCreate()</kbd> to restore the counter:</li>
</ol>
<pre style="padding-left: 60px">SharedPreferences settings = getPreferences(<span>MODE_PRIVATE</span>)<span>;<br/></span><span>int </span>defaultCounter = <span>0</span><span>;<br/></span><span>mCounter </span>= settings.getInt(<span>KEY_COUNTER</span><span>, </span>defaultCounter)<span>;<br/></span>((TextView)findViewById(R.id.<span>textViewCounter</span>))<br/>        .setText(<span>"Counter: " </span>+ Integer.<span>toString</span>(<span>mCounter</span>))<span>;</span></pre>
<ol start="3">
<li>Run the program and try it out.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you can see, this is very similar to saving state data, because it also uses name/value pairs. Here, we just stored an <kbd>int</kbd>, but we can just as easily store one of the other primitive data types. Each data type has equivalent getters and setters, for example, <kbd>SharedPreferences.getBoolean()</kbd> or <kbd>SharedPreferences.setString()</kbd>.</p>
<p>Saving our data requires the services of <kbd>SharedPreferences.Editor</kbd>. This is evoked with <kbd>edit()</kbd> and accepts <kbd>remove()</kbd> and <kbd>clear()</kbd> procedures, as well as setters such as <kbd>putInt()</kbd>. Note that we must conclude any changes with the <kbd>commit()</kbd> statement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There is a slightly more sophisticated variant of the <kbd>getPreferences()</kbd> accessor: <kbd>getSharedPreferences()</kbd>. It can be used to store multiple preference sets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using more than one preference file</h1>
                </header>
            
            <article>
                
<p>Using <kbd>getSharedPreferences()</kbd> is no different from using its counterpart, but it allows for more than one preference file. It takes the following form:</p>
<pre>getSharedPreferences(String name, int mode) </pre>
<p>Here, <kbd>name</kbd> is the file. The <kbd>mode</kbd> can be either <kbd>MODE_PRIVATE</kbd>, <kbd>MODE_WORLD_READABLE</kbd>, or <kbd>MODE_WORLD_WRITABLE</kbd> and describes the file's access levels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="2bf1b0ac-516b-48e1-95f6-ce76f2046d20.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Data Storage</em>, for more examples on data storage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the activity life cycle</h1>
                </header>
            
            <article>
                
<p>As mobile hardware continues to improve, so too does the demand placed on that hardware. With increasingly more powerful applications and user multi-tasking, the already limited resources can be quite challenging. The Android OS has many features built in to help the user get the best performance from their device, such as limiting background processes, disabling application notifications, and allowing data limits. The OS will also manage application lifetime based on foreground tasks. If your application is in the foreground, the life cycle is straightforward. But as soon as your user switches tasks and your application is moved to the background, understanding the Android application life cycle becomes very important.</p>
<p>The following diagram shows the stages through which an activity passes during its lifetime:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ef2056bc-430c-4f66-b623-6c0055c0a21f.png" style="width:25.42em;height:37.08em;"/></div>
<p>Along with the stages, the diagram also shows the methods that can be overridden. As you can see, we've already utilized most of these methods in the preceding recipes. Hopefully, getting the big picture will help your understanding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new project in Android Studio with a <span class="packt_screen">Blank Activity</span>, and call it <kbd>ActivityLifecycle</kbd>. We will use the (auto-generated) <kbd>TextView</kbd> method to display the state information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To see the application move through the various stages, we will create methods for all<br/>
the stages:</p>
<ol>
<li>Open <kbd>activity_main.xml</kbd> and add an ID to the auto-generated <kbd>TextView</kbd>:</li>
</ol>
<pre style="padding-left: 60px">android:id="@+id/textViewState" </pre>
<ol start="2">
<li>The remaining steps will be in <kbd>MainActivity.java</kbd>. Modify the <kbd>onCreate()</kbd> method to set the initial text:</li>
</ol>
<pre style="padding-left: 60px">((TextView)findViewById(R.id.<span>textViewState</span>)).setText(<span>"onCreate()n"</span>)<span>;<br/></span></pre>
<ol start="3">
<li>Add the following methods to handle the remaining events:</li>
</ol>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>protected void </span><span>onStart</span>() {<br/>    <span>super</span>.onStart()<span>;<br/></span><span>    </span>((TextView)findViewById(R.id.<span>textViewState</span>)).append(<span>"onStart()</span><span>\n</span><span>"</span>)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>protected void </span><span>onResume</span>() {<br/>    <span>super</span>.onResume()<span>;<br/></span><span>    </span>((TextView)findViewById(R.id.<span>textViewState</span>)).append(<span>"onResume()</span><span>\n</span><span>"</span>)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>protected void </span><span>onPause</span>() {<br/>    <span>super</span>.onPause()<span>;<br/></span><span>    </span>((TextView)findViewById(R.id.<span>textViewState</span>)).append(<span>"onPause()</span><span>\n</span><span>"</span>)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>protected void </span><span>onStop</span>() {<br/>    <span>super</span>.onStop()<span>;<br/></span><span>    </span>((TextView)findViewById(R.id.<span>textViewState</span>)).append(<span>"onStop()</span><span>\n</span><span>"</span>)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>protected void </span><span>onRestart</span>() {<br/>    <span>super</span>.onRestart()<span>;<br/></span><span>    </span>((TextView)findViewById(R.id.<span>textViewState</span>)).append(<span>"onRestart()</span><span>\n</span><span>"</span>)<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>protected void </span><span>onDestroy</span>() {<br/>    <span>super</span>.onDestroy()<span>;<br/></span><span>    </span>((TextView)findViewById(R.id.<span>textViewState</span>)).append(<span>"onDestroy()</span><span>\n</span><span>"</span>)<span>;<br/></span>}</pre>
<ol start="4">
<li>Run the application and observe what happens when the activity is interrupted by pressing the Back and Home keys. Try other actions, such as task switching, to see how they impact your application.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Our activity can exist in one of these three states: <strong>active</strong>, <strong>paused</strong>, or <strong>stopped</strong>. There is also<br/>
a fourth state, <strong>destroyed</strong> (but there's no guarantee the OS will ever call it):</p>
<ul>
<li>An activity is in the <kbd>active</kbd> state when its interface is available for the user. It persists from <kbd>onResume()</kbd> until <kbd>onPause()</kbd>, which is brought about when another activity comes to the foreground. If this new activity does not entirely obscure our activity, then ours will remain in the <kbd>paused</kbd> state until the new activity is finished or dismissed. It will then immediately call <kbd>onResume()</kbd> and continue.</li>
<li>When a newly started activity fills the screen or makes our activity invisible, then our activity will enter the <kbd>stopped</kbd> state, and resumption will always invoke a call to <kbd>onRestart()</kbd>.</li>
<li>When an activity is in either the <kbd>paused</kbd> or <kbd>stopped</kbd> state, the operating system can (and will) remove it from the memory when the memory is low or when other applications demand it.</li>
<li>It is worth noting that we never actually see the results of the <kbd>onDestroy()</kbd> method, as the activity is removed by this point. If you want to explore these methods further, then it is well worth employing <kbd>Activity.isFinishing()</kbd> to see whether the activity is really finishing before <kbd>onDestroy()</kbd> is executed, as seen in the following snippet:</li>
</ul>
<pre style="padding-left: 60px"><span>@Override<br/></span><span>public void </span><span>onPause</span>() {<br/>    <span>super</span>.onPause()<span>;<br/></span><span>    </span>((TextView)findViewById(R.id.<span>textViewState</span>)).append(<span>"onPause()</span><span>\n</span><span>"</span>)<span>;<br/></span><span>    if </span>(isFinishing()){<br/>        ((TextView)findViewById(R.id.<span>textViewState</span>)).append(<span>" ... finishing"</span>)<span>;<br/></span><span>    </span>}<br/>}</pre>
<div class="packt_tip">When implementing these methods, always call the superclass before doing any work.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>To shut down an activity, directly call its <kbd>finish()</kbd> method, which in turn calls <kbd>onDestroy()</kbd>. To perform the same action from a child activity, use <kbd>finishFromChild(Activity child)</kbd>, where <kbd>child</kbd> is the calling subactivity.</p>
<p>It is often useful to know whether an activity is being shut down or merely paused, and the <kbd>isFinishing(boolean)</kbd> method returns a value that indicates which of these two states the activity is in.</p>


            </article>

            
        </section>
    </body></html>