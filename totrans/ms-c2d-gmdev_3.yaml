- en: Chapter 3. Focusing on Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。专注于物理
- en: This chapter is for those of you who want to incorporate physics into your games.
    Whether you're building a mini golf game that uses realistic wall bounces or a
    platformer with endless gravity, this chapter is for you. It will have tutorials
    on the physics side of games, as well as show you how to use a physics engine
    without gravity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是为那些想要将物理融入游戏中的您而准备的。无论您是在构建一个使用逼真墙壁弹跳的迷你高尔夫游戏，还是一个具有无尽重力的平台游戏，本章都是为您准备的。它将提供有关游戏物理方面的教程，并展示如何在没有重力的情况下使用物理引擎。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How Chipmunk works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chipmunk 的工作原理
- en: Setting up a project and creating basic objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目和创建基本对象
- en: Setting gravity by tilting the device
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过倾斜设备设置重力
- en: Handling collisions in Chipmunk
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Chipmunk 中处理碰撞
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must use Chipmunk for collision detection only (and not physics). Not all
    games need (or should even consider using) a physics engine. Sometimes, it's better
    to leave it out. However, if you feel your game will either be more polished or
    be produced faster, then by all means use it. That being said, the project in
    this book will not need a physics engine. So, instead of following the project
    here, we will create a small project that has many modular examples that can be
    adapted in your other projects. The book's main project will continue in the next
    chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须仅使用 Chipmunk 进行碰撞检测（而不是物理）。并非所有游戏都需要（或甚至应该考虑使用）物理引擎。有时，最好将其排除在外。然而，如果您觉得您的游戏将更加精致或生产速度更快，那么请务必使用它。话虽如此，本书中的项目将不需要物理引擎。因此，我们不会在这里遵循项目，而是将创建一个小项目，其中包含许多模块化示例，这些示例可以适应您的其他项目。本书的主要项目将在下一章继续。
- en: You may have been used to using the Box2D physics engine, but ever since version
    3.0 of Cocos2d, there is no longer any support from the developers to make Box2D
    work out of the box as it did in previous versions. That being said, this chapter
    will focus on Chipmunk. If this chapter does not cover everything you need as
    far as physics is concerned, feel free to check out the documentation at [http://chipmunk-physics.net/documentation.php](http://chipmunk-physics.net/documentation.php).
    It also has a variety of online tutorials.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经习惯了使用 Box2D 物理引擎，但自从 Cocos2d 的 3.0 版本以来，开发者不再提供任何支持，使得 Box2D 无法像之前版本那样直接工作。话虽如此，本章将专注于
    Chipmunk。如果本章没有涵盖您在物理方面的所有需求，请随时查看[http://chipmunk-physics.net/documentation.php](http://chipmunk-physics.net/documentation.php)的文档。它还提供了各种在线教程。
- en: Learn how Chipmunk works
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Chipmunk 的工作原理
- en: As previously mentioned, Chipmunk is the physics engine that's integrated with
    Cocos2d, and is the main physics engine from version 3.0 onwards. The good news
    for both newcomers and fans of Box2D alike is that Chipmunk is very simple to
    use. Let's get down to how Chipmunk basically works.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Chipmunk 是与 Cocos2d 集成的物理引擎，并且是从 3.0 版本开始的主要物理引擎。对于新人和 Box2D 的粉丝来说，好消息是
    Chipmunk 非常易于使用。让我们来看看 Chipmunk 基本上是如何工作的。
- en: Overall structure of Chipmunk
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chipmunk 的整体结构
- en: Chipmunk is a physics engine in Cocos2d that simulates real-world physics, that
    is, making use of gravity, collisions, objects bouncing off each other, and so
    on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Chipmunk 是 Cocos2d 中的一个物理引擎，它模拟现实世界的物理，即利用重力、碰撞、物体相互弹跳等。
- en: Chipmunk uses a "bodies within a world" way of doing things. This means that,
    as shown in the following diagram, there's a physics simulation happening (called
    a **world**), and anything with physics applicable to it is a **body**. You just
    create a world that will simulate physics on the bodies within, and off you go.
    Each world you create will have its own gravity attached to it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Chipmunk 使用“世界中的物体”的方式来处理事情。这意味着，如图所示，有一个物理模拟正在进行（称为**世界**），并且任何适用于物理的物体都是一个**物体**。您只需创建一个世界，它将在其中的物体上模拟物理，然后就可以开始了。您创建的每个世界都将有自己的重力附加到它。
- en: This is a simple representation of bodies within a world. Note that the entire
    green rectangle is the world, and the individual squares are bodies within it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对世界中物体的简单表示。请注意，整个绿色矩形是世界，而单个正方形是其中的物体。
- en: '![Overall structure of Chipmunk](img/image00243.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Chipmunk的整体结构](img/image00243.jpeg)'
- en: Each body has a type (explained in the next section) as well as properties such
    as density, mass, friction, elasticity, velocity, and more. In Cocos2d, you can
    attach a physics body to a sprite with a single line of code, and the sprite will
    move around to the place where the body is located.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个物体都有一个类型（下一节将解释）以及密度、质量、摩擦、弹性、速度等属性。在 Cocos2d 中，你可以用一行代码将物理体附加到精灵上，精灵将移动到身体所在的位置。
- en: When these objects have their boundaries touching/intersecting one another,
    it's a collision. When a collision occurs, you can handle it however you wish.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些物体的边界相互接触/相交时，就发生了碰撞。当发生碰撞时，你可以按自己的意愿处理它。
- en: Types of bodies
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物体的类型
- en: 'Chipmunk has three types of physics bodies that can be added to the world.
    They are static, dynamic, and kinematic:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Chipmunk 有三种类型的物理体可以添加到世界中。它们是静态的、动态的和运动的：
- en: '**Static bodies**: These are the walls, ground, immovable rocks, and other
    objects in the game. They will not be affected by any gravity or other forces
    that try to interact with them.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态体**：这些是墙壁、地面、不可移动的岩石和游戏中的其他物体。它们不会受到任何重力或其他试图与之交互的力的作用。'
- en: '**Dynamic bodies**: These are the default when creating a `CCPhysicsBody` object.
    These are the objects that will go flying around, colliding with other objects,
    and have forces act upon them.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态体**：创建 `CCPhysicsBody` 对象时的默认设置。这些是会四处飞溅、与其他物体碰撞并受到力作用的物体。'
- en: '**Kinematic bodies**: These are a sort of hybrid body type that cannot be influenced
    by forces or gravity, but can still be moved by `CCActions` and other methods.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动学体**：这是一种混合体类型，不能受到力或重力的作用，但仍然可以通过 `CCActions` 和其他方法移动。'
- en: In general, you will only be using static and dynamic bodies (and so is the
    case with this chapter). If you feel that you need more help with kinematic body
    types, check out the Cocos2d documentation about physics bodies at [http://www.cocos2d-swift.org/docs/api/Constants/CCPhysicsBodyType.html](http://www.cocos2d-swift.org/docs/api/Constants/CCPhysicsBodyType.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你只会使用静态和动态体（本章也是如此）。如果你觉得需要更多关于运动学体类型的帮助，请查看 Cocos2d 关于物理体的文档，网址为 [http://www.cocos2d-swift.org/docs/api/Constants/CCPhysicsBodyType.html](http://www.cocos2d-swift.org/docs/api/Constants/CCPhysicsBodyType.html)。
- en: Now that you know how Chipmunk works from a technical perspective, let's actually
    get down to the coding so that we can see these physics bodies for ourselves.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从技术角度了解了 Chipmunk 的工作原理，让我们实际开始编码，以便我们可以亲自看到这些物理体。
- en: Setting up a project and creating basic objects
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目和创建基本对象
- en: The Chipmunk physics engine is fairly well integrated within the Cocos2d library.
    It works within SpriteBuilder as well as programmatically within Cocos2d. As with
    the rest of this book, we will be focusing on creating the project with code,
    and only using SpriteBuilder as the tool for project creation. So, create a new
    project in SpriteBuilder and publish it. If you've forgotten how to do this, feel
    free to go back and reference the project creation in the first chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Chipmunk 物理引擎在 Cocos2d 库中集成得相当好。它可以在 SpriteBuilder 中工作，也可以在 Cocos2d 中以编程方式工作。与本书的其余部分一样，我们将专注于使用代码创建项目，并且只使用
    SpriteBuilder 作为项目创建的工具。因此，在 SpriteBuilder 中创建一个新的项目并发布它。如果你忘记了如何做，请随时回到第一章中参考项目创建。
- en: Setting up Cocos2d for use with physics
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为使用物理设置 Cocos2d
- en: 'First, we need to lay down the groundwork so that we can begin to code with
    it, as the published SpriteBuilder project uses the SpriteBuilder files and not
    the actual coded scenes. Similar to the previous chapter, open `AppDelegate.m`
    and add the following line of code to the top of the file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要打下基础，以便我们可以开始使用它进行编码，因为发布的 SpriteBuilder 项目使用的是 SpriteBuilder 文件，而不是实际的编码场景。类似于上一章，打开
    `AppDelegate.m` 并在文件顶部添加以下代码行：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in the `startScene` method of the `AppDelegate.m` file, replace that
    one line of code that already exists with the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `AppDelegate.m` 文件的 `startScene` 方法中，用以下代码替换已经存在的那一行代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With that in place, open `MainScene.h` and add code such that your file looks
    something like this (make sure you change the `CCNode` inheritance to `CCScene`,
    or else some later methods won''t work):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，打开 `MainScene.h` 并添加代码，使你的文件看起来像这样（确保将 `CCNode` 继承改为 `CCScene`，否则一些后续的方法将无法工作）：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, open `MainScene.m` and add this block of code between the `@implementation`
    and `@end` lines:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 `MainScene.m` 并在 `@implementation` 和 `@end` 行之间添加以下代码块：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you run the project at this point (in any simulator or on any device), you'll
    see a full, green screen. If you don't, go back and make sure you copy all of
    the code as instructed. If you do see the green color, then you're set to move
    on to the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在此时运行项目（在任何模拟器或设备上），你会看到一个全屏的绿色屏幕。如果没有，请返回并确保你已按照指示复制了所有代码。如果你看到了绿色，那么你已经准备好进入下一部分。
- en: Building a world for physics to exist
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为物理存在构建一个世界
- en: Cocos2d is simply a graphics engine, and we need to create a Chipmunk physics
    simulation environment so that we can make use of the library. This sounds a lot
    more complicated than it actually is. Basically, we create a `CCPhysicsNode` object,
    and then add our sprites and nodes to this object, instead of `self`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d 只是一个图形引擎，我们需要创建一个 Chipmunk 物理模拟环境，以便我们可以使用这个库。这听起来比实际情况要复杂得多。基本上，我们创建一个
    `CCPhysicsNode` 对象，然后把我们的小精灵和节点添加到这个对象中，而不是 `self`。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, `self` is a reference to the current object. In the past, we've added
    objects to the screen using `[self addChild:]`, but with the `CCPhysicsNode` object,
    we're going to add objects using [`world addChild:]`, since `world` will be the
    name of our `CCPhysicsNode` object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`self` 是对当前对象的引用。在过去，我们使用 `[self addChild:]` 将对象添加到屏幕上，但使用 `CCPhysicsNode`
    对象，我们将使用 `[`world addChild:]` 来添加对象，因为 `world` 将是我们 `CCPhysicsNode` 对象的名称。
- en: 'So, open `MainScene.h` and add the declaration for the world variable below
    the `winSize` declaration:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开 `MainScene.h` 文件，并在 `winSize` 声明下方添加对 world 变量的声明：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then open `MainScene.m` and add this block of code after the background is
    created in the `init` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开 `MainScene.m` 文件，并在 `init` 方法中背景创建之后添加以下代码块：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And that's it! The preceding code will create a physics world that allows physics
    to be simulated. All we need to do next is create some `CCNode` objects, add physics
    bodies to the `CCNode` objects, then add the `CCNode` objects to the physics world
    (instead of `self`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！前面的代码将创建一个允许物理模拟的物理世界。我们接下来需要做的是创建一些 `CCNode` 对象，将这些物理体添加到 `CCNode` 对象中，然后将
    `CCNode` 对象添加到物理世界中（而不是 `self`）。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载示例代码文件，以获取你购买的所有
    Packt Publishing 书籍。如果你在其他地方购买了这本书，你可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给你。
- en: Setting `debugDraw` to `YES` ensures that whenever we attach any physics body
    to a `CCNode` object and add it to the world, we will have an outline of that
    body's shape drawn over our objects. Thus, we will know exactly where each body
    is and how it's colliding. Normally, when `debugDraw` is not turned on, we won't
    see these shapes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `debugDraw` 设置为 `YES` 确保每次我们将任何物理体附加到 `CCNode` 对象并添加到世界中时，我们都会在我们的对象上绘制该体的轮廓。因此，我们将确切知道每个体的位置以及它是如何碰撞的。通常，当
    `debugDraw` 未开启时，我们不会看到这些形状。
- en: The collision will still work the same whether you have `debugDraw` on or not.
    The main purpose is to, well, debug the project to make sure the physics bodies
    are added and colliding as intended.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否开启了 `debugDraw`，碰撞效果都会相同。主要目的是调试项目，确保物理体被添加并按照预期进行碰撞。
- en: Enabling touch creation of our object
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用触摸创建我们的对象
- en: Now we are going to need some objects on the screen that we want to collide
    with one another. Instead of programmatically spawning the objects, let's have
    the objects spawn wherever the user touches the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在屏幕上放置一些想要相互碰撞的对象。我们不是通过编程生成对象，而是让对象在用户触摸屏幕的任何位置生成。
- en: 'So, open `MainScene.m` and add the following line of code anywhere in the `init`
    method. This will allow you to grab any touch data from the user:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开 `MainScene.m` 文件，并在 `init` 方法中的任何位置添加以下代码行。这将允许你从用户那里获取任何触摸数据：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, below the `init` method, we add this method so that we can start receiving
    touches in our scene. This method (as seen in the previous chapter) will grab
    any touch event, and we want to grab the location of the touch so that we can
    position the object accordingly. Then we will spawn a black square at the touch
    position:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`init`方法下方，我们添加这个方法，这样我们就可以在我们的场景中开始接收触摸。这个方法（如前一章所示）将捕获任何触摸事件，我们想要捕获触摸的位置，以便我们可以相应地定位对象。然后我们将在触摸位置生成一个黑色方块：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will create a node that's 10 percent of the screen's width and add it to
    the `world` object. We're adding it to `world` instead of `self` because when
    we add physics bodies to the square, we want the simulation to handle the object's
    movement. We need to set the `anchorPoint` of the node because, by default, a
    `CCNode` has its anchor point at (0,0).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个占屏幕宽度的10%的节点并将其添加到`world`对象中。我们将它添加到`world`而不是`self`，因为我们添加物理体到方块时，希望模拟处理对象的运动。我们需要设置节点的`anchorPoint`，因为默认情况下，`CCNode`的锚点在(0,0)。
- en: If you run the game at this point, you will see the same green screen. As you
    tap around the screen, black squares will appear, centered at the touch location.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你此时运行游戏，你会看到相同的绿色屏幕。当你触摸屏幕时，黑色方块会在触摸位置出现。
- en: However, you'll notice that even though we've added them to the world object,
    they aren't falling according to the gravity we set up, and they aren't colliding
    and pushing each other around. What we have to do next is create a `CCPhysicsBody`
    object and assign it to the created square so that the physics simulation will
    handle the movement properly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会注意到，尽管我们已经将它们添加到世界对象中，但它们并没有按照我们设置的引力下落，它们也没有相互碰撞和推动。我们接下来要做的就是创建一个`CCPhysicsBody`对象，并将其分配给创建的方块，以便物理模拟可以正确处理运动。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're still a bit unsure what exactly `CCPhysicsBody` is, it's essentially
    an object that has a shape, or perimeter, that defines where the object can collide
    with other objects. `CCPhysicsBody` also has other properties such as elasticity,
    restitution, density, and so on, and is best used when attached to a `CCNode`
    object so that the node can have its movement handled by the physics body.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不确定`CCPhysicsBody`究竟是什么，它本质上是一个具有形状或周界的对象，这定义了对象可以与哪些其他对象发生碰撞。`CCPhysicsBody`还具有其他属性，如弹性、恢复系数、密度等，并且最好将其附加到`CCNode`对象上，以便节点可以由物理体处理其运动。
- en: Making the objects fall – adding CCPhysicsBody
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使物体下落——添加CCPhysicsBody
- en: 'In the `MainScene.m` file, add the following code to the bottom of the touchBegan
    method. This will add the physics body we want to the square:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainScene.m`文件中，将以下代码添加到`touchBegan`方法的底部。这将添加我们想要的物理体到方块中：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this code in place, when you run the game, you will notice that the objects
    not only begin to fall but also have that debug square that was mentioned earlier.
    Notice that we don't have to declare the body type as **dynamic**, as that's the
    default. Also note the **elasticity** (which, as you might recall, is the bounciness)
    of 0.5\. This is set so that the squares don't go bouncing all over the place.
    If we wanted that, we would've set the elasticity to a higher number, such as
    1.0.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里放置好代码后，当你运行游戏时，你会注意到物体不仅开始下落，而且还有之前提到的调试方块。注意，我们不需要声明为**动态**的物理体类型，因为这是默认设置。还要注意**弹性**（你可能还记得，这是弹跳性），设置为0.5。这是为了确保方块不会到处弹跳。如果我们想要这样，我们会将弹性设置为更高的数字，比如1.0。
- en: But oh no! The squares just fall off the screen as if it's a bottomless pit.
    Let's fix that.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是哦不！方块就像无底洞一样从屏幕上掉落。让我们来修复这个问题。
- en: Adding the ground and walls
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加地面和墙壁
- en: Creating a ground object is easy, but since the walls and the ceiling are basically
    the same thing, let's define a method that will take in `CGRect` and create for
    us a static, invisible node with those dimensions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建地面对象很容易，但由于墙壁和天花板基本上是同一件事，让我们定义一个方法，它将接受`CGRect`并为我们创建一个具有这些尺寸的静态、不可见节点。
- en: 'So, anywhere in `MainScene.m`, add the following method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`MainScene.m`的任何地方，添加以下方法：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code is fairly similar to the square''s code, except for one notable difference:
    the type of the physics body. We set it to `static` because we don''t want the
    gravity affecting it, nor do we want the squares to push the ground in any direction.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与方块的代码非常相似，除了一个明显的区别：物理体的类型。我们将其设置为`static`，因为我们不希望重力影响它，也不希望方块以任何方向推动地面。
- en: 'Just because we declared a method doesn''t mean it will automatically generate
    walls for us. So, go to your `init` method and add the following block of code
    to add the walls around the edges of the device:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为我们声明了一个方法，并不意味着它会自动为我们生成墙壁。所以，去你的`init`方法中，添加以下代码块来在设备的边缘添加墙壁：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is fairly self-explanatory in terms of positioning. The bottom-left
    corner of every Cocos2d scene is (0,0), and the `CGRectMake` function takes in
    the *x* and *y* coordinates, and then the width and height of the rectangle.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在定位方面相当直观。每个Cocos2d场景的左下角是(0,0)，`CGRectMake`函数接受*x*和*y*坐标，然后是矩形的宽度和高度。
- en: That's all for creating a simple object with some physics acting on it! Feel
    free to mess around with some of the variables such as elasticity, gravity, and
    so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建一个具有一些物理作用的简单对象的所有内容！请随意调整一些变量，如弹性、重力等。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'At this point, if you notice that your objects seem to be lagging when they
    move across the screen—even though Xcode says the game is running at 60 FPS—add
    the following line of code at the top of the `startScene` method in `AppDelegate.m`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你注意到你的物体在屏幕上移动时似乎有些滞后——即使Xcode显示游戏正在以60 FPS运行——请在`AppDelegate.m`中的`startScene`方法顶部添加以下行代码：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Setting gravity by tilting the device
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过倾斜设备设置重力
- en: When your user tilts the device, the device's accelerometer will pick up that
    information at even the slightest, most minute values. This is beneficial to those
    who wish to use the accelerometer (or tilting) within their game, especially with
    regards to moving the character or manipulating gravity, which is what we'll cover
    in this section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的用户倾斜设备时，设备的加速度计会在最轻微、最微小的值上捕捉到这些信息。这对希望在游戏中使用加速度计（或倾斜）的人来说是有益的，尤其是在移动角色或操纵重力方面，这是我们将在本节中讨论的内容。
- en: Ever since iOS 5.0, UIAccelerometer has been replaced by the Core Motion framework
    data. Thankfully, it's no more complicated, so let's get started.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自从iOS 5.0以来，UIAccelerometer已被Core Motion框架数据所取代。幸运的是，它并不复杂，让我们开始吧。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you aren''t a registered developer and can''t use your actual device to
    test (and have been doing so on the simulator), note that it''s not possible to
    test the accelerometer with the simulator unless the data can be sent to the simulator.
    Here''s a link that might be useful in this situation: [http://www.vimov.com/isimulate/](http://www.vimov.com/isimulate/).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是注册的开发者，无法使用实际设备进行测试（并且一直在模拟器上这样做），请注意，除非数据可以发送到模拟器，否则无法使用模拟器测试加速度计。这里有一个在这种情况下可能有用的链接：[http://www.vimov.com/isimulate/](http://www.vimov.com/isimulate/)。
- en: However, even if you can't test the accelerometer on the simulator by default,
    it will still work as intended on anyone's device, so if you plan to include the
    accelerometer in your game, feel free to still follow along.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使默认情况下你无法在模拟器上测试加速度计，它仍然会在任何设备上按预期工作，所以如果你计划在你的游戏中包含加速度计，请随意继续操作。
- en: Setting up the accelerometer
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置加速度计
- en: 'Open `MainScene.h` and import the Core Motion framework:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MainScene.h`并导入Core Motion框架：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then add a variable for something called the `CMMotionManager`. This object
    will calculate the accelerometer data, and we can collect this data when we need
    it. Add the following line of code under the `world` variable:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为名为`CMMotionManager`的东西添加一个变量。此对象将计算加速度计数据，我们可以在需要时收集这些数据。在`world`变量下添加以下行代码：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now open `MainScene.m`, and anywhere in the `init` method, add the following
    block of code so that the motion manager we just declared will begin to grab the
    accelerometer''s data:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`MainScene.m`，在任何`init`方法的位置，添加以下代码块，以便我们刚刚声明的运动管理器开始获取加速度计的数据：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Right now, if you run the game, you won't notice any changes in the way it plays
    or any debug information. Even though the motion manager is initialized and is
    grabbing the data, we must set up a method to collect the data so that we can
    do something with it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你运行游戏，你不会注意到它在玩法或任何调试信息上的任何变化。尽管运动管理器已初始化并且正在获取数据，但我们必须设置一个收集数据的方法，以便我们可以对它进行操作。
- en: Reading the data
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取数据
- en: 'In your `init` method of `MainScene.m`, after you''ve initialized the motion
    manager, add the following line of code. It will run the specified method at the
    given interval (60 times per second):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`MainScene.m`的`init`方法中，初始化运动管理器后，添加以下行代码。它将在给定的间隔（每秒60次）运行指定的方法：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, anywhere in `MainScene.m`, we add the method we want to be called at
    the specified interval so that we can read the accelerometer data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`MainScene.m`中的任何地方，我们添加我们想要在指定间隔被调用的方法，这样我们就可以读取加速度计数据：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, if you run the game, you'll see a lot of information being printed in the
    console output in Xcode. If the numbers are changing as you tilt the device, it
    means everything's working. Yay! If not, go back and make sure you add everything
    correctly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏，你将在Xcode的控制台输出中看到大量信息。如果数字在你倾斜设备时发生变化，这意味着一切正常。太好了！如果不这样，请返回并确保你正确添加了所有内容。
- en: Next, we're going to actually set the game's gravity based on how the device
    is rotated at any given moment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据设备在任何给定时刻的旋转设置游戏的重力。
- en: Manipulating gravity to your heart's content
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随心所欲地操纵重力
- en: 'Instead of typing that long line of text every time, let''s make a method with
    a relevant name and pass the accelerometer data. That being said, modify your
    `getAccelerometerData` method to the following, and add this new method, which
    will set the gravity of the physics world based on the accelerometer''s data:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次都输入那么长的文本行，让我们创建一个具有相关名称的方法并传递加速度计数据。换句话说，将你的`getAccelerometerData`方法修改如下，并添加这个新方法，它将根据加速度计的数据设置物理世界的重力：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, if you run the game and spawn a few blocks, you''ll see them floating,
    falling down, sliding sideways, or in whichever direction your iOS device perceives
    as "down." You''ll probably see something similar to the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏并生成几个方块，你会看到它们漂浮、下落、侧滑，或者以iOS设备感知的“下”的任何方向移动。你可能看到的截图如下：
- en: '![Manipulating gravity to your heart''s content](img/image00244.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![随心所欲地操纵重力](img/image00244.jpeg)'
- en: From here onwards, feel free to turn off debug draw, maybe mess around with
    how much gravity is set, or even change the axis the gravity is affected by.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你可以随意关闭调试绘制，也许可以玩一下设置的重力大小，或者甚至改变重力影响的轴。
- en: You might notice that a square stops moving on a wall, then doesn't move when
    you rotate the device; that's because the object's body is sleeping. This is done
    to help conserve CPU processing time as well as energy when an object has no active
    collisions and no forces acting on it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到一个方块在墙上停止移动，然后当你旋转设备时也不移动；这是因为物体的身体处于休眠状态。这样做是为了帮助节省没有活跃碰撞和作用力的物体在CPU处理时间和能量。
- en: 'However, if you need them to be constantly moving, add the following line of
    code to your `init` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要它们持续移动，请将以下代码行添加到你的`init`方法中：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This defaults to 0.5 seconds, and why the sleeping happens when the squares
    stop moving against a wall. Setting it to a relatively large value, such as 100,000,
    will ensure that they never stop moving (that is, unless the square is sitting
    still for that duration, but the higher the threshold is, the less likely it is
    to happen).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下为0.5秒，并且当方块停止与墙壁相对移动时会发生休眠。将其设置为相对较大的值，例如100,000，将确保它们永远不会停止移动（即，除非方块在这段时间内保持静止，但阈值越高，这种情况发生的可能性就越小）。
- en: Handling collisions in Chipmunk
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Chipmunk中处理碰撞
- en: It's relatively easy to handle collisions within Cocos2d when using Chipmunk
    (as is pretty much everything else in Cocos2d). That is why so many developers
    use Cocos2d. To do so, we need to do a few different steps so that Cocos2d can
    properly detect and handle our collisions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Chipmunk（在Cocos2d中几乎做任何事情）时处理碰撞相对容易。这就是为什么许多开发者使用Cocos2d。为了做到这一点，我们需要执行几个不同的步骤，以便Cocos2d能够正确检测和处理我们的碰撞。
- en: Setting the collision delegate
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置碰撞代理
- en: The delegate pattern is a common way to handle messages sent by a class to any
    of its potential parent classes. For example, if you want to use `UITableView`
    (which is the standard table in `UIKit`), you must set the delegate of the table
    view to the class you're adding it to so that when the table view tries to refresh
    the data in the table, it knows which class' methods to call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式是处理由一个类发送给其任何潜在父类的消息的常见方式。例如，如果你想使用`UITableView`（这是`UIKit`中的标准表格），你必须将表格视图的代理设置为你要添加到其中的类，这样当表格视图尝试刷新表格中的数据时，它就知道要调用哪个类的哪些方法。
- en: 'That being said, we need to tell `MainScene` that it will be a delegate for
    our collision handler, so open up `MainScene.h` and add `CCPhysicsCollisionDelegate`
    to the `@interface` line. This will allow the `CCPhysicsNode` object to set collision
    detection events on our `MainScene` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们需要告诉`MainScene`它将成为我们的碰撞处理程序的代理，所以打开`MainScene.h`并将`CCPhysicsCollisionDelegate`添加到`@interface`行。这将允许`CCPhysicsNode`对象在我们的`MainScene`类上设置碰撞检测事件：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then open `MainScene.m`, and in the `init` method, set the `world` object''s
    collision delegate to `self`, like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开`MainScene.m`，在`init`方法中，将`world`对象的碰撞代理设置为`self`，如下所示：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Recall that `world` is our `CCPhysicsNode` object, so any collision detection
    events that happen within that world (or simulation) will need to be sent somewhere
    to be handled further. We're setting it to `self` because self refers to the current
    `MainScene` instance (our currently running scene). Finally, this helps us determine
    which objects collide with other objects. Without this line of code, we wouldn't
    be able to see in the code when two objects collide, let alone tell which objects
    they actually are.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`world`是我们的`CCPhysicsNode`对象，所以在这个世界（或模拟）中发生的任何碰撞检测事件都需要发送到某个地方进行处理。我们将它设置为`self`，因为`self`指的是当前的`MainScene`实例（我们正在运行的场景）。最后，这有助于我们确定哪些对象与哪些对象相撞。如果没有这一行代码，我们就无法在代码中看到两个对象何时相撞，更不用说知道它们实际上是哪些对象了。
- en: Although this doesn't do anything directly if you run the game now, it properly
    sets up your physics simulation to be able to detect and handle collisions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果你现在运行游戏这不会直接做任何事情，但它正确地设置了你的物理模拟，以便能够检测和处理碰撞。
- en: Setting collision tags on game objects
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置游戏对象的碰撞标签
- en: Before we can create the method that will detect our collisions, we need to
    specify which objects will be colliding with one another. For now, we'll only
    be considering squares colliding with other squares.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以创建检测碰撞的方法之前，我们需要指定哪些对象将相互碰撞。现在，我们只考虑正方形与其他正方形之间的碰撞。
- en: 'Therefore, in the `touchBegan` method of the `MainScene.m` file, add the following
    line of code so that the collision detection delegate knows what object is colliding:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`MainScene.m`文件的`touchBegan`方法中添加以下代码行，以便碰撞检测代理知道哪个对象正在相撞：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can do this with any physics body, but for now, this is our only object.
    With that in place, let's add the code to detect the actual collision between
    two squares.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用任何物理体做这件事，但就目前而言，这是我们唯一的对象。有了这个设置，让我们添加代码来检测两个正方形之间的实际碰撞。
- en: Detecting collision
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: The way Chipmunk handles collisions in Cocos2d is by detecting all collisions
    and sending method calls to the respective functions for each collision type.
    So, since we're going to be detecting the collision between two squares, both
    parameters have to be named square. Otherwise, the method won't get called properly.
    The actual names of the variables of the parameters (`firstSquare` and `secondSquare`)
    don't matter for the sake of detection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Chipmunk在Cocos2d中处理碰撞的方式是通过检测所有碰撞并向每个碰撞类型相应的函数发送方法调用。因此，既然我们要检测两个正方形的碰撞，两个参数都必须命名为square。否则，方法将无法正确调用。参数变量的实际名称（`firstSquare`和`secondSquare`）对于检测来说并不重要。
- en: 'So, anywhere in `MainScene.m`, add the following method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`MainScene.m`中的任何地方，添加以下方法：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you run the game at this point, you should see the `squares collided!` text
    being printed to the console output every time a square collides with another.
    If it doesn't, go back and make sure you add everything correctly. From here onwards,
    you can do whatever you want when the two objects collide, as you have a pointer
    to both objects as well as their types.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你应该会看到每次一个正方形与另一个正方形碰撞时，`squares collided!`文本被打印到控制台输出。如果看不到，请返回并确保你正确添加了所有内容。从现在开始，当两个对象碰撞时，你可以做任何你想做的事情，因为你已经有了两个对象的指针以及它们的类型。
- en: 'As another example, suppose we want to detect collisions between the squares
    and a wall; it''s very easy. First, add `wall` as `collisionType` to the body
    in the addWallWithRect method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，假设我们想要检测正方形与墙壁之间的碰撞；这非常简单。首先，在`addWallWithRect`方法中将`wall`作为`collisionType`添加到身体中：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, add the method to detect square-wall collisions (notice the name change
    in the parameter from the previous `collisionBegan` method we added):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加检测正方形-墙壁碰撞的方法（注意在之前添加的`collisionBegan`方法中参数名称的变化）：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you run the game at this point and spawn a square, as soon as it hits a wall,
    you should see the output being printed. And that's it for detecting collisions!
    Just set the `collisionDelegate` property, set the `collisionType` property, and
    add the collision methods.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏并生成一个方块，一旦它碰到墙壁，你应该会看到输出被打印出来。这就是检测碰撞的全部！只需设置 `collisionDelegate` 属性，设置
    `collisionType` 属性，并添加碰撞方法。
- en: What if you want to detect collisions on objects, but don't want them to be
    bouncing with other objects? In Chipmunk, you can do that.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检测对象上的碰撞，但不想它们与其他对象弹跳？在 Chipmunk 中，你可以做到这一点。
- en: Using Chipmunk for just collision detection
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅使用 Chipmunk 进行碰撞检测
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Here is an important note: if you''re going to just detect one of the following,
    you do not need to use a physics engine for your collision detection, but rather
    the listed method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的注意事项：如果你只是要检测以下之一，你不需要使用物理引擎进行碰撞检测，而是使用列出的方法：
- en: For rectangles intersecting rectangles, use `CGRectIntersectsRect`
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于相交的矩形，请使用 `CGRectIntersectsRect`
- en: For points inside rectangles, use `CGRectContainsPoint`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于矩形内部的点，请使用 `CGRectContainsPoint`
- en: For radius/distance intersection, use `ccpDistance`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于半径/距离交集，请使用 `ccpDistance`
- en: If you're going to be detecting collisions with non-rectangular and noncircular
    objects, feel free to read on.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将检测非矩形和非圆形对象的碰撞，请继续阅读。
- en: Sometimes, all you're doing is sending objects across the screen, or rotating
    them with your custom actions, and you just want to know when two objects collide,
    but don't want the bouncing, pushing, and colliding that comes with the entire
    physics engine. Luckily, we can do that in Chipmunk.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你所做的只是将对象发送到屏幕上，或者用你自定义的动作旋转它们，你只想知道两个对象何时碰撞，但不想有整个物理引擎带来的弹跳、推动和碰撞。幸运的是，我们可以在
    Chipmunk 中做到这一点。
- en: Turning the physics body into a sensor
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将物理体转换为传感器
- en: Sensors, with respect to Chipmunk, are basically bodies that can detect collisions,
    but pass right through other bodies. These are helpful when you have areas or
    sections of the screen that trigger certain events, but don't actually cause any
    physics-based interactions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chipmunk 中，传感器基本上是可以检测碰撞但穿过其他物体的物体。当你在屏幕上有区域或部分触发某些事件，但实际上不造成任何基于物理的交互时，这些很有用。
- en: For example, if you're making a top-down mini golf game with a physics engine
    and you want to include ramps, the best way to do this is to set the ramp as a
    sensor. When the ball and ramp collide, set the gravity in a certain direction.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在使用物理引擎制作一个俯视迷你高尔夫游戏，并且想要包含斜坡，最好的方法是将斜坡设置为传感器。当球和斜坡碰撞时，设置重力在某个方向。
- en: 'To make a body a sensor, simply set the `sensor` variable to true, like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个物体设置为传感器，只需将 `sensor` 变量设置为 true，如下所示：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you run the game now, you'll notice that the blocks fall right through one
    another, as well as right through the floor.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你会注意到方块直接穿过彼此，以及穿过地板。
- en: And that's it! All you need is the collision handling (in the previous section),
    and the sensor variable set to true. Any physics body that's a sensor will trigger
    collision detection events, but not cause any movement or changes to other bodies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你所需要的就是碰撞处理（在上一节中），以及将传感器变量设置为 true。任何作为传感器的物理体都会触发碰撞检测事件，但不会引起任何移动或改变其他物体。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, you learned how to create a physics simulation, add
    bodies to the simulation, set the gravity of the world with the accelerometer,
    handle collisions, and even use the simulation for just collision detection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建物理模拟，向模拟中添加物体，使用加速度计设置世界的重力，处理碰撞，甚至仅使用模拟进行碰撞检测。
- en: When it comes to really complex physics engine mechanics, such as ropes, joints,
    and pivots, the Cocos2d documentation at [http://www.cocos2d-swift.org/docs/api/index.html](http://www.cocos2d-swift.org/docs/api/index.html)
    explains a lot. At the time of writing this book, there are very few (if any)
    tutorials on such complex mechanics available.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到真正复杂的物理引擎机制，如绳索、关节和枢轴时，[http://www.cocos2d-swift.org/docs/api/index.html](http://www.cocos2d-swift.org/docs/api/index.html)
    上的 Cocos2d 文档解释了很多。在撰写本书时，关于此类复杂机制的可用的教程非常少（如果有的话）。
- en: In the next chapter, you'll learn about sound in Cocos2d and some of the cool
    things you can do to sound effects within the engine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于 Cocos2d 中的声音以及你可以在引擎中为声音效果做的酷炫事情。
