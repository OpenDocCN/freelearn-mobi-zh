- en: Chapter 3. Focusing on Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is for those of you who want to incorporate physics into your games.
    Whether you're building a mini golf game that uses realistic wall bounces or a
    platformer with endless gravity, this chapter is for you. It will have tutorials
    on the physics side of games, as well as show you how to use a physics engine
    without gravity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Chipmunk works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a project and creating basic objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting gravity by tilting the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling collisions in Chipmunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must use Chipmunk for collision detection only (and not physics). Not all
    games need (or should even consider using) a physics engine. Sometimes, it's better
    to leave it out. However, if you feel your game will either be more polished or
    be produced faster, then by all means use it. That being said, the project in
    this book will not need a physics engine. So, instead of following the project
    here, we will create a small project that has many modular examples that can be
    adapted in your other projects. The book's main project will continue in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You may have been used to using the Box2D physics engine, but ever since version
    3.0 of Cocos2d, there is no longer any support from the developers to make Box2D
    work out of the box as it did in previous versions. That being said, this chapter
    will focus on Chipmunk. If this chapter does not cover everything you need as
    far as physics is concerned, feel free to check out the documentation at [http://chipmunk-physics.net/documentation.php](http://chipmunk-physics.net/documentation.php).
    It also has a variety of online tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: Learn how Chipmunk works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously mentioned, Chipmunk is the physics engine that's integrated with
    Cocos2d, and is the main physics engine from version 3.0 onwards. The good news
    for both newcomers and fans of Box2D alike is that Chipmunk is very simple to
    use. Let's get down to how Chipmunk basically works.
  prefs: []
  type: TYPE_NORMAL
- en: Overall structure of Chipmunk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chipmunk is a physics engine in Cocos2d that simulates real-world physics, that
    is, making use of gravity, collisions, objects bouncing off each other, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Chipmunk uses a "bodies within a world" way of doing things. This means that,
    as shown in the following diagram, there's a physics simulation happening (called
    a **world**), and anything with physics applicable to it is a **body**. You just
    create a world that will simulate physics on the bodies within, and off you go.
    Each world you create will have its own gravity attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple representation of bodies within a world. Note that the entire
    green rectangle is the world, and the individual squares are bodies within it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overall structure of Chipmunk](img/image00243.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each body has a type (explained in the next section) as well as properties such
    as density, mass, friction, elasticity, velocity, and more. In Cocos2d, you can
    attach a physics body to a sprite with a single line of code, and the sprite will
    move around to the place where the body is located.
  prefs: []
  type: TYPE_NORMAL
- en: When these objects have their boundaries touching/intersecting one another,
    it's a collision. When a collision occurs, you can handle it however you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Types of bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chipmunk has three types of physics bodies that can be added to the world.
    They are static, dynamic, and kinematic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static bodies**: These are the walls, ground, immovable rocks, and other
    objects in the game. They will not be affected by any gravity or other forces
    that try to interact with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic bodies**: These are the default when creating a `CCPhysicsBody` object.
    These are the objects that will go flying around, colliding with other objects,
    and have forces act upon them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kinematic bodies**: These are a sort of hybrid body type that cannot be influenced
    by forces or gravity, but can still be moved by `CCActions` and other methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, you will only be using static and dynamic bodies (and so is the
    case with this chapter). If you feel that you need more help with kinematic body
    types, check out the Cocos2d documentation about physics bodies at [http://www.cocos2d-swift.org/docs/api/Constants/CCPhysicsBodyType.html](http://www.cocos2d-swift.org/docs/api/Constants/CCPhysicsBodyType.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how Chipmunk works from a technical perspective, let's actually
    get down to the coding so that we can see these physics bodies for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project and creating basic objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Chipmunk physics engine is fairly well integrated within the Cocos2d library.
    It works within SpriteBuilder as well as programmatically within Cocos2d. As with
    the rest of this book, we will be focusing on creating the project with code,
    and only using SpriteBuilder as the tool for project creation. So, create a new
    project in SpriteBuilder and publish it. If you've forgotten how to do this, feel
    free to go back and reference the project creation in the first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Cocos2d for use with physics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to lay down the groundwork so that we can begin to code with
    it, as the published SpriteBuilder project uses the SpriteBuilder files and not
    the actual coded scenes. Similar to the previous chapter, open `AppDelegate.m`
    and add the following line of code to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `startScene` method of the `AppDelegate.m` file, replace that
    one line of code that already exists with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, open `MainScene.h` and add code such that your file looks
    something like this (make sure you change the `CCNode` inheritance to `CCScene`,
    or else some later methods won''t work):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, open `MainScene.m` and add this block of code between the `@implementation`
    and `@end` lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you run the project at this point (in any simulator or on any device), you'll
    see a full, green screen. If you don't, go back and make sure you copy all of
    the code as instructed. If you do see the green color, then you're set to move
    on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a world for physics to exist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cocos2d is simply a graphics engine, and we need to create a Chipmunk physics
    simulation environment so that we can make use of the library. This sounds a lot
    more complicated than it actually is. Basically, we create a `CCPhysicsNode` object,
    and then add our sprites and nodes to this object, instead of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, `self` is a reference to the current object. In the past, we've added
    objects to the screen using `[self addChild:]`, but with the `CCPhysicsNode` object,
    we're going to add objects using [`world addChild:]`, since `world` will be the
    name of our `CCPhysicsNode` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open `MainScene.h` and add the declaration for the world variable below
    the `winSize` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open `MainScene.m` and add this block of code after the background is
    created in the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! The preceding code will create a physics world that allows physics
    to be simulated. All we need to do next is create some `CCNode` objects, add physics
    bodies to the `CCNode` objects, then add the `CCNode` objects to the physics world
    (instead of `self`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Setting `debugDraw` to `YES` ensures that whenever we attach any physics body
    to a `CCNode` object and add it to the world, we will have an outline of that
    body's shape drawn over our objects. Thus, we will know exactly where each body
    is and how it's colliding. Normally, when `debugDraw` is not turned on, we won't
    see these shapes.
  prefs: []
  type: TYPE_NORMAL
- en: The collision will still work the same whether you have `debugDraw` on or not.
    The main purpose is to, well, debug the project to make sure the physics bodies
    are added and colliding as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling touch creation of our object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we are going to need some objects on the screen that we want to collide
    with one another. Instead of programmatically spawning the objects, let's have
    the objects spawn wherever the user touches the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open `MainScene.m` and add the following line of code anywhere in the `init`
    method. This will allow you to grab any touch data from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, below the `init` method, we add this method so that we can start receiving
    touches in our scene. This method (as seen in the previous chapter) will grab
    any touch event, and we want to grab the location of the touch so that we can
    position the object accordingly. Then we will spawn a black square at the touch
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will create a node that's 10 percent of the screen's width and add it to
    the `world` object. We're adding it to `world` instead of `self` because when
    we add physics bodies to the square, we want the simulation to handle the object's
    movement. We need to set the `anchorPoint` of the node because, by default, a
    `CCNode` has its anchor point at (0,0).
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game at this point, you will see the same green screen. As you
    tap around the screen, black squares will appear, centered at the touch location.
  prefs: []
  type: TYPE_NORMAL
- en: However, you'll notice that even though we've added them to the world object,
    they aren't falling according to the gravity we set up, and they aren't colliding
    and pushing each other around. What we have to do next is create a `CCPhysicsBody`
    object and assign it to the created square so that the physics simulation will
    handle the movement properly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're still a bit unsure what exactly `CCPhysicsBody` is, it's essentially
    an object that has a shape, or perimeter, that defines where the object can collide
    with other objects. `CCPhysicsBody` also has other properties such as elasticity,
    restitution, density, and so on, and is best used when attached to a `CCNode`
    object so that the node can have its movement handled by the physics body.
  prefs: []
  type: TYPE_NORMAL
- en: Making the objects fall – adding CCPhysicsBody
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `MainScene.m` file, add the following code to the bottom of the touchBegan
    method. This will add the physics body we want to the square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this code in place, when you run the game, you will notice that the objects
    not only begin to fall but also have that debug square that was mentioned earlier.
    Notice that we don't have to declare the body type as **dynamic**, as that's the
    default. Also note the **elasticity** (which, as you might recall, is the bounciness)
    of 0.5\. This is set so that the squares don't go bouncing all over the place.
    If we wanted that, we would've set the elasticity to a higher number, such as
    1.0.
  prefs: []
  type: TYPE_NORMAL
- en: But oh no! The squares just fall off the screen as if it's a bottomless pit.
    Let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ground and walls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a ground object is easy, but since the walls and the ceiling are basically
    the same thing, let's define a method that will take in `CGRect` and create for
    us a static, invisible node with those dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, anywhere in `MainScene.m`, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is fairly similar to the square''s code, except for one notable difference:
    the type of the physics body. We set it to `static` because we don''t want the
    gravity affecting it, nor do we want the squares to push the ground in any direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just because we declared a method doesn''t mean it will automatically generate
    walls for us. So, go to your `init` method and add the following block of code
    to add the walls around the edges of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code is fairly self-explanatory in terms of positioning. The bottom-left
    corner of every Cocos2d scene is (0,0), and the `CGRectMake` function takes in
    the *x* and *y* coordinates, and then the width and height of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: That's all for creating a simple object with some physics acting on it! Feel
    free to mess around with some of the variables such as elasticity, gravity, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, if you notice that your objects seem to be lagging when they
    move across the screen—even though Xcode says the game is running at 60 FPS—add
    the following line of code at the top of the `startScene` method in `AppDelegate.m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Setting gravity by tilting the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your user tilts the device, the device's accelerometer will pick up that
    information at even the slightest, most minute values. This is beneficial to those
    who wish to use the accelerometer (or tilting) within their game, especially with
    regards to moving the character or manipulating gravity, which is what we'll cover
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Ever since iOS 5.0, UIAccelerometer has been replaced by the Core Motion framework
    data. Thankfully, it's no more complicated, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you aren''t a registered developer and can''t use your actual device to
    test (and have been doing so on the simulator), note that it''s not possible to
    test the accelerometer with the simulator unless the data can be sent to the simulator.
    Here''s a link that might be useful in this situation: [http://www.vimov.com/isimulate/](http://www.vimov.com/isimulate/).'
  prefs: []
  type: TYPE_NORMAL
- en: However, even if you can't test the accelerometer on the simulator by default,
    it will still work as intended on anyone's device, so if you plan to include the
    accelerometer in your game, feel free to still follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the accelerometer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `MainScene.h` and import the Core Motion framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a variable for something called the `CMMotionManager`. This object
    will calculate the accelerometer data, and we can collect this data when we need
    it. Add the following line of code under the `world` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open `MainScene.m`, and anywhere in the `init` method, add the following
    block of code so that the motion manager we just declared will begin to grab the
    accelerometer''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Right now, if you run the game, you won't notice any changes in the way it plays
    or any debug information. Even though the motion manager is initialized and is
    grabbing the data, we must set up a method to collect the data so that we can
    do something with it.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your `init` method of `MainScene.m`, after you''ve initialized the motion
    manager, add the following line of code. It will run the specified method at the
    given interval (60 times per second):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, anywhere in `MainScene.m`, we add the method we want to be called at
    the specified interval so that we can read the accelerometer data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run the game, you'll see a lot of information being printed in the
    console output in Xcode. If the numbers are changing as you tilt the device, it
    means everything's working. Yay! If not, go back and make sure you add everything
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to actually set the game's gravity based on how the device
    is rotated at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating gravity to your heart's content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of typing that long line of text every time, let''s make a method with
    a relevant name and pass the accelerometer data. That being said, modify your
    `getAccelerometerData` method to the following, and add this new method, which
    will set the gravity of the physics world based on the accelerometer''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the game and spawn a few blocks, you''ll see them floating,
    falling down, sliding sideways, or in whichever direction your iOS device perceives
    as "down." You''ll probably see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating gravity to your heart''s content](img/image00244.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From here onwards, feel free to turn off debug draw, maybe mess around with
    how much gravity is set, or even change the axis the gravity is affected by.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that a square stops moving on a wall, then doesn't move when
    you rotate the device; that's because the object's body is sleeping. This is done
    to help conserve CPU processing time as well as energy when an object has no active
    collisions and no forces acting on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you need them to be constantly moving, add the following line of
    code to your `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This defaults to 0.5 seconds, and why the sleeping happens when the squares
    stop moving against a wall. Setting it to a relatively large value, such as 100,000,
    will ensure that they never stop moving (that is, unless the square is sitting
    still for that duration, but the higher the threshold is, the less likely it is
    to happen).
  prefs: []
  type: TYPE_NORMAL
- en: Handling collisions in Chipmunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's relatively easy to handle collisions within Cocos2d when using Chipmunk
    (as is pretty much everything else in Cocos2d). That is why so many developers
    use Cocos2d. To do so, we need to do a few different steps so that Cocos2d can
    properly detect and handle our collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the collision delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The delegate pattern is a common way to handle messages sent by a class to any
    of its potential parent classes. For example, if you want to use `UITableView`
    (which is the standard table in `UIKit`), you must set the delegate of the table
    view to the class you're adding it to so that when the table view tries to refresh
    the data in the table, it knows which class' methods to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, we need to tell `MainScene` that it will be a delegate for
    our collision handler, so open up `MainScene.h` and add `CCPhysicsCollisionDelegate`
    to the `@interface` line. This will allow the `CCPhysicsNode` object to set collision
    detection events on our `MainScene` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open `MainScene.m`, and in the `init` method, set the `world` object''s
    collision delegate to `self`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Recall that `world` is our `CCPhysicsNode` object, so any collision detection
    events that happen within that world (or simulation) will need to be sent somewhere
    to be handled further. We're setting it to `self` because self refers to the current
    `MainScene` instance (our currently running scene). Finally, this helps us determine
    which objects collide with other objects. Without this line of code, we wouldn't
    be able to see in the code when two objects collide, let alone tell which objects
    they actually are.
  prefs: []
  type: TYPE_NORMAL
- en: Although this doesn't do anything directly if you run the game now, it properly
    sets up your physics simulation to be able to detect and handle collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting collision tags on game objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can create the method that will detect our collisions, we need to
    specify which objects will be colliding with one another. For now, we'll only
    be considering squares colliding with other squares.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in the `touchBegan` method of the `MainScene.m` file, add the following
    line of code so that the collision detection delegate knows what object is colliding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can do this with any physics body, but for now, this is our only object.
    With that in place, let's add the code to detect the actual collision between
    two squares.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting collision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way Chipmunk handles collisions in Cocos2d is by detecting all collisions
    and sending method calls to the respective functions for each collision type.
    So, since we're going to be detecting the collision between two squares, both
    parameters have to be named square. Otherwise, the method won't get called properly.
    The actual names of the variables of the parameters (`firstSquare` and `secondSquare`)
    don't matter for the sake of detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, anywhere in `MainScene.m`, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game at this point, you should see the `squares collided!` text
    being printed to the console output every time a square collides with another.
    If it doesn't, go back and make sure you add everything correctly. From here onwards,
    you can do whatever you want when the two objects collide, as you have a pointer
    to both objects as well as their types.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, suppose we want to detect collisions between the squares
    and a wall; it''s very easy. First, add `wall` as `collisionType` to the body
    in the addWallWithRect method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the method to detect square-wall collisions (notice the name change
    in the parameter from the previous `collisionBegan` method we added):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game at this point and spawn a square, as soon as it hits a wall,
    you should see the output being printed. And that's it for detecting collisions!
    Just set the `collisionDelegate` property, set the `collisionType` property, and
    add the collision methods.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to detect collisions on objects, but don't want them to be
    bouncing with other objects? In Chipmunk, you can do that.
  prefs: []
  type: TYPE_NORMAL
- en: Using Chipmunk for just collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an important note: if you''re going to just detect one of the following,
    you do not need to use a physics engine for your collision detection, but rather
    the listed method:'
  prefs: []
  type: TYPE_NORMAL
- en: For rectangles intersecting rectangles, use `CGRectIntersectsRect`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For points inside rectangles, use `CGRectContainsPoint`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For radius/distance intersection, use `ccpDistance`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're going to be detecting collisions with non-rectangular and noncircular
    objects, feel free to read on.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, all you're doing is sending objects across the screen, or rotating
    them with your custom actions, and you just want to know when two objects collide,
    but don't want the bouncing, pushing, and colliding that comes with the entire
    physics engine. Luckily, we can do that in Chipmunk.
  prefs: []
  type: TYPE_NORMAL
- en: Turning the physics body into a sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sensors, with respect to Chipmunk, are basically bodies that can detect collisions,
    but pass right through other bodies. These are helpful when you have areas or
    sections of the screen that trigger certain events, but don't actually cause any
    physics-based interactions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you're making a top-down mini golf game with a physics engine
    and you want to include ramps, the best way to do this is to set the ramp as a
    sensor. When the ball and ramp collide, set the gravity in a certain direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a body a sensor, simply set the `sensor` variable to true, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you'll notice that the blocks fall right through one
    another, as well as right through the floor.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! All you need is the collision handling (in the previous section),
    and the sensor variable set to true. Any physics body that's a sensor will trigger
    collision detection events, but not cause any movement or changes to other bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, you learned how to create a physics simulation, add
    bodies to the simulation, set the gravity of the world with the accelerometer,
    handle collisions, and even use the simulation for just collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to really complex physics engine mechanics, such as ropes, joints,
    and pivots, the Cocos2d documentation at [http://www.cocos2d-swift.org/docs/api/index.html](http://www.cocos2d-swift.org/docs/api/index.html)
    explains a lot. At the time of writing this book, there are very few (if any)
    tutorials on such complex mechanics available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about sound in Cocos2d and some of the cool
    things you can do to sound effects within the engine.
  prefs: []
  type: TYPE_NORMAL
