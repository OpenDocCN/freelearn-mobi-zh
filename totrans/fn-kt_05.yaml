- en: More on Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we covered many features of Kotlin's functions. But
    now we'll expand on these many features, most of them borrowed from other languages,
    but with a new twist to fully accommodate them into Kotlin's overall goals and
    flavour—type-safety and pragmatical conciseness.
  prefs: []
  type: TYPE_NORMAL
- en: Some features, such as **Domain Specific Languages** (**DSLs**), let developers
    extend the language to domains that were not considered when Kotlin was first
    designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this chapter, you''ll have a big picture of all function features,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type-safe builders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion and corecursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-expression functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, all our examples were declared in a normal way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function sum takes two `Int` values and adds them. Declared in a normal
    way, we must provide a body with curly braces and an explicit `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `sum` function has its body declared inside curly braces with a `return`
    clause. But if our function is just one expression, it could have been written
    in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, no curly braces, no `return` clause, and an equals (`=`) symbol. If you
    pay attention, it just looks similar to a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to cut even more characters, you can use type inference too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Use type inference for a function's return when it is very evident which type
    you are trying to return. A good rule of thumb is to use it for simple types such
    as numeric values, Boolean, string, and simple `data class` constructors. Anything
    more complicated, especially if the function does any transformation, should have
    explicit types. Your future self will be glad!
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function can have zero or more parameters. Our function, `basicFunction`,
    takes two parameters, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each parameter is defined as `parameterName: ParameterType`, in our example, `name:
    String` and `size: Int`. Nothing new here.'
  prefs: []
  type: TYPE_NORMAL
- en: vararg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It gets interesting when parameters have two types that we have already covered—`vararg`
    and lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A function with a parameter marked with the modifier, `vararg` can be called
    with zero or more values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A function can't have multiple `vararg` parameters, not even with different
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already discussed how, if a function's last parameter is a lambda, it can't
    be passed outside the parenthesis and inside curly braces, as if the lambda itself
    is the body of a control structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered this `unless` function in [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml),
    *Getting Started with Functional Programming*, in the section, *First-class and
    high-order functions*. Let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what happens if we combine `vararg` and lambda? Let''s check it in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambdas can be at the end of a function with a `vararg` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get a little adventurous, a `vararg` parameter of lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t pass a lambda outside of the parenthesis, but we can pass many lambdas
    inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Named parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, our functions should not have too many parameters, but this isn't always
    the case. Some functions tend to be big, for example, the `data class` constructors
    (constructors are technically a function that returns a new instance).
  prefs: []
  type: TYPE_NORMAL
- en: What is the problem with functions with many parameters?
  prefs: []
  type: TYPE_NORMAL
- en: They are hard to use. This can be alleviated or fixed with default parameters
    that we will cover in the next section, *Default parameters*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are hard to read—named parameters to the rescue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are probably doing too much. Are you sure that your function isn't too
    big? Try to refactor it and clean up. Look for possible side effects and other
    harmful practices. A special case is `data class` constructors, as they are just
    autogenerated assignments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With named parameters, you can add readability to any function invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a `data class` constructor as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A normal invocation will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But including named parameters will increase the information available for
    the reader/maintainer and reduce mental work. We can also pass the parameters
    in any order that is more convenient or meaningful for the actual context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Named parameters are very useful when they are combined with a `vararg` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Named parameters on high-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually when we define a high-order function, we never name the parameters
    for the lambda(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is possible to add them. So, the `f` lambda now has its parameters named—`age`
    and `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn''t change any behavior, it is just to give more clarity on the intended
    use of this lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: But it isn't possible to call a lambda with named parameters. In our example,
    invoking `f` with names produces a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, function parameters can have default values. For the `Programmer`,
    the `favouriteLanguage` and `yearsOfExperience` data classes have default values
    (remember that a constructor is a function too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `Programmer` can be created with just two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you want to pass `yearsOfExperience`, it must be as a named parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can still pass all parameters if you want to, but they must be provided
    in the right order if you aren''t using named arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Definitively, one of the best features of Kotlin is extension functions. Extension
    functions let you modify existing types with new functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To add an extension function to an existing type, you must write the function's
    name next to the type's name, joined by a dot (`.`).
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we add an extension function (`sendToConsole()`) to the `String`
    type. Inside the function's body, `this` refers the instance of `String` type
    (in this extension function, `string` is the receiver type).
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the dot (`.`) and `this`, extension functions have the same syntax
    rules and features as a normal function. Indeed, behind the scenes, an extension
    function is a normal function whose first parameter is a value of the receiver
    type. So, our `sendToConsole()` extension function is equivalent to the next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in reality, we aren''t modifying a type with new functions. Extension functions
    are a very elegant way to write utility functions, easy to write, very fun to
    use, and nice to read—a win-win. This also means that extension functions have
    one restriction—they can''t access private members of `this`, in contrast with
    a proper member function that can access everything inside the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Invoking an extension function is the same as a normal function—with an instance
    of the receiver type (that will be referenced as `this` inside the extension),
    invoke the function by name.
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a big difference between member functions and extension functions when
    we talk about inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The open class `Canine` has a subclass, `Dog`. A standalone function, `printSpeak`,
    receives a parameter of type `Canine` and prints the content of the result of
    the function `speak(): String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We already covered this in [Chapter 1](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml),
    *Kotlin – Data Types, Objects and Classes*, in the *Inheritance *section. Open
    classes with `open` methods (member functions) can be extended and alter their
    behavior. Invoking the `speak` function will act differently depending on which
    type is your instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `printSpeak` function can be invoked with any instance of a class that
    *is-a* `Canine`, either `Canine` itself or any subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this code, we can see this on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07ebfddd-9372-4688-aa65-a4baba259a7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Although both are `Canine`, the behavior of `speak` is different in both cases,
    as the subclass overrides the parent implementation.
  prefs: []
  type: TYPE_NORMAL
- en: But with extension functions, many things are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous example, `Feline` is an open class extended by the `Cat`
    class. But `speak` is now an extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Extension functions don''t need to be marked as override, because we aren''t
    overriding anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this code, we can see this on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d28f873-ad11-4f56-a174-1b3c0bd91f3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, both invocations produce the same result. Although in the beginning
    it seems confusing, once you analyse what is happening, it becomes clear. We''re
    invoking the `Feline.speak()` function twice; this is because each parameter that
    we pass is a `Feline` to the `printSpeak(Feline)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this code, we can see this on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50f03c90-318c-4fec-9028-d4d9de9d9372.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, it is still the same behavior as with the previous examples, but
    using the right value for `name`. Speaking of which, we can reference `name` with
    `name` and `this.name`; both are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions as members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extension functions can be declared as members of a class. An instance of a
    class with extension functions declared is called the **dispatch receiver.**
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Caregiver` open class internally defines, extension functions for two
    different classes, `Feline` and `Primate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Both extension functions are meant to be used inside an instance of `Caregiver`.
    Indeed, it is a good practice to mark member extension functions as private, if
    they aren't open.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `Primate.react()`, we are using the `name` value from `Primate`
    and the `name` value from `Caregiver`. To access members with a name conflict,
    the extension receiver (`this`) takes precedence and to access members of the
    dispatcher receiver, the qualified `this` syntax must be used. Other members of
    the dispatcher receiver that don't have a name conflict can be used without qualified
    `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t get confused by the various means of `this` that we have already covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside a class, `this` means the instance of that class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside an extension function, `this` means the instance of the receiver type
    like the first parameter in our utility function with nice syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to our *Zoo* example, we instantiate a `Caregiver`, a `Cat`, and
    a `Primate`, and we invoke the function `Caregiver.takeCare` with both animal
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this code, we can see this on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cad2a39-09ef-4755-963c-d27ae0a94429.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Any zoo needs a veterinary surgeon. The class `Vet` extends `Caregiver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We override the `Feline.react()` function with a different implementation.
    We are also using the `Vet` class''s name directly, as the `Feline` class doesn''t
    have a property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After which, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25274a35-6b26-4563-a986-33c61c6b238b.png)'
  prefs: []
  type: TYPE_IMG
- en: Extension functions with conflicting names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens when an extension function has the same name as a member function?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Worker` class has a function `work(): String` and a private function `rest():
    String`. We also have two extension functions with the same signature, `work`
    and `rest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Having extension functions with the same signature isn''t a compilation error,
    but a warning: `Extension is shadowed by a member: public final fun work(): String`'
  prefs: []
  type: TYPE_NORMAL
- en: It is legal to declare a function with the same signature as a member function,
    but the member function always takes precedence, therefore, the extension function
    is never invoked. This behavior changes when the member function is private, in
    this case, the extension function takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to overload an existing member function with an extension
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'On execution, `work()` invokes the member function and `work(String)` and `rest()` are
    extension functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6eaa0a12-3eb0-4256-98c1-1e54da9793c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Extension functions for objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, objects are a type, therefore they can have functions, including
    extension functions (among other things, such as extending interfaces and others).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a `buildBridge` extension function to the object, `Builder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can include companion objects. The class `Designer` has two inner objects,
    the `companion` object and `Desk` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this functions works like any normal object member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Infix functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions (normal or extension) with just one parameter can be marked as `infix`
    and used with the `infix` notation. The `infix` notation is useful to express
    the code naturally for some domains, for example, math and algebra operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an `infix` extension function to the `Int` type, `superOperation`
    (which is just a regular sum with a fancy name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `superOperation` function with the `infix` notation or normal
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: Another area where the `infix` notation is commonly used, is on assertion libraries,
    such as **HamKrest** ([https://github.com/npryce/hamkrest](https://github.com/npryce/hamkrest))
    or **Kluent** ([https://github.com/MarkusAmshove/Kluent](https://github.com/MarkusAmshove/Kluent)).
    Writing specification code in a natural, easy to understand language is a huge
    advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kluent assertions look like natural English expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Kluent also comes with a backtick version for even greater readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Backticks (`` ` ``) let you write arbitrary identifiers, including words that
    are reserved in Kotlin. Now, you can write your own kaomoji functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12e0fde8-446a-469c-8fa6-855d64ec3c1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can chain many `infix` functions to produce internal DSLs, or recreate
    classic memes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `your`  function, receives `Pair<Base, Us>` as a parameter (a kind of tuple
    that comes with and is widely used on the Kotlin standard library) and the `infix`
    extension function `<K, V> K.to(v: V)` returns a `Pair<K, V>` using the receiver
    as the first member and the parameter as the second parameter (`to` can be invoked
    with any combination of types).'
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Operator overloading** is a form of polymorphism. Some operators change behaviors
    on different types. The classic example is the operator plus (`+`). On numeric
    values, plus is a sum operation and on `String` is a concatenation. Operator overloading
    is a useful tool to provide your API with a natural surface. Let''s say that we''re
    writing a `Time` and `Date` library; it''ll be natural to have the plus and minus
    operators defined on time units.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin lets you define the behavior of operators on your own or existing types
    with functions, normal or extension, marked with the `operator` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The operator function plus returns a `Pack` value. To invoke it, you can use
    the `infix` operator way (`Wolf + Wolf`) or the normal way (`Wolf.plus(Wolf)`).
  prefs: []
  type: TYPE_NORMAL
- en: Something to be aware of about operator overloading in Kotlin—the operators
    that you can override in Kotlin are limited; you can't create arbitrary operators.
  prefs: []
  type: TYPE_NORMAL
- en: Binary operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary operators receive a parameter (there are exceptions to this rule—`invoke`
    and indexed access).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Pack.plus` extension function receives a `Wolf` parameter and returns
    a new `Pack`. Note that `MutableMap` also has a plus (`+`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table will show you all the possible binary operators that can
    be overloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Equivalent** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `x + y` | `x.plus(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x - y` | `x.minus(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x * y` | `x.times(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x / y` | `x.div(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x % y` | `x.rem(y)` | From Kotlin 1.1, previously `mod`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x..y` | `x.rangeTo(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x in y` | `y.contains(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x !in y` | `!y.contains(x)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x += y` | `x.plussAssign(y)` | Must return `Unit`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x -= y` | `x.minusAssign(y)` | Must return `Unit`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x *= y` | `x.timesAssign(y)` | Must return `Unit`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x /= y` | `x.divAssign(y)` | Must return `Unit`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x %= y` | `x.remAssign(y)` | From Kotlin 1.1, previously `modAssign`. Must
    return `Unit`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x == y` | `x?.equals(y) ?: (y === null)` | Checks for `null`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x != y` | `!(x?.equals(y) ?: (y === null))` | Checks for `null`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x < y` | `x.compareTo(y) < 0` | Must return `Int`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x > y` | `x.compareTo(y) > 0` | Must return `Int`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x <= y` | `x.compareTo(y) <= 0` | Must return `Int`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x >= y` | `x.compareTo(y) >= 0` | Must return `Int`. |'
  prefs: []
  type: TYPE_TB
- en: Invoke
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml), *Getting Started
    with Functional Programming*, in the section *First-class and high-order functions*, when
    we introduced lambda functions, we show the definition of `Function1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `invoke` function is an operator, a curious one. The `invoke` operator can
    be called without `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class `Wolf` has an `invoke` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That's why we can call a lambda function directly with parenthesis; we are,
    indeed, calling the `invoke` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table will show you different declarations of `invoke` with a
    number of different arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Equivalent** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `x()` | `x.invoke()` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x(y)` | `x.invoke(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x(y1, y2)` | `x.invoke(y1, y2)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x(y1, y2..., yN)` | `x.invoke(y1, y2..., yN)` |  |'
  prefs: []
  type: TYPE_TB
- en: Indexed access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The indexed access operator is the array read and write operations with square
    brackets (`[]`), that is used on languages with C-like syntax. In Kotlin, we use
    the `get` operators for reading and `set` for writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Pack.get` operator, we can use `Pack` as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Most of Kotlin data structures have a definition of the `get` operator, in this
    case, the `Map<K, V>` returns a `V?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table will show you different declarations of `get` with a different
    number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Equivalent** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `x[y]` | `x.get(y)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x[y1, y2]` | `x.get(y1, y2)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x[y1, y2..., yN]` | `x.get(y1, y2..., yN)` |  |'
  prefs: []
  type: TYPE_TB
- en: 'The `set` operator has similar syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The operators `get` and `set` can have any arbitrary code, but it is a very
    well-known and old convention that indexed access is used for reading and writing.
    When you write these operators (and by the way, all the other operators too),
    use the principle of *least surprise*. Limiting the operators to their natural
    meaning on a specific domain, makes them easier to use and read in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table will show you different declarations of `set` with a different
    number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Equivalent** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `x[y] = z` | `x.set(y, z)` | Return value is ignored |'
  prefs: []
  type: TYPE_TB
- en: '| `x[y1, y2] = z` | `x.set(y1, y2, z)` | Return value is ignored |'
  prefs: []
  type: TYPE_TB
- en: '| `x[y1, y2..., yN] = z` | `x.set(y1, y2..., yN, z)` | Return value is ignored
    |'
  prefs: []
  type: TYPE_TB
- en: Unary operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unary operators** don''t have parameters and act directly in the dispatcher.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a `not` operator to the `Wolf` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table will show you all the possible unary operators that can
    be overloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Equivalent** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `+x` | `x.unaryPlus()` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `-x` | `x.unaryMinus()` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `!x` | `x.not()` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `x++` | `x.inc()` | Postfix, it must be a call on a `var`, should return
    a compatible type with the dispatcher type, shouldn''t mutate the dispatcher.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `x--` | `x.dec()` | Postfix, it must be a call on a `var`, should return
    a compatible type with the dispatcher type, shouldn''t mutate the dispatcher.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `++x` | `x.inc()` | Prefix, it must be a call on a `var`, should return a
    compatible type with the dispatcher type, shouldn''t mutate the dispatcher. |'
  prefs: []
  type: TYPE_TB
- en: '| `--x` | `x.dec()` | Prefix, it must be a call on a `var`, should return a
    compatible type with the dispatcher type, shouldn''t mutate the dispatcher. |'
  prefs: []
  type: TYPE_TB
- en: Postfix (increment and decrement) returns the original value and then changes
    the variable with the operator returned value. Prefix returns the operator's returned
    value and then changes the variable with that value.
  prefs: []
  type: TYPE_NORMAL
- en: Type-safe builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the two previous sections (`infix` functions and operator overloading),
    we have a good foundation for building fantastic DSLs. A **DSL** is a language
    that is specialized to a particular domain, in contrast to **general-purpose language** (**GPL**).
    Classic examples of DSLs (even when people don't realize it) are HTML (markup)
    and SQL (relational database queries).
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin provides many features to create internal DSLs (a DSL that runs internally
    inside a host GPL), but there is one feature that we still need to cover, type-safe
    builders. Type-safe builders let us define data in a (semi) declarative way and
    are very useful to define GUIs,  HTML markup, XML, and others.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a beautiful Kotlin DSL is TornadoFX. **TornadoFX** ([https://tornadofx.io/](https://tornadofx.io/))
    is DSL for creating JavaFX applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We write an `FxApp` class that extends `tornadofx.App` and receives a `tornadofx.View`
    class (a class reference, not an instance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In less than 20 lines of code, including imports and main function, we can
    create a GUI application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa2565c7-bdb1-44e8-bb59-e574a6cd5318.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, right now, it doesn't do anything, but it is simple to create a JavaFX
    Application with TornadoFX, if you compare it with Java. People with JavaFX experience
    could say that you can achieve something similar with FXML (a declarative XML
    language designed to build JavaFX layouts), but as with any other XML file, writing
    and maintaining is hard, and TornadoFX's DSL is simpler, flexible, and is compiled
    with Kotlin's type-safety.
  prefs: []
  type: TYPE_NORMAL
- en: But how do type-safe builders work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example from the Kotlin Standard Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can find `with` blocks in other languages, such as JavaScript and Visual
    Basic (including .Net). A `with` block is a language construct that lets us use
    any property or method on the value that we pass as a parameter. But in Kotlin,
    `with` is not a reserved keyword but rather a normal function with a special type
    of parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `with` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is any value of type `T`, a receiver (as in extension function?)
    and the second one, `block`, is a function of type `T.() -> R`. In Kotlin's documentation,
    this kind of function is named **function type** with receiver and with any instance
    of `T,` we can call the `block` function. No worries about the `inline` modifier,
    we'll cover it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A trick to understanding the function type with receiver is to think of it as
    an extension function. Have a look at the declaration with that familiar dot (`.`),
    and inside the function, we can use any member of the receiver type using `this`,
    as in extension functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about another example? Let''s have a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `buildString` function receives a `StringBuilder.() -> Unit` parameter
    and returns a `String`; the declaration is astonishingly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` function is an extension function similar to `with` but instead
    of returning `R`, returns the receiver instance. Usually, `apply` is used for
    *initializing* and *instance*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all these functions are very simple to understand, but they
    increase Kotlin's usefulness and readability a great deal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of my big passions is cycling. The emotion of movement, the effort, the
    health benefits, and enjoying the landscape are some of the benefits (and I can
    keep going on and on).
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to create a way to have a registry of my bikes and their components.
    For the prototype phase, I''ll use XML, but later on we can change to a different
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is the perfect scenario to create a type-safe builder in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, my `bicycle` DSL should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: My DSL is regular Kotlin code, is compiled fast, and my IDE will help me to
    autocomplete, and will complain when I make a mistake—a win-win situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'All parts of my `bicycle` in my DSL will extend/implement the `Element` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`Part` is the base class for all my parts; it has `children` and `attributes`
    properties; it also inherits the `Element` interface with an XML implementation.
    Changing to a different format (JSON, YAML, and others) should not be too difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: The `initElement` function receives two parameters, an element `T` and an `init`
    function with receiver `T.() -> Unit`. Internally, the `init` function is executed
    and the element is added as children.
  prefs: []
  type: TYPE_NORMAL
- en: '`Part` is annotated with an `@ElementMarker` annotation, that is itself annotated
    with `@DslMarker`. It prevents inner elements from reaching outer elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we can use `frame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It is still possible to do it explicitly with `this` qualified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, several enumerations to describe materials, bar types, and brakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of these parts have a `material` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a `material` property of type `Material` enumeration, and we store it
    inside the `attributes` map, transforming the value back and forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`Bicycle` defines a `description` function and functions for `frame`, `fork`,
    and `bar`. Each function receives an `init` function that we pass directly to
    `initElement`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Frame` has a function for the back wheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`Wheel` has a property `brake` using the `Brake` enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '`Bar` has a property for its type, using the `BarType` enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`Fork` defines a function for the front wheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We are close to the finish, the only thing that we need now is an entry function
    for our DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: And that's all. DSLs in Kotlin with the `infix` functions, operator overloading,
    and type-safe builders are extremely powerful, and the Kotlin community is creating
    new and exciting libraries every day.
  prefs: []
  type: TYPE_NORMAL
- en: Inline functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-order functions are very useful and fancy, but they come with a caveat—performance
    penalties. Remember, from [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml),
    *Getting Started with Functional Programming*, in the section, *First-class and
    high-order functions*, that on compilation time, a lambda gets translated into
    an object that is allocated, and we are calling its `invoke` operator; those operations
    consume CPU power and memory, regardless of how small they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Once compiled, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If performance is a priority for you (mission critical application, games,
    video streaming), you can mark a high-order function as `inline`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Once compiled, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole function execution is replaced by the high-order function''s body
    and the lambda''s body. The `inline` functions are faster, albeit generating more
    bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dfad12f-a9ed-4580-9e9e-c085050fbfcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 2.3 milliseconds per execution doesn't look like a lot, but in the long run
    and with more optimizations, can create a noticeable compound effect.
  prefs: []
  type: TYPE_NORMAL
- en: Inline restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inline lambda functions have an important restriction—they can't be manipulated
    in any way (stored, copied, and others).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UserService` stores a list of listeners `(User) -> Unit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing `addListener` into an `inline` function will produce a compilation
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If you think about it, it makes sense. When we inline a lambda, we're replacing
    it for its body, and that isn't something that we can store on a `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this problem with the `noinline` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `noinline` on an `inline` function will inline just the high-order function
    body but not the `noinline` lambda parameters (an `inline` high-order function
    can have both: `inline` and `noinline` lambdas). The resulting bytecode isn''t
    as fast as a fully inline function, and the compiler will show a warning.'
  prefs: []
  type: TYPE_NORMAL
- en: Inline lambda functions can't be used inside another execution context (local
    object, nested lambda).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we can''t use `transform` inside the `buildUser` lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this problem, we need a `crossinline` modifier (alternatively, we can
    use `noinline` but with the associated performance lost):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated code is quite complex. Many pieces are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: A class that extends `(String) -> User` to represent `buildUser` and internally
    creates `User` using `String::toLowerCase` to transform the name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A normal inline code to execute `List<User>.map()` using an instance of the
    class that represents `buildUser`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<T>.map()` is `inline`, so that code gets generated too'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you're aware of its restrictions, inline high-order functions are a great
    way to increase the execution speed of your code. Indeed, a lot of the high-order
    functions inside the Kotlin Standard Library are `inline`.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion and corecursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml), *Getting Started
    with Functional Programming*, in the section, *Recursion*, we cover recursion
    extensively (albeit there are recursion topics that are outside the scope of this
    book).
  prefs: []
  type: TYPE_NORMAL
- en: 'We used recursion to write classic algorithms such as Fibonacci (we''re reusing
    `tailrecFib` from [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml), *Getting
    Started with Functional Programming*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'And Factorial (same here, reusing `tailrecFactorial` from [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml),
    *Getting Started with Functional Programming*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, we started with a number, and we reduced it to reach a base condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example that we looked at was `FunList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The functions, `forEach` and `fold`, are recursive. Starting with the complete
    list, we reduce it until we reach the end (represented with a `Nil`), the base
    case. The other functions—`reverse`, `foldRight`, and `map` are just using `fold`
    with different variations.
  prefs: []
  type: TYPE_NORMAL
- en: So, on one hand, recursion takes a complex value and reduces it to the desired
    answer and on the other hand, corecursion takes a value and builds on top of it
    to produce a compound value (including potentially infinite data structures such
    as `Sequence<T>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we use a `fold` function for recursive operations, we can use an `unfold`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `unfold` function takes two parameters, an initial `S` value that represents
    the starting or base step, and an `f` lambda that takes that `S` step and produces
    a `Pair<T, S>?` (a nullable `Pair`) of the `T` value to add to the sequence and
    the next `S` step.
  prefs: []
  type: TYPE_NORMAL
- en: If the result of `f(s)` is null, we return an empty sequence, else we create
    a single value sequence and add the result of `unfold` with the new step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `unfold,` we can create a function that repeats a single element many
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `elements` function takes the element to repeat any number of values. Internally,
    it uses `unfold`, passing `1` as the initial step and a lambda that takes the
    current step and compares it with `numOfValues`, returning `Pair<T, Int>` with
    the same element and the current step `+ 1` or `null.`
  prefs: []
  type: TYPE_NORMAL
- en: 'It is okay, but not very interesting. What about returning a Factorial sequence?
    We have you covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Same principle, the only difference is that our initial step is `Pair<Long,
    Int>` (the first element to carry the calculation and the second to evaluate against
    size) and therefore, our lambda should return `Pair<Long, Pair<Long, Int>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fibonacci will look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Except that in this case, we use `Triple<Long, Long, Int>`.
  prefs: []
  type: TYPE_NORMAL
- en: The corecursive implementations to generate Factorial and Fibonacci sequences
    are a mirror of the recursive implementations to calculate a Factorial or a Fibonacci
    number, respectively—and some people can argue that is easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we have already covered most of the Kotlin features for functional
    programming. We reviewed how to write shorter functions with single-expression
    functions, the different kind of parameters, how to extend our types with extension
    functions, and how to write natural and readable code with `infix` functions and
    operators. We also covered the basics of DSL authoring with type-safe builders
    and how to write efficient high-order functions. Last, but not least, we learned
    about recursion and corecursion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Kotlin delegates.
  prefs: []
  type: TYPE_NORMAL
