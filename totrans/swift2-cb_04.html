<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Design Patterns with Swift</h1></div></div></div><p class="calibre7">In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Writing into a log file</li><li class="listitem">Creating a factory of musical notes</li><li class="listitem">Simulating a home automation</li><li class="listitem">Delivering some pizzas</li><li class="listitem">Protocol-oriented programming</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec35" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">When object-oriented <a id="id143" class="calibre1"/>programming was introduced, the developers noticed that there were some objects or classes that were programmed following the same philosophy.</p><p class="calibre7">Xerox labs, for example, introduced the Model-View-Controller pattern in the 70s to develop programs using SmallTalk. A few other patterns were introduced by Xerox, but they were not called this.</p><p class="calibre7">When a book called <em class="calibre9">Design Patterns</em> was released in 1994, written by the Gang of Four, it brought solutions for common engineering problems. It demonstrated that the main problem with software development costs was maintenance; the usage of design patterns would cause a high cost in the first phase of software development but it would significantly reduce the maintenance costs.</p><p class="calibre7">Nowadays, design patterns are so important that it is very common to talk about them in job interviews. If you are experienced in Swift or Objective-C, you've already used some of these patterns without realizing.</p><p class="calibre7">In this chapter, we will cover a few design patterns; if possible, we will look at some common samples of these patterns in Swift.</p><div><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre7">Before we start, I'd like to comment that design patterns are very questionable nowadays; for example, the singleton pattern that is shown in the <em class="calibre9">Writing into a log file</em> recipe of this chapter was criticized by some developers because it is very easy to implement, and this is also the reason some programmers avoid this pattern. Others don't think that way, they think that you can use it, but only at the right moment, as the author explains in this URL: <a class="calibre1" href="http://www.ibm.com/developerworks/library/co-single/">http://www.ibm.com/developerworks/library/co-single/</a>. Anyway, arguing about this topic is out of the scope of this book. I will show you some patterns, and then you can decide whether to use them and when.</p><p class="calibre7">Another detail I'd like to comment on is that some examples can look more complicated than those without patterns. Don't forget that design patterns are not based on simplicity, but in software maintenance.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec36" class="calibre1"/>Writing into a log file</h1></div></div></div><p class="calibre7">This recipe is <a id="id144" class="calibre1"/>about a very simple and also a very common pattern design: the Singleton pattern. The idea of this pattern is to have an object with only one instance. You've already used this pattern in Swift or Objective-C, for example, when you used UIDevice or UIApplication.</p><p class="calibre7">For this recipe, we will create an object that will write out logs into a file. Note that it doesn't matter where we are in our application code, we should write only into one single file using one single object.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec100" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">As we will write into a file, you will probably like to see its contents after running the application. Before we start, let's check whether we are able to see the destination folder.</p><p class="calibre7">If you use the simulator, open the Finder window and go to your home directory; you can use the shortcut <em class="calibre9">command</em> + <em class="calibre9">shift</em> + <em class="calibre9">H</em>. If you can't see a folder called <code class="email">Library</code>, you have to press <em class="calibre9">command</em> + <em class="calibre9">J</em> to show the view options. Now, check the <strong class="calibre8">Show Library Folder</strong> option, as shown in the following screenshot:</p><div><img src="img/00038.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Of course, you <a id="id145" class="calibre1"/>won't have the application if you haven't run it yet, so on your <code class="email">viewDidLoad</code> method, paste the code <code class="email">print(NSHomeDirectory())</code> to know your path, and then you can follow it.</p><div><h3 class="title2"><a id="tip28" class="calibre1"/>Tip</h3><p class="calibre7">An easy way to open the document folder of the application is to print the home directory and copy it. Then, you can go to the <strong class="calibre8">Finder</strong> application, press <em class="calibre9">command</em> + <em class="calibre9">shift</em> + <em class="calibre9">G</em> and paste your path.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec101" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's create a small calculator and record the user actions. Remember that we don't need to instantiate the logger object every time we use the log; as it will be a singleton, you can call it from <a id="id146" class="calibre1"/>anywhere. So, let's get started.</p><div><ol class="orderedlist"><li class="listitem" value="1">Start a project called <code class="email">Chapter 4 Log File</code> and create a file called <code class="email">Log.swift</code>. Here is where we will define our log class. Copy the following code into the file:<div><pre class="programlisting">private var myLogInstance:Log = Log()
class Log {
    private var handle:NSFileHandle

    class func getInstance() -&gt; Log{
            return myLogInstance
    }

    private init(){
        var path:String = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as String
        let fullpath = path.stringByAppendingPathComponent("application.log")
        NSFileManager.defaultManager().createFileAtPath(fullpath, contents: nil, attributes: nil)
        self.handle=NSFileHandle(forWritingAtPath:fullpath)!
    }

    private func getCurrentTime() -&gt; String{
        let date = NSDate()
        let calendar = NSCalendar.currentCalendar()
        let components = calendar.components(.CalendarUnitHour | .CalendarUnitMinute | .CalendarUnitSecond, fromDate: date)
        let hour:Int = components.hour
        let minutes = components.minute
        let seconds = components.second
        return String(format: "%02d:%02d:%02d",hour, minutes, seconds)
    }

    func info(message:String){
      let finalMessage = "INFO: \(self.getCurrentTime()):\(message)\n"
      handle.writeData(finalMessage.dataUsingEncoding (NSUTF8StringEncoding, allowLossyConversion: false)!)
        handle.synchronizeFile()
    }

    func error(message:String){
        let finalMessage = "ERROR:\(self.getCurrentTime()):\(message)\n"
        handle.writeData(message.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!)
    }

    deinit{
        handle.closeFile()
    }
}</pre></div></li><li class="listitem" value="2">Now, of course, we need to complete our application to check the usage of our code. Go to <a id="id147" class="calibre1"/>the storyboard and add two text fields (each of them will represent a number), a segmented control that will represent the current operator, a button to show the result, and a label where the result will be displayed. Your layout should be similar to the following one:<div><img src="img/00039.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Now, let's code <a id="id148" class="calibre1"/>the view controller. First, let's add the attributes:<div><pre class="programlisting">var chosenOperator:Character = "+"
         @IBOutlet var firstNumber: UITextField!
@IBOutlet var labelResult: UILabel!
@IBOutlet var secondNumber: UITextField!</pre></div></li><li class="listitem" value="4">Don't forget to link each graphic component with its attribute. Now, it's time to code our program methods; in this case, we will develop a method to save the chosen operator and another to show the results:<div><pre class="programlisting">@IBAction func operatorChanged(sender: UISegmentedControl) {
        switch sender.selectedSegmentIndex {
        case 0:
            chosenOperator = "+"
        case 1:
            chosenOperator = "-"
        case 2:
            chosenOperator = "*"
        case 3:
            chosenOperator = "/"
        default:
            Log.getInstance().error("Invalid value \(sender.selectedSegmentIndex)")
            return
        }
        Log.getInstance().info("User has chosen the following operator: \(chosenOperator)")
    }

    @IBAction func displayResult(sender: UIButton)
    {
        var number1:Double?
        var number2:Double?
        number1=(firstNumber.text as NSString).doubleValue
        number2=(secondNumber.text as NSString).doubleValue
        
      
        
        switch chosenOperator{
        case "+":
            labelResult.text = "\(number1! + number2!)"
            Log.getInstance().info("\(number1!) + \(number2!) = \(number1! + number2!)")
        case "-":
            labelResult.text = "\(number1! - number2!)"
            Log.getInstance().info("\(number1!) - \(number2!) = \(number1! + number2!)")
        case "*":
            labelResult.text = "\(number1! * number2!)"
            Log.getInstance().info("\(number1!) * \(number2!) = \(number1! + number2!)")
        case "/":
            if number2! == 0.0 {
                Log.getInstance().error("Trying to divide by zero")
                let alert = UIAlertController(title: "Error", message: "Cant divide by zero", preferredStyle:.Alert)
                self.presentViewController(alert, animated: true, completion: nil)
            }else {
                labelResult.text = "\(number1!)/\(number2!)"
                Log.getInstance().info("\(number1!) / \(number2!) = \(number1! + number2!)")
            }
        default:
            break;
        }   
    }</pre></div></li><li class="listitem" value="5">To finish our application, we should add a little bit of code on our application delegate. Filling <a id="id149" class="calibre1"/>these events will register when the user has opened the application, put the application on in the background, and returned to the application. Here is the code:<div><pre class="programlisting">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
    print(NSHomeDirectory())
    Log.getInstance().info("Application has started")
    return true
}
func applicationDidEnterBackground(application: UIApplication) {
    Log.getInstance().info("Application has gone to background")
}
func applicationDidBecomeActive(application: UIApplication) {
    Log.getInstance().info("Application has become active")
}</pre></div></li><li class="listitem" value="6">Now, click on play and test the program; then, press the Home button and come back to the application. When you are done, go to the application documents folder, as demonstrated at the beginning, and open the file <code class="email">application.log</code>. Note that every action was registered on the same file; it doesn't matter if it was an event produced by the app delegate or by the view controller.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec102" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">In this recipe, we will see the introduction of the access control. Swift has three access levels:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre8">Public</strong>: In this <a id="id150" class="calibre1"/>level, the object, attribute, or global variable can be used from anywhere, even from another module</li><li class="listitem"><strong class="calibre8">Internal</strong>: In this <a id="id151" class="calibre1"/>level, the corresponding entity can be accessed from anywhere, except from another module</li><li class="listitem"><strong class="calibre8">Private</strong>: In this level, the <a id="id152" class="calibre1"/>entity can be accessed only from the current file, even from the same module</li></ul></div><p class="calibre7">As you can see, the idea of a singleton is to make sure that there will be only one instance of a class. As the initializer of the class is private, it can't be called from anywhere, but only from a method or function that is in the current file.</p><p class="calibre7">So, we created a method <a id="id153" class="calibre1"/>called <code class="email">getInstance</code> to access the only instance we have, and then we can access the object methods. Notice that we had to use classes; if we used structs, we would break the rule of one object only.</p><div><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre7">Sometimes, you will see the implementation of a singleton accepting nil values, such as <code class="email">private var myLogInstance:Log?</code>, and then initializing it inside the <code class="email">getInstance</code> method, such as:</p><div><pre class="programlisting">if myLogInstance == nil { myLogInstance = Log() } return myLogInstance</pre></div><p class="calibre7">The reason is that some software architects think that you don't have to start your application instantiating every singleton object, except when you are going to use it. There are some singleton objects that are never called, and you shouldn't waste this memory. If you notice, this class also had a deinitializer. Technically speaking, this method won't be called if you are running your application on iOS because iOS apps usually don't finish. However, the application can still end in certain circumstances, and you might close the file handle in the right way.</p></div><p class="calibre7">Now, when talking about file usage, first of all, we have to know what the application document's folder path is, because this is the location we have chosen for writing the log file. There is a function called <code class="email">NSSearchPathForDirectoriesInDomains</code> that returns the full path of a requested folder (actually, it returns an array of paths). After calling this function, we can create the file with the file manager and open it using <code class="email">NSFileHandle</code>.</p><div><h3 class="title2"><a id="tip29" class="calibre1"/>Tip</h3><p class="calibre7">Don't use paths by concatenating with the home directories in this manner: <code class="email">NSHomeDirectory() + /Documents</code>. Apple can change its path in future versions like it did with the bundle on iOS 8.</p></div><p class="calibre7">If this class wasn't a singleton, you wouldn't open this file here; you would open and close it every time you had to write a message because you must avoid having two open handles for the same file. Opening and closing a handle is a slow operation; it can affect your application performance.</p><p class="calibre7">In the case of writing into the log file with a high frequency, you will have to avoid clashing the file writing or opening, but if you have a singleton, this problem is much easier to control.</p><p class="calibre7">To finish this recipe, I would like to comment that this simple log system is based on real log systems used in applications. Usually, log files try to register the log level, such as info, error, warning or <a id="id154" class="calibre1"/>debug, and its time. With this information in mind, you can filter your log when it gets bigger and figure out what is going on when the application has crashed.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec103" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">The solution we had for our singleton application was to keep the object instance on a global variable; the ideal solution for this pattern is keeping it on a class variable, also called a static attribute. Swift 2 introduced support for static attributes so we no longer have to worry about this problem.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec37" class="calibre1"/>Creating a factory of musical notes</h1></div></div></div><p class="calibre7">Composing <a id="id155" class="calibre1"/>music with computers is something very common nowadays. Creating software that allows a musician to create his own music looks easy but it is not, mainly because there are lots of possibilities for each note.</p><p class="calibre7">In this recipe, we will <a id="id156" class="calibre1"/>use the pattern <strong class="calibre8">Abstract Factory</strong>. This pattern will allow us to change the note type that we want to create, and it will also initialize the note type for us.</p><p class="calibre7">As you may know, there are a lot of <a id="id157" class="calibre1"/>note symbols; you can check this URL on Wikipedia if you want to know more about it: <a class="calibre1" href="http://en.wikipedia.org/wiki/List_of_musical_symbols">http://en.wikipedia.org/wiki/List_of_musical_symbols</a>.</p><p class="calibre7">However, for this recipe, we <a id="id158" class="calibre1"/>will work with three types of notes: the drum quarter note, the piano quarter note, and the quarter rest note. Of course, this is only an example; in a real program, you will probably have to complete it with tied notes, and so on.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec104" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a project called <code class="email">Chapter 4 Musical Notes</code>; now, download the pictures that correspond to this recipe from the Internet. In this case, we have these pictures: <code class="email">staff.png</code>, <code class="email">quarter_rest.png</code>, <code class="email">cnote.png</code>, <code class="email">dnote</code>, <code class="email">cdrum.png</code>, and <code class="email">ddrum.png</code>.</p><p class="calibre7">We will also need some MP3 sounds for this recipe. Download three sounds for the piano notes and another three for the drums; of course, we won't have any sound for the rest note.</p><p class="calibre7">Place the pictures <a id="id159" class="calibre1"/>that were downloaded into your <code class="email">images.xcassets</code> folder. If you like, you can also add the same pictures with different resolutions for use in different resolution devices (iPad and iPhone).</p><p class="calibre7">Before you start, we will just need to add a framework called <code class="email">AVFoundation</code>. This will enable our app to play sounds. To do this, just click on the project navigator, then click on build phases. After this, expand the <strong class="calibre8">Link binary with Libraries</strong> section, then click on the plus button. Select <a id="id160" class="calibre1"/>
<strong class="calibre8">AVFoundation</strong> and click on <strong class="calibre8">Add</strong>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec105" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">As usual, we will start with the models. First, let's create a note protocol, as we know that in future we can have more than one type of note and we should be prepared for it. So, create a new file called <code class="email">NoteProtocol.swift</code> and put the following code in it:<div><pre class="programlisting">import Foundation
import UIKit

enum NoteStep {
    case NOTE_C,
    NOTE_D,
    NOTE_E
}
protocol NoteProtocol {
    var sound:String?{
        get set
    }
    var image:UIImage?{
        get set
    }
    var step: NoteStep {
        get set
    }
    var location:CGPoint {
        get set
    }
    func play()
}</pre></div></li><li class="listitem" value="2">The next step is <a id="id161" class="calibre1"/>to create an implementation of this protocol. Create a file called <code class="email">MusicalNote.swift</code> and add the <a id="id162" class="calibre1"/>following content into it:<div><pre class="programlisting">import Foundation
import UIKit
import AVFoundation

class MusicalNote: NoteProtocol{
    lazy private var _player = AVAudioPlayer()
    private var _sound:String?
    var sound:String? {
        get { return _sound }
        set(newSound){ self._sound = newSound }
    }
    
    private var _image:UIImage?
    var image:UIImage?{
        get{ return _image}
        set(newImage){ self._image = newImage }
    }
    
    private var _step:NoteStep
    var step: NoteStep {
        get{ return _step }
        set(newStep){ self._step = newStep }
    }
    
    private var _location:CGPoint
    var location:CGPoint {
        get { return _location }
        set(newLocation){ self._location = newLocation }
    }
    
    func play(){
        if let mySound = _sound {
            var urlSound = NSURL(fileURLWithPath: NSBundle.mainBundle().pathForResource(mySound, ofType: "mp3")!)
            self._player = AVAudioPlayer(contentsOfURL: urlSound, error: nil)
            self._player.prepareToPlay()
            self._player.play()
        }
    }
    
    init(_ step:NoteStep = .NOTE_C){
        self._location = CGPointZero
        self._step = step
    }
}</pre></div></li><li class="listitem" value="3">Now that we have implemented our note class, see to it that this note is not piano-specific or drum-specific; we only need to build it in a different way according to the note type and step. So, now we need to define a factory of notes. With the same logic we applied before, we now need to create a protocol of a note.<p class="calibre15">The only method that we will define is <code class="email">createNote</code>, and it needs to know the note step (C, D, or E) and its position on the staff. It's time to create a new <a id="id163" class="calibre1"/>file called <code class="email">AbstractNoteFactory.swift</code> and type the following code:</p><div><pre class="programlisting">protocol AbstractNoteFactory {
    func createNote(noteStep:NoteStep, order:Int) -&gt; NoteProtocol
}</pre></div></li><li class="listitem" value="4">Once we have <a id="id164" class="calibre1"/>the definition of a note factory, we can start creating our own factories. Let's start with the simplest one: <code class="email">SilenceFactory</code>; this factory will create only one kind of note, no matter its step. Type this code in a file called <code class="email">SilenceFactory.swift</code>:<div><pre class="programlisting">import UIKit
class SilenceFactory: AbstractNoteFactory {
    func createNote(noteStep:NoteStep, order:Int) -&gt; 
      NoteProtocol{
        var note = MusicalNote(noteStep)
        note.image = UIImage(named: "quarter_rest.png")
        note.sound = nil
        note.step = noteStep
        var x = CGFloat(120) + CGFloat(40 * order)
        note.location = CGPointMake(x, 25)
        return note
    }
}</pre></div></li><li class="listitem" value="5">With this class, we will save some steps for when we need to create a new silent note. Following the same logic, let's create the piano factory and the drum factory. Use <a id="id165" class="calibre1"/>this code to create the piano factory:<div><pre class="programlisting">class PianoNoteFactory: AbstractNoteFactory {
    func createNote(noteStep:NoteStep, order:Int) -&gt; NoteProtocol{
        var note = MusicalNote(noteStep)
        note.step = noteStep
        var x:CGFloat = CGFloat(120.0) + CGFloat(40.0) * CGFloat(order)
        
        switch noteStep {
        case .NOTE_C:
            note.image = UIImage(named: "cnote.png")
            note.location = CGPointMake( CGFloat(x), 57)
            note.sound = "piano_c"
        case .NOTE_D:
            note.image = UIImage(named: "dnote.png")
            note.location = CGPointMake( CGFloat(x), 44)
            note.sound = "piano_d"
        case .NOTE_E:
            note.image = UIImage(named: "dnote.png")
            note.location = CGPointMake( CGFloat(x), 36)
            note.sound = "piano_e"
        }
        return note
    }
}</pre></div></li><li class="listitem" value="6">And now, let's <a id="id166" class="calibre1"/>create the drum factory:<div><pre class="programlisting">class DrumNoteFactory: AbstractNoteFactory {
    func createNote(noteStep:NoteStep, order:Int) -&gt; NoteProtocol{
        var note = MusicalNote(noteStep)
        note.step = noteStep
        var x:CGFloat = CGFloat(120.0) + CGFloat(40.0) * CGFloat(order)
        
        switch noteStep {
        case .NOTE_C:
            note.image = UIImage(named: "cdrum.png")
            note.location = CGPointMake( CGFloat(x), 57)
            note.sound = "bighit"
        case .NOTE_D:
            note.image = UIImage(named: "ddrum.png")
            note.location = CGPointMake( CGFloat(x), 46)
            note.sound = "cymbal"
        case .NOTE_E:
            note.image = UIImage(named: "ddrum.png")
            note.location = CGPointMake( CGFloat(x), 38)
            note.sound = "hithat"
        }
        return note
    }
}</pre></div></li><li class="listitem" value="7">Good, it's time to create our layout. For this recipe, we will need to add a staff (the image view), which is where the notes will be displayed, a segmented control that will let us choose the note factory we want, and a play button that will <a id="id167" class="calibre1"/>appear after we create 10 notes and <a id="id168" class="calibre1"/>which will allow us to hear our music.<div><img src="img/00040.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="8">We won't allow the user to play the music before it is completely composed. For this reason, the play button must start as invisible. To do this, after adding the button to the view on the storyboard, click on it, go to the attribute inspector, and select the <strong class="calibre8">Hidden</strong> option.</li><li class="listitem" value="9">As you know, we now have to link the segmented control and the button with its attribute. Let's also add other attributes that are necessary for this app:<div><pre class="programlisting">    @IBOutlet var segmentedControl: UISegmentedControl!
    @IBOutlet var playButton: UIButton!
    @IBOutlet var staff: UIImageView!
    var notes = [NoteProtocol]()
    var factory:AbstractNoteFactory = SilenceFactory()
    var timer:NSTimer?
    var pos = 0</pre></div><div><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre7">In this case, we had to specify the factory type as <code class="email">AbstractNoteFactory</code>; if not, it will be declared as <code class="email">SilenceFactory</code>, and it won't allow us to change the factory type.</p></div></li><li class="listitem" value="10">Let's add the possibility to tap on the staff and add a note. To do this, we will add the <a id="id169" class="calibre1"/>following code on <code class="email">viewDidLoad</code>:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        let recognizer = UITapGestureRecognizer(target: self, action:Selector("handleTap:"))
        self.view.addGestureRecognizer(recognizer)
    }</pre></div></li><li class="listitem" value="11">As you can see, every <a id="id170" class="calibre1"/>time we tap on the screen, we have to check whether it is in a place where we can add a note. Let's implement this gesture action:<div><pre class="programlisting">    func handleTap(recognizer:UITapGestureRecognizer) {
        let point = recognizer.locationInView(staff)
        var noteStep:NoteStep = .NOTE_C
        switch point.y {
        case 105...125:
            noteStep = .NOTE_C
        case 95...105:
            noteStep = .NOTE_D
        case 80...95:
            noteStep = .NOTE_E
        default:
            return
        }
        var note = factory.createNote(noteStep, order: notes.count)
        notes.append(note)
        var imageView = UIImageView(frame: CGRect(origin: note.location, size: note.image!.size))
        imageView.image = note.image
        staff.addSubview(imageView)
        if notes.count == 10 {
            self.segmentedControl.hidden = true
            self.playButton.hidden = false
        }
    }</pre></div></li><li class="listitem" value="12">As you can see, when we tap on the screen, we just ask for a new note; it doesn't matter which one is the current factory. Now, the segmented control will change the <a id="id171" class="calibre1"/>current factory when the user wants it:<div><pre class="programlisting">    @IBAction func changeFactory(sender: UISegmentedControl) {
        switch sender.selectedSegmentIndex {
        case 0:
            factory = SilenceFactory()
        case 1:
            factory = PianoNoteFactory()
        case 2:
            factory = DrumNoteFactory()
        default:
            break;
        }
    }</pre></div></li><li class="listitem" value="13">To finish this <a id="id172" class="calibre1"/>app, we have to create an event for the play button. As we are not going to press the button for each note, we will initialize the timer and create a method to play each note after half a second:<div><pre class="programlisting">    @IBAction func playMusic(sender: UIButton) {
        playButton.enabled = false
        timer = NSTimer.scheduledTimerWithTimeInterval(0.5, target: self, selector: Selector("playNote"), userInfo: nil, repeats: true)
        timer?.fire()
    }
    func playNote(){
        notes[pos].play()
        pos++
        if pos &gt;= notes.count {
            timer?.invalidate()
            pos = 0
            playButton.enabled = true
        }
    }</pre></div></li><li class="listitem" value="14">Now, click on play and compose your music.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec106" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">The Abstract Factory pattern saves us from performing a lot of steps after instantiating an object. As a programmer, we don't need to worry about the class that the object needs to use, only the base class; in this case, it created an object of the <code class="email">NoteProtocol</code> type.</p><p class="calibre7">As every factory implements the same protocol, we don't need to check which the current factory is. We can also <a id="id173" class="calibre1"/>create new factories, and the code change <a id="id174" class="calibre1"/>wouldn't be painful.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec107" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">We will create another creational pattern that will allow us to create a home automation simulator.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec38" class="calibre1"/>Simulating a home automation</h1></div></div></div><p class="calibre7">Technology is <a id="id175" class="calibre1"/>getting more and more popular every day; soon we will control even our door locks from our mobile phones. However, how does it work? Imagine when you walk into your living room, a sensor can detect that there is someone there and it will turn on the light. Also, if a barometer detects that it is going to rain, it can close the home windows. The examples mentioned here are good samples of objects that change their status and tell other objects about this change. For this case, we will use the <a id="id176" class="calibre1"/>pattern <strong class="calibre8">Observer</strong>, also known as the <strong class="calibre8">publisher-subscriber</strong> <a id="id177" class="calibre1"/>pattern.</p><p class="calibre7">In this recipe, we will create a sample of a home with only two windows, a door lock, and a clothes line. To make it simple, the application will read the sensor information from a file.</p><p class="calibre7">When we receive information from the radar, it may be that someone is approaching your home. In this case, the door lock must be locked and the windows should be closed, or when this person goes away, the windows can be opened again. Also, when the barometer detects that it is going to rain, the windows must be closed and the clothes line must collect the clothes. When the rain stops, these robots can do the opposite action.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec108" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Let's create a new project called <code class="email">Chapter 4 Observer</code>. My first idea for this recipe was to create a list of actions into a file, but as with a few actions, it will be enough; we will create an array with actions instead.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec109" class="calibre1"/>How to do it…</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">First, let's create the simplest model, which in our case is the door lock. Basically, the only thing that we need to do here is to store its status, which can be opened or <a id="id178" class="calibre1"/>closed. So, create a file called <code class="email">DoorLock.swift</code> and add the following code:<div><pre class="programlisting">class DoorLock {
    enum Status {
        case OPENED, CLOSED
    }
    private var _status = Status.OPENED
    var status:Status {
        return _status
    }
    func open(){
        _status = .OPENED
    }
    func close(){
        _status = .CLOSED
    }
}</pre></div></li><li class="listitem" value="2">Once we've done the previous code, we can do something similar with the clothes line, so put the following code into a new file called <code class="email">ClothesLine.swift</code>:<div><pre class="programlisting">class ClothesLine {
    enum Status {
        case COLLECTED,
            LINED
    }
    private var _status = Status.LINED
    var status:Status {
        return _status
    }
    func collect(){
        _status = .COLLECTED
    }
    func line(){
        _status = .LINED
    }
}</pre></div></li><li class="listitem" value="3">Ok, now we need our last accessory, that is, the window. In this case, we have to store the count of times it was closed. Imagine that two people approach our house and one of them goes away; we have to keep the window closed because there is another person still near our house. So, create a file called <a id="id179" class="calibre1"/><code class="email">Window.swift</code> and add the following code:<div><pre class="programlisting">class Window {
    enum Status {
        case OPENED, CLOSED(times:Int)
    }
    private var _status = Status.OPENED
    var status:Status {
        return _status
    }
    func open(){
        switch _status{
        case .CLOSED(var times):
            times = times - 1
            if times == 0{
                _status = .OPENED
            }else{
                _status = .CLOSED(times:times)
            }
        default:
            _status = .OPENED
        }
    }
    func close(){
        switch _status{
        case .CLOSED(var times):
            times = times + 1
            _status = .CLOSED(times:times)
        default:
            _status = .CLOSED(times:1)
        }
    }
}</pre></div></li><li class="listitem" value="4">Good, now it's time to create the radar. Remember that the radar needs to store some objects that will notify the status change, so we will create a nested class called <code class="email">RadarObserver</code>. Start adding this class into a new file called <code class="email">Radar.swift</code>, as follows:<div><pre class="programlisting">class Radar{
    class RadarObserver{
        var onSomeoneAproaches: ()-&gt;Void
        var onSomeoneHasGoneAway: () -&gt; Void
        
        init(){
            self.onSomeoneAproaches = { () -&gt; Void in
            }
            self.onSomeoneHasGoneAway = {() -&gt; Void in
            }
        }
    }
var observers = [RadarObserver]()
    func addObserver(observer: RadarObserver){
        observers.append(observer)
    }</pre></div></li><li class="listitem" value="5">This feature can be added because we are creating a nested class; Swift doesn't allow us to create nested protocols. Now, create the methods that store or remove the observers. We will not remove any observer in this recipe but, as I <a id="id180" class="calibre1"/>told you earlier, always be prepared for the future.</li><li class="listitem" value="6">The last part of this class is the methods that change the object status:<div><pre class="programlisting">    func detectedSomeone(){
        for observer in observers {
            observer.onSomeoneAproaches()
        }
    }
    func someoneHasGoneAway(){
        for observer in observers {
            observer.onSomeoneHasGoneAway()
        }
    }
}</pre></div></li><li class="listitem" value="7">Once we've understood it, we can create the barometer following the philosophy which we have used here:<div><pre class="programlisting">class Barometer{
    class BarometerObserver{
        var onItsGoingToRain:() -&gt; Void
        var onRainHasFinished:() -&gt; Void

        init() {
            self.onItsGoingToRain = { () -&gt; Void in
            }
            self.onRainHasFinished = { () -&gt; Void in
            }
        }
    }
    private var observers = [BarometerObserver]()
    func addObserver(observer: BarometerObserver){
        observers.append(observer)
    }
    func removeObserver(observer:BarometerObserver){
        var index: Int?
        for (i,object) in observers.enumerate(){
            if object === observer{
                index = i
                break
            }
        }
        if let indexFound = index{
            observers.removeAtIndex(indexFound)
        }
    }
    func detectedRain(){
        for observer in observers {
            observer.onItsGoingToRain()
        }
    }
    
    func detectedNoRain(){
        for observer in observers {
            observer.onRainHasFinished()
        }
    }
}</pre></div></li><li class="listitem" value="8">Ok, now we can <a id="id181" class="calibre1"/>create our display. For this recipe, we will add five labels, one for each accessory and one to show the last action. We also need a button to start simulating the reception of radar and barometer events. You will see a view similar to the following one:<div><img src="img/00041.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="9">Now, let's link these components with the corresponding attributes:<div><pre class="programlisting">    @IBOutlet var labelWindow1: UILabel!
    @IBOutlet var labelWindow2: UILabel!
    @IBOutlet var labelDoorLock: UILabel!
    @IBOutlet var labelClothesLine: UILabel!
    @IBOutlet var labelLastAction: UILabel!
    @IBOutlet var buttonStart: UIButton!</pre></div></li><li class="listitem" value="10">Now, let's go to <a id="id182" class="calibre1"/>the view controller and let's start completing the attributes. In this case, we need a radar, a barometer, two windows, a door lock, a clothes line, a list of actions that will be performed, and a timer to make the simulation easier for our eyes:<div><pre class="programlisting">    var radar = Radar()
    var barometer = Barometer()
    var window1 = Window()
    var window2 = Window()
    var doorLock = DoorLock()
    var clothesLine = ClothesLine()
    var actions=[String]()
    var timer:NSTimer?</pre></div></li><li class="listitem" value="11">Now, let's create a private function that will update the labels. This function is an auxiliary <a id="id183" class="calibre1"/>function, so we don't need to repeat this code in every observer action:<div><pre class="programlisting">    private func updateLabels(){
        switch self.window1.status {
        case .CLOSED:
            self.labelWindow1.text = "Window 1 Status: CLOSED"
        default:
            self.labelWindow1.text = "Window 1 Status: OPENED"
        }
        
        switch self.window2.status {
        case .CLOSED:
            self.labelWindow2.text = "Window 2 Status: CLOSED"
        default:
            self.labelWindow2.text = "Window 2 Status: OPENED"
        }
        
        switch self.doorLock.status {
        case .CLOSED:
            self.labelDoorLock.text = "Door Lock Status: CLOSED"
        default:
            self.labelDoorLock.text = "Door Lock Status: OPENED"
        }
        
        switch self.clothesLine.status {
        case .COLLECTED:
            self.labelClothesLine.text = "Clothes Status: LINED"
        default:
            self.labelClothesLine.text = "Clothes Status: COLLECTED"
        }
    }</pre></div></li><li class="listitem" value="12">Next, on our <code class="email">viewDidLoad</code> method, we will add the observer's code. The following code only has the creation of the first two observers; you have to complete it following the same rule because it will be exhausting showing all of them:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        var radarObserver = Radar.RadarObserver()
        radarObserver.onSomeoneAproaches = { () -&gt; Void in
            self.window1.close()
            self.updateLabels()
        }
        
        radarObserver.onSomeoneHasGoneAway = {
            () -&gt; Void in
            self.window1.open()
            self.updateLabels()
        }
        radar.addObserver(radarObserver)
        
        radarObserver = Radar.RadarObserver()
        radarObserver.onSomeoneAproaches = { () -&gt; Void in
            self.window2.close()
            self.updateLabels()
        }
        radarObserver.onSomeoneHasGoneAway = {
            () -&gt; Void in
            self.window2.open()
            self.updateLabels()
        }
        radar.addObserver(radarObserver)
}
…</pre></div></li><li class="listitem" value="13">Now, we can <a id="id184" class="calibre1"/>complete creating the simulator, the event of our button, which will initialize the actions and the timer, and a function that will be called by the timer and perform the corresponding action:<div><pre class="programlisting">    func tick(){
        var action = actions.first
        actions.removeAtIndex(0)
        if actions.count == 0 {
            buttonStart.enabled = true
            timer?.invalidate()
        }
        
        if action == "someoneapproches"{
            radar.detectedSomeone()
        }else if action == "someoneleaves"{
            radar.someoneHasGoneAway()
        }else if action == "startrainning" {
            barometer.detectedRain()
        }else if action == "rainfinishes" {
            barometer.detectedNoRain()
        }
        
        labelLastAction.text = action
    }

    @IBAction func start(sender: AnyObject) {
        buttonStart.enabled = false
        actions = ["someoneapproches","someoneleaves", "someoneapproches","someoneapproches", "startrainning","someoneleaves","someoneleaves", "rainfinishes"]
        timer = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: Selector("tick"), userInfo: nil, repeats: true)
        timer!.fire()
    }</pre></div></li><li class="listitem" value="14">It's done now! Click on play and watch it work.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec110" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">As you can see, the main goal of an observer is to execute an action, and to do this we used closures. This Swift feature is equivalent to blocks on Objective-C and function variables in JavaScript. A closure knows where the object was created and can access its attributes even if it was stored in another object.</p><p class="calibre7">In our recipe, when the <a id="id185" class="calibre1"/>radar or the barometer detects something different, it will notify every observer who has subscribed to it. Each observer acts over the corresponding accessory (window, door lock, or that thing called a clothes line). Note that if we would like to write a traditional object method, it will be necessary to create new classes that inherit from the same observer and store in it the attribute that it is going to use. It wouldn't be a bad implementation, but using closures is much easier and more flexible.</p><p class="calibre7">If you are a Martin Fowler fan, you have probably noticed that some code here is very similar to the barometer observer and the radar observer. This is what Mr. Martin calls the smell of a code, meaning that the code doesn't need to be technically wrong to still smell bad.</p><p class="calibre7">That would be true in this case, except that this is just an example. Remember that in real life, the radar would probably have to notify you of the intruder's position, and the barometer would need to notify you of the precipitation, making the notifier's methods incompatible.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec111" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">We already learned about behavioral patterns and creational patterns. In the next recipe, we will use a structural <a id="id186" class="calibre1"/>pattern, creating new object types based on a new feature.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec39" class="calibre1"/>Delivering some pizzas</h1></div></div></div><p class="calibre7">Imagine that you <a id="id187" class="calibre1"/>have to create a new window type which will have a border; the first idea is borrowed from a window class, creating a new class called <code class="email">BorderedWindow</code>. You can do the same thing with scroll bars; call it <code class="email">ScrolledWindow</code>. Now, if we need to create a window with a scroll and border, we have to create a new class called <code class="email">ScrolledAndBorderedWindow</code>, but imagine that we now need to add a double and triple bordered window, which will have lots of combinations.</p><p class="calibre7">To prevent this kind of problem, there is a <a id="id188" class="calibre1"/>pattern called <strong class="calibre8">decorator</strong>; this pattern allows us to create new object types based on a new feature.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec112" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new project called <code class="email">Chapter 4 Pizzas</code> and add the pizza image into <code class="email">Images.xcassets</code>. Now, let's heat up the oven and prepare some pizzas.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec113" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's execute these steps to deliver some pizzas:</p><div><ol class="orderedlist"><li class="listitem" value="1">First of all, let's create a base class that defines a pizza, so create a new file called <code class="email">Pizza.swift</code> and create the following class:<div><pre class="programlisting">class BasePizza {
    private var _price:Double
    var price:Double {
        get {
            return _price
        }
    }
    var name:String

    init(name:String, price:Double){
        self.name = name
        self._price = price
    }
}</pre></div></li><li class="listitem" value="2">As you can see, this class stores the price and the pizza or ingredient name. Now, we can <a id="id189" class="calibre1"/>define some pizzas with their prices:<div><pre class="programlisting">class SimplePizza : BasePizza{
    init() {
        super.init(name: "SimplePizza", price: 4.50)
    }
}

class Peperoni: BasePizza{
    init() {
        super.init(name: "Peperoni", price: 7.50)
    }
}

class ChickenFiesta:BasePizza {
    init() {
        super.init(name: "ChickenFiesta", price: 7.50)
    }
}</pre></div></li><li class="listitem" value="3">Create a new file called <code class="email">PizzaDecorators.swift</code>; here is where we will create the extra ingredients. First, we need to create a class that defines what a pizza decorator is:<div><pre class="programlisting">class BasePizzaDecorator:BasePizza {
    var decoratedPizza:BasePizza?
    init(name:String, price:Double, decoratedPizza:BasePizza){
        self.decoratedPizza = decoratedPizza
        super.init(name: name, price: price)
    }

    override var price:Double {
        get {
            return super.price + decoratedPizza!.price
        }
    }
}</pre></div></li><li class="listitem" value="4">Now, let's add some extra ingredients. In this case, we will have jalapeños, cheese, mushrooms, and olives:<div><pre class="programlisting">class Jalapeño:BasePizzaDecorator {
    init(decoratedPizza:BasePizza){
        super.init(name: "Jalapeño", price: 1.20, decoratedPizza: decoratedPizza)
    }
}

class Cheese:BasePizzaDecorator {
    init(decoratedPizza:BasePizza){
        super.init(name: "Cheese", price: 1.30, decoratedPizza: decoratedPizza)
    }
}

class Mushroom:BasePizzaDecorator {
    init(decoratedPizza:BasePizza){
        super.init(name: "Mushroom", price: 1.10, decoratedPizza: decoratedPizza)
    }
}
class Olive:BasePizzaDecorator {
    init(decoratedPizza:BasePizza){
        super.init(name: "Olive", price: 1.10, decoratedPizza: decoratedPizza)
    }
}</pre></div></li><li class="listitem" value="5">Good! Once you're done with that, we can create the view. We will add one label to display the <a id="id190" class="calibre1"/>total, four buttons for the extra ingredients, one text view to display the ingredients that we've already added to our pizza, and an Image View to make our application happier. At the end, we should have a layout similar to the one shown here:<div><img src="img/00042.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="6">Now, we can create the view controller. Let's start with the attributes:<div><pre class="programlisting">    var myDeliciousPizza: BasePizza?
    @IBOutlet var totalLabel: UILabel!
    @IBOutlet var ingredientsList: UITextView!</pre></div></li><li class="listitem" value="7">Let's ask the user to <a id="id191" class="calibre1"/>select the pizza that he wants. In this case, we need to do it on <code class="email">viewDidAppear</code> because we will do it with an action sheet, and this component doesn't work on the <code class="email">viewDidLoad</code> method because the view is not ready to display action sheets yet:<div><pre class="programlisting">    override func viewDidAppear(animated: Bool) {
        var choosePizzaType = UIAlertController(title: "Pizza", message: "Choose your pizza", preferredStyle: .ActionSheet)
        choosePizzaType.addAction(UIAlertAction(title: "Simple", style: .Default, handler: { (action) in
            self.myDeliciousPizza = SimplePizza()
            self.refreshPrice()
        }))
        
        choosePizzaType.addAction(UIAlertAction(title: "Peperoni", style: .Default, handler: { (action) in
            self.myDeliciousPizza = Peperoni()
            self.refreshPrice()
        }))
        
        choosePizzaType.addAction(UIAlertAction(title: "Chicken Fiesta \u{1F389}", style: .Default, handler: { (action) in
            self.myDeliciousPizza = ChickenFiesta()
            self.refreshPrice()
        }))
        
        self.presentViewController(choosePizzaType, animated: true){   }
    }</pre></div></li><li class="listitem" value="8">We need to <a id="id192" class="calibre1"/>create a method called <code class="email">refreshPrice</code>; it is as easy as this one:<div><pre class="programlisting">    func refreshPrice(){
        self.totalLabel.text = "Total: \(myDeliciousPizza!.price)"
    }</pre></div></li><li class="listitem" value="9">To finish our application, we have to add the events that belong to the buttons; don't forget to link them:<div><pre class="programlisting">    @IBAction func addJalapeño(sender: UIButton) {
        myDeliciousPizza = Jalapeño(decoratedPizza: myDeliciousPizza!)
        self.ingredientsList.text = self.ingredientsList.text + "Jalapeño\n"
        self.refreshPrice()
    }
    
    @IBAction func addCheese(sender: UIButton) {
        myDeliciousPizza = Cheese(decoratedPizza: myDeliciousPizza!)
        self.ingredientsList.text = self.ingredientsList.text + "Cheese\n"
        self.refreshPrice()
    }
    
    @IBAction func addOlives(sender: UIButton) {
        myDeliciousPizza = Olive(decoratedPizza: myDeliciousPizza!)
        self.ingredientsList.text = self.ingredientsList.text + "Olive\n"
        self.refreshPrice()
    }
    
    @IBAction func addMushrooms(sender: UIButton) {
        myDeliciousPizza = Mushroom(decoratedPizza: myDeliciousPizza!)
        self.ingredientsList.text = self.ingredientsList.text + "Mushrooms\n"
        self.refreshPrice()
    }</pre></div></li><li class="listitem" value="10">Now the application is done, press play, choose a pizza, add some ingredients and enjoy your meal.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec114" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">The decorator pattern <a id="id193" class="calibre1"/>allows us to create a new object based on another one, which is very useful to prevent the creation of uncontrolled numbers of classes based on combinations of features.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec115" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">There are more patterns. You can <a id="id194" class="calibre1"/>check them out on Wikipedia (<a class="calibre1" href="http://en.wikipedia.org/wiki/Software_design_pattern">http://en.wikipedia.org/wiki/Software_design_pattern</a>). Check which ones are the best for your project. There is also another feature called anti-pattern, which explains common bad practices. In the next chapter, we will learn how to work with concurrent code with Swift, something that is very common nowadays, mainly if you like to develop games.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec40" class="calibre1"/>Protocol-oriented programming</h1></div></div></div><p class="calibre7">With the first <a id="id195" class="calibre1"/>version of Swift, you were able to extend classes, structs, and enums using extensions. This is a very powerful feature and allows you, the developer, to fine tune existing types to better meet your application needs. With Swift 2.0, Apple has included a new feature: protocol extensions. It is easy to only think of this as a small feature; however, it has the power to transform the way you write your code. Apple is calling this new paradigm protocol-oriented programming. In this recipe, we will learn how to take advantage of this new feature and some new patterns compared to object-oriented programming.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec116" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">For this recipe, create a new playground titled <code class="email">Chapter 4 Protocols</code>. We will be using a playground only for this recipe, so do not worry about any project settings.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec117" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's start by adding some code:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we will <a id="id196" class="calibre1"/>create two protocols and a struct that conforms to these two protocols, like so:<div><pre class="programlisting">protocol Flyable {
       var topSpeed: Int { get }
   }

   protocol Transportable {
       var seatCount: Int { get }
   }

   struct Plane: Flyable, Transportable {
       var topSpeed = 650
       var seatCount = 220
   }</pre></div></li><li class="listitem" value="2">With OOP, we could have created a single superclass with all properties and subclasses when needed. However, this would result in a more complex superclass and each subclass would contain properties/functionality that it does not need. By defining <code class="email">Flyable</code> and <code class="email">Transportable</code> as protocols, we can have custom data types inherit from multiple sources instead of a single superclass. Now that we have some basic protocols, it's time to actually extend them. Let's extend the <code class="email">Flyable</code> protocol to check whether another <code class="email">Flyable</code> object is faster. Add this code to your playground:<div><pre class="programlisting">extension Flyable {
    func isFasterThan(item: Flyable) -&gt; Bool {
        return self.topSpeed &gt; item.topSpeed
    }
}

let commercialPlane = Plane()
let jetPlane = Plane(topSpeed: 850, seatCount: 20)

commercialPlane.isFasterThan(jetPlane)</pre></div><div><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre7">It is important to note another new feature related to protocol extensions: default behaviors. If you look at our previous implementation, you will notice that we defined a method rather than declare one. Standard protocols require the conforming object to define each method, but with Swift 2.0, we can provide a default implementation so other classes do not have to.</p></div></li><li class="listitem" value="3">Let's create another extension, but only for types that also conform to the Transportable <a id="id197" class="calibre1"/>protocol. Add this code to your playground:<div><pre class="programlisting">extension Flyable where Self: Transportable {
    func containsMorePassengers(item: Self) -&gt; Bool {
        return self.seatCount &gt; item.seatCount
    }
}

commercialPlane.containsMorePassengers(jetPlane)</pre></div><p class="calibre15">The <code class="email">Self</code> keyword with a capital <code class="email">S</code> represents that class or structure that is conforming to the protocol. In this case it means the <code class="email">Plane</code> class. Using this simple combination, you can see how useful protocol extensions can be with custom types. The real power of protocol extensions comes from your ability to extend the Swift Standard Library. Let's take a look.</p><div><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre7">Using the protocol extension feature with the Swift Standard Library allows us to add functionality to existing protocols such as <code class="email">Equatable</code> and <code class="email">CollectionType</code> (arrays and dictionaries).</p></div></li><li class="listitem" value="4">Let's add functionality to <code class="email">CollectionType</code> to get the average speed of <code class="email">Flyable</code> types in an array. Add this code to your playground:<div><pre class="programlisting">extension CollectionType where Self.Generator.Element: Flyable {
    func averageTopSpeed() -&gt; Int {
        var total = 0, count = 0
        for item in self {
            total += item.topSpeed
            count++
        }
        return (total/count)
    }
}

let planes = [commercialPlane, jetPlane, Plane()]
planes.averageTopSpeed()</pre></div></li></ol><div></div><p class="calibre7">This protocol extension defines the <code class="email">averageTopSpeed</code> method. The implementation is pretty simple. We define a count and total variable and then iterate through each item in the collection and add to the total while incrementing count. We have to manually increment count because <code class="email">CollectionType</code> has a different property type for count (rather than <code class="email">Int</code>).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec118" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Because protocols <a id="id198" class="calibre1"/>provide more flexibility, you can create more finely tuned code to fit each of your application's needs. For the most power, utilize custom type protocol extensions as well as extending the Swift Standard Library extensions.</p><p class="calibre7">Note how we are creating a struct for <code class="email">Plane</code> rather than an object. This highlights one issue with OOP involving object reference.</p><p class="calibre7">Imagine we have two objects: A and B. A creates some set of data and then shares this data with object B by reference. This means two different objects are referencing the same data object. B then changes some of this data. Now, object A may find data with changes it does not know how to handle. This may seem like a small issue but can cause many problems, even in simple applications.</p><p class="calibre7">In Swift, structs are passed by value instead of reference. In our previous example, object A would have copied the data rather than pass a reference to it, thus each object would have its own copy that does not interfere with the other.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec119" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">If you would like to learn more or better understand why you would want to use protocol <a id="id199" class="calibre1"/>extensions and protocol-oriented programming, check out the WWDC 2015 video titled <em class="calibre9">Protocol-Oriented Programming in Swift</em> (<a class="calibre1" href="https://developer.apple.com/videos/play/wwdc2015-408/">https://developer.apple.com/videos/play/wwdc2015-408/</a>)</li></ul></div></div></div></body></html>