- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Watch Project – Fitness Companion UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement the activity button screen for the Fitness
    Companion project. In the previous chapter, we looked at the design of Fitness
    Companion and, more specifically, the **Current Activity** screen design. Then
    we broke the screen down into all the components required. We then implemented
    all the components using SwiftUI. At the end of the previous chapter, we only
    had a single screen that couldn’t be swiped. The main section will be swipeable
    and present the user with a list of buttons for controlling the current activity.
    Then, we will analyze the activity button screen, break it down into all the components
    it is composed of, and implement all the components to provide a fitness app-like
    feel.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be split into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Activity button screen overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the activity button screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have created a fitness companion application
    for WatchOS. This will serve as a template with a swipeable screen to show the
    user information about an activity. It will serve as a solid foundation for further
    expanding the fitness application or pivoting the project to something different
    while using the core structure we have implemented. As we reach the end of the
    chapter, I will provide exercises to implement more advanced functionality in
    the fitness companion app. This will be the fourth and last project in this book,
    providing you with a 360-degree view of iOS UI development using Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires you to download Xcode version 14 or above from Apple’s
    App Store.
  prefs: []
  type: TYPE_NORMAL
- en: To install Xcode, just search for Xcode in the App Store and select and download
    the latest version. Open Xcode and follow any additional installation instructions.
    Once Xcode has opened and launched, you’re ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 14 of Xcode has the following features/requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It includes SDKs for iOS 16, iPadOS 16, macOS 12.3, tvOS 16, and watchOS 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports on-device debugging in iOS 11 or later, tvOS 11 or later, and watchOS
    4 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will require a Mac running macOS Monterey 12.5 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download the sample code from the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects)'
  prefs: []
  type: TYPE_NORMAL
- en: Activity button screen overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will take another look at the wireframe from [*Chapter
    8*](B18783_08.xhtml#_idTextAnchor402) and break it down into its components. The
    following figure showcases the activity button screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Activity button screen](img/B18783_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Activity button screen
  prefs: []
  type: TYPE_NORMAL
- en: Before we code our application, we will break down the activity button screen
    into the elements that comprise it. As a little task, see whether you can figure
    out what these are. Don’t worry if you don’t know the exact UI component names;
    we will look at the components in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Image components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An Image component is one of the core components offered by SwiftUI. It allows
    you to display an image, which can be used to provide a visual representation
    or to aid a body of text. We will use it to display icons for buttons to control
    the current activity. The following figures show the icons from the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Lock image](img/B18783_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Lock image
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – New image](img/B18783_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – New image
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – End image](img/B18783_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – End image
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Pause image](img/B18783_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Pause image
  prefs: []
  type: TYPE_NORMAL
- en: These images contain not only an icon but also a background. This is something
    that will be further explored later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Text components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using text components to display button titles. Refer to [*Chapter
    2*](B18783_02.xhtml#_idTextAnchor246) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement the code for the activity button screen
    using the components we discussed in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Activity Button Screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement our application’s activity button screen
    and thus complete the fourth and final project in this book. Before we do this,
    we must implement a swipeable page system. The first page will contain the implementation
    from the previous chapter, and the second page will be the activity buttons. Naturally,
    you can use this to expand to as many pages as you require.
  prefs: []
  type: TYPE_NORMAL
- en: Swipeable Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will implement our swipeable pages. Luckily for us, it
    is super simple to implement as many things as possible in SwiftUI. Simply enclose
    our current `VStack` in the `MainView` inside a `TabView` as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we implemented a `TabView`, which is used to create multiple
    pages in our fitness companion app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run it, it will look the same. However, if you try and swipe the
    screen, you will notice a bit of bounce. This is because there is only a single
    page. Now, let’s add a dummy second page to help us test our new `TabView`. After
    the `VStack`, add a `Text` component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we have implemented the second page in our `TabView`. If you try and swipe
    on the page, it will go to the next page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each view within the `TabView` is treated as an individual page. Honestly,
    it’s as simple as that. Running our application will result in the following,
    which shows two dots at the bottom that indicate that there are two pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – First page](img/B18783_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – First page
  prefs: []
  type: TYPE_NORMAL
- en: 'Swiping from right to left will show the second page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Second page](img/B18783_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Second page
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we added an extra page using the `TabView` component. This
    allowed us to add another page that the user was able to traverse with a swipe
    gesture. In the next section, we will add the activity buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Activity Buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will implement the activity buttons on the second page of
    our `TabView`. We will be using custom colors for the background of each button
    and the icon itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and create these custom colors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **Assets** section within the **Project Navigator**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Assets folder](img/B18783_09_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Assets folder
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Assets** section, right-click on the empty space and select **New**
    **Color Set**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – New Color Set button](img/B18783_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – New Color Set button
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Attributes inspector**, set the name of the color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – New Color Set button](img/B18783_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – New Color Set button
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Any Appearance** or **Dark** to set the color. This ensures that in
    all color modes, the desired color will be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Any Appearance](img/B18783_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Any Appearance
  prefs: []
  type: TYPE_NORMAL
- en: 'Now make sure **Content** is set to **sRGB** and **Input Method** is set to
    **8-bit Hexadecimal**. Then set the **Hex** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Setting the color](img/B18783_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Setting the color
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat these steps for all the colors listed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`endColour`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hex color value: `#FF161C`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endColourBackground`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hex color value: `#390B0C`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lockColour`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hex color value: `#06F5E7`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lockColourBackground`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hex color value: `#113330`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`newColour`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hex color value: `#86FE01`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`newColourBackground`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hex color value: `#1E3400`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pauseColour`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hex color value: `#BBA700`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pauseColourBackground`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hex color value: `#342F00`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once completed, the **Assets** screen should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Colors added](img/B18783_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Colors added
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the colors have been created, we cannot use them directly in our
    code. Let’s fix this. Doing so is rather simple. In the `MainView`, we will extend
    the `Color` functionality to support our colors. Before doing so, I thought it
    is prudent to mention why I spelled color like so when referring to the functionality.
    This is the American spelling and is the one used within Swift. To extend the
    functionality, we must spell it this way, but as I am British, the spelling I
    personally use is *Colour*. Now that is cleared up. Let’s extend the Swift color.
    Add the following code above the `MainView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Though we have added it to the `MainView`, extending the Swift color allows
    us to use it anywhere in our project. It’s also worth mentioning that this means
    only in our project and doesn’t extend beyond the scope of our project into other
    projects. Our project is small, so it’s perfectly fine putting it inside the `MainView`.
    However, it is common practice to put extensions like this in a specific file.
    If there are a lot of color extensions, then they could have their own Color file.
    This is beyond the scope of this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick overview of the preceding code: we extended the Color using
    static variables of the names we set previously in the asset.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The variable names do not need to be the same as the color name. But it is good
    practice to keep them the same. It makes them easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the buttons is made up of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the background, we will use a `Rectangle` component. More specifically,
    we will use the `RoundedRectangle` component as it allows us to set a corner radius.
    Feel free to change the design and use a `Rectangle` or any other shape. For the
    icon, we will use the `Image` component and use a built-in icon. Feel free to
    use your own image or look at SF Symbols, as discussed earlier, in [*Chapter 6*](B18783_06.xhtml#_idTextAnchor354),
    *Implementing the Sidebar*, to see all built-in icons. The text is the simplest
    of all the components and will use a basic `Text` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most difficult part of the buttons is the background and icon. This is
    because they are on top of each other. The text is placed below the image, making
    it easy to add. We will initially concentrate on getting the background and icon
    coded. We will use a `ZStack` to place the icon on top of the background. Replace
    the second-page dummy `Text` component with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a `RoundedRectangle` with a corner radius of 18\. Feel free
    to increase the number to get more rounded corners, or to lower it. Setting the
    style to `.continuous` makes the corners appear smoother, which is always a good
    thing. Let’s see what this produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Simple rounded rectangle](img/B18783_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Simple rounded rectangle
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, it’s not looking anything like the button in the figures shown at
    the start of this chapter. There are just two things missing – the background
    color and making the size smaller. We will use the `lockColourBackground` color
    we created previously and set the size to a width of `70` and a height of `64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the image background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Rounded color styled](img/B18783_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Rounded color styled
  prefs: []
  type: TYPE_NORMAL
- en: 'The background is finally looking more like our design. The next step is to
    add the icon inside of the rectangle. Doing so is simple. Add an image with the
    icon after the `RoundedRectangle` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application now will produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Teardrop icon in background](img/B18783_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Teardrop icon in background
  prefs: []
  type: TYPE_NORMAL
- en: 'We used **SF Symbols** to obtain the teardrop icon. Feel free to use any icon
    as you see fit, or even your own image. We need to change the icon style. There
    are two main aspects to update, the color and size. Update the image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We first set it to `resizable`, which allows us to change the size. Next, we
    set the color using one of the colors we created earlier. Next, we ensure the
    aspect ratio is set to fit, which allows us to resize the image without distorting
    it. Finally, we set the size because we have a locked aspect ratio. Setting the
    width automatically sets the height accordingly. Running the application produces
    the result that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Lock button](img/B18783_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Lock button
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add text to our button. The text isn’t inside of the icon or
    even the rectangle but sits beneath it. But we still want it to be clickable,
    so we will wrap all of the button contents inside a `VStack` and also add the
    `Text` component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for wrapping the button in a `VStack` is two-fold:'
  prefs: []
  type: TYPE_NORMAL
- en: We want all of it to be clickable (to be implemented next).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As there will be multiple buttons, the `VStack` is technically the button without
    the icon, rectangle, or text components. Pretty cool!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s make the `VStack` clickable, and then we will take a look at the result.
    First, we need a function for it to call. We could use an inline function, but
    we will create a dedicated function. This provides a nice abstraction in our code
    base. Before the body, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is a simple one. When clicked, a message is logged to the terminal.
    Now update the `VStack` with an `onTapGesture` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That was a lot. Let’s run our application and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Finished lock button](img/B18783_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Finished lock button
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to click the button. It will log a message. Before wrapping up this
    project and implementing the remaining buttons, here is the code so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have almost completed the chapter; the only thing left is to add the remaining
    buttons. First, let’s add the remaining function callbacks above the body, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have implemented the callbacks, we are going to implement the buttons.
    Each button itself is actually simple, as it is the same as the lock button but
    with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RoundedRectangle`’s `foregroundColor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image’s icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image’s `foregroundColor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onTapGesture` callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Merely duplicating the `VStack` code would effectively be duplicating the button.
    We would have the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Extra buttons added](img/B18783_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Extra buttons added
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can’t see a difference, I don’t blame you. It’s hard to see what’s actually
    happened, but if you look at the bottom of the screen, there are five dots, indicating
    that there are five pages now. Remember, when implementing the second page, we
    stated that each component in the root would be its own page. So, we want to group
    all these buttons together by putting them in a 2x2 grid. To organize components
    on the same line, we can use an `HStack`. We only need two on a single line, so
    first, we will enclose the first two buttons, the `VStacks` in an `HStack`. This
    will result in three pages, the first being the one implemented in the previous
    chapter and two for each `HStack`, which isn’t what we want. One small change
    and it will be fixed. Can you guess what it is? Just enclose both `HStacks` in
    a single `VStack`. This will put them on top of each other, thus rendering a grid.
    The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s time to run our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Button grid system](img/B18783_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Button grid system
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be ready to finish this chapter and call it a day. Please bear with
    me – the top row of the grid is too close to the time for my liking. Let’s add
    top `VStack` we just implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is it, the final build and run of our application – drum roll, please!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Button grid system](img/B18783_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Button grid system
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now at the end of our project, and our application looks amazing. Before
    we summarize, feel free to visit the GitHub repository to double-check your code
    base: [https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we added the activity buttons. We did this by implementing
    another page in our fitness app. We leveraged a grid-based system for laying out
    our buttons. We used a variety of core components combined with stacks to organize
    them. In the following section, we will summarize this chapter, and ultimately
    this book. But first, we will look at some code to help you with the extra tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Different Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add different exercises to the fitness companion app, you can modify the
    `MainView` by introducing a new data structure to store exercise information and
    update the UI accordingly. Here’s an example of how you can make these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this modified code, we have introduced a new `Exercise` struct that stores
    the name and image name of each exercise. You can add more exercises to the `exercises`
    array by creating new `Exercise` instances.
  prefs: []
  type: TYPE_NORMAL
- en: In the view, we have used a `ForEach` loop to iterate over the exercises and
    display them dynamically. Each exercise is represented by a `VStack` containing
    an image and a text label. When an exercise is tapped, the activity state is updated
    with the selected exercise’s name.
  prefs: []
  type: TYPE_NORMAL
- en: You can customize the exercise images and add more properties to the `Exercise`
    struct based on your specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Active timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add functionality for an active timer that can be started, stopped, and
    paused, you can modify the `MainView` by introducing additional state variables
    and actions. Here’s an example of how you can make these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this modified code, we have made the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We introduced `isTimerRunning` and `isTimerPaused` state variables to track
    the timer’s state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added `startTimer()`, `pauseTimer()`, and `stopTimer()` actions to handle
    starting, pausing, and stopping the timer, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We modified the “Start/Pause” button to toggle between the `isTimerRunning`
    state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We updated the timer’s `onReceive` closure to only increment the counter and
    update the timer string when the timer is running and not paused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added functionality to reset the counter and timer string when the **End**
    button is pressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these changes, you can now start, pause, and stop the timer in your fitness
    companion app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we successfully added the activity button screen to our Fitness
    Companion application. We began by analyzing the wireframe and breaking down each
    element into SwiftUI components. From there, we implemented the components to
    match the design from the wireframes. Through this process, we gained a deeper
    understanding of how to combine core SwiftUI components using stacks to create
    complex buttons. We finally looked at a few implementations for the extra tasks
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to express my gratitude for taking the time to read this book. There
    were moments when I questioned the purpose of writing yet another programming
    book, but ultimately, it was a worthwhile endeavor. I sincerely hope that you
    were able to gain something from it. If you have any questions or would like to
    contact me directly, please feel free to use any of the platforms listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Twitter: [https://twitter.com/SonarSystems](https://twitter.com/SonarSystems)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Email: [support@sonarsystems.co.uk](mailto:support@sonarsystems.co.uk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Discord: [https://discord.gg/7e78FxrgqH](https://discord.gg/7e78FxrgqH)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FireDEV Podcast: [https://open.spotify.com/show/387RiHksQE33KYHTitFXhg](https://open.spotify.com/show/387RiHksQE33KYHTitFXhg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
