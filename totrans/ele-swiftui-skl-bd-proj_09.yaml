- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Watch Project – Fitness Companion UI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能手表项目 – 健身伴侣 UI
- en: In this chapter, we will implement the activity button screen for the Fitness
    Companion project. In the previous chapter, we looked at the design of Fitness
    Companion and, more specifically, the **Current Activity** screen design. Then
    we broke the screen down into all the components required. We then implemented
    all the components using SwiftUI. At the end of the previous chapter, we only
    had a single screen that couldn’t be swiped. The main section will be swipeable
    and present the user with a list of buttons for controlling the current activity.
    Then, we will analyze the activity button screen, break it down into all the components
    it is composed of, and implement all the components to provide a fitness app-like
    feel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为健身伴侣项目实现活动按钮屏幕。在前一章中，我们研究了健身伴侣的设计，特别是 **当前活动** 屏幕设计。然后我们将屏幕分解为所有必需的组件。然后我们使用
    SwiftUI 实现了所有组件。在前一章的结尾，我们只有一个无法滑动的单屏。主要部分将是可滑动的，向用户提供控制当前活动的按钮列表。然后，我们将分析活动按钮屏幕，将其分解为其组成的所有组件，并实现所有组件以提供类似健身应用程序的感觉。
- en: 'This chapter will be split into the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为以下部分：
- en: Activity button screen overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动按钮屏幕概述
- en: Implementing the activity button screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现活动按钮屏幕
- en: Extra tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外任务
- en: By the end of this chapter, you will have created a fitness companion application
    for WatchOS. This will serve as a template with a swipeable screen to show the
    user information about an activity. It will serve as a solid foundation for further
    expanding the fitness application or pivoting the project to something different
    while using the core structure we have implemented. As we reach the end of the
    chapter, I will provide exercises to implement more advanced functionality in
    the fitness companion app. This will be the fourth and last project in this book,
    providing you with a 360-degree view of iOS UI development using Swift.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将创建一个适用于 WatchOS 的健身伴侣应用程序。这将作为一个模板，带有可滑动的屏幕，向用户展示活动信息。它将作为进一步扩展健身应用程序或使用我们已实现的内核结构将项目转向不同方向的一个坚实基础。随着我们接近本章的结尾，我将提供练习，以在健身伴侣应用程序中实现更多高级功能。这将本书的第四个也是最后一个项目，为你提供一个使用
    Swift 进行 iOS UI 开发的 360 度视角。
- en: Technical Requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires you to download Xcode version 14 or above from Apple’s
    App Store.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求你从 Apple 的 App Store 下载 Xcode 14 或更高版本。
- en: To install Xcode, just search for Xcode in the App Store and select and download
    the latest version. Open Xcode and follow any additional installation instructions.
    Once Xcode has opened and launched, you’re ready to go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Xcode，只需在 App Store 中搜索 Xcode，选择并下载最新版本。打开 Xcode 并遵循任何额外的安装说明。一旦 Xcode 打开并启动，你就可以开始了。
- en: 'Version 14 of Xcode has the following features/requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 14 版本具有以下功能/要求：
- en: It includes SDKs for iOS 16, iPadOS 16, macOS 12.3, tvOS 16, and watchOS 9
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括 iOS 16、iPadOS 16、macOS 12.3、tvOS 16 和 watchOS 9 的 SDK
- en: It supports on-device debugging in iOS 11 or later, tvOS 11 or later, and watchOS
    4 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持在 iOS 11 或更高版本、tvOS 11 或更高版本和 watchOS 4 或更高版本上的设备调试
- en: You will require a Mac running macOS Monterey 12.5 or later
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个运行 macOS Monterey 12.5 或更高版本的 Mac
- en: 'Download the sample code from the following GitHub link:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下 GitHub 链接下载示例代码：
- en: '[https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects)'
- en: Activity button screen overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动按钮屏幕概述
- en: 'In this section, we will take another look at the wireframe from [*Chapter
    8*](B18783_08.xhtml#_idTextAnchor402) and break it down into its components. The
    following figure showcases the activity button screen:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将再次查看第 [*8章*](B18783_08.xhtml#_idTextAnchor402) 中的线框，并将其分解为其组成部分。以下图展示了活动按钮屏幕：
- en: '![Figure 9.1 – Activity button screen](img/B18783_09_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 活动按钮屏幕](img/B18783_09_1.jpg)'
- en: Figure 9.1 – Activity button screen
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 活动按钮屏幕
- en: Before we code our application, we will break down the activity button screen
    into the elements that comprise it. As a little task, see whether you can figure
    out what these are. Don’t worry if you don’t know the exact UI component names;
    we will look at the components in the following section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写应用程序代码之前，我们将把活动按钮屏幕分解成构成它的元素。作为一个小任务，看看你是否能弄清楚这些是什么。如果你不知道确切的UI组件名称，不要担心；我们将在下一节中查看组件。
- en: Image components
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像组件
- en: 'An Image component is one of the core components offered by SwiftUI. It allows
    you to display an image, which can be used to provide a visual representation
    or to aid a body of text. We will use it to display icons for buttons to control
    the current activity. The following figures show the icons from the application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图像组件是SwiftUI提供的核心组件之一。它允许你显示图像，可以用来提供视觉表示或辅助文本内容。我们将使用它来显示控制当前活动的按钮图标。以下图示显示了应用程序中的图标：
- en: '![Figure 9.2 – Lock image](img/B18783_09_2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 锁定图像](img/B18783_09_2.jpg)'
- en: Figure 9.2 – Lock image
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 锁定图像
- en: '![Figure 9.3 – New image](img/B18783_09_3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 新图像](img/B18783_09_3.jpg)'
- en: Figure 9.3 – New image
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 新图像
- en: '![Figure 9.4 – End image](img/B18783_09_4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 结束图像](img/B18783_09_4.jpg)'
- en: Figure 9.4 – End image
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 结束图像
- en: '![Figure 9.5 – Pause image](img/B18783_09_5.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 暂停图像](img/B18783_09_5.jpg)'
- en: Figure 9.5 – Pause image
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 暂停图像
- en: These images contain not only an icon but also a background. This is something
    that will be further explored later in this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像不仅包含图标，还包含背景。这是在本章后面将进一步探讨的内容。
- en: Text components
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本组件
- en: We will be using text components to display button titles. Refer to [*Chapter
    2*](B18783_02.xhtml#_idTextAnchor246) for more information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用文本组件来显示按钮标题。有关更多信息，请参阅[*第2章*](B18783_02.xhtml#_idTextAnchor246)。
- en: In the next section, we will implement the code for the activity button screen
    using the components we discussed in the previous sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用前几节中讨论的组件来实现活动按钮屏幕的代码。
- en: Implementing the Activity Button Screen
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现活动按钮屏幕
- en: In this section, we will implement our application’s activity button screen
    and thus complete the fourth and final project in this book. Before we do this,
    we must implement a swipeable page system. The first page will contain the implementation
    from the previous chapter, and the second page will be the activity buttons. Naturally,
    you can use this to expand to as many pages as you require.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们的应用程序的活动按钮屏幕，从而完成本书的第四个也是最后一个项目。在我们这样做之前，我们必须实现一个可滑动页面系统。第一页将包含上一章的实现，第二页将是活动按钮。当然，你可以使用它扩展到所需的任何页面数。
- en: Swipeable Pages
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可滑动页面
- en: 'In this section, we will implement our swipeable pages. Luckily for us, it
    is super simple to implement as many things as possible in SwiftUI. Simply enclose
    our current `VStack` in the `MainView` inside a `TabView` as demonstrated here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们的可滑动页面。幸运的是，在SwiftUI中实现尽可能多的功能非常简单。只需将我们的当前`VStack`包裹在`MainView`内部的`TabView`中，如下所示：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we implemented a `TabView`, which is used to create multiple
    pages in our fitness companion app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了一个`TabView`，用于在我们的健身伴侣应用程序中创建多个页面。
- en: 'Now, if you run it, it will look the same. However, if you try and swipe the
    screen, you will notice a bit of bounce. This is because there is only a single
    page. Now, let’s add a dummy second page to help us test our new `TabView`. After
    the `VStack`, add a `Text` component, like so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行它，看起来会一样。然而，如果你尝试滑动屏幕，你会注意到一点反弹。这是因为只有一个页面。现在，让我们添加一个虚拟的第二页来帮助我们测试我们新的`TabView`。在`VStack`之后，添加一个`Text`组件，如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have implemented the second page in our `TabView`. If you try and swipe
    on the page, it will go to the next page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的`TabView`中实现了第二页。如果你尝试在页面上滑动，它会跳转到下一页。
- en: 'Each view within the `TabView` is treated as an individual page. Honestly,
    it’s as simple as that. Running our application will result in the following,
    which shows two dots at the bottom that indicate that there are two pages:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabView`内的每个视图都被视为一个单独的页面。老实说，就这么简单。运行我们的应用程序将产生以下结果，显示底部有两个点，表示有两个页面：'
- en: '![Figure 9.6 – First page](img/B18783_09_6.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 第一页](img/B18783_09_6.jpg)'
- en: Figure 9.6 – First page
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 第一页
- en: 'Swiping from right to left will show the second page, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从右向左滑动将显示第二页，如下所示：
- en: '![Figure 9.7 – Second page](img/B18783_09_7.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 第二页](img/B18783_09_7.jpg)'
- en: Figure 9.7 – Second page
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 第二页
- en: In this section, we added an extra page using the `TabView` component. This
    allowed us to add another page that the user was able to traverse with a swipe
    gesture. In the next section, we will add the activity buttons.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 `TabView` 组件添加了一个额外的页面。这使得我们能够添加另一个用户可以通过滑动手势导航的页面。在下一节中，我们将添加活动按钮。
- en: Activity Buttons
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动按钮
- en: In this section, we will implement the activity buttons on the second page of
    our `TabView`. We will be using custom colors for the background of each button
    and the icon itself.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现 `TabView` 的第二页上的活动按钮。我们将为每个按钮的背景和图标本身使用自定义颜色。
- en: 'Let’s go ahead and create these custom colors:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建这些自定义颜色：
- en: 'Navigate to the **Assets** section within the **Project Navigator**:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**项目导航器**中的**资产**部分：
- en: '![Figure 9.8 – Assets folder](img/B18783_09_8.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 资产文件夹](img/B18783_09_8.jpg)'
- en: Figure 9.8 – Assets folder
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 资产文件夹
- en: 'In the **Assets** section, right-click on the empty space and select **New**
    **Color Set**:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**资产**部分，右键单击空白区域并选择**新建** **颜色集**：
- en: '![Figure 9.9 – New Color Set button](img/B18783_09_9.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 新建颜色集按钮](img/B18783_09_9.jpg)'
- en: Figure 9.9 – New Color Set button
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 新建颜色集按钮
- en: 'In **Attributes inspector**, set the name of the color:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性检查器**中设置颜色的名称：
- en: '![Figure 9.10 – New Color Set button](img/B18783_09_10.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 新建颜色集按钮](img/B18783_09_10.jpg)'
- en: Figure 9.10 – New Color Set button
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 新建颜色集按钮
- en: 'Select **Any Appearance** or **Dark** to set the color. This ensures that in
    all color modes, the desired color will be used:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**任何外观**或**深色**来设置颜色。这确保了在所有颜色模式下，将使用所需的颜色：
- en: '![Figure 9.11 – Any Appearance](img/B18783_09_11.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 任何外观](img/B18783_09_11.jpg)'
- en: Figure 9.11 – Any Appearance
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 任何外观
- en: 'Now make sure **Content** is set to **sRGB** and **Input Method** is set to
    **8-bit Hexadecimal**. Then set the **Hex** value:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在确保**内容**设置为**sRGB**，**输入方法**设置为**8 位十六进制**。然后设置**十六进制**值：
- en: '![Figure 9.12 – Setting the color](img/B18783_09_12.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 设置颜色](img/B18783_09_12.jpg)'
- en: Figure 9.12 – Setting the color
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 设置颜色
- en: 'Repeat these steps for all the colors listed:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复以上步骤为所有列出的颜色：
- en: '`endColour`'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endColour`'
- en: 'Hex color value: `#FF161C`'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制颜色值：`#FF161C`
- en: '`endColourBackground`'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`endColourBackground`'
- en: 'Hex color value: `#390B0C`'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十六进制颜色值：`#390B0C`
- en: '`lockColour`'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lockColour`'
- en: 'Hex color value: `#06F5E7`'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十六进制颜色值：`#06F5E7`
- en: '`lockColourBackground`'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lockColourBackground`'
- en: 'Hex color value: `#113330`'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十六进制颜色值：`#113330`
- en: '`newColour`'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newColour`'
- en: 'Hex color value: `#86FE01`'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十六进制颜色值：`#86FE01`
- en: '`newColourBackground`'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newColourBackground`'
- en: 'Hex color value: `#1E3400`'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十六进制颜色值：`#1E3400`
- en: '`pauseColour`'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pauseColour`'
- en: 'Hex color value: `#BBA700`'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十六进制颜色值：`#BBA700`
- en: '`pauseColourBackground`'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pauseColourBackground`'
- en: 'Hex color value: `#342F00`'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十六进制颜色值：`#342F00`
- en: 'Once completed, the **Assets** screen should look as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，**资产**屏幕应如下所示：
- en: '![Figure 9.13 – Colors added](img/B18783_09_13.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 添加的颜色](img/B18783_09_13.jpg)'
- en: Figure 9.13 – Colors added
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 添加的颜色
- en: 'Even though the colors have been created, we cannot use them directly in our
    code. Let’s fix this. Doing so is rather simple. In the `MainView`, we will extend
    the `Color` functionality to support our colors. Before doing so, I thought it
    is prudent to mention why I spelled color like so when referring to the functionality.
    This is the American spelling and is the one used within Swift. To extend the
    functionality, we must spell it this way, but as I am British, the spelling I
    personally use is *Colour*. Now that is cleared up. Let’s extend the Swift color.
    Add the following code above the `MainView` struct:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管颜色已经创建，但我们不能直接在我们的代码中使用它们。让我们解决这个问题。这样做相当简单。在 `MainView` 中，我们将扩展 `Color` 功能以支持我们的颜色。在这样做之前，我认为提到为什么我在提到功能时将颜色拼写成这样是谨慎的。这是美式拼写，并且在
    Swift 中使用。为了扩展功能，我们必须这样拼写，但因为我来自英国，我个人使用的拼写是 *Colour*。现在澄清了这一点。让我们扩展 Swift 颜色。在
    `MainView` 结构之上添加以下代码：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Though we have added it to the `MainView`, extending the Swift color allows
    us to use it anywhere in our project. It’s also worth mentioning that this means
    only in our project and doesn’t extend beyond the scope of our project into other
    projects. Our project is small, so it’s perfectly fine putting it inside the `MainView`.
    However, it is common practice to put extensions like this in a specific file.
    If there are a lot of color extensions, then they could have their own Color file.
    This is beyond the scope of this project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经将其添加到`MainView`中，但扩展Swift颜色允许我们在项目的任何地方使用它。这也值得提一下，这意味着仅限于我们的项目，并且不会超出我们项目的范围扩展到其他项目。我们的项目很小，所以将其放在`MainView`内部是完全可以接受的。然而，将此类扩展放在特定文件中是常见的做法。如果有许多颜色扩展，它们可以有自己的颜色文件。这超出了本项目范围。
- en: 'Here’s a quick overview of the preceding code: we extended the Color using
    static variables of the names we set previously in the asset.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的简要概述：我们通过使用之前在资产中设置的名称的静态变量扩展了颜色。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The variable names do not need to be the same as the color name. But it is good
    practice to keep them the same. It makes them easier to maintain.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名称不需要与颜色名称相同。但保持它们相同是良好的实践。这使得它们更容易维护。
- en: 'Each of the buttons is made up of three components:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮由三个组件组成：
- en: Background
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景
- en: Icon
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标
- en: Text
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: For the background, we will use a `Rectangle` component. More specifically,
    we will use the `RoundedRectangle` component as it allows us to set a corner radius.
    Feel free to change the design and use a `Rectangle` or any other shape. For the
    icon, we will use the `Image` component and use a built-in icon. Feel free to
    use your own image or look at SF Symbols, as discussed earlier, in [*Chapter 6*](B18783_06.xhtml#_idTextAnchor354),
    *Implementing the Sidebar*, to see all built-in icons. The text is the simplest
    of all the components and will use a basic `Text` component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背景，我们将使用一个`矩形`组件。更具体地说，我们将使用`圆角矩形`组件，因为它允许我们设置圆角半径。请随意更改设计并使用`矩形`或任何其他形状。对于图标，我们将使用`图像`组件并使用内置图标。请随意使用您自己的图像或查看之前讨论的
    SF Symbols，在[*第6章*](B18783_06.xhtml#_idTextAnchor354)，*实现侧边栏*，查看所有内置图标。文本是所有组件中最简单的，将使用基本的`文本`组件。
- en: 'The most difficult part of the buttons is the background and icon. This is
    because they are on top of each other. The text is placed below the image, making
    it easy to add. We will initially concentrate on getting the background and icon
    coded. We will use a `ZStack` to place the icon on top of the background. Replace
    the second-page dummy `Text` component with the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮最难的部分是背景和图标。这是因为它们是重叠的。文本放置在图像下方，这使得添加变得容易。我们最初将专注于获取背景和图标的代码。我们将使用`ZStack`将图标放置在背景上方。用以下代码替换第二页的占位符`文本`组件：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have created a `RoundedRectangle` with a corner radius of 18\. Feel free
    to increase the number to get more rounded corners, or to lower it. Setting the
    style to `.continuous` makes the corners appear smoother, which is always a good
    thing. Let’s see what this produced:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个圆角半径为18的`圆角矩形`。请随意增加数字以获得更圆滑的圆角，或降低它。将样式设置为`.continuous`会使圆角看起来更平滑，这始终是好事。让我们看看这会产生什么：
- en: '![Figure 9.14 – Simple rounded rectangle](img/B18783_09_14.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 简单圆角矩形](img/B18783_09_14.jpg)'
- en: Figure 9.14 – Simple rounded rectangle
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 简单圆角矩形
- en: 'Right now, it’s not looking anything like the button in the figures shown at
    the start of this chapter. There are just two things missing – the background
    color and making the size smaller. We will use the `lockColourBackground` color
    we created previously and set the size to a width of `70` and a height of `64`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它看起来与本章开头所示图中的按钮没有任何相似之处。只是缺少两件事——背景颜色和使尺寸更小。我们将使用之前创建的`lockColourBackground`颜色，并将尺寸设置为宽度`70`和高度`64`：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following figure shows the image background:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了图像背景：
- en: '![Figure 9.15 – Rounded color styled](img/B18783_09_15.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 圆角颜色样式](img/B18783_09_15.jpg)'
- en: Figure 9.15 – Rounded color styled
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 圆角颜色样式
- en: 'The background is finally looking more like our design. The next step is to
    add the icon inside of the rectangle. Doing so is simple. Add an image with the
    icon after the `RoundedRectangle` component:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 背景现在看起来更像我们的设计。下一步是向矩形内添加图标。这样做很简单。在`圆角矩形`组件之后添加带有图标的图像：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running the application now will produce the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序现在将产生以下结果：
- en: '![Figure 9.16 – Teardrop icon in background](img/B18783_09_16.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16 – 背景中的泪滴图标](img/B18783_09_16.jpg)'
- en: Figure 9.16 – Teardrop icon in background
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 背景中的泪滴图标
- en: 'We used **SF Symbols** to obtain the teardrop icon. Feel free to use any icon
    as you see fit, or even your own image. We need to change the icon style. There
    are two main aspects to update, the color and size. Update the image as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**SF Symbols**获取泪滴图标。请随意使用您认为合适的任何图标，甚至您自己的图像。我们需要更改图标样式。有两个主要方面需要更新，即颜色和大小。按照以下方式更新图像：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We first set it to `resizable`, which allows us to change the size. Next, we
    set the color using one of the colors we created earlier. Next, we ensure the
    aspect ratio is set to fit, which allows us to resize the image without distorting
    it. Finally, we set the size because we have a locked aspect ratio. Setting the
    width automatically sets the height accordingly. Running the application produces
    the result that follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将其设置为`resizable`，这允许我们更改大小。接下来，我们使用之前创建的一种颜色设置颜色。然后，我们确保宽高比设置为适合，这样我们就可以在不扭曲图像的情况下调整大小。最后，我们设置大小，因为我们有一个固定的宽高比。设置宽度会自动设置相应的高度。运行应用程序会产生以下结果：
- en: '![Figure 9.17 – Lock button](img/B18783_09_17.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 – 锁定按钮](img/B18783_09_17.jpg)'
- en: Figure 9.17 – Lock button
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 锁定按钮
- en: 'Next, we will add text to our button. The text isn’t inside of the icon or
    even the rectangle but sits beneath it. But we still want it to be clickable,
    so we will wrap all of the button contents inside a `VStack` and also add the
    `Text` component, like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的按钮添加文本。文本不在图标或矩形内部，而是位于其下方。但我们仍然希望它可点击，因此我们将所有按钮内容包裹在一个`VStack`中，并添加`Text`组件，如下所示：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The reason for wrapping the button in a `VStack` is two-fold:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将按钮包裹在`VStack`中的原因有两个：
- en: We want all of it to be clickable (to be implemented next).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望所有内容都可点击（将在下一部分实现）。
- en: As there will be multiple buttons, the `VStack` is technically the button without
    the icon, rectangle, or text components. Pretty cool!
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于将有多个按钮，`VStack`在技术上是没有图标的按钮，没有矩形或文本组件。非常酷！
- en: 'Let’s make the `VStack` clickable, and then we will take a look at the result.
    First, we need a function for it to call. We could use an inline function, but
    we will create a dedicated function. This provides a nice abstraction in our code
    base. Before the body, add the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使`VStack`可点击，然后我们将查看结果。首先，我们需要一个函数来调用它。我们可以使用内联函数，但我们将创建一个专用函数。这为我们提供了代码库中的良好抽象。在主体之前，添加以下代码：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The function is a simple one. When clicked, a message is logged to the terminal.
    Now update the `VStack` with an `onTapGesture` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很简单。点击时，会在终端记录一条消息。现在用`onTapGesture`函数更新`VStack`：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That was a lot. Let’s run our application and see the result:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很多了。让我们运行我们的应用程序并查看结果：
- en: '![Figure 9.18 – Finished lock button](img/B18783_09_18.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18 – 完成的锁定按钮](img/B18783_09_18.jpg)'
- en: Figure 9.18 – Finished lock button
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 完成的锁定按钮
- en: 'Feel free to click the button. It will log a message. Before wrapping up this
    project and implementing the remaining buttons, here is the code so far:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随意点击按钮。它将记录一条消息。在完成这个项目并实现剩余的按钮之前，以下是到目前为止的代码：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have almost completed the chapter; the only thing left is to add the remaining
    buttons. First, let’s add the remaining function callbacks above the body, like
    so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了这一章；唯一剩下的事情是添加剩余的按钮。首先，让我们在主体上方添加剩余的功能回调，如下所示：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have implemented the callbacks, we are going to implement the buttons.
    Each button itself is actually simple, as it is the same as the lock button but
    with the following changes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了回调函数，我们将实现按钮。每个按钮本身实际上很简单，因为它与锁定按钮相同，但有一些以下更改：
- en: '`RoundedRectangle`’s `foregroundColor`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoundedRectangle`的`foregroundColor`'
- en: Image’s icon
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的图标
- en: Image’s `foregroundColor`
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的`foregroundColor`
- en: Text
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: The `onTapGesture` callback
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onTapGesture`回调'
- en: 'Merely duplicating the `VStack` code would effectively be duplicating the button.
    We would have the following results:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 仅复制`VStack`代码实际上就是复制按钮。我们会得到以下结果：
- en: '![Figure 9.19 – Extra buttons added](img/B18783_09_19.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图9.19 – 添加的额外按钮](img/B18783_09_19.jpg)'
- en: Figure 9.19 – Extra buttons added
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 – 添加的额外按钮
- en: 'If you can’t see a difference, I don’t blame you. It’s hard to see what’s actually
    happened, but if you look at the bottom of the screen, there are five dots, indicating
    that there are five pages now. Remember, when implementing the second page, we
    stated that each component in the root would be its own page. So, we want to group
    all these buttons together by putting them in a 2x2 grid. To organize components
    on the same line, we can use an `HStack`. We only need two on a single line, so
    first, we will enclose the first two buttons, the `VStacks` in an `HStack`. This
    will result in three pages, the first being the one implemented in the previous
    chapter and two for each `HStack`, which isn’t what we want. One small change
    and it will be fixed. Can you guess what it is? Just enclose both `HStacks` in
    a single `VStack`. This will put them on top of each other, thus rendering a grid.
    The code for this is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到差异，我不怪你。很难看到实际上发生了什么，但如果你看屏幕底部，有五个点，表示现在有五个页面。记住，在实现第二个页面时，我们声明根中的每个组件都将是一个页面。因此，我们想要通过将它们放入一个2x2网格中来将这些按钮组合在一起。为了在同一行上组织组件，我们可以使用`HStack`。我们只需要一行上的两个，所以首先，我们将前两个按钮，即`VStacks`放入一个`HStack`中。这将导致三个页面，第一个是上一章中实现的页面，以及每个`HStack`的两个页面，这不是我们想要的。一个小改动就可以修复。你能猜到是什么吗？只需将两个`HStacks`放入一个单独的`VStack`中。这将使它们堆叠在一起，从而形成一个网格。这个代码如下：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s time to run our app:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行我们的应用程序了：
- en: '![Figure 9.20 – Button grid system](img/B18783_09_20.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图9.20 – 按钮网格系统](img/B18783_09_20.jpg)'
- en: Figure 9.20 – Button grid system
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 按钮网格系统
- en: 'You might be ready to finish this chapter and call it a day. Please bear with
    me – the top row of the grid is too close to the time for my liking. Let’s add
    top `VStack` we just implemented:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经准备好完成这一章，然后结束这一天。请耐心等待——网格的顶部对我来说太靠近时间了。让我们添加我们刚刚实现的顶部`VStack`：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is it, the final build and run of our application – drum roll, please!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它，我们应用程序的最终构建和运行——鼓掌，请！
- en: '![Figure 9.21 – Button grid system](img/B18783_09_21.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图9.21 – 按钮网格系统](img/B18783_09_21.jpg)'
- en: Figure 9.21 – Button grid system
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 – 按钮网格系统
- en: 'We are now at the end of our project, and our application looks amazing. Before
    we summarize, feel free to visit the GitHub repository to double-check your code
    base: [https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在到了项目的结尾，我们的应用程序看起来很棒。在我们总结之前，请随意访问GitHub仓库以双重检查你的代码库：[https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects](https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects)。
- en: In this section, we added the activity buttons. We did this by implementing
    another page in our fitness app. We leveraged a grid-based system for laying out
    our buttons. We used a variety of core components combined with stacks to organize
    them. In the following section, we will summarize this chapter, and ultimately
    this book. But first, we will look at some code to help you with the extra tasks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们添加了活动按钮。我们通过在我们的健身应用程序中实现另一个页面来做到这一点。我们利用基于网格的系统来布局我们的按钮。我们使用了各种核心组件与堆叠相结合来组织它们。在下一节中，我们将总结本章，最终总结这本书。但首先，我们将查看一些代码来帮助你完成额外任务。
- en: Different Exercises
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的练习
- en: 'To add different exercises to the fitness companion app, you can modify the
    `MainView` by introducing a new data structure to store exercise information and
    update the UI accordingly. Here’s an example of how you can make these changes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将不同的练习添加到健身伴侣应用程序中，你可以通过引入一个新的数据结构来存储练习信息并相应地更新UI来修改`MainView`。以下是如何进行这些更改的示例：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this modified code, we have introduced a new `Exercise` struct that stores
    the name and image name of each exercise. You can add more exercises to the `exercises`
    array by creating new `Exercise` instances.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的代码中，我们引入了一个新的`Exercise`结构体，用于存储每个练习的名称和图片名称。你可以通过创建新的`Exercise`实例来向`exercises`数组添加更多练习。
- en: In the view, we have used a `ForEach` loop to iterate over the exercises and
    display them dynamically. Each exercise is represented by a `VStack` containing
    an image and a text label. When an exercise is tapped, the activity state is updated
    with the selected exercise’s name.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们使用了`ForEach`循环来遍历练习并动态显示它们。每个练习由一个包含图片和文本标签的`VStack`表示。当点击一个练习时，活动状态会更新为所选练习的名称。
- en: You can customize the exercise images and add more properties to the `Exercise`
    struct based on your specific requirements.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据具体需求自定义练习图片，并向`Exercise`结构体添加更多属性。
- en: Active timer
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动计时器
- en: 'To add functionality for an active timer that can be started, stopped, and
    paused, you can modify the `MainView` by introducing additional state variables
    and actions. Here’s an example of how you can make these changes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个可以启动、停止和暂停的活动计时器的功能，您可以通过引入额外的状态变量和操作来修改`MainView`。以下是如何进行这些更改的示例：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this modified code, we have made the following changes:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的代码中，我们进行了以下更改：
- en: We introduced `isTimerRunning` and `isTimerPaused` state variables to track
    the timer’s state.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们引入了`isTimerRunning`和`isTimerPaused`状态变量来跟踪计时器的状态。
- en: We added `startTimer()`, `pauseTimer()`, and `stopTimer()` actions to handle
    starting, pausing, and stopping the timer, respectively.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了`startTimer()`、`pauseTimer()`和`stopTimer()`操作来分别处理启动、暂停和停止计时器。
- en: We modified the “Start/Pause” button to toggle between the `isTimerRunning`
    state.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们修改了“开始/暂停”按钮，使其在`isTimerRunning`状态之间切换。
- en: We updated the timer’s `onReceive` closure to only increment the counter and
    update the timer string when the timer is running and not paused.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更新了计时器的`onReceive`闭包，使其仅在计时器正在运行且未暂停时增加计数器并更新计时器字符串。
- en: We added functionality to reset the counter and timer string when the **End**
    button is pressed.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按下**结束**按钮时，我们添加了重置计数器和计时器字符串的功能。
- en: With these changes, you can now start, pause, and stop the timer in your fitness
    companion app.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，您现在可以在您的健身伴侣应用程序中启动、暂停和停止计时器。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we successfully added the activity button screen to our Fitness
    Companion application. We began by analyzing the wireframe and breaking down each
    element into SwiftUI components. From there, we implemented the components to
    match the design from the wireframes. Through this process, we gained a deeper
    understanding of how to combine core SwiftUI components using stacks to create
    complex buttons. We finally looked at a few implementations for the extra tasks
    as well.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地将活动按钮屏幕添加到我们的健身伴侣应用程序中。我们首先分析了线框图，并将每个元素分解为SwiftUI组件。从那里，我们实现了这些组件以匹配线框图中的设计。通过这个过程，我们更深入地理解了如何使用堆栈组合核心SwiftUI组件来创建复杂的按钮。我们最终还查看了一些额外任务的实现。
- en: 'I want to express my gratitude for taking the time to read this book. There
    were moments when I questioned the purpose of writing yet another programming
    book, but ultimately, it was a worthwhile endeavor. I sincerely hope that you
    were able to gain something from it. If you have any questions or would like to
    contact me directly, please feel free to use any of the platforms listed here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我想表达我对您花时间阅读这本书的感激之情。有时候我会质疑写另一本编程书的目的是什么，但最终，这是一项值得的努力。我真诚地希望您能从中获得一些东西。如果您有任何问题或想直接联系我，请随时使用以下列出的任何平台：
- en: 'Twitter: [https://twitter.com/SonarSystems](https://twitter.com/SonarSystems)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Twitter: [https://twitter.com/SonarSystems](https://twitter.com/SonarSystems)'
- en: 'Email: [support@sonarsystems.co.uk](mailto:support@sonarsystems.co.uk)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '邮箱: [support@sonarsystems.co.uk](mailto:support@sonarsystems.co.uk)'
- en: 'Discord: [https://discord.gg/7e78FxrgqH](https://discord.gg/7e78FxrgqH)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Discord: [https://discord.gg/7e78FxrgqH](https://discord.gg/7e78FxrgqH)'
- en: 'FireDEV Podcast: [https://open.spotify.com/show/387RiHksQE33KYHTitFXhg](https://open.spotify.com/show/387RiHksQE33KYHTitFXhg)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FireDEV播客: [https://open.spotify.com/show/387RiHksQE33KYHTitFXhg](https://open.spotify.com/show/387RiHksQE33KYHTitFXhg)'
