["```swift\nimport CoreData// 1\\. Create a persistent container\nlet container = NSPersistentContainer(name: \"MyDataModel\")\n// 2\\. Load the persistent store\ncontainer.loadPersistentStores { (storeDescription, error)\n    in\n    if let error = error {\n        fatalError(\"Failed to load persistent store: \\(error)\")\n    }\n}\n// 3\\. Create a managed object context\nlet context = container.viewContext\n```", "```swift\nlet newEmployee = Employee(context: context)newEmployee.name = \"John Doe\"\nnewEmployee.title = \"Software Engineer\"\nnewEmployee.startDate = Date()\ndo {\n    try context.save()\n} catch {\n    fatalError(\"Failed to save context: \\(error)\")\n}\n```", "```swift\nlet persistentContainer = NSPersistentContainer(name: \"MyApp\")persistentContainer.loadPersistentStores(completionHandler: { (storeDescription, error) in\n    if let error = error {\n        fatalError(\"Failed to load persistent store: \\(error)\")\n    }\n})\nlet writeContext = NSManagedObjectContext(concurrencyType:\n    .privateQueueConcurrencyType)\nwriteContext.persistentStoreCoordinator =\n    persistentContainer.persistentStoreCoordinator\nlet readContext = NSManagedObjectContext(concurrencyType:\n    .privateQueueConcurrencyType)\nreadContext.persistentStoreCoordinator =\n    persistentContainer.persistentStoreCoordinator\n```", "```swift\nlet parentContext = NSManagedObjectContext(concurrencyType:    .privateQueueConcurrencyType)\nparentContext.persistentStoreCoordinator =\n    persistentStoreCoordinator\nlet readContext1 = NSManagedObjectContext(concurrencyType:\n    .mainQueueConcurrencyType)\nreadContext1.parent = parentContext\nlet readContext2 = NSManagedObjectContext(concurrencyType:\n    .mainQueueConcurrencyType)\nreadContext2.parent = parentContext\n```", "```swift\nvar object: MyEntity?let fetchRequest: NSFetchRequest<MyEntity> = MyEntity.fetchRequest()\nfetchRequest.predicate = NSPredicate (format: \"id == %@\", someID)\ndo {\n    object = try mainContext.fetch(fetchRequest).first\n} catch {\n    print(\"Error fetching object: \\(error)\")\n}\nguard let objectID = object?.objectID else {\n    return\n}\nLet backgroundContext = NSManagedObjectContext\n    (concurrencyType: .privateQueueConcurrencyType)\nbackgroundContext.persistentStoreCoordinator =\n    persistentStoreCoordinator\nbackgroundContext.perform {\n    let backgroundObject = backgroundContext.object(with:objectID)\n}\n```", "```swift\nlet managedObjectModel = NSManagedObjectModel.mergedModel    (from: [Bundle.main])!\nlet persistentStoreCoordinator =NSPersistentStoreCoordinator\n    (managedObjectModel: managedObjectModel)\ndo {\n    try persistentStoreCoordinator.addPersistentStore(ofType: \n   NSInMemoryStoreType, configurationName: nil, at: nil, options: nil)\n} catch {\n    fatalError(\"Failed to create in-memory persistent store\n        coordinator: \\(error)\")\n}\n```", "```swift\nfunc testFetchPerformance() {    let context = persistentContainer.viewContext\n    let request = NSFetchRequest<MyEntity>(entityName: \"MyEntity\")\n    measure {\n        do {\n            for _ in 0..<200 {\n                let result = try context.fetch(request)\n            }\n            let result = try context.fetch(request)\n            XCTAssertEqual(result.count, 1000)\n        } catch {\n            XCTFail(\"Failed to fetch objects:\n                \\(error.localizedDescription)\")\n        }\n    }\n```", "```swift\nlet defaults = UserDefaults.standarddefaults.set(true, forKey: \"isUserLoggedIn\")\n```", "```swift\nlet defaults = UserDefaults.standardlet isUserLoggedIn = defaults.bool(forKey: \"isUserLoggedIn\")\n```", "```swift\nlet defaults = UserDefaults(suiteName: \"group.com.yourcompany.     yourapp\")!\ndefaults.set(true, forKey: \"myBoolValue\")\nlet myBoolValue = defaults.bool(forKey: \"myBoolValue\")\n```", "```swift\n    struct Person {    var name: String    var age: Int}let person = Person(name: \"John Smith\", age: 30)let data = try? NSKeyedArchiver.archivedData(withRoot    Object: person, requiringSecureCoding: false)UserDefaults.standard.set(data, forKey: \"person\")let storedData = UserDefaults.standard.data(forKey:\"person\")if let storedPerson = try? NSKeyedUnarchiver.unarchivedObject    (ofClass: Person.self, from:storedData!) {}\n    ```", "```swift\nstruct Person: Codable {    var name: String\n    var age: Int\n}\nlet person = Person(name: \"John Smith\", age: 30)\nlet encoder = JSONEncoder()\nif let encoded = try? encoder.encode(person) {\n    UserDefaults.standard.set(encoded, forKey: \"person\")\n    if let storedData = UserDefaults.standard.data\n        (forKey: \"person\") {\n        let decoder = JSONDecoder()\n        if let storedPerson = try? decoder.decode\n            (Person.self, from: storedData) {\n        }\n    }\n}\n```", "```swift\nimport UIKitimport Security\nclass KeychainManager {\n    private let serviceName = \"MyAppTokenService\"\n    func saveToken(token: String) -> Bool {\n        guard let tokenData = token.data(using: .utf8) else {\n            return false\n        }\n        let keychainItem = [\n            kSecClass: kSecClassGenericPassword,\n            kSecAttrService: serviceName,\n            kSecAttrAccount: \"MyAppToken\",\n            kSecValueData: tokenData\n        ] as CFDictionary\n        let status = SecItemAdd(keychainItem, nil)\n        return status == errSecSuccess\n    }\n}\n```", "```swift\n    func readToken() -> String? {        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrService as String: service,\n            kSecAttrAccount as String: account,\n            kSecReturnData as String: true,\n            kSecMatchLimit as String: kSecMatchLimitOne\n        ]\n        var result: AnyObject?\n        let status = SecItemCopyMatching(query as\n            CFDictionary, &result)\n        if status == errSecSuccess, let tokenData =\n            result as? Data, let token = String(data:\n                tokenData, encoding: .utf8) {\n            return token\n        } else {\n            return nil\n        }\n    }\n```", "```swift\n<key>com.example.myapp.shared-keychain</key><array>\n    <string>$(AppIdentifierPrefix)com.example.myapp</string>\n</array>\n```", "```swift\nfunc savePasswordToKeychain(password: String) -> Bool {    guard let data = password.data(using: .utf8) else {\n        return false\n    }\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccessGroup as String:\n            \"com.example.myapp.shared-keychain\",\n        kSecAttrAccount as String: \"myPassword\",\n        kSecValueData as String: data\n    ]\n    SecItemDelete(query as CFDictionary)\n    let status = SecItemAdd(query as CFDictionary, nil)\n    return status == errSecSuccess\n}\n```"]