- en: Chapter 6. Making Your App Orientation-aware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will walk you through the process of dealing with the Android
    application behavior on device configuration changes. In the course of this chapter,
    we will cover comprehensive details of the theoretical concepts, but we will not
    make any significant changes to the `POIApp`. The following topics will be covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Android behavior on configuration changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking the Android application orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the activity state for configuration changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding alternative resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually handling the orientation behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android behavior on configuration changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All modern smartphones and tablets switch between portrait and landscape modes
    in response to the way a user rotates the device. The Android application is expected
    to respond to the configuration changes and displays appropriate layouts for the
    current device configuration. The Android device configuration can be changed
    at runtime in many forms, such as device orientation changes, device language
    changes, device font updates, device connected to external displays, device connected
    to docks, and so on. In all of the earlier cases, Android restarts the running
    activity, loads alternative resources if available, to properly load your application
    for the given configurations. The activity goes through a series of life cycle
    methods, such as `OnDestroy()`, followed by `OnCreate()` to deal with the activity
    restart behavior.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you are running your application on Nexus 5 device with 1080
    x 1920 resolution in the portrait mode, and while the orientation changes to landscape,
    the application has to respond appropriately to fit the layout and its child views
    for the 1920 x 1080 dimension. You may ask why not just adjust the view in the
    layout to fit to the appropriate size? Why should the activity be restarted? Well,
    Android does this to keep things simple. However, internally, it does many things
    and provides some of the advance features to make the configuration changes smoother.
  prefs: []
  type: TYPE_NORMAL
- en: If the device configuration changes, Android destroys and restarts only the
    activity in the foreground, but the application instance still remains unchanged.
    When the activity restarts, the appropriate layout for that configuration is loaded.
    For such events, it is important that your application must restore the state
    of your activity and the user entered data on the UI. This can be possible using
    the `OnSaveInstanceState()` and `OnRestoreInstanceState()` callback methods.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter tackles some of the key points to build smooth, responsive, and
    orientation aware applications.
  prefs: []
  type: TYPE_NORMAL
- en: Locking the Android application orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Google design guidelines, the Android application must respond
    to the device orientation and display an appropriate layout for the given orientation.
    However, some kind of applications, such as games, video players, and so on, are
    intended to restrict the orientation to landscape or portrait only. For native
    Android applications, this can be achieved using the `android:screenOrientation`
    property to the `&lt;activity&gt;` declaration in the `AndroidManifest.xml` descriptor
    file. Xamarin makes this even simplified and recommends that you do not to edit
    the `AndroidManifest.xml` file manually at any point of time, instead it allows
    you to set all the application configuration metadata using `[Activity]` attribute
    custom properties to the activity declaration.
  prefs: []
  type: TYPE_NORMAL
- en: As we recall from Chapter 3, *Creating the Points Of Interest App*, we are already
    using some of the properties of the `[Activity]` attribute, such as `Label`, `MainLauncher`,
    and `Icon`. Now to lock the activity orientation behavior, we can use the **ScreenOrientation**
    property on the activity class declaration. The `ScreenOrientation` property needs
    to be specified statically to each activity that requires control over the orientation
    lock. It cannot be controlled globally for the whole application scope.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScreenOrientation` attribute expects any one of the possible constants
    defined in the `Android.Content.PM.ScreenOrientation` enumeration. The `ScreenOrientation`
    enum defines all the set of device configuration constants such as `FullSensor`,
    `FullUser`, `Landscape`, `Locked`, `Nosensor`, `Portrait`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For the complete set of `ScreenOrientation` constants, visit the official Xamarin.Android
    documentation at [http://developer.xamarin.com/api/type/Android.Content.PM.ScreenOrientation/](http://developer.xamarin.com/api/type/Android.Content.PM.ScreenOrientation/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in this book, we will build the `POIApp` to respond to the device
    orientation and other different configuration''s change events. The following
    code block is used for demonstration purpose only and will not be continued along
    with the `POIApp` example code. You can add the following attributes to lock the
    `POIListActivity` orientation to landscape only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make the preceding changes to `POIListActivity` and run the app. You will notice
    that the POI list screen overrides the device orientation lock settings and it
    will always be shown in the landscape mode.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically requesting the orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also change the desired activity orientation dynamically by setting
    the `RequestedOrientation` property to your activity. This allows further flexibility
    to dynamically change the orientation anytime as required. Add the following code
    snippet anywhere in your activity to restrict the currently running activity orientation
    to landscape only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The changes made to the `RequestedOrientation` property has an impact on the
    activity in the foreground and a request for the specified orientation is made
    immediately by causing the current activity to restart. You can use the same property
    to obtain the current configuration that is in effect for the current activity.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the activity state for configuration changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Runtime configuration changes in the Android device cause the activity in the
    foreground to go through a restart process. This behavior is intended to simplify
    the process for the activity to reinitialize with alternative resources for the
    given configuration. As the activity goes through the recreation process, you
    might lose the user entered data or the current state of the activity. For any
    such course of events, all the Android applications must retain the activity state
    quickly and cheaply to avoid undesirable user experience. The following section
    will help you dive deeper to understand the process to retain the activity state.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the configuration changes, the activity goes through a series of life
    cycle methods, such as `OnDestroy()` followed by `OnCreate()`. On its way, it
    calls `OnSaveInstanceState()` before it destroys the activity so that you can
    save the activity state data. The application state can be retained during the
    `onCreate()` or `OnRestoreInstanceState()` callback methods. To understand the
    whole process, we must recall the activity life cycle methods as described in
    Chapter 1, *The Anatomy of an Android App*. The following figure depicts the activity
    life cycle and the `OnSaveInstanceState` and `OnRestoreInstanceState ()` method''s
    call flow with their respective configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/zHkF0fQQ.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A change in the orientation calls the `OnPause()`, `OnSaveInstanceState()`,
    `OnStop()`, and `OnDestroy()` methods followed by `OnCreate()`, `OnStart()`, `OnRestoreInstanceState()`,
    and `OnResume()`. Remember that this sequence is not always true. For example,
    when a user presses the device back button or calls the `Finish()` method, you
    do not need to save the activity state; hence, it just calls `OnPause()`, `OnStop()`,
    and `OnDestroy()`, but the `OnSaveInstanceState()` method is never called.
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of `OnSaveInstanceState()` and `OnRestoreInstanceState()`
    takes care of saving and retaining the data on all the Android view input widgets
    (for example, `EditText`, `CheckBox`, `RadioButton`, and so on) that are attached
    to the layout with an `id` property. This means that the Android SDK implements
    the `OnSaveInstanceState()` and the `OnRestoreInstanceState()` methods on each
    of the view controls.
  prefs: []
  type: TYPE_NORMAL
- en: Based on two factors, Android decides whether the state of a view attached to
    a view group will be retained in the orientation change. One factor is the `id`
    property and the other is based on the value set for the `view.SaveEnabled` property.
    The `SaveEnabled` property checks whether the `onSaveInstanceState()` method will
    be called on that view. The default value for `SaveEnabled` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the `SaveEnabled` property, Android provides yet another interesting
    method that allows you to control the save state behavior for the entire hierarchy
    under a view. For example, if you have five different views under a `LinearLayout`,
    and you wish not to save state for all those five views, including `LinearLayout`,
    you can just achieve this by setting the `SaveFromParentEnabled` property of `LinearLayout`
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: For applications using custom or compound views, you must handle the state restoration
    manually. You need to override the `OnSaveInstanceState()` and `OnRestoreInstanceState()`
    methods in your custom view implementation to store the state of your view.
  prefs: []
  type: TYPE_NORMAL
- en: Manually saving the activity state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to manually save the activity state, you must override the following
    methods in your activity and write your own logic to save and restore the activity
    state in data bundles. The `OnSaveInstanceState()` method supplies an instance
    of `Bundle` in which we can dump the data, and the `OnRestoreInstanceState()`
    method returns the previously saved `Bundle`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Bundle` is a special kind of container that provides the key/value maps of
    heterogeneous values. `Bundle` is generally used for parsing data from one activity
    to another or while saving and retrieving the view state. The `Bundle` class provides
    a set of overloaded `PutXXX()` and `GetXXX()` methods to store and retrieve the
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet depicts the `OnSaveInstanceState()` and `OnRestoreInstanceState()`
    methods'' prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Retaining the POI list scroll position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we had quite a lot of ground on the activity life cycle behavior on
    configuration changes. Let's now implement it to `POIApp`. When the POI list grows,
    it allows the user to scroll vertically to see all of the list items. Let's say,
    the user has scrolled till the 10th element in the list, and in the meantime,
    the device orientation changed. Due to the device configuration change request,
    the activity restarted and causes the list to appear from the top. It is a good
    idea to retain the list scroll position for better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to retain the POI list scroll position when
    the device configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the index of the first visible list item and save it in `Bundle` in the
    `OnSaveInstanceState()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, the string `scroll_position` is used as the key
    to save the current scroll position of `ListView` on orientation change. The same
    key should be used while retrieving the data from the `OnRestoreInstanceState()`
    callback.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restore the saved list scrolling position in `OnRestoreInstanceState()`. Note
    that we have to use the same key that was used to save the current scroll position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet to the `DownloadPoisListAsync()` method in the
    `POIListActivity` class and queue the message for scrolling the POI list to the
    last saved scroll position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now run the application and test the POI application by changing the orientation;
    notice that the scroll positions are retained.
  prefs: []
  type: TYPE_NORMAL
- en: Building the orientation-aware layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android allows you to add multiple competing versions of resources to make an
    application compatible with different device configurations. The Android system
    comes handy when it comes to picking up the right resources for a given configuration.
    You don't need to write any code to find what is the current configuration and
    choose the appropriate resources. All you need to do is to add multiple versions
    of resources, such as `string.xml`, `.png` drawable images, or layout XML files,
    so that the best version of resource can be picked up under different circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that your app was primarily targeted to the U.S. market, but now we
    are looking forward to targeting Russia with the Russian language support. In
    this case, multiple versions of `string.xml` can be added to support the Russian
    language. Or imagine that a user is running the app on a tablet in the portrait
    mode, and now the device rotates to the landscape orientation. The screen width
    gets doubled and provides the opportunity to display more information. In such
    cases, you will need to add multiple versions of activity layouts for different
    orientations. Let's hold our breath till the next chapter to learn more about
    how to build the orientation aware layout for Android tablets.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the resources added to the application will be added to various subdirectories
    under the `Resources` directory. The default resource directory structure is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/YRuxqZab.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any resource that is added as a default resource will be used when there are
    no alternative best match resources available for the given configuration. Alternative
    resources are designed for a specific configuration.
  prefs: []
  type: TYPE_NORMAL
- en: To add alternative resources, you just need to use the specific configuration
    qualifier. The configuration qualifiers you can use for device screen sizes are
    small, normal, large, and xlarge. For example, layouts for an extra-large screen,
    such as a tablet layout, should go in the **layout-xlarge** directory. Since Android
    3.2, Android recommends that you use the `sw&lt;N&gt;dp` configuration qualifier
    to define an extra-large layout for the tablet. For example, if your multipane
    tablet layout requires at least 600dp of screen width, you should place it in
    the layout-`sw600dp` directory.
  prefs: []
  type: TYPE_NORMAL
- en: To provide the translated version of the `strings.xml` file for Russian users,
    you have to place the `string.xml` file in the `Resources/values-ru/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table depicts the list of configuration qualifiers that allow
    you to provide special resources for different screen configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Characteristic
  prefs: []
  type: TYPE_NORMAL
- en: Qualifier
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: Screen size
  prefs: []
  type: TYPE_NORMAL
- en: small, normal, large, and xlarge
  prefs: []
  type: TYPE_NORMAL
- en: Resources for small, normal, large, and extra-large screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: l dpi
  prefs: []
  type: TYPE_NORMAL
- en: Resources for low-density (l dpi) screens (~120 dpi). You can now ignore this
    resource set, as no new Android devices with ldpi density are out in the market.
  prefs: []
  type: TYPE_NORMAL
- en: mdpi
  prefs: []
  type: TYPE_NORMAL
- en: Resources for medium-density (mdpi) screens (~160 dpi). (This is the baseline
    density.)
  prefs: []
  type: TYPE_NORMAL
- en: hdpi
  prefs: []
  type: TYPE_NORMAL
- en: Resources for high-density (hdpi) screens (~240 dpi).
  prefs: []
  type: TYPE_NORMAL
- en: xhdpi
  prefs: []
  type: TYPE_NORMAL
- en: Resources for extra-high-density (xhdpi) screens (~320 dpi).
  prefs: []
  type: TYPE_NORMAL
- en: xxhdpi
  prefs: []
  type: TYPE_NORMAL
- en: Resources for extra-extra-high-density (xxhdpi) screens (~480 dpi).
  prefs: []
  type: TYPE_NORMAL
- en: xxxhdpi
  prefs: []
  type: TYPE_NORMAL
- en: Resources for extra-extra-extra-high-density (xxxhdpi) use (~640 dpi). Use this
    for the launcher icon only; see the earlier note.
  prefs: []
  type: TYPE_NORMAL
- en: nodpi
  prefs: []
  type: TYPE_NORMAL
- en: Resources for all densities. These are density-independent resources. The system
    does not scale resources tagged with this qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: Device orientation
  prefs: []
  type: TYPE_NORMAL
- en: land
  prefs: []
  type: TYPE_NORMAL
- en: Resources for screens in the landscape orientation.
  prefs: []
  type: TYPE_NORMAL
- en: port
  prefs: []
  type: TYPE_NORMAL
- en: Resources for screens in the portrait orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect ratio
  prefs: []
  type: TYPE_NORMAL
- en: long
  prefs: []
  type: TYPE_NORMAL
- en: Resources for screens that have a significantly taller or wider aspect ratio
    (when in the portrait or landscape orientation, respectively) than the baseline
    screen configuration.
  prefs: []
  type: TYPE_NORMAL
- en: notlong
  prefs: []
  type: TYPE_NORMAL
- en: Resources for use screens that have an aspect ratio that is similar to the baseline
    screen configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the following Chapter 7, *Designing for Multiple Screen Sizes*, we will make
    use of the alternative layout resource to make the application compatible for
    Android tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Manually handling the orientation behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described, the Android system automatically takes care of updating appropriate
    resources when the configuration changes. However, at times due to performance
    reasons, you might like to restrict the activity restart and write your own logic
    to update appropriate resources for the given configuration. But remember that
    this is not recommended by the Google guidelines; if you're implementing this
    for your application, do it at your own risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will guide you to manually handle the required configuration
    for your app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ConfigurationChanges` attribute to the activity declaration. This
    allows you to declare all possible configurations values defined in `Android.Content.PM.ConfigChanges`
    that you want to handle yourself for your app. At runtime, this adds the `android:configChanges`
    attribute to your activity declaration in the `AndroidManifest.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code syntax, we stated that we will be manually handling the
    configuration for the device orientation and sliding keyboard state changes. Note
    that the preceding declaration bypasses the whole activity destruction process
    and simply returns a callback to let you know about the changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Override `OnConfigurationChanged()` in your activity. This method will be called
    when one of the configuration changes, as listed in the `ConfigurationChanges`
    attribute declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, in the `OnConfigurationChanged()` method, you need to update the UI so
    that it reflects the orientation change. For our `POIApp`, we allow the system
    to handle the configuration itself. Note that the all the code snippets used in
    this chapter are for demonstration purpose only, and we will not continue with
    these changes to build `POIApp` for rest of the chapters in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground on the behavior of an activity when
    the device configuration is changed, forcing the activity to display a specified
    orientation and to save and restore the activity state. The next chapter will
    guide you to deal with designing applications for various device form factors
    such as Android tablets.
  prefs: []
  type: TYPE_NORMAL
