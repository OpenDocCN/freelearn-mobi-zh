- en: A Short Introduction to Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程简述
- en: The term **reactive** got famous recently. Not only did it get trending, but
    it has started ruling the software development sector with new blog posts articles
    every day, and presentations, emerging frameworks and libraries, and more. Even
    the big IT companies that are often referred to as market giants, such as Google,
    Facebook, Amazon, Microsoft, and Netflix, are not only supporting and using reactive
    programming themselves, but they've even started releasing new frameworks for
    the same.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式** 这个术语最近变得非常流行。它不仅成为趋势，而且每天都有新的博客文章、演讲、新兴的框架和库出现，开始统治软件开发领域。甚至那些经常被称为市场巨头的知名
    IT 公司，如 Google、Facebook、Amazon、Microsoft 和 Netflix，不仅支持和使用响应式编程，甚至开始发布针对同一目的的新框架。'
- en: So, as a programmer, we are wondering about reactive programming. Why is everyone
    getting crazy about it? What does *reactive programming* exactly mean? What are
    the benefits of reactive programming? And, finally, should we learn it? If yes,
    then how?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个程序员，我们在思考响应式编程。为什么每个人都对它如此疯狂？响应式编程究竟是什么意思？响应式编程有哪些好处？最后，我们应该学习它吗？如果是的话，那么应该如何学习？
- en: On the other hand, **Kotlin** is also the newest programming language you've
    heard of (we're guessing you've heard of Kotlin, as this book assumes that you've
    a little understanding of the language). Kotlin, as a language, solves many important
    problems in Java. The best part is its interoperability with Java. If you carefully
    watch the trends, then you would know that Kotlin has created not a strong wind
    but a storm to blow things around it. Even the Google at *Google IO/17* declared
    its official support for Kotlin as an official programming language for Android
    application development, noting that it is the first time since the perception
    of the Android Framework that Google has added another language to the Android
    family other than Java. Soon after, Spring also expressed their support for Kotlin.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**Kotlin** 也是你最近听说的新编程语言（我们猜测你已经听说过 Kotlin，因为这本书假设你对这种语言有一定的了解）。作为一门语言，Kotlin
    解决了 Java 中许多重要的问题。最好的部分是它与 Java 的互操作性。如果你仔细观察趋势，你就会知道 Kotlin 不仅创造了一股强大的风，还引发了一场风暴，影响了周围的一切。甚至
    Google 在 *Google IO/17* 上也宣布了对 Kotlin 的官方支持，将其作为 Android 应用开发的官方编程语言，并指出这是自 Android
    框架出现以来，Google 首次向 Android 家族添加了除 Java 之外的语言。不久之后，Spring 也表达了他们对 Kotlin 的支持。
- en: To say it in simple words, Kotlin is powerful enough to create a great application,
    but if you combine reactive programming style with Kotlin, it would be super easy
    to build great apps better.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话来说，Kotlin 已经足够强大，可以创建出色的应用程序，但如果你将响应式编程风格与 Kotlin 结合起来，构建出色的应用程序将会变得超级简单。
- en: This book will present reactive programming in Kotlin with RxKotlin and Reactor,
    along with their implementations in Spring, Hibernate, and Android.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用 RxKotlin 和 Reactor 在 Kotlin 中介绍响应式编程，并展示它们在 Spring、Hibernate 和 Android
    中的实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is reactive programming?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是响应式编程？
- en: Reasons to adapt functional reactive programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用函数式响应式编程的原因
- en: Reactive Manifesto
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式宣言
- en: Comparison between the `observer` (reactive) pattern and familiar patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observer`（响应式）模式与熟悉模式的比较'
- en: Getting started with RxKotlin
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 RxKotlin
- en: What is reactive programming?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是响应式编程？
- en: Reactive programming is an asynchronous programming paradigm that revolves around
    data streams and the propagation of change. In simpler words, those programs which
    propagate all the changes that affected its data/data streams to all the interested
    parties (such as end users, components and sub-parts, and other programs that
    are somehow related) are called **reactive programs**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是一种围绕数据流和变化传播的异步编程范式。用更简单的话来说，那些将影响其数据/数据流的所有变化传播给所有相关方（如最终用户、组件和子组件，以及其他以某种方式相关的程序）的程序被称为
    **响应式程序**。
- en: For example, take any spreadsheet (say the Google Sheet), put any number in
    the A1 cell, and in the B1 cell, write the `=ISEVEN(A1)` function; it'll show
    `TRUE` or  `FALSE`, depending on whether you've entered an even or odd number.
    Now, if you modify the number in A1, the value of B1 will also get changed automatically;
    such behavior is called **reactive**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，拿任何电子表格（比如说 Google Sheet），在 A1 单元格中输入任何数字，在 B1 单元格中写入 `=ISEVEN(A1)` 函数；它会显示
    `TRUE` 或 `FALSE`，取决于你输入的是偶数还是奇数。现在，如果你修改 A1 中的数字，B1 的值也会自动改变；这种行为被称为 **响应式**。
- en: 'Not clear enough? Let''s look at a coding example and then try to understand
    it again. The following is a normal Kotlin code block to determine if a number
    is even or odd:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还不够清楚？让我们看看一个编码示例，然后再尝试再次理解它。以下是一个用于确定数字是偶数还是奇数的正常Kotlin代码块：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you check the output of the program, then you'll see that, although the number
    is assigned a new value, `isEven` is still true; however, if `isEven` was made
    to track changes of the number, then it would automatically become false. A reactive
    program would just do the same.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查程序的输出，那么你会看到，尽管数字被分配了新的值，`isEven`仍然是true；然而，如果`isEven`被用来跟踪数字的变化，那么它将自动变为false。响应式程序会做同样的事情。
- en: Reasons to adapt functional reactive programming
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用函数式响应式编程的原因
- en: 'So, let''s first discuss the reasons to adapt functional reactive programming.
    There''s no point in changing the whole way you code unless it gets you some really
    significant benefits, right? Yes, functional reactive programming gets you a set
    of mind-blowing benefits, as listed here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们首先讨论采用函数式响应式编程的原因。除非它带来一些真正显著的好处，否则改变你整个编码方式是没有意义的，对吧？是的，函数式响应式编程为你带来了一系列令人震惊的好处，如下所示：
- en: '**Get rid of the callback hell**:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摆脱回调地狱**：'
- en: A callback is a method that gets called when a predefined event occurs. The
    mechanism of passing interfaces with callback methods is called **callback mechanism**.
    This mechanism involves a hell of a lot of code, including the interfaces, their
    implementations, and more. Hence, it is referred to as **callback hell**.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回调是在预定义事件发生时被调用的方法。传递带有回调方法接口的机制称为**回调机制**。这种机制涉及大量的代码，包括接口、它们的实现等等。因此，它被称为**回调地狱**。
- en: '**Standard mechanism for error handling**:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准错误处理机制**：'
- en: Generally, while working with complex tasks and HTTP calls, handling errors
    are a major concern, especially in the absence of any standard mechanism, it becomes
    a headache.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，在处理复杂任务和HTTP调用时，错误处理是一个主要关注点，尤其是在没有标准机制的情况下，这会变成一个头疼的问题。
- en: '**It''s a lot simpler than regular threading**:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比常规多线程简单得多**：'
- en: Though Kotlin makes it easier to work with threading as compared to Java, it's
    still complicated enough. Reactive programming helps to make it easier.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然与Java相比，Kotlin使线程处理变得更加容易，但它仍然足够复杂。响应式编程有助于使其更容易。
- en: '**Straightforward way for async operations**:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步操作的直接方法**：'
- en: Threading and asynchronous operations are interrelated. As threading got easier,
    so did the async operations.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 线程和异步操作是相互关联的。随着线程变得更容易，异步操作也是如此。
- en: '**One for everything**, **the same API for every operation****s**:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一应俱全**，**每个操作都使用相同的API**：'
- en: Reactive programming, especially RxKotlin, offers you a simple and straightforward
    API. You can use it for anything and everything, be it network call, database
    access, computation, or UI operations.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应式编程，尤其是RxKotlin，为你提供了一个简单直接的API。你可以用它做任何事情，无论是网络调用、数据库访问、计算还是UI操作。
- en: '**The functional way**:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式方法**：'
- en: Reactive programming leads you to write readable declarative code as, here,
    things are more functional.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应式编程引导你编写可读的声明式代码，因为在这里，事情更加函数化。
- en: '**Maintainable and testable code**:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护和可测试的代码**：'
- en: The most important point-by following reactive programming properly, your program
    becomes more maintainable and testable.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最重要的要点——通过正确地遵循响应式编程，你的程序将变得更加易于维护和测试。
- en: Reactive Manifesto
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式宣言
- en: So, what is the Reactive Manifesto? The Reactive Manifesto ([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))
    is a document defining the four reactive principles. You can think of it as the
    map to the treasure of reactive programming, or like the bible for the programmers
    of the reactive programming religion.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是响应式宣言？响应式宣言([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))是一份定义四个响应式原则的文档。你可以将其视为响应式编程宝藏的地图，或者像响应式编程宗教的圣经一样。
- en: Everyone starting with reactive programming should have a read of the manifesto
    to understand what reactive programming is all about and what its principles are.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开始学习响应式编程的人都应该阅读这份宣言，以了解响应式编程的实质及其原则。
- en: 'So, the following is the gist of four principles that Reactive Manifesto defines:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下就是响应式宣言定义的四个原则的精髓：
- en: '**Responsive**:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：'
- en: The system responds in a timely manner. Responsive systems focus on providing
    rapid and consistent response times, so they deliver a consistent quality of service.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 系统能够及时响应。响应式系统专注于提供快速和一致的反应时间，因此它们提供一致的服务质量。
- en: '**Resilient**:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：'
- en: In case the system faces any failure, it stays responsive. Resilience is achieved
    by replication, containment, isolation, and delegation. Failures are contained
    within each component, isolating components from each other, so when failure has
    occurred in a component, it will not affect the other components or the system
    as a whole.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果系统遇到任何故障，它仍然保持响应。通过复制、遏制、隔离和委派实现弹性。故障被限制在每个组件内部，隔离组件彼此之间，因此当某个组件发生故障时，它不会影响其他组件或整个系统。
- en: '**Elastic**:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：'
- en: Reactive systems can react to changes and stay responsive under varying workload.
    They achieve elasticity in a cost effective way on commodity hardware and software
    platforms.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反应式系统可以响应变化，并在不同的工作负载下保持响应性。它们在商品硬件和软件平台上以成本效益的方式实现弹性。
- en: '**Message driven**:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：'
- en: In order to establish the resilient principle, reactive systems need to establish
    a boundary between components by relying on asynchronous message passing.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了建立弹性原则，反应式系统需要通过依赖异步消息传递在组件之间建立边界。
- en: By implementing all four preceding principles, the system becomes reliable and
    responsive thus, reactive.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施前四个原则，系统变得可靠和响应，因此是反应式的。
- en: Reactive Streams standard specifications
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流标准规范
- en: Along with the Reactive Manifesto, we also have a standard specification on
    Reactive Streams. Everything in the reactive world is accomplished with the help
    of Reactive Streams. In 2013, Netflix, Pivotal, and Lightbend (previously known
    as Typesafe) felt a need for a standards specification for Reactive Streams as
    the reactive programming was beginning to spread and more frameworks for reactive
    programming were starting to emerge, so they started the initiative that resulted
    in Reactive Streams standard specification, which is now getting implemented across
    various frameworks and platforms.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反应式宣言之外，我们还有关于反应式流的标准化规范。在反应式世界的每一件事都是通过反应式流完成的。2013年，Netflix、Pivotal和Lightbend（之前称为Typesafe）感觉到需要为反应式流制定标准规范，因为反应式编程开始传播，更多的反应式编程框架开始出现，因此他们启动了导致反应式流标准规范倡议的工作，现在它正在各种框架和平台上得到实施。
- en: You can take a look at the Reactive Streams standard specification at—[http://www.reactive-streams.org/](http://www.reactive-streams.org/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看反应式流标准规范——[http://www.reactive-streams.org/](http://www.reactive-streams.org/)。
- en: Reactive Frameworks for Kotlin
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin的反应式框架
- en: 'To write Reactive programs, we need a library or a specific programming language;
    we can''t refer to Kotlin as a reactive language (basically, I don''t know any
    such language that is reactive by itself) as it is a powerful and flexible programming
    language for modern multiplatform applications, fully interoperable with Java
    and Android. However, there are reactive libraries out there to help us with these.
    So, let''s take a look at the available list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写反应式程序，我们需要一个库或特定的编程语言；我们不能将Kotlin称为反应式语言（基本上，我不知道有任何这样的语言是本身反应式的），因为它是一种强大的灵活的编程语言，适用于现代多平台应用程序，完全与Java和Android互操作。然而，有一些反应式库可以帮助我们实现这些。因此，让我们看看可用的列表：
- en: RxKotlin
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxKotlin
- en: Reactor-Kotlin
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reactor-Kotlin
- en: Redux-Kotlin
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux-Kotlin
- en: FunKTionale
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FunKTionale
- en: RxJava and other Reactive Java Frameworks can also be used with Kotlin (as Kotlin
    is 100% interoperable with Java-bidirectional)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava和其他反应式Java框架也可以与Kotlin一起使用（因为Kotlin与Java完全互操作）
- en: In this book, we will focus on RxJava and Reactor-kotlin (in the later chapters,
    on Spring).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将重点关注RxJava和Reactor-kotlin（在后面的章节中，关于Spring）。
- en: Getting started with RxKotlin
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用RxKotlin
- en: RxKotlin is a specific implementation of reactive programming for Kotlin, which
    is influenced by functional programming. It favors function composition, avoidance
    of global state, and side effects. It relies on the `observer` pattern of producer/consumer,
    with a lot of operators that allow composing, scheduling, throttling, transforming,
    error handling, and lifecycle management.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: RxKotlin是针对Kotlin的反应式编程的具体实现，它受到函数式编程的影响。它倾向于函数组合、避免全局状态和副作用。它依赖于生产者/消费者模式的`observer`模式，有许多操作符允许组合、调度、节流、转换、错误处理和生命周期管理。
- en: Whereas Reactor-Kotlin is also based on functional programming, and it is widely
    accepted and backed by the Spring Framework.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 而 Reactor-Kotlin 也基于函数式编程，并且得到了 Spring 框架的广泛认可和支持。
- en: Downloading and setting up RxKotlin
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和设置 RxKotlin
- en: 'You can download and build RxKotlin from GitHub ([https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin)).
    I do not require any other dependencies. The documentation on the GitHub wiki
    page is well structured. Here''s how you can check out the project from GitHub
    and run the build:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 下载和构建 RxKotlin ([https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin))。我不需要任何其他依赖项。GitHub
    wiki 页面上的文档结构良好。以下是您如何从 GitHub 检出项目并运行构建的说明：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also use Maven and Gradle, as instructed on the page.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以按照页面上的说明使用 Maven 和 Gradle。
- en: 'For Gradle, use the following compile dependency:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Gradle，使用以下编译依赖项：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For Maven, use this dependency:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Maven，使用以下依赖项：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This book targets RxKotlin 2.x, so remember to use `io.reactive.rxjava2` instead
    of `io.reactivex.rxkotlin`, as the latter one is for RxKotlin 1.x.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本书针对 RxKotlin 2.x，所以请记住使用`io.reactive.rxjava2`而不是`io.reactivex.rxkotlin`，因为后者是针对
    RxKotlin 1.x 的。
- en: Note that we are using RxKotlin version 2.1.0 for this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这本书中使用的是 RxKotlin 版本 2.1.0。
- en: Now, let's take a look at what RxKotlin is all about. We will begin with something
    well-known and, gradually, we will get into the secrets of the library.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 RxKotlin 是什么。我们将从一个众所周知的东西开始，然后逐渐深入了解库的秘密。
- en: Comparing the pull mechanism with the RxJava push mechanism
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较拉取机制与 RxJava 推送机制
- en: RxKotlin revolves around the observable type that represents a system of data/events
    intended for push mechanism (instead of the pull mechanism of the `iterator` pattern
    of traditional programs), thus it is lazy and can be used synchronously and asynchronously.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: RxKotlin 围绕表示用于推送机制（而不是传统程序中`iterator`模式的拉取机制）的数据/事件系统的可观察类型，因此它是懒加载的，可以同步和异步使用。
- en: 'It will be easier for us to understand if we start with a simple example that
    works with a list of data. So, here is the code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从与数据列表一起工作的简单示例开始，我们会更容易理解。所以，这里是代码：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot is the output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是输出结果：
- en: '![](img/d1c8d575-2c41-4e63-9ab0-da8b5d83f1a3.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1c8d575-2c41-4e63-9ab0-da8b5d83f1a3.jpg)'
- en: So, let's go through the program line by line to understand how it works.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们逐行分析程序，了解它是如何工作的。
- en: At comment `1`, we're creating a list of seven items (the list contains data
    of mixed data types with the help of any class). On comment `2`, we are creating
    `iterator` from the list, so that we can iterate over the data. In comment `3`,
    we have created a `while` loop to pull data from the list with the help of `iterator`,
    and then, in `4`, we're printing it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`1`中，我们创建了一个包含七个项目的列表（列表通过任何类帮助包含混合数据类型的数据）。在注释`2`中，我们是从列表中创建`iterator`，这样我们就可以遍历数据。在注释`3`中，我们创建了一个`while`循环，通过`iterator`从列表中提取数据，然后在注释`4`中打印它。
- en: The thing to notice is that we're pulling data from the list while the current
    thread is blocked until the data is received and ready. For example, think of
    getting that data from a network call/database query instead of just `List` and,
    in that case, how long the thread will be blocked. You can obviously create a
    separate thread for those operations, but then also, it will increase complexity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们在当前线程阻塞直到收到数据并准备就绪的同时，从列表中提取数据。例如，想象一下从网络调用/数据库查询中获取数据，而不是仅仅从`List`中获取，在这种情况下，线程将被阻塞多长时间。显然，你可以为这些操作创建一个单独的线程，但这样也会增加复杂性。
- en: Just give a thought; which one is a better approach? Making the program wait
    for data or pushing data to the program whenever it's available?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅思考一下；哪种方法更好？让程序等待数据，还是当数据可用时将数据推送到程序？
- en: The building blocks of the ReactiveX Framework (be it RxKotlin or RxJava) are
    the observables. The `observable` class is just the opposite of `iterator` interface.
    It has an underlying collection or computation that produces values that can be
    consumed by a consumer. However, the difference is that the consumer doesn't *pull*
    these values from the producer, like in the `iterator` pattern; instead, the producer
    *pushes* the values as notifications to the consumer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveX 框架（无论是 RxKotlin 还是 RxJava）的构建块是可观察的。`observable`类与`iterator`接口正好相反。它有一个底层集合或计算，产生可以被消费者消费的值。然而，区别在于消费者不像在`iterator`模式中那样从生产者*拉取*这些值；相反，生产者将值作为通知*推送*给消费者。
- en: 'So, let''s take the same example again, this time with `observable`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们再次以相同的例子为例，这次使用`observable`：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This program output is the same as the previous one—it prints all the items
    in the list. The difference is in the approach. So, let''s see how it actually
    works:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序输出与上一个相同——它打印出列表中的所有项。不同之处在于方法。那么，让我们看看它实际上是如何工作的：
- en: Create a list (just the same as the previous one).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个列表（与上一个相同）。
- en: An `observable` instance is created with that list.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该列表创建了一个`observable`实例。
- en: We're subscribing to the `observer` instance (we're using named arguments for
    `lambda` and covering it in detail later).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在订阅`observer`实例（我们使用命名参数为`lambda`，稍后详细说明）。
- en: As we subscribe to `observable`, each data will be pushed to `onNext`, and,
    as it gets ready, it will call `onComplete` when all data is pushed and `onError`
    if any error occurs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅`observable`时，每个数据都会被推送到`onNext`，当所有数据都推送完毕时，它将调用`onComplete`，如果发生任何错误，则调用`onError`。
- en: So, you learned to use the `observable` instances, and they are quite similar
    to the `iterator` instances, which is something we're very familiar with. We can
    use these `observable` instances to build asynchronous streams and push data updates
    to their subscribers (even to multiple subscribers).This was a simple implementation
    of the reactive programming paradigm. The data is being propagated to all the
    interested parties—the subscribers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你学会了如何使用`observable`实例，它们与非常熟悉的`iterator`实例非常相似。我们可以使用这些`observable`实例来构建异步流并将数据更新推送到它们的订阅者（甚至是多个订阅者）。这是一个简单的响应式编程范式实现。数据正在传播到所有感兴趣的各方——订阅者。
- en: The ReactiveEvenOdd program
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactiveEvenOdd程序
- en: 'So, now that we are somewhat familiar with `observables`, let''s modify the
    even-odd program in a reactive way. Here is the code for doing so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们多少熟悉了`observables`，让我们以响应式的方式修改偶数奇数程序。以下是实现这一点的代码：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/60dc06c0-1b42-4e9d-abf1-a7758439f918.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60dc06c0-1b42-4e9d-abf1-a7758439f918.jpg)'
- en: In this program, we have used `subject` and `map`, which we will cover in the
    later chapters. Here, it is just to show how easy it is in reactive programming
    to notify the changes. If you look at the program closely, then you'll also find
    that the code is modular and functional. When we notify `subject` with a number,
    it calls the method in `map`, then it calls the method in `subscribe` with the
    return value of the `map` method. The `map` method checks if the number is even
    and returns true or false accordingly; in the `subscribe` method, we are receiving
    that value and printing even or odd accordingly. The `subject.onNext` method is
    the way through which we message the new value to the subject, so it can process
    it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用了`subject`和`map`，我们将在后面的章节中介绍。在这里，它只是展示了在响应式编程中通知变化是多么容易。如果你仔细查看程序，你也会发现代码是模块化和函数式的。当我们用数字通知`subject`时，它调用`map`中的方法，然后调用`subscribe`方法中的方法，该方法是`map`方法的返回值。`map`方法检查数字是否为偶数，并相应地返回true或false；在`subscribe`方法中，我们接收该值并相应地打印偶数或奇数。`subject.onNext`方法是向主题发送新值的方式，以便它可以处理它。
- en: The ReactiveCalculator project
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactiveCalculator项目
- en: 'So, let''s start with an event with the user input. Go through the following
    example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从一个用户输入的事件开始。通过以下示例进行操作：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the code, you''ll get the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，你会得到以下输出：
- en: '![](img/db5f48be-584a-4eef-b303-e091c49aaea3.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db5f48be-584a-4eef-b303-e091c49aaea3.jpg)'
- en: 'In the `main` method, we are not doing much operation except for just listening
    to the input and passing it to the `ReactiveCalculator` class, and doing all other
    operations in the class itself, thus it is modular. In the later chapters, we
    will create a separate `observable` for the input process, and we will process
    all user inputs there. We have followed the pull mechanism on the user input for
    the sake of simplicity, which you will learn to remove in the next chapters. So,
    let''s now take a look at the following `ReactiveCalculator` class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`方法中，我们并没有做很多操作，除了监听输入并将其传递给`ReactiveCalculator`类，所有其他操作都在类内部完成，因此它是模块化的。在后面的章节中，我们将为输入过程创建一个单独的`observable`，并将所有用户输入处理在那里。为了简化，我们遵循了用户输入的拉机制，你将在下一章学习如何移除它。现在，让我们看一下下面的`ReactiveCalculator`类：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this program, we have push mechanism (`observable` pattern) only to the data,
    not the event (user input). While the initial chapters in this book will show
    you how to observe on data changes; RxJava also allows you to `observer` events
    (such as user input), we will get them covered during the end of the book while
    discussing RxJava on Android. So, now, let's understand how this code works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们只有对数据（而不是事件，即用户输入）有推送机制（`observable`模式）。虽然本书的初始章节将向你展示如何观察数据变化；RxJava还允许你观察事件（如用户输入），我们将在本书末尾讨论RxJava在Android上的应用时涵盖这一点。所以，现在，让我们了解这个代码是如何工作的。
- en: First, we created a `ReactiveCalculator` class, which observes on its data and
    even on itself; so, whenever its property is modified, it calls all its `calculate`
    methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个`ReactiveCalculator`类，它观察其数据甚至自身；因此，每当其属性被修改时，它都会调用所有的`calculate`方法。
- en: We used `Pair` to pair two variables and created four `subject` on the `Pair`
    to observe changes on it and then process it; we need four `subject` as there
    are four separate operations. You will also learn to optimize it with just one
    method in the later chapters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Pair`来配对两个变量，并在`Pair`上创建了四个`subject`来观察其变化并对其进行处理；我们需要四个`subject`因为存在四个独立的操作。在后面的章节中，你还将学习如何仅用一个方法来优化它。
- en: On the `calculate` methods, we are just notifying the subject to process the
    `Pair` and print the new result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calculate`方法上，我们只是通知主题处理`Pair`并打印新的结果。
- en: If you focus on the `map` methods in both the programs, then you will learn
    that the `map` method takes the value that we passed with `onNext` and processes
    it to come up with a resultant value; that resultant value can be of any data
    type, and this resultant value is passed to the subscriber to process further
    and/or show the output.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关注这两个程序中的`map`方法，那么你会了解到`map`方法接受我们通过`onNext`传递的值，并将其处理成结果值；这个结果值可以是任何数据类型，并且这个结果值会被传递给订阅者以进一步处理和/或显示输出。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about what reactive programming is and the reasons
    we should learn it. We also started with coding. The reactive coding pattern may
    seem new or somehow uncommon, but it is not that hard; while using it, you just
    need to declare a few more things.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是响应式编程以及我们应该学习它的原因。我们还开始了编码。响应式编程模式可能看起来很新或者有些不常见，但它并不难；在使用它时，你只需要声明一些额外的事情。
- en: We learned about `observable` and its use. We also got introduced to `subject`
    and `map`, which we will learn in depth in the later chapters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了`observable`及其用法。我们还介绍了`subject`和`map`，我们将在后面的章节中深入学习。
- en: We will continue with `ReactiveCalculator` example in the later chapters and
    see how we can optimize and enhance this program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将继续使用`ReactiveCalculator`示例，并看看我们如何可以优化和增强这个程序。
- en: The three examples presented in this chapter may seem a bit confusing and complex
    at first, but they're really simple, and they will become familiar to you as you
    proceed with this book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的三个示例可能一开始看起来有些混乱和复杂，但它们实际上非常简单，随着你继续阅读本书，它们将变得熟悉起来。
- en: In the next chapter, we will learn more about functional programming and functional
    interfaces in RxKotlin.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于函数式编程和RxKotlin中的函数式接口。
