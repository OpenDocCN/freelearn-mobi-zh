- en: A Short Introduction to Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **reactive** got famous recently. Not only did it get trending, but
    it has started ruling the software development sector with new blog posts articles
    every day, and presentations, emerging frameworks and libraries, and more. Even
    the big IT companies that are often referred to as market giants, such as Google,
    Facebook, Amazon, Microsoft, and Netflix, are not only supporting and using reactive
    programming themselves, but they've even started releasing new frameworks for
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a programmer, we are wondering about reactive programming. Why is everyone
    getting crazy about it? What does *reactive programming* exactly mean? What are
    the benefits of reactive programming? And, finally, should we learn it? If yes,
    then how?
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **Kotlin** is also the newest programming language you've
    heard of (we're guessing you've heard of Kotlin, as this book assumes that you've
    a little understanding of the language). Kotlin, as a language, solves many important
    problems in Java. The best part is its interoperability with Java. If you carefully
    watch the trends, then you would know that Kotlin has created not a strong wind
    but a storm to blow things around it. Even the Google at *Google IO/17* declared
    its official support for Kotlin as an official programming language for Android
    application development, noting that it is the first time since the perception
    of the Android Framework that Google has added another language to the Android
    family other than Java. Soon after, Spring also expressed their support for Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: To say it in simple words, Kotlin is powerful enough to create a great application,
    but if you combine reactive programming style with Kotlin, it would be super easy
    to build great apps better.
  prefs: []
  type: TYPE_NORMAL
- en: This book will present reactive programming in Kotlin with RxKotlin and Reactor,
    along with their implementations in Spring, Hibernate, and Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is reactive programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasons to adapt functional reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Manifesto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison between the `observer` (reactive) pattern and familiar patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with RxKotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is reactive programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is an asynchronous programming paradigm that revolves around
    data streams and the propagation of change. In simpler words, those programs which
    propagate all the changes that affected its data/data streams to all the interested
    parties (such as end users, components and sub-parts, and other programs that
    are somehow related) are called **reactive programs**.
  prefs: []
  type: TYPE_NORMAL
- en: For example, take any spreadsheet (say the Google Sheet), put any number in
    the A1 cell, and in the B1 cell, write the `=ISEVEN(A1)` function; it'll show
    `TRUE` or  `FALSE`, depending on whether you've entered an even or odd number.
    Now, if you modify the number in A1, the value of B1 will also get changed automatically;
    such behavior is called **reactive**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not clear enough? Let''s look at a coding example and then try to understand
    it again. The following is a normal Kotlin code block to determine if a number
    is even or odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you check the output of the program, then you'll see that, although the number
    is assigned a new value, `isEven` is still true; however, if `isEven` was made
    to track changes of the number, then it would automatically become false. A reactive
    program would just do the same.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons to adapt functional reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s first discuss the reasons to adapt functional reactive programming.
    There''s no point in changing the whole way you code unless it gets you some really
    significant benefits, right? Yes, functional reactive programming gets you a set
    of mind-blowing benefits, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get rid of the callback hell**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A callback is a method that gets called when a predefined event occurs. The
    mechanism of passing interfaces with callback methods is called **callback mechanism**.
    This mechanism involves a hell of a lot of code, including the interfaces, their
    implementations, and more. Hence, it is referred to as **callback hell**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Standard mechanism for error handling**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, while working with complex tasks and HTTP calls, handling errors
    are a major concern, especially in the absence of any standard mechanism, it becomes
    a headache.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**It''s a lot simpler than regular threading**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though Kotlin makes it easier to work with threading as compared to Java, it's
    still complicated enough. Reactive programming helps to make it easier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Straightforward way for async operations**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threading and asynchronous operations are interrelated. As threading got easier,
    so did the async operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**One for everything**, **the same API for every operation****s**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming, especially RxKotlin, offers you a simple and straightforward
    API. You can use it for anything and everything, be it network call, database
    access, computation, or UI operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The functional way**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming leads you to write readable declarative code as, here,
    things are more functional.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Maintainable and testable code**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important point-by following reactive programming properly, your program
    becomes more maintainable and testable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reactive Manifesto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is the Reactive Manifesto? The Reactive Manifesto ([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))
    is a document defining the four reactive principles. You can think of it as the
    map to the treasure of reactive programming, or like the bible for the programmers
    of the reactive programming religion.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone starting with reactive programming should have a read of the manifesto
    to understand what reactive programming is all about and what its principles are.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the following is the gist of four principles that Reactive Manifesto defines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system responds in a timely manner. Responsive systems focus on providing
    rapid and consistent response times, so they deliver a consistent quality of service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Resilient**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case the system faces any failure, it stays responsive. Resilience is achieved
    by replication, containment, isolation, and delegation. Failures are contained
    within each component, isolating components from each other, so when failure has
    occurred in a component, it will not affect the other components or the system
    as a whole.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Elastic**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive systems can react to changes and stay responsive under varying workload.
    They achieve elasticity in a cost effective way on commodity hardware and software
    platforms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Message driven**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to establish the resilient principle, reactive systems need to establish
    a boundary between components by relying on asynchronous message passing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By implementing all four preceding principles, the system becomes reliable and
    responsive thus, reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams standard specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the Reactive Manifesto, we also have a standard specification on
    Reactive Streams. Everything in the reactive world is accomplished with the help
    of Reactive Streams. In 2013, Netflix, Pivotal, and Lightbend (previously known
    as Typesafe) felt a need for a standards specification for Reactive Streams as
    the reactive programming was beginning to spread and more frameworks for reactive
    programming were starting to emerge, so they started the initiative that resulted
    in Reactive Streams standard specification, which is now getting implemented across
    various frameworks and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: You can take a look at the Reactive Streams standard specification at—[http://www.reactive-streams.org/](http://www.reactive-streams.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Frameworks for Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write Reactive programs, we need a library or a specific programming language;
    we can''t refer to Kotlin as a reactive language (basically, I don''t know any
    such language that is reactive by itself) as it is a powerful and flexible programming
    language for modern multiplatform applications, fully interoperable with Java
    and Android. However, there are reactive libraries out there to help us with these.
    So, let''s take a look at the available list:'
  prefs: []
  type: TYPE_NORMAL
- en: RxKotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactor-Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux-Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FunKTionale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJava and other Reactive Java Frameworks can also be used with Kotlin (as Kotlin
    is 100% interoperable with Java-bidirectional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will focus on RxJava and Reactor-kotlin (in the later chapters,
    on Spring).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxKotlin is a specific implementation of reactive programming for Kotlin, which
    is influenced by functional programming. It favors function composition, avoidance
    of global state, and side effects. It relies on the `observer` pattern of producer/consumer,
    with a lot of operators that allow composing, scheduling, throttling, transforming,
    error handling, and lifecycle management.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas Reactor-Kotlin is also based on functional programming, and it is widely
    accepted and backed by the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and setting up RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download and build RxKotlin from GitHub ([https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin)).
    I do not require any other dependencies. The documentation on the GitHub wiki
    page is well structured. Here''s how you can check out the project from GitHub
    and run the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can also use Maven and Gradle, as instructed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Gradle, use the following compile dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For Maven, use this dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This book targets RxKotlin 2.x, so remember to use `io.reactive.rxjava2` instead
    of `io.reactivex.rxkotlin`, as the latter one is for RxKotlin 1.x.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using RxKotlin version 2.1.0 for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at what RxKotlin is all about. We will begin with something
    well-known and, gradually, we will get into the secrets of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the pull mechanism with the RxJava push mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxKotlin revolves around the observable type that represents a system of data/events
    intended for push mechanism (instead of the pull mechanism of the `iterator` pattern
    of traditional programs), thus it is lazy and can be used synchronously and asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be easier for us to understand if we start with a simple example that
    works with a list of data. So, here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1c8d575-2c41-4e63-9ab0-da8b5d83f1a3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, let's go through the program line by line to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: At comment `1`, we're creating a list of seven items (the list contains data
    of mixed data types with the help of any class). On comment `2`, we are creating
    `iterator` from the list, so that we can iterate over the data. In comment `3`,
    we have created a `while` loop to pull data from the list with the help of `iterator`,
    and then, in `4`, we're printing it.
  prefs: []
  type: TYPE_NORMAL
- en: The thing to notice is that we're pulling data from the list while the current
    thread is blocked until the data is received and ready. For example, think of
    getting that data from a network call/database query instead of just `List` and,
    in that case, how long the thread will be blocked. You can obviously create a
    separate thread for those operations, but then also, it will increase complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Just give a thought; which one is a better approach? Making the program wait
    for data or pushing data to the program whenever it's available?
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks of the ReactiveX Framework (be it RxKotlin or RxJava) are
    the observables. The `observable` class is just the opposite of `iterator` interface.
    It has an underlying collection or computation that produces values that can be
    consumed by a consumer. However, the difference is that the consumer doesn't *pull*
    these values from the producer, like in the `iterator` pattern; instead, the producer
    *pushes* the values as notifications to the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take the same example again, this time with `observable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This program output is the same as the previous one—it prints all the items
    in the list. The difference is in the approach. So, let''s see how it actually
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a list (just the same as the previous one).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `observable` instance is created with that list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're subscribing to the `observer` instance (we're using named arguments for
    `lambda` and covering it in detail later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we subscribe to `observable`, each data will be pushed to `onNext`, and,
    as it gets ready, it will call `onComplete` when all data is pushed and `onError`
    if any error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: So, you learned to use the `observable` instances, and they are quite similar
    to the `iterator` instances, which is something we're very familiar with. We can
    use these `observable` instances to build asynchronous streams and push data updates
    to their subscribers (even to multiple subscribers).This was a simple implementation
    of the reactive programming paradigm. The data is being propagated to all the
    interested parties—the subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: The ReactiveEvenOdd program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now that we are somewhat familiar with `observables`, let''s modify the
    even-odd program in a reactive way. Here is the code for doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60dc06c0-1b42-4e9d-abf1-a7758439f918.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this program, we have used `subject` and `map`, which we will cover in the
    later chapters. Here, it is just to show how easy it is in reactive programming
    to notify the changes. If you look at the program closely, then you'll also find
    that the code is modular and functional. When we notify `subject` with a number,
    it calls the method in `map`, then it calls the method in `subscribe` with the
    return value of the `map` method. The `map` method checks if the number is even
    and returns true or false accordingly; in the `subscribe` method, we are receiving
    that value and printing even or odd accordingly. The `subject.onNext` method is
    the way through which we message the new value to the subject, so it can process
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The ReactiveCalculator project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s start with an event with the user input. Go through the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code, you''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db5f48be-584a-4eef-b303-e091c49aaea3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `main` method, we are not doing much operation except for just listening
    to the input and passing it to the `ReactiveCalculator` class, and doing all other
    operations in the class itself, thus it is modular. In the later chapters, we
    will create a separate `observable` for the input process, and we will process
    all user inputs there. We have followed the pull mechanism on the user input for
    the sake of simplicity, which you will learn to remove in the next chapters. So,
    let''s now take a look at the following `ReactiveCalculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we have push mechanism (`observable` pattern) only to the data,
    not the event (user input). While the initial chapters in this book will show
    you how to observe on data changes; RxJava also allows you to `observer` events
    (such as user input), we will get them covered during the end of the book while
    discussing RxJava on Android. So, now, let's understand how this code works.
  prefs: []
  type: TYPE_NORMAL
- en: First, we created a `ReactiveCalculator` class, which observes on its data and
    even on itself; so, whenever its property is modified, it calls all its `calculate`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: We used `Pair` to pair two variables and created four `subject` on the `Pair`
    to observe changes on it and then process it; we need four `subject` as there
    are four separate operations. You will also learn to optimize it with just one
    method in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: On the `calculate` methods, we are just notifying the subject to process the
    `Pair` and print the new result.
  prefs: []
  type: TYPE_NORMAL
- en: If you focus on the `map` methods in both the programs, then you will learn
    that the `map` method takes the value that we passed with `onNext` and processes
    it to come up with a resultant value; that resultant value can be of any data
    type, and this resultant value is passed to the subscriber to process further
    and/or show the output.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about what reactive programming is and the reasons
    we should learn it. We also started with coding. The reactive coding pattern may
    seem new or somehow uncommon, but it is not that hard; while using it, you just
    need to declare a few more things.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about `observable` and its use. We also got introduced to `subject`
    and `map`, which we will learn in depth in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue with `ReactiveCalculator` example in the later chapters and
    see how we can optimize and enhance this program.
  prefs: []
  type: TYPE_NORMAL
- en: The three examples presented in this chapter may seem a bit confusing and complex
    at first, but they're really simple, and they will become familiar to you as you
    proceed with this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about functional programming and functional
    interfaces in RxKotlin.
  prefs: []
  type: TYPE_NORMAL
