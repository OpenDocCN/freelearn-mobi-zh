- en: Chapter 5. Getting Around – Pathfinding and AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we learned about camera and lighting effects. We
    added a skybox, lights, and shadows to our Tank Battle game. We created lightmaps
    to make our scene dynamic. We took a look at cookies by giving our tank headlights.
    We also took a look at projectors by creating a blob shadow for the tank. A turbo
    boost was also created for the tank. By adjusting the viewing angle of the camera,
    we were able to make the tank look as if it is going much faster than it really
    is. When we finished, we had a dynamic and exciting-looking scene.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter is all about the enemy. No longer will the player be able to
    just sit in one place to gather points. We will be adding an enemy tank to the
    game. By using Unity''s NavMesh system, the tank will be able to do pathfinding
    and chase the player. Once found, the tanks will shoot and reduce the player''s
    score.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: NavMesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NaveMeshAgent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pathfinding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chase and attack AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be adding modifications to the Tank Battle game from [Chapter 4](ch04.html
    "Chapter 4. Setting the Stage – Camera Effects and Lighting"), *Setting the Stage
    – Camera Effects and Lighting*, so open it up and we can begin.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AI and pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AI** is, as you might have guessed, **artificial intelligence**. In the broadest
    sense this is anything an inanimate object might do to appear to be making decisions.
    You are probably most familiar with this concept from video games. When a character,
    not controlled by the player, selects a weapon to use and a target to use it on,
    this is AI.'
  prefs: []
  type: TYPE_NORMAL
- en: In its most complex form, AI attempts to mimic full human intelligence. However,
    there is still far too much happening incredibly fast for this to truly succeed.
    Video games do not need to reach nearly this far. We are primarily concerned with
    making our characters appear intelligent, but still conquerable by our players.
    Usually, this means not allowing characters to act on more information than a
    real player might have. Adjusting how much information characters have and can
    act on is a good way to adjust the level of difficulty in a game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pathfinding** is a subset of AI. We use it all the time, though you have
    probably never realized it. Pathfinding is, as the word suggests, the act of finding
    a path. Every time you need to find your way between any two points, you are doing
    pathfinding. As far as our characters are concerned, the simplest form of pathfinding
    is to follow a straight line to the goal point. Obviously, this method works best
    on an open plain, but tends to fail when there are any obstacles in the way. Another
    method is to overlay the game with a grid. Using the grid, we can find a path
    that goes around any obstacles and reaches our target.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative method of pathfinding, and perhaps the one most often chosen,
    makes use of a special navigation mesh, or NavMesh. This is just a special model
    that is never seen by the player but covers all of the area that a computer character
    can move around in. It is then navigated in a similar way to the grid, the difference
    being that the triangles of the mesh are used rather than the squares of the grid.
    This is the method we will be using in Unity. Unity provides a nice set of tools
    for creating the NavMesh and utilizing it.
  prefs: []
  type: TYPE_NORMAL
- en: The NavMesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the navigation mesh in Unity is very simple. The process is similar
    to the one we used for making lightmaps. We just mark some meshes to be used,
    adjust some settings in a special window, and hit a button. So, load up the Tank
    Battle game in Unity, if you haven't already done so, and we can get started.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the NavMesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity can automatically generate a NavMesh from any meshes that exist in a
    scene. To do so, the mesh must first be marked as static, just as we did for lightmaps.
    However, we do not want or need to be able to navigate the roofs of our city,
    so we make use of a special list of settings for dictating what type of static
    each object will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the city from the **Hierarchy** window and click on the down arrow to
    the right of **Static** in the **Inspector** window and we can take a look at
    the options available for static objects as follows:![Time for action – creating
    the NavMesh](img/2014OT_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nothing**: This option is used to quickly deselect all the other options.
    If all the others are unchecked, this one will be checked.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Everything**: Using this option, you can quickly select all the other options.
    When all of them are checked, this one will also be checked. The checkbox next
    to the **Static** label in the **Inspector** window performs the same function
    as checking and unchecking the **Everything** checkbox.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightmap Static**: This option needs to be checked, when working with lightmaps,
    in order for them to work. Any mesh that does not have this checked will not be
    lightmapped.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occluder Static**: This is an option for working with occlusion. **Occlusion**
    is a method of runtime optimization that involves only rendering objects that
    can actually be seen whether or not they are within the camera''s view space.
    An **Occluder** is an object that will block other objects from being seen. It
    works in conjunction with the **Occludee Static** option. The best object choices
    for this option are large and solid.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batching Static**: This is another option for runtime optimization. Batching
    is the act of grouping objects together before rendering them. It greatly increases
    the overall render speed of a game.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation Static**: This is the option we are primarily concerned with at
    this point. Any mesh that has this option checked will be used when calculating
    the NavMesh.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occludee Static**: As mentioned a moment ago, this option works in conjunction
    with **Occluder Static** for the good of occlusion. An Occludee is an object that
    will be obscured by other objects. When covered by an Occluder, this object will
    not be drawn.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Off Mesh Link Generation**: This option also works with the NavMesh calculation.
    An Off Mesh Link is a connection between two parts of the NavMesh that aren''t
    physically connected, such as the roof and the street. Using a few settings in
    the **Navigation** window and this option, the links are automatically generated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to make the NavMesh work properly, we need to change the settings
    so that only the streets of the city can be navigated. When was the last time
    you saw a tank jump to or fall from the roof of a building? So, we need to change
    the **Static** options so that only the streets have **Navigation Static** checked.
    This can be done in one of the following two ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first way is to go through and uncheck the option for each object we want
    changed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is to uncheck **Naviagation Static** for the top-level object in
    the **Hierarchy** window and, when Unity asks if we want to make the change for
    all children objects, reply with a yes. Then, go to just the objects that we want
    to navigate and recheck the option.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, open the **Navigation** window by going to Unity's toolbar and clicking
    on **Window** followed by **Navigation** at the bottom of the menu. The following
    screenshot displays the window where all the work of making the NavMesh happens:![Time
    for action – creating the NavMesh](img/2014OT_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This window consists of three pages and a variety of settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an object is selected, the settings will appear on the **Object** page.
    The two checkboxes correspond directly with the **Static** options of the same
    name that we set a moment ago. The drop-down list in **Navigation Layer** lets
    us use different layers for different parts of our NavMesh. These layers can be
    used to affect the pathfinding calculation. For example, a car can be set to only
    travel on a road layer and the human can follow the sidewalk layer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Bake** page is the one we are interested in; it is full of options to
    change how the NavMesh is generated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radius**: This should be set to the size of the average character. It is
    used to keep characters from walking too close to the walls.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Height**: This is the height of your characters. Using this, Unity can calculate
    and remove the areas that are too low for them to pass. Anything lower than this
    value is deemed too small.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Max Slope**: Anything steeper than this value is ignored when calculating
    NavMesh.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Step Height**: When making use of stairs, one must use this value. This is
    the maximum height of a stair that a character can step on.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Drop Height**: This is the height from which characters can fall. With it,
    paths will include jumping off ledges, if it is faster to do so. As you can tell
    from the screenshot, this is a Unity Pro-only feature.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Jump Distance**: Using this value, characters can jump across gaps in NavMesh.
    This value represents the longest distance that can be jumped. As you can tell
    from the screenshot, this is a Unity Pro only feature.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Min Region Area**: If parts of the NavMesh are too small, anything smaller
    than this value, they will not be used in the final NavMesh.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Width Inaccuracy %**: When doing the NavMesh calculations, Unity makes use
    of a number of approximations. This is not entirely accurate, but it is fast.
    This value represents how much inaccuracy is allowed for the horizontal.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Height Inaccuracy %**: This is the same as the previous settings, the difference
    being that it works for the vertical.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Height Mesh**: With this option checked, the original height information
    is maintained in NavMesh. Unless you have a special need of it, this option should
    remain off. It takes the system longer to calculate and requires more memory to
    store.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The third page, **Layers**, allows us to adjust the cost of movement for each
    of our layers. Essentially, how difficult is it to move through different parts
    of our game world. With cars, we could adjust the layers, so it is twice as costly
    for them to move through the field as it is to move along the road.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the bottom of the window, we have two buttons:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Clear**: This button removes the previously created NavMesh. After using
    this button, you will need to re-bake the NavMesh before you can make use of pathfinding
    again.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Bake**: This button starts the work and creates the NavMesh.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Our city is very simple, so the default values will suit us well enough. Hit
    **Bake** and watch the progress bar in the bottom-right corner. Once it is done,
    a blue mesh will appear. This is the NavMesh and, of course, represents all of
    the area that a character can move through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one last thing we need to do. Our NavMesh is just right but, if you
    look closely, it goes through the fountain in the center of the city. It would
    just be wrong if enemy tanks start driving through the fountain. To fix this,
    start by selecting the mesh that forms the wall around the fountain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the toolbar of Unity, click on **Component**, followed by **Navigation**,
    and finally **NavMeshObstacle**. This simply adds a component that tells the navigation
    system to go around when finding a path. Because we had the wall already selected,
    the new component is already sized to fit. You can see it represented as a wire
    cylinder in the **Scene** view.![Time for action – creating the NavMesh](img/2014OT_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the NavMesh. We made use of the **Navigation** window and the **Static**
    options to tell Unity which meshes to use when calculating the NavMesh. The Unity
    team put a lot of work into making this process quick and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – creating extra obstacles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember, in [Chapter 3](ch03.html "Chapter 3. The Backbone of Any Game – Meshes,
    Materials, and Animations"), *The Backbone of Any Game – Meshes, Materials, and
    Animation*, when the challenge was to create obstacles for the player, you were
    encouraged to create additional meshes, such as tank traps and rubble. It would
    be a bad idea to let the enemy tanks drive through these, as well. So, have a
    go at turning these into obstacles for the navigation system. This will be done
    just as with the fountain.
  prefs: []
  type: TYPE_NORMAL
- en: The NavMeshAgent component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be thinking that it is all well and good that we have a NavMesh, but
    there are no characters to navigate it. In this section, we will start the creation
    of our enemy tank.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to import and do a little setup on a second tank, before we can
    do any AI type programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `Tanks_Type03.png` and `Tanks_Type03.blend` from the starting assets
    for the chapter and import them to the `Tanks` folder under the `Models` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Unity has finished importing, select the new tank in the **Project** window
    and take a look at it in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tank has no animations, so the **Animation Type** can be set to **None**
    and **Import Animation** can be unchecked from the **Rig** and **Animations**
    pages respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the tank from the **Project** window to the **Scene** window; any clear
    patch of street will work just fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For starters, rename the model in the **Scene** view to `EnemyTank`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to change the parenting of the tank so the turret can turn and
    the cannon will follow, just as we did for the player's tank. To do that, create
    an empty **GameObject** and rename it to `TurretPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position `TurretPivot` to be at the base of the turret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, drag-and-drop `TurretPivot` onto `EnemyTank` to
    make `EnemyTank` the parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Still in the **Hierarchy** window, make the cannon and turret mesh objects children
    of `TurretPivot`. When Unity asks whether you are sure that you want to break
    the prefab connection, be sure to click on **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tank is a little large, so adjust the **Scale Factor** of the tank's Import
    Settings in the **Inspector** window to `0.6` to give us a tank that is about
    the size of the player's.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for the tank to be able to navigate our new NavMesh, we need to add
    a **NavMeshAgent** component. First, select `EnemyTank` in the **Hierarchy** window
    and then go to the toolbar of Unity; click on **Component**, followed by **Navigation**,
    and then click on **NavMeshAgent**. In the **Inspector** window, we can see the
    new component and the settings associated with it, as shown in the following screenshot:![Time
    for action – creating the enemy](img/2014OT_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Radius**: This is simply how big the agent is. Working in conjunction with
    the **Radius** value we set in the **Navigation** window, this keeps the object
    from walking partly in the walls.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: The **NavMeshAgent** component automatically moves the connected
    object when it has a path. This value dictates how fast to follow the path in
    units per second.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceleration**: This is the maximum speed that the agent will accelerate
    with.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Speed**: This is the degrees per second that the agent can turn.
    A person would have a very high angular speed, while a car''s angular speed would
    be low.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopping Distance**: This is how far away from the target destination the
    agent will start to slow down and stop.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Traverse Off Mesh Link**: With this checkbox checked, the agent will
    use the Off Mesh Links when pathfinding, such as jumping gaps and falling off
    ledges.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Braking**: With this checkbox checked, the agent will stop as soon as
    it reaches the destination, rather than overshooting, because of the irregular
    frame rate.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Repath**: If the path that was found is incomplete for any reason, this
    checkbox allows Unity to automatically try to find a new one.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height**: This setting affects the cylinder that appears in the editor, around
    the agent. It simply sets the height of that cylinder.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base Offset**: This is the vertical offset of the colliders that are attached
    to the agent.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obstacle Avoidance Type**: This is how much effort the agent will put in
    to find a smooth path around obstacles. The higher the quality, the more work
    is done.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoidance Priority**: This value dictates who has the right of way. An agent
    with a high value will go around an agent with a low value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NavMesh Walkable**: Remember those layers that were mentioned earlier when
    discussing the **Navigation** window? This is where we can set which layers the
    agent is able to traverse. Only the layers in this list that are checked will
    be used for pathfinding.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the settings, let's use them. For the enemy tank, a value
    of `2.4` for the **Radius** and `4` for the **Height** will work well. You should
    be able to see another wire cylinder in the **Scene** window, this time around
    our enemy tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do is to turn `EnemyTank` into a prefab. Do this just as we
    did with the targets, by dragging it from the **Hierarchy** window and dropping
    it on the `Prefabs` folder in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an enemy tank. We also learned about the settings for the **NavMeshAgent**
    component. However, if you try to play the game now, nothing will appear to happen.
    This is because the **NavMeshAgent** component is not being given a destination.
    We will solve that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The chase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next task is to make our enemy tank chase the player around. We will need
    two scripts. The first will simply advertise the player's current position. The
    second will use that position and the **NavMeshAgent** component that we set up
    earlier to find a path to the player.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – the player is over here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a very short script, we can easily allow all our enemies know the location
    of the player:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new script in the `Scripts` folder of the **Project** window.
    Name it `PlayerPosition`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script will start with a single static variable. This variable will simply
    hold the current position of the player. Because it is static, we will be able
    to easily access it from the rest of our scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the next lines of code, we make use of the `Start` function. This function
    is automatically called when a scene is first loaded. We use it so that the `position`
    variable can be filled and used as soon as the game starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last segment of code simply updates the `position` variable in every frame
    to the player's current position. We also do this in the `LateUpdate` function
    so that it is done after the player has moved. The `LateUpdate` function is called
    at the end of every frame. With that, the player is able to move during the `OnGUI`
    and `Update` functions and their position is updated later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last thing to do with this script is to add it to the player's tank. So,
    return to Unity and drag-and-drop the script from the Project window to the tank
    to add it as a component, just as we have done with all our other scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the first script needed for our chase AI. This script simply updates
    a variable with the player's current position. We will make use of it in our next
    script, where we will make the enemy tank move around.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – chasing the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next script will control our simple chase AI. Because we are making use
    of the **NavMesh** and **NavMeshAgent** components, we can leave nearly all the
    difficult portions of pathfinding to Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, create a new script. This time name it `ChasePlayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first line for this script simply holds a reference to the **NavMeshAgent**
    component that we set up earlier. We need access to this component in order to
    move the enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last segment of code first makes sure that we have our **NavMeshAgent**
    reference and then updates our goal destination. It uses the `PlayerPosition`
    script's variable, that was set up earlier, and the `SetDestination` function
    from the **NavMeshAgent**. Once we tell the function where to go, the **NavMeshAgent**
    component does all the hard work of getting us there. We are updating our goal
    destination in the `FixedUpdate` function because we do not need to update the
    destination in every frame. Updating too often could cause a serious lag if there
    are a whole lot of enemies. The `FixedUpdate` function is called at regular intervals
    and is slower than the frame rate, so it is perfect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now need to add the script to our enemy tank. Select the `prefab` in the
    **Project** window, and drag-and-drop the script in the **Inspector** panel, underneath
    the **NavMeshAgent** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to connect the reference, as we have done previously. Drag the **NavMeshAgent**
    component to the **Agent** value in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game now to try it out. Wherever the enemy starts, it finds its way
    around all the buildings and makes it to the player's position. As you drive around,
    you can watch the enemy follow. However, the enemy tank ends up going through
    our tank. Also, we can drive through it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step to fixing it is to add some colliders. Add a **Box Collider**
    component from underneath **Physics** in the **Component** menu to the turret,
    chassis, and each of the **TreadCase** objects. Neither the cannon nor the treads
    need colliders. The tread casings already cover the area of the treads, and the
    cannon is too small a target to be shot at properly.![Time for action – chasing
    the player](img/2014OT_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are making any of these changes in the **Scene** view, be sure to click
    on the **Apply** button in the **Inspector** window to update the root prefab
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last thing to change is the **Stopping Distance** property on the **NavMeshAgent**
    component. When the tanks fight, they move into range and start firing. They do
    not try to occupy the same space as the enemy, unless that enemy is small and
    squishy. By setting **Stopping Distance** to `10` we are able to replicate this
    behavior.![Time for action – chasing the player](img/2014OT_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we created a script that causes a **NavMeshAgent** component,
    in this case our enemy tank, to chase the player. We added colliders to stop us
    from driving through the enemy. And, we adjusted the **Stopping Distance** to
    give us a better tank behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding shadow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try adding a blob shadow to the enemy tank. This will give it a better visual
    sense of being grounded. You can just copy the one that was made for the player's
    tank.
  prefs: []
  type: TYPE_NORMAL
- en: Being attacked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What fun is a game without a little conflict; the nagging choice, the fight
    to the death, the doom of the cosmos? Every game needs some form of conflict to
    drive the player towards seeking a resolution. Our game will become a battle for
    points. Before, it was just shoot some targets and get some points.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will make the enemy tank shoot at the player. Every time the enemy scores
    a hit, we will reduce the player's score by a few points.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – getting ready to fire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The enemy will shoot in a similar manner to how the player fires, but we will
    use some basic AI to control the direction and firing speed, replacing the player''s
    input controls:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start this off with a new script called `ShootAtPlayer`. Create it in
    the `Scripts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with all our other scripts, we start this one out with two variables. The
    first variable will hold the last position the enemy tank was at. It will not
    be shooting if the tank is in motion, so we need to store that last position to
    see if we have moved. The second variable will be the maximum speed at which we
    can move and shoot. If the tank moves faster than this, it will not fire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next two variables dictate how long it takes the tank to ready a shot. It
    is unrealistic to be shooting the player in every single frame. So, we use the
    first variable to adjust the length of time it takes to ready a shot, and the
    second to store when the shot is ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next variable is how fast the turret can rotate. While the tank is readying
    its shot, the turret will not be rotating to point at the player. That gives the
    player an opportunity to move out of the way. However, we need a speed to keep
    the turret from snapping to face the player after shooting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last two variables here hold references to other parts of the tank. The
    `turretPivot` variable, of course, is the pivot of the turret that we will be
    rotating. The `muzzlePoint` variable will be used as the point from where our
    cannon is fired. These will be used in the same manner as the ones for the player's
    tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the first function of the script, we will make use of the `Update` function.
    It starts by calling a function that will check to see whether it is possible
    to fire the cannon. If we can fire, we perform some checks on our `readyTime`
    variable. If it is less than zero, we have not yet begun to ready our shot and
    call a function to do so. Otherwise, if it is less than the current time, we have
    finished the preparation and call the function to fire the cannon. If we are unable
    to fire, we first call a function to clear any preparations and then rotate the
    turret to face the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will create our `CheckCanFire` function. The first part of code checks
    to see if we have moved too fast. First, we use `Vector3.Distance` to see how
    far we have moved since the last frame. By dividing the distance by the length
    of the frame, we are able to determine the speed with which we moved. Next, we
    update our `lastPosition` variable with our current position, so it is ready for
    the next frame. Finally, we compare the current speed with the `maxSpeed`. If
    we moved too fast in this frame, we are unable to fire and return a result of
    `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the second half of the `CheckCanFire` function, we check to see if the turret
    is pointed at the player. First, we find the direction to the player. Given any
    point in space and subtracting the second point's location from it, will give
    us the direction from the second point to the first as a vector. We then flatten
    the direction by setting the `y` value to `0`. This is done because we do not
    want to be looking up or down at the player. Then, we use `Vector3.Angle` to find
    the angle between the direction to the player and our turret's forward direction.
    Finally, we compare the angle to a low value to determine whether we are looking
    at the player, and return the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `PrepareFire` function is quick and easy. It simply sets our `readyTime`
    variable to the time in the future when the tank will be done preparing its shot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Fire` function starts by making sure that we have a `muzzlePoint` reference
    to shoot from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function continues with the creation of a `RaycastHit` variable to store
    the result of our shot. We use `Physics.Raycast` and `SendMessage`, just as we
    did in the `FireControls` script, to shoot at anything and tell it that we hit
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Fire` function finishes by clearing the fire preparations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ClearFire` function is another quick function. It sets our `readyTime`
    variable to be less than zero, indicating that the tank is not preparing to fire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function for the script is `RotateTurret`. It begins by checking the
    `turretPivot` variable and canceling the function should the reference be missing.
    It is followed by the finding of the flat direction that points at the player,
    just as we did earlier. Next, we create the `step` variable to hold how much we
    can move this frame. We use `Vector3.RotateTowards` to find a vector that is closer
    to pointing at our target than the current forward direction is. Finally, we use
    `Quaternion.LookRotation` to create a special rotation that points our turret
    in the new direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, returning to Unity, create an empty **GameObject** and rename it to `MuzzlePoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position `MuzzlePoint` as we did for the player, at the end of the cannon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make `MuzzlePoint` a child of the cannon and zero out any **Y** rotation that
    might be on it, in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add our new `ShootAtPlayer` script to the enemy tank. Additionally, connect
    the references to the `TurretPivot` and `MuzzlePoint` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, for the enemy tank, hit the **Apply** button in the **Inspector** window
    to update the prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you play the game now, you will see the enemy rotating to point at you, but
    your score never decreases. This is because of two issues. First, the tank is
    slightly floating. It doesn't matter where in the world you place it, when playing
    the game, the tank will slightly float. This is because of the way the NavMeshAgent
    component functions. The fix is simple, just set the **Base Offset** to `-0.3`
    in the **Inspector** window. This tricks the system and puts the tank on the ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second reason the score isn't changing is because the player is missing
    a function. Open the `ScoreCounter` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be adding the `RemovePoints` function. Given an amount, this function
    simply removes that many points from the player's score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action – getting ready to fire](img/2014OT_05_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We gave the enemy the ability to attack the player. The new `ShootAtPlayer`
    script checks first to see whether the tank has slowed down and whether the cannon
    is trained on the player. If so, it will take regular shots at the player to reduce
    their score. The player is going to need to keep moving and aim at targets fast,
    if they hope to be left with any points at the end of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – player feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unless you are paying close attention to your score, it is difficult to tell
    when you are being shot at. We will be working with explosions in a future chapter
    but, even so, the player needs some feedback to tell what is going on. Most games
    will flash a red texture on the screen when the player is hit, whether or not
    there are any explosions. Try creating a simple texture and drawing it on the
    screen for half a second when the player is hit.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking the enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Players tend to become frustrated quickly when faced with an enemy they are
    unable to fight against. So, we are going to give our player the ability to hurt
    and destroy the enemy tank. This will function in a similar manner to the way
    the targets are shot.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – giving it a weakness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to weaken our enemies is to give them some health that is reduced
    when they are shot, and to destroy them when they run out of health:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a new script and naming it `Health`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script is rather short and starts with a single variable. This variable
    will keep track of the remaining health of the tank. By setting the default value
    to `3`, the tank will be able to survive three hits before being destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script also contains only one function, `Hit`. As in the case of the targets,
    this function is called by the `BroadcastMessage` function when the player shoots
    at it. The first line of the function reduces `health` by one point. The next
    line checks to see if `health` is below zero. If it is, the tank is destroyed
    by calling the `Destroy` function and passing it the `gameObject` variable. We
    also give the player a handful of points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It really is just that simple. Now, add the new script to the `EnemyTank` prefab
    in the **Project** window, and it will update all the enemy tanks that you currently
    have in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try it out. Add a few extra enemy tanks to the scene and watch them follow you
    around and disappear when you shoot them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We gave the enemy tank a weakness, health. By creating a short script, the tank
    is able to track its health and detect when it has been shot. Once the tank runs
    out of health, it is removed from the game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – coloring the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have two targets to shoot at: the animated ones and the tank. However,
    they are both indicated with red slices. Try to make the ones that point at tanks
    be a different color. You will have to make a duplicate of the `IndicatorSlice`
    prefab and change the `IndicatorControl` script so that it can be told which type
    of slice to use when the `CreateSlice` and `NewSlice` functions are called.'
  prefs: []
  type: TYPE_NORMAL
- en: As a further challenge, the moment we give a creature some health, players want
    to be able to see how much damage they have done to it. There are two ways you
    could do this. First, you could put a cluster of cubes above the tank. Then, each
    time the tank loses health, you delete one of the cubes. The second option is
    a little more difficult, drawing the bar in the GUI and changing its size based
    on the remaining health. To make the bar stay above the tank as the camera moves
    around, take a look at `Camera.WorldToScreenPoint`, in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a limited number of enemies in the game, at the beginning, is not suitable
    for our game to have lasting fun. Therefore, we need to make some spawn points.
    As tanks are destroyed, these will issue forth new tanks to keep the player on
    their toes.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating spawns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The script we will be creating in this section will keep our game world populated
    with all the enemies our player might want to destroy:'
  prefs: []
  type: TYPE_NORMAL
- en: We need another new script for this section. Once created, name it `SpawnPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script begins simply with a few variables. The first variable will hold
    a reference to our `EnemyTank` prefab. We need it so we can spawn duplicates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second variable tracks the spawned tank. When it is destroyed we will create
    a new one. Using this variable we prevent the game from becoming overwhelmed with
    the enemy. There will only be as many tanks as spawn points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The third variable is for setting a distance from the player, to prevent spawning
    tanks on top of the player. If the player is outside this distance, a new tank
    can be spawned. If they are within, a new tank will not be spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first function we will use is `FixedUpdate`. It will start by checking a
    function to see whether it needs to spawn a new tank. If it does, it will call
    the `SpawnTank` function to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we create the `CanSpawn` function. The first line of the function checks
    to see whether we already have a tank and returns `false` if we do. The second
    line uses `Vector3.Distance` to determine how far away the player currently is.
    The last line compares that distance to the minimum distance away that the player
    needs to be before we can spawn anything and returns the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function, `SpawnTank`, starts by checking to make sure the `tankPrefab`
    reference has been connected. It can't continue if there is nothing to spawn.
    The second line uses the `Instantiate` function to create a duplicate of the prefab.
    In order to store it in our variable, we use `as GameObject` to make it the proper
    type. The last line moves the new tank to the spawn point's position. We don't
    want the tanks appearing in random locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to Unity, create an empty **GameObject**, and rename it to `SpawnPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `SpawnPoint` script that we just created, to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, with the spawn point selected, connect the prefab reference by dragging
    the `EnemyTank` prefab from the `Prefabs` folder and dropping it on the appropriate
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, turn the `SpawnPoint` object into a prefab, by dragging-and-dropping it
    from the **Hierarchy** window and into the `Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, populate the city with the new points. Positioning one in each corner
    of the city will work well.![Time for action – creating spawns](img/2014OT_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created spawn points for the game. Each point will spawn a new tank. When
    a tank is destroyed, a new one is created at the spawn point. Feel free to build
    the game and try it out on your device. This section and chapter are now complete
    and ready for wrap up.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – two for one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having one spawn point per tank is great, until we want many tanks. Or, we desire
    them to all spawn in the same location. Your challenge here is to make a single
    spawn point track multiple tanks. If any one of the tanks is destroyed, a new
    one should be created. You will definitely need an array to keep track of all
    the tanks. Also, implement a delay for the spawn. We don't want it spawning multiple
    tanks on top of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have all the knowledge and tools that you need, as a further challenge,
    try creating other types of enemy tanks. Experiment with size and speed. They
    can also have different strengths, or give more points when destroyed. Perhaps
    there is a tank that actually gives the player points when shooting at them. Play
    around and have some fun with it.
  prefs: []
  type: TYPE_NORMAL
- en: Pop Quiz – understanding enemies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Probably the most common act performed in games is shooting with guns.
    We have done it a couple of times now. Do you remember what function we use to
    determine where and what our bullet might hit?
  prefs: []
  type: TYPE_NORMAL
- en: '`Input.mousePosition`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Transform.position`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Physics.Raycast`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. We will need a great many enemies running around for us to shoot at. Do
    you remember which function we use to make them move around our NavMesh?
  prefs: []
  type: TYPE_NORMAL
- en: '`CharacterController.Move`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NavMeshAgent.SetDestination`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NavMesh.CalculatePath`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. Finally, all these enemies will have to be spawned again and again. Do
    you remember what function we use to spawn these enemies?
  prefs: []
  type: TYPE_NORMAL
- en: '`Instantiate`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Destroy`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Start`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about NavMeshes and pathfinding. We also did a little
    work with AI. It was perhaps among the simplest types of AI but chase behaviors
    are highly important to all types of games. To utilize all of this, we created
    an enemy tank. It chased the player and shot at them to reduce their score. To
    give the edge back to the player, we gave health to the enemy tanks. The player
    can now shoot the enemy tanks as well as the targets for points. But, we also
    created some spawn points. Every time a tank was destroyed a new one will be created.
    In terms of general game play, our Tank Battle game is pretty much complete.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be creating a new game. In order to explore some
    of the special features of the mobile platform, we will create a Space Fighter
    game. Nearly all the buttons will be removed from the screen, in favor of new
    control methods. We will be turning the device's tilt sensors into our steering
    method. And, we will have to touch enemies and targets to shoot at them. We will
    also take a look at a different methods of spawning to give the player an endless
    amount of space to fly through.
  prefs: []
  type: TYPE_NORMAL
