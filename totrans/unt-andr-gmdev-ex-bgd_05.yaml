- en: Chapter 5. Getting Around – Pathfinding and AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。四处走动 – 寻路和人工智能
- en: '*In the previous chapter, we learned about camera and lighting effects. We
    added a skybox, lights, and shadows to our Tank Battle game. We created lightmaps
    to make our scene dynamic. We took a look at cookies by giving our tank headlights.
    We also took a look at projectors by creating a blob shadow for the tank. A turbo
    boost was also created for the tank. By adjusting the viewing angle of the camera,
    we were able to make the tank look as if it is going much faster than it really
    is. When we finished, we had a dynamic and exciting-looking scene.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们学习了关于摄像机和照明效果的知识。我们在坦克大战游戏中添加了天空盒、灯光和阴影。我们创建了光照贴图来使场景动态。我们通过给坦克添加车头灯来查看饼干。我们还通过为坦克创建一个阴影来查看投影仪。还为坦克创建了一个涡轮增压。通过调整摄像机的观看角度，我们能够使坦克看起来比实际速度快得多。当我们完成时，我们有一个动态且看起来很刺激的场景。*'
- en: '*This chapter is all about the enemy. No longer will the player be able to
    just sit in one place to gather points. We will be adding an enemy tank to the
    game. By using Unity''s NavMesh system, the tank will be able to do pathfinding
    and chase the player. Once found, the tanks will shoot and reduce the player''s
    score.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章全部关于敌人。玩家将不再能够只坐在一个地方来收集分数。我们将向游戏中添加一个敌方坦克。通过使用Unity的NavMesh系统，坦克将能够进行寻路并追逐玩家。一旦被发现，坦克就会开火并减少玩家的分数。*'
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: NavMesh
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NavMesh
- en: NaveMeshAgent
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaveMeshAgent
- en: Pathfinding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻路
- en: Chase and attack AI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追击和攻击人工智能
- en: Spawn points
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成点
- en: We will be adding modifications to the Tank Battle game from [Chapter 4](ch04.html
    "Chapter 4. Setting the Stage – Camera Effects and Lighting"), *Setting the Stage
    – Camera Effects and Lighting*, so open it up and we can begin.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对第四章中的坦克大战游戏进行修改，[第四章](ch04.html "第四章。搭建舞台 – 摄像机效果和照明")，*搭建舞台 – 摄像机效果和照明*，所以请打开它，我们可以开始。
- en: Understanding AI and pathfinding
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解人工智能和寻路
- en: '**AI** is, as you might have guessed, **artificial intelligence**. In the broadest
    sense this is anything an inanimate object might do to appear to be making decisions.
    You are probably most familiar with this concept from video games. When a character,
    not controlled by the player, selects a weapon to use and a target to use it on,
    this is AI.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**正如你可能猜到的，是**人工智能**。在广义上，这是任何非生命物体可能做的事情，以看起来像是在做决策。你可能最熟悉这个概念来自视频游戏。当一个角色，不是由玩家控制的，选择一个武器和一个目标来使用，这就是人工智能。'
- en: In its most complex form, AI attempts to mimic full human intelligence. However,
    there is still far too much happening incredibly fast for this to truly succeed.
    Video games do not need to reach nearly this far. We are primarily concerned with
    making our characters appear intelligent, but still conquerable by our players.
    Usually, this means not allowing characters to act on more information than a
    real player might have. Adjusting how much information characters have and can
    act on is a good way to adjust the level of difficulty in a game.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最复杂的形式中，人工智能试图模仿完整的人类智能。然而，仍有太多事情发生得非常快，以至于这很难真正成功。视频游戏不需要达到这种程度。我们主要关注的是让我们的角色看起来聪明，但仍然可以被我们的玩家征服。通常，这意味着不让角色根据比真实玩家可能拥有的更多信息来行动。调整角色拥有的信息和可以采取行动的信息量是调整游戏难度的好方法。
- en: '**Pathfinding** is a subset of AI. We use it all the time, though you have
    probably never realized it. Pathfinding is, as the word suggests, the act of finding
    a path. Every time you need to find your way between any two points, you are doing
    pathfinding. As far as our characters are concerned, the simplest form of pathfinding
    is to follow a straight line to the goal point. Obviously, this method works best
    on an open plain, but tends to fail when there are any obstacles in the way. Another
    method is to overlay the game with a grid. Using the grid, we can find a path
    that goes around any obstacles and reaches our target.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻路**是人工智能的一个子集。我们经常使用它，尽管你可能从未意识到这一点。正如其词义所示，寻路就是找到一条路径。每次你需要在你和任何两个点之间找到路径时，你就是在进行寻路。就我们的角色而言，最简单的寻路形式是沿着直线到目标点。显然，这种方法在开阔平原上效果最好，但如果有任何障碍物，这种方法就会失败。另一种方法是使用网格覆盖游戏。使用网格，我们可以找到一条绕过任何障碍物并达到目标的路径。'
- en: An alternative method of pathfinding, and perhaps the one most often chosen,
    makes use of a special navigation mesh, or NavMesh. This is just a special model
    that is never seen by the player but covers all of the area that a computer character
    can move around in. It is then navigated in a similar way to the grid, the difference
    being that the triangles of the mesh are used rather than the squares of the grid.
    This is the method we will be using in Unity. Unity provides a nice set of tools
    for creating the NavMesh and utilizing it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找的另一种方法，也许是最常选择的方法，是使用一个特殊的导航网格，或称为 NavMesh。这是一个玩家永远不会看到的特殊模型，但它覆盖了计算机角色可以移动的所有区域。然后以类似网格的方式导航，区别在于使用网格的三角形而不是网格的方形。这是我们将在
    Unity 中使用的方法。Unity 提供了一套很好的工具来创建 NavMesh 并利用它。
- en: The NavMesh
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NavMesh
- en: Creating the navigation mesh in Unity is very simple. The process is similar
    to the one we used for making lightmaps. We just mark some meshes to be used,
    adjust some settings in a special window, and hit a button. So, load up the Tank
    Battle game in Unity, if you haven't already done so, and we can get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中创建导航网格非常简单。这个过程与我们制作光照贴图的过程类似。我们只需标记一些网格用于使用，在一个特殊窗口中调整一些设置，然后点击一个按钮。所以，如果你还没有这样做，请加载
    Unity 中的坦克战斗游戏，我们就可以开始了。
- en: Time for action – creating the NavMesh
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 - 创建 NavMesh
- en: 'Unity can automatically generate a NavMesh from any meshes that exist in a
    scene. To do so, the mesh must first be marked as static, just as we did for lightmaps.
    However, we do not want or need to be able to navigate the roofs of our city,
    so we make use of a special list of settings for dictating what type of static
    each object will be:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 可以自动从场景中存在的任何网格生成 NavMesh。为此，网格必须首先被标记为静态，就像我们对光照贴图所做的那样。然而，我们不想或不需要能够导航我们城市的屋顶，因此我们使用一组特殊的设置来指定每个对象将是什么类型的静态：
- en: Select the city from the **Hierarchy** window and click on the down arrow to
    the right of **Static** in the **Inspector** window and we can take a look at
    the options available for static objects as follows:![Time for action – creating
    the NavMesh](img/2014OT_05_01.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 窗口中选择城市，然后在 **Inspector** 窗口中点击 **Static** 右侧的向下箭头，我们可以查看静态对象可用的选项如下：![Time
    for action – creating the NavMesh](img/2014OT_05_01.jpg)
- en: '**Nothing**: This option is used to quickly deselect all the other options.
    If all the others are unchecked, this one will be checked.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nothing**: 此选项用于快速取消选择所有其他选项。如果所有其他选项都被取消勾选，则此选项将被勾选。'
- en: '**Everything**: Using this option, you can quickly select all the other options.
    When all of them are checked, this one will also be checked. The checkbox next
    to the **Static** label in the **Inspector** window performs the same function
    as checking and unchecking the **Everything** checkbox.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Everything**: 使用此选项，您可以快速选择所有其他选项。当所有这些选项都被勾选时，此选项也会被勾选。**Inspector** 窗口中
    **Static** 标签旁边的复选框执行与勾选和取消勾选 **Everything** 复选框相同的操作。'
- en: '**Lightmap Static**: This option needs to be checked, when working with lightmaps,
    in order for them to work. Any mesh that does not have this checked will not be
    lightmapped.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lightmap Static**: 在使用光照贴图时，需要勾选此选项，以便它们能够正常工作。任何未勾选此选项的网格将不会进行光照贴图处理。'
- en: '**Occluder Static**: This is an option for working with occlusion. **Occlusion**
    is a method of runtime optimization that involves only rendering objects that
    can actually be seen whether or not they are within the camera''s view space.
    An **Occluder** is an object that will block other objects from being seen. It
    works in conjunction with the **Occludee Static** option. The best object choices
    for this option are large and solid.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Occluder Static**: 这是一个用于处理遮挡的选项。**Occlusion** 是一种运行时优化方法，它只渲染实际上可以看到的对象，无论它们是否在摄像机的视图空间内。**Occluder**
    是一个将阻止其他对象被看到的对象。它与 **Occludee Static** 选项协同工作。此选项的最佳对象选择是大型且坚固的。'
- en: '**Batching Static**: This is another option for runtime optimization. Batching
    is the act of grouping objects together before rendering them. It greatly increases
    the overall render speed of a game.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Batching Static**: 这是另一种运行时优化的选项。批处理是在渲染之前将对象分组的行为。它大大提高了游戏的整体渲染速度。'
- en: '**Navigation Static**: This is the option we are primarily concerned with at
    this point. Any mesh that has this option checked will be used when calculating
    the NavMesh.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Navigation Static**: 这是目前我们主要关注的选项。任何勾选了此选项的网格将在计算 NavMesh 时使用。'
- en: '**Occludee Static**: As mentioned a moment ago, this option works in conjunction
    with **Occluder Static** for the good of occlusion. An Occludee is an object that
    will be obscured by other objects. When covered by an Occluder, this object will
    not be drawn.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**被遮挡物静态**: 如前所述，此选项与**遮挡物静态**结合使用，以利于遮挡。被遮挡物是指将被其他物体遮挡的物体。当被遮挡物遮挡时，此物体将不会绘制。'
- en: '**Off Mesh Link Generation**: This option also works with the NavMesh calculation.
    An Off Mesh Link is a connection between two parts of the NavMesh that aren''t
    physically connected, such as the roof and the street. Using a few settings in
    the **Navigation** window and this option, the links are automatically generated.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离网链接生成**: 此选项也与NavMesh计算一起工作。离网链接是NavMesh两个物理上未连接的部分之间的连接，例如屋顶和街道。通过在**导航**窗口中使用一些设置和此选项，链接将自动生成。'
- en: 'In order to make the NavMesh work properly, we need to change the settings
    so that only the streets of the city can be navigated. When was the last time
    you saw a tank jump to or fall from the roof of a building? So, we need to change
    the **Static** options so that only the streets have **Navigation Static** checked.
    This can be done in one of the following two ways:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使NavMesh正常工作，我们需要更改设置，以便只有城市的街道可以导航。你上次看到坦克跳到或从建筑物的屋顶上下来是什么时候？因此，我们需要更改**静态**选项，以便只有街道有**导航静态**被选中。这可以通过以下两种方式之一完成：
- en: The first way is to go through and uncheck the option for each object we want
    changed.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是逐一取消我们想要更改的每个对象的选项。
- en: The second is to uncheck **Naviagation Static** for the top-level object in
    the **Hierarchy** window and, when Unity asks if we want to make the change for
    all children objects, reply with a yes. Then, go to just the objects that we want
    to navigate and recheck the option.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是取消**层次结构**窗口中顶级对象的**导航静态**选项，当Unity询问我们是否要为所有子对象进行更改时，回答“是”。然后，仅针对我们想要导航的对象重新选中此选项。
- en: Now, open the **Navigation** window by going to Unity's toolbar and clicking
    on **Window** followed by **Navigation** at the bottom of the menu. The following
    screenshot displays the window where all the work of making the NavMesh happens:![Time
    for action – creating the NavMesh](img/2014OT_05_02.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过访问Unity的工具栏并点击**窗口**，然后点击菜单底部的**导航**来打开**导航**窗口。以下截图显示了制作NavMesh的所有工作的窗口：![Time
    for action – creating the NavMesh](img/2014OT_05_02.jpg)
- en: 'This window consists of three pages and a variety of settings:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此窗口由三个页面和各种设置组成：
- en: When an object is selected, the settings will appear on the **Object** page.
    The two checkboxes correspond directly with the **Static** options of the same
    name that we set a moment ago. The drop-down list in **Navigation Layer** lets
    us use different layers for different parts of our NavMesh. These layers can be
    used to affect the pathfinding calculation. For example, a car can be set to only
    travel on a road layer and the human can follow the sidewalk layer.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择一个对象时，设置将出现在**对象**页面上。两个复选框直接对应于我们刚才设置的相同名称的**静态**选项。**导航层**下拉列表让我们可以为NavMesh的不同部分使用不同的层。这些层可以用来影响路径查找计算。例如，可以将汽车设置为仅在道路层上行驶，而人类可以跟随人行道层。
- en: The **Bake** page is the one we are interested in; it is full of options to
    change how the NavMesh is generated.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘焙**页面是我们感兴趣的一个页面；它充满了更改NavMesh生成方式的选项。'
- en: '**Radius**: This should be set to the size of the average character. It is
    used to keep characters from walking too close to the walls.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**半径**: 这应该设置为平均角色的尺寸。它用于防止角色走得太靠近墙壁。'
- en: '**Height**: This is the height of your characters. Using this, Unity can calculate
    and remove the areas that are too low for them to pass. Anything lower than this
    value is deemed too small.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**高度**: 这是角色的身高。使用此设置，Unity可以计算并移除角色无法通过的区域。任何低于此值的区域都被认为是太小了。'
- en: '**Max Slope**: Anything steeper than this value is ignored when calculating
    NavMesh.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最大坡度**: 在计算NavMesh时，任何比此值更陡峭的物体都将被忽略。'
- en: '**Step Height**: When making use of stairs, one must use this value. This is
    the maximum height of a stair that a character can step on.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步高**: 当使用楼梯时，必须使用此值。这是角色可以踩上的楼梯的最大高度。'
- en: '**Drop Height**: This is the height from which characters can fall. With it,
    paths will include jumping off ledges, if it is faster to do so. As you can tell
    from the screenshot, this is a Unity Pro-only feature.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下落高度**: 这是指角色可以坠落的高度。有了这个设置，路径将包括从边缘跳下的情况，如果这样做更快的话。从截图可以看出，这是一个Unity Pro独有的功能。'
- en: '**Jump Distance**: Using this value, characters can jump across gaps in NavMesh.
    This value represents the longest distance that can be jumped. As you can tell
    from the screenshot, this is a Unity Pro only feature.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**跳跃距离**: 使用这个值，角色可以在NavMesh中跳过间隙。这个值代表可以跳过的最长距离。从截图可以看出，这是一个Unity Pro独有的功能。'
- en: '**Min Region Area**: If parts of the NavMesh are too small, anything smaller
    than this value, they will not be used in the final NavMesh.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最小区域面积**: 如果NavMesh的部分区域太小，小于这个值的任何区域将不会被用于最终的NavMesh中。'
- en: '**Width Inaccuracy %**: When doing the NavMesh calculations, Unity makes use
    of a number of approximations. This is not entirely accurate, but it is fast.
    This value represents how much inaccuracy is allowed for the horizontal.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**宽度误差百分比**: 在进行NavMesh计算时，Unity使用了许多近似值。这并不完全准确，但速度很快。这个值代表水平方向允许的误差量。'
- en: '**Height Inaccuracy %**: This is the same as the previous settings, the difference
    being that it works for the vertical.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**高度误差百分比**: 这与之前的设置相同，区别在于它适用于垂直方向。'
- en: '**Height Mesh**: With this option checked, the original height information
    is maintained in NavMesh. Unless you have a special need of it, this option should
    remain off. It takes the system longer to calculate and requires more memory to
    store.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**高度网格**: 如果选中这个选项，原始的高度信息将保留在NavMesh中。除非你有特殊需求，否则这个选项应该保持关闭状态。它需要更长的时间来计算，并且需要更多的内存来存储。'
- en: The third page, **Layers**, allows us to adjust the cost of movement for each
    of our layers. Essentially, how difficult is it to move through different parts
    of our game world. With cars, we could adjust the layers, so it is twice as costly
    for them to move through the field as it is to move along the road.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三页，**层**，允许我们调整每个层的移动成本。基本上，移动通过我们游戏世界的不同部分有多难。对于汽车，我们可以调整层，使它们在田野中移动的成本是沿路的两倍。
- en: 'At the bottom of the window, we have two buttons:'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在窗口底部，我们有两个按钮：
- en: '**Clear**: This button removes the previously created NavMesh. After using
    this button, you will need to re-bake the NavMesh before you can make use of pathfinding
    again.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**清除**: 这个按钮删除之前创建的NavMesh。使用此按钮后，您需要重新烘焙NavMesh，然后才能再次使用路径查找。'
- en: '**Bake**: This button starts the work and creates the NavMesh.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**烘焙**: 这个按钮开始工作并创建NavMesh。'
- en: Our city is very simple, so the default values will suit us well enough. Hit
    **Bake** and watch the progress bar in the bottom-right corner. Once it is done,
    a blue mesh will appear. This is the NavMesh and, of course, represents all of
    the area that a character can move through.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的城市非常简单，所以默认值将足够适合我们。点击**烘焙**并观察右下角的进度条。一旦完成，会出现一个蓝色网格。这就是NavMesh，当然，代表了一个角色可以移动通过的所有区域。
- en: There is one last thing we need to do. Our NavMesh is just right but, if you
    look closely, it goes through the fountain in the center of the city. It would
    just be wrong if enemy tanks start driving through the fountain. To fix this,
    start by selecting the mesh that forms the wall around the fountain.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要做最后一件事。我们的NavMesh恰到好处，但如果仔细观察，它会穿过城市中心的喷泉。如果敌方坦克开始开进喷泉，那就太不合适了。为了修复这个问题，首先选择形成喷泉周围墙壁的网格。
- en: In the toolbar of Unity, click on **Component**, followed by **Navigation**,
    and finally **NavMeshObstacle**. This simply adds a component that tells the navigation
    system to go around when finding a path. Because we had the wall already selected,
    the new component is already sized to fit. You can see it represented as a wire
    cylinder in the **Scene** view.![Time for action – creating the NavMesh](img/2014OT_05_07.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity的工具栏中，点击**组件**，然后是**导航**，最后是**NavMeshObstacle**。这仅仅是一个组件，它告诉导航系统在寻找路径时绕行。因为我们已经选择了墙壁，所以新的组件已经调整大小以适应。你可以在**场景**视图中看到它表示为一个线框圆柱体。![创建NavMesh的行动时间](img/2014OT_05_07.jpg)
- en: '*What just happened?*'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created the NavMesh. We made use of the **Navigation** window and the **Static**
    options to tell Unity which meshes to use when calculating the NavMesh. The Unity
    team put a lot of work into making this process quick and easy.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了NavMesh。我们使用了**导航**窗口和**静态**选项来告诉Unity在计算NavMesh时使用哪些网格。Unity团队为此过程投入了大量工作，使其变得快速且简单。
- en: Have a go hero – creating extra obstacles
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼——创建额外障碍
- en: Remember, in [Chapter 3](ch03.html "Chapter 3. The Backbone of Any Game – Meshes,
    Materials, and Animations"), *The Backbone of Any Game – Meshes, Materials, and
    Animation*, when the challenge was to create obstacles for the player, you were
    encouraged to create additional meshes, such as tank traps and rubble. It would
    be a bad idea to let the enemy tanks drive through these, as well. So, have a
    go at turning these into obstacles for the navigation system. This will be done
    just as with the fountain.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在[第3章](ch03.html "第3章。任何游戏的骨架——网格、材质和动画")中，*任何游戏的骨架——网格、材质和动画*，当挑战是为玩家创建障碍时，你被鼓励创建额外的网格，例如坦克陷阱和碎石。让敌方坦克通过这些障碍是个坏主意。所以，尝试将这些转换为导航系统的障碍。这将与喷泉的做法一样。
- en: The NavMeshAgent component
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NavMeshAgent组件
- en: You might be thinking that it is all well and good that we have a NavMesh, but
    there are no characters to navigate it. In this section, we will start the creation
    of our enemy tank.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，我们有了NavMesh，但没有角色可以导航它。在本节中，我们将开始创建我们的敌方坦克。
- en: Time for action – creating the enemy
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建敌方坦克
- en: 'We will need to import and do a little setup on a second tank, before we can
    do any AI type programming:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何AI类型编程之前，我们需要导入并设置第二个坦克：
- en: Select `Tanks_Type03.png` and `Tanks_Type03.blend` from the starting assets
    for the chapter and import them to the `Tanks` folder under the `Models` folder.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从章节的起始资源中选择`Tanks_Type03.png`和`Tanks_Type03.blend`，并将它们导入到`Models`文件夹下的`Tanks`文件夹中。
- en: Once Unity has finished importing, select the new tank in the **Project** window
    and take a look at it in the **Inspector** window.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Unity完成导入，请在**项目**窗口中选择新的坦克，并在**检查器**窗口中查看它。
- en: This tank has no animations, so the **Animation Type** can be set to **None**
    and **Import Animation** can be unchecked from the **Rig** and **Animations**
    pages respectively.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这辆坦克没有动画，因此可以将**动画类型**设置为**无**，并分别从**骨架**和**动画**页面取消勾选**导入动画**。
- en: Drag the tank from the **Project** window to the **Scene** window; any clear
    patch of street will work just fine.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将坦克从**项目**窗口拖到**场景**窗口；任何清晰的街道区域都行。
- en: For starters, rename the model in the **Scene** view to `EnemyTank`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将**场景**视图中的模型重命名为`EnemyTank`。
- en: Now, we need to change the parenting of the tank so the turret can turn and
    the cannon will follow, just as we did for the player's tank. To do that, create
    an empty **GameObject** and rename it to `TurretPivot`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更改坦克的父级，以便炮塔可以旋转，炮管可以跟随，就像我们对玩家的坦克所做的那样。为此，创建一个空的**GameObject**并将其重命名为`TurretPivot`。
- en: Position `TurretPivot` to be at the base of the turret.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TurretPivot`定位在炮塔的底部。
- en: In the **Hierarchy** window, drag-and-drop `TurretPivot` onto `EnemyTank` to
    make `EnemyTank` the parent.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，将`TurretPivot`拖放到`EnemyTank`上，使`EnemyTank`成为父对象。
- en: Still in the **Hierarchy** window, make the cannon and turret mesh objects children
    of `TurretPivot`. When Unity asks whether you are sure that you want to break
    the prefab connection, be sure to click on **Yes**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**层次结构**窗口中，将炮管和炮塔网格对象设置为`TurretPivot`的子对象。当Unity询问你是否确定要断开预制件连接时，请确保点击**是**。
- en: The tank is a little large, so adjust the **Scale Factor** of the tank's Import
    Settings in the **Inspector** window to `0.6` to give us a tank that is about
    the size of the player's.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 坦克有点大，所以需要在**检查器**窗口中调整坦克的导入设置中的**缩放因子**为`0.6`，以得到大约与玩家大小相当的坦克。
- en: In order for the tank to be able to navigate our new NavMesh, we need to add
    a **NavMeshAgent** component. First, select `EnemyTank` in the **Hierarchy** window
    and then go to the toolbar of Unity; click on **Component**, followed by **Navigation**,
    and then click on **NavMeshAgent**. In the **Inspector** window, we can see the
    new component and the settings associated with it, as shown in the following screenshot:![Time
    for action – creating the enemy](img/2014OT_05_03.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让坦克能够导航我们的新NavMesh，我们需要添加一个**NavMeshAgent**组件。首先，在**层次结构**窗口中选择`EnemyTank`，然后转到Unity的工具栏；点击**组件**，然后点击**导航**，接着点击**NavMeshAgent**。在**检查器**窗口中，我们可以看到新的组件及其相关设置，如下面的截图所示：![创建敌方坦克的行动时间](img/2014OT_05_03.jpg)
- en: '**Radius**: This is simply how big the agent is. Working in conjunction with
    the **Radius** value we set in the **Navigation** window, this keeps the object
    from walking partly in the walls.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**：这仅仅是代理的大小。与我们在**导航**窗口中设置的**半径**值一起工作，这可以防止对象部分地走进墙壁。'
- en: '**Speed**: The **NavMeshAgent** component automatically moves the connected
    object when it has a path. This value dictates how fast to follow the path in
    units per second.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：当**NavMeshAgent**组件有路径时，它会自动移动连接的对象。此值决定了以每秒多少单位速度跟随路径。'
- en: '**Acceleration**: This is the maximum speed that the agent will accelerate
    with.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速度**：这是代理将加速到的最大速度。'
- en: '**Angular Speed**: This is the degrees per second that the agent can turn.
    A person would have a very high angular speed, while a car''s angular speed would
    be low.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角速度**：这是代理每秒可以转动的度数。人会有很高的角速度，而汽车的角速度会很低。'
- en: '**Stopping Distance**: This is how far away from the target destination the
    agent will start to slow down and stop.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止距离**：这是代理开始减速并停止距离目标目的地有多远。'
- en: '**Auto Traverse Off Mesh Link**: With this checkbox checked, the agent will
    use the Off Mesh Links when pathfinding, such as jumping gaps and falling off
    ledges.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动穿越离网链接**：勾选此复选框后，代理在路径查找时将使用离网链接，例如跳跃缺口和从边缘掉落。'
- en: '**Auto Braking**: With this checkbox checked, the agent will stop as soon as
    it reaches the destination, rather than overshooting, because of the irregular
    frame rate.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动制动**：勾选此复选框后，代理一到达目的地就会停止，而不是因为不规则的帧率而超过去。'
- en: '**Auto Repath**: If the path that was found is incomplete for any reason, this
    checkbox allows Unity to automatically try to find a new one.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重新规划路径**：如果找到的路径因任何原因不完整，此复选框允许Unity自动尝试找到一个新的路径。'
- en: '**Height**: This setting affects the cylinder that appears in the editor, around
    the agent. It simply sets the height of that cylinder.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度**：此设置影响编辑器中出现的围绕代理的圆柱体。它只是设置了该圆柱体的高度。'
- en: '**Base Offset**: This is the vertical offset of the colliders that are attached
    to the agent.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础偏移**：这是附加到代理上的碰撞器的垂直偏移。'
- en: '**Obstacle Avoidance Type**: This is how much effort the agent will put in
    to find a smooth path around obstacles. The higher the quality, the more work
    is done.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**障碍物避免类型**：这是代理在寻找绕过障碍物的平滑路径时将投入多少努力。质量越高，工作越多。'
- en: '**Avoidance Priority**: This value dictates who has the right of way. An agent
    with a high value will go around an agent with a low value.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免优先级**：此值决定了谁有通行权。值高的代理会绕过值低的代理。'
- en: '**NavMesh Walkable**: Remember those layers that were mentioned earlier when
    discussing the **Navigation** window? This is where we can set which layers the
    agent is able to traverse. Only the layers in this list that are checked will
    be used for pathfinding.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavMesh可通行**：还记得之前在讨论**导航**窗口时提到的那些层吗？这就是我们可以设置代理能够穿越的层的地方。只有在这个列表中勾选的层才会用于路径查找。'
- en: Now that we understand the settings, let's use them. For the enemy tank, a value
    of `2.4` for the **Radius** and `4` for the **Height** will work well. You should
    be able to see another wire cylinder in the **Scene** window, this time around
    our enemy tank.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经了解了设置，让我们来使用它们。对于敌方坦克，**半径**设置为`2.4`，**高度**设置为`4`将工作得很好。你应该能在**场景**窗口中看到另一个线形圆柱体，这次是在我们的敌方坦克周围。
- en: The last thing to do is to turn `EnemyTank` into a prefab. Do this just as we
    did with the targets, by dragging it from the **Hierarchy** window and dropping
    it on the `Prefabs` folder in the **Project** window.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要做的就是将`EnemyTank`转换为预制体。就像我们处理目标一样做，通过从**层次结构**窗口拖动它，并将其放置在**项目**窗口中的`Prefabs`文件夹上。
- en: '*What just happened?*'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created an enemy tank. We also learned about the settings for the **NavMeshAgent**
    component. However, if you try to play the game now, nothing will appear to happen.
    This is because the **NavMeshAgent** component is not being given a destination.
    We will solve that in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个敌人坦克。我们还了解了**NavMeshAgent**组件的设置。然而，如果你现在尝试玩游戏，什么都不会发生。这是因为**NavMeshAgent**组件没有被赋予一个目的地。我们将在下一节解决这个问题。
- en: The chase
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追逐
- en: Our next task is to make our enemy tank chase the player around. We will need
    two scripts. The first will simply advertise the player's current position. The
    second will use that position and the **NavMeshAgent** component that we set up
    earlier to find a path to the player.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是让我们的敌人坦克追逐玩家。我们需要两个脚本。第一个脚本将简单地广播玩家的当前位置。第二个脚本将使用那个位置和我们之前设置的**NavMeshAgent**组件来找到通往玩家的路径。
- en: Time for action – the player is over here
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 玩家在这里
- en: 'With a very short script, we can easily allow all our enemies know the location
    of the player:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个非常短的脚本，我们可以轻松地让所有敌人知道玩家的位置：
- en: Start by creating a new script in the `Scripts` folder of the **Project** window.
    Name it `PlayerPosition`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在**项目**窗口的`Scripts`文件夹中创建一个新的脚本。命名为`PlayerPosition`。
- en: This script will start with a single static variable. This variable will simply
    hold the current position of the player. Because it is static, we will be able
    to easily access it from the rest of our scripts.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本将从单个静态变量开始。这个变量将简单地保存玩家的当前位置。因为它是一个静态变量，所以我们可以轻松地从我们的其他脚本中访问它。
- en: '[PRE0]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the next lines of code, we make use of the `Start` function. This function
    is automatically called when a scene is first loaded. We use it so that the `position`
    variable can be filled and used as soon as the game starts.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于接下来的代码行，我们使用`Start`函数。当场景首次加载时，这个函数会自动被调用。我们使用它来确保`position`变量可以在游戏开始时立即填充并使用。
- en: '[PRE1]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last segment of code simply updates the `position` variable in every frame
    to the player's current position. We also do this in the `LateUpdate` function
    so that it is done after the player has moved. The `LateUpdate` function is called
    at the end of every frame. With that, the player is able to move during the `OnGUI`
    and `Update` functions and their position is updated later.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的最后一段只是将`position`变量在每一帧更新为玩家的当前位置。我们也在`LateUpdate`函数中这样做，以确保在玩家移动之后完成。`LateUpdate`函数在每个帧的末尾被调用。这样，玩家就可以在`OnGUI`和`Update`函数期间移动，并且他们的位置稍后会被更新。
- en: '[PRE2]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last thing to do with this script is to add it to the player's tank. So,
    return to Unity and drag-and-drop the script from the Project window to the tank
    to add it as a component, just as we have done with all our other scripts.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个脚本的最后一步是将它添加到玩家的坦克上。所以，回到Unity，从项目窗口拖放脚本到坦克上，就像我们之前对所有的其他脚本所做的那样，添加它作为一个组件。
- en: '*What just happened?*'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the first script needed for our chase AI. This script simply updates
    a variable with the player's current position. We will make use of it in our next
    script, where we will make the enemy tank move around.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为追逐AI创建了第一个必要的脚本。这个脚本只是更新一个变量，该变量包含玩家的当前位置。我们将在下一个脚本中使用它，我们将让敌人坦克四处移动。
- en: Time for action – chasing the player
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 追逐玩家
- en: 'Our next script will control our simple chase AI. Because we are making use
    of the **NavMesh** and **NavMeshAgent** components, we can leave nearly all the
    difficult portions of pathfinding to Unity:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的脚本将控制我们的简单追逐AI。因为我们正在使用**NavMesh**和**NavMeshAgent**组件，我们可以将路径查找的大部分困难部分留给Unity：
- en: Again, create a new script. This time name it `ChasePlayer`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次创建一个新的脚本。这次给它命名为`ChasePlayer`。
- en: The first line for this script simply holds a reference to the **NavMeshAgent**
    component that we set up earlier. We need access to this component in order to
    move the enemy.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本的第一个代码行只是保存了我们之前设置的**NavMeshAgent**组件的引用。我们需要访问这个组件来移动敌人。
- en: '[PRE3]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last segment of code first makes sure that we have our **NavMeshAgent**
    reference and then updates our goal destination. It uses the `PlayerPosition`
    script's variable, that was set up earlier, and the `SetDestination` function
    from the **NavMeshAgent**. Once we tell the function where to go, the **NavMeshAgent**
    component does all the hard work of getting us there. We are updating our goal
    destination in the `FixedUpdate` function because we do not need to update the
    destination in every frame. Updating too often could cause a serious lag if there
    are a whole lot of enemies. The `FixedUpdate` function is called at regular intervals
    and is slower than the frame rate, so it is perfect.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的最后部分首先确保我们有了**NavMeshAgent**引用，然后更新我们的目标目的地。它使用之前设置的`PlayerPosition`脚本变量和**NavMeshAgent**的`SetDestination`函数。一旦我们告诉函数去哪里，**NavMeshAgent**组件就会做所有艰难的工作，带我们到那里。我们在`FixedUpdate`函数中更新目标目的地，因为我们不需要在每一帧都更新目的地。更新太频繁可能会导致严重的延迟，如果有很多敌人。`FixedUpdate`函数以固定间隔调用，比帧率慢，所以它很完美。
- en: '[PRE4]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now need to add the script to our enemy tank. Select the `prefab` in the
    **Project** window, and drag-and-drop the script in the **Inspector** panel, underneath
    the **NavMeshAgent** component.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要将脚本添加到我们的敌人坦克中。在**项目**窗口中选择`prefab`，并将脚本拖放到**检查器**面板中，位于**NavMeshAgent**组件下方。
- en: Be sure to connect the reference, as we have done previously. Drag the **NavMeshAgent**
    component to the **Agent** value in the **Inspector** window.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一定要连接引用，就像我们之前做的那样。将**NavMeshAgent**组件拖到**检查器**窗口中的**代理**值。
- en: Play the game now to try it out. Wherever the enemy starts, it finds its way
    around all the buildings and makes it to the player's position. As you drive around,
    you can watch the enemy follow. However, the enemy tank ends up going through
    our tank. Also, we can drive through it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在玩游戏来尝试一下。无论敌人从哪里开始，它都会绕过所有建筑并到达玩家的位置。当你驾驶时，你可以观察敌人跟随。然而，敌人坦克最终穿过了我们的坦克。而且，我们也可以穿过它。
- en: The first step to fixing it is to add some colliders. Add a **Box Collider**
    component from underneath **Physics** in the **Component** menu to the turret,
    chassis, and each of the **TreadCase** objects. Neither the cannon nor the treads
    need colliders. The tread casings already cover the area of the treads, and the
    cannon is too small a target to be shot at properly.![Time for action – chasing
    the player](img/2014OT_05_08.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复这个问题的第一步是添加一些碰撞器。从**组件**菜单下的**物理**中添加一个**盒子碰撞器**组件到炮塔、底盘以及每个**履带箱**对象。大炮和履带不需要碰撞器。履带箱已经覆盖了履带的区域，而大炮的目标太小，无法被正确射击。![行动时间
    – 追踪玩家](img/2014OT_05_08.jpg)
- en: Note
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are making any of these changes in the **Scene** view, be sure to click
    on the **Apply** button in the **Inspector** window to update the root prefab
    object.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在**场景**视图中进行任何这些更改，请确保在**检查器**窗口中点击**应用**按钮来更新根预制对象。
- en: The last thing to change is the **Stopping Distance** property on the **NavMeshAgent**
    component. When the tanks fight, they move into range and start firing. They do
    not try to occupy the same space as the enemy, unless that enemy is small and
    squishy. By setting **Stopping Distance** to `10` we are able to replicate this
    behavior.![Time for action – chasing the player](img/2014OT_05_04.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要更改的是**NavMeshAgent**组件上的**停止距离**属性。当坦克战斗时，它们进入射程并开始射击。它们不会试图占据与敌人相同的空间，除非那个敌人很小且柔软。通过将**停止距离**设置为`10`，我们能够复制这种行为。![行动时间
    – 追踪玩家](img/2014OT_05_04.jpg)
- en: '*What just happened?*'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In this section, we created a script that causes a **NavMeshAgent** component,
    in this case our enemy tank, to chase the player. We added colliders to stop us
    from driving through the enemy. And, we adjusted the **Stopping Distance** to
    give us a better tank behavior.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个脚本，使**NavMeshAgent**组件，在这种情况下是我们的敌人坦克，去追逐玩家。我们添加了碰撞器以阻止我们穿过敌人。我们还调整了**停止距离**以获得更好的坦克行为。
- en: Have a go hero – adding shadow
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄般的动作 – 添加阴影
- en: Try adding a blob shadow to the enemy tank. This will give it a better visual
    sense of being grounded. You can just copy the one that was made for the player's
    tank.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试给敌人坦克添加一个阴影。这将给它一个更好的视觉上的接地感。你可以直接复制为玩家坦克制作的那个。
- en: Being attacked
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被攻击
- en: What fun is a game without a little conflict; the nagging choice, the fight
    to the death, the doom of the cosmos? Every game needs some form of conflict to
    drive the player towards seeking a resolution. Our game will become a battle for
    points. Before, it was just shoot some targets and get some points.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 没有冲突的游戏有什么乐趣；那令人烦恼的选择，那场殊死搏斗，那宇宙的末日？每个游戏都需要某种形式的冲突来驱使玩家寻求解决方案。我们的游戏将变成一场争夺分数的战斗。在此之前，它只是射击一些目标并获得一些分数。
- en: Now, we will make the enemy tank shoot at the player. Every time the enemy scores
    a hit, we will reduce the player's score by a few points.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将让敌方坦克射击玩家。每次敌人击中，我们将减少玩家几分。
- en: Time for action – getting ready to fire
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 准备射击
- en: 'The enemy will shoot in a similar manner to how the player fires, but we will
    use some basic AI to control the direction and firing speed, replacing the player''s
    input controls:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人将以与玩家射击相似的方式射击，但我们将使用一些基本的 AI 来控制方向和射击速度，以替换玩家的输入控制：
- en: We will start this off with a new script called `ShootAtPlayer`. Create it in
    the `Scripts` folder.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从这个名为 `ShootAtPlayer` 的新脚本开始。在 `Scripts` 文件夹中创建它。
- en: As with all our other scripts, we start this one out with two variables. The
    first variable will hold the last position the enemy tank was at. It will not
    be shooting if the tank is in motion, so we need to store that last position to
    see if we have moved. The second variable will be the maximum speed at which we
    can move and shoot. If the tank moves faster than this, it will not fire.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们所有的其他脚本一样，我们从这个脚本开始时有两个变量。第一个变量将保存敌方坦克的最后位置。如果坦克在移动，它将不会射击，因此我们需要存储那个最后位置以查看我们是否移动了。第二个变量将是我们可以移动和射击的最大速度。如果坦克移动得比这个速度快，它将不会开火。
- en: '[PRE5]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next two variables dictate how long it takes the tank to ready a shot. It
    is unrealistic to be shooting the player in every single frame. So, we use the
    first variable to adjust the length of time it takes to ready a shot, and the
    second to store when the shot is ready.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下两个变量决定了坦克准备射击所需的时间。在每一帧都射击玩家是不现实的。因此，我们使用第一个变量来调整准备射击所需的时间长度，第二个变量来存储射击何时准备就绪。
- en: '[PRE6]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next variable is how fast the turret can rotate. While the tank is readying
    its shot, the turret will not be rotating to point at the player. That gives the
    player an opportunity to move out of the way. However, we need a speed to keep
    the turret from snapping to face the player after shooting.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个变量是炮塔旋转的速度。当坦克准备射击时，炮塔不会旋转指向玩家。这给了玩家一个移动避开的机会。然而，我们需要一个速度来防止炮塔在射击后立即转向面对玩家。
- en: '[PRE7]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last two variables here hold references to other parts of the tank. The
    `turretPivot` variable, of course, is the pivot of the turret that we will be
    rotating. The `muzzlePoint` variable will be used as the point from where our
    cannon is fired. These will be used in the same manner as the ones for the player's
    tank.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里最后两个变量持有坦克其他部分的引用。`turretPivot` 变量当然是我们要旋转的炮塔的旋转点。`muzzlePoint` 变量将用作我们的炮火发射点。这些将按照与玩家坦克相同的模式使用。
- en: '[PRE8]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the first function of the script, we will make use of the `Update` function.
    It starts by calling a function that will check to see whether it is possible
    to fire the cannon. If we can fire, we perform some checks on our `readyTime`
    variable. If it is less than zero, we have not yet begun to ready our shot and
    call a function to do so. Otherwise, if it is less than the current time, we have
    finished the preparation and call the function to fire the cannon. If we are unable
    to fire, we first call a function to clear any preparations and then rotate the
    turret to face the player.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于脚本的第一个功能，我们将使用 `Update` 函数。它首先调用一个函数来检查是否可以发射炮火。如果我们能发射，我们会对我们的 `readyTime`
    变量进行一些检查。如果它小于零，我们还没有开始准备射击，并调用一个函数来这样做。否则，如果它小于当前时间，我们已经完成了准备，并调用一个函数来发射炮火。如果我们不能发射，我们首先调用一个函数来清除任何准备，然后旋转炮塔面对玩家。
- en: '[PRE9]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we will create our `CheckCanFire` function. The first part of code checks
    to see if we have moved too fast. First, we use `Vector3.Distance` to see how
    far we have moved since the last frame. By dividing the distance by the length
    of the frame, we are able to determine the speed with which we moved. Next, we
    update our `lastPosition` variable with our current position, so it is ready for
    the next frame. Finally, we compare the current speed with the `maxSpeed`. If
    we moved too fast in this frame, we are unable to fire and return a result of
    `false`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的`CheckCanFire`函数。代码的第一部分检查我们是否移动得太快。首先，我们使用`Vector3.Distance`来查看自上一帧以来我们移动了多远。通过将距离除以帧的长度，我们能够确定我们移动的速度。然后，我们使用当前的位置更新我们的`lastPosition`变量，以便它为下一帧做好准备。最后，我们将当前速度与`maxSpeed`进行比较。如果我们在这帧中移动得太快，我们就无法射击并返回一个`false`的结果。
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For the second half of the `CheckCanFire` function, we check to see if the turret
    is pointed at the player. First, we find the direction to the player. Given any
    point in space and subtracting the second point's location from it, will give
    us the direction from the second point to the first as a vector. We then flatten
    the direction by setting the `y` value to `0`. This is done because we do not
    want to be looking up or down at the player. Then, we use `Vector3.Angle` to find
    the angle between the direction to the player and our turret's forward direction.
    Finally, we compare the angle to a low value to determine whether we are looking
    at the player, and return the result.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`CheckCanFire`函数的第二部分，我们检查炮塔是否指向玩家。首先，我们找到指向玩家的方向。给定空间中的任何点，从它减去第二个点的位置，将给出从第二个点到第一个点的方向向量。然后，我们通过将`y`值设置为`0`来简化方向。这是因为在玩家上下看时我们不想这样做。然后，我们使用`Vector3.Angle`来找到指向玩家方向和我们的炮塔前进方向之间的角度。最后，我们将角度与一个低值进行比较，以确定我们是否在看着玩家，并返回结果。
- en: '[PRE11]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `PrepareFire` function is quick and easy. It simply sets our `readyTime`
    variable to the time in the future when the tank will be done preparing its shot.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PrepareFire`函数简单快捷。它只是将我们的`readyTime`变量设置为坦克完成射击准备的未来时间。'
- en: '[PRE12]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Fire` function starts by making sure that we have a `muzzlePoint` reference
    to shoot from.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Fire`函数首先确保我们有一个可以从中射击的`muzzlePoint`引用。'
- en: '[PRE13]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function continues with the creation of a `RaycastHit` variable to store
    the result of our shot. We use `Physics.Raycast` and `SendMessage`, just as we
    did in the `FireControls` script, to shoot at anything and tell it that we hit
    it.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数继续创建一个`RaycastHit`变量来存储射击结果。我们使用`Physics.Raycast`和`SendMessage`，就像我们在`FireControls`脚本中做的那样，射击任何东西并告诉它我们击中了它。
- en: '[PRE14]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Fire` function finishes by clearing the fire preparations.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Fire`函数通过清除射击准备来完成。'
- en: '[PRE15]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `ClearFire` function is another quick function. It sets our `readyTime`
    variable to be less than zero, indicating that the tank is not preparing to fire.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClearFire`函数是另一个快速函数。它将我们的`readyTime`变量设置为小于零，表示坦克没有准备射击。'
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last function for the script is `RotateTurret`. It begins by checking the
    `turretPivot` variable and canceling the function should the reference be missing.
    It is followed by the finding of the flat direction that points at the player,
    just as we did earlier. Next, we create the `step` variable to hold how much we
    can move this frame. We use `Vector3.RotateTowards` to find a vector that is closer
    to pointing at our target than the current forward direction is. Finally, we use
    `Quaternion.LookRotation` to create a special rotation that points our turret
    in the new direction.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本中的最后一个函数是`RotateTurret`。它首先检查`turretPivot`变量，如果引用缺失则取消函数。接着，它找到指向玩家的平面方向，就像我们之前做的那样。然后，我们创建`step`变量来保存这一帧我们可以移动的距离。我们使用`Vector3.RotateTowards`找到一个比当前前进方向更接近指向目标的向量。最后，我们使用`Quaternion.LookRotation`创建一个特殊的旋转，使炮塔指向新的方向。
- en: '[PRE17]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, returning to Unity, create an empty **GameObject** and rename it to `MuzzlePoint`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到Unity中，创建一个空的**GameObject**并将其重命名为`MuzzlePoint`。
- en: Position `MuzzlePoint` as we did for the player, at the end of the cannon.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MuzzlePoint`的位置设置为我们为玩家所做的，在炮管末端。
- en: Make `MuzzlePoint` a child of the cannon and zero out any **Y** rotation that
    might be on it, in the **Inspector** window.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MuzzlePoint`设置为炮管的子对象，并在**Inspector**窗口中将其任何**Y**旋转归零。
- en: Next, add our new `ShootAtPlayer` script to the enemy tank. Additionally, connect
    the references to the `TurretPivot` and `MuzzlePoint` variables.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将我们的新`ShootAtPlayer`脚本添加到敌方坦克上。此外，连接到`TurretPivot`和`MuzzlePoint`变量的引用。
- en: Finally, for the enemy tank, hit the **Apply** button in the **Inspector** window
    to update the prefab.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于敌人坦克，在**检查器**窗口中点击**应用**按钮以更新预制体。
- en: If you play the game now, you will see the enemy rotating to point at you, but
    your score never decreases. This is because of two issues. First, the tank is
    slightly floating. It doesn't matter where in the world you place it, when playing
    the game, the tank will slightly float. This is because of the way the NavMeshAgent
    component functions. The fix is simple, just set the **Base Offset** to `-0.3`
    in the **Inspector** window. This tricks the system and puts the tank on the ground.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，你会看到敌人旋转指向你，但你的分数从未减少。这是因为两个问题。首先，坦克略微漂浮。无论你在世界的哪个地方放置它，在玩游戏时，坦克都会略微漂浮。这是因为NavMeshAgent组件的工作方式。修复方法是简单的，只需在**检查器**窗口中将**基础偏移**设置为`-0.3`。这会让系统上当，并将坦克放在地面上。
- en: The second reason the score isn't changing is because the player is missing
    a function. Open the `ScoreCounter` script.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个原因是分数没有变化是因为玩家缺少一个函数。打开`ScoreCounter`脚本。
- en: We will be adding the `RemovePoints` function. Given an amount, this function
    simply removes that many points from the player's score.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加`RemovePoints`函数。给定一个数值，这个函数简单地从玩家的分数中减去这么多分数。
- en: '[PRE18]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Time for action – getting ready to fire](img/2014OT_05_05.jpg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动起来——准备射击](img/2014OT_05_05.jpg)'
- en: '*What just happened?*'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We gave the enemy the ability to attack the player. The new `ShootAtPlayer`
    script checks first to see whether the tank has slowed down and whether the cannon
    is trained on the player. If so, it will take regular shots at the player to reduce
    their score. The player is going to need to keep moving and aim at targets fast,
    if they hope to be left with any points at the end of the game.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们赋予了敌人攻击玩家的能力。新的`ShootAtPlayer`脚本首先检查坦克是否减速以及大炮是否对准了玩家。如果是这样，它将对玩家进行常规射击以减少他们的分数。如果玩家希望在游戏结束时保留任何分数，他们需要不断移动并快速瞄准目标。
- en: Have a go hero – player feedback
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试——玩家反馈
- en: Unless you are paying close attention to your score, it is difficult to tell
    when you are being shot at. We will be working with explosions in a future chapter
    but, even so, the player needs some feedback to tell what is going on. Most games
    will flash a red texture on the screen when the player is hit, whether or not
    there are any explosions. Try creating a simple texture and drawing it on the
    screen for half a second when the player is hit.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你密切关注你的分数，否则很难判断你是否正在被射击。我们将在未来的章节中处理爆炸，即使如此，玩家也需要一些反馈来了解发生了什么。大多数游戏会在玩家被击中时在屏幕上闪烁红色纹理，无论是否有爆炸。尝试创建一个简单的纹理，并在玩家被击中时在屏幕上绘制半秒钟。
- en: Attacking the enemy
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击敌人
- en: Players tend to become frustrated quickly when faced with an enemy they are
    unable to fight against. So, we are going to give our player the ability to hurt
    and destroy the enemy tank. This will function in a similar manner to the way
    the targets are shot.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对无法与之战斗的敌人时，玩家往往会很快感到沮丧。因此，我们将赋予玩家伤害和摧毁敌人坦克的能力。这将以类似于射击目标的方式工作。
- en: Time for action – giving it a weakness
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动起来——赋予它弱点
- en: 'The easiest way to weaken our enemies is to give them some health that is reduced
    when they are shot, and to destroy them when they run out of health:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的敌人变弱的最简单方法是为它们提供一些生命值，当它们被射击时会减少，当生命值耗尽时摧毁它们：
- en: We start by creating a new script and naming it `Health`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的脚本，并将其命名为`Health`。
- en: This script is rather short and starts with a single variable. This variable
    will keep track of the remaining health of the tank. By setting the default value
    to `3`, the tank will be able to survive three hits before being destroyed.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本相当简短，并且从一个单一变量开始。这个变量将跟踪坦克剩余的生命值。通过将默认值设置为`3`，坦克在被摧毁之前能够承受三次攻击。
- en: '[PRE19]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This script also contains only one function, `Hit`. As in the case of the targets,
    this function is called by the `BroadcastMessage` function when the player shoots
    at it. The first line of the function reduces `health` by one point. The next
    line checks to see if `health` is below zero. If it is, the tank is destroyed
    by calling the `Destroy` function and passing it the `gameObject` variable. We
    also give the player a handful of points.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本也只包含一个函数，`Hit`。就像目标的情况一样，当玩家射击它时，这个函数由`BroadcastMessage`函数调用。函数的第一行将`health`减少一点。下一行检查`health`是否低于零。如果是，通过调用`Destroy`函数并传递`gameObject`变量来销毁坦克。我们还给玩家一些分数。
- en: '[PRE20]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It really is just that simple. Now, add the new script to the `EnemyTank` prefab
    in the **Project** window, and it will update all the enemy tanks that you currently
    have in the scene.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的是这样简单。现在，将新脚本添加到**项目**窗口中的`EnemyTank`预制体，它将更新场景中当前所有的敌方坦克。
- en: Try it out. Add a few extra enemy tanks to the scene and watch them follow you
    around and disappear when you shoot them.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一下。在场景中添加几个额外的敌方坦克，并观察它们围绕你移动，在你射击它们时消失。
- en: '*What just happened?*'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We gave the enemy tank a weakness, health. By creating a short script, the tank
    is able to track its health and detect when it has been shot. Once the tank runs
    out of health, it is removed from the game.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给敌方坦克一个弱点，即生命值。通过创建一个简短的脚本，坦克能够跟踪其生命值并检测它是否被射击。一旦坦克的生命值耗尽，它将从游戏中移除。
- en: Have a go hero – coloring the enemy
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄般的操作——为敌人着色
- en: 'We now have two targets to shoot at: the animated ones and the tank. However,
    they are both indicated with red slices. Try to make the ones that point at tanks
    be a different color. You will have to make a duplicate of the `IndicatorSlice`
    prefab and change the `IndicatorControl` script so that it can be told which type
    of slice to use when the `CreateSlice` and `NewSlice` functions are called.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个射击目标：动画目标和坦克。然而，它们都由红色切片指示。尝试使指向坦克的切片颜色不同。你将需要复制`IndicatorSlice`预制体并修改`IndicatorControl`脚本，以便在调用`CreateSlice`和`NewSlice`函数时能够指定使用哪种类型的切片。
- en: As a further challenge, the moment we give a creature some health, players want
    to be able to see how much damage they have done to it. There are two ways you
    could do this. First, you could put a cluster of cubes above the tank. Then, each
    time the tank loses health, you delete one of the cubes. The second option is
    a little more difficult, drawing the bar in the GUI and changing its size based
    on the remaining health. To make the bar stay above the tank as the camera moves
    around, take a look at `Camera.WorldToScreenPoint`, in the documentation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的挑战，当我们给一个生物一些生命值时，玩家希望能够看到他们对其造成的伤害量。你可以有两种方法来做这件事。首先，你可以在坦克上方放置一个立方体簇。然后，每次坦克失去生命值时，就删除一个立方体。第二种选项稍微复杂一些，在GUI中绘制条形并根据剩余的生命值改变其大小。为了使条形在摄像机移动时保持在坦克上方，请查看文档中的`Camera.WorldToScreenPoint`。
- en: Spawning
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成
- en: Having a limited number of enemies in the game, at the beginning, is not suitable
    for our game to have lasting fun. Therefore, we need to make some spawn points.
    As tanks are destroyed, these will issue forth new tanks to keep the player on
    their toes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时，游戏中的敌人数量有限并不适合我们的游戏以保持持久的乐趣。因此，我们需要创建一些生成点。随着坦克被摧毁，这些生成点将产生新的坦克，以保持玩家保持警惕。
- en: Time for action – creating spawns
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建生成点
- en: 'The script we will be creating in this section will keep our game world populated
    with all the enemies our player might want to destroy:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将创建的脚本将保持我们的游戏世界充满玩家可能想要摧毁的所有敌人：
- en: We need another new script for this section. Once created, name it `SpawnPoint`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为这部分创建另一个新的脚本。一旦创建，将其命名为`SpawnPoint`。
- en: This script begins simply with a few variables. The first variable will hold
    a reference to our `EnemyTank` prefab. We need it so we can spawn duplicates.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本简单地开始，定义了几个变量。第一个变量将保存对`EnemyTank`预制体的引用。我们需要它来生成副本。
- en: '[PRE21]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second variable tracks the spawned tank. When it is destroyed we will create
    a new one. Using this variable we prevent the game from becoming overwhelmed with
    the enemy. There will only be as many tanks as spawn points.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个变量跟踪生成的坦克。当它被销毁时，我们将创建一个新的坦克。使用这个变量，我们防止游戏被敌人淹没。坦克的数量将和生成点一样多。
- en: '[PRE22]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The third variable is for setting a distance from the player, to prevent spawning
    tanks on top of the player. If the player is outside this distance, a new tank
    can be spawned. If they are within, a new tank will not be spawned.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个变量用于设置玩家距离，以防止在玩家上方生成坦克。如果玩家在这个距离之外，可以生成一个新的坦克。如果他们在里面，则不会生成新的坦克。
- en: '[PRE23]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first function we will use is `FixedUpdate`. It will start by checking a
    function to see whether it needs to spawn a new tank. If it does, it will call
    the `SpawnTank` function to do so.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用第一个函数是`FixedUpdate`。它将首先检查一个函数，看是否需要生成一个新的坦克。如果需要，它将调用`SpawnTank`函数来生成。
- en: '[PRE24]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we create the `CanSpawn` function. The first line of the function checks
    to see whether we already have a tank and returns `false` if we do. The second
    line uses `Vector3.Distance` to determine how far away the player currently is.
    The last line compares that distance to the minimum distance away that the player
    needs to be before we can spawn anything and returns the result.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`CanSpawn`函数。函数的第一行检查我们是否已经有了坦克，如果有，则返回`false`。第二行使用`Vector3.Distance`来确定玩家当前的距离。最后一行将这个距离与玩家需要到达的最小距离进行比较，以确定我们是否可以生成任何东西，并返回结果。
- en: '[PRE25]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The last function, `SpawnTank`, starts by checking to make sure the `tankPrefab`
    reference has been connected. It can't continue if there is nothing to spawn.
    The second line uses the `Instantiate` function to create a duplicate of the prefab.
    In order to store it in our variable, we use `as GameObject` to make it the proper
    type. The last line moves the new tank to the spawn point's position. We don't
    want the tanks appearing in random locations.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数，`SpawnTank`，首先检查确保`tankPrefab`引用已经被连接。如果没有东西可以生成，它将无法继续。第二行使用`Instantiate`函数创建预制体的副本。为了将其存储在我们的变量中，我们使用`as
    GameObject`使其成为正确的类型。最后一行将新坦克移动到生成点的位置。我们不希望坦克出现在随机的位置。
- en: '[PRE26]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Return to Unity, create an empty **GameObject**, and rename it to `SpawnPoint`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，创建一个空的**GameObject**，并将其重命名为`SpawnPoint`。
- en: Add the `SpawnPoint` script that we just created, to it.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚创建的`SpawnPoint`脚本添加到其中。
- en: Next, with the spawn point selected, connect the prefab reference by dragging
    the `EnemyTank` prefab from the `Prefabs` folder and dropping it on the appropriate
    value.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择生成点，通过从`Prefabs`文件夹中将`EnemyTank`预制体拖动并放置在适当的值上，连接预制体引用。
- en: Now, turn the `SpawnPoint` object into a prefab, by dragging-and-dropping it
    from the **Hierarchy** window and into the `Prefabs` folder.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过从**Hierarchy**窗口拖动并放置到`Prefabs`文件夹中，将`SpawnPoint`对象转换为预制体。
- en: Finally, populate the city with the new points. Positioning one in each corner
    of the city will work well.![Time for action – creating spawns](img/2014OT_05_06.jpg)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用新的点填充城市。在每个角落放置一个点将工作得很好。![行动时间 - 创建生成点](img/2014OT_05_06.jpg)
- en: '*What just happened?*'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created spawn points for the game. Each point will spawn a new tank. When
    a tank is destroyed, a new one is created at the spawn point. Feel free to build
    the game and try it out on your device. This section and chapter are now complete
    and ready for wrap up.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为游戏创建了生成点。每个点都会生成一个新的坦克。当一个坦克被摧毁时，在生成点处会创建一个新的坦克。你可以自由地构建游戏并在你的设备上尝试它。本节和本章现在已完成，准备总结。
- en: Have a go hero – two for one
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼 - 一对二
- en: Having one spawn point per tank is great, until we want many tanks. Or, we desire
    them to all spawn in the same location. Your challenge here is to make a single
    spawn point track multiple tanks. If any one of the tanks is destroyed, a new
    one should be created. You will definitely need an array to keep track of all
    the tanks. Also, implement a delay for the spawn. We don't want it spawning multiple
    tanks on top of each other.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个坦克有一个生成点很好，直到我们想要很多坦克。或者，我们希望它们都在同一个位置生成。这里的挑战是让一个生成点跟踪多个坦克。如果任何一个坦克被摧毁，应该创建一个新的。你肯定需要一个数组来跟踪所有的坦克。还要实现一个生成延迟。我们不希望它一次生成多个坦克。
- en: Now that you have all the knowledge and tools that you need, as a further challenge,
    try creating other types of enemy tanks. Experiment with size and speed. They
    can also have different strengths, or give more points when destroyed. Perhaps
    there is a tank that actually gives the player points when shooting at them. Play
    around and have some fun with it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了所有需要的知识和工具，作为一个进一步的挑战，尝试创建其他类型的敌方坦克。实验一下大小和速度。它们也可以有不同的强度，或者在摧毁时获得更多分数。也许有一种坦克在玩家射击它们时会给玩家加分。玩一玩，享受其中的乐趣。
- en: Pop Quiz – understanding enemies
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 - 理解敌人
- en: Q1\. Probably the most common act performed in games is shooting with guns.
    We have done it a couple of times now. Do you remember what function we use to
    determine where and what our bullet might hit?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 在游戏中，最常见的行为可能是使用枪支射击。我们已经做过几次了。你还记得我们用来确定子弹可能击中哪里和什么的函数吗？
- en: '`Input.mousePosition`'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.mousePosition`'
- en: '`Transform.position`'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Transform.position`'
- en: '`Physics.Raycast`'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Physics.Raycast`'
- en: Q2\. We will need a great many enemies running around for us to shoot at. Do
    you remember which function we use to make them move around our NavMesh?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 我们需要许多敌人四处奔跑，以便我们可以射击它们。你还记得我们用来让它们在NavMesh上移动的函数吗？
- en: '`CharacterController.Move`'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CharacterController.Move`'
- en: '`NavMeshAgent.SetDestination`'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NavMeshAgent.SetDestination`'
- en: '`NavMesh.CalculatePath`'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NavMesh.CalculatePath`'
- en: Q3\. Finally, all these enemies will have to be spawned again and again. Do
    you remember what function we use to spawn these enemies?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 最后，所有这些敌人将不得不一次又一次地被生成。你还记得我们用来生成这些敌人的函数吗？
- en: '`Instantiate`'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Instantiate`'
- en: '`Destroy`'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Destroy`'
- en: '`Start`'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Start`'
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about NavMeshes and pathfinding. We also did a little
    work with AI. It was perhaps among the simplest types of AI but chase behaviors
    are highly important to all types of games. To utilize all of this, we created
    an enemy tank. It chased the player and shot at them to reduce their score. To
    give the edge back to the player, we gave health to the enemy tanks. The player
    can now shoot the enemy tanks as well as the targets for points. But, we also
    created some spawn points. Every time a tank was destroyed a new one will be created.
    In terms of general game play, our Tank Battle game is pretty much complete.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了NavMesh和路径查找。我们还做了一些与AI相关的工作。这可能是最简单的AI类型之一，但追逐行为对所有类型的游戏都至关重要。为了利用所有这些，我们创建了一个敌方坦克。它追逐玩家并向他们射击以减少他们的分数。为了给玩家一些优势，我们给敌方坦克增加了生命值。现在，玩家可以射击敌方坦克以及目标以获得分数。但是，我们也创建了一些生成点。每次坦克被摧毁时，都会创建一个新的坦克。从一般游戏玩法来看，我们的坦克大战游戏几乎已经完成。
- en: In the next chapter, we will be creating a new game. In order to explore some
    of the special features of the mobile platform, we will create a Space Fighter
    game. Nearly all the buttons will be removed from the screen, in favor of new
    control methods. We will be turning the device's tilt sensors into our steering
    method. And, we will have to touch enemies and targets to shoot at them. We will
    also take a look at a different methods of spawning to give the player an endless
    amount of space to fly through.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个新的游戏。为了探索移动平台的一些特殊功能，我们将创建一个太空战斗机游戏。几乎所有的按钮都将从屏幕上移除，以支持新的控制方法。我们将把设备的倾斜传感器转换成我们的转向方法。而且，我们必须触摸敌人来射击它们。我们还将探讨不同的生成方法，为玩家提供无尽的飞行空间。
