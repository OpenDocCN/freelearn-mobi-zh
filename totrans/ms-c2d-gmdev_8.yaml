- en: Chapter 8. Exploring Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final chapter of this book, if your heart so desires, you can start learning
    Swift, Apple's new programming language. Here, you'll get a brief overview of
    what Swift is, how the language works, and some various syntax differences between
    Objective-C and Swift. We'll also cover the creation of a few simple apps using
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Swift works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning Swift through Playgrounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cocos2d-Swift to create a game in Swift instead of Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter will not cover most of Swift. It is instead intended as an introduction
    to coding in Swift through Cocos2d to create a game with this engine.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that Swift, as a language, is only compatible with iOS 7 and above.
    If you intend to support iOS 6 or prior, you cannot use Swift in your project.
  prefs: []
  type: TYPE_NORMAL
- en: How Swift works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main difference between Objective-C and Swift is in the way it looks. It
    still feels like Objective-C (in the sense that you can call all of the same methods),
    but the syntax is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to call this in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you end up calling the following in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Also, instead of using a header and a main file as in Objective-C, there's only
    a `.swift` file that gets used for everything.
  prefs: []
  type: TYPE_NORMAL
- en: There are obviously some syntax differences that you'll have to learn about
    when it comes to coding in Swift, but those who are familiar with Objective-C
    will pick up Swift quite easily. Don't worry, even if you aren't familiar with
    Objective-C. Swift is an easy-to-learn language, which makes picking it up much
    better.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, let's cover some syntax differences using Apple's new tool
    they created to help learn and debug Swift—Playgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Swift through Playgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playgrounds offer a way to test your Swift code quickly and easily without much
    baggage that usually comes when creating a test project in another language. They're
    intended as files used for prototyping and quick fiddling with code if you have
    problems with a small section. They're really easy to use and understand, so let's
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing you'll notice about Swift is that there are no semicolons required
    (except when writing multiple statements on one line, which must be separated
    by semicolons). That's right—none! They're optional, but the preferred style of
    writing Swift code is without semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: Also, when coding if statements, loops, switch statements, and so on, you must
    use curly braces around the block of code that will be run (even if there's only
    one line of code that will be executed).
  prefs: []
  type: TYPE_NORMAL
- en: Right now, go ahead and open the `SwiftSyntax.playground` file in the `Sample
    Projects` folder included with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you cannot open the file within Xcode, update your version of Xcode to the
    newest version, as your version might be outdated.
  prefs: []
  type: TYPE_NORMAL
- en: When you open this file in Xcode, you'll see a lot of things happening. It's
    separated via comment lines (`// ------`). Each section represents a different
    set of syntax differences between Objective-C and Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not explicitly stated what the Objective-C equivalent is, you
    can see how to declare a variable, how to run loops, create and call functions,
    and so on. Also, not all the syntax differences with Swift are included here.
    Only the most common uses of the language appear here.
  prefs: []
  type: TYPE_NORMAL
- en: With the playground file opened, let's see how Playgrounds are organized so
    that you can better understand what's going on (and why Playgrounds are useful
    for purposes besides just being a place to hold code).
  prefs: []
  type: TYPE_NORMAL
- en: How Playgrounds are organized
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The left side obviously has the code. The right side has a description of the
    state of the code; for example, if it's a variable, it will show the variable's
    value. If it's a `println` statement (the standard way to print the console in
    Swift), it will display the output.
  prefs: []
  type: TYPE_NORMAL
- en: If you type any new code in the Playground, you'll see the Playground's right-hand-side
    pane update as you type. If you copy and paste any code, you'll see all the lines
    updated with the final result of each line.
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a Playground, we don't have to worry about using a `println`
    or `NSLog` statement here. It will automatically show up on the right-hand side
    of the Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the results over time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the cool things about using Playgrounds is that you can track the progress
    of your loops over time. For example, if you want to see each item that was printed
    in the names array, or what the value of a variable is in each iteration, you
    can see it visually with the Playground's **Value History** button.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you want to debug your own Swift code in a project (and not just a
    Playground), you can bring it into a playground and observe the results over time.
    So if you have, say, an enemy patrolling back and forth with a loop, you can use
    the Playground's value history to see each value (in this case, position) at each
    iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, go to the `for` loop section (approximately line 90), and find the
    line that says total `+= x` within the `for` loop, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the results over time](img/image00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To view, move your mouse arrow onto the (100 times) line in the right-hand-side
    pane, and you should see two buttons appear on the right side of it. The first
    is an eyeball that will show you every value that a given object contains. For
    example, if you have a dictionary, you can view all the key/value pairs in that
    dictionary, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the results over time](img/image00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second button is the **Value History** button. When your mouse arrow is
    on it, it will turn into a **+** button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the results over time](img/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on this button, you''ll see a chart showing the values of that
    variable over time as the loop iterates (you''ll also see the output console,
    which displays the names being printed as expected, from the previous loop) as
    shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the results over time](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to get more details of how your variable changes over time, you
    can either drag the red scrubber to the bottom of the **Value History** section,
    or click on any data point along the chart to see its respective value, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the results over time](img/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Learning more about Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of content on Swift that wasn't covered here, such as lazy variables,
    the identity operator, the nil coalescing operator, class initializers, inheritance,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Some great places to learn more about Swift include [www.lynda.com](http://www.lynda.com)
    (a great course on Swift is at [www.lynda.com/Swift-tutorials/Swift-Essential-Training/180105-2.html](http://www.lynda.com/Swift-tutorials/Swift-Essential-Training/180105-2.html))
    and [www.raywenderlich.com/tutorials](http://www.raywenderlich.com/tutorials),
    which have many online courses and tutorials that go over the basic and advanced
    features of Swift. You can also look at Apple's developer videos; just search
    for Swift at [https://developer.apple.com/videos/wwdc/2014/.](https://developer.apple.com/videos/wwdc/2014/.)
    Then there are sample projects, the Swift developer blog at [https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/),
    as well as other websites such as Stack Overflow.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, Playgrounds can be very useful for developers who are
    just learning Swift, as well as those who are more experienced and wish to test
    their code for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: But a Playground isn't an app all by itself, so let's make a simple game using
    Swift as our language for Cocos2d. Again, you'll notice that the code itself is
    fairly similar to Objective-C; only the syntax is slightly different, so you should
    pick it up fairly quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a game in Swift instead of Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind using Cocos2d-Swift is to switch over to the new programming
    language, right? Even though the Swift version of Cocos2d is still relatively
    new, and everything might not be implemented by the time you read this book, it
    can still be used as the core language when creating a game. So let's make a very
    simple game here, building upon the core concepts you just learned and combining
    them with the knowledge you already have of how the Cocos2d engine works in general.
  prefs: []
  type: TYPE_NORMAL
- en: Why use Swift instead of Objective-C? Because, you should be staying up to date
    with the latest technologies in the field, and Swift is just the next step in
    that direction. Also, as the years pass by, Apple may slowly deprecate and stop
    supporting Objective-C (but that's just a theory).
  prefs: []
  type: TYPE_NORMAL
- en: In general, it helps to know more languages if the opportunity calls for it.
    And if you're interested in web development, Swift feels very similar to JavaScript,
    so it's like learning two languages at once.
  prefs: []
  type: TYPE_NORMAL
- en: So why Cocos2d-Swift specifically? For the same reasons you just read. Also,
    typing code in Swift is generally faster than in Objective-C, and so, if you can
    create code faster, you can, in theory, create games faster, which is awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Goal of the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game we're going to make consists of a turret in the center that can shoot
    bullets, a score counter, and square-shaped enemies that come in from the left
    and the right. If the enemies make it to the center, it's game over! As the score
    increases, so will the spawn rate of enemies, eventually overwhelming the turret's
    fire rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few screenshots of the game we''ll be making:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Goal of the game](img/image00305.jpeg)![Goal of the game](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Starting a new Swift project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember, the way to start Cocos2d projects now is by going through SpriteBuilder.
    Even though we won't be using SpriteBuilder for any code, we still have to go
    through the process of creating a project there.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in SpriteBuilder, go to **File** | **New** | **Project**. Select the location
    where you want to create the project, name it something like `TurretGame`, and
    make sure you select **Swift** as the language. This is also shown in the following
    screenshot for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting a new Swift project](img/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in `Turret Game`, go to the `Assets` folder of this book''s content,
    and drag the `Images` folder into the resources list on the left side of SpriteBuilder
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting a new Swift project](img/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After it has been imported to SpriteBuilder, right-click (or press *Ctrl* and
    click) on the `Images` folder in SpriteBuilder, and select **Make Smart Sprite
    Sheet**. This is what TexturePacker normally does for us. However, we can speed
    up the process using SpriteBuilder's auto sheet maker, since this is only going
    to be an example project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting a new Swift project](img/image00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once it has turned into a sprite sheet, the folder icon should be of a pinkish
    color with a smiley on it. Now, go to **File** | **Publish** so that SpriteBuilder
    can generate the necessary files for our project and we can be on our way.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the font files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, SpriteBuilder is lame at the time of writing this book and doesn't
    handle BMFonts very well. So, what we're going to do instead of having SpriteBuilder
    handle the sizing/exporting is create our own BMFont and manually add it to our
    list of files. This might not be the most efficient way, but it works, so we're
    going with it.
  prefs: []
  type: TYPE_NORMAL
- en: In this book's project folder, you should see a list of folders such as `resources-hd`
    and so on next to the `Images` folder you dragged into SpriteBuilder. Copy all
    four of these folders and paste them in the iOS `Resources` folder of your project
    files. When it asks you, make sure you click on **Merge** (as well as **Apply
    to All**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the font files](img/image00310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will add the font files for each size type to the respective folder so
    that Cocos2d's directory search mode can find the correct size based on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Bridging-Header and loading MainScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objective-C, when working with Swift files, needs something called a `Bridging-Header`
    file. It's automatically created, so all we have to do is import the file. The
    format of the file is `ProjectName-Swift.h`, where `ProjectName` is the name of
    your project (for example, if the project is called `TurretGame`, we'll use `TurretGame-Swift.h`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, feel free to open the Xcode project. Open `AppDelegate.m` and, at the
    top of the file, add the import statement to add the `Bridging-Header` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `StartScene` method, we need to change the line of code that will
    transition to the main scene (as well as add a line that will read in our images
    sheet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We're using `node` here instead of `Scene` because we're calling a `Swift` class.
    In the previous examples in this book, the `Scene` method was a method we created,
    whereas `node` is a predefined function that does the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the background, turret, and score label
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because Swift is intended to be short and to the point when it comes to readability,
    the following code is all that is required in the `MainScene.swift` file in order
    to get a white background, an image to display, and a label at the bottom of the
    screen (note the `CCScene` inheritance; the default is `CCNode`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the project at this point, and you'll see exactly what we described as our
    result. If you're starting to appreciate how little code it takes to make stuff
    happen, then Swift just might be your language to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to getting the turret to rotate.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the turret with touchMoved
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice so far how just about all the classes and methods are named exactly the
    same, with minor syntax differences between Objective-C and Swift. It's going
    to be the same for our `touchBegan`, `touchMoved`, and `touchEnded` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a variable to store the player''s touch position. So,
    at the top of `MainScene`, add the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `init()` method, set the user interaction Boolean to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following methods to `MainScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game, you'll be able to drag your finger around and rotate the
    turret in the direction of your finger.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting some bullets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ours is not a very useful turret unless it's shooting bullets, so let's write
    that code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want a method we can call (or schedule). We want to make it spawn
    a bullet and then launch it in the direction of our finger (where the turret is
    pointing). So go ahead and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we now have this function that will create a bullet and launch it
    along a path, we have no way of testing it yet. So, in our `touchBegan` method,
    we add a call to schedule the selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in our `touchEnded` method, we add a call to `unschedule` the selector
    (as we don''t want the turret to shoot constantly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you're wondering why the selector is in quotes, let me tell you that that's
    just the syntax of Swift. Instead of explicitly stating the function, you have
    to pass the function name as a string, and Swift handles the rest.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game at this point, you'll watch those bullets go rocketing out
    of the turret when you drag your finger across the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning enemies and sending them towards the center
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want some enemies to shoot at, so let''s create a method that will spawn
    an enemy along either the left or right wall, and send it to the center of the
    screen (where the turret is), over a period of 3 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It's great that we have a method to spawn enemies, but there are none currently
    spawning. So, just like the `shootBullet` function we scheduled, we must schedule
    the `spawnEnemy` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `init()` method, add the following line of code to spawn the enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There we go! Now we have our enemies spawning. But even if they make it to their
    final position, nothing happens. Let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to GameOver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an enemy gets near the center (after the action completes), we want our
    game to be over, so let's create a `GameOverScene` class, and transition to it
    when an enemy reaches their end position.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new file by hitting *Command* + *N* (or **File** | **New** |
    **File**). Select **Cocoa Touch Class** by navigating to **iOS** | **Source**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transitioning to GameOver](img/image00311.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then name it `GameOverScene`, and make sure you choose **Swift** as the language.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transitioning to GameOver](img/image00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Save it in the `Source` folder of your project, and it will automatically open
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace your `GameOverScene` class with the following, which will set the background
    to white, create a label in the center of the screen, enable touches, and transition
    back to `MainScene` when the screen is tapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to test this scene, add the following `replaceScene` call to the closure
    (or code block) of the enemy''s move action in `MainScene.swift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Hmmm! Except now that it transitions properly, it's not much of a game, since
    we can't stop the enemies with the bullets we're shooting. Let's fix that!
  prefs: []
  type: TYPE_NORMAL
- en: Handling collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a ton of different ways to handle collisions, but the way we're going
    to handle them is by using the bounding box of our bullets and the enemies. To
    do that, we're going to set up two arrays (one for enemies and one for bullets)
    and a function to loop through the arrays and check for bounding box intersections.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add two variables for the arrays. We''re going to use `NSMutableArray`
    instead of Swift''s arrays because Swift''s array allows us to remove an item
    only via its index, and not by passing the item itself. So, it will be easier
    with `NSMutableArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add our bullets and enemies to their respective array (as well
    as handle their removal from the array). So, in our `shootBullet` and `spawnEnemy`
    functions, we add the objects to the array, as well as remove the bullet from
    the array right before we remove it from the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to create a function that will loop through our arrays and check
    for collisions. If a collision is found, we will remove both objects from the
    arrays (and the screen) and break out of the loop so that we don't accidentally
    go out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following function in the `MainScene.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to schedule this function so that it will be called frequently
    enough when our bullets interact with the enemies, and the collision will get
    detected at the right time. To do that, simply schedule it in the `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Run the game at this point, and you'll see the bullets colliding properly. But
    no! It's not much of a game without a score counter. So let's add that to this
    example game in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Counting the score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All we need is a variable that tracks our score and a label to display it. Arguably,
    you can also have this on the game over scene, but we're not going to worry about
    that in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at the top of our `MainScene` class, we create two variables as described,
    and then add the label to the screen in the `init()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the `update` function, which gets automatically called by
    Cocos2d:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to increase the score by `100` for every enemy that dies, so in
    the `checkForCollisions` function, we simply add `100` to the score variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game at this point, you'll see the score increasing as time goes
    on, as well as when any enemy gets hit by a bullet. The only thing left to do
    is make the game harder over time (because it's rather boring at the moment).
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the difficulty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally (although it doesn''t entirely matter for the purpose of making the
    example work), we want our difficulty to increase over time so that only the best
    players can make it far. We''re going to do this by increasing the rate at which
    units spawn (every 2,000 points, to be exact). First, we want some variables to
    hold the current spawn rate as well as the amount of points accrued since the
    last increase in difficulty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must replace the hardcoded value of `0.35` with the `spawnRate` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time we increase our `score` variable, we must also increase the
    `scoreSinceLastIncrease` variable. So in `update` as well as `checkForCollisions`,
    we need to add the same amount to both the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to check inside our update: method whether the score since
    the last difficulty increase has crossed our limit (in this case, we''re going
    to increase it after every 2,000 points earned). To do this, we''ll just `unschedule`
    the `spawnEnemy` function, reduce `spawnRate` (only to a certain amount), and
    `re-schedule` the `spawnEnemy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Run the game at this point and watch as more and more units come flooding into
    the view, eventually overwhelming you.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! We've just made a very simple game in Cocos2d but with the help
    of Swift this time. It's not the best or most fun game in the world but it counts.
    Plus, this example was more of a way to show you how to go ahead and make games
    using Swift as your core language instead of Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make use of playgrounds and create a basic
    game using Cocos2d and Swift.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, if you wish to learn more about Swift, there's a plethora
    of available online resources at your disposal—online courses, Apple-created content,
    as well as online communities that provide assistance as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Happy coding!
  prefs: []
  type: TYPE_NORMAL
