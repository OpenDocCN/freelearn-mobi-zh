- en: <st c="0">2</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Simplifying Our Entities with SwiftData</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="41">Let’s start our journey to mastering iOS 18 with one of the most
    important and useful frameworks Apple has released in the last few years –</st>
    <st c="182">SwiftData.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="192">SwiftData</st>** <st c="202">is an</st> <st c="209">excellent
    example of Swift macro usage, taking the old and beloved Core Data framework to
    a whole new level of simplicity and adapting it to the modern world of Swift and</st>
    <st c="380">declarative programming.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="404">In this chapter, we will do</st> <st c="433">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="447">Understand the</st> <st c="463">SwiftData background</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="483">Define a data model, including its relationships</st> <st c="533">and
    attributes</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="547">Learn about the SwiftData container</st> <st c="584">and configurations</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="602">Fetch and manipulate data using the</st> <st c="639">model context</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="652">Migrate our data to new</st> <st c="677">version schemas</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="692">It’s going to be a long ride with an exciting new framework!</st>
    <st c="754">So, after the technical requirements, let’s start with some background
    on</st> <st c="828">the framework.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="842">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="865">This chapter includes many code examples, some of which can be found
    in the following</st> <st c="952">GitHub repository:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[<st c="970">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202)'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1056">To run them, we will need Xcode 16</st> <st c="1092">or newer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1101">Understanding SwiftData’s background</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1138">To understand SwiftData’s background and its roots, it’s important
    to go one step backward and</st> <st c="1234">learn about the</st> **<st c="1250">Core</st>**
    **<st c="1255">Data</st>** <st c="1259">framework.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1270">Core Data has been the primary data framework for Apple platforms
    for many years, even before iOS</st> <st c="1369">was born.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1378">Core Data was</st> <st c="1393">added to iOS in iOS 3, bringing
    the power of handling a data graph to mobile devices flexibly and efficiently.</st>
    <st c="1504">Note that I haven’t mentioned the word</st> *<st c="1543">database</st>*
    <st c="1551">or</st> *<st c="1555">persistency</st>*<st c="1566">, and that’s
    for a good reason.</st> <st c="1598">We should remember that Core Data is not
    an</st> **<st c="1642">SQLite</st>** <st c="1648">wrapper, even though its persistent
    store is based on SQLite in most cases.</st> <st c="1725">The primary goal of
    Core Data is to handle our app’s</st> <st c="1778">data layer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1789">But what does it mean to handle the app’s data layer?</st> <st
    c="1844">Well, most apps work with several layers – the UI, business logic, and
    data layer.</st> <st c="1927">The data layer is built upon data entities that
    define the core items that our app works with.</st> <st c="2022">For example,
    a to-do app can have entities such as a</st> *<st c="2075">list</st>*<st c="2079">,</st>
    *<st c="2081">task,</st>* <st c="2086">or</st> *<st c="2090">reminder</st>*<st
    c="2098">. A music app can have entities such as an</st> *<st c="2141">album</st>*<st
    c="2146">,</st> *<st c="2148">song</st>*<st c="2152">,</st> <st c="2154">or</st>
    *<st c="2157">playlist</st>*<st c="2165">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2166">The data layer defines the different entities and how they are
    related.</st> <st c="2239">For example, an album can contain many songs, and a
    list can contain many tasks.</st> <st c="2320">if there’s a need for persistence,
    the data layer also handles how the different entities’ data is saved to disk.</st>
    <st c="2434">According to our understanding of a data layer, Core Data fulfills
    its role as an app data layer by defining its data model, handling persistency,
    migrations, and even undo operations.</st> <st c="2619">So, if Core Data is such
    an excellent framework for handling data, why do we</st> <st c="2696">need SwiftData?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2711">Core Data is a great framework, but it was designed for different
    times when we used to code with Objective-C, and UIkit hadn’t even been created.</st>
    <st c="2859">Ever since then, the iOS development world has changed significantly
    – we now have Swift, and moreover, we have SwiftUI.</st> <st c="2980">Even though
    Core Data has received updates to support Swift and SwiftUI, it still felt outdated
    in a world of type-safety, multithreading, and declarative programming.</st> <st
    c="3148">Fetching and observing data changes have become cumbersome in Core Data,
    as we use design patterns more suitable for the UIkit/Objective-C era.</st> <st
    c="3292">In this context, SwiftData promises to bring a modern, straightforward
    framework to handle data much more flawlessly, using the full power of Swift</st>
    <st c="3440">and Combine.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3452">One of the best things about SwiftData is that it uses</st> *<st
    c="3508">Swift macros</st>* <st c="3520">– the same Swift macros we learned about
    in</st> [*<st c="3565">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)<st
    c="3575">. The macros help us elegantly implement SwiftData without using</st>
    <st c="3640">boilerplate code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3657">It’s time to get into business and create our first</st> <st c="3710">SwiftData
    models!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3727">Defining a SwiftData model</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3754">Usually, when</st> <st c="3769">discussing a data framework, it
    is common to start with the basic setup.</st> <st c="3842">However, this time,
    we will begin with the model itself.</st> <st c="3899">Why is that?</st> <st c="3912">Because
    I want to demonstrate how simple and easy it is to convert an existing data model
    to a SwiftData model, using the following piece</st> <st c="4050">of code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4294">In this code, we see a standard</st> `<st c="4327">Book</st>` <st
    c="4331">class, with the addition of a macro named</st> `<st c="4374">@Model</st>`<st
    c="4380">. Before we expand the</st> `<st c="4403">@Model</st>` <st c="4409">macro
    and see what it does precisely, let’s focus on what happens when we</st> <st c="4484">add
    it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4491">Adding the</st> `<st c="4503">@Model</st>` <st c="4509">macro is
    all it takes to convert a regular class into a model backed with a persistent
    store.</st> <st c="4604">Similar to how Core Data entities work, the class name
    is the entity name, and its variables are the</st> <st c="4705">entity attributes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4723">When we</st> <st c="4732">compare that to Core Data, we can see
    that the model declaration process is backward – in Core Data, we declare the
    model in the model editor and then generate its class, whereas in SwiftData, we
    take a regular class and make it</st> <st c="4961">a model.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4969">But what does</st> `<st c="4984">@Model</st>` <st c="4990">macro
    really do?</st> <st c="5008">Let’s expand it</st> <st c="5024">and see.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5032">Expanding the @Model macro</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5059">We already</st> <st c="5071">know what a Swift Macro is capable
    of, and SwiftData is a great chance to explore a new</st> <st c="5159">macro implementation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5180">To expand the macro, we can right-click on the</st> `<st c="5228">@Model</st>`
    <st c="5234">name and select</st> **<st c="5251">Expand Macro</st>** <st c="5263">from
    the pop-up menu.</st> <st c="5286">The class body now looks</st> <st c="5311">like
    this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="6354">So, what happened</st> <st c="6373">to our beautiful and minimal</st>
    `<st c="6402">Book</st>` <st c="6406">class?</st> <st c="6414">It appears that
    the</st> `<st c="6434">@Model</st>` <st c="6440">macro has been quite</st> <st
    c="6462">active here.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6474">To simplify it, let’s try to break</st> <st c="6510">it down:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="6523">Book</st>``<st c="6598">PersistentModel</st>` <st c="6613">and</st>
    `<st c="6618">Observable</st>`<st c="6628">. The</st> `<st c="6634">PersistentModel</st>`
    <st c="6649">protocol helps SwiftData work with our style and access its attributes.</st>
    <st c="6722">The</st> `<st c="6726">Observable</st>` <st c="6736">protocol allows
    us to be notified of changes to</st> <st c="6785">the data.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="6914">PersistentModel</st>` <st c="6929">protocol is, we will discover
    that it requires the implementation of two variables –</st>`<st c="7014">backingData</st>`
    <st c="7026">and</st> `<st c="7031">schemaMetaData</st>`<st c="7045">. We can
    see their implementation directly in our macro-expanded code.</st> <st c="7116">These
    variables help SwiftData to store and retrieve our entity information specifically
    for our properties.</st> <st c="7225">And perhaps this is where the real power
    of Swift Macro comes into play – the ability to generate code that is custom-made
    for</st> <st c="7352">our class.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="7362">We have property macros</st>**<st c="7386">: If we look at the
    class properties, we can see that they have their macros now.</st> <st c="7469">Expanding
    them reveals that they have now become a computed variable, so we can store and
    retrieve data not from just our memory but also from our backing</st> <st c="7624">data
    store:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="7756">Additional lines</st> <st c="7774">of code wrap everything together,
    such as the observation and</st> <st c="7836">registering attributes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7859">Is this complicated?</st> <st c="7881">A little bit.</st> <st c="7895">But
    that’s one of the benefits of having a macro – to simplify complex implementations.</st>
    <st c="7983">What’s important to understand is that every class marked with a</st>
    `<st c="8048">@Model</st>` <st c="8054">macro immediately receives a store of
    its own and is added to the</st> <st c="8121">SwiftData schema.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8138">However, to add a more complex data model, we need to be able to
    define relationships between our models.</st> <st c="8245">Let’s see how</st>
    <st c="8259">it works.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8268">Adding relationships</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="8289">Unlike real life, in SwiftData, relationships</st> <st c="8336">are
    simple.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8347">A</st> **<st c="8350">relationship</st>** <st c="8362">is a</st>
    <st c="8368">database scheme that defines how entities are linked to each other,
    and in Core Data, we have two types of relationships –</st> **<st c="8491">to-one</st>**
    <st c="8497">and</st> **<st c="8502">to-many</st>**<st c="8509">. In short, a</st>
    *<st c="8523">to-one</st>* <st c="8529">relationship means that we will have one
    instance of the other kind for each entity instance.</st> <st c="8624">An example
    of that would be cars and engines – every car has one, and only one, engine, so
    that will make the relationship between them a</st> *<st c="8762">to-one</st>*
    <st c="8768">relationship.</st> <st c="8783">However, cars and wheels have a</st>
    *<st c="8815">to-many</st>* <st c="8822">relationship because a car can have</st>
    <st c="8859">multiple wheels.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8875">Even though the explanation is simple enough, it gets even simpler
    in SwiftData.</st> <st c="8957">If we want to define a relationship between models,
    we just need to create another variable, as</st> <st c="9053">shown here:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="9317">In our</st> <st c="9325">example, we added the following two properties
    to the</st> `<st c="9379">Book</st>` <st c="9383">class:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="9390">Author</st>`<st c="9397">: This is a</st> *<st c="9410">to-one</st>*
    <st c="9416">relationship to the</st> `<st c="9437">Author</st>` <st c="9443">entity
    because, in our case, each book has only</st> <st c="9492">one author</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="9502">pages</st>`<st c="9508">: In the case of</st> `<st c="9526">Page</st>`
    <st c="9530">entity, we</st> <st c="9542">have a</st> *<st c="9549">to-many</st>*
    <st c="9556">relationship, since a book can contain</st> <st c="9596">multiple
    pages</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9610">One thing to note is that we also need to mark both</st> `<st c="9663">Page</st>`
    <st c="9667">and</st> `<st c="9672">Author</st>` <st c="9678">entities with the</st>
    `<st c="9697">@Model</st>` <st c="9703">macro, as they must be part of our schema.</st>
    <st c="9747">This can be seen in the</st> <st c="9771">following code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="9990">Is adding</st> <st c="10001">models so simple?</st> <st c="10019">The
    short answer is, yes!</st> <st c="10045">Linking entities to each other in SwiftData
    is as easy as adding</st> <st c="10110">a property.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10121">The longer answer is, well, we’ll have to do extra work to customize
    the relationships a little bit.</st> <st c="10223">Let’s meet the</st> `<st c="10238">@</st>``<st
    c="10239">Relationship</st>` <st c="10251">macro.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10258">If you’re familiar with Core Data relationships, you probably
    know there is more than declaring</st> *<st c="10355">to-many</st>* <st c="10362">and</st>
    *<st c="10367">to-one</st>*<st c="10373">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10374">To-many and to-one relationships</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10407">To-one relationships</st> <st c="10429">represent associations
    between entities where</st> <st c="10475">one instance of an entity is related
    to another single instance of a different entity.</st> <st c="10562">Conversely,
    to-many relationships represent associations where one instance of an entity can
    be related to multiple instances of another entity.</st> <st c="10707">For example,
    in a bookstore database, a to-one relationship could connect a “book” entity to
    an “author” entity, as each book has one author.</st> <st c="10849">In contrast,
    a to-many relationship could connect a “book” entity to a “category” entity, as
    a book can belong to</st> <st c="10963">multiple categories.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10983">We can customize our relationship using the</st> `<st c="11028">@Relationship</st>`
    <st c="11041">macro in two</st> <st c="11055">primary ways.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11068">Let’s start with defining the</st> <st c="11099">deletion rules.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11114">SwiftData relationship deletion rules</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11152">What happens to</st> `<st c="11169">pages</st>` <st c="11174">and</st>
    `<st c="11179">author</st>` <st c="11185">entities if we delete a book?</st> <st
    c="11216">Logically, all the book pages</st> <st c="11246">need to be deleted,
    but the author needs to be retained because they might be linked to another book.</st>
    <st c="11348">We can represent this logic with</st> *<st c="11381">deletion rules</st>*<st
    c="11395">; if you’re familiar with Core Data, it is basically the same as</st>
    <st c="11461">in SwiftData.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11474">This is how we can define the logic to a property</st> <st c="11525">in
    SwiftData:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '@Model'
  prefs: []
  type: TYPE_NORMAL
- en: class Book {
  prefs: []
  type: TYPE_NORMAL
- en: '… <st c="13124">@Relationship(inverse: \Page.book) var pages: [Page] =</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13178">[]</st> …
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Model'
  prefs: []
  type: TYPE_NORMAL
- en: class Page {
  prefs: []
  type: TYPE_NORMAL
- en: 'var content: String <st c="13225">var book: Book?</st> init(content: String)
    {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.content = content
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: \Page.book
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'let newPage = Page(content: "Swift Data")'
  prefs: []
  type: TYPE_NORMAL
- en: newPage.book = book
  prefs: []
  type: TYPE_NORMAL
- en: // book.pages property <st c="13678">contains</st> 'newPage'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '@Model'
  prefs: []
  type: TYPE_NORMAL
- en: class Folder {
  prefs: []
  type: TYPE_NORMAL
- en: 'var parent: Folder? @Relationship(inverse: \Folder.parent) var subFolders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Folder]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var name: String'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var id: UUID'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'init(parent: Folder? = nil, subFolders: [Folder], name:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'String, id: UUID) {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.parent = parent
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.subFolders = subFolders
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.name = name
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.id = id
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'var firstName: String? = "MyName"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17295">@Attribute</st> macro with the <st c="17321">.unique</st> option
    makes our database’s specific property values unique.
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="17389">UUID</st>` <st c="17394">is a classic example of a unique value
    for a property, but we can apply that to any other type of property, such as user
    IDs</st> <st c="17520">and names.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="17530">But what does it really mean to make a property</st> *<st c="17579">unique</st>*<st
    c="17585">? What will happen when we try to insert an instance with an already
    existing</st> <st c="17663">unique attribute?</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="17680">In the case of a unique property, SwiftData performs an</st> `<st
    c="17769">INSERT</st>` <st c="17775">or</st> `<st c="17779">UPDATE</st>` <st c="17785">operation.</st>
    <st c="17797">This means that if an instance with a unique value already exists,
    SwiftData will not create a new object in its store but, rather, update the</st>
    <st c="17940">existing instance.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="17958">Declaring a property as unique using the</st> `<st c="18000">@Attribute</st>`
    <st c="18010">macro is straightforward.</st> <st c="18037">However, sometimes
    we need something more sophisticated.</st> <st c="18094">For example, let’s say
    we have a</st> `<st c="18127">Book</st>` <st c="18131">model with</st> `<st c="18143">name</st>`
    <st c="18147">and</st> `<st c="18152">publicationName</st>` <st c="18167">properties.</st>
    <st c="18180">In our case, we can have two books with the same name or the same</st>
    `<st c="18246">publicationName</st>`<st c="18261">, but we can’t have two books
    when both properties are identical.</st> <st c="18327">The combination of</st>
    `<st c="18346">publicationName</st>` <st c="18361">and</st> `<st c="18366">name</st>`
    <st c="18370">creates the book’s</st> <st c="18390">unique identity.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="18406">One solution is maintaining a property that tries to build a unique
    ID from these two properties.</st> <st c="18505">Another elegant option is to
    use the</st> `<st c="18542">#Unique</st>` <st c="18549">macro to define more complex</st>
    <st c="18579">uniqueness requirements:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18723">In this code example, we enforce the uniqueness of the</st> `<st
    c="18779">Book</st>` <st c="18783">model by combining two key paths.</st> <st
    c="18818">Just like the attribute parameter,</st> `<st c="18853">.unique</st>`<st
    c="18860">, if we try to insert a new book instance</st> <st c="18902">when we
    already have one with the same name and publication name, SwiftData will perform
    an</st> `<st c="18994">upsert</st>` <st c="19000">operation and update</st> <st
    c="19022">that instance.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19036">Even though SwiftData handles unique attributes well, it is important
    to ensure we carefully pick unique attributes and key paths according to an application’s
    requirements.</st> <st c="19211">Too many unique attributes can cause complexity
    and</st> <st c="19263">performance issues.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19282">Unique attributes are great for simplifying the task of handling
    duplicate instances.</st> <st c="19369">Another attribute feature that can make
    our life simpler</st> <st c="19426">is</st> *<st c="19429">transient</st>*<st
    c="19438">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19439">Going non-persistent with transient</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19475">The nice thing about working with SwiftData is that all properties
    automatically become the entity’s</st> <st c="19577">attributes and are saved
    persistently to the local data store.</st> <st c="19640">However, sometimes, there
    are cases where we want to have a property that is</st> *<st c="19717">memory-only</st>*
    <st c="19728">and not saved persistently.</st> <st c="19757">A formatted version
    of one of the values is an excellent example of such a property.</st> <st c="19842">One
    option to achieve that is to create a function or a computed variable, and then
    return a value based on the relevant property.</st> <st c="19973">However, there
    are other cases where a computed variable or a function is not a convenient solution.</st>
    <st c="20074">Let’s say we want a temporary counter or to maintain a flag relevant
    only to an application’s current</st> <st c="20176">life cycle.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20187">For these kinds of cases, we</st> <st c="20217">have a</st> *<st
    c="20224">transient</st>* <st c="20233">attribute.</st> <st c="20245">Transient
    attribute is not a new idea – Core Data had transient properties from its early
    versions.</st> <st c="20345">Since SwiftData is based on Core Data fundamentals,
    it supports transient properties out of</st> <st c="20437">the box.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20445">Here is how we declare a</st> *<st c="20471">transient</st>* <st
    c="20480">property</st> <st c="20490">in SwiftData:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20539">In this code snippet, the</st> `<st c="20566">openCounter</st>`
    <st c="20577">variable will not be saved locally to the persistent</st> <st c="20631">store
    and will be initialized each time we fetch the entity from</st> <st c="20696">our
    database.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20709">Transient properties may sound like a minor feature, but there
    are many cases where it really makes the difference, and the transient macro provides
    this flexibility.</st> <st c="20877">Full names or calculated ages are great examples</st>
    <st c="20926">of that.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20934">Exploring the container</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20958">Until now, we discussed how to declare the different entities
    using the</st> `<st c="21031">@Model</st>` <st c="21037">macro, define their</st>
    <st c="21058">relationships using the</st> `<st c="21082">@Relationship</st>`
    <st c="21095">macro, and customize their attributes using the</st> `<st c="21144">@</st>``<st
    c="21145">Attribute</st>` <st c="21154">macro.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="21161">However, we haven’t discussed setting up SwiftData to work with
    a schema and a</st> <st c="21241">persistent store.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="21258">When we delved into the</st> `<st c="21283">@Model</st>` <st c="21289">macro,
    drawing parallels with Core Data was straightforward and remains so now.</st>
    <st c="21370">In Core Data, we set up the stack using</st> `<st c="21410">NSPersistentContainer</st>`<st
    c="21431">, which encapsulates the different components, such as the data model,
    the store, and the context, into one stack that we can</st> <st c="21557">work
    with.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="21567">In SwiftData, we use</st> `<st c="21589">ModelContainer</st>`<st
    c="21603">, which has the</st> <st c="21619">same responsibility.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="21639">Let’s try to understand how</st> <st c="21668">it works.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="21677">Setting up ModelContainer</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="21703">ModelContainer</st>` <st c="21718">is essential</st> <st c="21732">for
    working with SwiftData.</st> <st c="21760">The reason is that SwiftData has three
    main components that the container encapsulates and</st> <st c="21851">wraps together:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="21962">@Model</st>` <st c="21968">macro to</st> <st c="21978">our entities</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="21990">The store</st>**<st c="22000">: The backend store where we
    will save</st> <st c="22040">our data</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="22048">The context</st>**<st c="22060">: This is our link to the store
    and the sandbox, where we can add, edit, and delete</st> <st c="22145">different
    records</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="22162">Here is the basic and minimal way to create</st> <st c="22207">a
    container:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="22411">In this code, we create an object from the</st> `<st c="22455">ModelContainer</st>`
    <st c="22469">type and provide it with the three models we made earlier in the</st>
    *<st c="22535">Defining a SwiftData</st>* *<st c="22556">Model</st>* <st c="22561">section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="22570">Note that, in our case, we have one parameter,</st> `<st c="22618">Schema</st>`<st
    c="22624">, which holds all the different models relevant to our container –</st>
    `<st c="22691">Book</st>`<st c="22695">,</st> `<st c="22697">Author</st>`<st c="22703">,</st>
    <st c="22705">and</st> `<st c="22709">Page</st>`<st c="22713">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="22714">The fact that we need to provide a list of models may raise some
    eyebrows – why do we need to do that?</st> <st c="22818">Can’t Xcode locate all
    the models and add them automatically?</st> <st c="22880">The</st> `<st c="22884">@Model</st>`
    <st c="22890">macro indeed expands code at compile time, but it doesn’t mean SwiftData
    is aware of all our entities when we set it up at the beginning of the app run.</st>
    <st c="23044">So, whenever we add a new model, we must add it to the list of models
    in our</st> `<st c="23121">Schema</st>` <st c="23127">parameter.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="23138">Regarding including the</st> `<st c="23163">Book</st>` <st c="23167">entity
    independently from the</st> `<st c="23198">Author</st>` <st c="23204">entity –
    when we add the</st> `<st c="23230">Book</st>` <st c="23234">model to the models’
    list, it automatically consists of all associated models, including those related
    to the models further down the</st> <st c="23369">hierarchy.</st> <st c="23380">It
    means that, theoretically, we can include only the root object while doing something</st>
    <st c="23468">like that:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="23498">And that</st> <st c="23508">will be enough to include</st> `<st
    c="23534">Author</st>` <st c="23540">and</st> `<st c="23545">Page</st>`<st c="23549">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="23550">So, what will we do with the container instance we just created?</st>
    <st c="23616">Let’s see in the</st> <st c="23633">next section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="23646">Connecting the container using the modelContainer modifier</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="23705">Now that</st> <st c="23715">we have a model container, we want
    to link it somehow to our UI so that we can start</st> <st c="23800">using it.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="23809">To do that, we will use the</st> `<st c="23838">modelContainer</st>`
    <st c="23852">modifier to connect the container to</st> <st c="23890">our scene:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="23982">In our code example, we add the</st> `<st c="24014">modelContainer</st>`
    <st c="24028">modifier to our</st> `<st c="24045">WindowGroup</st>`<st c="24056">,
    thus making it available to the</st> <st c="24090">whole app.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="24100">Instead of creating a connector and connecting it to</st> `<st
    c="24154">WindowGroup</st>`<st c="24165">, we can use another</st> `<st c="24186">modeContainer</st>`
    `<st c="24199">init</st>` <st c="24204">method and pass only the list</st> <st
    c="24235">of entities:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <st c="24304">Passing the list of entities can be a simple and easy way of setting
    up a container.</st> <st c="24390">So, why do we need the</st> `<st c="24413">ModelContainer</st>`
    <st c="24427">class?</st> <st c="24435">The simple answer is, as always, to provide
    more customization.</st> <st c="24499">Let’s</st> <st c="24505">see how!</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="24513">Working with ModelConfiguration</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="24545">The</st> `<st c="24550">ModelContainer</st>` <st c="24564">offers
    us more than just scheme passing; it empowers us to configure our</st> `<st c="24638">SwiftData</st>`
    <st c="24647">store for specific models and customize it to our</st> <st c="24698">particular
    requirements.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="24722">To do</st> <st c="24729">that, we will use the</st> `<st c="24751">ModelConfiguration</st>`
    <st c="24769">struct,</st> <st c="24778">as follows:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="25128">Let’s try to understand what is happening in this code snippet.</st>
    <st c="25193">First, we create a schema with a list of our models.</st> <st c="25246">Then,
    we declare a model configuration struct, pass the schema, and set its backend
    store to in-memory.</st> <st c="25350">Finally, we return a model container based
    on our schema and a set containing the configuration we</st> <st c="25449">just
    created.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25462">All this process feels a little bit awkward, clumsy, and redundant
    – why do we need to create a configuration if we’re passing the same schema again?</st>
    <st c="25613">And why is it a set?</st> <st c="25634">The main configuration idea
    is to provide different behavior for a different set</st> <st c="25715">of models.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25725">Here’s an example.</st> <st c="25745">Imagine we have a brainstorm
    sketch app.</st> <st c="25786">We want to sketch and store our concepts in the
    app’s persistent storage while all drawings on the whiteboard canvas remain</st>
    <st c="25910">in memory.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25920">In this case, we can</st> <st c="25942">create two configurations,
    one for in-memory and one for</st> <st c="25999">persistent storage and</st> **<st
    c="26022">CloudKit</st>** <st c="26030">integration:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26550">In our example, we created two different schemas – a list of models
    for brainstorming and a list of models for the</st> <st c="26666">user projects.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26680">Based on these models, we create two different configurations.</st>
    <st c="26744">The idea brainstorming configuration is saved in memory, and the
    projects’ configuration is saved locally and syncs</st> <st c="26860">to CloudKit.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26872">Working with two different configurations and schemas for two
    app features is a great example of model configuration usage.</st> <st c="26997">We
    can use the model configuration for additional customization, such as</st> <st
    c="27070">the following:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27084">Different</st> <st c="27095">store files</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27106">Different</st> <st c="27117">group containers</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27133">Different</st> <st c="27144">auto-saving mechanisms</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27166">However, let’s suppose we don’t need the model configuration to
    configure different behavior</st> <st c="27260">for different groups of models.</st>
    <st c="27292">In that case, we can work directly with the model container and
    initiate it with the</st> <st c="27377">entire schema.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27391">We now know how to declare and group our models for a schema to
    be used in a model container.</st> <st c="27486">But there’s one crucial thing
    missing – how to insert, update, and fetch data.</st> <st c="27565">We will</st>
    <st c="27572">do that by placing the missing piece in the puzzle –</st> <st c="27626">the
    context.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27638">Fetching and manipulating our data using model context</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27693">Developers familiar with Core Data are also familiar with the
    idea of</st> **<st c="27764">context</st>**<st c="27771">. Context is our data</st>
    <st c="27793">sandbox.</st> <st c="27802">This is the place where we can manipulate</st>
    <st c="27844">and fetch data, and it’s the link</st> <st c="27878">between our
    models and the</st> <st c="27905">persistent store.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27922">To gain</st> <st c="27931">access to our context from our SwiftUI
    view, we can use an environment variable</st> <st c="28011">named</st> `<st c="28017">modelContext</st>`<st
    c="28029">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28114">The</st> `<st c="28119">modelContext</st>` <st c="28131">environment
    variable is available whenever we set up our scene using the</st> `<st c="28205">modelContainer</st>`
    <st c="28219">modifier.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28229">In non-SwiftUI</st> <st c="28245">instances, we can access the</st>
    <st c="28274">context using our model container</st> `<st c="28308">mainContext</st>`
    <st c="28319">property:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28375">To understand</st> <st c="28390">how to work with a model context,
    we’ll</st> <st c="28430">start with the most basic operation, saving new objects
    for</st> <st c="28490">our store.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28500">Saving new objects</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28519">At the beginning of this chapter, in the</st> *<st c="28561">Defining
    a SwiftData model</st>* <st c="28587">section, we learned that our models are
    just Swift classes marked with a</st> `<st c="28661">@</st>``<st c="28662">Model</st>`
    <st c="28667">macro.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28674">The way we</st> <st c="28686">define a model in SwiftData also
    means that the creation of a new instance is straightforward</st> <st c="28780">for
    us:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28845">Our next step is adding that book instance to</st> <st c="28892">our
    context:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28933">Adding</st> `<st c="28941">newBook</st>` <st c="28948">to the
    model context doesn’t necessarily mean it is being saved to our persistent store,
    but it does mean that it is in our context and is ready to be pushed forward to
    our store.</st> <st c="29129">Having our entity in our context helps us manage
    the interaction between our app and the underlying persistent store.</st> <st
    c="29247">In our context, we can make changes, adding and deleting information
    without actually saving these actions to our data store.</st> <st c="29373">The
    context is beneficial when working with concurrency operations or when we want
    to manage</st> <st c="29466">undo operations.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29482">To actually save to the persistent store, we can use the context</st>
    `<st c="29548">save()</st>` <st c="29554">method:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'var body: some Scene {'
  prefs: []
  type: TYPE_NORMAL
- en: WindowGroup {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ContentView()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '.modelContainer(for: Book.self, <st c="29938">isAutosaveEnabled:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29956">false</st>)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'let fetchDesciprtor = <st c="31509">FetchDescriptor</st><Book>(predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Predicate { $0.name == "My Book"})'
  prefs: []
  type: TYPE_NORMAL
- en: let book = try? modelContext.fetch(fetchDesciprtor).first
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'let fetchDesciprtor = FetchDescriptor<Book>(predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Predicate { book in'
  prefs: []
  type: TYPE_NORMAL
- en: return book.pages.count > 10
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="32813">@Query private var books: [Book]</st> var body: some View {'
  prefs: []
  type: TYPE_NORMAL
- en: List {
  prefs: []
  type: TYPE_NORMAL
- en: ForEach(books) { book in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text(book.name)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '@Query(<st c="33764">filter: #Predicate<Book> {</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33791">$0.pages.count > 300</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33887">@Query</st> that returns only books that contain more than 300
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33951">Of course, we can perform even more complex queries by upgrading
    our Swift expression inside</st> <st c="34045">the predicate:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34179">In this example, we filter books that contain more than 300 pages,
    but this time, we also want to</st> <st c="34278">receive books that we haven’t
    read or are marked as favorites.</st> <st c="34341">The fact that we use a Swift
    expression to filter our results makes our queries more descriptive and powerful</st>
    <st c="34451">than</st> `<st c="34456">NSPredicate</st>`<st c="34467">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34468">However, when displaying data in a list, it is not enough to filter
    it; it is also crucial to sort it.</st> <st c="34572">That’s the job of our second
    main</st> `<st c="34606">@</st>``<st c="34607">Query</st>` <st c="34612">feature.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34621">Sorting the data</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34638">Sorting is an essential aspect of presenting information to our
    users.</st> <st c="34710">We should remember</st> <st c="34729">that sorting is
    not a lightweight task; it requires a complex algorithm to be</st> <st c="34807">done
    efficiently.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34824">That’s why we need to ensure that we can sort by a property whose
    type conforms to the</st> `<st c="34912">SortComparator</st>` <st c="34926">protocol,
    introduced as part of</st> <st c="34959">iOS 15.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34966">Let’s see how we can sort our</st> <st c="34997">filtered books:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <st c="35172">In this example, we pass an array of</st> `<st c="35210">SortDescriptor</st>`
    <st c="35224">– we first sort by the book name and then by its number of pages.</st>
    <st c="35291">It’s pretty easy to use</st> `<st c="35315">SortDescriptor</st>`
    <st c="35329">– we initialize it using a key path to the desired property, just
    like in the</st> <st c="35408">preceding example.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35426">Performing sorting with SwiftData is extremely simple.</st> <st
    c="35482">However, under the hood, it requires</st> <st c="35519">running algorithms
    that must be optimized for performance in order to work efficiently.</st> <st
    c="35607">We don’t need these optimizations when working with 100 or 200 records.</st>
    <st c="35679">However, there are cases when our data store contains thousands
    of records.</st> <st c="35755">For these cases, we need to index</st> <st c="35789">our
    data.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="35798">Adding the #Index macro for performance</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35838">Before we index our data, let’s try to understand what it means
    exactly.</st> <st c="35912">When performing</st> <st c="35928">read operations
    such as sorting or querying, we expect our app to work seamlessly with thousands
    of records.</st> <st c="36037">Obviously, performing a full-table scan to find
    a book named</st> *<st c="36098">Mastering iOS 18</st>* <st c="36114">is inefficient.</st>
    <st c="36131">So, what do we do?</st> <st c="36150">Like a book index, the database
    index contains keys that help it locate a specific record.</st> <st c="36241">For
    example, if we want to index our book’s</st> `<st c="36285">name</st>` <st c="36289">property,
    we can create a data structure, such as a B-tree, which can help us locate the
    exact instance according to</st> <st c="36407">its name.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36416">In SwiftData, we don’t need to create any structure to index our
    data.</st> <st c="36488">All we need to do is add the</st> `<st c="36517">#Index</st>`
    <st c="36523">macro to</st> <st c="36533">our model:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <st c="36672">If the preceding code looks familiar, that’s because we did something
    similar when we added the</st> `<st c="36769">#Unique</st>` <st c="36776">macro
    to our model in the</st> *<st c="36803">Adding the @Attribute</st>* *<st c="36825">macro</st>*
    <st c="36830">section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36839">In this case, we decided to add two indexes to</st> <st c="36887">our
    model:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36897">The first is to index the name property, allowing an app to sort
    records by name or query data for a specific</st> <st c="37008">book name.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37018">The second index is based on the combination of the</st> `<st
    c="37071">name</st>` <st c="37075">and</st> `<st c="37080">publicationName</st>`
    <st c="37095">properties</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="37106">If you remember from the</st> *<st c="37132">Adding the @Attribute
    macro</st>* <st c="37159">section, we decided that this combination defines our
    book’s uniqueness.</st> <st c="37233">Creating an index for this combination can
    help us quickly find a specific book</st> <st c="37313">when needed.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37325">Indexing looks like magic – we add another key path to the list
    of indexes, and everything works faster.</st> <st c="37431">So, why not do that
    for all properties?</st> <st c="37471">What’s</st> <st c="37478">the catch?</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37488">It’s because</st> <st c="37502">indexing comes with a price.</st>
    <st c="37531">First, we need to duplicate some of our data.</st> <st c="37577">If
    we need to index the name property, we need to create a structure that contains
    all the names.</st> <st c="37675">This results in additional storage for our app.</st>
    <st c="37723">But adding an index doesn’t stop with storage – it also affects
    performance.</st> <st c="37800">Indexing is not a one-time operation, as it requires
    maintenance.</st> <st c="37866">Each</st> `<st c="37871">insert</st>`<st c="37877">,</st>
    `<st c="37879">update</st>`<st c="37885">, or</st> `<st c="37890">delete</st>`
    <st c="37896">operation requires SwiftData to maintain the index structure, impacting
    the</st> <st c="37973">operation performance.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="37995">In summary, indexing is a great SwiftData feature.</st> <st c="38047">However,
    use it carefully and balance its benefits with</st> <st c="38103">its costs.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38113">We’ve learned so many things so far!</st> <st c="38151">We’ve
    learned how to define models, create instances, fetch them, and connect them to</st>
    <st c="38237">the UI.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38244">But we know that m</st><st c="38263">aintaining a persistent store
    is much more than that.</st> <st c="38318">Our first app version is so much different
    than our 50th version, and it also means that our data schema will change during
    our app version’s life cycle.</st> <st c="38472">But what should we do once we
    already have a store full of data?</st> <st c="38537">That’s our next topic –
    how to perform</st> <st c="38576">data migration.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38591">Migrating our data to a new schema</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38626">Data migration is not a weird expression for those who have worked
    with Core Data.</st> <st c="38710">It is obvious</st> <st c="38724">that we need
    to change our schema as our</st> <st c="38765">app evolves.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38777">There are two types of migrations –</st> *<st c="38814">lightweight</st>*
    <st c="38825">and</st> *<st c="38830">custom</st>* <st c="38836">migration.</st>
    <st c="38848">With lightweight migration, we perform changes that don’t require
    custom logic.</st> <st c="38928">For example, adding an entity, a property, and
    a relationship are all good examples of lightweight migration.</st> <st c="39038">Conversely,
    changing a property type, making a property unique, and creating a new property
    based on other properties are examples of custom migrations.</st> <st c="39191">Now
    that we know what migration types we have, it’s important to understand when it
    is relevant to perform</st> <st c="39298">a migration.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="39310">When we’re in our development stage, migration is unnecessary
    before we have an official version of our app on the App Store.</st> <st c="39437">We
    only need to perform migration when an end user holds</st> <st c="39494">a version
    with an older schema.</st> <st c="39526">This also means that if we perform schema
    changes in several versions, we must ensure that SwiftData knows how to migrate
    throughout all</st> <st c="39663">these versions.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="39678">Now, let’s discuss how SwiftData migration works and what the
    essential migration</st> <st c="39761">components are.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="39776">Learning the basic migration process</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="39813">A SwiftData</st> <st c="39826">migration has three</st> <st c="39846">main
    components:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="39862">VersiondSchema</st>`<st c="39877">: Describes a specific</st>
    <st c="39901">schema version</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="39915">MigrationStage</st>`<st c="39930">: Describes the migration
    process between two versions of the</st> <st c="39993">same schema</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="40004">SchemaMigrationPlan</st>`<st c="40024">: Describes how the schema
    migration stages are based on the</st> <st c="40086">migration stages</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="40102">Let’s try to describe how everything is connected, using</st>
    *<st c="40160">Figure 2</st>**<st c="40168">.2</st>*<st c="40170">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.2: A migration process between three different versions](img/B21795_02_2.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="40295">Figure 2.2: A migration process between three different versions</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*<st c="40359">Figure 2</st>**<st c="40368">.2</st>* <st c="40370">shows three
    different version schemas for three different versions.</st> <st c="40439">We
    create a migration</st> <st c="40461">stage each time we migrate the app from
    one version to another.</st> <st c="40525">Once we have the various stages, we
    can wrap them into one big</st> <st c="40588">migration plan.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40603">Returning to our book’s app, let’s try to migrate our schema to
    support a</st> `<st c="40678">subtitle</st>` <st c="40686">for our</st> `<st c="40695">Book</st>`
    <st c="40699">entity.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40707">First, we need to create our</st> <st c="40737">version schemas.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40753">Creating a version schema</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40779">To migrate</st> <st c="40791">our book to a new schema, we need
    to create two version schemas – the first is our current schema, and the second
    is the</st> <st c="40912">destination schema:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <st c="41502">In this code, we created two enums that conform to the</st> `<st
    c="41558">VersionedSchema</st>` <st c="41573">protocol.</st> <st c="41584">As
    part of</st> <st c="41595">the protocol definition, we need to define the version
    identifier and what models</st> <st c="41677">will change.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41689">We added a new</st> `<st c="41705">subtitle</st>` <st c="41713">property
    to the second version in this case.</st> <st c="41759">We need to update the schema
    we use across the app, with the new</st> <st c="41824">property included.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41842">Our next step is to define the different stages and the</st> <st
    c="41899">migration plan.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41914">Creating the migration stages and plan</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41953">We should</st> <st c="41964">consider the versioned schemas as
    the building blocks of our migration process.</st> *<st c="42044">Figure 2</st>**<st
    c="42052">.2</st>* <st c="42054">shows that we create the migration stages based
    on the</st> <st c="42110">versioned schemas.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42128">Here’s an example of a</st> <st c="42152">migration stage:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: <st c="42285">The</st> `<st c="42290">migrateV1toV2</st>` <st c="42303">stage
    handles the migration from</st> `<st c="42337">BookSchemaV1</st>` <st c="42349">to</st>
    `<st c="42353">BookSchemaV2</st>`<st c="42365">. Note that this is a lightweight
    migration – we only added a property, so this is all that we need to create</st>
    <st c="42475">the stage.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42485">What about a custom migration?</st> <st c="42517">With a custom
    migration, we need to provide a closure that handles data before and after the
    migration stage, where we perform all the</st> <st c="42652">required changes.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42669">Here’s an example of a custom transition from version V2 to V3,
    where we have removed the subtitle property and added it as part of the</st> <st
    c="42806">book name:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: <st c="43147">As we can</st> <st c="43158">see in the code example, our</st>
    `<st c="43187">willMigrate</st>` <st c="43198">closure receives a context to work
    with, and SwiftData performs that closure</st> <st c="43276">when needed.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43288">We fetch all the books and assemble a new name from the book name
    and its subtitle property.</st> <st c="43382">At the end of the closure code,
    we</st> <st c="43417">call</st> `<st c="43422">context.save()</st>`<st c="43436">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43437">Now that we have both migration steps, we can create our</st>
    <st c="43495">migration plan:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: <st c="44174">The migration</st> <st c="44189">plan is just another Enum conforming
    to</st> `<st c="44229">SchemaMigrationPlan</st>`<st c="44248">, with static variables
    describing the list of schemas and stages (not something we haven’t</st> <st c="44340">seen
    before).</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44353">Now, we have a migration plan, but SwiftData doesn’t know what
    to do with it.</st> <st c="44432">Our next step will be connecting the migration
    plan to our</st> <st c="44491">SwiftData container.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44511">Connecting the migration plan to our container</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44558">Connecting</st> <st c="44570">the migration plan to our container
    is perhaps the most straightforward step in</st> <st c="44650">the process.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44662">The</st> `<st c="44667">ModelContainer</st>` <st c="44681">struct
    has a</st> `<st c="44695">migrationPlan</st>` <st c="44708">property specifically
    for that, and we need to pass the migration plan</st> <st c="44780">Enum type:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <st c="44904">Note the way that migrations work in SwiftData in terms of a language
    paradigm.</st> <st c="44985">We don’t have to initialize anything, since we only
    pass the schemas, stages, and plan types.</st> <st c="45079">The reason is the
    way SwiftUI works – since we work in an immutable environment, it is much more
    convenient to work with static variables and types instead</st> <st c="45235">of
    instances.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45248">Migration in SwiftData is not a simple task.</st> <st c="45294">It
    involves conforming to multiple protocols, maintaining schema versions, and understanding
    how a store is built to switch between lightweight and</st> <st c="45442">custom
    migration.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45459">But this is because migration, in general, is a complex and sensitive
    process.</st> <st c="45539">Trying to carefully plan beforehand how our schema
    looks can reduce the number of schema versions and stages, easing our process
    when considering</st> <st c="45684">that we will have to migrate our store at</st>
    <st c="45727">some point.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45738">Summary</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45746">SwiftData holds significance for iOS developers looking to support
    iOS 17 and above, representing a natural progression from Apple’s previous framework,
    Core Data.</st> <st c="45911">Within the context of a declarative Swift environment,
    SwiftData aligns more seamlessly</st> <st c="45999">than before.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="46011">In this chapter, we’ve learned about SwiftData’s background, defined
    the different SwiftData models, created relationships, and customized the model
    attributes.</st> <st c="46173">We moved on to the container – a component that
    wraps everything together, performs fetches, and saves.</st> <st c="46277">Lastly,
    we migrated our data from different schema versions using lightweight and custom
    migrations.</st> <st c="46378">Throughout the chapter, we saw the heavy use of
    Swift macros and protocols, which are more suitable for the modern world of Swift
    compared</st> <st c="46517">to Objective-C.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="46532">That’s a lot for one chapter!</st> <st c="46563">Remember that
    the data layer is c</st><st c="46596">omplex to manage and maintain, and there’s
    much more to learn.</st> <st c="46660">The data layer is one side of our project;
    the other side is, of course, the UI.</st> <st c="46741">To complete our understanding
    of the data layer, it’s essential to explore how the UI can monitor changes.</st>
    <st c="46848">This is why our forthcoming chapter will focus on the</st> <st c="46902">observation
    framework.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
