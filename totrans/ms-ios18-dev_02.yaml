- en: <st c="0">2</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">2</st c="0">
- en: <st c="2">Simplifying Our Entities with SwiftData</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">使用SwiftData简化我们的实体</st c="2">
- en: <st c="41">Let’s start our journey to mastering iOS 18 with one of the most
    important and useful frameworks Apple has released in the last few years –</st>
    <st c="182">SwiftData.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41">让我们以苹果在过去几年中发布的最重要和最有用的框架之一——</st c="41"><st c="182">SwiftData</st
    c="182">——开始我们的iOS 18精通之旅。</st c="182">
- en: '**<st c="192">SwiftData</st>** <st c="202">is an</st> <st c="209">excellent
    example of Swift macro usage, taking the old and beloved Core Data framework to
    a whole new level of simplicity and adapting it to the modern world of Swift and</st>
    <st c="380">declarative programming.</st>'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="192">SwiftData</st>** <st c="202">是Swift宏使用的优秀示例，将老旧且深受喜爱的Core Data框架提升到了一个全新的简单化水平，并使其适应Swift和<st
    c="380">声明式编程</st c="380">的现代世界。</st c="209">'
- en: <st c="404">In this chapter, we will do</st> <st c="433">the following:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="404">在本章中，我们将做以下事情：</st c="404">
- en: <st c="447">Understand the</st> <st c="463">SwiftData background</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="447">了解SwiftData的</st c="447"><st c="463">背景</st c="463"></st c="463">
- en: <st c="483">Define a data model, including its relationships</st> <st c="533">and
    attributes</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="483">定义数据模型，包括其</st c="483"><st c="533">关系</st c="533">和属性</st c="533"></st
    c="533">
- en: <st c="547">Learn about the SwiftData container</st> <st c="584">and configurations</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="547">了解SwiftData容器</st c="547"><st c="584">和配置</st c="584"></st c="584">
- en: <st c="602">Fetch and manipulate data using the</st> <st c="639">model context</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="602">使用模型上下文</st c="602"><st c="639">检索和操作数据</st c="639"></st c="639">
- en: <st c="652">Migrate our data to new</st> <st c="677">version schemas</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="652">将我们的数据迁移到新的</st c="652"><st c="677">版本模式</st c="677"></st c="677">
- en: <st c="692">It’s going to be a long ride with an exciting new framework!</st>
    <st c="754">So, after the technical requirements, let’s start with some background
    on</st> <st c="828">the framework.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="692">这将是一次漫长的旅程，将会有一个令人兴奋的新框架！</st c="692">因此，在技术要求之后，让我们从框架的背景开始。</st
    c="754"><st c="828">框架</st c="828">
- en: <st c="842">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="842">技术要求</st c="842">
- en: <st c="865">This chapter includes many code examples, some of which can be found
    in the following</st> <st c="952">GitHub repository:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="865">本章包含许多代码示例，其中一些可以在以下</st c="865"><st c="952">GitHub仓库</st c="952">中找到：</st
    c="952">
- en: '[<st c="970">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[<st c="970">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202</st
    c="970"]](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202)'
- en: <st c="1056">To run them, we will need Xcode 16</st> <st c="1092">or newer.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1056">要运行它们，我们需要Xcode 16</st c="1056">或更新的版本。</st c="1092">
- en: <st c="1101">Understanding SwiftData’s background</st>
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1101">理解SwiftData的背景</st c="1101">
- en: <st c="1138">To understand SwiftData’s background and its roots, it’s important
    to go one step backward and</st> <st c="1234">learn about the</st> **<st c="1250">Core</st>**
    **<st c="1255">Data</st>** <st c="1259">framework.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1138">要了解SwiftData的背景及其根源，重要的是要退一步</st c="1138"><st c="1234">了解</st c="1234"><st
    c="1250">Core</st c="1250">数据</st c="1250"><st c="1255">框架</st c="1255"></st c="1255"></st
    c="1259">
- en: <st c="1270">Core Data has been the primary data framework for Apple platforms
    for many years, even before iOS</st> <st c="1369">was born.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1270">Core Data多年来一直是苹果平台的主要数据框架，甚至在iOS</st c="1270"><st c="1369">诞生之前。</st
    c="1369">
- en: <st c="1378">Core Data was</st> <st c="1393">added to iOS in iOS 3, bringing
    the power of handling a data graph to mobile devices flexibly and efficiently.</st>
    <st c="1504">Note that I haven’t mentioned the word</st> *<st c="1543">database</st>*
    <st c="1551">or</st> *<st c="1555">persistency</st>*<st c="1566">, and that’s
    for a good reason.</st> <st c="1598">We should remember that Core Data is not
    an</st> **<st c="1642">SQLite</st>** <st c="1648">wrapper, even though its persistent
    store is based on SQLite in most cases.</st> <st c="1725">The primary goal of
    Core Data is to handle our app’s</st> <st c="1778">data layer.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1378">Core Data是在iOS 3中添加到iOS的，它将处理数据图的能力灵活且高效地带给移动设备。</st c="1378">请注意，我没有提到单词</st
    c="1504"><st c="1543">数据库</st c="1543">或</st c="1504"><st c="1551">持久性</st c="1551">，这有一个很好的原因。</st
    c="1555"><st c="1566">我们应该记住，Core Data不是一个</st c="1598"><st c="1642">SQLite</st
    c="1642">包装器，尽管其持久存储在大多数情况下基于SQLite。</st c="1648">Core Data的主要目标是处理我们应用的</st c="1725"><st
    c="1778">数据层</st c="1778"></st c="1778">
- en: <st c="1789">But what does it mean to handle the app’s data layer?</st> <st
    c="1844">Well, most apps work with several layers – the UI, business logic, and
    data layer.</st> <st c="1927">The data layer is built upon data entities that
    define the core items that our app works with.</st> <st c="2022">For example,
    a to-do app can have entities such as a</st> *<st c="2075">list</st>*<st c="2079">,</st>
    *<st c="2081">task,</st>* <st c="2086">or</st> *<st c="2090">reminder</st>*<st
    c="2098">. A music app can have entities such as an</st> *<st c="2141">album</st>*<st
    c="2146">,</st> *<st c="2148">song</st>*<st c="2152">,</st> <st c="2154">or</st>
    *<st c="2157">playlist</st>*<st c="2165">.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1789">但处理应用程序的数据层意味着什么呢？</st> <st c="1844">嗯，大多数应用程序都与几个层一起工作——UI、业务逻辑和数据层。</st>
    <st c="1927">数据层建立在定义我们应用程序所处理的核心项目的数据实体之上。</st> <st c="2022">例如，一个待办事项应用程序可以具有诸如</st>
    *<st c="2075">列表</st>*<st c="2079">、</st> *<st c="2081">任务</st>*、 <st c="2086">或</st>
    *<st c="2090">提醒</st>*<st c="2098">之类的实体。</st> <st c="2154">一个音乐应用程序可以具有诸如</st>
    *<st c="2141">专辑</st>*<st c="2146">、</st> *<st c="2148">歌曲</st>*、 <st c="2152">或</st>
    *<st c="2157">播放列表</st>*<st c="2165">之类的实体。</st>
- en: <st c="2166">The data layer defines the different entities and how they are
    related.</st> <st c="2239">For example, an album can contain many songs, and a
    list can contain many tasks.</st> <st c="2320">if there’s a need for persistence,
    the data layer also handles how the different entities’ data is saved to disk.</st>
    <st c="2434">According to our understanding of a data layer, Core Data fulfills
    its role as an app data layer by defining its data model, handling persistency,
    migrations, and even undo operations.</st> <st c="2619">So, if Core Data is such
    an excellent framework for handling data, why do we</st> <st c="2696">need SwiftData?</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2166">数据层定义了不同的实体以及它们之间的关系。</st> <st c="2239">例如，一个专辑可以包含许多歌曲，一个列表可以包含许多任务。</st>
    <st c="2320">如果需要持久化，数据层也处理了不同实体的数据如何保存到磁盘上的问题。</st> <st c="2434">根据我们对数据层的理解，Core
    Data通过定义其数据模型、处理持久化、迁移甚至撤销操作来履行其作为应用程序数据层的角色。</st> <st c="2619">所以，如果Core Data是处理数据如此出色的框架，为什么我们</st>
    <st c="2696">还需要SwiftData？</st>
- en: <st c="2711">Core Data is a great framework, but it was designed for different
    times when we used to code with Objective-C, and UIkit hadn’t even been created.</st>
    <st c="2859">Ever since then, the iOS development world has changed significantly
    – we now have Swift, and moreover, we have SwiftUI.</st> <st c="2980">Even though
    Core Data has received updates to support Swift and SwiftUI, it still felt outdated
    in a world of type-safety, multithreading, and declarative programming.</st> <st
    c="3148">Fetching and observing data changes have become cumbersome in Core Data,
    as we use design patterns more suitable for the UIkit/Objective-C era.</st> <st
    c="3292">In this context, SwiftData promises to bring a modern, straightforward
    framework to handle data much more flawlessly, using the full power of Swift</st>
    <st c="3440">and Combine.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2711">Core Data是一个伟大的框架，但它是为不同的时代设计的，当时我们使用Objective-C进行编码，而UIKit甚至还没有被创建。</st>
    <st c="2859">从那时起，iOS开发世界已经发生了显著变化——我们现在有了Swift，而且更重要的是，我们有了SwiftUI。</st> <st
    c="2980">尽管Core Data已经更新以支持Swift和SwiftUI，但它仍然在类型安全、多线程和声明式编程的世界中感觉过时。</st> <st
    c="3148">在Core Data中获取和观察数据变化变得繁琐，因为我们使用了更适合UIKit/Objective-C时代的设计模式。</st> <st
    c="3292">在这种情况下，SwiftData承诺带来一个现代、直接的框架来更完美地处理数据，利用Swift</st> <st c="3440">和Combine的全部力量。</st>
- en: <st c="3452">One of the best things about SwiftData is that it uses</st> *<st
    c="3508">Swift macros</st>* <st c="3520">– the same Swift macros we learned about
    in</st> [*<st c="3565">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)<st
    c="3575">. The macros help us elegantly implement SwiftData without using</st>
    <st c="3640">boilerplate code.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3452">SwiftData最好的事情之一是它使用了</st> *<st c="3508">Swift宏</st>* <st c="3520">——我们在</st>
    [*<st c="3565">第10章</st>*](B21795_10.xhtml#_idTextAnchor329)<st c="3575">中学到的相同的Swift宏。</st>
    <st c="3575">这些宏帮助我们优雅地实现SwiftData，而无需使用</st> <st c="3640">样板代码。</st>
- en: <st c="3657">It’s time to get into business and create our first</st> <st c="3710">SwiftData
    models!</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3657">是时候进入商业领域并创建我们的第一个</st> <st c="3710">SwiftData模型了！</st>
- en: <st c="3727">Defining a SwiftData model</st>
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3727">定义SwiftData模型</st>
- en: <st c="3754">Usually, when</st> <st c="3769">discussing a data framework, it
    is common to start with the basic setup.</st> <st c="3842">However, this time,
    we will begin with the model itself.</st> <st c="3899">Why is that?</st> <st c="3912">Because
    I want to demonstrate how simple and easy it is to convert an existing data model
    to a SwiftData model, using the following piece</st> <st c="4050">of code:</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3754">通常，在讨论数据框架时，我们通常会从基本设置开始。</st> <st c="3842">然而，这次，我们将从模型本身开始。</st>
    <st c="3899">为什么是那样呢？</st> <st c="3912">因为我想要展示如何简单地将现有的数据模型转换为 SwiftData 模型，使用以下代码片段：</st>
    <st c="4050">：</st>
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="4294">In this code, we see a standard</st> `<st c="4327">Book</st>` <st
    c="4331">class, with the addition of a macro named</st> `<st c="4374">@Model</st>`<st
    c="4380">. Before we expand the</st> `<st c="4403">@Model</st>` <st c="4409">macro
    and see what it does precisely, let’s focus on what happens when we</st> <st c="4484">add
    it.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4294">在这段代码中，我们看到一个标准的</st> `<st c="4327">Book</st>` <st c="4331">类</st>，添加了一个名为</st>
    `<st c="4374">@Model</st>`<st c="4380">的宏。在我们展开</st> `<st c="4403">@Model</st>`
    <st c="4409">宏并查看它确切地做了什么之前，让我们关注当我们</st> <st c="4484">添加它时会发生什么。</st>
- en: <st c="4491">Adding the</st> `<st c="4503">@Model</st>` <st c="4509">macro is
    all it takes to convert a regular class into a model backed with a persistent
    store.</st> <st c="4604">Similar to how Core Data entities work, the class name
    is the entity name, and its variables are the</st> <st c="4705">entity attributes.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4491">添加</st> `<st c="4503">@Model</st>` <st c="4509">宏</st> <st c="4509">就足以将一个常规类转换为带有持久存储的模型。</st>
    <st c="4604">类似于 Core Data 实体的工作方式，类名是实体名，其变量是</st> `<st c="4705">实体属性。</st>`
- en: <st c="4723">When we</st> <st c="4732">compare that to Core Data, we can see
    that the model declaration process is backward – in Core Data, we declare the
    model in the model editor and then generate its class, whereas in SwiftData, we
    take a regular class and make it</st> <st c="4961">a model.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4723">当我们</st> <st c="4732">将其与 Core Data 进行比较时，我们可以看到模型声明过程是相反的——在 Core
    Data 中，我们在模型编辑器中声明模型，然后生成其类，而在 SwiftData 中，我们取一个常规类并将其</st> <st c="4961">转换为模型。</st>
- en: <st c="4969">But what does</st> `<st c="4984">@Model</st>` <st c="4990">macro
    really do?</st> <st c="5008">Let’s expand it</st> <st c="5024">and see.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4969">但是</st> `<st c="4984">@Model</st>` <st c="4990">宏实际上做了什么？</st>
    <st c="5008">让我们展开它</st> <st c="5024">并看看。</st>
- en: <st c="5032">Expanding the @Model macro</st>
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5032">展开 @Model 宏</st>
- en: <st c="5059">We already</st> <st c="5071">know what a Swift Macro is capable
    of, and SwiftData is a great chance to explore a new</st> <st c="5159">macro implementation.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5059">我们已经</st> <st c="5071">知道了 Swift 宏的能力，SwiftData 是探索一种新的</st> <st
    c="5159">宏实现</st> <st c="5159">的好机会。</st>
- en: <st c="5180">To expand the macro, we can right-click on the</st> `<st c="5228">@Model</st>`
    <st c="5234">name and select</st> **<st c="5251">Expand Macro</st>** <st c="5263">from
    the pop-up menu.</st> <st c="5286">The class body now looks</st> <st c="5311">like
    this:</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5180">要展开宏，我们可以右键单击</st> `<st c="5228">@Model</st>` <st c="5234">名称</st>，并从弹出菜单中选择**<st
    c="5251">展开宏</st>** <st c="5263">。</st> <st c="5286">现在类体看起来</st> <st c="5311">是这样的：</st>
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="6354">So, what happened</st> <st c="6373">to our beautiful and minimal</st>
    `<st c="6402">Book</st>` <st c="6406">class?</st> <st c="6414">It appears that
    the</st> `<st c="6434">@Model</st>` <st c="6440">macro has been quite</st> <st
    c="6462">active here.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6354">那么，我们的美丽且简约的</st> `<st c="6402">Book</st>` <st c="6406">类</st>
    <st c="6414">发生了什么</st>？<st c="6414">看起来</st> `<st c="6434">@Model</st>` <st c="6440">宏</st>
    <st c="6462">在这里非常</st> <st c="6462">活跃。</st>
- en: <st c="6474">To simplify it, let’s try to break</st> <st c="6510">it down:</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6474">为了简化，让我们尝试将其</st> <st c="6510">分解：</st>
- en: '`<st c="6523">Book</st>``<st c="6598">PersistentModel</st>` <st c="6613">and</st>
    `<st c="6618">Observable</st>`<st c="6628">. The</st> `<st c="6634">PersistentModel</st>`
    <st c="6649">protocol helps SwiftData work with our style and access its attributes.</st>
    <st c="6722">The</st> `<st c="6726">Observable</st>` <st c="6736">protocol allows
    us to be notified of changes to</st> <st c="6785">the data.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6523">Book</st>` `<st c="6598">PersistentModel</st>` `<st c="6613">和</st>
    `<st c="6618">Observable</st>` `<st c="6628">。` `<st c="6634">PersistentModel</st>`
    `<st c="6649">协议帮助 SwiftData 与我们的风格协同工作并访问其属性。</st> `<st c="6722">Observable</st>`
    `<st c="6736">协议允许我们通知数据的</st> `<st c="6785">更改。</st>`'
- en: '`<st c="6914">PersistentModel</st>` <st c="6929">protocol is, we will discover
    that it requires the implementation of two variables –</st>`<st c="7014">backingData</st>`
    <st c="7026">and</st> `<st c="7031">schemaMetaData</st>`<st c="7045">. We can
    see their implementation directly in our macro-expanded code.</st> <st c="7116">These
    variables help SwiftData to store and retrieve our entity information specifically
    for our properties.</st> <st c="7225">And perhaps this is where the real power
    of Swift Macro comes into play – the ability to generate code that is custom-made
    for</st> <st c="7352">our class.</st>'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6914">PersistentModel</st>` <st c="6929">协议是，我们将发现它需要实现两个变量——</st>`<st
    c="7014">backingData</st>` <st c="7026">和</st> `<st c="7031">schemaMetaData</st>`<st
    c="7045">。我们可以在我们的宏展开代码中直接看到它们的实现。</st> <st c="7116">这些变量帮助SwiftData专门为我们存储和检索我们的实体信息。</st>
    <st c="7225">并且也许这正是Swift宏真正强大的地方——能够生成针对</st> <st c="7352">我们的类定制的代码。</st>'
- en: '**<st c="7362">We have property macros</st>**<st c="7386">: If we look at the
    class properties, we can see that they have their macros now.</st> <st c="7469">Expanding
    them reveals that they have now become a computed variable, so we can store and
    retrieve data not from just our memory but also from our backing</st> <st c="7624">data
    store:</st>'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7362">我们有属性宏</st>**<st c="7386">：如果我们查看类属性，我们可以看到它们现在有自己的宏。</st> <st
    c="7469">展开它们会显示它们现在已成为计算变量，因此我们可以从我们的内存以及我们的后端</st> <st c="7624">数据存储中存储和检索数据：</st>'
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="7756">Additional lines</st> <st c="7774">of code wrap everything together,
    such as the observation and</st> <st c="7836">registering attributes.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7756">额外的代码行</st> <st c="7774">将所有内容组合在一起，例如观察和</st> <st c="7836">注册属性。</st>
- en: <st c="7859">Is this complicated?</st> <st c="7881">A little bit.</st> <st c="7895">But
    that’s one of the benefits of having a macro – to simplify complex implementations.</st>
    <st c="7983">What’s important to understand is that every class marked with a</st>
    `<st c="8048">@Model</st>` <st c="8054">macro immediately receives a store of
    its own and is added to the</st> <st c="8121">SwiftData schema.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7859">这很复杂吗？</st> <st c="7881">有一点。</st> <st c="7895">但这就是拥有宏的好处之一——简化复杂的实现。</st>
    <st c="7983">重要的是要理解，每个带有</st> `<st c="8048">@Model</st>` <st c="8054">宏的类立即获得自己的存储，并添加到</st>
    <st c="8121">SwiftData模式。</st>
- en: <st c="8138">However, to add a more complex data model, we need to be able to
    define relationships between our models.</st> <st c="8245">Let’s see how</st>
    <st c="8259">it works.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8138">然而，要添加更复杂的数据模型，我们需要能够定义模型之间的关系。</st> <st c="8245">让我们看看它是如何工作的。</st>
- en: <st c="8268">Adding relationships</st>
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8268">添加关系</st>
- en: <st c="8289">Unlike real life, in SwiftData, relationships</st> <st c="8336">are
    simple.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8289">与现实生活不同，在SwiftData中，关系</st> <st c="8336">很简单。</st>
- en: <st c="8347">A</st> **<st c="8350">relationship</st>** <st c="8362">is a</st>
    <st c="8368">database scheme that defines how entities are linked to each other,
    and in Core Data, we have two types of relationships –</st> **<st c="8491">to-one</st>**
    <st c="8497">and</st> **<st c="8502">to-many</st>**<st c="8509">. In short, a</st>
    *<st c="8523">to-one</st>* <st c="8529">relationship means that we will have one
    instance of the other kind for each entity instance.</st> <st c="8624">An example
    of that would be cars and engines – every car has one, and only one, engine, so
    that will make the relationship between them a</st> *<st c="8762">to-one</st>*
    <st c="8768">relationship.</st> <st c="8783">However, cars and wheels have a</st>
    *<st c="8815">to-many</st>* <st c="8822">relationship because a car can have</st>
    <st c="8859">multiple wheels.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8347">一个</st> **<st c="8350">关系</st>** <st c="8362">是一个数据库模式，它定义了实体如何相互关联，在Core
    Data中，我们有两种类型的关系——</st> **<st c="8491">一对一</st>** <st c="8497">和</st> **<st c="8502">多对多</st>**<st
    c="8509">。简而言之，一个</st> *<st c="8523">一对一</st>** <st c="8529">关系意味着对于每个实体实例，我们都会有一个其他类型的实例。</st>
    <st c="8624">一个例子就是汽车和引擎——每辆汽车都有一台，且只有一台引擎，因此它们之间的关系将是一个</st> *<st c="8762">一对一</st>**
    <st c="8768">关系。</st> <st c="8783">然而，汽车和轮子有一个</st> *<st c="8815">多对多</st>** <st
    c="8822">关系，因为一辆汽车可以有</st> <st c="8859">多个轮子。</st>
- en: <st c="8875">Even though the explanation is simple enough, it gets even simpler
    in SwiftData.</st> <st c="8957">If we want to define a relationship between models,
    we just need to create another variable, as</st> <st c="9053">shown here:</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8875">尽管解释足够简单，但在SwiftData中，它变得更简单。</st> <st c="8957">如果我们想在模型之间定义关系，我们只需要创建另一个变量，就像</st>
    <st c="9053">这里</st> <st c="9055">所示：</st>
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="9317">In our</st> <st c="9325">example, we added the following two properties
    to the</st> `<st c="9379">Book</st>` <st c="9383">class:</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9317">在我们的</st> <st c="9325">示例中，我们向</st> `<st c="9379">Book</st>` <st
    c="9383">类中添加了以下两个属性：</st>
- en: '`<st c="9390">Author</st>`<st c="9397">: This is a</st> *<st c="9410">to-one</st>*
    <st c="9416">relationship to the</st> `<st c="9437">Author</st>` <st c="9443">entity
    because, in our case, each book has only</st> <st c="9492">one author</st>'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="9390">Author</st>`<st c="9397">：这是一个</st> *<st c="9410">一对多</st> <st
    c="9416">关系到</st> `<st c="9437">Author</st>` <st c="9443">实体，因为在我们这个例子中，每本书只有一个</st>
    <st c="9492">作者</st>'
- en: '`<st c="9502">pages</st>`<st c="9508">: In the case of</st> `<st c="9526">Page</st>`
    <st c="9530">entity, we</st> <st c="9542">have a</st> *<st c="9549">to-many</st>*
    <st c="9556">relationship, since a book can contain</st> <st c="9596">multiple
    pages</st>'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="9502">页数</st>`<st c="9508">：在</st> `<st c="9526">Page</st>` <st c="9530">实体的情况下，我们</st>
    <st c="9542">有一个</st> *<st c="9549">多对多</st> <st c="9556">关系，因为一本书可以包含</st> <st
    c="9596">多个页面</st>'
- en: <st c="9610">One thing to note is that we also need to mark both</st> `<st c="9663">Page</st>`
    <st c="9667">and</st> `<st c="9672">Author</st>` <st c="9678">entities with the</st>
    `<st c="9697">@Model</st>` <st c="9703">macro, as they must be part of our schema.</st>
    <st c="9747">This can be seen in the</st> <st c="9771">following code:</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9610">有一点需要注意，我们还需要用</st> `<st c="9663">Page</st>` <st c="9667">和</st>
    `<st c="9672">Author</st>` <st c="9678">实体标记上</st> `<st c="9697">@Model</st>`
    <st c="9703">宏，因为它们必须是我们模式的一部分。</st> <st c="9747">这可以在以下代码中看到：</st>
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="9990">Is adding</st> <st c="10001">models so simple?</st> <st c="10019">The
    short answer is, yes!</st> <st c="10045">Linking entities to each other in SwiftData
    is as easy as adding</st> <st c="10110">a property.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9990">添加模型这么简单吗？</st> <st c="10001">简短的答案是，是的！</st> <st c="10019">在 SwiftData
    中将实体相互链接与添加一个属性一样简单。</st> <st c="10045">Linking entities to each other in SwiftData
    is as easy as adding</st> <st c="10110">a property.</st>
- en: <st c="10121">The longer answer is, well, we’ll have to do extra work to customize
    the relationships a little bit.</st> <st c="10223">Let’s meet the</st> `<st c="10238">@</st>``<st
    c="10239">Relationship</st>` <st c="10251">macro.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10121">更长的答案是，嗯，我们需要做一些额外的工作来稍微定制一下这些关系。</st> <st c="10223">让我们来认识一下</st>
    `<st c="10238">@</st>``<st c="10239">关系</st>` <st c="10251">宏。</st>
- en: <st c="10258">If you’re familiar with Core Data relationships, you probably
    know there is more than declaring</st> *<st c="10355">to-many</st>* <st c="10362">and</st>
    *<st c="10367">to-one</st>*<st c="10373">.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10258">如果你熟悉 Core Data 关系，你可能知道除了声明</st> *<st c="10355">多对多</st> <st
    c="10362">和</st> *<st c="10367">一对多</st>*<st c="10373">.</st>
- en: <st c="10374">To-many and to-one relationships</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10374">多对多和一对多关系</st>
- en: <st c="10407">To-one relationships</st> <st c="10429">represent associations
    between entities where</st> <st c="10475">one instance of an entity is related
    to another single instance of a different entity.</st> <st c="10562">Conversely,
    to-many relationships represent associations where one instance of an entity can
    be related to multiple instances of another entity.</st> <st c="10707">For example,
    in a bookstore database, a to-one relationship could connect a “book” entity to
    an “author” entity, as each book has one author.</st> <st c="10849">In contrast,
    a to-many relationship could connect a “book” entity to a “category” entity, as
    a book can belong to</st> <st c="10963">multiple categories.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10407">一对多关系</st> <st c="10429">表示实体之间的关联，其中</st> <st c="10475">一个实体的一个实例与另一个不同实体的单个实例相关联。</st>
    <st c="10562">相反，多对多关系表示关联，其中一个实体的一个实例可以与另一个实体的多个实例相关联。</st> <st c="10707">例如，在一个书店数据库中，一对多关系可以将“书”实体与“作者”实体连接起来，因为每本书只有一个作者。</st>
    <st c="10849">相比之下，多对多关系可以将“书”实体与“类别”实体连接起来，因为一本书可以属于</st> <st c="10963">多个类别。</st>
- en: <st c="10983">We can customize our relationship using the</st> `<st c="11028">@Relationship</st>`
    <st c="11041">macro in two</st> <st c="11055">primary ways.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10983">我们可以通过使用</st> `<st c="11028">@Relationship</st>` <st c="11041">宏来以两种主要方式自定义我们的关系。</st>
- en: <st c="11068">Let’s start with defining the</st> <st c="11099">deletion rules.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11068">让我们从定义</st> <st c="11099">删除规则。</st>
- en: <st c="11114">SwiftData relationship deletion rules</st>
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="11114">SwiftData 关系删除规则</st>
- en: <st c="11152">What happens to</st> `<st c="11169">pages</st>` <st c="11174">and</st>
    `<st c="11179">author</st>` <st c="11185">entities if we delete a book?</st> <st
    c="11216">Logically, all the book pages</st> <st c="11246">need to be deleted,
    but the author needs to be retained because they might be linked to another book.</st>
    <st c="11348">We can represent this logic with</st> *<st c="11381">deletion rules</st>*<st
    c="11395">; if you’re familiar with Core Data, it is basically the same as</st>
    <st c="11461">in SwiftData.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11152">如果我们删除一本书，</st> `<st c="11169">页面</st>` <st c="11174">和</st> `<st
    c="11179">作者</st>` <st c="11185">实体会发生什么？</st> <st c="11216">从逻辑上讲，所有书籍页面</st>
    <st c="11246">都需要被删除，但作者需要保留，因为他们可能与其他书籍相关联。</st> <st c="11348">我们可以用</st> *<st
    c="11381">删除规则</st>*<st c="11395">来表示这种逻辑；如果你熟悉 Core Data，它基本上与</st> <st c="11461">SwiftData</st>
    相同。
- en: <st c="11474">This is how we can define the logic to a property</st> <st c="11525">in
    SwiftData:</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11474">这就是我们如何在 SwiftData 中定义属性</st> <st c="11525">的逻辑：</st>
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '@Model'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '@模型'
- en: class Book {
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: class Book {
- en: '… <st c="13124">@Relationship(inverse: \Page.book) var pages: [Page] =</st>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '… <st c="13124">@关系（inverse: \Page.book） var pages: [Page] =</st>'
- en: <st c="13178">[]</st> …
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13178">[]</st> …
- en: '}'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Model'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '@模型'
- en: class Page {
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: class Page {
- en: 'var content: String <st c="13225">var book: Book?</st> init(content: String)
    {'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var content: String <st c="13225">var book: Book?</st> init(content: String)
    {'
- en: self.content = content
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.content = content
- en: '}'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: \Page.book
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: \Page.book
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'let newPage = Page(content: "Swift Data")'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'let newPage = Page(content: "Swift 数据")'
- en: newPage.book = book
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: newPage.book = book
- en: // book.pages property <st c="13678">contains</st> 'newPage'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: // book.pages 属性 <st c="13678">包含</st> 'newPage'
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '@Model'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '@模型'
- en: class Folder {
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: class Folder {
- en: 'var parent: Folder? @Relationship(inverse: \Folder.parent) var subFolders:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var parent: Folder? @关系（inverse: \Folder.parent） var subFolders:'
- en: '[Folder]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[文件夹]'
- en: 'var name: String'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var name: String'
- en: 'var id: UUID'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var id: UUID'
- en: 'init(parent: Folder? = nil, subFolders: [Folder], name:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'init(parent: Folder? = nil, subFolders: [Folder], name:'
- en: 'String, id: UUID) {'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'String, id: UUID) {'
- en: self.parent = parent
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.parent = parent
- en: self.subFolders = subFolders
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.subFolders = subFolders
- en: self.name = name
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.id = id
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.id = id
- en: '}'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'var firstName: String? = "MyName"'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'var firstName: String? = "MyName"'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="17295">@Attribute</st> macro with the <st c="17321">.unique</st> option
    makes our database’s specific property values unique.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17295">@属性</st> 宏与 <st c="17321">.unique</st> 选项使我们的数据库特定属性值唯一。
- en: '`<st c="17389">UUID</st>` <st c="17394">is a classic example of a unique value
    for a property, but we can apply that to any other type of property, such as user
    IDs</st> <st c="17520">and names.</st>'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="17389">UUID</st>` <st c="17394">是属性唯一值的经典示例，但我们可以将其应用于任何其他类型的属性，例如用户
    ID</st> <st c="17520">和名称。</st>'
- en: <st c="17530">But what does it really mean to make a property</st> *<st c="17579">unique</st>*<st
    c="17585">? What will happen when we try to insert an instance with an already
    existing</st> <st c="17663">unique attribute?</st>
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="17530">但是，将属性设置为</st> *<st c="17579">唯一</st>*<st c="17585">究竟意味着什么？当我们尝试插入一个已经存在</st>
    <st c="17663">唯一属性</st>的实例时，会发生什么？
- en: <st c="17680">In the case of a unique property, SwiftData performs an</st> `<st
    c="17769">INSERT</st>` <st c="17775">or</st> `<st c="17779">UPDATE</st>` <st c="17785">operation.</st>
    <st c="17797">This means that if an instance with a unique value already exists,
    SwiftData will not create a new object in its store but, rather, update the</st>
    <st c="17940">existing instance.</st>
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="17680">在唯一属性的情况下，SwiftData 执行</st> `<st c="17769">INSERT</st>` <st c="17775">或</st>
    `<st c="17779">UPDATE</st>` <st c="17785">操作。</st> <st c="17797">这意味着如果已存在具有唯一值的实例，SwiftData
    将不会在其存储中创建新对象，而是更新</st> <st c="17940">现有实例。</st>
- en: <st c="17958">Declaring a property as unique using the</st> `<st c="18000">@Attribute</st>`
    <st c="18010">macro is straightforward.</st> <st c="18037">However, sometimes
    we need something more sophisticated.</st> <st c="18094">For example, let’s say
    we have a</st> `<st c="18127">Book</st>` <st c="18131">model with</st> `<st c="18143">name</st>`
    <st c="18147">and</st> `<st c="18152">publicationName</st>` <st c="18167">properties.</st>
    <st c="18180">In our case, we can have two books with the same name or the same</st>
    `<st c="18246">publicationName</st>`<st c="18261">, but we can’t have two books
    when both properties are identical.</st> <st c="18327">The combination of</st>
    `<st c="18346">publicationName</st>` <st c="18361">and</st> `<st c="18366">name</st>`
    <st c="18370">creates the book’s</st> <st c="18390">unique identity.</st>
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `<st c="17958">@Attribute</st>` <st c="18000">宏将属性声明为唯一属性是直接的。</st> <st c="18037">然而，有时我们需要更复杂的功能。</st>
    <st c="18094">例如，假设我们有一个</st> `<st c="18127">Book</st>` <st c="18131">模型，具有</st>
    `<st c="18143">name</st>` <st c="18147">和</st> `<st c="18152">publicationName</st>`
    <st c="18167">属性。</st> <st c="18180">在我们的情况下，我们可以有两个同名或同</st> `<st c="18246">publicationName</st>`<st
    c="18261">的书籍，但我们不能有两个属性完全相同的书籍。</st> <st c="18327">`<st c="18346">publicationName</st>`
    <st c="18361">和</st> `<st c="18366">name</st>` <st c="18370">的组合构成了书籍的唯一标识。</st>
- en: <st c="18406">One solution is maintaining a property that tries to build a unique
    ID from these two properties.</st> <st c="18505">Another elegant option is to
    use the</st> `<st c="18542">#Unique</st>` <st c="18549">macro to define more complex</st>
    <st c="18579">uniqueness requirements:</st>
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18406">一个解决方案是维护一个属性，尝试从这两个属性中构建一个唯一的ID。</st> <st c="18505">另一个优雅的选项是使用</st>
    `<st c="18542">#Unique</st>` <st c="18549">宏来定义更复杂的</st> `<st c="18579">唯一性要求：</st>
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="18723">In this code example, we enforce the uniqueness of the</st> `<st
    c="18779">Book</st>` <st c="18783">model by combining two key paths.</st> <st
    c="18818">Just like the attribute parameter,</st> `<st c="18853">.unique</st>`<st
    c="18860">, if we try to insert a new book instance</st> <st c="18902">when we
    already have one with the same name and publication name, SwiftData will perform
    an</st> `<st c="18994">upsert</st>` <st c="19000">operation and update</st> <st
    c="19022">that instance.</st>
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18723">在这个代码示例中，我们通过组合两个键路径来强制执行</st> `<st c="18779">Book</st>` <st c="18783">模型的唯一性。</st>
    <st c="18818">就像属性参数一样，</st> `<st c="18853">.unique</st>`<st c="18860">，如果我们尝试插入一个新书籍实例，而我们已经有了一个同名和出版名称相同的实例，SwiftData将执行一个</st>
    `<st c="18994">upsert</st>` <st c="19000">操作并更新</st> `<st c="19022">该实例。</st>
- en: <st c="19036">Even though SwiftData handles unique attributes well, it is important
    to ensure we carefully pick unique attributes and key paths according to an application’s
    requirements.</st> <st c="19211">Too many unique attributes can cause complexity
    and</st> <st c="19263">performance issues.</st>
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19036">尽管SwiftData处理唯一属性很好，但确保我们根据应用程序的要求仔细选择唯一属性和键路径是很重要的。</st> <st
    c="19211">过多的唯一属性可能导致复杂性和</st> <st c="19263">性能问题。</st>
- en: <st c="19282">Unique attributes are great for simplifying the task of handling
    duplicate instances.</st> <st c="19369">Another attribute feature that can make
    our life simpler</st> <st c="19426">is</st> *<st c="19429">transient</st>*<st
    c="19438">.</st>
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19282">唯一属性非常适合简化处理重复实例的任务。</st> <st c="19369">另一个可以简化我们生活的属性特性是</st>
    *<st c="19429">瞬态</st>*<st c="19438">。</st>
- en: <st c="19439">Going non-persistent with transient</st>
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19439">使用瞬态属性进行非持久化</st>
- en: <st c="19475">The nice thing about working with SwiftData is that all properties
    automatically become the entity’s</st> <st c="19577">attributes and are saved
    persistently to the local data store.</st> <st c="19640">However, sometimes, there
    are cases where we want to have a property that is</st> *<st c="19717">memory-only</st>*
    <st c="19728">and not saved persistently.</st> <st c="19757">A formatted version
    of one of the values is an excellent example of such a property.</st> <st c="19842">One
    option to achieve that is to create a function or a computed variable, and then
    return a value based on the relevant property.</st> <st c="19973">However, there
    are other cases where a computed variable or a function is not a convenient solution.</st>
    <st c="20074">Let’s say we want a temporary counter or to maintain a flag relevant
    only to an application’s current</st> <st c="20176">life cycle.</st>
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19475">与SwiftData一起工作的好处是，所有属性都自动成为实体的</st> <st c="19577">属性，并且被持久保存到本地数据存储中。</st>
    <st c="19640">然而，有时，我们可能想要一个仅存在于内存中而不被持久保存的属性。</st> <st c="19717">内存中</st> *<st
    c="19728">并且不持久保存</st> *<st c="19757">的属性是一个很好的例子。</st> <st c="19842">实现这一目标的一种方法是创建一个函数或计算变量，然后根据相关属性返回一个值。</st>
    <st c="19973">然而，在其他情况下，计算变量或函数可能不是方便的解决方案。</st> <st c="20074">假设我们想要一个临时的计数器或维护一个仅与应用程序当前</st>
    <st c="20176">生命周期相关的标志。</st>
- en: <st c="20187">For these kinds of cases, we</st> <st c="20217">have a</st> *<st
    c="20224">transient</st>* <st c="20233">attribute.</st> <st c="20245">Transient
    attribute is not a new idea – Core Data had transient properties from its early
    versions.</st> <st c="20345">Since SwiftData is based on Core Data fundamentals,
    it supports transient properties out of</st> <st c="20437">the box.</st>
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20187">对于这类情况，我们</st> <st c="20217">有一个</st> *<st c="20224">瞬态</st> *<st
    c="20233">属性。</st> <st c="20245">瞬态属性不是一个新概念——Core Data从早期版本就支持瞬态属性。</st> <st
    c="20345">由于SwiftData基于Core Data的基本原理，它默认支持瞬态属性。</st>
- en: <st c="20445">Here is how we declare a</st> *<st c="20471">transient</st>* <st
    c="20480">property</st> <st c="20490">in SwiftData:</st>
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20445">以下是我们在SwiftData中声明</st> *<st c="20471">瞬态</st> *<st c="20480">属性</st>
    <st c="20490">的方法：</st>
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="20539">In this code snippet, the</st> `<st c="20566">openCounter</st>`
    <st c="20577">variable will not be saved locally to the persistent</st> <st c="20631">store
    and will be initialized each time we fetch the entity from</st> <st c="20696">our
    database.</st>
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20539">在这个代码片段中，</st> `<st c="20566">openCounter</st>` <st c="20577">变量不会被保存到本地持久</st>
    <st c="20631">存储中，并且每次我们从</st> <st c="20696">我们的数据库中检索实体时都会重新初始化。</st>
- en: <st c="20709">Transient properties may sound like a minor feature, but there
    are many cases where it really makes the difference, and the transient macro provides
    this flexibility.</st> <st c="20877">Full names or calculated ages are great examples</st>
    <st c="20926">of that.</st>
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20709">瞬态属性可能听起来是一个小功能，但在许多情况下，它确实能带来差异，瞬态宏提供了这种灵活性。</st> <st c="20877">全名或计算年龄是很好的例子</st>
    <st c="20926">。</st>
- en: <st c="20934">Exploring the container</st>
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20934">探索容器</st>
- en: <st c="20958">Until now, we discussed how to declare the different entities
    using the</st> `<st c="21031">@Model</st>` <st c="21037">macro, define their</st>
    <st c="21058">relationships using the</st> `<st c="21082">@Relationship</st>`
    <st c="21095">macro, and customize their attributes using the</st> `<st c="21144">@</st>``<st
    c="21145">Attribute</st>` <st c="21154">macro.</st>
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20958">到目前为止，我们讨论了如何使用</st> `<st c="21031">@Model</st>` <st c="21037">宏声明不同的实体，使用</st>
    `<st c="21082">@Relationship</st>` <st c="21095">宏定义它们的关系，以及使用</st> `<st c="21144">@</st>``<st
    c="21145">Attribute</st>` <st c="21154">宏自定义它们的属性。</st>
- en: <st c="21161">However, we haven’t discussed setting up SwiftData to work with
    a schema and a</st> <st c="21241">persistent store.</st>
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21161">然而，我们还没有讨论如何设置SwiftData与模式和一个</st> <st c="21241">持久存储</st>一起工作。</st>
- en: <st c="21258">When we delved into the</st> `<st c="21283">@Model</st>` <st c="21289">macro,
    drawing parallels with Core Data was straightforward and remains so now.</st>
    <st c="21370">In Core Data, we set up the stack using</st> `<st c="21410">NSPersistentContainer</st>`<st
    c="21431">, which encapsulates the different components, such as the data model,
    the store, and the context, into one stack that we can</st> <st c="21557">work
    with.</st>
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21258">当我们深入研究</st> `<st c="21283">@Model</st>` <st c="21289">宏时，与Core
    Data的比较是直接的，并且现在仍然是如此。</st> <st c="21370">在Core Data中，我们使用</st> `<st c="21410">NSPersistentContainer</st>`<st
    c="21431">设置堆栈，它将数据模型、存储和上下文等不同组件封装到一个我们可以</st> <st c="21557">与之工作的堆栈中。</st>
- en: <st c="21567">In SwiftData, we use</st> `<st c="21589">ModelContainer</st>`<st
    c="21603">, which has the</st> <st c="21619">same responsibility.</st>
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21567">在SwiftData中，我们使用</st> `<st c="21589">模型容器</st>`<st c="21603">，它具有相同的职责。</st>
- en: <st c="21639">Let’s try to understand how</st> <st c="21668">it works.</st>
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21639">让我们尝试理解它是如何工作的。</st> <st c="21668">。</st>
- en: <st c="21677">Setting up ModelContainer</st>
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21677">设置模型容器</st>
- en: '`<st c="21703">ModelContainer</st>` <st c="21718">is essential</st> <st c="21732">for
    working with SwiftData.</st> <st c="21760">The reason is that SwiftData has three
    main components that the container encapsulates and</st> <st c="21851">wraps together:</st>'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="21703">模型容器</st>` <st c="21718">对于使用SwiftData至关重要。</st> <st c="21732">原因是SwiftData有三个主要组件，容器将它们封装并</st>
    <st c="21851">一起包装：</st>'
- en: '`<st c="21962">@Model</st>` <st c="21968">macro to</st> <st c="21978">our entities</st>'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="21962">@Model</st>` <st c="21968">宏到</st> <st c="21978">我们的实体</st>'
- en: '**<st c="21990">The store</st>**<st c="22000">: The backend store where we
    will save</st> <st c="22040">our data</st>'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21990">存储</st>**<st c="22000">：我们将保存数据的后端存储'
- en: '**<st c="22048">The context</st>**<st c="22060">: This is our link to the store
    and the sandbox, where we can add, edit, and delete</st> <st c="22145">different
    records</st>'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22048">上下文</st>**<st c="22060">：这是我们与存储和沙盒的链接，我们可以添加、编辑和删除</st> <st
    c="22145">不同的记录</st>'
- en: <st c="22162">Here is the basic and minimal way to create</st> <st c="22207">a
    container:</st>
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22162">以下是以基本和最小的方式创建</st> <st c="22207">容器的方法：</st>
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="22411">In this code, we create an object from the</st> `<st c="22455">ModelContainer</st>`
    <st c="22469">type and provide it with the three models we made earlier in the</st>
    *<st c="22535">Defining a SwiftData</st>* *<st c="22556">Model</st>* <st c="22561">section.</st>
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22411">在这段代码中，我们从一个</st> `<st c="22455">模型容器</st>` <st c="22469">类型创建一个对象，并为其提供我们在</st>
    *<st c="22535">定义SwiftData</st>* *<st c="22556">模型</st>* <st c="22561">部分中早先创建的三个模型。</st>
- en: <st c="22570">Note that, in our case, we have one parameter,</st> `<st c="22618">Schema</st>`<st
    c="22624">, which holds all the different models relevant to our container –</st>
    `<st c="22691">Book</st>`<st c="22695">,</st> `<st c="22697">Author</st>`<st c="22703">,</st>
    <st c="22705">and</st> `<st c="22709">Page</st>`<st c="22713">.</st>
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22570">请注意，在我们的情况下，我们有一个参数，</st> `<st c="22618">模式</st>`<st c="22624">，它包含与我们的容器相关的所有不同模型
    –</st> `<st c="22691">书籍</st>`<st c="22695">，`<st c="22697">作者</st>`<st c="22703">，`<st
    c="22705">和</st> `<st c="22709">页面</st>`<st c="22713">。</st>
- en: <st c="22714">The fact that we need to provide a list of models may raise some
    eyebrows – why do we need to do that?</st> <st c="22818">Can’t Xcode locate all
    the models and add them automatically?</st> <st c="22880">The</st> `<st c="22884">@Model</st>`
    <st c="22890">macro indeed expands code at compile time, but it doesn’t mean SwiftData
    is aware of all our entities when we set it up at the beginning of the app run.</st>
    <st c="23044">So, whenever we add a new model, we must add it to the list of models
    in our</st> `<st c="23121">Schema</st>` <st c="23127">parameter.</st>
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22714">我们需要提供一个模型列表的事实可能会让人感到惊讶 – 为什么我们需要这样做呢？</st> <st c="22818">Xcode不能定位所有模型并自动将它们添加进去吗？</st>
    <st c="22880">的确，</st> `<st c="22884">@Model</st>` <st c="22890">宏在编译时扩展代码，但这并不意味着SwiftData在应用运行开始时设置时就知道我们所有的实体。</st>
    <st c="23044">因此，每次我们添加一个新的模型时，我们必须将其添加到我们的</st> `<st c="23121">模式</st>` <st c="23127">参数中的模型列表中。</st>
- en: <st c="23138">Regarding including the</st> `<st c="23163">Book</st>` <st c="23167">entity
    independently from the</st> `<st c="23198">Author</st>` <st c="23204">entity –
    when we add the</st> `<st c="23230">Book</st>` <st c="23234">model to the models’
    list, it automatically consists of all associated models, including those related
    to the models further down the</st> <st c="23369">hierarchy.</st> <st c="23380">It
    means that, theoretically, we can include only the root object while doing something</st>
    <st c="23468">like that:</st>
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23138">关于独立包含</st> `<st c="23163">书籍</st>` <st c="23167">实体，而不是</st>
    `<st c="23198">作者</st>` <st c="23204">实体 – 当我们将</st> `<st c="23230">书籍</st>` <st
    c="23234">模型添加到模型列表中时，它自动包含所有相关模型，包括那些与</st> <st c="23369">层次结构中更下方的模型</st> <st
    c="23380">相关的模型。</st> <st c="23380">这意味着，从理论上讲，我们可以在进行类似操作时只包含根对象：</st>
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="23498">And that</st> <st c="23508">will be enough to include</st> `<st
    c="23534">Author</st>` <st c="23540">and</st> `<st c="23545">Page</st>`<st c="23549">.</st>
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23498">这</st> <st c="23508">就足够包含</st> `<st c="23534">作者</st>` <st c="23540">和</st>
    `<st c="23545">页面</st>`<st c="23549">。</st>
- en: <st c="23550">So, what will we do with the container instance we just created?</st>
    <st c="23616">Let’s see in the</st> <st c="23633">next section.</st>
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23550">所以，我们将如何使用我们刚刚创建的容器实例呢？</st> <st c="23616">让我们在下一节中看看。</st> <st
    c="23633">译文：</st>
- en: <st c="23646">Connecting the container using the modelContainer modifier</st>
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23646">使用模型容器修饰符连接容器</st>
- en: <st c="23705">Now that</st> <st c="23715">we have a model container, we want
    to link it somehow to our UI so that we can start</st> <st c="23800">using it.</st>
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23705">现在我们有了模型容器，我们希望以某种方式将其与我们的UI连接起来，以便我们可以开始使用它。</st> <st c="23715">译文：</st>
- en: <st c="23809">To do that, we will use the</st> `<st c="23838">modelContainer</st>`
    <st c="23852">modifier to connect the container to</st> <st c="23890">our scene:</st>
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23809">为了做到这一点，我们将使用`<st c="23838">modelContainer</st>` `<st c="23852">修饰符将容器连接到我们的场景：</st>
    <st c="23890">译文：</st>
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="23982">In our code example, we add the</st> `<st c="24014">modelContainer</st>`
    <st c="24028">modifier to our</st> `<st c="24045">WindowGroup</st>`<st c="24056">,
    thus making it available to the</st> <st c="24090">whole app.</st>
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23982">在我们的代码示例中，我们将`<st c="24014">modelContainer</st>` `<st c="24028">修饰符添加到我们的`<st
    c="24045">WindowGroup</st>` `<st c="24056">中，使其在整个应用程序中可用。</st> <st c="24090">译文：</st>
- en: <st c="24100">Instead of creating a connector and connecting it to</st> `<st
    c="24154">WindowGroup</st>`<st c="24165">, we can use another</st> `<st c="24186">modeContainer</st>`
    `<st c="24199">init</st>` <st c="24204">method and pass only the list</st> <st
    c="24235">of entities:</st>
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24100">我们不需要创建连接器并将其连接到`<st c="24154">WindowGroup</st>`，我们可以使用另一个`<st
    c="24186">modeContainer</st>` `<st c="24199">init</st>` `<st c="24204">方法，并仅传递实体列表：</st>
    <st c="24235">译文：</st>
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="24304">Passing the list of entities can be a simple and easy way of setting
    up a container.</st> <st c="24390">So, why do we need the</st> `<st c="24413">ModelContainer</st>`
    <st c="24427">class?</st> <st c="24435">The simple answer is, as always, to provide
    more customization.</st> <st c="24499">Let’s</st> <st c="24505">see how!</st>
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24304">传递实体列表可以是一种简单且易于设置容器的方法。</st> <st c="24390">那么，为什么我们需要</st> `<st
    c="24413">ModelContainer</st>` <st c="24427">类呢？</st> <st c="24435">简单的回答是，一如既往，为了提供更多的定制。</st>
    <st c="24499">让我们</st> <st c="24505">看看吧！</st> <st c="24513">译文：</st>
- en: <st c="24513">Working with ModelConfiguration</st>
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24513">译文：</st>
- en: <st c="24545">The</st> `<st c="24550">ModelContainer</st>` <st c="24564">offers
    us more than just scheme passing; it empowers us to configure our</st> `<st c="24638">SwiftData</st>`
    <st c="24647">store for specific models and customize it to our</st> <st c="24698">particular
    requirements.</st>
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24545">`<st c="24550">ModelContainer</st>` `<st c="24564">不仅提供了模式传递的功能；它还赋予我们配置特定模型的`<st
    c="24638">SwiftData</st>` `<st c="24647">存储并对其进行定制以满足我们`<st c="24698">特定需求`的能力。</st>
    <st c="24705">译文：</st>
- en: <st c="24722">To do</st> <st c="24729">that, we will use the</st> `<st c="24751">ModelConfiguration</st>`
    <st c="24769">struct,</st> <st c="24778">as follows:</st>
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24722">为了做到这一点，我们将使用`<st c="24751">ModelConfiguration</st>` `<st c="24769">结构体，如下所示：</st>
    <st c="24778">译文：</st>
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="25128">Let’s try to understand what is happening in this code snippet.</st>
    <st c="25193">First, we create a schema with a list of our models.</st> <st c="25246">Then,
    we declare a model configuration struct, pass the schema, and set its backend
    store to in-memory.</st> <st c="25350">Finally, we return a model container based
    on our schema and a set containing the configuration we</st> <st c="25449">just
    created.</st>
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25128">让我们尝试理解这个代码片段中正在发生的事情。</st> <st c="25193">首先，我们创建一个包含我们模型列表的模式。</st>
    <st c="25246">然后，我们声明一个模型配置结构体，传递模式，并将其后端存储设置为内存。</st> <st c="25350">最后，我们根据我们的模式和刚刚创建的配置集合返回一个模型容器。</st>
    <st c="25449">译文：</st>
- en: <st c="25462">All this process feels a little bit awkward, clumsy, and redundant
    – why do we need to create a configuration if we’re passing the same schema again?</st>
    <st c="25613">And why is it a set?</st> <st c="25634">The main configuration idea
    is to provide different behavior for a different set</st> <st c="25715">of models.</st>
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25462">整个过程感觉有点笨拙、笨拙和重复——如果我们再次传递相同的模式，为什么还需要创建配置呢？</st> <st c="25613">而且为什么它是集合形式呢？</st>
    <st c="25634">主要配置思想是为不同的模型集合提供不同的行为。</st> <st c="25715">译文：</st>
- en: <st c="25725">Here’s an example.</st> <st c="25745">Imagine we have a brainstorm
    sketch app.</st> <st c="25786">We want to sketch and store our concepts in the
    app’s persistent storage while all drawings on the whiteboard canvas remain</st>
    <st c="25910">in memory.</st>
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25725">这里有一个例子。</st> <st c="25745">想象一下，我们有一个头脑风暴草图应用。</st> <st c="25786">我们想在应用程序的持久存储中绘制并存储我们的概念，而白板画布上的所有绘图都保留在内存中。</st>
    <st c="25910">译文：</st>
- en: <st c="25920">In this case, we can</st> <st c="25942">create two configurations,
    one for in-memory and one for</st> <st c="25999">persistent storage and</st> **<st
    c="26022">CloudKit</st>** <st c="26030">integration:</st>
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此情况下，我们可以<st c="25920">创建两个配置，一个用于内存，一个用于</st> <st c="25942">持久存储和</st> **<st
    c="26022">CloudKit</st>** <st c="26030">集成：</st>
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="26550">In our example, we created two different schemas – a list of models
    for brainstorming and a list of models for the</st> <st c="26666">user projects.</st>
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26550">在我们的例子中，我们创建了两个不同的模式——一个用于头脑风暴的模型列表和一个用于</st> <st c="26666">用户项目的模型列表。</st>
- en: <st c="26680">Based on these models, we create two different configurations.</st>
    <st c="26744">The idea brainstorming configuration is saved in memory, and the
    projects’ configuration is saved locally and syncs</st> <st c="26860">to CloudKit.</st>
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26680">基于这些模型，我们创建了两个不同的配置。</st> <st c="26744">头脑风暴配置保存在内存中，而项目配置保存在本地并同步到</st>
    <st c="26860">CloudKit。</st>
- en: <st c="26872">Working with two different configurations and schemas for two
    app features is a great example of model configuration usage.</st> <st c="26997">We
    can use the model configuration for additional customization, such as</st> <st
    c="27070">the following:</st>
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26872">使用两个不同的配置和两个应用程序功能的模式是模型配置使用的绝佳例子。</st> <st c="26997">我们可以使用模型配置进行额外的自定义，例如</st>
    <st c="27070">以下内容：</st>
- en: <st c="27084">Different</st> <st c="27095">store files</st>
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27084">不同的</st> <st c="27095">存储文件</st>
- en: <st c="27106">Different</st> <st c="27117">group containers</st>
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27106">不同的</st> <st c="27117">组容器</st>
- en: <st c="27133">Different</st> <st c="27144">auto-saving mechanisms</st>
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27133">不同的</st> <st c="27144">自动保存机制</st>
- en: <st c="27166">However, let’s suppose we don’t need the model configuration to
    configure different behavior</st> <st c="27260">for different groups of models.</st>
    <st c="27292">In that case, we can work directly with the model container and
    initiate it with the</st> <st c="27377">entire schema.</st>
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27166">然而，假设我们不需要模型配置来为不同的模型组配置不同的行为</st> <st c="27260">。</st> <st c="27292">在这种情况下，我们可以直接与模型容器一起工作，并使用整个模式</st>
    <st c="27377">来初始化它。</st>
- en: <st c="27391">We now know how to declare and group our models for a schema to
    be used in a model container.</st> <st c="27486">But there’s one crucial thing
    missing – how to insert, update, and fetch data.</st> <st c="27565">We will</st>
    <st c="27572">do that by placing the missing piece in the puzzle –</st> <st c="27626">the
    context.</st>
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27391">我们现在知道如何声明和分组我们的模型以用于模型容器中的模式。</st> <st c="27486">但还有一个关键的东西缺失——如何插入、更新和获取数据。</st>
    <st c="27565">我们将通过放置拼图中的缺失部分——</st> <st c="27626">上下文。</st> 来完成这些操作。
- en: <st c="27638">Fetching and manipulating our data using model context</st>
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27638">使用模型上下文获取和操作我们的数据</st>
- en: <st c="27693">Developers familiar with Core Data are also familiar with the
    idea of</st> **<st c="27764">context</st>**<st c="27771">. Context is our data</st>
    <st c="27793">sandbox.</st> <st c="27802">This is the place where we can manipulate</st>
    <st c="27844">and fetch data, and it’s the link</st> <st c="27878">between our
    models and the</st> <st c="27905">persistent store.</st>
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27693">熟悉 Core Data 的开发者也熟悉**<st c="27764">上下文</st>**<st c="27771">的概念。上下文是我们的数据</st>
    <st c="27793">沙盒。</st> <st c="27802">这是我们可以操作和获取数据的地方，也是我们模型和</st> <st c="27844">持久存储之间的</st>
    <st c="27878">链接。</st>
- en: <st c="27922">To gain</st> <st c="27931">access to our context from our SwiftUI
    view, we can use an environment variable</st> <st c="28011">named</st> `<st c="28017">modelContext</st>`<st
    c="28029">:</st>
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27922">要访问我们的上下文以从我们的 SwiftUI 视图中获取，我们可以使用一个名为</st> <st c="28011">modelContext</st>
    <st c="28029">的环境变量：</st>
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="28114">The</st> `<st c="28119">modelContext</st>` <st c="28131">environment
    variable is available whenever we set up our scene using the</st> `<st c="28205">modelContainer</st>`
    <st c="28219">modifier.</st>
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28114">当使用</st> `<st c="28205">modelContainer</st>` <st c="28219">修饰符设置场景时，`<st
    c="28119">modelContext</st>` <st c="28131">环境变量始终可用。</st>
- en: <st c="28229">In non-SwiftUI</st> <st c="28245">instances, we can access the</st>
    <st c="28274">context using our model container</st> `<st c="28308">mainContext</st>`
    <st c="28319">property:</st>
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28229">在非 SwiftUI</st> <st c="28245">实例中，我们可以使用我们的模型容器</st> `<st c="28308">mainContext</st>`
    <st c="28319">属性来访问上下文：</st>
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="28375">To understand</st> <st c="28390">how to work with a model context,
    we’ll</st> <st c="28430">start with the most basic operation, saving new objects
    for</st> <st c="28490">our store.</st>
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28375">为了理解</st> <st c="28390">如何与模型上下文一起工作，我们将</st> <st c="28430">从最基本的操作开始，为我们的存储保存新的对象。</st>
- en: <st c="28500">Saving new objects</st>
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28500">保存新对象</st>
- en: <st c="28519">At the beginning of this chapter, in the</st> *<st c="28561">Defining
    a SwiftData model</st>* <st c="28587">section, we learned that our models are
    just Swift classes marked with a</st> `<st c="28661">@</st>``<st c="28662">Model</st>`
    <st c="28667">macro.</st>
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28519">在本章的开头，在</st> *<st c="28561">定义SwiftData模型</st>* <st c="28587">部分，我们了解到我们的模型只是标记有</st>
    `<st c="28661">@</st>``<st c="28662">Model</st>` <st c="28667">宏的Swift类。</st>
- en: <st c="28674">The way we</st> <st c="28686">define a model in SwiftData also
    means that the creation of a new instance is straightforward</st> <st c="28780">for
    us:</st>
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28674">我们在SwiftData中定义模型的方式也意味着新实例的创建对我们来说非常直接</st> <st c="28686">：</st>
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="28845">Our next step is adding that book instance to</st> <st c="28892">our
    context:</st>
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28845">我们的下一步是将该书籍实例添加到</st> <st c="28892">我们的上下文中：</st>
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="28933">Adding</st> `<st c="28941">newBook</st>` <st c="28948">to the
    model context doesn’t necessarily mean it is being saved to our persistent store,
    but it does mean that it is in our context and is ready to be pushed forward to
    our store.</st> <st c="29129">Having our entity in our context helps us manage
    the interaction between our app and the underlying persistent store.</st> <st
    c="29247">In our context, we can make changes, adding and deleting information
    without actually saving these actions to our data store.</st> <st c="29373">The
    context is beneficial when working with concurrency operations or when we want
    to manage</st> <st c="29466">undo operations.</st>
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28933">添加</st> `<st c="28941">newBook</st>` <st c="28948">到模型上下文并不一定意味着它被保存到我们的持久存储中，但它确实意味着它在我们的上下文中，并且已准备好被推送到我们的存储。</st>
    <st c="29129">在我们的上下文中，我们可以进行更改，添加和删除信息，而无需实际将这些操作保存到我们的数据存储中。</st> <st c="29247">上下文在处理并发操作或当我们想要管理</st>
    <st c="29466">撤销操作时非常有用。</st>
- en: <st c="29482">To actually save to the persistent store, we can use the context</st>
    `<st c="29548">save()</st>` <st c="29554">method:</st>
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29482">要实际保存到持久存储，我们可以使用上下文的</st> `<st c="29548">save()</st>` <st c="29554">方法：</st>
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'var body: some Scene {'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'var body: some Scene {'
- en: WindowGroup {
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: WindowGroup {
- en: ContentView()
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ContentView()
- en: '}'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '.modelContainer(for: Book.self, <st c="29938">isAutosaveEnabled:</st>'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '.modelContainer(for: Book.self, <st c="29938">isAutosaveEnabled:</st>'
- en: <st c="29956">false</st>)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29956">false</st>)
- en: '}'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'let fetchDesciprtor = <st c="31509">FetchDescriptor</st><Book>(predicate:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'let fetchDesciprtor = <st c="31509">FetchDescriptor</st><Book>(predicate:'
- en: '#Predicate { $0.name == "My Book"})'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#Predicate { $0.name == "My Book"})'
- en: let book = try? modelContext.fetch(fetchDesciprtor).first
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: let book = try? modelContext.fetch(fetchDesciprtor).first
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'let fetchDesciprtor = FetchDescriptor<Book>(predicate:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'let fetchDesciprtor = FetchDescriptor<Book>(predicate:'
- en: '#Predicate { book in'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#Predicate { book in'
- en: return book.pages.count > 10
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return book.pages.count > 10
- en: '})'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<st c="32813">@Query private var books: [Book]</st> var body: some View {'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="32813">@Query private var books: [Book]</st> var body: some View {'
- en: List {
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: List {
- en: ForEach(books) { book in
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ForEach(books) { book in
- en: Text(book.name)
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text(book.name)
- en: '}'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '@Query(<st c="33764">filter: #Predicate<Book> {</st>'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '@Query(<st c="33764">filter: #Predicate<Book> {</st>'
- en: <st c="33791">$0.pages.count > 300</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33791">$0.pages.count > 300</st>
- en: <st c="33887">@Query</st> that returns only books that contain more than 300
    pages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33887">@Query</st> 仅返回包含超过300页的书籍。
- en: <st c="33951">Of course, we can perform even more complex queries by upgrading
    our Swift expression inside</st> <st c="34045">the predicate:</st>
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33951">当然，我们可以通过升级在谓词内的Swift表达式来执行更复杂的查询：</st> <st c="34045">：</st>
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="34179">In this example, we filter books that contain more than 300 pages,
    but this time, we also want to</st> <st c="34278">receive books that we haven’t
    read or are marked as favorites.</st> <st c="34341">The fact that we use a Swift
    expression to filter our results makes our queries more descriptive and powerful</st>
    <st c="34451">than</st> `<st c="34456">NSPredicate</st>`<st c="34467">.</st>
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34179">在这个例子中，我们过滤出包含超过300页的书籍，但这次，我们还想</st> <st c="34278">接收那些我们尚未阅读或标记为收藏的书籍。</st>
    <st c="34341">我们使用Swift表达式来过滤结果，这使得我们的查询更加描述性和强大</st> <st c="34451">，比</st> `<st
    c="34456">NSPredicate</st>`<st c="34467">.</st>
- en: <st c="34468">However, when displaying data in a list, it is not enough to filter
    it; it is also crucial to sort it.</st> <st c="34572">That’s the job of our second
    main</st> `<st c="34606">@</st>``<st c="34607">Query</st>` <st c="34612">feature.</st>
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34468">然而，当在列表中显示数据时，仅仅过滤是不够的；还需要对其进行排序。</st> <st c="34572">这就是我们第二个主要</st>
    `<st c="34606">@</st>``<st c="34607">Query</st>` <st c="34612">功能的作用。</st>
- en: <st c="34621">Sorting the data</st>
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34621">对数据进行排序</st>
- en: <st c="34638">Sorting is an essential aspect of presenting information to our
    users.</st> <st c="34710">We should remember</st> <st c="34729">that sorting is
    not a lightweight task; it requires a complex algorithm to be</st> <st c="34807">done
    efficiently.</st>
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34638">排序是向用户展示信息的一个基本方面。</st> <st c="34710">我们应该记住</st> <st c="34729">排序不是一个轻量级任务；它需要一个复杂的算法才能高效完成。</st>
- en: <st c="34824">That’s why we need to ensure that we can sort by a property whose
    type conforms to the</st> `<st c="34912">SortComparator</st>` <st c="34926">protocol,
    introduced as part of</st> <st c="34959">iOS 15.</st>
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34824">这就是为什么我们需要确保我们可以按符合iOS 15中引入的`<st c="34912">SortComparator</st>`
    <st c="34926">协议的类型属性进行排序。</st>
- en: <st c="34966">Let’s see how we can sort our</st> <st c="34997">filtered books:</st>
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34966">让我们看看我们如何对</st> <st c="34997">过滤后的书籍进行排序：</st>
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="35172">In this example, we pass an array of</st> `<st c="35210">SortDescriptor</st>`
    <st c="35224">– we first sort by the book name and then by its number of pages.</st>
    <st c="35291">It’s pretty easy to use</st> `<st c="35315">SortDescriptor</st>`
    <st c="35329">– we initialize it using a key path to the desired property, just
    like in the</st> <st c="35408">preceding example.</st>
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35172">在这个例子中，我们传递了一个`<st c="35210">SortDescriptor</st>` <st c="35224">数组——我们首先按书名排序，然后按页数排序。</st>
    <st c="35291">使用`<st c="35315">SortDescriptor</st>` <st c="35329">非常简单——我们使用一个指向所需属性的键路径来初始化它，就像在先前的例子中一样。</st>
- en: <st c="35426">Performing sorting with SwiftData is extremely simple.</st> <st
    c="35482">However, under the hood, it requires</st> <st c="35519">running algorithms
    that must be optimized for performance in order to work efficiently.</st> <st
    c="35607">We don’t need these optimizations when working with 100 or 200 records.</st>
    <st c="35679">However, there are cases when our data store contains thousands
    of records.</st> <st c="35755">For these cases, we need to index</st> <st c="35789">our
    data.</st>
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用SwiftData进行排序极其简单。<st c="35426">然而，在底层，它需要运行必须针对性能进行优化的算法，以便高效工作。</st> <st
    c="35482">当我们处理100或200条记录时，我们不需要这些优化。</st> <st c="35519">然而，当我们的数据存储包含数千条记录时，情况就不同了。</st>
    <st c="35607">在这些情况下，我们需要对数据进行索引。</st> <st c="35679">我们的数据。</st>
- en: '<st c="35798">Adding the #Index macro for performance</st>'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35798">添加#Index宏以提高性能</st>
- en: <st c="35838">Before we index our data, let’s try to understand what it means
    exactly.</st> <st c="35912">When performing</st> <st c="35928">read operations
    such as sorting or querying, we expect our app to work seamlessly with thousands
    of records.</st> <st c="36037">Obviously, performing a full-table scan to find
    a book named</st> *<st c="36098">Mastering iOS 18</st>* <st c="36114">is inefficient.</st>
    <st c="36131">So, what do we do?</st> <st c="36150">Like a book index, the database
    index contains keys that help it locate a specific record.</st> <st c="36241">For
    example, if we want to index our book’s</st> `<st c="36285">name</st>` <st c="36289">property,
    we can create a data structure, such as a B-tree, which can help us locate the
    exact instance according to</st> <st c="36407">its name.</st>
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35838">在我们对数据进行索引之前，让我们先了解一下这究竟意味着什么。</st> <st c="35912">当执行排序或查询等读取操作时，我们希望我们的应用程序能够与数千条记录无缝工作。</st>
    <st c="36037">显然，对整个表进行全表扫描以查找名为</st> *<st c="36098">Mastering iOS 18</st>* <st
    c="36114">的书籍是不高效的。</st> <st c="36131">那么我们该怎么办呢？</st> <st c="36150">就像书籍索引一样，数据库索引包含键，帮助它定位特定记录。</st>
    <st c="36241">例如，如果我们想对书籍的</st> `<st c="36285">name</st>` <st c="36289">属性进行索引，我们可以创建一个数据结构，如B树，它可以帮助我们根据</st>
    <st c="36407">其名称定位精确实例。</st>
- en: <st c="36416">In SwiftData, we don’t need to create any structure to index our
    data.</st> <st c="36488">All we need to do is add the</st> `<st c="36517">#Index</st>`
    <st c="36523">macro to</st> <st c="36533">our model:</st>
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36416">在SwiftData中，我们不需要创建任何结构来索引我们的数据。</st> <st c="36488">我们只需要将</st>
    `<st c="36517">#Index</st>` <st c="36523">宏添加到</st> <st c="36533">我们的模型中：</st>
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="36672">If the preceding code looks familiar, that’s because we did something
    similar when we added the</st> `<st c="36769">#Unique</st>` <st c="36776">macro
    to our model in the</st> *<st c="36803">Adding the @Attribute</st>* *<st c="36825">macro</st>*
    <st c="36830">section.</st>
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36672">如果前面的代码看起来很熟悉，那是因为我们在</st> *<st c="36803">添加 @Attribute</st>*
    *<st c="36825">宏</st>* <st c="36830">部分添加了</st> `<st c="36769">#Unique</st>` <st
    c="36776">宏到我们的模型中时，我们做了类似的事情。</st>
- en: <st c="36839">In this case, we decided to add two indexes to</st> <st c="36887">our
    model:</st>
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36839">在这种情况下，我们决定为我们</st> <st c="36887">模型添加两个索引：</st>
- en: <st c="36897">The first is to index the name property, allowing an app to sort
    records by name or query data for a specific</st> <st c="37008">book name.</st>
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="36897">第一个是索引名称属性，允许应用程序按名称排序记录或查询特定</st> `<st c="37008">书籍名称</st>` <st
    c="37095">的数据。</st>
- en: <st c="37018">The second index is based on the combination of the</st> `<st
    c="37071">name</st>` <st c="37075">and</st> `<st c="37080">publicationName</st>`
    <st c="37095">properties</st>
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="37018">第二个索引是基于</st> `<st c="37071">name</st>` <st c="37075">和</st> `<st
    c="37080">publicationName</st>` <st c="37095">属性的</st>
- en: <st c="37106">If you remember from the</st> *<st c="37132">Adding the @Attribute
    macro</st>* <st c="37159">section, we decided that this combination defines our
    book’s uniqueness.</st> <st c="37233">Creating an index for this combination can
    help us quickly find a specific book</st> <st c="37313">when needed.</st>
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37106">如果您还记得从</st> *<st c="37132">添加 @Attribute 宏</st>* <st c="37159">部分，我们决定这个组合定义了我们书籍的独特性。</st>
    <st c="37233">为这个组合创建索引可以帮助我们在需要时快速找到特定的书籍</st> <st c="37313">。</st>
- en: <st c="37325">Indexing looks like magic – we add another key path to the list
    of indexes, and everything works faster.</st> <st c="37431">So, why not do that
    for all properties?</st> <st c="37471">What’s</st> <st c="37478">the catch?</st>
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37325">索引看起来像魔法——我们向索引列表中添加另一个键路径，然后一切运行得更快。</st> <st c="37431">那么，为什么不将此应用于所有属性呢？</st>
    <st c="37471">有什么</st> <st c="37478">问题吗？</st>
- en: <st c="37488">It’s because</st> <st c="37502">indexing comes with a price.</st>
    <st c="37531">First, we need to duplicate some of our data.</st> <st c="37577">If
    we need to index the name property, we need to create a structure that contains
    all the names.</st> <st c="37675">This results in additional storage for our app.</st>
    <st c="37723">But adding an index doesn’t stop with storage – it also affects
    performance.</st> <st c="37800">Indexing is not a one-time operation, as it requires
    maintenance.</st> <st c="37866">Each</st> `<st c="37871">insert</st>`<st c="37877">,</st>
    `<st c="37879">update</st>`<st c="37885">, or</st> `<st c="37890">delete</st>`
    <st c="37896">operation requires SwiftData to maintain the index structure, impacting
    the</st> <st c="37973">operation performance.</st>
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37488">这是因为</st> <st c="37502">索引是有代价的。</st> <st c="37531">首先，我们需要复制一些我们的数据。</st>
    <st c="37577">如果我们需要索引名称属性，我们需要创建一个包含所有名称的结构。</st> <st c="37675">这导致我们的应用程序需要额外的存储空间。</st>
    <st c="37723">但添加索引并不止于存储——它还会影响性能。</st> <st c="37800">索引不是一次性操作，因为它需要维护。</st>
    <st c="37866">每次</st> `<st c="37871">插入</st>`<st c="37877">、</st> `<st c="37879">更新</st>`<st
    c="37885">或</st> `<st c="37890">删除</st>` <st c="37896">操作都需要 SwiftData 维护索引结构，从而影响</st>
    <st c="37973">操作性能。</st>
- en: <st c="37995">In summary, indexing is a great SwiftData feature.</st> <st c="38047">However,
    use it carefully and balance its benefits with</st> <st c="38103">its costs.</st>
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37995">总的来说，索引是 SwiftData 的一个优秀功能。</st> <st c="38047">然而，请谨慎使用，并权衡其好处与</st>
    <st c="38103">成本。</st>
- en: <st c="38113">We’ve learned so many things so far!</st> <st c="38151">We’ve
    learned how to define models, create instances, fetch them, and connect them to</st>
    <st c="38237">the UI.</st>
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38113">我们到目前为止已经学到了很多东西！</st> <st c="38151">我们学习了如何定义模型、创建实例、获取它们并将它们连接到</st>
    <st c="38237">UI。</st>
- en: <st c="38244">But we know that m</st><st c="38263">aintaining a persistent store
    is much more than that.</st> <st c="38318">Our first app version is so much different
    than our 50th version, and it also means that our data schema will change during
    our app version’s life cycle.</st> <st c="38472">But what should we do once we
    already have a store full of data?</st> <st c="38537">That’s our next topic –
    how to perform</st> <st c="38576">data migration.</st>
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38244">但我们知道，维护持久存储远不止这些。</st> <st c="38263">我们的第一个应用程序版本与我们的第50个版本大不相同，这也意味着我们的数据模式将在应用程序版本的生命周期中发生变化。</st>
    <st c="38472">但我们已经有一个数据满载的存储库，我们应该怎么办呢？</st> <st c="38537">这就是我们下一个主题——如何执行</st>
    <st c="38576">数据迁移。</st>
- en: <st c="38591">Migrating our data to a new schema</st>
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38591">将我们的数据迁移到新架构</st>
- en: <st c="38626">Data migration is not a weird expression for those who have worked
    with Core Data.</st> <st c="38710">It is obvious</st> <st c="38724">that we need
    to change our schema as our</st> <st c="38765">app evolves.</st>
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38626">对于那些使用过Core Data的人来说，数据迁移不是一个奇怪的表达。</st> <st c="38710">很明显，随着我们的应用发展，我们需要更改我们的</st>
    <st c="38724">架构。</st>
- en: <st c="38777">There are two types of migrations –</st> *<st c="38814">lightweight</st>*
    <st c="38825">and</st> *<st c="38830">custom</st>* <st c="38836">migration.</st>
    <st c="38848">With lightweight migration, we perform changes that don’t require
    custom logic.</st> <st c="38928">For example, adding an entity, a property, and
    a relationship are all good examples of lightweight migration.</st> <st c="39038">Conversely,
    changing a property type, making a property unique, and creating a new property
    based on other properties are examples of custom migrations.</st> <st c="39191">Now
    that we know what migration types we have, it’s important to understand when it
    is relevant to perform</st> <st c="39298">a migration.</st>
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38777">有两种类型的迁移——</st> *<st c="38814">轻量级</st>* <st c="38825">和</st>
    *<st c="38830">自定义</st>* <st c="38836">迁移。</st> <st c="38848">在轻量级迁移中，我们执行不需要自定义逻辑的更改。</st>
    <st c="38928">例如，添加实体、属性和关系都是轻量级迁移的好例子。</st> <st c="39038">相反，更改属性类型、使属性唯一以及基于其他属性创建新属性都是自定义迁移的例子。</st>
    <st c="39191">现在我们知道了有哪些迁移类型，了解何时进行迁移是重要的。</st>
- en: <st c="39310">When we’re in our development stage, migration is unnecessary
    before we have an official version of our app on the App Store.</st> <st c="39437">We
    only need to perform migration when an end user holds</st> <st c="39494">a version
    with an older schema.</st> <st c="39526">This also means that if we perform schema
    changes in several versions, we must ensure that SwiftData knows how to migrate
    throughout all</st> <st c="39663">these versions.</st>
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39310">在我们处于开发阶段时，在我们拥有App Store上的官方版本之前，迁移是不必要的。</st> <st c="39437">我们只需要在最终用户持有</st>
    <st c="39494">较旧架构的版本时进行迁移。</st> <st c="39526">这也意味着，如果我们对几个版本进行架构更改，我们必须确保SwiftData知道如何在整个</st>
    <st c="39663">这些版本中进行迁移。</st>
- en: <st c="39678">Now, let’s discuss how SwiftData migration works and what the
    essential migration</st> <st c="39761">components are.</st>
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39678">现在，让我们讨论SwiftData迁移的工作原理以及基本迁移</st> <st c="39761">组件。</st>
- en: <st c="39776">Learning the basic migration process</st>
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39776">学习基本迁移过程</st>
- en: <st c="39813">A SwiftData</st> <st c="39826">migration has three</st> <st c="39846">main
    components:</st>
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39813">SwiftData迁移有三个</st> <st c="39826">主要组件：</st>
- en: '`<st c="39862">VersiondSchema</st>`<st c="39877">: Describes a specific</st>
    <st c="39901">schema version</st>'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="39862">版本架构</st>`<st c="39877">: 描述特定的</st> <st c="39901">架构版本</st>'
- en: '`<st c="39915">MigrationStage</st>`<st c="39930">: Describes the migration
    process between two versions of the</st> <st c="39993">same schema</st>'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="39915">迁移阶段</st>`<st c="39930">: 描述同一架构版本之间的迁移过程</st>'
- en: '`<st c="40004">SchemaMigrationPlan</st>`<st c="40024">: Describes how the schema
    migration stages are based on the</st> <st c="40086">migration stages</st>'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="40004">架构迁移计划</st>`<st c="40024">: 描述架构迁移阶段是基于</st> <st c="40086">迁移阶段</st>'
- en: <st c="40102">Let’s try to describe how everything is connected, using</st>
    *<st c="40160">Figure 2</st>**<st c="40168">.2</st>*<st c="40170">:</st>
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40102">让我们尝试描述如何使用</st> *<st c="40160">图2</st>**<st c="40168">.2</st>*<st
    c="40170">来展示所有事物之间的联系：</st>
- en: '![Figure 2.2: A migration process between three different versions](img/B21795_02_2.jpg)'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图2.2：三个不同版本之间的迁移过程](img/B21795_02_2.jpg)'
- en: '<st c="40295">Figure 2.2: A migration process between three different versions</st>'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40295">图2.2：三个不同版本之间的迁移过程</st>
- en: '*<st c="40359">Figure 2</st>**<st c="40368">.2</st>* <st c="40370">shows three
    different version schemas for three different versions.</st> <st c="40439">We
    create a migration</st> <st c="40461">stage each time we migrate the app from
    one version to another.</st> <st c="40525">Once we have the various stages, we
    can wrap them into one big</st> <st c="40588">migration plan.</st>'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="40359">图2</st>**<st c="40368">.2</st>* <st c="40370">展示了三个不同版本的三个不同版本架构。</st>
    <st c="40439">每次我们将应用程序从一个版本迁移到另一个版本时，我们都会创建一个迁移</st> <st c="40461">阶段。</st> <st
    c="40525">一旦我们有了各种阶段，我们就可以将它们封装成一个大的</st> <st c="40588">迁移计划。</st>'
- en: <st c="40603">Returning to our book’s app, let’s try to migrate our schema to
    support a</st> `<st c="40678">subtitle</st>` <st c="40686">for our</st> `<st c="40695">Book</st>`
    <st c="40699">entity.</st>
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40603">回到我们的书籍应用，让我们尝试将我们的架构迁移以支持</st> `<st c="40678">副标题</st>` <st c="40686">为我们</st>
    `<st c="40695">Book</st>` <st c="40699">实体。</st>
- en: <st c="40707">First, we need to create our</st> <st c="40737">version schemas.</st>
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40707">首先，我们需要创建我们的</st> <st c="40737">版本架构。</st>
- en: <st c="40753">Creating a version schema</st>
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40753">创建版本架构</st>
- en: <st c="40779">To migrate</st> <st c="40791">our book to a new schema, we need
    to create two version schemas – the first is our current schema, and the second
    is the</st> <st c="40912">destination schema:</st>
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40779">为了将</st> <st c="40791">我们的书籍迁移到新的架构，我们需要创建两个版本架构——第一个是我们当前的架构，第二个是</st>
    <st c="40912">目标架构：</st>
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="41502">In this code, we created two enums that conform to the</st> `<st
    c="41558">VersionedSchema</st>` <st c="41573">protocol.</st> <st c="41584">As
    part of</st> <st c="41595">the protocol definition, we need to define the version
    identifier and what models</st> <st c="41677">will change.</st>
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41502">在这段代码中，我们创建了两个符合</st> `<st c="41558">VersionedSchema</st>` <st
    c="41573">协议的枚举。</st> <st c="41584">作为协议定义的一部分，我们需要定义版本标识符以及哪些模型</st> <st c="41677">将发生变化。</st>
- en: <st c="41689">We added a new</st> `<st c="41705">subtitle</st>` <st c="41713">property
    to the second version in this case.</st> <st c="41759">We need to update the schema
    we use across the app, with the new</st> <st c="41824">property included.</st>
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41689">在这种情况下，我们向第二个版本添加了一个新的</st> `<st c="41705">副标题</st>` <st c="41713">属性。</st>
    <st c="41759">我们需要更新整个应用中使用的架构，包括新的</st> <st c="41824">属性。</st>
- en: <st c="41842">Our next step is to define the different stages and the</st> <st
    c="41899">migration plan.</st>
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41842">我们的下一步是定义不同的阶段和</st> <st c="41899">迁移计划。</st>
- en: <st c="41914">Creating the migration stages and plan</st>
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41914">创建迁移阶段和计划</st>
- en: <st c="41953">We should</st> <st c="41964">consider the versioned schemas as
    the building blocks of our migration process.</st> *<st c="42044">Figure 2</st>**<st
    c="42052">.2</st>* <st c="42054">shows that we create the migration stages based
    on the</st> <st c="42110">versioned schemas.</st>
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41953">我们应该</st> <st c="41964">将版本架构视为我们迁移过程的构建块。</st> *<st c="42044">图
    2</st>**<st c="42052">.2</st>* <st c="42054">显示我们根据</st> <st c="42110">版本架构创建迁移阶段。</st>
- en: <st c="42128">Here’s an example of a</st> <st c="42152">migration stage:</st>
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42128">这是一个迁移阶段的示例：</st>
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="42285">The</st> `<st c="42290">migrateV1toV2</st>` <st c="42303">stage
    handles the migration from</st> `<st c="42337">BookSchemaV1</st>` <st c="42349">to</st>
    `<st c="42353">BookSchemaV2</st>`<st c="42365">. Note that this is a lightweight
    migration – we only added a property, so this is all that we need to create</st>
    <st c="42475">the stage.</st>
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42285">`<st c="42290">migrateV1toV2</st>` <st c="42303">阶段处理从</st> `<st
    c="42337">BookSchemaV1</st>` <st c="42349">到</st> `<st c="42353">BookSchemaV2</st>`<st
    c="42365">的迁移。</st> 注意，这是一个轻量级迁移——我们只添加了一个属性，所以这就是我们需要创建</st> <st c="42475">阶段的所有内容。</st>
- en: <st c="42485">What about a custom migration?</st> <st c="42517">With a custom
    migration, we need to provide a closure that handles data before and after the
    migration stage, where we perform all the</st> <st c="42652">required changes.</st>
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42485">关于自定义迁移呢？</st> <st c="42517">使用自定义迁移，我们需要提供一个闭包来处理迁移阶段前后数据，在那里我们执行所有</st>
    <st c="42652">所需的变化。</st>
- en: <st c="42669">Here’s an example of a custom transition from version V2 to V3,
    where we have removed the subtitle property and added it as part of the</st> <st
    c="42806">book name:</st>
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42669">这是一个从版本 V2 到 V3 的自定义过渡示例，其中我们移除了副标题属性并将其作为</st> <st c="42806">书名的一部分：</st>
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="43147">As we can</st> <st c="43158">see in the code example, our</st>
    `<st c="43187">willMigrate</st>` <st c="43198">closure receives a context to work
    with, and SwiftData performs that closure</st> <st c="43276">when needed.</st>
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43147">正如我们可以在代码示例中看到的那样，我们的</st> `<st c="43187">willMigrate</st>` <st
    c="43198">闭包接收一个上下文来工作，SwiftData 在需要时执行该闭包</st> <st c="43276">。</st>
- en: <st c="43288">We fetch all the books and assemble a new name from the book name
    and its subtitle property.</st> <st c="43382">At the end of the closure code,
    we</st> <st c="43417">call</st> `<st c="43422">context.save()</st>`<st c="43436">.</st>
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43288">我们获取所有书籍并从书名及其副标题属性中组装一个新的名称。</st> <st c="43382">在关闭代码的末尾，我们</st>
    <st c="43417">调用</st> `<st c="43422">context.save()</st>`<st c="43436">。</st>
- en: <st c="43437">Now that we have both migration steps, we can create our</st>
    <st c="43495">migration plan:</st>
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43437">现在我们有了迁移步骤，我们可以创建我们的</st> <st c="43495">迁移计划：</st>
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="44174">The migration</st> <st c="44189">plan is just another Enum conforming
    to</st> `<st c="44229">SchemaMigrationPlan</st>`<st c="44248">, with static variables
    describing the list of schemas and stages (not something we haven’t</st> <st c="44340">seen
    before).</st>
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44174">迁移</st> <st c="44189">计划只是符合</st> `<st c="44229">SchemaMigrationPlan</st>`<st
    c="44248">的另一个枚举，其中静态变量描述了模式列表和阶段（不是我们之前没有</st> <st c="44340">见过的东西）。</st>
- en: <st c="44353">Now, we have a migration plan, but SwiftData doesn’t know what
    to do with it.</st> <st c="44432">Our next step will be connecting the migration
    plan to our</st> <st c="44491">SwiftData container.</st>
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44353">现在，我们有了迁移计划，但SwiftData不知道如何处理它。</st> <st c="44432">我们的下一步将是将迁移计划连接到我们的</st>
    <st c="44491">SwiftData容器。</st>
- en: <st c="44511">Connecting the migration plan to our container</st>
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44511">将迁移计划连接到我们的容器</st>
- en: <st c="44558">Connecting</st> <st c="44570">the migration plan to our container
    is perhaps the most straightforward step in</st> <st c="44650">the process.</st>
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44558">将</st> <st c="44570">迁移计划连接到我们的容器可能是这个过程中最直接的一步。</st>
- en: <st c="44662">The</st> `<st c="44667">ModelContainer</st>` <st c="44681">struct
    has a</st> `<st c="44695">migrationPlan</st>` <st c="44708">property specifically
    for that, and we need to pass the migration plan</st> <st c="44780">Enum type:</st>
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44662">`<st c="44667">ModelContainer</st>` <st c="44681">结构体有一个</st>
    `<st c="44695">migrationPlan</st>` <st c="44708">属性专门用于此，我们需要传递迁移计划</st> <st c="44780">枚举类型：</st>
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="44904">Note the way that migrations work in SwiftData in terms of a language
    paradigm.</st> <st c="44985">We don’t have to initialize anything, since we only
    pass the schemas, stages, and plan types.</st> <st c="45079">The reason is the
    way SwiftUI works – since we work in an immutable environment, it is much more
    convenient to work with static variables and types instead</st> <st c="45235">of
    instances.</st>
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44904">注意SwiftData在语言范式方面迁移的工作方式。</st> <st c="44985">我们不需要初始化任何东西，因为我们只传递模式、阶段和计划类型。</st>
    <st c="45079">原因是SwiftUI的工作方式——由于我们在不可变环境中工作，使用静态变量和类型而不是实例要方便得多</st> <st c="45235">。</st>
- en: <st c="45248">Migration in SwiftData is not a simple task.</st> <st c="45294">It
    involves conforming to multiple protocols, maintaining schema versions, and understanding
    how a store is built to switch between lightweight and</st> <st c="45442">custom
    migration.</st>
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45248">在SwiftData中迁移不是一个简单的任务。</st> <st c="45294">它涉及到遵守多个协议、维护模式版本，以及理解如何构建存储以在轻量级和</st>
    <st c="45442">自定义迁移之间切换。</st>
- en: <st c="45459">But this is because migration, in general, is a complex and sensitive
    process.</st> <st c="45539">Trying to carefully plan beforehand how our schema
    looks can reduce the number of schema versions and stages, easing our process
    when considering</st> <st c="45684">that we will have to migrate our store at</st>
    <st c="45727">some point.</st>
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45459">但这是因为迁移，总的来说，是一个复杂且敏感的过程。</st> <st c="45539">在事先仔细规划我们的模式看起来如何时，可以减少模式版本和阶段的数量，简化我们在考虑</st>
    <st c="45684">我们将在某个时候迁移我们的存储时</st> <st c="45727">的过程。</st>
- en: <st c="45738">Summary</st>
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45738">摘要</st>
- en: <st c="45746">SwiftData holds significance for iOS developers looking to support
    iOS 17 and above, representing a natural progression from Apple’s previous framework,
    Core Data.</st> <st c="45911">Within the context of a declarative Swift environment,
    SwiftData aligns more seamlessly</st> <st c="45999">than before.</st>
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45746">SwiftData对希望支持iOS 17及以上版本的iOS开发者具有重要意义，它代表了从苹果之前框架Core Data的自然演进。</st>
    <st c="45911">在声明式Swift环境中，SwiftData比以前更无缝地</st> <st c="45999">对齐。</st>
- en: <st c="46011">In this chapter, we’ve learned about SwiftData’s background, defined
    the different SwiftData models, created relationships, and customized the model
    attributes.</st> <st c="46173">We moved on to the container – a component that
    wraps everything together, performs fetches, and saves.</st> <st c="46277">Lastly,
    we migrated our data from different schema versions using lightweight and custom
    migrations.</st> <st c="46378">Throughout the chapter, we saw the heavy use of
    Swift macros and protocols, which are more suitable for the modern world of Swift
    compared</st> <st c="46517">to Objective-C.</st>
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46011">在本章中，我们了解了SwiftData的背景，定义了不同的SwiftData模型，创建了关系，并自定义了模型属性。</st>
    <st c="46173">然后我们转向容器——一个将所有内容包装在一起、执行获取和保存操作的组件。</st> <st c="46277">最后，我们使用轻量级和自定义迁移将数据从不同的模式版本迁移过来。</st>
    <st c="46378">在整个章节中，我们看到了Swift宏和协议的广泛使用，这些在Swift的现代世界中比Objective-C更合适。</st> <st
    c="46517">。</st>
- en: <st c="46532">That’s a lot for one chapter!</st> <st c="46563">Remember that
    the data layer is c</st><st c="46596">omplex to manage and maintain, and there’s
    much more to learn.</st> <st c="46660">The data layer is one side of our project;
    the other side is, of course, the UI.</st> <st c="46741">To complete our understanding
    of the data layer, it’s essential to explore how the UI can monitor changes.</st>
    <st c="46848">This is why our forthcoming chapter will focus on the</st> <st c="46902">observation
    framework.</st>
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46532">这章内容很多！</st> <st c="46563">请记住，数据层是复杂的，管理和维护它需要学习很多。</st> <st
    c="46596">数据层是项目的一侧；当然，另一侧是UI。</st> <st c="46741">为了完整理解数据层，探索UI如何监控变化是至关重要的。</st>
    <st c="46848">这就是为什么我们即将到来的章节将专注于</st> <st c="46902">观察框架。</st>
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
