- en: Chapter 2. Getting Up and Running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will examine the Unity Interface in detail, explore all of
    its views and tools while personalizing them to suit our particular development
    style, and configure our environment for remote debugging using Unity Remote.
    In this chapter we will finish laying down the foundation for building applications
    and explore all of the Unity options that we need.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the Unity user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize our interface with new custom layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure and deploy Unity Remote for debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test our application using Unity Remote and our new custom layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it...
  prefs: []
  type: TYPE_NORMAL
- en: Welcome home
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've ever used a 3D modeling tool or written an application using any modern
    software development IDE you will find Unity 3 very familiar and fairly straightforward.
    The interface for Unity is composed of a Toolbar area that consists of 5 basic
    control groups and a number of user customizable areas that can contain Views.
  prefs: []
  type: TYPE_NORMAL
- en: Transform tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The transform tools are used with the Scene View and allow you to manipulate
    the objects in the scene. We will take a moment to walk through these tools since
    we will spend much of our time using them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transform tools](img/978-1-84969-040-9_2_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working our way from left to right the first of the tools is a multi-use tool
    that is used to manipulate the camera in the scene. The camera you're moving is
    of your view of the scene and has no relationship to what is actually shown in
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the default mode, the **Hand** tool will simply translate the camera around.
    Pressing the left mouse button and dragging will translate along the X-axis of
    the camera. If you have a mouse wheel, scrolling that wheel will move the camera
    along the Z-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transform tools](img/978-1-84969-040-9_2_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Holding the *Alt* key or the right mouse button will cause the Hand to change
    into an Eye. In this mode you can orbit the camera around its current pivot point
    in the scene. The Scene Gizmo in the upper left of the scene view reflects this.
    As you pivot the camera, the gizmo will update to reflect the current camera pivot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transform tools](img/978-1-84969-040-9_2_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Holding the *Control* key allows you to zoom the camera as you move the mouse
    around in the scene. This is particularly useful if you need to get in close to
    where some critical action should be taking place.
  prefs: []
  type: TYPE_NORMAL
- en: Transform Gizmo Toggles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two gizmos that determine how the updates to an object, using the
    Transform Gizmo, will impact on the object. The Transform Gizmo is just as it
    sounds, it appears in the Scene View and allows us to change the position or rotation
    of an object. These toggles determine where the Gizmo will appear.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transform Gizmo Toggles](img/978-1-84969-040-9_2_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first toggle is the **Position** toggle. If set to **Center**, the Transformation
    Gizmo will appear in the center of the object's bounds that you want to transform.
    In most cases this is what you want if you are laying out an object in a scene.
    However, if you want to change an object's position based upon its pivot point,
    select **Pivot** for the setting of the toggle.
  prefs: []
  type: TYPE_NORMAL
- en: The second toggle is the **Rotation** toggle. Here you will determine whether
    or not rotations will be relative to the object's Local coordinate system or based
    upon the Global or world space coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: VCR Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next set of controls is used to drive the gameplay in the Game View. The
    visual representation of these controls is so commonplace that they almost require
    no explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '![VCR Controls](img/978-1-84969-040-9_2_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Play** control will cause the game to start playing. If you want to stop
    and look at things you press the **Pause** button. When the **Pause** button is
    pressed, Unity will switch to **Scene** view (unless already displayed) so you
    can examine the details of the scene. Pressing **Pause** again will cause the
    game to continue where it left off. If, while paused, you want to determine what
    will happen in the next cycle, you can press the **Step** button. Pressing the
    **Step** button while a game is playing will cause it to enter a paused state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the **Scene View** is on a separate tab you will be able to see both views
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Layers drop-down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you develop your applications you will create layers in the **Scene View**
    which represent groups of game objects that you want to display in the view. This
    helps to unclutter the display in a very complex scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layers drop-down](img/978-1-84969-040-9_2_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the **Layers** drop-down you can select what layers you want to see and which
    ones you want to hide. The hidden objects are still there and will display in
    Game View the next time the game is run.
  prefs: []
  type: TYPE_NORMAL
- en: Layout drop-down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the development of creating a game you will find that some tools are
    useful for some scenarios and not useful in others. Custom layouts allow you to
    define a collection of views, and their position and configuration, while providing
    a unique name for the layout so that you can switch to it later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout drop-down](img/978-1-84969-040-9_2_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Layout** drop-down will display all of the layouts that are available
    for you to switch to, allowing you to rapidly move between multiple IDE arrangements
    so that you have the tools that are important to you when you need them.
  prefs: []
  type: TYPE_NORMAL
- en: Project view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Project view](img/978-1-84969-040-9_2_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Project** view is where you will manage all of the assets that are in
    your project. However, if the files in those folders get updated (that is, you
    change the mesh of an object in some other tool), those updates will be changed
    in Unity as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This view corresponds to the Asset folder of your project, but you should NEVER
    make changes to the project folder directly, you should make your changes in the
    Unity Project view.
  prefs: []
  type: TYPE_NORMAL
- en: You can add new assets to your project by simply dragging them from the desktop,
    or file system browser, right into the project view and Unity will import the
    content for use. Under the covers, Unity will also move the assets into the project's
    Assets folder.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchy view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Hierarchy view](img/978-1-84969-040-9_2_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Hierarchy** view is a close peer to the **Project** view. Where the **Project**
    view is responsible for managing the assets that are available to your sandbox
    — the **Scene** view, the **Hierarchy** view is used to manage the objects that
    are in the scene and the parent child relationships of those objects. For example,
    you may have a vehicle object in the scene that has a light attached to it. In
    the **Hierarchy** view these objects would have a parent child relationship, such
    that the light would be the child of the vehicle object. The result would mean
    that as the parent object changed through transform, rotation, or other the child
    object would be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: In large projects there will be a large number of objects in the **Hierarchy**
    view. To make it easier to find particular objects, or types of objects, Unity
    provides the search box in the **Hierarchy** view. When you enter the name of
    an object, Unity will filter the **Scene** view such that the objects you have
    entered are clearly visible in the view while the other objects are grayed-out.
    For example, suppose you are trying to find the steering wheel component of a
    scene that consists of a large number of game objects. If you enter **steering
    wheel** in the search box it will only provide texture, color, and so on to that
    object so that it is easy to find. Similarly, if you enter a type of object, such
    as **light**, in the search box the scene will only highlight the lights in the
    scene — even if the word 'light' isn't in the name of the Game Object.
  prefs: []
  type: TYPE_NORMAL
- en: Scene view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Scene** view is where you will you will spend most of your time. It is
    in the Scene view that you will build your game, position the camera, change environment
    settings, observe occlusion levels, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scene view](img/978-1-84969-040-9_2_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Game view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Game** view is where the action takes place. Whenever you press **Play**
    in the VCR controls, this view will use the active camera in the scene and render
    what that camera sees to the **Game** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game view](img/978-1-84969-040-9_2_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Control Bar**, in the **Game** view, contains useful controls for adjusting
    the Game view to deliver information useful in rendering the **Game** view closer
    to the actual target display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game view](img/978-1-84969-040-9_2_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first tool in the **Control Bar** is the **Free Aspect** drop-down that
    allows you to change the aspect ratio of the **Game** view to different values.
    This is particularly important for iOS development as you can select the aspect
    ratio of your target device and get a better idea of how your content will look
    with the appropriate perspective applied.
  prefs: []
  type: TYPE_NORMAL
- en: The next tool is the **Maximize on Play** toggle which, when enabled, will display
    the **Game** view in full screen. In the case where this **Game** view is not
    the same resolution as the screen, you will note that the **Game** view maximizes
    to cover the entire display, but only renders the scene at whatever resolution
    / aspect ratio you have set in the **Free Aspect** drop-down.
  prefs: []
  type: TYPE_NORMAL
- en: The next control is the **Gizmos** control. This will force Unity to render
    all of the Gizmos that are present in the **Scene** view in the **Game** view.
  prefs: []
  type: TYPE_NORMAL
- en: The final control is the **Stats** control. When enabled this will show the
    Rendering Statistics window overlaid on the **Game** view. This is an extremely
    useful control to have active, as you will gain insight into how your application
    is performing at a high-level, without having to delve into the **Profiler** view
    while playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Inspector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Inspector** view contains all of the properties for the selected Game
    Object in a view. The properties that the Inspector shows are entirely context
    sensitive based upon the Game Object selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspector](img/978-1-84969-040-9_2_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As Game Objects in Unity are composed of components such as meshes, scripts,
    transforms, and so on. each of the components that make up the Game Object will
    have its editor appear in the **Inspector**. So, for example, in our example **Inspector**
    we've selected a camera in the scene. As you can see the Transform, Camera, and
    so on each have editors that show up for this Game Object.
  prefs: []
  type: TYPE_NORMAL
- en: Console view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Console** view shows all of the messages that come from your game. These
    messages may come from the Unity engine, or may represent messages which you have
    sent to the **Console** view using the script commands, such as `Debug.Log()`.
    If you double-click on the messages that appear in the **Console** view, you will
    be taken directly to the script that caused the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Console view](img/978-1-84969-040-9_2_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Profiler view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Unity Profiler is your best friend when building games with Unity, particularly
    when developing for an iOS device. While the tool is only available with the Pro
    version of Unity, it deserves special attention as it provides substantially more
    information than the Rendering Statistics window in **Game** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiler view](img/978-1-84969-040-9_2_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the top are profile tools that provide information about CPU Usage, Rendering,
    Memory, and Audio statistics. Next to each Profiler is a histogram representing
    the values retrieved from the instrumentation process on each frame. You can click
    and drag the mouse across the histogram and see the results across multiple profile
    tools, which will help to correlate specific performance issues with other events
    that occur in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiler view](img/978-1-84969-040-9_2_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The bottom provides information about function calls that are being made by
    the application. This is done by instrumenting the code and determining how often
    the functions are being called. This can help determine where the hot spots are
    within an application so that you can focus your attention and get your game performing
    well on your target platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiler view](img/978-1-84969-040-9_2_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action — Creating a new layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Unity environment has a lot of features and options, it is possible
    to become entirely overwhelmed by the amount of data, or not realize that something
    has gone awry. We will look at building out a simple customization for our environment
    that contains the views we need, as well as some of the views that don't appear
    in the interface by default, in order to prepare ourselves for testing applications.
    If you're familiar with the Eclipse development environment you may be thinking
    that Unity opens views depending on what action you're performing, but Unity doesn't
    do that. However, we are going to emulate some of that functionality by creating
    a new layout that is well suited to profiling an application.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step for creating a new layout is to start with a base layout and
    customize it. Unity has several default layouts to choose from, but for our purposes
    we will choose the Wide layout. In the **Window** Menu, select **Wide** layout:![Time
    for action — Creating a new layout](img/978-1-84969-040-9_2_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next, step to creating our layout, is to decide which views are most important
    for getting things done. Since we're planning to profile an application it makes
    sense to bring in the **Profile** view into our environment. Selecting the **Window**
    menu and Profiler will show the new view. However, you will notice that it is
    a standalone window and not attached to the rest of the environment. Unity doesn't
    require that all of the views live within the same window as the others. In fact,
    this makes it easier for users with multiple screens as you can have different
    groupings of views on different screens. However, for our purposes we will assume
    that we have one screen to work with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To position the Profiler inside our interface select the **Profiler** tab and
    drag it. This will result in a grayed out version of the tab appearing in the
    interface. As you move this grayed-out version into places where it can be docked,
    it will change shape to illustrate what it will look like if you dock it in that
    position. For now let''s release it right above the **Hierarchy** view and the
    **Project** view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Creating a new layout](img/978-1-84969-040-9_2_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since we're profiling our application we probably don't really need to know
    much about the Project's layout so we can remove the **Project** view from the
    layout. To accomplish this we need to select the **Menu** drop-down which appears
    in the upper right of the view and select the **Close** tab. Once done, the **Project**
    view will no longer be in the layout. Don't worry, if you ever need to bring it
    back you can always go into the **Window** menu and dock it in the same manner
    in which we introduced the **Profiler** view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we probably also want console messages, as they represent feedback from
    our game session. We will introduce the console by selecting **Window | Console**.
    When the console menu appears we will drag it right next to the **Hierarchy**
    tab, such that it appears as a tab in the same row with the **Hierarchy**. This
    represents the other layout option that Unity provides, which is to have rows
    of tabs for views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Creating a new layout](img/978-1-84969-040-9_2_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a new layout specifically for profiling an application and saved
    it, so that whenever we are ready to dive deep into debugging and application
    profiling we can simply switch to it, without having to otherwise clutter our
    environment when we are simply designing our game. This has some very substantial
    implications for productivity as the interface can be set up for a particular
    purpose, such as level editing, scripting, or testing and you can focus the environment
    on specifically what you need. While it may not seem like a large detail right
    now, as your projects get bigger you will be glad this level of flexibility is
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Saving a new layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created our new layout, we need to save it so we can reuse
    it later. In the **Window** menu select **Layouts | Save Layout:**![Time for action
    — Saving a new layout](img/978-1-84969-040-9_2_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be presented with a simple dialog box that will ask for the name of
    the layout. Enter **Profiler** into the text box and press **Save:**![Time for
    action — Saving a new layout](img/978-1-84969-040-9_2_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that your layout has been saved you can switch over to it at any time by
    selecting **Window | Layouts** and selecting your layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Saving a new layout](img/978-1-84969-040-9_2_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just saved our layout so that we can reference it later in our development
    process. In addition, we can share our layout with other developers by giving
    them the layout files that Unity stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layouts are stored with the .wlt extension in the following folder :'
  prefs: []
  type: TYPE_NORMAL
- en: 'on Mac OSx :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On Windows 7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unity 3:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unity 2.x:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On Windows XP
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity 3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unity 2.x
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The best way to see this in action is to deploy a real application and look
    at it from two different layouts to see how it will change the way you interact
    with your environment. This is also a great time to install Unity Remote, as we
    want to use it when we are doing rapid prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Deploying Unity Remote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the hardest things to do when building an application for an iOS device
    is to be able to get some real time feedback from the device, while still having
    the richness of the development environment to work with. Unity solves this problem
    with the Unity Remote application that will allow you to play test your application
    within Unity, while using the iOS device as a controller. Unity Remote accomplishes
    this by streaming the game to the iOS device through WiFi and gathering the input
    actions from the device and injecting them into the Unity environment. With Unity
    Remote you can avoid having to build and deploy your application to your device
    every time you make a change.
  prefs: []
  type: TYPE_NORMAL
- en: There is only one problem with Unity Remote when it comes to testing our application
    — we need to build it specifically for our device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, all iOS applications must be signed before they can be installed on
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to walk through each of the steps necessary to produce commercial
    content for Unity 3 that can be deployed to an iOS device:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to open the Unity Remote project in the XCode environment.
    The Unity Remote source project is not in the distribution for Unity and needs
    to be downloaded from the Unity website. Unity Remote is an official Unity extension
    on the website and can be downloaded at [http://unity3d.com/support/resources/unity-extensions/unity-remote:](http://unity3d.com/support/resources/unity-extensions/unity-remote)![Time
    for action — Deploying Unity Remote](img/978-1-84969-040-9_2_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this project has been downloaded, select the **UnityRemote.xcodeproj**
    to open this project in XCode. As we did in the last chapter, we need to create
    an **App ID** for Unity Remote in the **iOS Provisioning Portal:**![Time for action
    — Deploying Unity Remote](img/978-1-84969-040-9_2_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our **App ID** created, we need to enter that **App ID** into the XCode
    project so that the application will build with that **App ID** and be deployed
    to our iPhone. While Unity takes care of these steps for us, we will need to do
    them ourselves for Unity Remote as this is a regular XCode application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry, once we get Unity Remote installed we won't need to do this again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the project settings using the **Edit Project Settings** in the **Project**
    menu in XCode. This will display all of the settings that XCode will use to build
    and deploy your application:![Time for action — Deploying Unity Remote](img/978-1-84969-040-9_2_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two groups of settings that we are interested in for this project:
    Architectures and Code Signing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Architectures section we want to make sure that we have set the project's
    Base SDK to the appropriate version for our device. For example, if our device
    is running iOS 4.0 we want to make sure that we don't have the Base SDK set to
    build for iOS 4.2\. Simply select the drop-down list on the Base SDK line and
    XCode will tell you what the valid options are for your configuration. If XCode
    doesn't show an SDK here, it is because it is not installed properly and XCode
    will not be able to build with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Code Signing section you will want to select the Any IOS entry under
    the Code Signing Identity item. When you select the drop-down for this item it
    will display all of the possible code signing options for this project. Simply
    select the one that corresponds to the App ID you just created in the iOS Provisioning
    Portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With those settings updated for your App ID, and device, you can now build the
    project in XCode from the Build menu by selecting Build and Run. This will build
    the Unity Remote application with XCode and deploy it to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that you have the target device plugged in when you run this command
    or XCode will complain profusely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you aren't running the standard iOS 4.0 SDK that the Unity Remote project
    expects you will encounter a particular error.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Deploying Unity Remote](img/978-1-84969-040-9_2_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What this error is saying is that the Unity Remote was expecting iphoneos4.0
    to be installed as the SDK. This is represented in the toolbar, as well in the
    build configuration drop-down as **Base SDK Missing**. Depending on when you''ve
    begun your trek into iOS development, iphoneos4.0 may be a distant memory. To
    remedy this you will have to adjust the settings for the project to match the
    SDK that you have installed by editing the Active Target for Unity Remote:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Deploying Unity Remote](img/978-1-84969-040-9_2_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the **Architecture** section you can change the Base SDK to whichever SDK
    you desire. Generally, the best option is to set this to the **Lastest iOS** unless
    you have a particular reason to do otherwise. With this setting changed you will
    see that the **Base SDK Missing** error is gone from the toolbar and when you
    build the project it will successfully install on your device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — Deploying Unity Remote](img/978-1-84969-040-9_2_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just built and deployed Unity Remote to our device. This allows us to
    use our iOS device as an input to our game and test the behavior of the game from
    the iOS device, without having to deploy the application on the device. This is
    useful as it will speed the development process and reduce the number of code-compile-deploy
    cycles we have to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Testing our application using Unity Remote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have Unity Remote deployed we can get to the business of using
    our iOS device as a controller in our game development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Run Unity Remote on your device and a list of the machines ready to provide
    data for Unity Remote will appear in the list. If, for some reason, yours doesn't
    because of specific DNS or Bonjour security, you can enter the IP address of the
    machine you want to control by selecting the button in the lower left. If you
    don't really care to simulate the visual interface of the game on the iOS device
    you can change the radio button for **Show image** to **Off** and the game's frames
    will not be displayed on your device, yet you will still be able to control the
    game inside of Unity with your iOS device acting as a controller:![Time for action
    — Testing our application using Unity Remote](img/978-1-84969-040-9_2_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Play** in the Unity toolbar. This will be the signal for Unity and Unity
    Remote to begin exchanging data. The content that is in the **Game** view will
    begin to appear on the iOS device, though you may think something is wrong the
    first time you see it as it will appear to be a much lower resolution version
    of your game:![Time for action — Testing our application using Unity Remote](img/978-1-84969-040-9_2_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Game View representation of the game in Unity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you recall, I mentioned that Unity streams the game to the iOS device. What
    the IDE is doing is actually streaming the video of what''s happening in the game
    to your device so you will see a variety of compression artifacts, depending on
    your Wi-Fi connection speed and other factors:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Time for action — Testing our application using Unity Remote](img/978-1-84969-040-9_2_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: View of the game on Unity Remote
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is a normal behavior of Unity Remote (and one of the reasons for the Show
    Image radio button) and should not detract in any way from your ability to perform
    your testing. Remember, this is purely a testing tool to enable rapid development
    so visual fidelity is not necessary. If you really need to know exactly how its
    going to look, you can deploy the game to the device — but bookmark this chapter
    as you will find that after some time the benefit of knowing how great your content
    looks on the device will pale into comparison to being more productive using Unity
    Remote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What Unity Remote is doing behind the scenes is getting the frame buffer of
    the application and compressing that into a video stream and streaming that over
    to the iOS device. Any device input that is gathered through the iOS device is
    then transmitted through Wi-Fi to the Unity IDE and used to direct the objects
    in the environment. Whenever you enter **Play** mode in the **Editor**, your device
    will become the remote control for testing the game.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach is very useful for rapid application development, it is
    important to note that performance using this approach is approximated at best
    and you will still want to build and run your application on your device exclusively
    every so often, to confirm that performance and gameplay is as you expect. Similarly,
    it is important to note that this approach is very dependent on your Wi-Fi connection.
    If your device isn't showing a full Wi-Fi signal you can expect significant performance
    implications.
  prefs: []
  type: TYPE_NORMAL
- en: We have just performed all of the steps necessary to setup our development environment
    and publish content to Unity. Further we have built our own mini testing lab using
    Unity Remote so we can utilize our device, yet debug the game in our development
    environment. This is a crucial milestone as we can now focus entirely on customizing
    Unity and building games.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing about Unity Remote that is worth noting, while I had you build
    the remote application yourself you can actually download this in the App Store.
    Given this you may be asking yourself then why did you have me build it? As an
    iOS developer, even one using Unity, there are a number of times that you will
    find yourself needing to debug what is happening under the covers with XCode.
    In addition, you may find yourself wanting to integrate with some native feature
    of iOS that isn't supported in Unity. In all of these scenarios you will find
    yourself digging through the underlying XCode project, so now seemed to be the
    best time to get familiar with how things are put together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Links to the Unity Remote :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity Remote 3 for iPhone :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://itunes.apple.com/fr/app/unity-remote-3/id394632904?mt=8](http://itunes.apple.com/fr/app/unity-remote-3/id394632904?mt=8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity Remote 3 for iPad:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://itunes.apple.com/fr/app/unity-remote-3/id394632904?mt=8](http://itunes.apple.com/fr/app/unity-remote-3/id394632904?mt=8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity Remote < 3 for iPhone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://itunes.apple.com/fr/app/unity-remote/id305967442?mt=8](http://itunes.apple.com/fr/app/unity-remote/id305967442?mt=8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pop quiz - doing the thing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where can Unity views be displayed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Toolbar
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. Undocked on different screens
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. In Tabs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. Remotely on the iOS device
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: e. On other Unity machines
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where can you go to set up an application ID for your iOS device?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Apple Developer Forums
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. XCode Organizer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. iTunes Connect
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. iOS Provisioning Portal
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: e. XCode SDK
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Unity interface can only be customized for one user and use case? (true/false)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity Remote works over 3G Connections? (true/false)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to build Unity Remote in order to perform remote debugging? (true/false)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we explored the Unity environment and learned how to customize
    it for a particular purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Customize the Unity interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize the iOS deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy Unity Remote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test an application using custom layouts and Unity Remote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we have spent some time reviewing the Unity interface, we have done so
    at a relatively high-level. To get more in depth coverage of the Unity interface
    and its options, it is recommended that you read through the Unity documentation.
  prefs: []
  type: TYPE_NORMAL
- en: With the first two chapters under our belts, we can now leave behind the pre-built
    projects and begin building games from scratch, which is the subject of the next
    chapter — Hello World.
  prefs: []
  type: TYPE_NORMAL
