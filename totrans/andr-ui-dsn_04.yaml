- en: Chapter 4. Getting Started with Material Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Announced at the 2014 Google I/O conference and making its first appearance
    in Android Lollipop, Material Design is the new design language from Google.
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly big news for Android, as Material Design's whole purpose
    is to provide a more consistent user experience; and as an open platform Android
    is particularly vulnerable to inconsistencies. Open your Android device's app
    drawer and spend some time flicking through your apps, and chances are you'll
    encounter at least a few apps that will look and feel *very* different from one
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Material Design sets out to change all this by providing the tools and guidelines
    that you need to deliver a more unified user experience.
  prefs: []
  type: TYPE_NORMAL
- en: By adhering to Material Design principles, you can create apps that look good,
    run smoothly, and feel like a seamless extension of the Android platform. And
    who wouldn't want that?
  prefs: []
  type: TYPE_NORMAL
- en: However, Material Design is more than just a bunch of technical specifications
    about how much shading you should apply to a button and how opaque your UI's primary
    text should be. So, before we get into *how* to create a UI that perfectly compliments
    Google's new design direction, let's get a better understanding of what Material
    Design is by looking at the theory behind it.
  prefs: []
  type: TYPE_NORMAL
- en: The Material Design ethos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material Design is based on the idea of translating the physical properties
    of real-world materials into the virtual screen, and it takes much of its inspiration
    from paper, ink, and print techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Material Design encourages designers and developers to create on-screen objects
    that seem to possess the same qualities as real-world objects. This means using
    techniques such as shadows, light, and elevation to create a sense of depth and
    edges.
  prefs: []
  type: TYPE_NORMAL
- en: The way Material Design objects move also mimics how objects move in the physical
    world; for example, two real-world objects cannot occupy the same space simultaneously
    or pass through one another, so your on-screen objects shouldn't either.
  prefs: []
  type: TYPE_NORMAL
- en: To help you create this illusion, Material Design introduces the concept of
    a simulated 3D space where all UI objects possess *X*, *Y*, and *Z* coordinates.
    The *Z* coordinate is particularly important, as the positive *Z* axis extends
    outward toward the user, creating that sense of depth that's so very crucial to
    Material Design.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Material Design, every object occupies a position on the *Z* axis, and iteach
    object has a standard 1dp thickness.
  prefs: []
  type: TYPE_NORMAL
- en: Everything happens within Material Design's simulated 3D environment; objects
    appear, disappear, and transform into new objects without ever breaking the illusion
    of a continuous 3D environment.
  prefs: []
  type: TYPE_NORMAL
- en: When objects move through the Material Design space, they mimic how paper can
    be shuffled and bound together. For example, you can bind two sheets of material
    together along a common edge or *seam*, so they move together. By contrast, when
    two sheets of material overlap but occupy different positions along the *Z* axis,
    they're *not* bound together, and so can move independent of one another.
  prefs: []
  type: TYPE_NORMAL
- en: These design principles may give your user interface a distinct look and feel,
    but Material Design isn't just about how your UI looks. You can use Material Design
    elements such as depth and shadow to give your users visual clues about your interface's
    hierarchy, subtly guiding them toward the UI elements that they need to interact
    with next. If used correctly, Material Design can help to ensure that your users
    instinctively know how to navigate and interact with your app's user interface.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most effective ways of getting to grips with Material Design is to
    look at some examples of Material Design that are done well, so you know what
    you're aiming for.
  prefs: []
  type: TYPE_NORMAL
- en: Since Material Design is Google's design language, what better place to look
    for pointers than Google's own apps?
  prefs: []
  type: TYPE_NORMAL
- en: Case study – Hangouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Hangouts app has undergone a major overhaul to bring it into line with Material
    Design.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most notable UI changes is the **Create New Message** button, which
    now appears as a floating action button, also known as a FAB. As the most important
    action, this FAB is prominently and conveniently located in the bottom-right part
    of the main Hangouts screen, so it's always within easy reach when the user needs
    to create a new message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Case study – Hangouts](img/B05061_4_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Hangouts app uses two Material Design staples—elevation and shadows—to create
    the sense that the FAB is floating above all the other UI elements. This naturally
    draws the user's attention toward the screen's most important task; in this instance,
    the most important task is creating a new message.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – Google Calendar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Material Design encourages the use of bold colors and large images. You'll find
    both of these in the updated Google Calendar app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Case study – Google Calendar](img/B05061_4_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Google Calendar is a great example of a UI where colors and images not only
    make the app fun to look at, but also serve a purpose by helping the user pick
    up important information about their schedule at a glance. For example, a quick
    glance at the previous calendar image is all that's needed to see I have running
    club coming up on Monday night, thanks to the large, colorful picture of the running
    shoes.
  prefs: []
  type: TYPE_NORMAL
- en: Calendar is also a great example of Material Design animations. Spend some time
    moving around the Calendar app, and you'll encounter different animated flourishes,
    such as the on-screen elements moving on and off the screen, assembling into new
    views.
  prefs: []
  type: TYPE_NORMAL
- en: These short animations make navigating through the Google Calendar app a more
    fluid, natural, and generally much more enjoyable experience.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – Google Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google Maps uses Material Design's concept of **bottom sheets** to create an
    immersive experience, where the user selects a location and then explores all
    the information related to this location without leaving the Maps environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Google Maps app and select a location (whether it''s a huge tourist
    attraction, a famous landmark, or simply your local pub), and you''ll notice a
    bottom sheet peeking up from the bottom of your screen. In its default state,
    this bottom sheet displays a few facts about your chosen location, but when you
    drag the sheet upward, it expands to fill the entire screen. This expanded sheet
    contains much more information, including opening times, contact details, photos,
    and user reviews of your chosen location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Case study – Google Maps](img/B05061_4_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bottom sheets use shadows and elevation to create the impression that some components
    are positioned higher than others. In our Google Maps screenshot, the photo component
    is styled, so it appears to be lower than the rest of the bottom sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've read everything the bottom sheet has to offer, you can dismiss it
    by dragging the sheet off the screen. The bottom sheet will fold away, revealing
    the main Google Maps screen, leaving you with the impression that this main screen
    was hiding behind the bottom sheet the entire time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Material Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've explored the major concepts behind Material Design and seen a
    few examples of Material Design done well, it's time to look at how you can apply
    some of the core Material Design principles to your own Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections will show you how to give your app a Material Design makeover
    using visual techniques such as shadows and elevation. You will also learn how
    to make some more fundamental changes to the way your app functions, by adding
    things such as FABs, cards, and `RecyclerView`. Let's start by making sure your
    app *looks* the part.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Material theme to your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applying the Material theme is the quickest and easiest way to get a consistent
    Material Design look across your entire app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android provides light and dark variations for you to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Theme.Material`: This is the dark version of the Material theme. This is considered
    the default Material theme.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Theme.Material.Light`: This is the light variation of the Material theme.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Theme.Material.Light.DarkActionBar`: This is the light version of the theme
    but with a dark action bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To apply the Material theme to your app, you need to create a new style that
    inherits from the version of the theme that you want to use (`Theme.Material`, `Theme.Material.Light`,
    or `Theme.Material.Light.DarkActionBar`). Open your project''s `res/valus/styles.xml` 
    file, and create a new style that inherits from the theme of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To give your app its own identity while maintaining the look and feel of Material
    Design, you may want to add your own customizations to your inherited Material
    Design style. One of the most common customizations is changing the theme's base
    colors; for example, you may want to change the color of the action bar to match
    your app's *primary color*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Material Design uses two kinds of colors: primary and accent. As the name suggests,
    the primary color is the main color that''s used throughout your app—in Google
    Hangouts the primary color is green.'
  prefs: []
  type: TYPE_NORMAL
- en: The accent color is a brighter shade that you use to draw attention to your
    app's most important elements, such as the floating action button or title. By
    using a consistent primary color with the occasional splash of bolder accent color,
    you can create a user interface that's colorful and vibrant but doesn't distract
    the user from your application's content.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it''s time to customize the colors used in your inherited Material Design
    theme, there are several available attributes you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`colorPrimary`: This sets the color of the action bar''s background. This is
    your app''s primary color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorAccent`: This is your app''s accent color. This should compliment your
    app''s primary color, and is a good way of drawing the user''s attention toward
    important UI elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorControlNormal`: This sets the color of your app''s framework controls
    when they''re in their default, non-activated state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorControlActivated`: This sets the color of your framework controls when
    they''re in their activated state. This attribute overrides `colorAccent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:textColorPrimary`: This sets the color of the text on your controls.
    On devices running a pre-Lollipop version of Android, this attribute sets the
    color of the overflow menu and the action bar title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following attributes only work on devices running Android 5.0 or higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '`colorPrimaryDark`: This is a dark variant of your app''s primary color. This
    attribute sets the color of your navigation bar (via `navigationBarColor`) and
    status bar (via `statusBarColor`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorControlHighlight`: This is the color applied to your app''s framework
    control highlights, such as ripple animations. You can use this attribute to provide
    visual feedback that compliments your app''s color scheme. Just don''t get carried
    away—too much visual feedback and you''re running the risk of overwhelming the
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorSwitchThumbNormal`: The user interacts with a toggle switch by dragging
    the switch''s `Thumb` section back and forth. This attribute sets the color of
    the `Thumb` element when it''s in the *off* position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:colorButtonNormal`: This sets the color of a button when it''s in
    its default, non-pressed state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:colorEdgeEffect`: This sets the color of your app''s overscroll effect,
    which occurs when the user tries to scroll beyond your content''s boundaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:navigationBarColor`: This sets the color of the navigation bar, which
    is the bar that appears at the bottom of your device and contains the  ***Back**,* 
    ***Home**,* and  ***Recent*** softkeys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create your own variation of the Material theme, add any of the preceding
    attributes to the style we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, you know how to customize the colors in your Material-inspired theme, but
    what colors should you use? Once again, Material Design has the answers.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your color scheme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choosing your color scheme is one of the most important UI decisions you need
    to make, as the colors you pick will affect every single part of your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: To help you make this crucial design decision, the Android team released a complete
    palette of primary and accent colors that are designed to compliment one another.
    You can find the complete Material Design palette at [https://www.google.com/design/spec/style/color.html#](https://www.google.com/design/spec/style/color.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: When choosing your app's color scheme, you should select three hues from the
    primary palette (that's any color marked 500) and one accent color from the secondary
    palette (that's any color *except* the 500 colors).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Need some help selecting your palette?**'
  prefs: []
  type: TYPE_NORMAL
- en: Struggling to choose from the massive selection of colors and shades on offer?
    You may want to check out one of the many websites that can generate a complete
    Material Design palette for you. Simply select two colors, and the website generates
    a complete palette of primary and accent colors based on your selection. There's
    plenty of palette generators available online, but one of the simplest and easiest
    to use is Material Palette at [http://www.materialpalette.com/](http://www.materialpalette.com/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Backwards compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Material theme is only available in Android 5.0 (API level 21) and upwards,
    so in its default state you cannot use the Material theme or any other custom
    theme derived from it on devices running earlier versions of Android.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can make the Material theme available to users running API 7 and
    higher using the **AppCompat library**.
  prefs: []
  type: TYPE_NORMAL
- en: To add this library to your project, make sure you've downloaded the latest
    version of **Android Support Library** (if you're using Eclipse) or **Android
    Support Repository** (if you're using Android Studio). AppCompat relies on the
    v4 support library so make sure you've also added this library to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Studio users need to add AppCompat as a dependency in their module-level
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Eclipse users will need to locate the AppCompat library in their Android SDK
    directory, copy the library into their project's `libs` directory, right-click
    on the JAR file and select **Build Path**, followed by **Add to Build Path**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use AppCompat, make sure all your project''s activities extend `AppCompatActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Your theme must also inherit from `Theme.AppCompat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After this, you're free to customize the Material theme as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sense of depth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Material Design combines three visual techniques to create a sense of depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lights**: In Material Design''s simulated 3D environment, virtual lights
    illuminate the on-screen objects and allow them to cast shadows. Lighting takes
    the form of either key lights (which cast directional shadows) or ambient lighting
    (which create soft shadows from all angles).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shadows**: These give your users important visual clues about each object''s
    depth. When an object moves, shadows continue to supply important information
    including the direction the object is moving toward, and whether the distance
    between this object and other on-screen objects is increasing or decreasing. The
    shape an object casts is defined by the object''s background and *not* its content,
    so a circular button will cast a circular shadow, regardless of the shape of the
    button''s icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elevation**: Each UI element has its own elevation, which is the object''s
    elevation along the *Z* axis. Elevation can help you communicate the importance
    of each screen''s different UI elements, naturally drawing the user''s eye toward
    the most important on-screen elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create shadows by specifying an object's elevation. When you add an
    elevation, the framework automatically casts a shadow across the items behind
    the object. An object's elevation determines the appearance of its shadow; a view
    with a higher *Z* value will cast a larger, softer shadow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a view''s elevation, use the `android:elevation` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just keep in mind that all material elements have a thickness of 1dp, so elevation
    is the distance from the top of one surface to the top of another.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to set a view's elevation programmatically, use the `View.setElevation`
    and `View.getElevation` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Every object has a default *resting* elevation that should be consistent across
    your app. For example, if you position a floating action button at 10dp on one
    screen, it should be positioned at 10dp on *every* screen.
  prefs: []
  type: TYPE_NORMAL
- en: Objects can also have a responsive elevation, which is where they temporarily
    change their elevation in response to a user action. For example, if the user
    selects a picture in a gallery app, this picture may temporarily increase its
    elevation to indicate its selected status.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive elevations should also be consistent across your app, so if the picture
    in a gallery app changes elevation by 5dp, all other images that have responsive
    elevations must display the exact same 5dp behavior.
  prefs: []
  type: TYPE_NORMAL
- en: If an object changes elevation, it should return to its resting elevation as
    soon as possible—typically as soon as the input event is completed or cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: When adding components with responsive elevations, check that there's no possibility
    of one component encountering another component while it is changing elevation.
    Remember that in Material Design, objects cannot pass through one another! If
    the space is tight, then one solution is to use animations to temporarily move
    objects out of the way; for example, you could animate one object a few pixels
    to the right in order to clear the way for an object that's changing its elevation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Material Design structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you've selected your color palette, created a customized version
    of the Material theme, and know how to add elevation to your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to look at some of the new structural elements you can add
    to your app, so it doesn't *just* look like a Material app, it acts like a Material
    app, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with one of the most familiar Material Design features: floating
    action buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating action buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A FAB is a circular sheet of material that appears to float above the user interface
    (hence the name). If you have a persistent action that needs to be readily available
    to the user, you should consider displaying it as a FAB.
  prefs: []
  type: TYPE_NORMAL
- en: Floating icon buttons represent a single promoted action, and use the familiar
    system icons.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find all the system icons at [https://www.google.com/design/icons/](https://www.google.com/design/icons/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Adding a FAB to your project via XML is fairly straightforward, as it uses many
    attributes you're already familiar with, such as `android:id` and `layout_width`.
    However, in our FAB example, we're going to use a new element called `CoordinatorLayout`.
    This attribute lets you control the way your UI elements interact, and is particularly
    useful for telling FABs how they should react when the user scrolls the screen;
    should they move or remain anchored in the same place?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''re placing our FAB inside `CoordinatorLayout` and telling
    it to remain anchored to the bottom of the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that we haven't specified the FAB's background color; that's
    because the FAB defaults to your theme's `colorAccent` property unless you specify
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a click event in the usual way. So, to make things interesting,
    I''ll throw in another new element from Material Design: the **Snackbar**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Snackbars are similar to Toasts, but the key difference is that users can interact
    with them. The user dismisses a Snackbar by swiping it off the screen. Snackbars
    appear at the bottom of the screen. So, they are perfect for displaying a message
    that relates to our FAB, which also happens to be positioned towards the bottom
    of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating FABs there are a few guidelines you should keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Be positive**: Only use FABs for positive actions such as **Create**, **Like**, **Share**,
    or **Navigate, **and never for destructive actions such as **Archive** or **Trash**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use consistent spacing**: On mobile devices, you should place your FABs 16dp
    or more from the edge. On tablet-sized devices, floating action buttons should
    be a minimum of 24dp away from the edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid customized FABs**: Always use the standard circular icon, and don''t
    be tempted to give your action button extra dimensions. If you do want to put
    your own spin on a FAB, you can always animate the icon inside the button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t include overflow actions**: Overflow menus belong in toolbars, not
    in FABs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Impress with FAB animations**'
  prefs: []
  type: TYPE_NORMAL
- en: As a prominent UI element, FABs are the perfect opportunity to surprise and
    delight your users with animated flourishes. For example, you could design your
    `Create new email` FAB, so it transforms into a new e-mail when tapped. Experiment
    with different animations and transitions, but don't get carried away! Animations
    should be subtle, finishing touches and never get in the user's way or run the
    risk of distracting them from your app's actual content.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom sheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bottom sheet is a sheet of material that slides up from the bottom of the
    screen in response to user action, for example the sheet that appears when you
    select a point of interest in Google Maps.
  prefs: []
  type: TYPE_NORMAL
- en: A bottom sheet's initial height is relative to the height of the list items
    it contains, but a bottom sheet's initial height shouldn't be more than its 16:9
    ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom sheets initially only cover a portion of the screen, but they do expand
    to fill the entire screen when the user swipes upward. When a bottom sheet is
    expanded to its full height, the user can scroll through its content; again, the
    Google Maps app is a perfect example of this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom sheets are best suited to displaying three or more actions that don't
    require a description. If you want to display fewer than three actions, or you
    want to include detailed descriptions, then you should consider using a dialogue
    or menu instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of bottom sheets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Persistent bottom sheets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are persistent structural elements that appear throughout your application.
    They display in-app content that supplements the main view. Persistent bottom
    sheets remain visible even when they're not actively in use, and they rest at
    the same elevation as the rest of your app. Persistent bottom sheets are useful
    for drawing the user's attention toward important content by presenting it in
    a unique way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modal bottom sheets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a temporary sheet of material that rests at a higher elevation than
    the rest of your content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use modal bottom sheets to present actions in a list or grid format
    as an alternative to menus and simple dialogues. It's impossible for the user
    to overlook a modal sheet; when an active modal bottom sheet slides onto the screen,
    the rest of the screen dims. Users have to dismiss the modal sheet before they
    can interact with the underlying content. Modal bottom sheets are handy if you
    need to present the user with a list of actions, and there's no suitable place
    in your user interface where you can insert a menu button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, on larger screens where space is less restricted, components such as
    dialogues and menus may be more appropriate than modal bottom sheets. This is
    because bottom sheets, as the name suggests, always appear at the bottom of the
    screen. For a user interacting with your app on a larger device, such as a tablet
    held in portrait mode, a modal sheet may appear at a significant distance from
    where the user triggered the sheet. This might not sound like a big deal, but
    little annoyances like this can really add up, chipping away at the user's overall
    experience of your app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bottom sheets](img/B05061_4_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows an example of a modal bottom sheet in its default
    state before it's expanded.
  prefs: []
  type: TYPE_NORMAL
- en: CardView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cards give you a convenient and consistent way of displaying related content,
    particularly content that comprises of multiple data types. For example, you could
    create a card that contains images, links, text, or video about a specific subject.
  prefs: []
  type: TYPE_NORMAL
- en: Cards are also handy when you want to display data alongside interactive features,
    such as **+1**, comments, and user reviews. Just be wary of overloading your cards
    with too much information.
  prefs: []
  type: TYPE_NORMAL
- en: Cards have a constant width and a variable height that can expand temporarily
    depending on the available space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each card is made up of blocks of content. A typical card consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A header or primary title*. This should indicate what the card is all about.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rich media* such as images or video. Including rich media helps the user get
    valuable information from your card at a glance; for example, if you''re designing
    a weather app, featuring a picture on every card means your users get an idea
    of what the weather is going to be like just by glancing at that card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![CardView](img/B05061_4_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Supporting text*. Text that provides important information about the card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A primary action*. This is the most important action the user can perform
    within the context of this card. Think of this as the card''s equivalent of a
    FAB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Optional supplemental actions*. These can be icons, text, or even UI controls
    that give the user the ability to change the card''s content. In our weather example,
    you may include a slider that allows the user to scroll through the weather forecast
    for each hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you're designing your card's content hierarchy, you should place the most
    important content at the top, whereas supplemental icons usually belong at the
    very bottom of the card.
  prefs: []
  type: TYPE_NORMAL
- en: 'You add a card to your layout using `CardView`. The following code shows you
    how to add an empty card to your layout via XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You add content to `Cardview` in exactly the same way you add content to a
    regular layout. The following example demonstrates how to create a `LinearLayout`
    that contains a `Contacts` card. This `Contacts CardView` displays each person''s
    name and avatar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `CardViews` on devices that are running Android 2.1 (API level
    7) and higher by adding the `v7 cardview` library to your project. If you''re
    using Eclipse, you''ll need to add this library to your project''s `libs` directory,
    then select **Build Path**, followed by **Add to Build Path**. Android Studio
    users need to add this library as a dependency in their module-level `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a standard `CardView` to your layout is pretty straightforward, but
    if you want to customize Android''s standard `CardView`, you can make the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Change a card's corner radius using `cardView:cardCornerRadius`, for example, `card_view:cardCornerRadius="10dp"`.
    Alternatively, you can set the corner radius via your application code using the `cardView.setRadius`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change a card's background color using `card_view:cardBackgroundColor`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give your card an elevation and create a shadow using `card_view:cardElevation`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists and RecyclerView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists give you a way of presenting related data types in a consistent, easy-to-read
    format.
  prefs: []
  type: TYPE_NORMAL
- en: A list consists of continuous columns and rows that serve as containers for
    tiles. You should prioritize your most important content within each tile; imagine
    you're designing an e-mail app where each e-mail is represented by a tile. Typically,
    each tile would display the sender's name and the subject heading in a larger
    font, as this is the most important information, and then you'd provide a preview
    of the e-mail's text in a smaller font.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical list tile contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**: In a single list, each tile contains a single line of text. In a
    two-line list, each tile contains a maximum of two lines of text. If you need
    to display more than two lines of text, consider using a card instead. The amount
    of text can vary between tiles within the same list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primary actions**: These are consistent throughout every tile in the list.
    In our e-mail example, the primary action might be *open e-mail*, and this primary
    action would appear on every tile within the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional supplemental actions**: These usually take the form of icons or
    secondary text and should be placed on the right side of each tile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You create a list using the `RecylerView`, which is a container for displaying
    large data sets. `RecylerViews` offers improved performance over `ListViews`,
    as it recycles views directly. When item views are no longer visible to the user, `RecylerView`
    automatically replaces their contents with a different element from the data set,
    resulting in smoother scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: '`RecylerView` also offers default animations for common operations, such as
    removing items from the list, and it provides layout managers to help you position
    the items within those lists.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RecyclerView` provides three built-in layout managers for you to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LinearLayoutManager` displays items in a horizontal or vertical scrolling
    list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridLayoutManager` displays items in a grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StaggeredGridLayoutManager` displays items in a staggered grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use `RecylerView` in your project, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `RecyclerView` support library to your project's Gradle build file (`com.android.support:recyclerview-v7:23.1.0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define your data source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `RecylerView` to your layout file, like you''d add a regular view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the layout manager you want to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an adapter. To use `RecylerView`, you need to create an adapter that
    extends the `RecylerView.Adapter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create `ViewHolder`. The `RecyclerView` adapter relies on the `ViewHolder` object
    that stores references to all your views, so you don't need to use multiple `thefindViewById()`
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Assign the adapter to your `RecylerView`, via the `setAdapter` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animations and transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two more key features of Material Design are new animations and transitions.
    When used correctly, these visual effects don't just look nice, they also serve
    two major purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcing the Material Design illusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A crucial aspect of Material Design is the sense that on-screen elements possess
    the same characteristics as physical objects, and animation is a powerful tool
    that can help you really drive this point home.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, the way objects move varies depending on their physical characteristics.
    By varying your animations, you can create the sense that different on-screen
    objects possess different physical characteristics. For example, you can suggest
    that an object is heavier than others by making it move more slowly. And if the
    user sees an object moving quickly and accelerating rapidly, they'll assume that
    the object is lighter.
  prefs: []
  type: TYPE_NORMAL
- en: Another fundamental aspect of Material Design is the illusion that all on-screen
    objects appear, disappear, and transform inside a continuous 3D space. One of
    the most powerful ways of making your app feel like a real, 3D environment is
    to create a visual continuity between your app's activities.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, Android apps were designed as a sequence of screens, where each
    activity was a separate screen. Material Design seeks to blur these boundaries
    by using transitionsto ease the user from one activity to the next.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a new activity starts, the previous activity's elements might
    fade away, while elements from the new activity animate their way on screen. And
    if these two activities share common elements, you could animate these elements
    so that they appear to rearrange themselves into a new layout, which is actually
    an entirely new activity. In this way, you can create a more fluid and immersive
    user experience where users feel as though they're moving around inside your app's
    environment rather than switching from one screen to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Entrances and exits**'
  prefs: []
  type: TYPE_NORMAL
- en: Put some thought into the way your objects enter and exit the screen, as these
    are ideal opportunities to strengthen the illusion of Material Design's continuous
    3D environment. If an object enters the screen at a considerable pace, then the
    user will assume that this object has been traveling for some distance off screen,
    picking up speed along the way. If an object slows down as it exits the screen,
    the user will assume this object will come to a halt just off screen.
  prefs: []
  type: TYPE_NORMAL
- en: You should also look for opportunities to use these assumptions to your advantage.
    For example, if you have an object that you know will be making a reappearance,
    you could animate it so that it exits the screen at a crawl, and then edges its
    way back on screen when the time is right, giving the user the impression that
    this object has been hovering just off screen the entire time.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the user with a visual feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the user interacts with a UI element, your app should provide them
    with some form of visual confirmation that it's successfully registered their
    interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common user interaction is a touch event, so this is the type of event
    I'll be focusing on throughout this section. Just be aware that your app may need
    to handle other forms of user input, such as the user typing on a virtual keyboard
    or speaking commands into their device's microphone.
  prefs: []
  type: TYPE_NORMAL
- en: In Material Design, a touch ripple is the main mechanism that you'll use to
    provide the user with this visual confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: A touch ripple effect is a particularly useful animation, as you can use it
    to communicate additional information about the touch event, such as the duration
    of the event, the amount of pressure applied, and where the touch event occurred
    (the touch ripple moves outward from the point of input).
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to animate material so that it responds to user inputs, such
    as animating a photo so that it appears to lift slightly in response to the user
    long-pressing it.
  prefs: []
  type: TYPE_NORMAL
- en: Animations – a word of warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Animations have the potential to be one of the most powerful or destructive
    tools at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Our eyes are experts at detecting and tracking movement, but if multiple elements
    are moving at once, or moving in random patterns, then the user won't be able
    to keep up! Bad animation is far worse than no animation at all.
  prefs: []
  type: TYPE_NORMAL
- en: You should also avoid using time-consuming animations that serve no purpose
    other than to look pretty. Ideally, you should aim to catch your users off-guard
    with subtle, unexpected uses of animation that enhance their experience in some
    way, rather than simply using animation for the sake of it.
  prefs: []
  type: TYPE_NORMAL
- en: The finishing touches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you've created a user interface with a Material Design look and feel
    and added some structural elements, such as floating action buttons and cards,
    it's time to put the finishing touches to your Material Design application.
  prefs: []
  type: TYPE_NORMAL
- en: Designing your product icon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your product icon should communicate your app's identity while also indicating
    your app's purpose and core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Building your brand**'
  prefs: []
  type: TYPE_NORMAL
- en: If you're creating multiple apps, each product icon should be distinct, but
    you should also use each icon as an opportunity to create and reinforce a wider
    brand that spans all your Android offerings. Aim for some consistency across related
    product icons.
  prefs: []
  type: TYPE_NORMAL
- en: Product icons should reflect the same Material Design principles that we've
    explored throughout this chapter, so once again, you should take the physical
    qualities of paper and ink as your main inspiration. Your product icon should
    appear to be cut, folded, and illuminated exactly like other Material Design objects,
    but the real challenge is communicating all this information while also creating
    a product icon that's clean and simple.
  prefs: []
  type: TYPE_NORMAL
- en: Two particularly effective examples of Material Design icons are the Google
    Calendar and Gmail product icons. Both of these icons use simple shapes to create
    a sense of shadow, depth, and edges, while clearly communicating the app's main
    purpose and function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Gmail icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing your product icon](img/B05061_4_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s the Google Calendar icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing your product icon](img/B05061_4_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To make designing your product icon easier, Material Design introduces the concept
    of **product icon anatomy**. These are standardized shapes that you can incorporate
    into your design to help promote a consistent look and feel across product icons.
    You can view these standardized shapes at  [https://www.google.com/design/spec/style/icons.html#icons-product-icons](https://www.google.com/design/spec/style/icons.html#icons-product-icons)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Each product icon should contain the same structural elements. These elements
    are always viewed straight from above, and each component is positioned at the
    top of the previous component:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finish**: This is a soft tint that you should use to highlight the top edge
    of all your product icon elements. You shouldn''t apply this tint to your icon''s
    left, right, or bottom elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material background**: This is a sheet of material that serves as your icon''s
    background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material foreground**: This is an element that''s raised above the material
    background, and casts a shadow across that background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shadows**: This is a soft shadow that appears around all the edges of a raised
    material element. This shadow should be slightly heavier along the product icon''s
    right and bottom lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Creating the perfect product icon**'
  prefs: []
  type: TYPE_NORMAL
- en: Although layering paper elements is effective for creating a sense of depth,
    be careful not to overcomplicate your app by adding lots of layers. You should
    aim for a product icon that has all the shadows, depth, and edges you'd expect
    from a physical object, but it should *still* deliver a simple and streamlined
    look.
  prefs: []
  type: TYPE_NORMAL
- en: You should supply your icon at 48dp with edges of 1dp.
  prefs: []
  type: TYPE_NORMAL
- en: System icons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous section, we took an in-depth look at product icons, which are
    unique to your application, but what about system icons?
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the Android team has already given all the system icons
    a Material Design makeover. You should use these standard system icons unless
    you have a very, *very* good reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: You can grab the entire pack from [https://www.google.com/design/spec/style/icons.html#icons-system-icons](https://www.google.com/design/spec/style/icons.html#icons-system-icons)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Typography and writing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we'll look at everything you need to know about creating text
    that complies with Material Design principles, from general writing advice through
    to specific guidelines about how opaque your text should be.
  prefs: []
  type: TYPE_NORMAL
- en: Typefaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an Android developer, there are two main typefaces you need to know about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Roboto**: Since Android 4.0, Roboto has been the standard typeface for Android'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noto**: Since the release of Android 2.2, Noto has been the standard typeface
    for all languages that are not covered by Roboto'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Design uses both of these typefaces.
  prefs: []
  type: TYPE_NORMAL
- en: Text opacity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can give the user visual clues about how important each piece of text is
    using varying degrees of opacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opacity levels you should use will vary depending on the color of your
    text and the color of your app''s background. When you''re adding light text to
    a dark background, you should use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary text**: 100% opacity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secondary text**: 70% opacity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hint text, disabled text, and icons**: 30% opacity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you''re adding dark text to a light background, you should use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary text**: 87% opacity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secondary text**: 54% opacity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hint text, disabled text, and icons**: 38% opacity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When adding text to your UI, check that the color of your background doesn't
    make your text difficult to read. Also, be aware that too much contrast can make
    your text equally tricky to read; ideally, your text should maintain a contrast
    ratio of 7:1.
  prefs: []
  type: TYPE_NORMAL
- en: Writing guidelines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know how your text should look on the screen, it's time to turn
    our attention to what your text is actually *saying*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure your user interface is as user-friendly as possible, you should
    create text that''s as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear**: Your users will appreciate simple, direct language that doesn''t
    require repeat reading. Choose your words carefully, and look for the simplest
    way of conveying your message; for example, it''s better to say *move onto question
    2* rather than *navigate to question 2*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessible**: When writing your text, bear in mind that some people may be
    using your app in their second language. Even if you translate your app into other
    languages, culturally-specific phrases and slang may not survive the translation
    process. Your aim should be to write text that''s accessible to *everyone*. On
    a related note, when you create string resources, it''s generally a good idea
    to include detailed descriptions and perhaps even additional comments, so if your
    app does wind up getting translated, you stand a much greater chance of it being
    translated accurately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Necessary**: The whole idea of text is to help the user navigate and get
    value from your app, so whenever you''re tempted to add text to your UI, ask yourself—*does
    the user really need to know this?* For example, if you create a screen that consists
    of a form and a **Submit** button, your users will probably know what''s expected
    of them, without you having to add a **Please complete the form and then press
    the Submit button** disclaimer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concise**: The text you do decide to include should be short, sweet, and
    to the point. In the interests of keeping text to a minimum, use contractions
    wherever possible (so that''s *can''t* instead of *can not*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lacks punctuation**: Punctuation adds visual clutter, so you should omit
    punctuation wherever possible. In particular you should avoid exclamation marks.
    Every time you''re tempted to add an exclamation point, ask yourself—*do I really
    want to shout this at the user?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the present tense**: Most UI events happen in the here and now, so you
    should write in the present tense unless you have a *really* good reason not to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use active verbs**: Make your writing more engaging by opting for active
    verbs over passive ones. The only exception is if the passive version is much
    shorter and simpler than the active version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write in the right tone:** The *right* tone is friendly, respectful, and
    focused firmly on the user. You should address the user directly as *you*, and
    avoid the temptation of lumping yourself and the user together as *we*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the core principles of Material Design, including
    creating a UI that has that distinctive Material Design look and feel, and we
    covered how to incorporate some of the new structural features into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of the past few chapters, we've mainly focused on the technical
    aspects of creating a great user interface. In the next few chapters, we'll shift
    focus and look at how to capture the initial spark of inspiration via sketches,
    wireframes, and prototypes.
  prefs: []
  type: TYPE_NORMAL
