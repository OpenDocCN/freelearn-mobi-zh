["```swift\nclass Player {\n  var name: String!\n\n  init(name: String) {\n   self.name = name\n  }\n}\n```", "```swift\nfor player in players {\n  print(\"analysing \\(player.name)\")\n}\n```", "```swift\nstruct OurCollection<T> {\n  let items: [T]\n} \n```", "```swift\nlet player1 = Player(name: \"Helmi\")\nlet player2 = Player(name: \"Raphael\")\nlet player3 = Player(name: \"Adrien\")\nlet player4 = Player(name: \"Alain\")\n\nlet players = OurCollection(items:[player1,player2, player3, player4])\n```", "```swift\nextension OurCollection: SequenceType {\n  typealias Generator = AnyGenerator<T>\n\n  func generate() -> Generator {\n    var i = 0\n    return anyGenerator {\n      return i >= self.items.count ? nil : self.items[i++]\n    }\n  }\n}\n```", "```swift\n func generate() -> Generator {\n\n```", "```swift\n  typealias Generator = AnyGenerator<T>\n```", "```swift\nfunc generate() -> AnyGenerator<T> {\n\n```", "```swift\n return anyGenerator {\n return i >= self.items.count ? nil : self.items[i++]\n }\n\n```", "```swift\nfunc anyGenerator<Element>(body: () -> Element?) -> AnyGenerator<Element>\n```", "```swift\n  func generate() -> Generator {\n    var i = 0\n   let seq = anyGenerator {i < self.items.count ? self.items[i++] : nil}\n    return seq\n }\n```", "```swift\n  func generate() -> Generator {\n    var i = 0\n   return anyGenerator {i < self.items.count ? self.items[i++] : nil}\n }\n```", "```swift\nimport Foundation\n\nstruct OurCollection<T> {\n  let items: [T]\n}\n\nclass Player {\n  var name: String!\n\n  init(name: String) {\n   self.name = name\n  }\n}\n\nextension OurCollection: SequenceType {\n  typealias Generator = AnyGenerator<T>\n\n  func generate() -> Generator{\n    var i = 0\n    // Construct a AnyGenerator<T> instance, passing a closure\n    // that returns the next type T object in the iteration\n    return anyGenerator {\n      return i >= self.items.count ? nil : self.items[i++]\n    }\n  }\n}\n\nlet player1 = Player(name: \"Helmi\")\nlet player2 = Player(name: \"Raphael\")\nlet player3 = Player(name: \"Adrien\")\nlet player4 = Player(name: \"Alain\")\n\nlet players = OurCollection(items:[player1,player2, player3, player4])\n\nfor player in players {\n  print(\"Name: \\(player.name)\")\n}\n```", "```swift\nprotocol UserProtocol {\n  func sendMessage(mediator:MediatorProtocol, message:AnyObject)\n  func receiveMessage(message:AnyObject)\n}\n```", "```swift\nclass User: UserProtocol {\n  var name: String\n\n  init(name: String){\n   self.name = name\n  }\n\n  func sendMessage(mediator:MediatorProtocol, message:AnyObject){\n    mediator.broadcastMessage(self, message: message as AnyObject)\n  }\n\n  func receiveMessage(message:AnyObject){\n    print(\"\\(self.name) received \\(String(message))\")\n  }\n}\n```", "```swift\nprotocol MediatorProtocol {\n  var users:[UserProtocol]? { get }\n\n  func broadcastMessage(sender:UserProtocol, message:AnyObject)\n  func register(users: UserProtocol)\n}\n```", "```swift\nclass Mediator: MediatorProtocol {\n  private let queue = dispatch_queue_create(\"MediatorPattern\", DISPATCH_QUEUE_CONCURRENT)\n  var users:[UserProtocol]? = [User]()\n\n  func broadcastMessage(sender:UserProtocol, message:AnyObject){\n    dispatch_barrier_sync(self.queue, { () in\n\n      guard let users = self.users else {\n        return\n      }\n\n      for u in users{\n        if u as! User !== sender as! User {\n          u.receiveMessage(message)\n        }\n      }\n\n    })\n  }\n  func register(user: UserProtocol){\n    dispatch_barrier_sync(self.queue, { () in\n      users?.append(user)\n    })\n  }\n}\n```", "```swift\n    guard let users = users else {\n      return\n    }\n```", "```swift\n  private let queue = dispatch_queue_create(\"MediatorPattern\", DISPATCH_QUEUE_CONCURRENT)\n```", "```swift\nvar user1 = User(name: \"Julien\")\nvar user2 = User(name: \"Helmi\")\nvar user3 = User(name: \"Adrien\")\nvar user4 = User(name: \"Raphael\")\n```", "```swift\nvar mediator1 = Mediator()\nmediator1.register(user1)\nmediator1.register(user2)\nmediator1.register(user3)\n```", "```swift\nuser1.sendMessage(mediator1, message: \"message1 from \\(user1.name)\")\n```", "```swift\nvar mediator2 = Mediator()\nmediator2.register(user2)\nmediator2.register(user4)\n\nuser2.sendMessage(mediator2, message: \"message 2 from \\(user2.name)\")\n```", "```swift\nprotocol UserProtocol {\n  func update(object:AnyObject)\n}\n```", "```swift\nclass User: UserProtocol{\n  let name: String!\n\n  init(name: String) {\n    self.name = name\n  }\n\n  func update(object:AnyObject) {\n    let info = object as! Info\n    print(\"\\(self.name) notified that \\(info.message) have status \\(info.status) on \\(info.date.description)\")\n  }\n}\n```", "```swift\nclass Info {\n  var date = NSDate()\n  var message:String!\n  var status:InfoStatus!\n\n  init(msg: String, status:InfoStatus) {\n    self.message = msg\n    self.status = status\n  }\n}\n```", "```swift\nenum InfoStatus {\n  case Join\n  case Leave\n}\n```", "```swift\nprotocol RoomProtocol {\n  func addObserver(user: User)\n  func removeObserver(user: User)\n  func notifyObserver(object: AnyObject)\n}\n```", "```swift\nclass Room: RoomProtocol {\n\n  private var users = [User]()\n\n  func addObserver(user: User) {\n    users.append(user)\n    let info = Info(msg: \"\\(user.name)\", status: .Join)\n    notifyObserver(info)\n  }\n\n  func removeObserver(user: User) {\n    users.removeObject(user)\n    let info = Info(msg: \"\\(user.name)\", status: .Leave)\n    notifyObserver(info)\n  }\n\n  func notifyObserver(object: AnyObject){\n    for u in users {\n      u.update(object)\n    }\n  }\n}\n```", "```swift\nlet room = Room()\nlet user1 = User(name:\"Julien\")\nlet user2 = User(name:\"Alain\")\nlet user3 = User(name:\"Helmi\")\nlet user4 = User(name:\"Raphael\")\n```", "```swift\nroom.addObserver(user1)\nroom.addObserver(user2)\nroom.addObserver(user3)\nroom.addObserver(user4)\n```", "```swift\nroom.removeObserver(user2)\nroom.removeObserver(user3)\nroom.removeObserver(user1)\n```", "```swift\nroom.addObserver(user2)\n```"]