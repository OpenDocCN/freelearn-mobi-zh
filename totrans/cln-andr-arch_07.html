<html><head></head><body>
		<div><h1 id="_idParaDest-66"><em class="italic"><a id="_idTextAnchor070"/>Chapter 5</em>: Building the Domain of an Android Application</h1>
			<p>In this chapter, we will analyze what the architecture of an Android application typically looks like and its three main layers (<strong class="bold">presentation</strong>, <strong class="bold">domain</strong>, and <strong class="bold">data</strong>). Then, we will learn how we can translate it into clean architecture and focus on the domain layer, which sits at the center of the architecture. Next, we will look at the role it plays in the architecture of an application and what its entities and use cases are. Finally, we will look at an exercise, in which we are going to see how we can set up an Android Studio project with multiple modules and use them to structure the domain layer. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introducing the app's architecture</li>
				<li>Creating the domain layer</li>
			</ul>
			<p>By the end of this chapter, you will be familiar with the domain layer of an application, domain entities, and use cases.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor071"/>Technical requirements </h1>
			<p>These are the hardware and software requirements:</p>
			<ul>
				<li>Android Studio – Arctic Fox | 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter5">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter5</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3826FH6">https://bit.ly/3826FH6</a></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor072"/>Introducing the app's architecture</h1>
			<p>In this section, we <a id="_idIndexMarker394"/>will discuss the most common architecture that can be applied to an Android application and how it can be combined <a id="_idIndexMarker395"/>with <strong class="bold">clean architecture</strong> principles, and see how we should ideally structure our code base.</p>
			<p>In the exercises from the previous chapters, we saw how, for an application that requires the integration of multiple data sources for networking and persistence, we had to put a lot of logic inside the <code>ViewModel</code> class. In those examples, <code>ViewModel</code> had multiple responsibilities, including fetching the data from the internet, persisting it locally, and holding the required information in the user interface. On top of these extra responsibilities, <code>ViewModel</code> also had many dependencies on the different data sources; this means that a change in the networking or persistence libraries would require a change in <code>ViewModel</code>. To solve this problem, our code would need to be split into separate layers with different responsibilities. Typically, the layers would look like the following figure:</p>
			<div><div><img src="img/Figure_5.01_B18320.jpg" alt="Figure 5.1 – An app architecture diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – An app architecture diagram</p>
			<p>In <em class="italic">Figure 5.1</em>, we<a id="_idIndexMarker396"/> can see that there are three layers with<a id="_idIndexMarker397"/> different responsibilities:</p>
			<ul>
				<li><code>ViewModels</code>.</li>
				<li><strong class="bold">Domain layer</strong>: This layer is <a id="_idIndexMarker400"/>responsible for fetching data from the data layer and performing business logic that can be reused across an app.</li>
				<li><strong class="bold">Data layer</strong>: This layer<a id="_idIndexMarker401"/> is responsible for handling the business logic of an application that deals with the managing of data.</li>
			</ul>
			<p>We can apply the <em class="italic">clean architecture</em> principles on top of the layered architecture by placing the domain layer at the center, as shown in <em class="italic">Figure 5.2</em>, and making it the place to store our <em class="italic">entities</em> and <em class="italic">use cases</em>. At the outer layers are the presentation and data layers, which are<a id="_idIndexMarker402"/> represented by the <code>ViewModels</code> and <code>Repositories</code>) and the <strong class="bold">framework layer</strong> (represented<a id="_idIndexMarker403"/> by the user interface and persistence and networking frameworks):</p>
			<div><div><img src="img/Figure_5.02_B18320.jpg" alt="Figure 5.2 – An app layer dependency diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – An app layer dependency diagram</p>
			<p>In the <a id="_idIndexMarker404"/>preceding figure, we can see that the dependencies between the domain layer and the data layer are inverted. The domain layer will still draw data from the data layer, but because it has inverted dependencies, it will be less impacted by any changes to that layer, just as if any changes occur to the presentation layer, they will not impact the domain layer. If the app suffers from any changes to the use cases, then it will drive the changes in both the presentation and data layer. </p>
			<p>To separate the layers, we <a id="_idIndexMarker405"/>can use <strong class="bold">Android modules</strong>. This will help us impose further rigor on the project by avoiding unwanted dependencies between the layers. This also helps improve build times in large applications because of Gradle build caching, which will only rebuild modules that had code changes. This will look something like the following figure:</p>
			<div><div><img src="img/Figure_5.03_B18320.jpg" alt="Figure 5.3 – An app module diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – An app module diagram</p>
			<p>We can see that<a id="_idIndexMarker406"/> there isn't a limited number of modules we need for each layer or that we should have corresponding modules between the three layers. The expansion of each layer can be driven by different factors such as the data sources, the uses of the app, the technologies, and protocols used in those data sources (using REST APIs for certain data and Bluetooth or Near-field communication for other data types). The usage of the use cases might be another factor (such as having a certain set of use cases for use with multiple applications). We might want to expand the presentation layer because of how certain screens are grouped to form certain isolated features and flows inside an application (such as a settings section of the application, or a login/sign-up flow). One interesting aspect to note is the <code>:app</code> module, which has the role of combining all of the dependencies and assembling them together. Here, we will gather all the required dependencies and initialize them. </p>
			<p>An important thing to note here is that the modules aren't equivalent to the layers themselves; data modules can have dependencies to lower-level data modules. In fact, this situation will occur in scenarios when a module from a layer will need to have a dependency on another module from the same layer. If we were to create a dependency<a id="_idIndexMarker407"/> between the two, we might end up with a cyclical dependency, which is not wanted. In that situation, we will need to create a common module between the two that will hold the required dependencies. For example, if we want to navigate from a screen in <code>:presentation1</code> to a screen in <code>:presentation2</code> or any of the other ones, we will need to create a new module on which all of the presentation modules will depend and which will store the data or logic required to handle the navigation. We will look at this issue in more detail when we discuss the presentation layer.</p>
			<p>To create a new Android Studio module, you need to right-click the project in Android Studio, select <strong class="bold">New</strong>, and then <strong class="bold">Module</strong>, as shown in the following figure:</p>
			<div><div><img src="img/Figure_5.04_B18320.jpg" alt="Figure 5.4 – Creating a new Android Studio module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Creating a new Android Studio module</p>
			<p>You will then be<a id="_idIndexMarker408"/> prompted to select the type of module, and depending on the functionality, you can select <code>build.gradle</code> file. The plugin section in the file will indicate that an Android library was created:</p>
			<pre>plugins {
    id 'com.android.library'
    …
}</pre>
			<p>If we want to add a dependency to the newly created module, we can use the following in the <code>app</code> module:</p>
			<pre>dependencies {
    implementation(project(path: ":my-new-module"))
    …
}</pre>
			<p>The syntax to add a dependency to a module is similar to the syntax to add an external dependency and it's through the Gradle <code>implementation</code> method. The rest indicates that the <code>app</code> module will <a id="_idIndexMarker409"/>depend on another module inside the same project.</p>
			<p>In this section, we have analyzed the layers of Android app architecture and how we can apply clean architecture principles to these layers. In the following section, we will look at how we can build a domain layer. </p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor073"/>Creating the domain layer</h1>
			<p>In this section, we will <a id="_idIndexMarker410"/>discuss how to build the domain layer and what goes into it through certain examples. Finally, we will look at an exercise in which a domain layer is created.</p>
			<p>Because the domain layer sits at the center of the application, it will need to have a minimal number of dependencies. This means that the Gradle modules that form the domain layer will need to be the most stable modules in the project. This is to avoid causing other modules to change because of a change that occurred in a dependency that the domain modules use. The domain should be responsible for defining the entities and use cases for the application. </p>
			<p>Entities are represented by objects that hold data and are mainly immutable. Let's assume we want to represent a user as an entity. We might end up with something like the following: </p>
			<pre>data class User(
    val id: String,
    val firstName: String,
    val lastName: String,
    val email: String
) {
    fun getFullName() = "$firstName $lastName"
}</pre>
			<p>Here, we use a simple <code>data class</code>, and we declare all our fields immutable with the <code>val</code> keyword. We also have a business logic function for this object, which will return the full name of the user. </p>
			<p>Next, we need to define our use cases. Because the use cases will need to get data from the data layer, we will first need to create an abstraction for our repository, and we will end up with<a id="_idIndexMarker411"/> the following:</p>
			<pre>interface UserRepository {
    fun getUser(id: String): User
}</pre>
			<p>Here, we just have a simple method that will return a user based on <code>id</code>. We can now create a use case for retrieving the user:</p>
			<pre>class GetUserUseCase(private val userRepository: UserRepository) {
    fun getUser(id: String) = userRepository.getUser(id)
}</pre>
			<p>In the preceding example, we define a use case to retrieve the user, which will have a dependency on the <code>UserRepository</code>, which will be used to retrieve the user information. If we look at the preceding example, we can see a bit of redundancy because the use case doesn't have any extra logic and just returns the value of the repository. The benefit of use cases comes when we want to combine multiple results of multiple repositories. </p>
			<p>Let's assume that we want to associate the user with a particular location, defined as follows:</p>
			<pre>data class Location(
    val id: String,
    val userId: String,
    val lat: Double,
    val long: Double
)</pre>
			<p>Here, we just<a id="_idIndexMarker412"/> keep the latitude and longitude associated with a particular user. Now, let's assume that we would have a repository for the different locations:</p>
			<pre>interface LocationRepository {
    fun getLocation(userId: String): Location
}</pre>
			<p>Here, we again have an abstraction of a repository with a method to get a specific location based on <code>userId</code>. If we want to get a user and an associated location, we will need to create a specific use case for this:</p>
			<pre>class GetUserWithLocationUseCase(
    private val userRepository: UserRepository,
    private val locationRepository: LocationRepository
) {
    fun getUser(id: String) =
        UserWithLocation(userRepository.getUser(id), locationRepository.getLocation(id))
}
data class UserWithLocation(
    val user: User,
    val location: Location
)</pre>
			<p>In the preceding example, we create a new entity called <code>UserWithLocation</code>, which will store <code>User</code> and <code>Location</code>. <code>UserWithLocation</code> will then be used as a result for the <code>getUser</code> method in <code>GetUserWithLocationUseCase</code>. This will depend on both <code>UserRepository</code> and <code>LocationRepository</code> to fetch the relevant data. </p>
			<p>We can further improve the use cases by handling the threading as well. Because use cases will<a id="_idIndexMarker413"/> mainly deal with retrieving and managing data, which needs to be asynchronous, we should handle this on a separate thread. We can use <strong class="bold">Kotlin flows</strong> to<a id="_idIndexMarker414"/> manage this, and we might end up with something like this for the repositories:</p>
			<pre>interface UserRepository {
    fun getUser(id: String): Flow&lt;User&gt;
}
interface LocationRepository {
    fun getLocation(id: String): Flow&lt;Location&gt;
}</pre>
			<p>Here, we change the return types of the methods to a Kotlin flow, which might emit a stream of data or a single item. Now, we can combine the different flows in the stream in the use case:</p>
			<pre>class GetUserWithLocationUseCase(
    private val userRepository: UserRepository,
    private val locationRepository: LocationRepository
) {
    fun getUser(id: String) = combine(
        userRepository.getUser(id),
        locationRepository.getLocation(id)
    ) { user, location -&gt;
        UserWithLocation(user, location)
    }.flowOn(Dispatchers.IO)
}</pre>
			<p>Here, we <a id="_idIndexMarker415"/>combine the <code>User</code> and <code>Location</code> flows into a <code>UserWithLocation</code> flow, and we will execute the data fetching on the <code>IO</code> dispatcher. </p>
			<p>Often, when dealing with data loading and management, especially from the internet, we can encounter different errors, which we will have to factor into our use cases. To solve this, we can define error entities. There are many possibilities to define them, including extending the <code>Throwable</code> class, defining a particular data class, a combination of the two, or combining them with sealed classes:</p>
			<pre>sealed class UseCaseException(override val cause: Throwable?) : Throwable(cause) {
    class UserException(cause: Throwable) : 
        UseCaseException(cause)
    
    class LocationException(cause: Throwable) : 
        UseCaseException(cause)
    
    class UnknownException(cause: Throwable) : 
        UseCaseException(cause)
    companion object {
        fun extractException(throwable: Throwable): 
            UseCaseException {
            return if (throwable is UseCaseException) 
                throwable else UnknownException(throwable)
        }
    }
}</pre>
			<p>Here, we have <a id="_idIndexMarker416"/>created a sealed class that will have as subclasses a dedicated error for each entity, plus an unknown error that will deal with errors we haven't accounted for, and a companion method that will check a <code>Throwable</code> object and return <code>UnknownException</code> for any <code>Throwable</code> that isn't <code>UseCaseException</code>. We will need to make sure that the error is propagated through the flow stream, but first, we can combine the entity for success with the entity for error to ensure that the consumer of the use case will not need to check the type of <code>Throwable</code> again and make a cast. We can do this with the following approach:</p>
			<pre>sealed class Result&lt;out T : Any&gt; {
    data class Success&lt;out T : Any&gt;(val data: T) : 
        Result&lt;T&gt;()
    class Error(val exception: UseCaseException) : 
        Result&lt;Nothing&gt;()
}</pre>
			<p>Here, we defined a <code>Result</code> sealed class, which will have two subclasses for success and error. The <code>Success</code> class will hold the relevant data for the use case, and the <code>Error</code> class will contain the exceptions defined before. The <code>Error</code> class can be further expanded if needed to hold data as well as the error if we want to display the cached or persisted data as a placeholder. We can now modify the use case to incorporate the <code>Result</code> class <a id="_idIndexMarker417"/>and the error state:</p>
			<pre>class GetUserWithLocationUseCase(
    private val userRepository: UserRepository,
    private val locationRepository: LocationRepository
) {
    fun getUser(id: String) = combine(
        userRepository.getUser(id),
        locationRepository.getLocation(id)
    ) { user, location -&gt;
        <strong class="bold">Result.Success(UserWithLocation(user, location)) as </strong>
<strong class="bold">            Result&lt;UserWithLocation&gt;</strong>
    }.flowOn(Dispatchers.IO)
        <strong class="bold">.catch {</strong>
            <strong class="bold">emit(Result.Error(UseCaseException.</strong>
<strong class="bold">                extractException(it)))</strong>
        <strong class="bold">}</strong>
}</pre>
			<p>Here, we return <code>Result.Success</code>, which will hold the <code>UserWithLocation</code> object if no errors occur, and add use the <code>catch</code> operator to emit <code>Result.Error</code> with <code>UseCaseException</code> that occurred while fetching the data. Because these operations will repeat for multiple use cases, we can use abstraction to create a template for how each use case behaves and let the implementations deal with only processing the necessary <a id="_idIndexMarker418"/>data. An example might look like the following:</p>
			<pre>abstract class UseCase&lt;T : Any, R : Any&gt;(private val dispatcher: CoroutineDispatcher) {
    fun execute(input: T): Flow&lt;Result&lt;R&gt;&gt; = 
        executeData(input)
        .map {
            Result.Success(it) as Result&lt;R&gt;
        }
        .flowOn(dispatcher)
        .catch {
            emit(Result.Error(UseCaseException.
                extractException(it)))
        }
    internal abstract fun executeData(input: T): Flow&lt;R&gt;
}</pre>
			<p>In the preceding example, we have defined an abstract class that will contain the <code>execute</code> method, which will invoke the abstract <code>executeData</code> method and then map the result of that method into a <code>Result</code> object, followed by setting the flow on a <code>CoroutineDispatcher</code>, and finally, handling the errors in the <code>catch</code> operator. The implementation of this will look like the following. Note that the <code>internal</code> keyword for the <code>executeData</code> method will only make the method accessible in the current module. This is because we only want the <code>execute</code> method to be called by the users of this use case:</p>
			<pre>class GetUserWithLocationUseCase(
    dispatcher: CoroutineDispatcher,
    private val userRepository: UserRepository,
    private val locationRepository: LocationRepository
) : UseCase&lt;String, UserWithLocation&gt;(dispatcher) {
    override fun executeData(input: String): 
        Flow&lt;UserWithLocation&gt; {
        return combine(
            userRepository.getUser(input),
            locationRepository.getLocation(input)
        ) { user, location -&gt;
            UserWithLocation(user, location)
        }
    }
}</pre>
			<p>In this<a id="_idIndexMarker419"/> example, <code>GetUserWithLocationUseCase</code> will only have to deal with returning the necessary data relevant to the use case in the <code>executeData</code> method. We can use generics to bind the types of data we want the use case to process by introducing further abstractions for the required input and output of it:</p>
			<pre>abstract class UseCase&lt;T : UseCase.Request, R : UseCase.Response&gt;(private val dispatcher: CoroutineDispatcher) {
    …
    interface Request
    interface Response
}</pre>
			<p>Here, we have bound the generics in the <code>UseCase</code> class to two interfaces – <code>Request</code> and <code>Response</code>. The former is represented by the input data required by the use case, and the latter is <a id="_idIndexMarker420"/>represented by the output of the use case. The implementation will now look like this:</p>
			<pre>class GetUserWithLocationUseCase(
    dispatcher: CoroutineDispatcher,
    private val userRepository: UserRepository,
    private val locationRepository: LocationRepository
    ) : UseCase&lt;<strong class="bold">GetUserWithLocationUseCase.Request, </strong>
<strong class="bold">    GetUserWithLocationUseCase.Response</strong>&gt;(dispatcher) {
    override fun executeData(input: <strong class="bold">Request</strong>): Flow
        &lt;<strong class="bold">Response</strong>&gt; {
        return combine(
            userRepository.getUser(input.userId),
            locationRepository.getLocation(input.userId)
        ) { user, location -&gt;
            <strong class="bold">Response</strong>(UserWithLocation(user, location))
        }
    }
    <strong class="bold">data class Request(val userId: String) : UseCase.</strong>
<strong class="bold">        Request</strong>
    <strong class="bold">data class Response(val userWithLocation: </strong>
<strong class="bold">        UserWithLocation) : UseCase.Response</strong>
}</pre>
			<p>Here, we provided the implementations for the <code>Request</code> and <code>Response</code> classes and used them when extending from the base class. In this case, the <code>Request</code> and <code>Response</code> classes <a id="_idIndexMarker421"/>represent <strong class="bold">data transport objects</strong>. When we create templates for use cases, it is important to observe their evolution because as the complexity increases, the template may become inadequate. </p>
			<p>Often, we will have the opportunity to build a new use case from existing smaller use cases. Let's <a id="_idIndexMarker422"/>assume that for retrieving a user and retrieving a location, we have two separate use cases:</p>
			<pre> class GetUserUseCase(
    dispatcher: CoroutineDispatcher,
    private val userRepository: UserRepository
    ) : UseCase&lt;GetUserUseCase.Request, 
    GetUserUseCase.Response&gt;(dispatcher) {
    override fun executeData(input: Request): Flow
        &lt;Response&gt; {
        return userRepository.getUser(input.userId)
            .map {
                Response(it)
            }
    }
    data class Request(val userId: String) : UseCase.
        Request
    data class Response(val user: User) : UseCase.Response
}
class GetLocationUseCase(
    dispatcher: CoroutineDispatcher,
    private val locationRepository: LocationRepository
    ) : UseCase&lt;GetLocationUseCase.Request, 
    GetLocationUseCase.Response&gt;(dispatcher) {
    override fun executeData(input: Request): Flow
        &lt;Response&gt; {
        return locationRepository.getLocation(input.userId)
            .map {
                Response(it)
            }
    }
    data class Request(val userId: String) : UseCase
        .Request
    data class Response(val location: Location) : UseCase.
        Response
}</pre>
			<p>In the preceding examples, we have two classes for each use case to retrieve a user and a location. </p>
			<p>We can<a id="_idIndexMarker423"/> modify <code>GetUserWithLocationUseCase</code> to instead use the existing use cases, like this:</p>
			<pre>class GetUserWithLocationUseCase(
    dispatcher: CoroutineDispatcher,
    <strong class="bold">private val getUserUseCase: GetUserUseCase</strong>,
    <strong class="bold">private val getLocationUseCase: GetLocationUseCase</strong>
    ) : UseCase&lt;GetUserWithLocationUseCase.Request, 
        GetUserWithLocationUseCase.Response&gt;(dispatcher) {
    override fun executeData(input: Request): Flow
        &lt;Response&gt; {
        return combine( <strong class="bold">getUserUseCase.executeData</strong>
<strong class="bold">                (GetUserUseCase.Request(input.userId))</strong>,
            <strong class="bold">getLocationUseCase.executeData</strong>
<strong class="bold">                (GetLocationUseCase.Request(input.userId))</strong>
        ) { <strong class="bold">userResponse</strong>, <strong class="bold">locationResponse</strong> -&gt;
            Response(UserWithLocation(<strong class="bold">userResponse.user</strong>, 
                <strong class="bold">locationResponse.location</strong>))
        }
    }
    data class Request(val userId: String) : UseCase
        .Request
    data class Response(val userWithLocation:  
         UserWithLocation) : UseCase.Response
}</pre>
			<p>Here, we changed the dependencies to instead use two existing use cases instead of the repositories, invoked the <code>executeData</code> method from each one, and then built a new <code>Response</code> using the responses from both use cases.</p>
			<p>In this <a id="_idIndexMarker424"/>section, we looked at how to build a domain layer with entities, use cases, and abstractions for repositories. In the section that follows, we will look at an exercise related to building a domain layer.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor074"/>Exercise 05.01 – Building a domain layer</h2>
			<p>In this exercise, we will <a id="_idIndexMarker425"/>create a new project in <code>domain</code> will be created. This module will contain entities containing the following data:</p>
			<ul>
				<li><code>User</code>: This will have an ID of the <code>Long</code> type and a name, username, and email.</li>
				<li><code>Post</code>: This will have an ID and a user ID as a <code>Long</code> type, a title, and body.</li>
				<li><code>Interaction</code>: This will contain the total number of interactions with the app.</li>
				<li><code>Errors</code>: This is for when posts or users cannot be loaded.</li>
			</ul>
			<p>The following use cases will need to be defined for the application:</p>
			<ul>
				<li>Retrieving a list containing posts with user information, grouped with the interaction data</li>
				<li>Retrieving information about a particular user based on the ID</li>
				<li>Retrieving information about a particular post based on the ID</li>
				<li>Updating the interaction data</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ul>
				<li>Create a new project in Android Studio.</li>
				<li>Create a mapping of all the library dependencies and the versions in the root <code>build.gradle</code> file.</li>
				<li>Create the <code>domain</code> module in Android Studio.</li>
				<li>Create the required entities for the data and errors.</li>
				<li>Create the <code>Result</code> class, which will hold the success and error scenario.</li>
				<li>Create the repository abstractions to obtain the user, post, and interaction information.</li>
				<li>Create the four required use cases.</li>
			</ul>
			<p>Follow these<a id="_idIndexMarker427"/> steps to complete the exercise:</p>
			<ol>
				<li>Create a new project in Android Studio and select <strong class="bold">Empty Compose Activity</strong>.</li>
				<li>In the root <code>build.gradle</code> file, add the following configurations that will be used for all the modules in the project:<pre>buildscript {
    ext {
        javaCompileVersion = JavaVersion.VERSION_1_8
        jvmTarget = "1.8"
        defaultCompileSdkVersion = 31
        defaultTargetSdkVersion = 31
        defaultMinSdkVersion = 21
        …
}</pre></li>
				<li>In the same file, add the versions of the libraries that will be used by the Gradle modules:<pre>buildscript {
    ext {
        …
        versions = [
                androidGradlePlugin: "7.0.4",
                kotlin             : "1.5.31",
                hilt               : "2.40.5",
                coreKtx            : "1.7.0",
                appCompat          : "1.4.1",
                compose            : "1.0.5",
                lifecycleRuntimeKtx: "2.4.0",
                activityCompose    : "1.4.0",
                material           : "1.5.0",
                coroutines         : "1.5.2",
                junit              : "4.13.2",
                mockito            : "4.0.0",
                espressoJunit      : "1.1.3",
                espressoCore       : "3.4.0"
        ]
        …
}</pre></li>
				<li>In the same<a id="_idIndexMarker428"/> file, add a mapping for the plugin dependencies that the entire project will use:<pre>buildscript {
    ext {
        …
        gradlePlugins = [
                android: "com.android.tools.build:
                    gradle:${versions.
                        androidGradlePlugin}",
                kotlin : "org.jetbrains.kotlin:kotlin-    
                    gradle-plugin:${versions.kotlin}",
                hilt   : "com.google.dagger:hilt-
                    android-gradle-plugin:
                        ${versions.hilt}"
        ]
        …
}</pre></li>
				<li>Next, you will <a id="_idIndexMarker429"/>need to add the dependencies to the <code>androidx</code> libraries:<pre>buildscript {
    ext {
        …
        androidx = [
                core                   : "androidx.core:core-ktx:${versions.coreKtx}",
                appCompat              : "androidx.appcompat:appcompat:${versions.appCompat}",
                composeUi              : "androidx.compose.ui:ui:${versions.compose}",
                composeMaterial        : "androidx.compose.material:material:${versions.compose}",
                composeUiToolingPreview: "androidx.compose.ui:ui-tooling-preview:${versions.compose}",
                lifecycleRuntimeKtx    : "androidx.lifecycle:lifecycle-runtime-ktx:${versions.lifecycleRuntimeKtx}",
                composeActivity        : "androidx.activity:activity-compose:${versions.activityCompose}"
        ]
        …
}</pre></li>
				<li>Next, add the<a id="_idIndexMarker430"/> remaining libraries for material design, dependency injection, and tests:<pre>buildscript {
    ext {
        …
        material = [
                material: "com.google.android.
                    material:material:$
                        {versions.material}"
        ]
        coroutines = [
                coroutinesAndroid: "org.jetbrains.
                    kotlinx:kotlinx-coroutines-
                       android:${versions.coroutines}"
        ]
        di = [
                hiltAndroid : "com.google.dagger:hilt-
                    android:${versions.hilt}",
                hiltCompiler: "com.google.dagger:hilt-
                    compiler:${versions.hilt}"
        ]
        test = [
                junit     : 
                    "junit:junit:${versions.junit}",
                coroutines: "org.jetbrains.kotlinx:
                    kotlinx-coroutines-test:
                        ${versions.coroutines}",
                mockito   : "org.mockito.kotlin:
                   mockito-kotlin:${versions.mockito}"
        ]
        androidTest = [
                junit             : "androidx.test.ext
                    :junit:${versions.espressoJunit}",
                espressoCore      : "androidx.test.
                    espresso:espresso-core:$
                        {versions.espressoCore}",
                composeUiTestJunit: "androidx.compose.
                ui:ui-test-junit4:${versions.compose}"
        ]
    }
    …
}</pre></li>
				<li>In the same file, you will need to replace the previous mappings as plugin dependencies:<pre>buildscript {
     …
    dependencies {
        classpath gradlePlugins.android
        classpath gradlePlugins.kotlin
        classpath gradlePlugins.hilt
    }
}</pre></li>
				<li>Now, you need to switch to the <code>build.gradle</code> file in the app module and change the <a id="_idIndexMarker431"/>existing configurations with the ones defined in the top-level <code>build.gradle</code>:<pre>android {
    compileSdk defaultCompileSdkVersion
    defaultConfig {
        …
        minSdk defaultMinSdkVersion
        targetSdk defaultTargetSdkVersion
        versionCode 1
        versionName "1.0"
        …
    }
    …
    compileOptions {
        sourceCompatibility javaCompileVersion
        targetCompatibility javaCompileVersion
    }
    kotlinOptions {
        jvmTarget = jvmTarget
        useIR = true
    }
    buildFeatures {
        compose true
    }
    composeOptions {
        kotlinCompilerExtensionVersion 
            versions.compose
    }
    …
}</pre></li>
				<li>In the same <a id="_idIndexMarker432"/>file, you will need to replace the dependencies with the ones defined in the top-level <code>build.gradle</code> file:<pre>dependencies {
    implementation androidx.core
    implementation androidx.appCompat
    implementation material.material
    implementation androidx.composeUi
    implementation androidx.composeMaterial
    implementation androidx.composeUiToolingPreview
    implementation androidx.lifecycleRuntimeKtx
    implementation androidx.composeActivity
    testImplementation test.junit
}</pre></li>
				<li>In Android Studio, execute <strong class="bold">Sync Project with Gradle Files</strong> command and then the <strong class="bold">Make Project</strong> command to make sure that the project builds without any errors.</li>
				<li>Create a<a id="_idIndexMarker433"/> new module for the project named <code>domain</code>, which will be an Android library module.</li>
				<li>In the <code>build.gradle</code> file of the <code>domain</code> module, make sure you have the following plugins:<pre>plugins {
    id 'com.android.library'
    id 'kotlin-android'
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
}</pre></li>
				<li>In the same file, make sure you use the configurations defined in the top-level <code>build.gradle</code> file:<pre>android {
    compileSdk defaultCompileSdkVersion
    defaultConfig {
        minSdk defaultMinSdkVersion
        targetSdk defaultTargetSdkVersion
        …
    }
    …
    compileOptions {
        sourceCompatibility javaCompileVersion
        targetCompatibility javaCompileVersion
    }
    kotlinOptions {
        jvmTarget = jvmTarget
    }
}</pre></li>
				<li>In the same <a id="_idIndexMarker434"/>file, you will need to add the following dependencies:<pre>dependencies {
    implementation coroutines.coroutinesAndroid
    implementation di.hiltAndroid
    kapt di.hiltCompiler
    testImplementation test.junit
    testImplementation test.coroutines
    testImplementation test.mockito
}</pre></li>
				<li>Sync the project with Gradle files and build the project again to make sure that the Gradle configuration is correct.</li>
				<li>In the <code>domain</code> module, create a new package named <code>entity</code>.</li>
				<li>In the <code>entity</code> package, create <a id="_idIndexMarker435"/>a class named <code>Post</code>, which will have <code>id</code>, <code>userId</code>, <code>title</code>, and <code>body</code>:<pre>data class Post(
    val id: Long,
    val userId: Long,
    val title: String,
    val body: String
)</pre></li>
				<li>In the same package, create the <code>User</code> class, which will have <code>id</code>, <code>name</code>, <code>username</code>, and <code>email</code>:<pre>data class User(
    val id: Long,
    val name: String,
    val username: String,
    val email: String
)</pre></li>
				<li>Next, create a class named <code>PostWithUser</code>, which will contain the <code>post</code> and <code>user</code> information:<pre>data class PostWithUser(
    val post: Post,
    val user: User
)</pre></li>
				<li>In the same package, create a class called <code>Interaction</code>, which will contain the total number of clicks:<pre>data class Interaction(val totalClicks: Int)</pre></li>
				<li>Now, we<a id="_idIndexMarker436"/> need to create the error entities:<pre>sealed class UseCaseException(cause: Throwable) : Throwable(cause) {
    class PostException(cause: Throwable) : 
        UseCaseException(cause)
    class UserException(cause: Throwable) : 
        UseCaseException(cause)
    class UnknownException(cause: Throwable) : 
        UseCaseException(cause)
    companion object {
        fun createFromThrowable(throwable: Throwable): 
            UseCaseException {
            return if (throwable is UseCaseException) 
            throwable else UnknownException(throwable)
        }
    }
}</pre></li>
			</ol>
			<p>Here, we have exceptions defined for when there will be an issue with loading the post and user information, and <code>UnknownException</code>, which will be emitted when something else goes wrong.</p>
			<ol>
				<li value="22">Next, let's<a id="_idIndexMarker437"/> create the <code>Result</code> class, which will hold the success and error information:<pre>sealed class Result&lt;out T : Any&gt; {
    data class Success&lt;out T : Any&gt;(val data: T) : 
        Result&lt;T&gt;()
    class Error(val exception: UseCaseException) : 
        Result&lt;Nothing&gt;()
}</pre></li>
				<li>Now, we need to move on to defining the abstractions for the repositories, and to do so, we create a new package named <code>repository</code>.</li>
				<li>In the <code>repository</code> package, create an interface for managing the post data:<pre>interface PostRepository {
    fun getPosts(): Flow&lt;List&lt;Post&gt;&gt;
    fun getPost(id: Long): Flow&lt;Post&gt;
}</pre></li>
				<li>In the same package, create an interface for managing the user data:<pre>interface UserRepository {
    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;
    fun getUser(id: Long): Flow&lt;User&gt;
}</pre></li>
				<li>In the same package, create an interface for managing the interaction data:<pre>interface InteractionRepository {
    fun getInteraction(): Flow&lt;Interaction&gt;
    fun saveInteraction(interaction: Interaction): 
        Flow&lt;Interaction&gt;
}</pre></li>
				<li>Now, we <a id="_idIndexMarker438"/>move on to the use cases and start by creating a new package named <code>usecase</code>.</li>
				<li>In this package, create the <code>UseCase</code> template:<pre>abstract class UseCase&lt;I : UseCase.Request, O : UseCase.Response&gt;(private val configuration: Configuration) {
    fun execute(request: I) = process(request)
        .map {
            Result.Success(it) as Result&lt;O&gt;
        }
        .flowOn(configuration.dispatcher)
        .catch {
            emit(Result.Error(UseCaseException.
                createFromThrowable(it)))
        }
    internal abstract fun process(request: I): Flow&lt;O&gt;
    class Configuration(val dispatcher: 
        CoroutineDispatcher)
    interface Request
    interface Response
}</pre></li>
			</ol>
			<p>In this<a id="_idIndexMarker439"/> template, we have defined the data transfer objects' abstraction, as well as a <code>Configuration</code> class that holds <code>CoroutineDispatcher</code>. The reason for this <code>Configuration</code> class is to be able to add other parameters for the use case without modifying the <code>UseCase</code> subclasses. We have one <code>abstract</code> method, which will be implemented by the subclasses to retrieve the data from the repositories, and the <code>execute</code> method, which will take the data and convert it to <code>Result</code>, handle the error scenarios, and set the proper <code>CoroutineDispatcher</code>.</p>
			<ol>
				<li value="29">In the <code>usecase</code> package, create the use case to retrieve the list of posts with the user information and the interaction data:<pre>class GetPostsWithUsersWithInteractionUseCase @Inject constructor(
    configuration: Configuration,
    private val postRepository: PostRepository,
    private val userRepository: UserRepository,
    private val interactionRepository: 
        InteractionRepository
    ) : GetPostsWithUsersWithInteractionUseCase 
    GetPostsWithUsersWithInteractionUseCase {
    override fun process(request: Request): 
        Flow&lt;Response&gt; =
        combine(
            postRepository.getPosts(),
            userRepository.getUsers(),
            interactionRepository.getInteraction()
        ) { posts, users, interaction -&gt;
            val postUsers = posts.map { post -&gt;
                val user = users.first {
                    it.id == post.userId
                }
                PostWithUser(post, user)
            }
            Response(postUsers, interaction)
        }
    object Request : UseCase.Request
    data class Response(
        val posts: List&lt;PostWithUser&gt;,
        val interaction: Interaction
    ) : UseCase.Response
}</pre></li>
			</ol>
			<p>In this class, we extend the <code>UseCase</code> class, and in the <code>process</code> method, we combine the posts, users, and interaction flows. Because there is no input required, the <code>Request</code> class will have to be empty, and the <code>Response</code> class will contain a list of combined user and post information as well as the interaction data. The <code>@Inject</code> annotation will help us inject this use case later in the presentation layer. </p>
			<ol>
				<li value="30">In the<a id="_idIndexMarker440"/> same package, create the use case to retrieve a post by ID:<pre>class GetPostUseCase @Inject constructor(
    configuration: Configuration,
    private val postRepository: PostRepository
    ) : UseCase&lt;GetPostUseCase.Request, 
    GetPostUseCase.Response&gt;(configuration) {
    override fun process(request: Request): Flow
        &lt;Response&gt; =
        postRepository.getPost(request.postId)
            .map {
                Response(it)
            }
    data class Request(val postId: Long) : UseCase.
        Request
    data class Response(val post: Post) : UseCase.
        Response
}</pre></li>
				<li>In the<a id="_idIndexMarker441"/> same package, create the use case to retrieve a user by ID:<pre>class GetUserUseCase @Inject constructor(
    configuration: Configuration,
    private val userRepository: UserRepository
    ) : UseCase&lt;GetUserUseCase.Request,
    GetUserUseCase.Response&gt;(configuration) {
    override fun process(request: Request): Flow
        &lt;Response&gt; =
        userRepository.getUser(request.userId)
            .map {
                Response(it)
            }
    data class Request(val userId: Long) : UseCase.
        Request
    data class Response(val user: User) : UseCase.
        Response
}</pre></li>
				<li>Now, we move on to the last use case for updating the interaction data:<pre>class UpdateInteractionUseCase @Inject constructor(
    configuration: Configuration,
    private val interactionRepository: 
        InteractionRepository
    ) : UseCase&lt;UpdateInteractionUseCase.Request, 
    UpdateInteractionUseCase.Response&gt;(configuration) {
    override fun process(request: Request): Flow
        &lt;Response&gt; {
        return interactionRepository.saveInteraction
            (request.interaction)
            .map {
                Response
            }
    }
    data class Request(val interaction: Interaction) : 
         UseCase.Request
    object Response : UseCase.Response
}</pre></li>
				<li>To unit-test <a id="_idIndexMarker442"/>the code, we need to create a new folder called <code>resources</code> in the <code>test</code> folder of the <code>domain</code> module. </li>
				<li>Inside the <code>resources</code> folder, create a subfolder called <code>mockito-extensions</code>; inside this folder, create a file named <code>org.mockito.plugins.MockMaker</code>; and inside this file, add the following text – <code>mock-maker-inline</code>. This allows the Mockito testing library to mock the <code>final</code> Java class, which in Kotlin means all classes without the <code>open</code> keyword.</li>
				<li>Create a new<a id="_idIndexMarker443"/> class named <code>UseCaseTest</code> in the test folder of the <code>domain</code> module:<pre>class UseCaseTest {
    @ExperimentalCoroutinesApi
    private val configuration = UseCase.Configuration
        (TestCoroutineDispatcher())
    private val request = mock&lt;UseCase.Request&gt;()
    private val response = mock&lt;UseCase.Response&gt;()
    @ExperimentalCoroutinesApi
    private lateinit var useCase: 
        UseCase&lt;UseCase.Request, UseCase.Response&gt;
    @ExperimentalCoroutinesApi
    @Before
    fun setUp() {
        useCase = object : UseCase&lt;UseCase.Request, 
            UseCase.Response&gt;(configuration) {
            override fun process(request: Request):  
                Flow&lt;Response&gt; {
                assertEquals(this@UseCaseTest.request, 
                    request)
                return flowOf(response)
            }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we provide an implementation for the <code>UseCase</code> class, which will return a mocked response.</p>
			<ol>
				<li value="36">Next, create <a id="_idIndexMarker444"/>a test method that will verify the successful scenario for the <code>execute</code> method:<pre>    @ExperimentalCoroutinesApi
    @Test
    fun testExecuteSuccess() = runBlockingTest {
        val result = useCase.execute(request).first()
        assertEquals(Result.Success(response), result)
    }</pre></li>
			</ol>
			<p>Here, we assert that the result of the <code>execute</code> method is <code>Success</code> and that it contains the mocked response.</p>
			<ol>
				<li value="37">Next, create a new test class named <code>GetPostsWithUsersWithInteractionUseCaseTest</code>:<pre>class GetPostsWithUsersWithInteractionUseCaseTest {
    private val postRepository = mock&lt;PostRepository&gt;()
    private val userRepository = mock&lt;UserRepository&gt;()
    private val interactionRepository = mock&lt;InteractionRepository&gt;()
    private val useCase = GetPostsWithUsersWithInteractionUseCase(
        mock(),
        postRepository,
        userRepository,
        interactionRepository
    )
}</pre></li>
			</ol>
			<p>Here, we mock all the repositories and inject the mocks into the class we want to test.</p>
			<ol>
				<li value="38">Finally, create<a id="_idIndexMarker445"/> a test method that will verify the <code>process</code> method from the use case we are testing:<pre>    @ExperimentalCoroutinesApi
    @Test
    fun testProcess() = runBlockingTest {
        val user1 = User(1L, "name1", "username1", "email1")
        val user2 = User(2L, "name2", "username2", "email2")
        val post1 = Post(1L, user1.id, "title1", "body1")
        val post2 = Post(2L, user1.id, "title2", "body2")
        val post3 = Post(3L, user2.id, "title3", "body3")
        val post4 = Post(4L, user2.id, "title4", "body4")
        val interaction = Interaction(10)
        whenever(userRepository.getUsers()).thenReturn
            (flowOf(listOf(user1, user2)))
        whenever(postRepository.getPosts()).thenReturn
          (flowOf(listOf(post1, post2, post3, post4)))whenever(interactionRepository.getInteraction
            ()).thenReturn(flowOf(interaction))
        val response = useCase.process
            (GetPostsWithUsersWithInteractionUseCase.
                Request).first()
        assertEquals(
            GetPostsWithUsersWithInteractionUseCase.
                Response(
                listOf(
                    PostWithUser(post1, user1),
                    PostWithUser(post2, user1),
                    PostWithUser(post3, user2),
                    PostWithUser(post4, user2),
                ), interaction
            ),
            response
        )
    }</pre></li>
			</ol>
			<p>Here, we provide mock lists of users and posts and a mock interaction, then we return these for each of the repository calls, and then we assert that the result is a list of four posts, written by two users and the mock interaction.</p>
			<p>If we run the tests for these two methods, they should pass. To test the remaining use cases, the same principles can be applied that we used for <code>GetPostsWithUsersWithInteractionUseCaseTest</code> – create mock repositories, inject them into the object we wish to test, and then define the mocks for the input of the <code>process</code> method and the results we should expect, which will give us output as <a id="_idIndexMarker446"/>shown in the following screenshot:</p>
			<div><div><img src="img/Figure_5.05_B18320.jpg" alt="Figure 5.5 – Output of the use case unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Output of the use case unit tests</p>
			<p>In this section, we performed an exercise in which we created a simple domain that contained entities, a few simple use cases, and a particular use case that combined multiple data sources. The domain module has dependencies on flows and Hilt. This means that changes to these libraries might cause changes to our domain module. This decision was made because of the benefits that these libraries provide when it comes to reactive programming and dependency injection. Because we considered dependency injection when defining the use cases, this made them more testable, as we could inject mock objects<a id="_idIndexMarker447"/> into the tested objects very easily.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor075"/>Summary </h1>
			<p>In this chapter, we looked at how the architecture of an Android app is layered and focused on the domain layer, discussing the topics of entities and use cases. We also learned how to use dependency inversion to place use cases and entities at the center of our architecture. We did this by creating repository abstractions that can be implemented in the lower layers. We also learned how to use library modules to enforce separations between layers.</p>
			<p>In the chapter's exercise, we created a domain module for an Android application, providing an example of what a domain layer might look like. In the next chapter, we will focus on the data layer, in which we will provide implementations for the repository abstractions we defined in the domain layer, and discuss how we can use these repositories to manage an application's data.</p>
		</div>
	</body></html>