<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-66"><em class="italic"><a id="_idTextAnchor070"/>Chapter 5</em>: Building the Domain of an Android Application</h1>
			<p>In this chapter, we will analyze what the architecture of an Android application typically looks like and its three main layers (<strong class="bold">presentation</strong>, <strong class="bold">domain</strong>, and <strong class="bold">data</strong>). Then, we will learn how we can translate it into clean architecture and focus on the domain layer, which sits at the center of the architecture. Next, we will look at the role it plays in the architecture of an application and what its entities and use cases are. Finally, we will look at an exercise, in which we are going to see how we can set up an Android Studio project with multiple modules and use them to structure the domain layer. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introducing the app's architecture</li>
				<li>Creating the domain layer</li>
			</ul>
			<p>By the end of this chapter, you will be familiar with the domain layer of an application, domain entities, and use cases.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor071"/>Technical requirements </h1>
			<p>These are the hardware and software requirements:</p>
			<ul>
				<li>Android Studio – Arctic Fox | 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter5">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter5</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3826FH6">https://bit.ly/3826FH6</a></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor072"/>Introducing the app's architecture</h1>
			<p>In this section, we <a id="_idIndexMarker394"/>will discuss the most common architecture that can be applied to an Android application and how it can be combined <a id="_idIndexMarker395"/>with <strong class="bold">clean architecture</strong> principles, and see how we should ideally structure our code base.</p>
			<p>In the exercises from the previous chapters, we saw how, for an application that requires the integration of multiple data sources for networking and persistence, we had to put a lot of logic inside the <strong class="source-inline">ViewModel</strong> class. In those examples, <strong class="source-inline">ViewModel</strong> had multiple responsibilities, including fetching the data from the internet, persisting it locally, and holding the required information in the user interface. On top of these extra responsibilities, <strong class="source-inline">ViewModel</strong> also had many dependencies on the different data sources; this means that a change in the networking or persistence libraries would require a change in <strong class="source-inline">ViewModel</strong>. To solve this problem, our code would need to be split into separate layers with different responsibilities. Typically, the layers would look like the following figure:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_5.01_B18320.jpg" alt="Figure 5.1 – An app architecture diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – An app architecture diagram</p>
			<p>In <em class="italic">Figure 5.1</em>, we<a id="_idIndexMarker396"/> can see that there are three layers with<a id="_idIndexMarker397"/> different responsibilities:</p>
			<ul>
				<li><strong class="bold">Presentation layer</strong>: This<a id="_idIndexMarker398"/> layer is responsible for displaying data on the screen (also known as the <strong class="bold">UI layer</strong>). This <a id="_idIndexMarker399"/>usually contains classes required for managing the user interface and classes that will perform logic related to the user interface, such as <strong class="source-inline">ViewModels</strong>.</li>
				<li><strong class="bold">Domain layer</strong>: This layer is <a id="_idIndexMarker400"/>responsible for fetching data from the data layer and performing business logic that can be reused across an app.</li>
				<li><strong class="bold">Data layer</strong>: This layer<a id="_idIndexMarker401"/> is responsible for handling the business logic of an application that deals with the managing of data.</li>
			</ul>
			<p>We can apply the <em class="italic">clean architecture</em> principles on top of the layered architecture by placing the domain layer at the center, as shown in <em class="italic">Figure 5.2</em>, and making it the place to store our <em class="italic">entities</em> and <em class="italic">use cases</em>. At the outer layers are the presentation and data layers, which are<a id="_idIndexMarker402"/> represented by the <strong class="bold">interface adapter layer</strong> (represented by <strong class="source-inline">ViewModels</strong> and <strong class="source-inline">Repositories</strong>) and the <strong class="bold">framework layer</strong> (represented<a id="_idIndexMarker403"/> by the user interface and persistence and networking frameworks):</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_5.02_B18320.jpg" alt="Figure 5.2 – An app layer dependency diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – An app layer dependency diagram</p>
			<p>In the <a id="_idIndexMarker404"/>preceding figure, we can see that the dependencies between the domain layer and the data layer are inverted. The domain layer will still draw data from the data layer, but because it has inverted dependencies, it will be less impacted by any changes to that layer, just as if any changes occur to the presentation layer, they will not impact the domain layer. If the app suffers from any changes to the use cases, then it will drive the changes in both the presentation and data layer. </p>
			<p>To separate the layers, we <a id="_idIndexMarker405"/>can use <strong class="bold">Android modules</strong>. This will help us impose further rigor on the project by avoiding unwanted dependencies between the layers. This also helps improve build times in large applications because of Gradle build caching, which will only rebuild modules that had code changes. This will look something like the following figure:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_5.03_B18320.jpg" alt="Figure 5.3 – An app module diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – An app module diagram</p>
			<p>We can see that<a id="_idIndexMarker406"/> there isn't a limited number of modules we need for each layer or that we should have corresponding modules between the three layers. The expansion of each layer can be driven by different factors such as the data sources, the uses of the app, the technologies, and protocols used in those data sources (using REST APIs for certain data and Bluetooth or Near-field communication for other data types). The usage of the use cases might be another factor (such as having a certain set of use cases for use with multiple applications). We might want to expand the presentation layer because of how certain screens are grouped to form certain isolated features and flows inside an application (such as a settings section of the application, or a login/sign-up flow). One interesting aspect to note is the <strong class="source-inline">:app</strong> module, which has the role of combining all of the dependencies and assembling them together. Here, we will gather all the required dependencies and initialize them. </p>
			<p>An important thing to note here is that the modules aren't equivalent to the layers themselves; data modules can have dependencies to lower-level data modules. In fact, this situation will occur in scenarios when a module from a layer will need to have a dependency on another module from the same layer. If we were to create a dependency<a id="_idIndexMarker407"/> between the two, we might end up with a cyclical dependency, which is not wanted. In that situation, we will need to create a common module between the two that will hold the required dependencies. For example, if we want to navigate from a screen in <strong class="source-inline">:presentation1</strong> to a screen in <strong class="source-inline">:presentation2</strong> or any of the other ones, we will need to create a new module on which all of the presentation modules will depend and which will store the data or logic required to handle the navigation. We will look at this issue in more detail when we discuss the presentation layer.</p>
			<p>To create a new Android Studio module, you need to right-click the project in Android Studio, select <strong class="bold">New</strong>, and then <strong class="bold">Module</strong>, as shown in the following figure:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_5.04_B18320.jpg" alt="Figure 5.4 – Creating a new Android Studio module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Creating a new Android Studio module</p>
			<p>You will then be<a id="_idIndexMarker408"/> prompted to select the type of module, and depending on the functionality, you can select <strong class="bold">Android Library</strong> if the module doesn't contain code from the Android framework or <strong class="bold">Java or Kotlin Library</strong> if the module doesn't have any dependencies to the Android framework. In the exercises that follow, we will be using Android libraries. Once the module is created, it will already contain a set of generated files and folders. One of the most relevant ones will be the <strong class="source-inline">build.gradle</strong> file. The plugin section in the file will indicate that an Android library was created:</p>
			<p class="source-code">plugins {</p>
			<p class="source-code">    id 'com.android.library'</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>If we want to add a dependency to the newly created module, we can use the following in the <strong class="source-inline">app</strong> module:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">    implementation(project(path: ":my-new-module"))</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>The syntax to add a dependency to a module is similar to the syntax to add an external dependency and it's through the Gradle <strong class="source-inline">implementation</strong> method. The rest indicates that the <strong class="source-inline">app</strong> module will <a id="_idIndexMarker409"/>depend on another module inside the same project.</p>
			<p>In this section, we have analyzed the layers of Android app architecture and how we can apply clean architecture principles to these layers. In the following section, we will look at how we can build a domain layer. </p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor073"/>Creating the domain layer</h1>
			<p>In this section, we will <a id="_idIndexMarker410"/>discuss how to build the domain layer and what goes into it through certain examples. Finally, we will look at an exercise in which a domain layer is created.</p>
			<p>Because the domain layer sits at the center of the application, it will need to have a minimal number of dependencies. This means that the Gradle modules that form the domain layer will need to be the most stable modules in the project. This is to avoid causing other modules to change because of a change that occurred in a dependency that the domain modules use. The domain should be responsible for defining the entities and use cases for the application. </p>
			<p>Entities are represented by objects that hold data and are mainly immutable. Let's assume we want to represent a user as an entity. We might end up with something like the following: </p>
			<p class="source-code">data class User(</p>
			<p class="source-code">    val id: String,</p>
			<p class="source-code">    val firstName: String,</p>
			<p class="source-code">    val lastName: String,</p>
			<p class="source-code">    val email: String</p>
			<p class="source-code">) {</p>
			<p class="source-code">    fun getFullName() = "$firstName $lastName"</p>
			<p class="source-code">}</p>
			<p>Here, we use a simple <strong class="source-inline">data class</strong>, and we declare all our fields immutable with the <strong class="source-inline">val</strong> keyword. We also have a business logic function for this object, which will return the full name of the user. </p>
			<p>Next, we need to define our use cases. Because the use cases will need to get data from the data layer, we will first need to create an abstraction for our repository, and we will end up with<a id="_idIndexMarker411"/> the following:</p>
			<p class="source-code">interface UserRepository {</p>
			<p class="source-code">    fun getUser(id: String): User</p>
			<p class="source-code">}</p>
			<p>Here, we just have a simple method that will return a user based on <strong class="source-inline">id</strong>. We can now create a use case for retrieving the user:</p>
			<p class="source-code">class GetUserUseCase(private val userRepository: UserRepository) {</p>
			<p class="source-code">    fun getUser(id: String) = userRepository.getUser(id)</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we define a use case to retrieve the user, which will have a dependency on the <strong class="source-inline">UserRepository</strong>, which will be used to retrieve the user information. If we look at the preceding example, we can see a bit of redundancy because the use case doesn't have any extra logic and just returns the value of the repository. The benefit of use cases comes when we want to combine multiple results of multiple repositories. </p>
			<p>Let's assume that we want to associate the user with a particular location, defined as follows:</p>
			<p class="source-code">data class Location(</p>
			<p class="source-code">    val id: String,</p>
			<p class="source-code">    val userId: String,</p>
			<p class="source-code">    val lat: Double,</p>
			<p class="source-code">    val long: Double</p>
			<p class="source-code">)</p>
			<p>Here, we just<a id="_idIndexMarker412"/> keep the latitude and longitude associated with a particular user. Now, let's assume that we would have a repository for the different locations:</p>
			<p class="source-code">interface LocationRepository {</p>
			<p class="source-code">    fun getLocation(userId: String): Location</p>
			<p class="source-code">}</p>
			<p>Here, we again have an abstraction of a repository with a method to get a specific location based on <strong class="source-inline">userId</strong>. If we want to get a user and an associated location, we will need to create a specific use case for this:</p>
			<p class="source-code">class GetUserWithLocationUseCase(</p>
			<p class="source-code">    private val userRepository: UserRepository,</p>
			<p class="source-code">    private val locationRepository: LocationRepository</p>
			<p class="source-code">) {</p>
			<p class="source-code">    fun getUser(id: String) =</p>
			<p class="source-code">        UserWithLocation(userRepository.getUser(id), locationRepository.getLocation(id))</p>
			<p class="source-code">}</p>
			<p class="source-code">data class UserWithLocation(</p>
			<p class="source-code">    val user: User,</p>
			<p class="source-code">    val location: Location</p>
			<p class="source-code">)</p>
			<p>In the preceding example, we create a new entity called <strong class="source-inline">UserWithLocation</strong>, which will store <strong class="source-inline">User</strong> and <strong class="source-inline">Location</strong>. <strong class="source-inline">UserWithLocation</strong> will then be used as a result for the <strong class="source-inline">getUser</strong> method in <strong class="source-inline">GetUserWithLocationUseCase</strong>. This will depend on both <strong class="source-inline">UserRepository</strong> and <strong class="source-inline">LocationRepository</strong> to fetch the relevant data. </p>
			<p>We can further improve the use cases by handling the threading as well. Because use cases will<a id="_idIndexMarker413"/> mainly deal with retrieving and managing data, which needs to be asynchronous, we should handle this on a separate thread. We can use <strong class="bold">Kotlin flows</strong> to<a id="_idIndexMarker414"/> manage this, and we might end up with something like this for the repositories:</p>
			<p class="source-code">interface UserRepository {</p>
			<p class="source-code">    fun getUser(id: String): Flow&lt;User&gt;</p>
			<p class="source-code">}</p>
			<p class="source-code">interface LocationRepository {</p>
			<p class="source-code">    fun getLocation(id: String): Flow&lt;Location&gt;</p>
			<p class="source-code">}</p>
			<p>Here, we change the return types of the methods to a Kotlin flow, which might emit a stream of data or a single item. Now, we can combine the different flows in the stream in the use case:</p>
			<p class="source-code">class GetUserWithLocationUseCase(</p>
			<p class="source-code">    private val userRepository: UserRepository,</p>
			<p class="source-code">    private val locationRepository: LocationRepository</p>
			<p class="source-code">) {</p>
			<p class="source-code">    fun getUser(id: String) = combine(</p>
			<p class="source-code">        userRepository.getUser(id),</p>
			<p class="source-code">        locationRepository.getLocation(id)</p>
			<p class="source-code">    ) { user, location -&gt;</p>
			<p class="source-code">        UserWithLocation(user, location)</p>
			<p class="source-code">    }.flowOn(Dispatchers.IO)</p>
			<p class="source-code">}</p>
			<p>Here, we <a id="_idIndexMarker415"/>combine the <strong class="source-inline">User</strong> and <strong class="source-inline">Location</strong> flows into a <strong class="source-inline">UserWithLocation</strong> flow, and we will execute the data fetching on the <strong class="source-inline">IO</strong> dispatcher. </p>
			<p>Often, when dealing with data loading and management, especially from the internet, we can encounter different errors, which we will have to factor into our use cases. To solve this, we can define error entities. There are many possibilities to define them, including extending the <strong class="source-inline">Throwable</strong> class, defining a particular data class, a combination of the two, or combining them with sealed classes:</p>
			<p class="source-code">sealed class UseCaseException(override val cause: Throwable?) : Throwable(cause) {</p>
			<p class="source-code">    class UserException(cause: Throwable) : </p>
			<p class="source-code">        UseCaseException(cause)</p>
			<p class="source-code">    </p>
			<p class="source-code">    class LocationException(cause: Throwable) : </p>
			<p class="source-code">        UseCaseException(cause)</p>
			<p class="source-code">    </p>
			<p class="source-code">    class UnknownException(cause: Throwable) : </p>
			<p class="source-code">        UseCaseException(cause)</p>
			<p class="source-code">    companion object {</p>
			<p class="source-code">        fun extractException(throwable: Throwable): </p>
			<p class="source-code">            UseCaseException {</p>
			<p class="source-code">            return if (throwable is UseCaseException) </p>
			<p class="source-code">                throwable else UnknownException(throwable)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we have <a id="_idIndexMarker416"/>created a sealed class that will have as subclasses a dedicated error for each entity, plus an unknown error that will deal with errors we haven't accounted for, and a companion method that will check a <strong class="source-inline">Throwable</strong> object and return <strong class="source-inline">UnknownException</strong> for any <strong class="source-inline">Throwable</strong> that isn't <strong class="source-inline">UseCaseException</strong>. We will need to make sure that the error is propagated through the flow stream, but first, we can combine the entity for success with the entity for error to ensure that the consumer of the use case will not need to check the type of <strong class="source-inline">Throwable</strong> again and make a cast. We can do this with the following approach:</p>
			<p class="source-code">sealed class Result&lt;out T : Any&gt; {</p>
			<p class="source-code">    data class Success&lt;out T : Any&gt;(val data: T) : </p>
			<p class="source-code">        Result&lt;T&gt;()</p>
			<p class="source-code">    class Error(val exception: UseCaseException) : </p>
			<p class="source-code">        Result&lt;Nothing&gt;()</p>
			<p class="source-code">}</p>
			<p>Here, we defined a <strong class="source-inline">Result</strong> sealed class, which will have two subclasses for success and error. The <strong class="source-inline">Success</strong> class will hold the relevant data for the use case, and the <strong class="source-inline">Error</strong> class will contain the exceptions defined before. The <strong class="source-inline">Error</strong> class can be further expanded if needed to hold data as well as the error if we want to display the cached or persisted data as a placeholder. We can now modify the use case to incorporate the <strong class="source-inline">Result</strong> class <a id="_idIndexMarker417"/>and the error state:</p>
			<p class="source-code">class GetUserWithLocationUseCase(</p>
			<p class="source-code">    private val userRepository: UserRepository,</p>
			<p class="source-code">    private val locationRepository: LocationRepository</p>
			<p class="source-code">) {</p>
			<p class="source-code">    fun getUser(id: String) = combine(</p>
			<p class="source-code">        userRepository.getUser(id),</p>
			<p class="source-code">        locationRepository.getLocation(id)</p>
			<p class="source-code">    ) { user, location -&gt;</p>
			<p class="source-code">        <strong class="bold">Result.Success(UserWithLocation(user, location)) as </strong></p>
			<p class="source-code"><strong class="bold">            Result&lt;UserWithLocation&gt;</strong></p>
			<p class="source-code">    }.flowOn(Dispatchers.IO)</p>
			<p class="source-code">        <strong class="bold">.catch {</strong></p>
			<p class="source-code">            <strong class="bold">emit(Result.Error(UseCaseException.</strong></p>
			<p class="source-code"><strong class="bold">                extractException(it)))</strong></p>
			<p class="source-code">        <strong class="bold">}</strong></p>
			<p class="source-code">}</p>
			<p>Here, we return <strong class="source-inline">Result.Success</strong>, which will hold the <strong class="source-inline">UserWithLocation</strong> object if no errors occur, and add use the <strong class="source-inline">catch</strong> operator to emit <strong class="source-inline">Result.Error</strong> with <strong class="source-inline">UseCaseException</strong> that occurred while fetching the data. Because these operations will repeat for multiple use cases, we can use abstraction to create a template for how each use case behaves and let the implementations deal with only processing the necessary <a id="_idIndexMarker418"/>data. An example might look like the following:</p>
			<p class="source-code">abstract class UseCase&lt;T : Any, R : Any&gt;(private val dispatcher: CoroutineDispatcher) {</p>
			<p class="source-code">    fun execute(input: T): Flow&lt;Result&lt;R&gt;&gt; = </p>
			<p class="source-code">        executeData(input)</p>
			<p class="source-code">        .map {</p>
			<p class="source-code">            Result.Success(it) as Result&lt;R&gt;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        .flowOn(dispatcher)</p>
			<p class="source-code">        .catch {</p>
			<p class="source-code">            emit(Result.Error(UseCaseException.</p>
			<p class="source-code">                extractException(it)))</p>
			<p class="source-code">        }</p>
			<p class="source-code">    internal abstract fun executeData(input: T): Flow&lt;R&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we have defined an abstract class that will contain the <strong class="source-inline">execute</strong> method, which will invoke the abstract <strong class="source-inline">executeData</strong> method and then map the result of that method into a <strong class="source-inline">Result</strong> object, followed by setting the flow on a <strong class="source-inline">CoroutineDispatcher</strong>, and finally, handling the errors in the <strong class="source-inline">catch</strong> operator. The implementation of this will look like the following. Note that the <strong class="source-inline">internal</strong> keyword for the <strong class="source-inline">executeData</strong> method will only make the method accessible in the current module. This is because we only want the <strong class="source-inline">execute</strong> method to be called by the users of this use case:</p>
			<p class="source-code">class GetUserWithLocationUseCase(</p>
			<p class="source-code">    dispatcher: CoroutineDispatcher,</p>
			<p class="source-code">    private val userRepository: UserRepository,</p>
			<p class="source-code">    private val locationRepository: LocationRepository</p>
			<p class="source-code">) : UseCase&lt;String, UserWithLocation&gt;(dispatcher) {</p>
			<p class="source-code">    override fun executeData(input: String): </p>
			<p class="source-code">        Flow&lt;UserWithLocation&gt; {</p>
			<p class="source-code">        return combine(</p>
			<p class="source-code">            userRepository.getUser(input),</p>
			<p class="source-code">            locationRepository.getLocation(input)</p>
			<p class="source-code">        ) { user, location -&gt;</p>
			<p class="source-code">            UserWithLocation(user, location)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this<a id="_idIndexMarker419"/> example, <strong class="source-inline">GetUserWithLocationUseCase</strong> will only have to deal with returning the necessary data relevant to the use case in the <strong class="source-inline">executeData</strong> method. We can use generics to bind the types of data we want the use case to process by introducing further abstractions for the required input and output of it:</p>
			<p class="source-code">abstract class UseCase&lt;T : UseCase.Request, R : UseCase.Response&gt;(private val dispatcher: CoroutineDispatcher) {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    interface Request</p>
			<p class="source-code">    interface Response</p>
			<p class="source-code">}</p>
			<p>Here, we have bound the generics in the <strong class="source-inline">UseCase</strong> class to two interfaces – <strong class="source-inline">Request</strong> and <strong class="source-inline">Response</strong>. The former is represented by the input data required by the use case, and the latter is <a id="_idIndexMarker420"/>represented by the output of the use case. The implementation will now look like this:</p>
			<p class="source-code">class GetUserWithLocationUseCase(</p>
			<p class="source-code">    dispatcher: CoroutineDispatcher,</p>
			<p class="source-code">    private val userRepository: UserRepository,</p>
			<p class="source-code">    private val locationRepository: LocationRepository</p>
			<p class="source-code">    ) : UseCase&lt;<strong class="bold">GetUserWithLocationUseCase.Request, </strong></p>
			<p class="source-code"><strong class="bold">    GetUserWithLocationUseCase.Response</strong>&gt;(dispatcher) {</p>
			<p class="source-code">    override fun executeData(input: <strong class="bold">Request</strong>): Flow</p>
			<p class="source-code">        &lt;<strong class="bold">Response</strong>&gt; {</p>
			<p class="source-code">        return combine(</p>
			<p class="source-code">            userRepository.getUser(input.userId),</p>
			<p class="source-code">            locationRepository.getLocation(input.userId)</p>
			<p class="source-code">        ) { user, location -&gt;</p>
			<p class="source-code">            <strong class="bold">Response</strong>(UserWithLocation(user, location))</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    <strong class="bold">data class Request(val userId: String) : UseCase.</strong></p>
			<p class="source-code"><strong class="bold">        Request</strong></p>
			<p class="source-code">    <strong class="bold">data class Response(val userWithLocation: </strong></p>
			<p class="source-code"><strong class="bold">        UserWithLocation) : UseCase.Response</strong></p>
			<p class="source-code">}</p>
			<p>Here, we provided the implementations for the <strong class="source-inline">Request</strong> and <strong class="source-inline">Response</strong> classes and used them when extending from the base class. In this case, the <strong class="source-inline">Request</strong> and <strong class="source-inline">Response</strong> classes <a id="_idIndexMarker421"/>represent <strong class="bold">data transport objects</strong>. When we create templates for use cases, it is important to observe their evolution because as the complexity increases, the template may become inadequate. </p>
			<p>Often, we will have the opportunity to build a new use case from existing smaller use cases. Let's <a id="_idIndexMarker422"/>assume that for retrieving a user and retrieving a location, we have two separate use cases:</p>
			<p class="source-code"> class GetUserUseCase(</p>
			<p class="source-code">    dispatcher: CoroutineDispatcher,</p>
			<p class="source-code">    private val userRepository: UserRepository</p>
			<p class="source-code">    ) : UseCase&lt;GetUserUseCase.Request, </p>
			<p class="source-code">    GetUserUseCase.Response&gt;(dispatcher) {</p>
			<p class="source-code">    override fun executeData(input: Request): Flow</p>
			<p class="source-code">        &lt;Response&gt; {</p>
			<p class="source-code">        return userRepository.getUser(input.userId)</p>
			<p class="source-code">            .map {</p>
			<p class="source-code">                Response(it)</p>
			<p class="source-code">            }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    data class Request(val userId: String) : UseCase.</p>
			<p class="source-code">        Request</p>
			<p class="source-code">    data class Response(val user: User) : UseCase.Response</p>
			<p class="source-code">}</p>
			<p class="source-code">class GetLocationUseCase(</p>
			<p class="source-code">    dispatcher: CoroutineDispatcher,</p>
			<p class="source-code">    private val locationRepository: LocationRepository</p>
			<p class="source-code">    ) : UseCase&lt;GetLocationUseCase.Request, </p>
			<p class="source-code">    GetLocationUseCase.Response&gt;(dispatcher) {</p>
			<p class="source-code">    override fun executeData(input: Request): Flow</p>
			<p class="source-code">        &lt;Response&gt; {</p>
			<p class="source-code">        return locationRepository.getLocation(input.userId)</p>
			<p class="source-code">            .map {</p>
			<p class="source-code">                Response(it)</p>
			<p class="source-code">            }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    data class Request(val userId: String) : UseCase</p>
			<p class="source-code">        .Request</p>
			<p class="source-code">    data class Response(val location: Location) : UseCase.</p>
			<p class="source-code">        Response</p>
			<p class="source-code">}</p>
			<p>In the preceding examples, we have two classes for each use case to retrieve a user and a location. </p>
			<p>We can<a id="_idIndexMarker423"/> modify <strong class="source-inline">GetUserWithLocationUseCase</strong> to instead use the existing use cases, like this:</p>
			<p class="source-code">class GetUserWithLocationUseCase(</p>
			<p class="source-code">    dispatcher: CoroutineDispatcher,</p>
			<p class="source-code">    <strong class="bold">private val getUserUseCase: GetUserUseCase</strong>,</p>
			<p class="source-code">    <strong class="bold">private val getLocationUseCase: GetLocationUseCase</strong></p>
			<p class="source-code">    ) : UseCase&lt;GetUserWithLocationUseCase.Request, </p>
			<p class="source-code">        GetUserWithLocationUseCase.Response&gt;(dispatcher) {</p>
			<p class="source-code">    override fun executeData(input: Request): Flow</p>
			<p class="source-code">        &lt;Response&gt; {</p>
			<p class="source-code">        return combine( <strong class="bold">getUserUseCase.executeData</strong></p>
			<p class="source-code"><strong class="bold">                (GetUserUseCase.Request(input.userId))</strong>,</p>
			<p class="source-code">            <strong class="bold">getLocationUseCase.executeData</strong></p>
			<p class="source-code"><strong class="bold">                (GetLocationUseCase.Request(input.userId))</strong></p>
			<p class="source-code">        ) { <strong class="bold">userResponse</strong>, <strong class="bold">locationResponse</strong> -&gt;</p>
			<p class="source-code">            Response(UserWithLocation(<strong class="bold">userResponse.user</strong>, </p>
			<p class="source-code">                <strong class="bold">locationResponse.location</strong>))</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    data class Request(val userId: String) : UseCase</p>
			<p class="source-code">        .Request</p>
			<p class="source-code">    data class Response(val userWithLocation:  </p>
			<p class="source-code">         UserWithLocation) : UseCase.Response</p>
			<p class="source-code">}</p>
			<p>Here, we changed the dependencies to instead use two existing use cases instead of the repositories, invoked the <strong class="source-inline">executeData</strong> method from each one, and then built a new <strong class="source-inline">Response</strong> using the responses from both use cases.</p>
			<p>In this <a id="_idIndexMarker424"/>section, we looked at how to build a domain layer with entities, use cases, and abstractions for repositories. In the section that follows, we will look at an exercise related to building a domain layer.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor074"/>Exercise 05.01 – Building a domain layer</h2>
			<p>In this exercise, we will <a id="_idIndexMarker425"/>create a new project in <strong class="bold">Android Studio</strong> in which a<a id="_idIndexMarker426"/> new Gradle module named <strong class="source-inline">domain</strong> will be created. This module will contain entities containing the following data:</p>
			<ul>
				<li><strong class="source-inline">User</strong>: This will have an ID of the <strong class="source-inline">Long</strong> type and a name, username, and email.</li>
				<li><strong class="source-inline">Post</strong>: This will have an ID and a user ID as a <strong class="source-inline">Long</strong> type, a title, and body.</li>
				<li><strong class="source-inline">Interaction</strong>: This will contain the total number of interactions with the app.</li>
				<li><strong class="source-inline">Errors</strong>: This is for when posts or users cannot be loaded.</li>
			</ul>
			<p>The following use cases will need to be defined for the application:</p>
			<ul>
				<li>Retrieving a list containing posts with user information, grouped with the interaction data</li>
				<li>Retrieving information about a particular user based on the ID</li>
				<li>Retrieving information about a particular post based on the ID</li>
				<li>Updating the interaction data</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ul>
				<li>Create a new project in Android Studio.</li>
				<li>Create a mapping of all the library dependencies and the versions in the root <strong class="source-inline">build.gradle</strong> file.</li>
				<li>Create the <strong class="source-inline">domain</strong> module in Android Studio.</li>
				<li>Create the required entities for the data and errors.</li>
				<li>Create the <strong class="source-inline">Result</strong> class, which will hold the success and error scenario.</li>
				<li>Create the repository abstractions to obtain the user, post, and interaction information.</li>
				<li>Create the four required use cases.</li>
			</ul>
			<p>Follow these<a id="_idIndexMarker427"/> steps to complete the exercise:</p>
			<ol>
				<li>Create a new project in Android Studio and select <strong class="bold">Empty Compose Activity</strong>.</li>
				<li>In the root <strong class="source-inline">build.gradle</strong> file, add the following configurations that will be used for all the modules in the project:<p class="source-code">buildscript {</p><p class="source-code">    ext {</p><p class="source-code">        javaCompileVersion = JavaVersion.VERSION_1_8</p><p class="source-code">        jvmTarget = "1.8"</p><p class="source-code">        defaultCompileSdkVersion = 31</p><p class="source-code">        defaultTargetSdkVersion = 31</p><p class="source-code">        defaultMinSdkVersion = 21</p><p class="source-code">        …</p><p class="source-code">}</p></li>
				<li>In the same file, add the versions of the libraries that will be used by the Gradle modules:<p class="source-code">buildscript {</p><p class="source-code">    ext {</p><p class="source-code">        …</p><p class="source-code">        versions = [</p><p class="source-code">                androidGradlePlugin: "7.0.4",</p><p class="source-code">                kotlin             : "1.5.31",</p><p class="source-code">                hilt               : "2.40.5",</p><p class="source-code">                coreKtx            : "1.7.0",</p><p class="source-code">                appCompat          : "1.4.1",</p><p class="source-code">                compose            : "1.0.5",</p><p class="source-code">                lifecycleRuntimeKtx: "2.4.0",</p><p class="source-code">                activityCompose    : "1.4.0",</p><p class="source-code">                material           : "1.5.0",</p><p class="source-code">                coroutines         : "1.5.2",</p><p class="source-code">                junit              : "4.13.2",</p><p class="source-code">                mockito            : "4.0.0",</p><p class="source-code">                espressoJunit      : "1.1.3",</p><p class="source-code">                espressoCore       : "3.4.0"</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">}</p></li>
				<li>In the same<a id="_idIndexMarker428"/> file, add a mapping for the plugin dependencies that the entire project will use:<p class="source-code">buildscript {</p><p class="source-code">    ext {</p><p class="source-code">        …</p><p class="source-code">        gradlePlugins = [</p><p class="source-code">                android: "com.android.tools.build:</p><p class="source-code">                    gradle:${versions.</p><p class="source-code">                        androidGradlePlugin}",</p><p class="source-code">                kotlin : "org.jetbrains.kotlin:kotlin-    </p><p class="source-code">                    gradle-plugin:${versions.kotlin}",</p><p class="source-code">                hilt   : "com.google.dagger:hilt-</p><p class="source-code">                    android-gradle-plugin:</p><p class="source-code">                        ${versions.hilt}"</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">}</p></li>
				<li>Next, you will <a id="_idIndexMarker429"/>need to add the dependencies to the <strong class="source-inline">androidx</strong> libraries:<p class="source-code">buildscript {</p><p class="source-code">    ext {</p><p class="source-code">        …</p><p class="source-code">        androidx = [</p><p class="source-code">                core                   : "androidx.core:core-ktx:${versions.coreKtx}",</p><p class="source-code">                appCompat              : "androidx.appcompat:appcompat:${versions.appCompat}",</p><p class="source-code">                composeUi              : "androidx.compose.ui:ui:${versions.compose}",</p><p class="source-code">                composeMaterial        : "androidx.compose.material:material:${versions.compose}",</p><p class="source-code">                composeUiToolingPreview: "androidx.compose.ui:ui-tooling-preview:${versions.compose}",</p><p class="source-code">                lifecycleRuntimeKtx    : "androidx.lifecycle:lifecycle-runtime-ktx:${versions.lifecycleRuntimeKtx}",</p><p class="source-code">                composeActivity        : "androidx.activity:activity-compose:${versions.activityCompose}"</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">}</p></li>
				<li>Next, add the<a id="_idIndexMarker430"/> remaining libraries for material design, dependency injection, and tests:<p class="source-code">buildscript {</p><p class="source-code">    ext {</p><p class="source-code">        …</p><p class="source-code">        material = [</p><p class="source-code">                material: "com.google.android.</p><p class="source-code">                    material:material:$</p><p class="source-code">                        {versions.material}"</p><p class="source-code">        ]</p><p class="source-code">        coroutines = [</p><p class="source-code">                coroutinesAndroid: "org.jetbrains.</p><p class="source-code">                    kotlinx:kotlinx-coroutines-</p><p class="source-code">                       android:${versions.coroutines}"</p><p class="source-code">        ]</p><p class="source-code">        di = [</p><p class="source-code">                hiltAndroid : "com.google.dagger:hilt-</p><p class="source-code">                    android:${versions.hilt}",</p><p class="source-code">                hiltCompiler: "com.google.dagger:hilt-</p><p class="source-code">                    compiler:${versions.hilt}"</p><p class="source-code">        ]</p><p class="source-code">        test = [</p><p class="source-code">                junit     : </p><p class="source-code">                    "junit:junit:${versions.junit}",</p><p class="source-code">                coroutines: "org.jetbrains.kotlinx:</p><p class="source-code">                    kotlinx-coroutines-test:</p><p class="source-code">                        ${versions.coroutines}",</p><p class="source-code">                mockito   : "org.mockito.kotlin:</p><p class="source-code">                   mockito-kotlin:${versions.mockito}"</p><p class="source-code">        ]</p><p class="source-code">        androidTest = [</p><p class="source-code">                junit             : "androidx.test.ext</p><p class="source-code">                    :junit:${versions.espressoJunit}",</p><p class="source-code">                espressoCore      : "androidx.test.</p><p class="source-code">                    espresso:espresso-core:$</p><p class="source-code">                        {versions.espressoCore}",</p><p class="source-code">                composeUiTestJunit: "androidx.compose.</p><p class="source-code">                ui:ui-test-junit4:${versions.compose}"</p><p class="source-code">        ]</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>In the same file, you will need to replace the previous mappings as plugin dependencies:<p class="source-code">buildscript {</p><p class="source-code">     …</p><p class="source-code">    dependencies {</p><p class="source-code">        classpath gradlePlugins.android</p><p class="source-code">        classpath gradlePlugins.kotlin</p><p class="source-code">        classpath gradlePlugins.hilt</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, you need to switch to the <strong class="source-inline">build.gradle</strong> file in the app module and change the <a id="_idIndexMarker431"/>existing configurations with the ones defined in the top-level <strong class="source-inline">build.gradle</strong>:<p class="source-code">android {</p><p class="source-code">    compileSdk defaultCompileSdkVersion</p><p class="source-code">    defaultConfig {</p><p class="source-code">        …</p><p class="source-code">        minSdk defaultMinSdkVersion</p><p class="source-code">        targetSdk defaultTargetSdkVersion</p><p class="source-code">        versionCode 1</p><p class="source-code">        versionName "1.0"</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">    compileOptions {</p><p class="source-code">        sourceCompatibility javaCompileVersion</p><p class="source-code">        targetCompatibility javaCompileVersion</p><p class="source-code">    }</p><p class="source-code">    kotlinOptions {</p><p class="source-code">        jvmTarget = jvmTarget</p><p class="source-code">        useIR = true</p><p class="source-code">    }</p><p class="source-code">    buildFeatures {</p><p class="source-code">        compose true</p><p class="source-code">    }</p><p class="source-code">    composeOptions {</p><p class="source-code">        kotlinCompilerExtensionVersion </p><p class="source-code">            versions.compose</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>In the same <a id="_idIndexMarker432"/>file, you will need to replace the dependencies with the ones defined in the top-level <strong class="source-inline">build.gradle</strong> file:<p class="source-code">dependencies {</p><p class="source-code">    implementation androidx.core</p><p class="source-code">    implementation androidx.appCompat</p><p class="source-code">    implementation material.material</p><p class="source-code">    implementation androidx.composeUi</p><p class="source-code">    implementation androidx.composeMaterial</p><p class="source-code">    implementation androidx.composeUiToolingPreview</p><p class="source-code">    implementation androidx.lifecycleRuntimeKtx</p><p class="source-code">    implementation androidx.composeActivity</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">}</p></li>
				<li>In Android Studio, execute <strong class="bold">Sync Project with Gradle Files</strong> command and then the <strong class="bold">Make Project</strong> command to make sure that the project builds without any errors.</li>
				<li>Create a<a id="_idIndexMarker433"/> new module for the project named <strong class="source-inline">domain</strong>, which will be an Android library module.</li>
				<li>In the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">domain</strong> module, make sure you have the following plugins:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.library'</p><p class="source-code">    id 'kotlin-android'</p><p class="source-code">    id 'kotlin-kapt'</p><p class="source-code">    id 'dagger.hilt.android.plugin'</p><p class="source-code">}</p></li>
				<li>In the same file, make sure you use the configurations defined in the top-level <strong class="source-inline">build.gradle</strong> file:<p class="source-code">android {</p><p class="source-code">    compileSdk defaultCompileSdkVersion</p><p class="source-code">    defaultConfig {</p><p class="source-code">        minSdk defaultMinSdkVersion</p><p class="source-code">        targetSdk defaultTargetSdkVersion</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">    compileOptions {</p><p class="source-code">        sourceCompatibility javaCompileVersion</p><p class="source-code">        targetCompatibility javaCompileVersion</p><p class="source-code">    }</p><p class="source-code">    kotlinOptions {</p><p class="source-code">        jvmTarget = jvmTarget</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the same <a id="_idIndexMarker434"/>file, you will need to add the following dependencies:<p class="source-code">dependencies {</p><p class="source-code">    implementation coroutines.coroutinesAndroid</p><p class="source-code">    implementation di.hiltAndroid</p><p class="source-code">    kapt di.hiltCompiler</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">    testImplementation test.coroutines</p><p class="source-code">    testImplementation test.mockito</p><p class="source-code">}</p></li>
				<li>Sync the project with Gradle files and build the project again to make sure that the Gradle configuration is correct.</li>
				<li>In the <strong class="source-inline">domain</strong> module, create a new package named <strong class="source-inline">entity</strong>.</li>
				<li>In the <strong class="source-inline">entity</strong> package, create <a id="_idIndexMarker435"/>a class named <strong class="source-inline">Post</strong>, which will have <strong class="source-inline">id</strong>, <strong class="source-inline">userId</strong>, <strong class="source-inline">title</strong>, and <strong class="source-inline">body</strong>:<p class="source-code">data class Post(</p><p class="source-code">    val id: Long,</p><p class="source-code">    val userId: Long,</p><p class="source-code">    val title: String,</p><p class="source-code">    val body: String</p><p class="source-code">)</p></li>
				<li>In the same package, create the <strong class="source-inline">User</strong> class, which will have <strong class="source-inline">id</strong>, <strong class="source-inline">name</strong>, <strong class="source-inline">username</strong>, and <strong class="source-inline">email</strong>:<p class="source-code">data class User(</p><p class="source-code">    val id: Long,</p><p class="source-code">    val name: String,</p><p class="source-code">    val username: String,</p><p class="source-code">    val email: String</p><p class="source-code">)</p></li>
				<li>Next, create a class named <strong class="source-inline">PostWithUser</strong>, which will contain the <strong class="source-inline">post</strong> and <strong class="source-inline">user</strong> information:<p class="source-code">data class PostWithUser(</p><p class="source-code">    val post: Post,</p><p class="source-code">    val user: User</p><p class="source-code">)</p></li>
				<li>In the same package, create a class called <strong class="source-inline">Interaction</strong>, which will contain the total number of clicks:<p class="source-code">data class Interaction(val totalClicks: Int)</p></li>
				<li>Now, we<a id="_idIndexMarker436"/> need to create the error entities:<p class="source-code">sealed class UseCaseException(cause: Throwable) : Throwable(cause) {</p><p class="source-code">    class PostException(cause: Throwable) : </p><p class="source-code">        UseCaseException(cause)</p><p class="source-code">    class UserException(cause: Throwable) : </p><p class="source-code">        UseCaseException(cause)</p><p class="source-code">    class UnknownException(cause: Throwable) : </p><p class="source-code">        UseCaseException(cause)</p><p class="source-code">    companion object {</p><p class="source-code">        fun createFromThrowable(throwable: Throwable): </p><p class="source-code">            UseCaseException {</p><p class="source-code">            return if (throwable is UseCaseException) </p><p class="source-code">            throwable else UnknownException(throwable)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we have exceptions defined for when there will be an issue with loading the post and user information, and <strong class="source-inline">UnknownException</strong>, which will be emitted when something else goes wrong.</p>
			<ol>
				<li value="22">Next, let's<a id="_idIndexMarker437"/> create the <strong class="source-inline">Result</strong> class, which will hold the success and error information:<p class="source-code">sealed class Result&lt;out T : Any&gt; {</p><p class="source-code">    data class Success&lt;out T : Any&gt;(val data: T) : </p><p class="source-code">        Result&lt;T&gt;()</p><p class="source-code">    class Error(val exception: UseCaseException) : </p><p class="source-code">        Result&lt;Nothing&gt;()</p><p class="source-code">}</p></li>
				<li>Now, we need to move on to defining the abstractions for the repositories, and to do so, we create a new package named <strong class="source-inline">repository</strong>.</li>
				<li>In the <strong class="source-inline">repository</strong> package, create an interface for managing the post data:<p class="source-code">interface PostRepository {</p><p class="source-code">    fun getPosts(): Flow&lt;List&lt;Post&gt;&gt;</p><p class="source-code">    fun getPost(id: Long): Flow&lt;Post&gt;</p><p class="source-code">}</p></li>
				<li>In the same package, create an interface for managing the user data:<p class="source-code">interface UserRepository {</p><p class="source-code">    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;</p><p class="source-code">    fun getUser(id: Long): Flow&lt;User&gt;</p><p class="source-code">}</p></li>
				<li>In the same package, create an interface for managing the interaction data:<p class="source-code">interface InteractionRepository {</p><p class="source-code">    fun getInteraction(): Flow&lt;Interaction&gt;</p><p class="source-code">    fun saveInteraction(interaction: Interaction): </p><p class="source-code">        Flow&lt;Interaction&gt;</p><p class="source-code">}</p></li>
				<li>Now, we <a id="_idIndexMarker438"/>move on to the use cases and start by creating a new package named <strong class="source-inline">usecase</strong>.</li>
				<li>In this package, create the <strong class="source-inline">UseCase</strong> template:<p class="source-code">abstract class UseCase&lt;I : UseCase.Request, O : UseCase.Response&gt;(private val configuration: Configuration) {</p><p class="source-code">    fun execute(request: I) = process(request)</p><p class="source-code">        .map {</p><p class="source-code">            Result.Success(it) as Result&lt;O&gt;</p><p class="source-code">        }</p><p class="source-code">        .flowOn(configuration.dispatcher)</p><p class="source-code">        .catch {</p><p class="source-code">            emit(Result.Error(UseCaseException.</p><p class="source-code">                createFromThrowable(it)))</p><p class="source-code">        }</p><p class="source-code">    internal abstract fun process(request: I): Flow&lt;O&gt;</p><p class="source-code">    class Configuration(val dispatcher: </p><p class="source-code">        CoroutineDispatcher)</p><p class="source-code">    interface Request</p><p class="source-code">    interface Response</p><p class="source-code">}</p></li>
			</ol>
			<p>In this<a id="_idIndexMarker439"/> template, we have defined the data transfer objects' abstraction, as well as a <strong class="source-inline">Configuration</strong> class that holds <strong class="source-inline">CoroutineDispatcher</strong>. The reason for this <strong class="source-inline">Configuration</strong> class is to be able to add other parameters for the use case without modifying the <strong class="source-inline">UseCase</strong> subclasses. We have one <strong class="source-inline">abstract</strong> method, which will be implemented by the subclasses to retrieve the data from the repositories, and the <strong class="source-inline">execute</strong> method, which will take the data and convert it to <strong class="source-inline">Result</strong>, handle the error scenarios, and set the proper <strong class="source-inline">CoroutineDispatcher</strong>.</p>
			<ol>
				<li value="29">In the <strong class="source-inline">usecase</strong> package, create the use case to retrieve the list of posts with the user information and the interaction data:<p class="source-code">class GetPostsWithUsersWithInteractionUseCase @Inject constructor(</p><p class="source-code">    configuration: Configuration,</p><p class="source-code">    private val postRepository: PostRepository,</p><p class="source-code">    private val userRepository: UserRepository,</p><p class="source-code">    private val interactionRepository: </p><p class="source-code">        InteractionRepository</p><p class="source-code">    ) : GetPostsWithUsersWithInteractionUseCase </p><p class="source-code">    GetPostsWithUsersWithInteractionUseCase {</p><p class="source-code">    override fun process(request: Request): </p><p class="source-code">        Flow&lt;Response&gt; =</p><p class="source-code">        combine(</p><p class="source-code">            postRepository.getPosts(),</p><p class="source-code">            userRepository.getUsers(),</p><p class="source-code">            interactionRepository.getInteraction()</p><p class="source-code">        ) { posts, users, interaction -&gt;</p><p class="source-code">            val postUsers = posts.map { post -&gt;</p><p class="source-code">                val user = users.first {</p><p class="source-code">                    it.id == post.userId</p><p class="source-code">                }</p><p class="source-code">                PostWithUser(post, user)</p><p class="source-code">            }</p><p class="source-code">            Response(postUsers, interaction)</p><p class="source-code">        }</p><p class="source-code">    object Request : UseCase.Request</p><p class="source-code">    data class Response(</p><p class="source-code">        val posts: List&lt;PostWithUser&gt;,</p><p class="source-code">        val interaction: Interaction</p><p class="source-code">    ) : UseCase.Response</p><p class="source-code">}</p></li>
			</ol>
			<p>In this class, we extend the <strong class="source-inline">UseCase</strong> class, and in the <strong class="source-inline">process</strong> method, we combine the posts, users, and interaction flows. Because there is no input required, the <strong class="source-inline">Request</strong> class will have to be empty, and the <strong class="source-inline">Response</strong> class will contain a list of combined user and post information as well as the interaction data. The <strong class="source-inline">@Inject</strong> annotation will help us inject this use case later in the presentation layer. </p>
			<ol>
				<li value="30">In the<a id="_idIndexMarker440"/> same package, create the use case to retrieve a post by ID:<p class="source-code">class GetPostUseCase @Inject constructor(</p><p class="source-code">    configuration: Configuration,</p><p class="source-code">    private val postRepository: PostRepository</p><p class="source-code">    ) : UseCase&lt;GetPostUseCase.Request, </p><p class="source-code">    GetPostUseCase.Response&gt;(configuration) {</p><p class="source-code">    override fun process(request: Request): Flow</p><p class="source-code">        &lt;Response&gt; =</p><p class="source-code">        postRepository.getPost(request.postId)</p><p class="source-code">            .map {</p><p class="source-code">                Response(it)</p><p class="source-code">            }</p><p class="source-code">    data class Request(val postId: Long) : UseCase.</p><p class="source-code">        Request</p><p class="source-code">    data class Response(val post: Post) : UseCase.</p><p class="source-code">        Response</p><p class="source-code">}</p></li>
				<li>In the<a id="_idIndexMarker441"/> same package, create the use case to retrieve a user by ID:<p class="source-code">class GetUserUseCase @Inject constructor(</p><p class="source-code">    configuration: Configuration,</p><p class="source-code">    private val userRepository: UserRepository</p><p class="source-code">    ) : UseCase&lt;GetUserUseCase.Request,</p><p class="source-code">    GetUserUseCase.Response&gt;(configuration) {</p><p class="source-code">    override fun process(request: Request): Flow</p><p class="source-code">        &lt;Response&gt; =</p><p class="source-code">        userRepository.getUser(request.userId)</p><p class="source-code">            .map {</p><p class="source-code">                Response(it)</p><p class="source-code">            }</p><p class="source-code">    data class Request(val userId: Long) : UseCase.</p><p class="source-code">        Request</p><p class="source-code">    data class Response(val user: User) : UseCase.</p><p class="source-code">        Response</p><p class="source-code">}</p></li>
				<li>Now, we move on to the last use case for updating the interaction data:<p class="source-code">class UpdateInteractionUseCase @Inject constructor(</p><p class="source-code">    configuration: Configuration,</p><p class="source-code">    private val interactionRepository: </p><p class="source-code">        InteractionRepository</p><p class="source-code">    ) : UseCase&lt;UpdateInteractionUseCase.Request, </p><p class="source-code">    UpdateInteractionUseCase.Response&gt;(configuration) {</p><p class="source-code">    override fun process(request: Request): Flow</p><p class="source-code">        &lt;Response&gt; {</p><p class="source-code">        return interactionRepository.saveInteraction</p><p class="source-code">            (request.interaction)</p><p class="source-code">            .map {</p><p class="source-code">                Response</p><p class="source-code">            }</p><p class="source-code">    }</p><p class="source-code">    data class Request(val interaction: Interaction) : </p><p class="source-code">         UseCase.Request</p><p class="source-code">    object Response : UseCase.Response</p><p class="source-code">}</p></li>
				<li>To unit-test <a id="_idIndexMarker442"/>the code, we need to create a new folder called <strong class="source-inline">resources</strong> in the <strong class="source-inline">test</strong> folder of the <strong class="source-inline">domain</strong> module. </li>
				<li>Inside the <strong class="source-inline">resources</strong> folder, create a subfolder called <strong class="source-inline">mockito-extensions</strong>; inside this folder, create a file named <strong class="source-inline">org.mockito.plugins.MockMaker</strong>; and inside this file, add the following text – <strong class="source-inline">mock-maker-inline</strong>. This allows the Mockito testing library to mock the <strong class="source-inline">final</strong> Java class, which in Kotlin means all classes without the <strong class="source-inline">open</strong> keyword.</li>
				<li>Create a new<a id="_idIndexMarker443"/> class named <strong class="source-inline">UseCaseTest</strong> in the test folder of the <strong class="source-inline">domain</strong> module:<p class="source-code">class UseCaseTest {</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    private val configuration = UseCase.Configuration</p><p class="source-code">        (TestCoroutineDispatcher())</p><p class="source-code">    private val request = mock&lt;UseCase.Request&gt;()</p><p class="source-code">    private val response = mock&lt;UseCase.Response&gt;()</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    private lateinit var useCase: </p><p class="source-code">        UseCase&lt;UseCase.Request, UseCase.Response&gt;</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Before</p><p class="source-code">    fun setUp() {</p><p class="source-code">        useCase = object : UseCase&lt;UseCase.Request, </p><p class="source-code">            UseCase.Response&gt;(configuration) {</p><p class="source-code">            override fun process(request: Request):  </p><p class="source-code">                Flow&lt;Response&gt; {</p><p class="source-code">                assertEquals(this@UseCaseTest.request, </p><p class="source-code">                    request)</p><p class="source-code">                return flowOf(response)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we provide an implementation for the <strong class="source-inline">UseCase</strong> class, which will return a mocked response.</p>
			<ol>
				<li value="36">Next, create <a id="_idIndexMarker444"/>a test method that will verify the successful scenario for the <strong class="source-inline">execute</strong> method:<p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testExecuteSuccess() = runBlockingTest {</p><p class="source-code">        val result = useCase.execute(request).first()</p><p class="source-code">        assertEquals(Result.Success(response), result)</p><p class="source-code">    }</p></li>
			</ol>
			<p>Here, we assert that the result of the <strong class="source-inline">execute</strong> method is <strong class="source-inline">Success</strong> and that it contains the mocked response.</p>
			<ol>
				<li value="37">Next, create a new test class named <strong class="source-inline">GetPostsWithUsersWithInteractionUseCaseTest</strong>:<p class="source-code">class GetPostsWithUsersWithInteractionUseCaseTest {</p><p class="source-code">    private val postRepository = mock&lt;PostRepository&gt;()</p><p class="source-code">    private val userRepository = mock&lt;UserRepository&gt;()</p><p class="source-code">    private val interactionRepository = mock&lt;InteractionRepository&gt;()</p><p class="source-code">    private val useCase = GetPostsWithUsersWithInteractionUseCase(</p><p class="source-code">        mock(),</p><p class="source-code">        postRepository,</p><p class="source-code">        userRepository,</p><p class="source-code">        interactionRepository</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we mock all the repositories and inject the mocks into the class we want to test.</p>
			<ol>
				<li value="38">Finally, create<a id="_idIndexMarker445"/> a test method that will verify the <strong class="source-inline">process</strong> method from the use case we are testing:<p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testProcess() = runBlockingTest {</p><p class="source-code">        val user1 = User(1L, "name1", "username1", "email1")</p><p class="source-code">        val user2 = User(2L, "name2", "username2", "email2")</p><p class="source-code">        val post1 = Post(1L, user1.id, "title1", "body1")</p><p class="source-code">        val post2 = Post(2L, user1.id, "title2", "body2")</p><p class="source-code">        val post3 = Post(3L, user2.id, "title3", "body3")</p><p class="source-code">        val post4 = Post(4L, user2.id, "title4", "body4")</p><p class="source-code">        val interaction = Interaction(10)</p><p class="source-code">        whenever(userRepository.getUsers()).thenReturn</p><p class="source-code">            (flowOf(listOf(user1, user2)))</p><p class="source-code">        whenever(postRepository.getPosts()).thenReturn</p><p class="source-code">          (flowOf(listOf(post1, post2, post3, post4)))whenever(interactionRepository.getInteraction</p><p class="source-code">            ()).thenReturn(flowOf(interaction))</p><p class="source-code">        val response = useCase.process</p><p class="source-code">            (GetPostsWithUsersWithInteractionUseCase.</p><p class="source-code">                Request).first()</p><p class="source-code">        assertEquals(</p><p class="source-code">            GetPostsWithUsersWithInteractionUseCase.</p><p class="source-code">                Response(</p><p class="source-code">                listOf(</p><p class="source-code">                    PostWithUser(post1, user1),</p><p class="source-code">                    PostWithUser(post2, user1),</p><p class="source-code">                    PostWithUser(post3, user2),</p><p class="source-code">                    PostWithUser(post4, user2),</p><p class="source-code">                ), interaction</p><p class="source-code">            ),</p><p class="source-code">            response</p><p class="source-code">        )</p><p class="source-code">    }</p></li>
			</ol>
			<p>Here, we provide mock lists of users and posts and a mock interaction, then we return these for each of the repository calls, and then we assert that the result is a list of four posts, written by two users and the mock interaction.</p>
			<p>If we run the tests for these two methods, they should pass. To test the remaining use cases, the same principles can be applied that we used for <strong class="source-inline">GetPostsWithUsersWithInteractionUseCaseTest</strong> – create mock repositories, inject them into the object we wish to test, and then define the mocks for the input of the <strong class="source-inline">process</strong> method and the results we should expect, which will give us output as <a id="_idIndexMarker446"/>shown in the following screenshot:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_5.05_B18320.jpg" alt="Figure 5.5 – Output of the use case unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Output of the use case unit tests</p>
			<p>In this section, we performed an exercise in which we created a simple domain that contained entities, a few simple use cases, and a particular use case that combined multiple data sources. The domain module has dependencies on flows and Hilt. This means that changes to these libraries might cause changes to our domain module. This decision was made because of the benefits that these libraries provide when it comes to reactive programming and dependency injection. Because we considered dependency injection when defining the use cases, this made them more testable, as we could inject mock objects<a id="_idIndexMarker447"/> into the tested objects very easily.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor075"/>Summary </h1>
			<p>In this chapter, we looked at how the architecture of an Android app is layered and focused on the domain layer, discussing the topics of entities and use cases. We also learned how to use dependency inversion to place use cases and entities at the center of our architecture. We did this by creating repository abstractions that can be implemented in the lower layers. We also learned how to use library modules to enforce separations between layers.</p>
			<p>In the chapter's exercise, we created a domain module for an Android application, providing an example of what a domain layer might look like. In the next chapter, we will focus on the data layer, in which we will provide implementations for the repository abstractions we defined in the domain layer, and discuss how we can use these repositories to manage an application's data.</p>
		</div>
	</body></html>