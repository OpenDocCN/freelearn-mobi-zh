["```swift\nclass ReposTableViewController: UITableViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        self.title = \"Repos\"\n    }\n\n    //...\n}\n```", "```swift\n@discardableResult   \n internal func fetchRepos(forUsername username: String,\n      completionHandler: @escaping (FetchReposResult) -> Void) \n        -> URLSessionDataTask? {\n\n        let urlString = \"https://api.github.com/users/\\\n          (username)/repos\"\n        guard let url = URL(string: urlString) else {\n            return nil\n        }\n        var request = URLRequest(url: url)\n        request.setValue(\"application/vnd.github.v3+json\", \n          forHTTPHeaderField: \"Accept\")\n        let task = session.dataTask(with: request) { (data,\n          response, error) in\n\n            // First unwrap the optional data\n            guard let data = data else {\n                completionHandler(.failure(ResponseError.\n                  requestUnsuccessful))\n                return\n            }\n\n            do {\n                let decoder = JSONDecoder()\n                let responseObject = try decoder.\n                  decode([Repo].self, from: data)\n\n                completionHandler(.success(responseObject))\n            } catch {\n                completionHandler(.failure(error))\n            }\n        }\n        task.resume()\n\n        return task\n    }\n```", "```swift\nimport UIKit\n\nstruct Repo: Codable {\n    let name: String?\n    let url: URL?\n\n    enum CodingKeys: String, CodingKey {\n        case name = \"name\"\n        case url = \"html_url\"\n    }\n\n}\n\nenum FetchReposResult {\n    case success([Repo])\n    case failure(Error)\n}\n\nenum ResponseError: Error {\n    case requestUnsuccessful\n    case unexpectedResponseStructure }\n\nclass ReposTableViewController: UITableViewController {\n\n internal var session = URLSession.shared\n\n    //...\n}\n```", "```swift\nclass ReposTableViewController: UITableViewController {\n\n   internal var session = URLSession.shared\n\n internal var repos = [Repo]()\n\n    //...\n}\n```", "```swift\nclass ReposTableViewController: UITableViewController {\n\n    let session = URLSession.shared\n\n    var repos = [Repo]()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n let repo1 = Repo(name: \"Test repo 1\", \n   url: URL(string: \"http://example.com/repo1\")!)\n let repo2 = Repo(name: \"Test repo 2\", \n   url: URL(string: \"http://example.com/repo2\")!)\n repos.append(contentsOf: [repo1, repo2])\n    }\n\n    //...\n}\n```", "```swift\n// MARK: - Table view data source\noverride func numberOfSections(in tableView: UITableView) -> Int {\n    // #warning Incomplete implementation, return the number of \n     // sections\n    return 0\n}\n\noverride func tableView(_ tableView: UITableView, \n                        numberOfRowsInSection section: Int) -> Int {\n // #warning Incomplete implementation, return the number of rows\n    return 0\n}\n\n/*\noverride func tableView(_ tableView: UITableView, \n   cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n     let cell = tableView.dequeueReusableCell(withIdentifier: \n       \"RepoCell\", for: indexPath)\n     // Configure the cell...\n     return cell\n}\n*/\n```", "```swift\noverride func numberOfSections(in tableView: UITableView) -> Int {\n   1\n}\n```", "```swift\noverride func tableView(_ tableView: UITableView, \n  numberOfRowsInSection section: Int) -> Int {\n   repos.count\n}\n```", "```swift\nfunc register(_ cellClass: AnyClass?, \n              forCellReuseIdentifier identifier: String)\n```", "```swift\nfunc register(_ nib: UINib?, forCellReuseIdentifier identifier: String)\n```", "```swift\n/*\noverride func tableView(_ tableView: UITableView, \n   cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n let cell = tableView.dequeueReusableCell(withIdentifier:  \n   \"RepoCell\", for: indexPath)\n // Configure the cell... return cell\n}\n*/\n```", "```swift\noverride func tableView(_ tableView: UITableView, \n  cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \n      \"RepoCell\", for: indexPath)\n\n    // Configure the cell...\n    let repo = repos[indexPath.row]\n    cell.textLabel?.text = repo.name\n\n    return cell\n}\n```", "```swift\nclass ReposTableViewController: UITableViewController {\n\n    internal var session = URLSession.shared\n    internal var repos = [Repo]()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        title = \"Repos\"\n\n        fetchRepos(forUsername:\"SwiftProgrammingCookbook\"){ [weak self]\n          result in\n\n            switch result {\n            case .success(let repos):\n                self?.repos = repos\n\n            case .failure(let error):\n                self?.repos = []\n                print(\"There was an error: \\(error)\")\n            }\n            self?.tableView.reloadData()\n        }\n    }\n    //...\n}\n```", "```swift\nclass ReposTableViewController: UITableViewController {\n\n    let session = URLSession.shared\n    var repos = [Repo]()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        title = \"Repos\"\n\n        fetchRepos(forUsername:\"SwiftProgrammingCookbook\"){ [weak self] \n          result in\n\n            DispatchQueue.main.async {\n\n                switch result {\n                case .success(let repos):\n                    self?.repos = repos\n\n                case .failure(let error):\n                    self?.repos = []\n                    print(\"There was an error: \\(error)\")\n                }\n                self?.tableView.reloadData()\n            }\n        }\n    }\n}\n```", "```swift\n func tableView(_ tableView: UITableView, didSelectRowAt indexPath: \n   IndexPath)\n```", "```swift\noverride func tableView(_ tableView: UITableView, didSelectRowAt \n  indexPath: IndexPath) {\n\n    let repo = repos[indexPath.row]\n    let repoURL = repo.url\n\n    // TODO: Present the repo's URL in a webview\n}\n```", "```swift\noverride func tableView(_ tableView: UITableView, \n                        didSelectRowAt indexPath: IndexPath) {\n\n    let repo = repos[indexPath.row]\n    guard let repoURL = repo.url else { return }    \n\n    let webViewController = SFSafariViewController(url: repoURL)\n    show(webViewController, sender: nil)\n}\n```", "```swift\nextension ReposTableViewController: UITextFieldDelegate {\n\n}\n```", "```swift\nextension ReposTableViewController: UITextFieldDelegate {\n\n    public func textFieldShouldReturn(_ textField: UITextField) \n      -> Bool {\n\n    // TODO: Fetch repositories from username entered into text\n    // field\n // TODO: Dismiss keyboard\n\n // Returning true as we want the system to have the default \n   // behaviour\n return true\n    }\n}\n```", "```swift\nextension ReposTableViewController: UITextFieldDelegate {\n\n    public func textFieldShouldReturn(_ textField: UITextField) \n     -> Bool {\n\n        // If no username, clear the data\n         guard let enteredUsername = textField.text else {\n             repos.removeAll()\n             tableView.reloadData()\n             return true\n         }\n\n        // Fetch repositories from username entered into text field\n        fetchRepos(forUsername: enteredUsername) { [weak self] \n          result in\n\n                switch result {\n                case .success(let repos):\n                    self?.repos = repos\n\n                case .failure(let error):\n                    self?.repos = []\n                    print(\"There was an error: \\(error)\")\n                }\n                DispatchQueue.main.async {\n                   self?.tableView.reloadData()\n            }\n        }\n\n        // TODO: Dismiss keyboard\n\n        // Returning true as we want the system to have the default \n          // behaviour\n        return true\n    }\n}\n```", "```swift\nextension ReposTableViewController: UITextFieldDelegate {\n\n    public func textFieldShouldReturn(_ textField: UITextField) \n      -> Bool {\n\n        //...\n\n        // Dismiss keyboard\n        textField.resignFirstResponder()\n\n        // Returning true as we want the system to have the default \n           // behaviour\n        return true\n    }\n}\n```", "```swift\nfunc testThatRepoIsNotNil() {\n XCTAssertNotNil(viewControllerUnderTest?.repos)\n}\n```", "```swift\ninternal var repos: [Repo]?\n```", "```swift\nvar viewControllerUnderTest: ReposTableViewController?\n```", "```swift\noverride func setUp() {\n    viewControllerUnderTest = ReposTableViewController()\n}\n```", "```swift\nXCTAssert\nXCTAssertEqual\nXCTAssertTrue\nXCTAssertGreaterThan\nXCTAssertGreaterThanOrEqual\nXCTAssertLessThan\nXCTAssertLessThanOrEqual\nXCTAssertNil\n```", "```swift\n func testThatFetchRepoParsesSuccessfulData() { }\n```", "```swift\n    func testThatFetchRepoParsesSuccessfulData() {\n        viewControllerUnderTest?.fetchRepos(forUsername: \"\", completionHandler: { (response) in\n            print(\"\\(response)\")\n        })\n    }\n```", "```swift\nlet task = session.dataTask(with: request) { (data, response, error) in\n```", "```swift\nclass MockURLSession: URLSession {\n    override func dataTask(with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionDataTask {\n        return MockURLSessionDataTask(completionHandler: completionHandler, request: request)\n    }\n}\n```", "```swift\nclass MockURLSessionDataTask: URLSessionDataTask {\n\n    var completionHandler: (Data?, URLResponse?, Error?) -> Void\n    var request: URLRequest\n\n    init(completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void, request: URLRequest) {\n        self.completionHandler = completionHandler\n        self.request = request\n        super.init()\n    }\n\n    var calledResume = false\n\n    override func resume() {\n        calledResume = true\n    }\n\n}\n```", "```swift\nfunc testThatFetchRepoParsesSuccessfulData() {\n\n    viewControllerUnderTest?.session = MockURLSession()\n\n    // ...\n\n}\n```", "```swift\nvar responseObject: FetchReposResult?\n```", "```swift\nlet result = viewControllerUnderTest?.fetchRepos(forUsername: \"\", completionHandler: { (response) in\n        responseObject = response\n    }) as? MockURLSessionDataTask\n```", "```swift\nresult?.completionHandler(mockData, nil, nil)\n```", "```swift\nvar mockData: Data {\n    if let path = Bundle.main.path(forResource: \"mock_Data\", ofType: \"json\"), let contents = FileManager.default.contents(atPath: path){\n        return contents\n    }\n    return Data()\n}\n```", "```swift\nswitch responseObject {\n    case .success(let repos):\n\n    // Our test data had 3 repos, lets check that parsed okay\n XCTAssertEqual(repos.count, 9)\n\n    // We know the first repo has a specific name... let's check that\n XCTAssertEqual(repos.first?.name, \"aerogear-ios-oauth2\")\n    default:\n    // Anything other than success - failure...\n XCTFail()\n}\n```", "```swift\nfunc isUserInputValid(withText text: String) -> Bool {\n    return false\n}\n```", "```swift\nfunc testThatTextInputValidatesWithSingleWhitespace() {  \n}\n```", "```swift\nfunc testThatTextInputValidatesWithSingleWhitespaces() {\n    let result = viewControllerUnderTest?.isUserInputValid(withText: \"multiple white spaces\")\n    XCTAssertFalse(result!)\n}\n```", "```swift\nfunc isUserInputValid(withText text: String) -> Bool {\n    return !text.contains(\" \")\n}\n```", "```swift\nfunc testExample() throws {\n    // UI tests must launch the application that they test.\n    let app = XCUIApplication()\n    app.launch()\n}\n```", "```swift\nfunc testThatUsernameSearchBarIsAvailable() throws {\n    let app = XCUIApplication()\n    app.launch()\n app.textFields.element.tap()\n}\n```", "```swift\n@IBOutlet weak var usernameTextField: UITextField! {\n    didSet {\n        usernameTextField.accessibilityIdentifier = \n          \"input.textfield.username\"\n    }\n}\n```", "```swift\napp.textFields.element(matching: .textField, identifier: \n  \"input.textfield.username\").tap()\n```", "```swift\napp.scrollViews.element(matching: .button, identifier: \n  \"action.button.stopscrolling\").tap()\n```", "```swift\nlet textField = app.textFields.element(matching: .textField,\n  identifier: \"input.textfield.username\")\n```", "```swift\ntextField.tap()\ntextField.typeText(\"MrChrisBarker\")\n```", "```swift\napp.keyboards.buttons[\"return\"].tap()\n```", "```swift\nlet tableView = app.tables.staticTexts[\"XcodeValidateJson\"]\nXCTAssertTrue(tableView.waitForExistence(timeout: 5))\n```", "```swift\ntap()\ndoubleTap()\npress()\ntwoFingerTap()\nswipeUp()\nswipeDown()\nswipeLeft()\nswipeRight()\npinch()\nrotate()\n```", "```swift\nUIView().layer.maskedCorners = [.layerMinXMaxYCorner, \n .layerMaxXMaxYCorner]\n```", "```swift\nif #available(iOS 11.0, *) {\n    UIView().layer.maskedCorners = [.layerMinXMaxYCorner, \n      .layerMaxXMaxYCorner]\n} else {\n    // Fallback on earlier versions\n}\n```", "```swift\n@available(iOS 11.0, *)\nfunc availableCheck() {\n    UIView().layer.maskedCorners = [.layerMinXMaxYCorner,\n      .layerMaxXMaxYCorner]\n}\n```", "```swift\n@available(iOS 11.0, *)\nclass ReposTableViewController: UITableViewController { }\n```"]