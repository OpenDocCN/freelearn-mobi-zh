- en: Chapter 7. Throwing Your Weight Around – Physics and a 2D Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we learned about the special features of a mobile
    device and how to create touch and tilt controls. We also created a Space Fighter
    game to use these new controls. The steering of the ship was done by tilting the
    device and shooting by touching the screen. Using some special movement tricks,
    we gave the player an infinite amount of space to fly and enemies to fight.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter, we take a short break from the Space Fighter game to explore
    Unity''s physics engine. We will also take a look at options for creating a 2D
    game experience. To do all of this, we will be recreating one of the most popular
    mobile games on the market, Angry Birds. We will use physics to throw birds and
    destroy structures. We will also take a look at the creation of a level-selection
    screen.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Unity Physics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallax scrolling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isometric camera
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be creating a new project for this chapter, so start up Unity and let's
    begin!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 2D games in a 3D world
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most underrealized thing when developing games is the fact that
    it's possible to create 2D-style games in a 3D game engine such as Unity. As with
    everything else, it comes with its own set of advantages and disadvantages, but
    the choice can be well worth it for generating a pleasing game experience. The
    foremost of the advantages is that one can use 3D assets for the game. This allows
    dynamic lighting and shadows to be easily included. However, if using a 2D engine,
    any shadow would need to be painted directly into the assets and you would be
    hard-pressed to make it dynamic. On the disadvantage side is the use of 2D assets
    in the 3D world. It is completely possible to use them, but large file sizes become
    necessary to achieve the desired detail and keep it from appearing pixelated.
    Most 2D engines, however, make use of vector art that will keep the image's lines
    smooth as it is scaled up and down. Also, one is able to use normal animations
    for the 3D assets, but frame-by-frame animation is generally required for any
    2D asset. Altogether, the advantages have outweighed the disadvantages for many
    developers, creating a large selection of great looking 2D games that you may
    never realize were actually made in a 3D game engine. Now, we shall design another
    game by recreating the highly popular Angry Birds.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – preparing the world
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with preparing the world for the Angry Birds game:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: To start it all off, we need to create a new project in Unity. Naming it `Ch7_AngryBirds`
    will work well. Be sure to change the target platform to **Android** and set the
    **Bundle Identifier** to an appropriate value.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, import the starting assets for this chapter and create some folders to
    keep everything organized.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, it is very easy to turn a game from 3D to 2D. Simply select the **Main
    Camera** object that is by default present in every new scene, find the **Projection**
    value, and select **Orthographic** from the drop-down list.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，将游戏从3D转换为2D非常简单。只需选择默认存在于每个新场景中的**主摄像头**对象，找到**投影**值，然后从下拉列表中选择**正交**。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Every camera has two options for how to render the game. **Perspective** renders
    everything utilizing the distance from the camera, imitating the real world; objects
    that are farther away from the camera are drawn smaller than objects that are
    closer. **Orthographic** renders everything without this consideration; objects
    are not scaled based on their distance from the camera.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个摄像头都有两种渲染游戏的方式。**透视**渲染利用摄像头与物体之间的距离，模仿现实世界；距离摄像头较远的物体比距离较近的物体绘制得小。**正交**渲染不考虑这一点；物体不会根据其与摄像头的距离进行缩放。
- en: Initially, the amount of the scene that the camera views is far too large. To
    change this, set the **Size** value to `5`. This reduces the amount of space the
    camera will render. This value will keep us focused on the action as the game
    is played.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，摄像头所看到的场景范围过大。要改变这一点，将**大小**值设置为`5`。这将减少摄像头渲染的空间量。这个值将帮助我们专注于游戏中的动作。
- en: To make the camera properly usable, set its **Position** to `10` for the **X**
    axis, `3` for the **Y** axis, and `0` for the **Z** axis. Also, set its **Rotation**
    for the **Y** axis to `-90`. Everything is going to be positioned along the z
    axis, so our camera needs to be set to watch the axis and be far away enough so
    that it is not in the action.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使摄像头能够正确使用，将其**位置**设置为**X**轴的`10`，**Y**轴的`3`，**Z**轴的`0`。此外，将其**旋转**的**Y**轴设置为`-90`。所有东西都将沿着z轴定位，因此我们的摄像头需要设置为观察轴，并且足够远，以便它不在动作中。
- en: Next, we are going to need a ground. So, go to the menu bar of Unity and click
    on **GameObject**, followed by **Create Other**, and finally, click on **Cube**.
    This will suit well enough as a simple ground.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个地面。因此，前往Unity的菜单栏，点击**GameObject**，然后点击**Create Other**，最后点击**Cube**。这足以作为一个简单的地面。
- en: To make it look a little like a ground, create a green material and apply it
    to the **Cube**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让它看起来更像地面，创建一个绿色材质并将其应用到**Cube**上。
- en: The ground cube needs to be large enough to cover the whole of our field of
    play. To do this, set its **Scale** to `5` for the **X** axis, `10` for the **Y**
    axis, and `100` for the **Z** axis. Also, set its **Position** to `0` for the
    **X** and **Y** axes, and `30` for the **Z** axis. Since nothing will be moving
    along the x axis, the ground only needs to be large enough for the other objects
    that will be in our scene to land on. It does, however, need to be wide and tall
    enough to keep the camera from seeing the edges.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地面立方体需要足够大，以覆盖我们的整个游戏区域。为此，将其**缩放**设置为**X**轴的`5`，**Y**轴的`10`，**Z**轴的`100`。此外，将其**位置**设置为**X**和**Y**轴的`0`，**Z**轴的`30`。由于x轴上没有物体移动，地面只需要足够大，以便其他将在场景中的物体可以着陆。然而，它确实需要足够宽和高，以防止摄像头看到边缘。
- en: Right now, the ground looks rather dark due to the lack of light. From the menu
    bar of Unity, click on **GameObject**, followed by **Create Other**, and lastly
    click on **Directional Light** to add some brightness to the scene. It should
    be positioned to shine on the side of the cube that faces the camera.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，由于缺乏光源，地面看起来相当暗。从Unity的菜单栏点击**GameObject**，然后点击**Create Other**，最后点击**Directional
    Light**来为场景增加一些亮度。它应该被放置在照亮面对摄像头的立方体侧面的位置。
- en: Next, we need to keep all of the objects that will be flying around the scene
    from straying too far and causing problems. To do this, we need to create some
    trigger volumes. The simplest way to do this is to create three more cubes. Position
    one at each end of the ground object and the last cube at about 50 units above.
    Then, scale them to form a box with the ground. Each should be no thicker than
    a single unit, and they need to be five units deep, the same as the ground. Next,
    remove their **Mesh Renderer** and **Mesh Filter** components. This removes the
    visible box, while leaving the collider volume. To change them to trigger volumes,
    check the **Is Trigger** checkbox on each **Box Collider** component.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the volumes actually keep objects from straying too far, we need to
    create a new script. Create it and name it `GoneTooFar`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script has a single, short function, `OnTriggerEnter`. We use it to destroy
    any object that might enter the volume. This function is used by Unity's physics
    system to detect when an object has entered a trigger volume. We will go into
    more detail later but, for now, know that one of the two objects, either the volume
    or the object entering it, needs a **Rigidbody** component. In our case, everything
    we might want to remove when they enter the trigger will have a **Rigidbody**
    component.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finally, return to Unity and add the script to the three trigger-volume objects.![Time
    for action – preparing the world](img/2014OT_07_01.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We did the initial setup for our 2D game. By changing our camera view to **Orthographic**,
    the view switches from a 3D game to a 2D one. We also created a ground and some
    trigger volumes for our scene. Together, these will keep our birds and anything
    else from straying too far.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Physics
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, physics simulation primarily focuses on the use of the **Rigidbody**
    component. When the **Rigidbody** component is attached to any object, it will
    be taken over by the physics engine. The object will fall with gravity and bump
    into any object that has a collider. In our scripts, making use of the `OnCollision`
    function and the `OnTrigger` function requires a **Rigidbody** component to be
    attached to at least one of the two interacting objects. However, a **Rigidbody**
    component can interfere with any specific movement we might cause the object to
    take. Every **Rigidbody**, though, can be marked as kinematic, meaning the physics
    engine will not move it. The **CharacterController** component that we used for
    our tank is a special, modified **Rigidbody**. In this chapter, we will be making
    heavy use of the **Rigidbody** component to tie all of our birds, blocks, and
    pigs into the physics engine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our first physics objects, we will create the blocks that the pig castles
    are built out of. We will be creating three types of blocks: wood, glass, and
    rubber. With these few simple blocks, we will be able to easily create a large
    variety of levels and structures to smash with birds.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个物理对象，我们将创建猪城堡所用的块。我们将创建三种类型的块：木头、玻璃和橡胶。凭借这些简单的块，我们将能够轻松地创建大量不同级别和结构，供小鸟摧毁。
- en: Time for action – creating planks
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——创建木板
- en: 'Each of the blocks we will be creating will be largely similar:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的每个块都将非常相似：
- en: First, we will create the plank of wood. To do this, we need another cube. Rename
    it `Plank_Wood`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一块木板。为此，我们需要另一个立方体。将其重命名为`Plank_Wood`。
- en: Set the plank's **Scale** to `2` for the **X** and **Y** axes, and `0.25` for
    the **Z** axis. Its scale on the y and z axis define its size as seen by the player.
    The scale on the x axis makes sure that it will be hit by other physics objects
    in the scene.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将木板的**Scale**设置为**X**和**Y**轴为`2`，**Z**轴为`0.25`。它在y和z轴上的缩放定义了玩家看到的尺寸。x轴上的缩放确保它将被场景中的其他物理对象击中。
- en: Next, create a new material using the `plank_wood` texture and apply it to the
    cube.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的材质，使用`plank_wood`纹理，并将其应用到立方体上。
- en: To convert this new wood plank into a physics object, add a **Rigidbody** component.
    Make sure your plank is selected, go to the menu bar of Unity and click on **Component**,
    followed by **Physics**; finally, click on **Rigidbody**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这个新的木板转换为物理对象，请添加一个**Rigidbody**组件。确保选择木板，然后转到Unity的菜单栏，点击**Component**，然后点击**Physics**；最后，点击**Rigidbody**。
- en: We need to keep the plank from moving along the x axis and out of alignment
    with our other physics objects as well as keeping it from rotating to show its
    other sides to the player. To do this, we make use of the **Constraints** group
    of checkboxes on the **Rigidbody** component. Check the checkbox for the **X**
    axis next to **Freeze Position** and the **Y** and **Z** checkboxes next to **Freeze
    Rotation**. These will keep the object from moving in ways we don't want it to.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要防止木板沿着x轴移动，并与我们的其他物理对象对齐，同时防止它旋转以向玩家展示其另一面。为此，我们利用**Rigidbody**组件上的**Constraints**组中的复选框。在**Freeze
    Position**旁边勾选**X**轴的复选框，并在**Freeze Rotation**旁边勾选**Y**和**Z**轴的复选框。这将防止对象以我们不希望的方式移动。
- en: To make the plank function properly within our game, we need to create a new
    script and name it `Plank`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使木板在我们的游戏中正常工作，我们需要创建一个新的脚本，并将其命名为`Plank`。
- en: This script begins with a bunch of variables. The first two are for tracking
    the health of the plank. We need to separate the total amount of health from the
    current health, so we will be able to detect when the object has been reduced
    to half health. At that point, we will make use of our next three variables to
    change the object's material to one that shows damage. The last variable is used
    when the object runs out of health and is destroyed. We will use it to increase
    the player's score.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从一系列变量开始。前两个变量用于跟踪长板的健康状况。我们需要将总健康量与当前健康量分开，这样我们就能检测到对象健康量减少到一半的情况。在那个时刻，我们将利用接下来的三个变量将对象的材料更改为显示损坏的材料。最后一个变量用于对象耗尽健康量并被摧毁时。我们将用它来增加玩家的分数。
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the script's first function, we use `Awake` for initialization. We make
    sure the object's current health is the same as its total health, and we make
    sure the `didSwap` flag is set to `false`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于脚本的第一个函数，我们使用`Awake`进行初始化。我们确保对象的当前健康量与其总健康量相同，并确保`didSwap`标志设置为`false`。
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we make use of the `OnCollisionEnter` function. This is a special function,
    triggered by the **Rigidbody** component, that gives us information about what
    the object collided with and how. We use this information to find `collision.relativeVelocity.magnitude`.
    This is the speed at which the objects collided, and we use it as damage to reduce
    the current health. Next, the function checks to see if the health has been reduced
    to half and calls the `SwapToDamaged` function if it has. By using the `didSwap`
    flag, we make sure the function will only be called once. Finally, for the function,
    it checks to see if the health has dropped below zero. If it has, the object is
    destroyed and we call the `LevelTracker` script, which we will soon be making,
    to add to the player's score.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally for the script, we have the `SwapToDamaged` function. It starts by setting
    the `didSwap` flag to `true`. Next, it checks to make sure the `plankRenderer`
    and `damageMaterial` variables have references to other objects. Ultimately, it
    uses the `plankRenderer.sharedMaterial` value to change to the damaged looking
    material.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before we can add our `Plank` script to our objects, we need to create the `LevelTracker`
    script that was mentioned earlier. Create it now.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script is fairly short and starts with a single variable. The variable
    will track the player's score for the level and is `static` so that it can be
    easily changed as objects are destroyed for points.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we use the `Awake` function to make sure the player starts at zero when
    beginning a level.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally for the script, we add the `AddScore` function. This function simply
    takes the amount of points passed to it and increases the player's score. It is
    also `static`, so that it can be called by any object in the scene without needing
    a reference to the script.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Back in Unity, we need to create a new material using the `plank_wood_damaged`
    texture. This will be the material that the script will swap to.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Plank` script to our `Plank_Wood` object. Connect the **Damaged Material**
    reference to the new material and the **Plank Renderer** reference to the object's
    **Mesh Renderer** component.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we create different types of planks, we can adjust the **Total Health** value
    to give them different strengths. A value of `25` works pretty well for the wood
    planks.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create an empty **GameObject** and rename it `LevelTracker`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `LevelTracker` script to the object and it will begin to track the player's
    score.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to see the wood plank in action, position it above the ground and
    hit the play button. As soon as the game starts, Unity's physics will take over
    and drop the plank with gravity. If it started out high enough, you will be able
    to see it switch textures as it loses health.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the other two planks that we need, select the `Plank_Wood` object and
    press *Ctrl* + *D* twice to duplicate it. Rename one to `Plank_Glass` and the
    other to `Plank_Rubber`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create three new materials. One should be purple for the rubber plank,
    one should use the `plank_glass` texture for the glass plank, and the last material
    should use the `plank_glass_damaged` texture for when the glass plank is damaged.
    Apply the new materials to the proper locations for the new planks.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As for the health of the new planks, a value of `15` for the glass and `100`
    for the rubber will work well.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, turn your three planks into prefabs and use them to build a structure
    for us to knock down. Feel free to scale them to make different-sized blocks,
    but leave the x axis alone. Also, all of the blocks should be positioned at zero
    on the x axis and your structure should be centered around about `30` on the z
    axis.![Time for action – creating planks](img/2014OT_07_02.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the building blocks we needed for the structures that are going to
    be knocked down in our game. We used a **Rigidbody** component to tie them into
    the physics engine. Also, we created a script that keeps track of their health
    and swaps materials when it drops below half.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – creating a stone block
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wood and glass work well as basic blocks. But, if we are going to make harder
    levels, we need something a little stronger. Try your hand at making a stone block.
    Create two textures and materials for it to show its pristine and damaged states.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Physics materials
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Physics materials are special types of materials that specifically tell the
    physics engine how two objects should interact. This does not affect the appearance
    of an object. It defines the friction and bounciness of a collider. We will use
    them to give our rubber plank some bounce and the glass plank some slide.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sliding and bouncing
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Physics materials are quick enough to implement and will allow us to complete
    this section in four short steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Physics materials are created like everything else, in the **Project** panel.
    Right-click inside the **Project** panel and click on **Create** | **Physic Material**.
    Create two physic materials and name one `Glass` and the other `Rubber`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select one of them and take a look at it in the **Inspector** window. Right
    now, we are only concerned with the first three values. The others are used for
    more complex situations.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dynamic Friction**: This property is the amount of friction used when the
    object is moving. A value of zero is no friction, such as ice, and a value of
    one is a lot of friction, such as rubber.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static Friction**: This property functions the same as **Dynamic Friction**,
    the difference being that it is used when the object is not moving.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounciness**: This property is how much of an object''s energy is reflected
    when it hits something or is hit by something. Zero means none of the energy is
    reflected, while a value of one will reflect all of it.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `Glass` material, set the two friction values to `0.1` and **Bounciness**
    to `0`. For the `Rubber` material, set the two friction values to `1` and **Bounciness**
    to `0.8`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select your `Plank_Glass` prefab and take a look at its **Box Collider**
    component. To apply your new physics materials, simply drag-and-drop one from
    the **Project** to the **Material** slot. Do the same for your `Plank_Rubber`
    prefab and, any time an object hits one of them, the materials will be used to
    control their interaction.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a pair of physics materials. They control how two colliders interact
    when they run into each other. Using them, we are given control over the amount
    of friction and bounciness that is possessed by any collider.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Characters
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a bunch of generic blocks is just the beginning of this game. Next, we
    are going to create a few characters to add some life to the game. We are going
    to need some evil pigs to destroy and some good birds to throw at them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The enemy
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first character will be the enemy pig. On their own, they don't actually
    do anything. So, they are really just the wooden blocks we made earlier that happen
    to look like pigs. To make their destruction the goal of the game, however, we
    are going to expand our `LevelTracker` script to watch them and trigger a Game
    Over event if they are all destroyed. We will also expand it to draw the score
    on the screen and make it save the score for later use. To demonstrate the use
    of 2D assets in the 3D environment, the pigs are also created as flat textures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the pigs
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with creating the pigs for the Angry Birds game:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The pigs are created in a manner similar to that of the the wood planks. Start
    by creating an empty **GameObject** and naming it `Pig`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a plane, make it a child of the `Pig` object, and remove its **Mesh
    Collider** component. We do this because of the rotation the plane will need to
    face the camera. Being a child of the empty **GameObject** allows us to ignore
    that rotation when working with the pig.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the plane's local **Position** to `0` on each axis and set its **Rotation**
    to `90` on the **X** axis, `270` on the **Y** axis, and `0` on the **Z** axis.
    This will make the plane face the camera.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create two materials. Name one `Pig_Fresh` and the other `Pig_Damage`.
    From their **Shader** drop-down list, select **Transparent**, followed by **Cutout**,
    and finally **Soft Edge Unlit**. This allows us to make use of the the texture's
    alpha channel and provide some transparency.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish off the materials by adding the `pig_damage` and `pig_fresh` textures
    to them.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the `Pig` object, add a **Sphere Collider** component, a **Rigidbody** component,
    and the `Plank` script. We make use of the **Sphere Collider** component, rather
    than the **Mesh Collider** component the plane came with, because the plane has
    zero thickness and will, therefore, have many issues colliding with other objects.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To complete the pig's creation, apply your material to the plane and connect
    the references in the `Plank` script. Finally, set the **Constraints** parameters
    on the **Rigidbody** component just as we did for the other planks.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, turn the pig into a prefab and add it to your structure. Remember, leave
    them at zero on the x axis, but feel free to adjust their size, health, and score
    values to give them some variety.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to expand the `LevelTracker` script. Open it up and we can add
    some more code.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we add some more variables at the beginning of the script. The first
    one, as its name suggests, will hold a list of all the pigs in our scene. Next
    is a flag for signaling that the game has ended. And finally, a string for telling
    the player why the game has ended.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we need to add a line to the `Awake` function. This simply makes sure
    that the `gameOver` flag is `false` when the level starts.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the `OnGUI` function to draw a Game Over screen when the game has ended,
    or for drawing the current score if it is still continuing.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `DrawScore` function takes the current score and uses `GUI.Label` to draw
    it in the top-right corner of the screen.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `DrawGameOver` function first uses the `GUI.Box` function to draw a dark
    box over the whole of the screen, simultaneously drawing the Game Over message
    on the screen. Next, it draws the player''s final score in the middle of the screen.
    Below that, it draws a button. This button will save the player''s current score
    and load the level-selection screen we will create later. The `Application.LoadLevel`
    function is used to load any other scene in your game. All of the scenes you intend
    to load have to be added to the **Build Settings** window found in the **File**
    menu and can be loaded by using either their name or their index, as used here:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `LateUpdate` function, we call another function to check whether all
    the pigs have been destroyed if the game is not yet over.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we add the `CheckPigs` function. This function loops through the list
    of pigs to see if they are all destroyed. Should it find one that is still around,
    it exits the function. Otherwise, the game is flagged as being over and the message
    is set to tell the player that they succeeded in destroying all of the pigs.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `OutOfBirds` function will be called by the slingshot we are going to create
    later, when the player runs out of birds to launch at the pigs. If the game has
    not yet ended, the function ends the game and sets an appropriate message for
    the player.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we have the `SaveScore` function. Here, we use the `PlayerPrefs` class.
    It lets us easily store and retrieve small amounts of data, perfect for our current
    needs. We just need to provide it with a unique key to save the data under. For
    that, we use a short string combined with the level's index as provided by `Application.loadedLevel`.
    Next, we use `PlayerPrefs.GetInt` to retrieve the last score that was saved. If
    there isn't one, the zero that we passed to the function is returned as a default
    value. Finally, we compare the new score with the old score and use `PlayerPrefs.SetInt`
    to save the new score if it is higher.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Back in Unity, the pigs need to be added to the `LevelTracker` script's list.
    With the `LevelTracker` script selected, drag-and-drop each pig to the `Pigs`
    value in the **Inspector** window to add them.![Time for action – creating the
    pigs](img/2014OT_07_03.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the pigs and updated our `LevelTracker` script to track them. The
    pigs are really just like the planks of wood, but are spheres instead of boxes.
    The updated `LevelTracker` script watches for the instance when all of the pigs
    are destroyed and triggers a Game Over screen when they are. It also handles the
    drawing of the score while the game is being played and the saving of that score
    when the level is over.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The ally
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need something to throw at the pigs and their fortification. Here,
    we will create the simplest of the birds. The red bird is essentially just a rock.
    He has no special powers and nothing particularly special about his code, besides
    health. You will also notice that the bird is a 3D model, giving it the shadows
    that the pigs are missing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the red bird
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with creating the red bird:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Although the red bird model is 3D, it is set up in a manner similar to that
    of the pig. Create an empty **GameObject**, naming it `Bird_Red`, and add the
    appropriate model from the `birds` model as a child, zeroing out its position.
    The model should be rotated to align it along the z axis. If turned a little more
    toward the camera, the player is able to see the bird's face while still giving
    the impression of looking down the field.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, give it a **Sphere Collider** component and a **Rigidbody** component,
    and set the **Constraints** parameters.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to create a new script named `Bird`. This script will be a base
    for all of our birds, tracking their health and triggering their special powers
    when appropriate.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It starts with two variables. The first will keep track of the bird's current
    health. The second is a flag so that the bird will only use its special power
    once. It is marked as `protected` so the class that extends this script can use
    it while keeping it from interference from outside the class.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Update` function does three checks before activating the bird's special
    power. First, it checks whether it has already been done, then whether the screen
    has been touched, and finally whether the bird has a **Rigidbody** component and
    that it is not being controlled by another script.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the case of the red bird, the `DoSpecial` function only sets its flag to
    `true`. It is marked as `virtual` so that we can override the function for the
    other birds and make them do some fancier things.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `OnCollisionEnter` function works just like the one for the planks, subtracting
    health based on the strength of the collision and destroying the bird if it runs
    out of health.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Return to Unity and add the script to the `Bird_Red` object.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the bird's creation by turning it into a prefab and deleting it from
    the scene. The slingshot we will be creating soon will handle the creation of
    the birds when the game starts.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the red bird. It is set up just like our other physics objects. We
    also created a script to handle the bird's health that is expanded later, when
    we create the other birds for our game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Controls
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we are going to give the player the ability to interact with the game.
    First, we will create a slingshot to throw the birds. Following that will be the
    creation of the camera controls. We will even create a nice background effect
    to round out the look of our game.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Attacking
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To attack the pig fortress, we have our basic bird ammo. We need to create a
    slingshot to hurl that ammo at the pigs. It will also handle the spawning of the
    birds at the beginning of the level and automatically reload as birds are used.
    When the slingshot runs out of birds it will notify the `LevelTracker` script
    and the game will end. Finally, we will create a script that will keep the physics
    simulation from going on for too long. We don't want the player forced to sit
    and watch a pig slowly roll across the screen. So, the script will, after a little
    while, start damping the movement of the **Rigidbody** components to make them
    stop rather than keep rolling.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the slingshot
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the slingshot''s appearance will actually be an optical illusion:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: To start off the creation of the slingshot, add the `slingshot` model to the
    scene and position it at the origin. Apply a light brown material to the `Fork`
    model and a dark brown one to the `Pouch` model.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need four empty **GameObject**. Make them all the children of the `Slingshot`
    object.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the first `FocalPoint` and center it between the fork prongs of the slingshot.
    This will be the point through which we fire all of the birds.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is `Pouch`. Make the `pouch` model a child of this object, setting
    its position to `0.5` on the **X** axis and `0` on the **Y** and **Z** axes. This
    will make the pouch appear in front of the current bird without having to make
    a complete pouch model.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Third is `BirdPoint`; this will position the bird that is being fired. Make
    it a child of the `Pouch` point and set its position to `0` on the **X** and **Y**
    axes and `0.3` on the **Z** axis.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Last is `WaitPoint`; the birds waiting to be fired will be positioned behind
    this point. Set its position to `0` for the **X** axis, `0.5` for the **Y** axis,
    and `-4` for the **Z** axis.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, rotate the `Fork` model so that we can see both prongs of the fork. The
    values of `270` for the **X** axis, `25` for the **Y** axis, and `0` for the **Z**
    axis will work well.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Slingshot` script will provide most of the interaction for the player.
    Create it now.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start it with a group of variables. The first will keep a reference to the
    damper that was mentioned earlier. The second group keeps track of the birds that
    will be used in the level. Next is a group of variables that will track the current
    bird that is ready to be fired. Fourth, we have some variables to hold references
    to the points we created a moment ago. The `maxRange` variable is the distance
    from the focal point to which the player can drag the pouch. The last two variables
    define how powerfully the bird will be launched.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As with our other scripts, we use the `Awake` function for initialization. The
    `levelBirds` variable will hold references to all of the `bird` prefabs that will
    be used in the level. We start by creating an instance of each one and storing
    it in the `currentBirds` variable. The `isKinematic` variable is set to `true`
    on each bird's **Rigidbody** so that it does not move when it is not in use. Next,
    it readies the first bird to be fired and, finally, it positions the remaining
    birds behind the `waitPoint`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ReadyNextBird` function first checks to see if we have run out of birds.
    If so, it calls the `LevelTracker` script to trigger the Game Over event. The
    `nextIndex` variable tracks the current location of the birds in the list to fire
    at the player. Next, the function checks to make sure the next slot actually has
    a bird, incrementing the index and trying for a new bird if it does not have one.
    If there is a bird available, it is stored in the `toFireBird` variable and made
    a child of the `BirdPoint` object we created; its position and rotation are zeroed
    out. Finally, the firing and aiming flags are reset.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `SetWaitingPositions` function uses the position of the `waitPoint` to position
    all of the remaining birds behind the slingshot.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Update` function starts by checking to see if the player has fired a bird
    and watches the `rigidbodyDamper.allSleeping` variable to see if all of the physics
    objects have stopped moving. Once they do, the next bird is readied to fire. If
    we have not fired, the aiming flag is checked and the `DoAiming` function is called
    to handle the aiming. If the player is neither aiming nor has just fired a bird,
    we check for touch input and, if the player touches close enough to the focal
    point, we flag that the player has started aiming.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `DoAiming` function checks to see if the player has stopped touching the
    screen and fires the current bird when they have. If they have not, we position
    the pouch at the current touch point. Finally, the pouch's position is limited
    to keep it within the maximum range.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `GetTouchPoint` function uses `ScreenPointToRay` to find out where the player
    is touching in 3D space. This is just as when we were shooting asteroids but,
    because this game is 2D, we can just look at the ray's origin and return it with
    a zero for its x axis value.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, for this script, we have the `FireBird` function. This function starts
    by setting our `didFire` flag to `true`. Next, it finds out the direction to fire
    by finding the direction from the pouch's position to the `focalPoint`. It also
    uses the distance between them to determine the power to fire the bird with, clamping
    it between our min and max strengths. Then, it releases the bird by clearing its
    parent and setting its `isKinematic` flag to `false`. To launch it, we use the
    `rigidbody.AddForce` function and pass the direction multiplied by the power to
    it. `ForceMode.Impulse` is also passed to make the force applied once and immediately.
    Next, the pouch is positioned at the `focalPoint`, as if it were actually under
    tension. And finally, we call `rigidbodyDamper.ReadyDamp` to start the damping
    of the `Rigidbody` movement.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before we can make use of the `Slingshot` script, we need to create the `RigidbodyDamper`
    script.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script starts with six variables. The first two define how long to wait
    before the damping movement and how much to damp it by. The next two track whether
    it can apply the damping and when it will start. Next, is a variable that will
    be filled with a list of all the rigidbodies that are currently in the scene.
    Finally, it has the `allSleeping` flag that will be set to `true` when the movement
    has stopped.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ReadyDamp` function starts by using `FindObjectsOfType` to fill the list
    with all of the rigidbodies. It sets when to start damping as the sum of the current
    time and the wait length. It marks that the script can do its damping and resets
    the `allSleeping` flag. Finally, it uses `StartCoroutine` to call the `CheckSleepingRigidbodies`
    function. This is a special way of calling functions to make them run in the background
    without blocking the rest of the game from running.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `FixedUpdate` function, we first check to see if we can damp the movement
    and whether it is time to do it. If it is, we loop through all of the rigidbodies,
    applying our damp to each one's rotational and linear velocity. Those that are
    kinematic, controlled by scripts, and already sleeping, meaning they stopped moving,
    are skipped.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `CheckSleepingRigidbodies` function is special and will run in the background.
    This is made possible by the `IEnumerator` flag at the beginning of the function
    and the `yield return null` line in the middle. Together, these allow the function
    to pause regularly and keep from freezing the rest of the game while it waits
    for the function to complete. The function starts by creating a check flag and
    using it to check if all of the rigidbodies have stopped moving. If one is found
    still moving, the flag is set to `false` and the function pauses until the next
    frame, when it will try again. When it reaches the end, because all of the rigidbodies
    are sleeping, it sets the `allSleeping` flag to `true`, so that the slingshot
    can ready the next bird. It also stops itself from damping while the player is
    getting ready to fire the next bird.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, we have the `AddBodiesToCheck` function. This function will be used
    by anything that spawns new physics objects after the player has fired the bird.
    It starts by creating a temporary list and expanding the current one. Next, it
    adds all of the values from the temporary list to the expanded one. Finally, the
    list of rigidbodies is added after those of the temporary list.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Return to Unity and add the two scripts to the `Slingshot` object. On the `Slingshot`
    script component, connect the references to the **Rigidbody Damper** component
    and each of the points. Also, add to the **Level Birds** list as many references
    to the red bird as you want for the level.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep objects from rolling back and through the slingshot, create a **Box
    Collider** component and position it at the stock of the `Fork` model.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish off the look of the slingshot, we need to create the elastic bands
    that tie the pouch to the fork. We will do this by first creating the `SlingshotBand`
    script.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script starts with two variables. One for the point that the band will end
    at and one to reference the `LineRenderer` that will draw it.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Awake` function makes sure the `lineRenderer` variable has only two points
    and sets their initial positions.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the `LateUpdate` function, we set the `lineRenderer` variable's end position
    to the `endPoint` value. This point will move around with the pouch, so we need
    to constantly update the renderer.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Return to Unity and create an empty **GameObject**. Name it `Band_Near` and
    make it a child of the `Slingshot` object.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As children of this new point, create a cylinder and a second empty **GameObject**,
    named `Band`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the cylinder a brown material and position it near the prong of the slingshot
    fork.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the `Band` object, add a **Line Renderer** component found under **Effects**
    in the **Component** menu. After positioning it in the center of the cylinder,
    add the `SlingshotBand` script to the object.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the **Line Renderer** under **Materials**, you can put your brown material
    in the slot to color the band. under **Parameters**. Set the **Start Width** to
    `0.5` and the **End width** to `0.2` to set the size of the line.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create one more empty **GameObject** and name it `BandEnd_Near`. Make
    it a child of the `Pouch` object and position it inside the pouch.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, connect the script's references to its line renderer and end point.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the second band, duplicate the four objects we just created and position
    them far from the prong of the fork. The end point for this band can just be moved
    back along the x axis to keep it out of the way of the birds.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, turn the whole thing into a prefab so it can be easily reused in other
    levels.![Time for action – creating the slingshot](img/2014OT_07_04.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the slingshot that will be used to fire birds. We used techniques
    we learned in the previous chapter to handle touch input and track the player's
    finger while they aim and shoot. If you save your scene and position the camera
    to look at the slingshot, you will notice that it is complete if not entirely
    playable. Birds can be fired at the pig fortress, although we can only see the
    destruction from within Unity's **Scene** view.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Watching
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game is technically playable at this point, but it is kind of hard to see
    what is going on. Next, we will create a system to control the camera. It will
    allow the player to drag the camera left and right, follow the bird when it is
    launched and return to the slingshot when everything stops moving. There will
    also be a set of limits to keep the camera from going too far and viewing things
    we do not want the player to see.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – controlling the camera
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will only need one, fairly short script to control and manage our camera:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: To start and to keep everything organized, create a new empty **GameObject**
    and name it `CameraRig`. Also, to keep it simple, set its position to zero on
    each axis.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create three more empty **GameObject** and name them `LeftPoint`, `RightPoint`,
    and `TopPoint`. Set their **X** axis positions to `5`. Position the `LeftPoint`
    to be in front of the slingshot and at `3` on the **Y** axis. The `RightPoint`
    needs to be positioned in front of the `pig` structure you created. The `TopPoint`
    can be over the slingshot, but needs to set to `8` on the **Y** axis. These three
    points will define the limits of where our camera can move when being dragged
    and following birds.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make all three points, and the `Main Camera` object, children of the `CameraRig`
    object.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we create the `CameraControl` script. This script will control all of the
    movement and interaction with the camera.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our variables for this script start with a reference to the slingshot; we need
    this so we can follow the current bird when it is fired. Next are the references
    to the points we just created. The next group of variables control how long the
    camera will sit without input before returning to look at the slingshot and how
    fast it will return. The `dragScale` variable controls how fast the camera actually
    moves when the player drags their finger across the screen, allowing us to keep
    the scene moving with the finger. The last group is to control whether the camera
    can follow the current bird and how fast it can do so.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `Awake` function, we first make certain the camera is not following a
    bird and make it wait before heading to look at the slingshot. This allows us
    to initially point the camera to the pig fortress when the level starts and move
    to the slingshot after giving the player a chance to see what they are up against.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `StartWait` function sets the time when it will start to head back to the
    slingshot and records the position that it is heading back from. This allows us
    to create a smooth transition.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, we have the `Update` function. This one starts by checking whether the
    slingshot has fired. If it hasn't, it checks to see whether the player has started
    aiming, signaling that the bird should be followed and zeroing out the velocity
    if they have. If they have not, the `followBird` flag is cleared. Next, the function
    checks whether it should follow and does so if it should, also calling the `StartWait`
    function in case this is the frame in which the bird is destroyed. If it should
    not follow the bird, it checks for touch input and drags the camera if it finds
    any. The wait is again started in case the player removes their finger in this
    frame. Finally, it checks to see if the slingshot is done firing the current bird
    and if it is time to head back. Should both be true, the camera moves back to
    pointing at the slingshot.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `FollowBird` function starts by making sure there is a bird to follow by
    checking the `toFireBird` variable on the `Slingshot` script and stops following
    if a bird is not found. Should there be a bird, the function then determines a
    new point to move to that will look directly at the bird. It then uses the `Vector3.SmoothDamp`
    function to smoothly follow the bird. This function works similar to a spring—the
    farther away it is from its target position, the faster it moves the object. The
    `followVelocity` variable is used to keep it moving smoothly. Finally, it calls
    another function to limit the camera's position within those bounding points we
    set up earlier.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `DragCamera` function, we use the `deltaPosition` value of the current
    touch to determine how far it has moved since the last frame. By scaling this
    value and subtracting the vector from the camera's position, the function moves
    the camera as the player drags across the screen. This function also calls upon
    the function to clamp the camera's position.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ClampPosition` function starts by taking the camera's current position.
    It then clamps the z position to be between those of the `leftPoint` and `rightPoint`
    variables' `z` positions. Next, the `y` position is clamped between the `leftPoint`
    and `topPoint` variables' positions. Finally, the new position is reapplied to
    the camera's transform.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, we have the `BackToLeft` function. It starts by using the time and
    our duration variable to determine how much progress in returning to the slingshot
    the camera will have made. It records the camera's current position and uses `Mathf.SmoothStep`
    on both the z and y axes to find a new position that is the appropriate distance
    between the `waitPosition` variable and the `leftPoint` variable. Finally, the
    new position is applied.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, return to Unity and add the new script to the `Main Camera` object. Connect
    the references to the slingshot and each of the points to finish it off.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the camera to point at your pig fortress and turn the whole rig into
    a prefab.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the camera rig that will let the player watch all of the action as
    they play the game. The camera will now follow the birds as they are fired from
    the slingshot and can now be dragged by the player. By keying off the positions
    of a few objects, this movement is limited to keep the player from seeing things
    we don't want them to. If the camera is left idle long enough, it will also return
    to look at the slingshot.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – more levels
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have all of the pieces needed to make a complete level, we need
    some more levels. We need at least two more levels. You can use the blocks and
    pigs to create any level you might want. It is a good idea to keep the pig structures
    centered at about `30` on the **Z** axis. Also, think about the difficulty of
    the level while making it, so that you can end up with an easy, medium, and hard
    level.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: A better background
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great feature of many 2D games is a parallax scrolling background. This simply
    means that the background is created in layers that scroll by at different speeds.
    Think of it as if looking out the window of your car. The objects that are far
    away appear to hardly move, while the ones that are near move by quickly. In a
    2D game, it gives the illusion of depth and adds a nice touch to the look of the
    game. For this background, we will be layering several materials on a single plane.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the parallax background
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an alternative method of creating and utilizing a second camera, but
    ours will make use of a single script that additionally allows us to control the
    speed of each layer:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We will start this section with the creation of the `ParallaxScroll` script.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script starts with three variables. The first two keep track of each material
    and how fast they should scroll. The third keeps track of the camera's last position,
    so we can track how far it moves in each frame.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the `Start` function, we record the camera's beginning position. We use `Start`
    instead of `Awake` here, in case the camera needs to do any special movement at
    the beginning of the game.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Next, we use the `LateUpdate` function to make changes after the camera has
    moved about. It starts by finding the camera's new position and comparing the
    z axis values to determine how far it moved. Next, it loops through the list of
    materials. The loop first gathers the current offset of its texture using `mainTextureOffset`.
    Next, the camera's movement multiplied by the material's speed is subtracted from
    the offset's x axis to find a new horizontal position. Then, the new offset is
    applied to the material. Finally, the function records the camera's last position
    for the next frame.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Return to Unity and create six new materials. One for each of the background
    textures: `sky`, `hills_tall`, `hills_short`, `grass_light`, `grass_dark`, and
    `fronds`. All of the materials, except for the sky, need to use the **Diffuse**
    shader under **Transparent** in the **Shader** drop-down list. If they do not,
    we will not be able to see all of the textures when they are layered.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to adjust the **Tiling** of each of these new materials. For all
    of them, leave the **Y** axis as `1`. For the **X** axis, set `5` for the `sky`,
    `6` for `hills_tall`, `7` for `hills_short`, `8` for `grass_dark`, `9` for `fronds`,
    and `10` for `grass_light`. This will offset all of the features of the textures
    so a long pan does not see features regularly lining up.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a new plane. Name it `Background` and remove its **Mesh Collider**
    component.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position it at `-5` on the **X** axis, `7` on the **Y** axis, and `30` on the
    **Z** axis. Set its rotation to `90` for both the **X** and **Y** axes and `0`
    for **Z**. Also, set the scale to `10` for the **X** axis, `1` for the **Y** axis,
    and `1.5` for the **Z** axis. Altogether, these position the plane as facing the
    camera and filling the background.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the plane's **Mesh Renderer** component, expand the **Materials** list and
    set the **Size** to `6`. Add each of our new materials to the list slots in the
    order of `sky`, `hills_tall`, `hills_short`, `grass_dark`, `fronds`, `grass_light`.
    Do the same for the **Materials** list in the **Parallax Scroll** script component.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the **Parallax Scroll** script component, set the **Size** of the
    **Speeds** list to `6` and input the following values in the order of `0.03`,
    `0.024`, `0.018`, `0.012`, `0.006`, `0`. These values will move the materials
    gently and evenly.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turning the background into a prefab, at this point, will make it easy to reuse
    later.![Time for action – creating the parallax background](img/2014OT_07_05.jpg)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a parallax scroll effect. This effect will pan a series of background
    textures, giving the illusion of depth in our 2D game. To easily see it in action,
    hit play and grab the camera in the **Scene** view, moving it along the z axis
    to see the background change.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – dark of the night
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have two other levels to add backgrounds to. Your challenge here is to create
    your own background. Use the techniques you learned in this section to create
    a night-style background. It could include a stationary moon while everything
    else scrolls in the shot. For an added trick, create a cloud layer that slowly
    pans across the screen as well as with the camera and the rest of the background.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The flock variety
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one last set of assets we need to create for our levels, the other
    birds. We will create three more birds that each have a unique special ability:
    a yellow bird that accelerates, a blue bird that splits into multiple birds, and
    a black bird that explodes. With these our flock will be complete.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: To make the creation of these birds easier, we will be making use of a concept
    called **inheritance**. Inheritance allows a script to expand upon the functions
    it is inheriting without the need to rewrite them. If used correctly, this can
    be very powerful and, in our case, will aid in the quick creation of multiple
    characters that are largely similar.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The yellow bird
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will create the yellow bird. Largely, this bird functions exactly
    as the red bird. However, when the player touches the screen, the bird's speed
    increases. By extending the `Bird` script that we created earlier, this bird's
    creation becomes quite simple.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the yellow bird
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because of the power of inheritance, the script we are creating here consists
    of only a handful of lines of code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating the yellow bird in the same way as the red bird, using the
    `YellowBird` model instead.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of using the `Bird` script, we will create the `YellowBird` script.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script needs to extend the `Bird` script, so replace `MonoBehaviour` with
    `Bird` on line four. It should look similar to the following code snippet:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This script adds a single variable that will be used to multiply the bird's
    current velocity.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we override the `DoSpecial` function and multiply the bird''s `rigidbody.velocity`
    when it is called:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Return to Unity, add the script to your new bird, and turn it into a prefab.
    Add some to the list on your slingshot to use the bird in your level.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the yellow bird. This bird is simple. It directly modifies its velocity
    to suddenly gain a boost of speed when the player touches the screen. As you will
    soon see, we use this same style of script creation to create all of our birds.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The blue bird
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we create the blue bird. This bird splits into three birds when the player
    touches the screen. It will also extend the `Bird` script.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the blue bird
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The blue bird will again make use of inheritance, reducing the amount of code
    that needs to be written to create the bird:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色鸟将再次利用继承，减少创建鸟时需要编写的代码量：
- en: Again, start building your blue bird the same way as the previous two, substituting
    the appropriate model. You should also adjust the **Radius** of the **Sphere Collider**
    component to align appropriately with the smaller size of this bird.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，以与前面两个相同的方式开始构建你的蓝色鸟，替换适当的模型。你还应该调整**Sphere Collider**组件的**Radius**，以便与这只鸟较小的尺寸相匹配。
- en: Next, we create the `BlueBird` script.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`BlueBird`脚本。
- en: Again, adjust line four so the script extends `Bird` instead of `MonoBehaviour`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调整第四行，使脚本扩展到`Bird`而不是`MonoBehaviour`。
- en: '[PRE51]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This script has three variables. The first is a list of prefabs to spawn when
    the bird splits. Next is the angle difference between each new bird that will
    be launched. Finally is a value to spawn the birds a little ahead of their current
    position to keep them from getting stuck inside each other.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本有三个变量。第一个是在鸟分裂时生成预制体的列表。接下来是每个新发射的鸟之间的角度差。最后是一个值，用于在当前位置前方生成鸟，以防止它们互相卡住。
- en: '[PRE52]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, we override the `DoSpecial` function and start, as with the others, by
    marking that we made our special move. Next, it calculates half of the number
    of birds to spawn and creates an empty list for storing the rigidbodies of the
    newly spawned birds.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重写`DoSpecial`函数，并像其他人一样，标记我们已经做出了特殊动作。接下来，它计算要生成的鸟的数量的一半，并为存储新生成的鸟的刚体创建一个空列表。
- en: '[PRE53]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The function continues by looping through the list of birds, skipping the slots
    that are empty. It spawns the new birds at its position, continuing to the next
    if there is a missing **Rigidbody** component. The new **Rigidbody** component
    is then stored in the list.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数继续通过鸟的列表进行循环，跳过空槽位。它在当前位置生成新鸟，如果缺少**Rigidbody**组件，则继续到下一个。然后，新的**Rigidbody**组件被存储在列表中。
- en: '[PRE54]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using `Quaternion.Euler`, a new rotation is created that will angle the new
    bird along a path split off from the main path. The new bird's velocity is set
    to the rotated velocity of the current bird. It is then moved forward along its
    new path to get out of the way of the other birds being spawned.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Quaternion.Euler`创建一个新的旋转，这将使新鸟沿着从主路径分叉的路径旋转。新鸟的速度被设置为当前鸟旋转后的速度。然后它沿着新路径向前移动，以避开正在生成的其他鸟。
- en: '[PRE55]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After the loop, the function uses `FindObjectOfType` to find the slingshot that
    is currently in the scene. If found, it is changed to track the first new bird
    spawned as the one that was fired. The new list of rigidbodies is also set to
    the `rigidbodyDamper` variable to be added to its list of rigidbodies. Finally,
    the script destroys the bird it is attached to, completing the illusion that the
    bird has split apart.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，函数使用`FindObjectOfType`在场景中找到当前存在的弹弓。如果找到，它将改变以跟踪第一个新生成的鸟作为被发射的鸟。新的刚体列表也被设置为`rigidbodyDamper`变量，以便添加到其刚体列表中。最后，脚本销毁其附加的鸟，完成鸟分裂的幻觉。
- en: '[PRE56]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Before you add the script to your new bird, we actually need two blue birds:
    one that splits and one that does not. Duplicate your bird and name one `Bird_Blue_Split`
    and the other `Bird_Blue_Normal`. To the split bird add the new script and to
    the normal bird add the `Bird` script.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将脚本添加到你的新鸟之前，我们实际上需要两只蓝色鸟：一只负责分裂，另一只不分裂。复制你的鸟，将一个命名为`Bird_Blue_Split`，另一个命名为`Bird_Blue_Normal`。将新脚本添加到分裂的鸟上，将`Bird`脚本添加到正常的鸟上。
- en: Turn both birds into prefabs and add the normal bird to the other's list of
    birds to be split into.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两只鸟都转换为预制体，并将正常的鸟添加到另一只鸟的分裂鸟列表中。
- en: '*What just happened?*'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the blue bird. This bird splits into multiple birds when the user
    taps the screen. The effect actually requires two birds that look identical. One
    that does the splitting and another that is split into but does nothing special.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了蓝色鸟。当用户点击屏幕时，这只鸟会分裂成多只鸟。实际上，这个效果需要两只看起来完全相同的鸟。一只负责分裂，另一只被分裂但没有任何特殊动作。
- en: Have a go hero – creating a rainbow bird
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——创建彩虹鸟
- en: It is actually possible to add anything we want to spawn to the blue bird's
    list of things to split into. Your challenge here is to create a rainbow bird.
    This bird could split into different types of birds, not just blue ones. Or, perhaps
    it is a stone bird that splits into stone blocks. For an extended challenge, create
    a mystery bird that picks a bird from its list randomly when it splits.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The black bird
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we have the black bird. This bird explodes when the player touches
    the screen. As with all the birds discussed previously, it will extend the `Bird`
    script.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the black bird
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the two birds discussed earlier, inheriting from the red bird makes
    the black bird''s creation much easier:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: As with the others, this bird is initially created in the same way as the red
    bird, readjusting the **Radius** for its increased size.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, we create a new script to extend the `Bird` script. This time it is called
    `BlackBird`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not forget to adjust line four to extend the `Bird` script and not `MonoBehaviour`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This script has two variables. The first is the size of the explosion and the
    second is its strength.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Once more we override the `DoSpecial` function, first marking that we did it.
    Next, we use `Physics.OverlapSphere` to acquire a list of all of the objects that
    are within the range of the bird's explosion. The function then loops through
    the list, skipping any empty slots and those without rigidbodies. If the object
    does exist and has a **Rigidbody** component attached, we call `AddExplosionForce`
    to simulate the way an explosion's strength against you is reduced the further
    you are from it. We give the function the explosion's strength, followed by the
    bird's position and radius. The value `3` is a vertical modifier. It does not
    interfere with the distance an object is from the explosion but, instead, adjusts
    the angle the explosion hits it at. This `3` moves the force to below the object,
    because explosions that throw debris up are cooler than ones that push out. `ForceMode.Impulse`
    is again used to apply the force immediately. Finally, the function destroys the
    exploded bird.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As with the last two, apply your new script to your new bird and turn it into
    a prefab. You now have four birds to choose from when selecting the slingshot
    arsenal for each level.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created our fourth and last bird, the black bird. This bird explodes when
    the user touches the screen, throwing anything that might be near into the sky.
    This can be a fun bird to play around with and effective for destroying your pig
    forts.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – explosive blocks
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to cause explosions, we have another challenge. Create
    an explosive crate. Extend the `Plank` script to make it. When enough damage is
    done to the crate, trigger the explosion. For an added challenge, instead of making
    the crate explode, configure it to throw out a few bombs that explode when they
    hit something.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Have a go hero – explosive blocks](img/2014OT_07_06.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: Level selection
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we need to create our level selection. From this scene, we will be
    able to access and start playing all of the levels we created earlier. We will
    also display the current high scores for each level.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the level selection
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new scene and a single script will serve us well in managing our level selection:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: This last section begins by saving your current scene and hitting *Ctrl* + *N*
    to create a new one, named `LevelSelect`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this scene, we need to create a single, short script also named `LevelSelect`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first and only variable defines the size of the buttons that will appear
    on screen.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The only function is the `OnGUI` function. This function starts with a loop.
    It will loop through three times for the three levels we should have created earlier.
    A `Rect` variable is created and initialized to the `buttonSize`. The x and y
    values are then set to position the buttons in a row, centered on the screen.
    Next, the current high score for the level is retrieved, using `PlayerPrefs.GetInt`
    and the same key creation that we used in our `LevelTracker` script. Then, the
    function creates a string to hold the message that will appear on the button.
    Finally, the button is drawn and, when clicked, `Application.LoadLevel` is used
    to load the scene and start the user playing that level.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Return to Unity and add the script to the `Main Camera` object.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, open the **Build Settings** and add your scenes to the **Scenes in
    Build** list. Clicking and dragging on the scenes in the list will let you reorder
    them. Make sure your **LevelSelect** scene is first and has the index of zero
    to the right of it. The rest of your scenes can appear in whatever order you desire.
    But be aware that they will be associated with the buttons in the same order.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a level-selection screen. It uses a loop to create a list of buttons
    associated with the levels in our game. When a button is pressed, `Application.LoadLevel`
    starts that level. We also made use of `PlayerPrefs.GetInt` to retrieve the high
    scores for each of the levels.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding some style
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, the challenge is to use GUI styles to make the screen look great. A logo
    and a background would help a lot. Additionally, take a look at `GUI.BeginScrollView`
    if you have more than three levels. This function will let the user scroll through
    a list of levels that is far greater in size than can be easily seen on screen.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about physics in Unity and recreated the incredibly
    popular mobile game, Angry Birds. By using Unity's physics system, we are able
    to make all of the levels that we could ever want to play. With this game, we
    also explored options for creating a 2D game in a 3D environment. Our birds and
    slingshot are 3D assets, giving us the ability to light and shade them. The pigs
    and the background, however, are 2D images, reducing our lighting options, but
    can allow for some greater detail in the assets. The 2D images were also crucial
    in the creation of the parallax scrolling effect of the background. Finally, the
    building's blocks appear to be 2D, but are actually 3D blocks. We also created
    a level-selection screen. From there, the player can see their high scores and
    pick any of the levels that we created to play.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在Unity中使用物理知识，并重新制作了广受欢迎的移动游戏《愤怒的小鸟》。通过使用Unity的物理系统，我们能够制作出我们想要玩的所有关卡。在这个游戏中，我们还探索了在3D环境中创建2D游戏的可能性。我们的鸟和弹弓是3D资产，这使得我们能够对它们进行光照和阴影处理。然而，猪和背景是2D图像，这减少了我们的光照选项，但可以在资产中提供一些更详细的细节。2D图像在创建背景的视差滚动效果中也至关重要。最后，建筑块看起来是2D的，但实际上是3D块。我们还创建了一个关卡选择屏幕。从那里，玩家可以看到他们的高分，并选择我们创建的任何关卡来玩。
- en: In the next chapter, we return to the Space Fighter game we started in the previous
    chapter. We are going to create and add all of the special effects that finish
    off a game. We will add the shooting and explosion sound effects that every space
    game needs. We will also add various particle effects. When ships are shot at,
    they will actually explode, rather than just disappearing.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到上一章开始的空间战斗机游戏。我们将创建并添加所有完成游戏的特殊效果。我们将添加每个太空游戏都需要的开火和爆炸音效。我们还将添加各种粒子效果。当船只被射击时，它们实际上会爆炸，而不仅仅是消失。
