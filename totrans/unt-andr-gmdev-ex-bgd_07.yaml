- en: Chapter 7. Throwing Your Weight Around – Physics and a 2D Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 摆脱重量 - 物理和2D相机
- en: '*In the previous chapter, we learned about the special features of a mobile
    device and how to create touch and tilt controls. We also created a Space Fighter
    game to use these new controls. The steering of the ship was done by tilting the
    device and shooting by touching the screen. Using some special movement tricks,
    we gave the player an infinite amount of space to fly and enemies to fight.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们学习了移动设备的特殊功能以及如何创建触摸和倾斜控制。我们还创建了一个太空战斗机游戏来使用这些新控制。飞船的操控是通过倾斜设备，而射击是通过触摸屏幕完成的。使用一些特殊的移动技巧，我们给了玩家无限的飞行空间和敌人来战斗。*'
- en: '*In this chapter, we take a short break from the Space Fighter game to explore
    Unity''s physics engine. We will also take a look at options for creating a 2D
    game experience. To do all of this, we will be recreating one of the most popular
    mobile games on the market, Angry Birds. We will use physics to throw birds and
    destroy structures. We will also take a look at the creation of a level-selection
    screen.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们暂时从太空战斗机游戏中休息一下，来探索Unity的物理引擎。我们还将查看创建2D游戏体验的选项。为了完成所有这些，我们将重新创建市场上最受欢迎的移动游戏之一，愤怒的小鸟。我们将使用物理来投掷小鸟并摧毁结构。我们还将查看创建级别选择屏幕的过程。*'
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Unity Physics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity物理
- en: Parallax scrolling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直滚动
- en: Isometric camera
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等距相机
- en: Level selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别选择
- en: We will be creating a new project for this chapter, so start up Unity and let's
    begin!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本章创建一个新项目，所以启动Unity，让我们开始吧！
- en: 2D games in a 3D world
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D世界中的2D游戏
- en: Perhaps the most underrealized thing when developing games is the fact that
    it's possible to create 2D-style games in a 3D game engine such as Unity. As with
    everything else, it comes with its own set of advantages and disadvantages, but
    the choice can be well worth it for generating a pleasing game experience. The
    foremost of the advantages is that one can use 3D assets for the game. This allows
    dynamic lighting and shadows to be easily included. However, if using a 2D engine,
    any shadow would need to be painted directly into the assets and you would be
    hard-pressed to make it dynamic. On the disadvantage side is the use of 2D assets
    in the 3D world. It is completely possible to use them, but large file sizes become
    necessary to achieve the desired detail and keep it from appearing pixelated.
    Most 2D engines, however, make use of vector art that will keep the image's lines
    smooth as it is scaled up and down. Also, one is able to use normal animations
    for the 3D assets, but frame-by-frame animation is generally required for any
    2D asset. Altogether, the advantages have outweighed the disadvantages for many
    developers, creating a large selection of great looking 2D games that you may
    never realize were actually made in a 3D game engine. Now, we shall design another
    game by recreating the highly popular Angry Birds.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发游戏时，可能最未被充分认识到的一点是，在像Unity这样的3D游戏引擎中可以创建2D风格的游戏。与其他事物一样，它有其自身的优点和缺点，但为了生成令人愉悦的游戏体验，这种选择可能是值得的。最主要的优点是，可以为游戏使用3D资源。这允许动态光照和阴影轻松地被包含在内。然而，如果使用2D引擎，任何阴影都需要直接绘制到资源中，而且很难使其动态化。在缺点方面，2D资源在3D世界中的使用。完全有可能使用它们，但为了达到所需的细节并避免出现像素化，需要大文件大小。然而，大多数2D引擎都使用矢量艺术，这将在图像缩放和缩小时会保持线条平滑。此外，可以使用正常动画为3D资源，但对于任何2D资源通常需要逐帧动画。总的来说，对于许多开发者来说，优点已经超过了缺点，创造出了大量外观出色的2D游戏，你可能从未意识到这些游戏实际上是在3D游戏引擎中制作的。现在，我们将通过重新创建广受欢迎的愤怒的小鸟游戏来设计另一款游戏。
- en: Time for action – preparing the world
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 准备世界
- en: 'Let''s get started with preparing the world for the Angry Birds game:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为愤怒的小鸟游戏准备世界：
- en: To start it all off, we need to create a new project in Unity. Naming it `Ch7_AngryBirds`
    will work well. Be sure to change the target platform to **Android** and set the
    **Bundle Identifier** to an appropriate value.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始这一切，我们需要在Unity中创建一个新项目。将其命名为`Ch7_AngryBirds`将是一个不错的选择。确保将目标平台更改为**Android**，并将**包标识符**设置为适当的值。
- en: Next, import the starting assets for this chapter and create some folders to
    keep everything organized.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导入本章的起始资源并创建一些文件夹以保持一切井然有序。
- en: In Unity, it is very easy to turn a game from 3D to 2D. Simply select the **Main
    Camera** object that is by default present in every new scene, find the **Projection**
    value, and select **Orthographic** from the drop-down list.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，将游戏从3D转换为2D非常简单。只需选择默认存在于每个新场景中的**主摄像头**对象，找到**投影**值，然后从下拉列表中选择**正交**。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Every camera has two options for how to render the game. **Perspective** renders
    everything utilizing the distance from the camera, imitating the real world; objects
    that are farther away from the camera are drawn smaller than objects that are
    closer. **Orthographic** renders everything without this consideration; objects
    are not scaled based on their distance from the camera.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个摄像头都有两种渲染游戏的方式。**透视**渲染利用摄像头与物体之间的距离，模仿现实世界；距离摄像头较远的物体比距离较近的物体绘制得小。**正交**渲染不考虑这一点；物体不会根据其与摄像头的距离进行缩放。
- en: Initially, the amount of the scene that the camera views is far too large. To
    change this, set the **Size** value to `5`. This reduces the amount of space the
    camera will render. This value will keep us focused on the action as the game
    is played.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，摄像头所看到的场景范围过大。要改变这一点，将**大小**值设置为`5`。这将减少摄像头渲染的空间量。这个值将帮助我们专注于游戏中的动作。
- en: To make the camera properly usable, set its **Position** to `10` for the **X**
    axis, `3` for the **Y** axis, and `0` for the **Z** axis. Also, set its **Rotation**
    for the **Y** axis to `-90`. Everything is going to be positioned along the z
    axis, so our camera needs to be set to watch the axis and be far away enough so
    that it is not in the action.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使摄像头能够正确使用，将其**位置**设置为**X**轴的`10`，**Y**轴的`3`，**Z**轴的`0`。此外，将其**旋转**的**Y**轴设置为`-90`。所有东西都将沿着z轴定位，因此我们的摄像头需要设置为观察轴，并且足够远，以便它不在动作中。
- en: Next, we are going to need a ground. So, go to the menu bar of Unity and click
    on **GameObject**, followed by **Create Other**, and finally, click on **Cube**.
    This will suit well enough as a simple ground.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个地面。因此，前往Unity的菜单栏，点击**GameObject**，然后点击**Create Other**，最后点击**Cube**。这足以作为一个简单的地面。
- en: To make it look a little like a ground, create a green material and apply it
    to the **Cube**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让它看起来更像地面，创建一个绿色材质并将其应用到**Cube**上。
- en: The ground cube needs to be large enough to cover the whole of our field of
    play. To do this, set its **Scale** to `5` for the **X** axis, `10` for the **Y**
    axis, and `100` for the **Z** axis. Also, set its **Position** to `0` for the
    **X** and **Y** axes, and `30` for the **Z** axis. Since nothing will be moving
    along the x axis, the ground only needs to be large enough for the other objects
    that will be in our scene to land on. It does, however, need to be wide and tall
    enough to keep the camera from seeing the edges.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地面立方体需要足够大，以覆盖我们的整个游戏区域。为此，将其**缩放**设置为**X**轴的`5`，**Y**轴的`10`，**Z**轴的`100`。此外，将其**位置**设置为**X**和**Y**轴的`0`，**Z**轴的`30`。由于x轴上没有物体移动，地面只需要足够大，以便其他将在场景中的物体可以着陆。然而，它确实需要足够宽和高，以防止摄像头看到边缘。
- en: Right now, the ground looks rather dark due to the lack of light. From the menu
    bar of Unity, click on **GameObject**, followed by **Create Other**, and lastly
    click on **Directional Light** to add some brightness to the scene. It should
    be positioned to shine on the side of the cube that faces the camera.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，由于缺乏光源，地面看起来相当暗。从Unity的菜单栏点击**GameObject**，然后点击**Create Other**，最后点击**Directional
    Light**来为场景增加一些亮度。它应该被放置在照亮面对摄像头的立方体侧面的位置。
- en: Next, we need to keep all of the objects that will be flying around the scene
    from straying too far and causing problems. To do this, we need to create some
    trigger volumes. The simplest way to do this is to create three more cubes. Position
    one at each end of the ground object and the last cube at about 50 units above.
    Then, scale them to form a box with the ground. Each should be no thicker than
    a single unit, and they need to be five units deep, the same as the ground. Next,
    remove their **Mesh Renderer** and **Mesh Filter** components. This removes the
    visible box, while leaving the collider volume. To change them to trigger volumes,
    check the **Is Trigger** checkbox on each **Box Collider** component.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要防止场景中所有将要飞行的对象跑得太远并造成问题。为此，我们需要创建一些触发体积。最简单的方法是创建三个更多的立方体。将一个放置在地面对象的每个末端，最后一个立方体大约在50个单位的高度。然后，调整它们以形成一个与地面相同的盒子。每个立方体应该没有比单个单位更厚，并且它们需要深入五单位，与地面相同。接下来，移除它们的**Mesh
    Renderer**和**Mesh Filter**组件。这将移除可见的盒子，同时留下碰撞体积。要将它们更改为触发体积，请在每个**Box Collider**组件上勾选**Is
    Trigger**复选框。
- en: To make the volumes actually keep objects from straying too far, we need to
    create a new script. Create it and name it `GoneTooFar`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使体积实际上阻止对象跑得太远，我们需要创建一个新的脚本。创建它并将其命名为`GoneTooFar`。
- en: This script has a single, short function, `OnTriggerEnter`. We use it to destroy
    any object that might enter the volume. This function is used by Unity's physics
    system to detect when an object has entered a trigger volume. We will go into
    more detail later but, for now, know that one of the two objects, either the volume
    or the object entering it, needs a **Rigidbody** component. In our case, everything
    we might want to remove when they enter the trigger will have a **Rigidbody**
    component.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本有一个单一、简短的功能，`OnTriggerEnter`。我们使用它来销毁可能进入体积的任何对象。此函数由Unity的物理系统用于检测对象何时进入触发体积。我们将在稍后详细介绍，但在此阶段，要知道两个对象中的一个是体积或进入它的对象，需要有一个**Rigidbody**组件。在我们的情况下，当它们进入触发体积时，我们可能想要移除的所有内容都将有一个**Rigidbody**组件。
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finally, return to Unity and add the script to the three trigger-volume objects.![Time
    for action – preparing the world](img/2014OT_07_01.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回Unity并将脚本添加到三个触发体积对象上。![行动时间 - 准备世界](img/2014OT_07_01.jpg)
- en: '*What just happened?*'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We did the initial setup for our 2D game. By changing our camera view to **Orthographic**,
    the view switches from a 3D game to a 2D one. We also created a ground and some
    trigger volumes for our scene. Together, these will keep our birds and anything
    else from straying too far.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的2D游戏完成了初始设置。通过将我们的摄像机视图更改为**Orthographic**，视图从3D游戏切换到2D游戏。我们还为场景创建了一个地面和一些触发体积。这些一起将防止我们的鸟和其他任何东西跑得太远。
- en: Physics
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理
- en: In Unity, physics simulation primarily focuses on the use of the **Rigidbody**
    component. When the **Rigidbody** component is attached to any object, it will
    be taken over by the physics engine. The object will fall with gravity and bump
    into any object that has a collider. In our scripts, making use of the `OnCollision`
    function and the `OnTrigger` function requires a **Rigidbody** component to be
    attached to at least one of the two interacting objects. However, a **Rigidbody**
    component can interfere with any specific movement we might cause the object to
    take. Every **Rigidbody**, though, can be marked as kinematic, meaning the physics
    engine will not move it. The **CharacterController** component that we used for
    our tank is a special, modified **Rigidbody**. In this chapter, we will be making
    heavy use of the **Rigidbody** component to tie all of our birds, blocks, and
    pigs into the physics engine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，物理模拟主要关注使用**Rigidbody**组件。当**Rigidbody**组件附加到任何对象上时，它将被物理引擎接管。该对象将在重力作用下下落，并撞击任何具有碰撞器的对象。在我们的脚本中，要使用`OnCollision`函数和`OnTrigger`函数，至少需要将**Rigidbody**组件附加到两个交互对象中的至少一个上。然而，**Rigidbody**组件可能会干扰我们可能使对象采取的任何特定运动。不过，每个**Rigidbody**都可以标记为运动学，这意味着物理引擎不会移动它。我们用于坦克的**CharacterController**组件是一个特殊、修改过的**Rigidbody**。在本章中，我们将大量使用**Rigidbody**组件，将所有的鸟、方块和猪与物理引擎联系起来。
- en: Building blocks
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构成要素
- en: 'For our first physics objects, we will create the blocks that the pig castles
    are built out of. We will be creating three types of blocks: wood, glass, and
    rubber. With these few simple blocks, we will be able to easily create a large
    variety of levels and structures to smash with birds.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个物理对象，我们将创建猪城堡所用的块。我们将创建三种类型的块：木头、玻璃和橡胶。凭借这些简单的块，我们将能够轻松地创建大量不同级别和结构，供小鸟摧毁。
- en: Time for action – creating planks
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——创建木板
- en: 'Each of the blocks we will be creating will be largely similar:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的每个块都将非常相似：
- en: First, we will create the plank of wood. To do this, we need another cube. Rename
    it `Plank_Wood`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一块木板。为此，我们需要另一个立方体。将其重命名为`Plank_Wood`。
- en: Set the plank's **Scale** to `2` for the **X** and **Y** axes, and `0.25` for
    the **Z** axis. Its scale on the y and z axis define its size as seen by the player.
    The scale on the x axis makes sure that it will be hit by other physics objects
    in the scene.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将木板的**Scale**设置为**X**和**Y**轴为`2`，**Z**轴为`0.25`。它在y和z轴上的缩放定义了玩家看到的尺寸。x轴上的缩放确保它将被场景中的其他物理对象击中。
- en: Next, create a new material using the `plank_wood` texture and apply it to the
    cube.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的材质，使用`plank_wood`纹理，并将其应用到立方体上。
- en: To convert this new wood plank into a physics object, add a **Rigidbody** component.
    Make sure your plank is selected, go to the menu bar of Unity and click on **Component**,
    followed by **Physics**; finally, click on **Rigidbody**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这个新的木板转换为物理对象，请添加一个**Rigidbody**组件。确保选择木板，然后转到Unity的菜单栏，点击**Component**，然后点击**Physics**；最后，点击**Rigidbody**。
- en: We need to keep the plank from moving along the x axis and out of alignment
    with our other physics objects as well as keeping it from rotating to show its
    other sides to the player. To do this, we make use of the **Constraints** group
    of checkboxes on the **Rigidbody** component. Check the checkbox for the **X**
    axis next to **Freeze Position** and the **Y** and **Z** checkboxes next to **Freeze
    Rotation**. These will keep the object from moving in ways we don't want it to.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要防止木板沿着x轴移动，并与我们的其他物理对象对齐，同时防止它旋转以向玩家展示其另一面。为此，我们利用**Rigidbody**组件上的**Constraints**组中的复选框。在**Freeze
    Position**旁边勾选**X**轴的复选框，并在**Freeze Rotation**旁边勾选**Y**和**Z**轴的复选框。这将防止对象以我们不希望的方式移动。
- en: To make the plank function properly within our game, we need to create a new
    script and name it `Plank`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使木板在我们的游戏中正常工作，我们需要创建一个新的脚本，并将其命名为`Plank`。
- en: This script begins with a bunch of variables. The first two are for tracking
    the health of the plank. We need to separate the total amount of health from the
    current health, so we will be able to detect when the object has been reduced
    to half health. At that point, we will make use of our next three variables to
    change the object's material to one that shows damage. The last variable is used
    when the object runs out of health and is destroyed. We will use it to increase
    the player's score.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从一系列变量开始。前两个变量用于跟踪长板的健康状况。我们需要将总健康量与当前健康量分开，这样我们就能检测到对象健康量减少到一半的情况。在那个时刻，我们将利用接下来的三个变量将对象的材料更改为显示损坏的材料。最后一个变量用于对象耗尽健康量并被摧毁时。我们将用它来增加玩家的分数。
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the script's first function, we use `Awake` for initialization. We make
    sure the object's current health is the same as its total health, and we make
    sure the `didSwap` flag is set to `false`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于脚本的第一个函数，我们使用`Awake`进行初始化。我们确保对象的当前健康量与其总健康量相同，并确保`didSwap`标志设置为`false`。
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we make use of the `OnCollisionEnter` function. This is a special function,
    triggered by the **Rigidbody** component, that gives us information about what
    the object collided with and how. We use this information to find `collision.relativeVelocity.magnitude`.
    This is the speed at which the objects collided, and we use it as damage to reduce
    the current health. Next, the function checks to see if the health has been reduced
    to half and calls the `SwapToDamaged` function if it has. By using the `didSwap`
    flag, we make sure the function will only be called once. Finally, for the function,
    it checks to see if the health has dropped below zero. If it has, the object is
    destroyed and we call the `LevelTracker` script, which we will soon be making,
    to add to the player's score.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们利用 `OnCollisionEnter` 函数。这是一个特殊的函数，由 **Rigidbody** 组件触发，它提供了关于物体碰撞了什么以及如何碰撞的信息。我们使用这些信息来找到
    `collision.relativeVelocity.magnitude`。这是物体碰撞的速度，我们将其用作伤害来减少当前的健康值。接下来，函数检查健康值是否减少到一半，如果已经减少，则调用
    `SwapToDamaged` 函数。通过使用 `didSwap` 标志，我们确保函数只会被调用一次。最后，对于该函数，它检查健康值是否下降到零以下。如果是，则销毁对象，并调用我们即将制作的
    `LevelTracker` 脚本，以增加玩家的得分。
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally for the script, we have the `SwapToDamaged` function. It starts by setting
    the `didSwap` flag to `true`. Next, it checks to make sure the `plankRenderer`
    and `damageMaterial` variables have references to other objects. Ultimately, it
    uses the `plankRenderer.sharedMaterial` value to change to the damaged looking
    material.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于脚本，我们有 `SwapToDamaged` 函数。它首先将 `didSwap` 标志设置为 `true`。接下来，它检查确保 `plankRenderer`
    和 `damageMaterial` 变量有对其他对象的引用。最终，它使用 `plankRenderer.sharedMaterial` 值来切换到损坏的外观材质。
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before we can add our `Plank` script to our objects, we need to create the `LevelTracker`
    script that was mentioned earlier. Create it now.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够将 `Plank` 脚本添加到我们的对象之前，我们需要创建之前提到的 `LevelTracker` 脚本。现在就创建它。
- en: This script is fairly short and starts with a single variable. The variable
    will track the player's score for the level and is `static` so that it can be
    easily changed as objects are destroyed for points.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本相当简短，从单个变量开始。该变量将跟踪关卡中玩家的得分，并且是 `static` 的，这样就可以在对象被销毁以获得分数时轻松更改。
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we use the `Awake` function to make sure the player starts at zero when
    beginning a level.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `Awake` 函数确保玩家在开始关卡时从零开始。
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally for the script, we add the `AddScore` function. This function simply
    takes the amount of points passed to it and increases the player's score. It is
    also `static`, so that it can be called by any object in the scene without needing
    a reference to the script.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于脚本，我们添加了 `AddScore` 函数。这个函数简单地接受传递给它的分数数量，并增加玩家的得分。它也是 `static` 的，这样就可以在场景中的任何对象上调用它，而无需引用脚本。
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Back in Unity, we need to create a new material using the `plank_wood_damaged`
    texture. This will be the material that the script will swap to.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 中，我们需要使用 `plank_wood_damaged` 纹理创建一个新的材质。这将是在脚本中切换到的材质。
- en: Add the `Plank` script to our `Plank_Wood` object. Connect the **Damaged Material**
    reference to the new material and the **Plank Renderer** reference to the object's
    **Mesh Renderer** component.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Plank` 脚本添加到我们的 `Plank_Wood` 对象中。将 **Damaged Material** 引用连接到新材料，将 **Plank
    Renderer** 引用连接到对象的 **Mesh Renderer** 组件。
- en: As we create different types of planks, we can adjust the **Total Health** value
    to give them different strengths. A value of `25` works pretty well for the wood
    planks.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建不同类型的木板时，我们可以调整 **Total Health** 值以赋予它们不同的强度。对于木制木板，`25` 的值效果相当不错。
- en: Next, create an empty **GameObject** and rename it `LevelTracker`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个空的 **GameObject** 并将其重命名为 `LevelTracker`。
- en: Add the `LevelTracker` script to the object and it will begin to track the player's
    score.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LevelTracker` 脚本添加到对象中，它将开始跟踪玩家的得分。
- en: If you want to see the wood plank in action, position it above the ground and
    hit the play button. As soon as the game starts, Unity's physics will take over
    and drop the plank with gravity. If it started out high enough, you will be able
    to see it switch textures as it loses health.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想看到木板的实际效果，将其放置在地面上方并点击播放按钮。游戏开始后，Unity 的物理引擎将接管并让木板在重力作用下落下。如果它开始时的高度足够高，你将能够看到它随着健康值的降低而切换纹理。
- en: To make the other two planks that we need, select the `Plank_Wood` object and
    press *Ctrl* + *D* twice to duplicate it. Rename one to `Plank_Glass` and the
    other to `Plank_Rubber`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了制作我们需要的另外两个木板，选择 `Plank_Wood` 对象并按 *Ctrl* + *D* 两次来复制它。将一个重命名为 `Plank_Glass`，另一个重命名为
    `Plank_Rubber`。
- en: Next, create three new materials. One should be purple for the rubber plank,
    one should use the `plank_glass` texture for the glass plank, and the last material
    should use the `plank_glass_damaged` texture for when the glass plank is damaged.
    Apply the new materials to the proper locations for the new planks.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建三种新材料。其中一种应该是紫色，用于橡胶板；另一种应使用`plank_glass`纹理用于玻璃板；最后一种材料应使用`plank_glass_damaged`纹理，用于玻璃板损坏时。将新材料应用到新板的适当位置。
- en: As for the health of the new planks, a value of `15` for the glass and `100`
    for the rubber will work well.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于新板的健康值，玻璃板的值为`15`，橡胶板的值为`100`将非常合适。
- en: Finally, turn your three planks into prefabs and use them to build a structure
    for us to knock down. Feel free to scale them to make different-sized blocks,
    but leave the x axis alone. Also, all of the blocks should be positioned at zero
    on the x axis and your structure should be centered around about `30` on the z
    axis.![Time for action – creating planks](img/2014OT_07_02.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将你的三块板转换为预制体，并使用它们为我们构建一个要摧毁的结构。你可以自由地调整它们的大小，但请保持x轴不变。此外，所有块应该在x轴上的值为零，你的结构应该在大约`30`的z轴上居中。![行动时间
    – 创建板](img/2014OT_07_02.jpg)
- en: '*What just happened?*'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: We created the building blocks we needed for the structures that are going to
    be knocked down in our game. We used a **Rigidbody** component to tie them into
    the physics engine. Also, we created a script that keeps track of their health
    and swaps materials when it drops below half.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了游戏中将要被摧毁的结构所需的基本块。我们使用了一个**刚体**组件将它们与物理引擎连接起来。此外，我们还创建了一个脚本，用于跟踪它们的健康值，并在健康值降至一半以下时更换材料。
- en: Have a go hero – creating a stone block
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试 – 创建石块
- en: Wood and glass work well as basic blocks. But, if we are going to make harder
    levels, we need something a little stronger. Try your hand at making a stone block.
    Create two textures and materials for it to show its pristine and damaged states.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 木材和玻璃作为基本块效果很好。但是，如果我们打算制作更难的关卡，我们需要一些更坚固的材料。尝试制作一个石块。为它创建两个纹理和材料，以展示其原始和损坏状态。
- en: Physics materials
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理材料
- en: Physics materials are special types of materials that specifically tell the
    physics engine how two objects should interact. This does not affect the appearance
    of an object. It defines the friction and bounciness of a collider. We will use
    them to give our rubber plank some bounce and the glass plank some slide.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 物理材料是特殊类型的材料，它们会具体告诉物理引擎两个物体应该如何交互。这不会影响物体的外观。它定义了碰撞体的摩擦和弹性。我们将使用它们给我们的橡胶板一些弹性，给玻璃板一些滑动性。
- en: Time for action – sliding and bouncing
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 滑动和反弹
- en: 'Physics materials are quick enough to implement and will allow us to complete
    this section in four short steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 物理材料实现起来足够快，将使我们能够用四个简短的步骤完成这一部分：
- en: Physics materials are created like everything else, in the **Project** panel.
    Right-click inside the **Project** panel and click on **Create** | **Physic Material**.
    Create two physic materials and name one `Glass` and the other `Rubber`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物理材料就像其他所有内容一样，在**项目**面板中创建。在**项目**面板内右键单击，然后点击**创建** | **物理材料**。创建两个物理材料，一个命名为`Glass`，另一个命名为`Rubber`。
- en: Select one of them and take a look at it in the **Inspector** window. Right
    now, we are only concerned with the first three values. The others are used for
    more complex situations.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择其中一个，并在**检查器**窗口中查看它。目前，我们只关心前三个值。其他值用于更复杂的情况。
- en: '**Dynamic Friction**: This property is the amount of friction used when the
    object is moving. A value of zero is no friction, such as ice, and a value of
    one is a lot of friction, such as rubber.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态摩擦**：这个属性是在物体移动时使用的摩擦量。零表示没有摩擦，例如冰，而一表示很多摩擦，例如橡胶。'
- en: '**Static Friction**: This property functions the same as **Dynamic Friction**,
    the difference being that it is used when the object is not moving.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态摩擦**：这个属性与**动态摩擦**功能相同，区别在于它是在物体不移动时使用的。'
- en: '**Bounciness**: This property is how much of an object''s energy is reflected
    when it hits something or is hit by something. Zero means none of the energy is
    reflected, while a value of one will reflect all of it.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这个属性是当物体撞击某物或被某物撞击时，其能量反射的程度。零表示没有能量反射，而一表示全部反射。'
- en: For the `Glass` material, set the two friction values to `0.1` and **Bounciness**
    to `0`. For the `Rubber` material, set the two friction values to `1` and **Bounciness**
    to `0.8`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Glass`材质，将两个摩擦值设置为`0.1`，**弹性**设置为`0`。对于`Rubber`材质，将两个摩擦值设置为`1`，**弹性**设置为`0.8`。
- en: Next, select your `Plank_Glass` prefab and take a look at its **Box Collider**
    component. To apply your new physics materials, simply drag-and-drop one from
    the **Project** to the **Material** slot. Do the same for your `Plank_Rubber`
    prefab and, any time an object hits one of them, the materials will be used to
    control their interaction.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择你的`Plank_Glass`预制体，并查看其**Box Collider**组件。要应用你的新物理材质，只需从**Project**拖放到**Material**槽中。对`Plank_Rubber`预制体也做同样操作，任何时间一个对象撞击它们，就会使用这些材质来控制它们的交互。
- en: '*What just happened?*'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**发生了什么？**'
- en: We created a pair of physics materials. They control how two colliders interact
    when they run into each other. Using them, we are given control over the amount
    of friction and bounciness that is possessed by any collider.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一对物理材质。它们控制两个碰撞体相互碰撞时的交互方式。使用它们，我们可以控制任何碰撞体所具有的摩擦力和弹性。
- en: Characters
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: Having a bunch of generic blocks is just the beginning of this game. Next, we
    are going to create a few characters to add some life to the game. We are going
    to need some evil pigs to destroy and some good birds to throw at them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一堆通用块只是这个游戏的开始。接下来，我们将创建一些角色，为游戏增添一些活力。我们需要一些邪恶的猪来摧毁，和一些善良的鸟来投掷它们。
- en: The enemy
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人
- en: Our first character will be the enemy pig. On their own, they don't actually
    do anything. So, they are really just the wooden blocks we made earlier that happen
    to look like pigs. To make their destruction the goal of the game, however, we
    are going to expand our `LevelTracker` script to watch them and trigger a Game
    Over event if they are all destroyed. We will also expand it to draw the score
    on the screen and make it save the score for later use. To demonstrate the use
    of 2D assets in the 3D environment, the pigs are also created as flat textures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个角色将是敌人猪。单独来看，它们实际上并没有做什么。所以，它们实际上只是我们之前制作的看起来像猪的木块。然而，为了让它们的摧毁成为游戏的目标，我们将扩展我们的`LevelTracker`脚本以监视它们，如果它们全部被摧毁，则触发游戏结束事件。我们还将扩展它以在屏幕上绘制分数并保存分数以供以后使用。为了展示在3D环境中使用2D资产，猪也被创建为平面纹理。
- en: Time for action – creating the pigs
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建猪
- en: 'Let''s get started with creating the pigs for the Angry Birds game:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建愤怒的小鸟游戏中的猪：
- en: The pigs are created in a manner similar to that of the the wood planks. Start
    by creating an empty **GameObject** and naming it `Pig`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 猪的创建方式与木板的创建方式类似。首先创建一个空的**GameObject**，并将其命名为`Pig`。
- en: Next, create a plane, make it a child of the `Pig` object, and remove its **Mesh
    Collider** component. We do this because of the rotation the plane will need to
    face the camera. Being a child of the empty **GameObject** allows us to ignore
    that rotation when working with the pig.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个平面，将其设置为`Pig`对象的子对象，并移除其**Mesh Collider**组件。我们这样做是因为平面需要面向摄像机时的旋转。作为一个空**GameObject**的子对象，允许我们在处理猪时忽略那个旋转。
- en: Set the plane's local **Position** to `0` on each axis and set its **Rotation**
    to `90` on the **X** axis, `270` on the **Y** axis, and `0` on the **Z** axis.
    This will make the plane face the camera.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将平面的本地**位置**在每个轴上设置为`0`，将其**旋转**设置为**X**轴上的`90`，**Y**轴上的`270`，以及**Z**轴上的`0`。这将使平面面向摄像机。
- en: Now, create two materials. Name one `Pig_Fresh` and the other `Pig_Damage`.
    From their **Shader** drop-down list, select **Transparent**, followed by **Cutout**,
    and finally **Soft Edge Unlit**. This allows us to make use of the the texture's
    alpha channel and provide some transparency.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建两个材质。将一个命名为`Pig_Fresh`，另一个命名为`Pig_Damage`。从它们的**着色器**下拉列表中，选择**透明**，然后是**剪影**，最后是**软边缘不发光**。这允许我们利用纹理的alpha通道并提供一些透明度。
- en: Finish off the materials by adding the `pig_damage` and `pig_fresh` textures
    to them.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向它们添加`pig_damage`和`pig_fresh`纹理来完成材质。
- en: To the `Pig` object, add a **Sphere Collider** component, a **Rigidbody** component,
    and the `Plank` script. We make use of the **Sphere Collider** component, rather
    than the **Mesh Collider** component the plane came with, because the plane has
    zero thickness and will, therefore, have many issues colliding with other objects.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Pig`对象添加**Sphere Collider**组件、**Rigidbody**组件和`Plank`脚本。我们使用**Sphere Collider**组件，而不是平面自带**Mesh
    Collider**组件，因为平面没有厚度，因此将与其他对象发生许多碰撞问题。
- en: To complete the pig's creation, apply your material to the plane and connect
    the references in the `Plank` script. Finally, set the **Constraints** parameters
    on the **Rigidbody** component just as we did for the other planks.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成猪的创建，将你的材质应用到平面上，并在`Plank`脚本中连接引用。最后，就像我们对其他木板所做的那样，在**刚体**组件上设置**约束**参数。
- en: Now, turn the pig into a prefab and add it to your structure. Remember, leave
    them at zero on the x axis, but feel free to adjust their size, health, and score
    values to give them some variety.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将猪转换成预制体，并将其添加到你的结构中。记住，在x轴上保持它们为零，但你可以自由调整它们的大小、生命值和分数值，以增加它们的多样性。
- en: Next, we need to expand the `LevelTracker` script. Open it up and we can add
    some more code.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要扩展`LevelTracker`脚本。打开它，我们可以添加一些更多的代码。
- en: First, we add some more variables at the beginning of the script. The first
    one, as its name suggests, will hold a list of all the pigs in our scene. Next
    is a flag for signaling that the game has ended. And finally, a string for telling
    the player why the game has ended.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在脚本的开头添加一些变量。第一个，正如其名称所暗示的，将保存场景中所有猪的列表。接下来是一个标志，用于指示游戏是否结束。最后，一个字符串，用于告诉玩家游戏结束的原因。
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we need to add a line to the `Awake` function. This simply makes sure
    that the `gameOver` flag is `false` when the level starts.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`Awake`函数中添加一行代码。这仅仅确保当关卡开始时`gameOver`标志为`false`。
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the `OnGUI` function to draw a Game Over screen when the game has ended,
    or for drawing the current score if it is still continuing.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`OnGUI`函数在游戏结束时绘制游戏结束屏幕，或者如果游戏仍在继续，绘制当前的分数。
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `DrawScore` function takes the current score and uses `GUI.Label` to draw
    it in the top-right corner of the screen.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DrawScore`函数接受当前的分数，并使用`GUI.Label`在屏幕的右上角绘制它。'
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `DrawGameOver` function first uses the `GUI.Box` function to draw a dark
    box over the whole of the screen, simultaneously drawing the Game Over message
    on the screen. Next, it draws the player''s final score in the middle of the screen.
    Below that, it draws a button. This button will save the player''s current score
    and load the level-selection screen we will create later. The `Application.LoadLevel`
    function is used to load any other scene in your game. All of the scenes you intend
    to load have to be added to the **Build Settings** window found in the **File**
    menu and can be loaded by using either their name or their index, as used here:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DrawGameOver`函数首先使用`GUI.Box`函数在屏幕上绘制一个覆盖整个屏幕的深色框，同时绘制“游戏结束”消息在屏幕上。接下来，它在屏幕中间绘制玩家的最终分数。下面，它绘制了一个按钮。这个按钮将保存玩家的当前分数并加载我们稍后创建的水平选择屏幕。使用`Application.LoadLevel`函数来加载游戏中的任何其他场景。你打算加载的所有场景都必须添加到**文件**菜单中找到的**构建设置**窗口，并且可以使用它们的名称或索引来加载，就像这里使用的那样：'
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `LateUpdate` function, we call another function to check whether all
    the pigs have been destroyed if the game is not yet over.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LateUpdate`函数中，我们调用另一个函数来检查如果游戏尚未结束，是否所有猪都被摧毁了。
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we add the `CheckPigs` function. This function loops through the list
    of pigs to see if they are all destroyed. Should it find one that is still around,
    it exits the function. Otherwise, the game is flagged as being over and the message
    is set to tell the player that they succeeded in destroying all of the pigs.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加`CheckPigs`函数。这个函数会遍历猪的列表，查看它们是否全部被摧毁。如果找到一只仍然存在的猪，它会退出函数。否则，游戏会被标记为结束，并且会设置一条消息通知玩家他们成功摧毁了所有的猪。
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `OutOfBirds` function will be called by the slingshot we are going to create
    later, when the player runs out of birds to launch at the pigs. If the game has
    not yet ended, the function ends the game and sets an appropriate message for
    the player.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OutOfBirds`函数将在我们稍后创建的弹弓中调用，当玩家用完可以发射到猪身上的鸟时。如果游戏尚未结束，该函数将结束游戏并为玩家设置一条适当的消息。'
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we have the `SaveScore` function. Here, we use the `PlayerPrefs` class.
    It lets us easily store and retrieve small amounts of data, perfect for our current
    needs. We just need to provide it with a unique key to save the data under. For
    that, we use a short string combined with the level's index as provided by `Application.loadedLevel`.
    Next, we use `PlayerPrefs.GetInt` to retrieve the last score that was saved. If
    there isn't one, the zero that we passed to the function is returned as a default
    value. Finally, we compare the new score with the old score and use `PlayerPrefs.SetInt`
    to save the new score if it is higher.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`SaveScore`函数。在这里，我们使用`PlayerPrefs`类。它让我们能够轻松地存储和检索少量数据，非常适合我们的当前需求。我们只需要提供一个唯一的键来保存数据。为此，我们使用一个简短的字符串与由`Application.loadedLevel`提供的关卡索引相结合。接下来，我们使用`PlayerPrefs.GetInt`检索最后保存的分数。如果没有，函数中传递的零将作为默认值返回。最后，我们比较新分数和旧分数，如果新分数更高，则使用`PlayerPrefs.SetInt`保存新分数。
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Back in Unity, the pigs need to be added to the `LevelTracker` script's list.
    With the `LevelTracker` script selected, drag-and-drop each pig to the `Pigs`
    value in the **Inspector** window to add them.![Time for action – creating the
    pigs](img/2014OT_07_03.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，需要将猪添加到`LevelTracker`脚本的列表中。选择`LevelTracker`脚本后，将每个猪拖放到**检查器**窗口中的`Pigs`值以添加它们。![行动时间
    – 创建猪](img/2014OT_07_03.jpg)
- en: '*What just happened?*'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the pigs and updated our `LevelTracker` script to track them. The
    pigs are really just like the planks of wood, but are spheres instead of boxes.
    The updated `LevelTracker` script watches for the instance when all of the pigs
    are destroyed and triggers a Game Over screen when they are. It also handles the
    drawing of the score while the game is being played and the saving of that score
    when the level is over.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了猪并更新了我们的`LevelTracker`脚本以跟踪它们。猪实际上就像木板的形状，但它们是球体而不是盒子。更新的`LevelTracker`脚本会监视所有猪被摧毁的实例，并在它们被摧毁时触发游戏结束屏幕。它还处理游戏进行时的分数绘制以及在关卡结束时保存该分数。
- en: The ally
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同盟
- en: Next, we need something to throw at the pigs and their fortification. Here,
    we will create the simplest of the birds. The red bird is essentially just a rock.
    He has no special powers and nothing particularly special about his code, besides
    health. You will also notice that the bird is a 3D model, giving it the shadows
    that the pigs are missing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些东西去扔向猪和它们的防御工事。在这里，我们将创建最简单的鸟。红色的鸟本质上只是一个石头。他没有特殊的能力，代码中也没有什么特别之处，除了健康。你也会注意到这只鸟是一个3D模型，它有猪所缺少的阴影。
- en: Time for action – creating the red bird
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建红色鸟
- en: 'Let''s get started with creating the red bird:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建红色的鸟：
- en: Although the red bird model is 3D, it is set up in a manner similar to that
    of the pig. Create an empty **GameObject**, naming it `Bird_Red`, and add the
    appropriate model from the `birds` model as a child, zeroing out its position.
    The model should be rotated to align it along the z axis. If turned a little more
    toward the camera, the player is able to see the bird's face while still giving
    the impression of looking down the field.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然红色鸟模型是3D的，但它的设置方式与猪类似。创建一个空的**游戏对象**，命名为`Bird_Red`，并从`birds`模型中添加适当的模型作为子对象，将其位置归零。模型应该旋转以沿z轴对齐。如果稍微朝向摄像机转动，玩家就能看到鸟的脸，同时仍然给人一种向下看田野的印象。
- en: Next, give it a **Sphere Collider** component and a **Rigidbody** component,
    and set the **Constraints** parameters.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，给它添加一个**球体碰撞器**组件和一个**刚体**组件，并设置**约束**参数。
- en: Now, we need to create a new script named `Bird`. This script will be a base
    for all of our birds, tracking their health and triggering their special powers
    when appropriate.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的脚本名为`Bird`。这个脚本将成为我们所有鸟的基础，跟踪它们的生命值并在适当的时候触发它们的特殊能力。
- en: It starts with two variables. The first will keep track of the bird's current
    health. The second is a flag so that the bird will only use its special power
    once. It is marked as `protected` so the class that extends this script can use
    it while keeping it from interference from outside the class.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从两个变量开始。第一个将跟踪鸟当前的健康状况。第二个是一个标志，这样鸟就只会使用一次它的特殊能力。它被标记为`protected`，这样扩展此脚本的类可以使用它，同时防止来自类外部的干扰。
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Update` function does three checks before activating the bird's special
    power. First, it checks whether it has already been done, then whether the screen
    has been touched, and finally whether the bird has a **Rigidbody** component and
    that it is not being controlled by another script.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update` 函数在激活鸟的特殊能力之前进行三项检查。首先，检查它是否已经完成，然后检查屏幕是否被触摸，最后检查鸟是否有 **Rigidbody**
    组件，并且它不是由另一个脚本控制的。'
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the case of the red bird, the `DoSpecial` function only sets its flag to
    `true`. It is marked as `virtual` so that we can override the function for the
    other birds and make them do some fancier things.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在红色鸟的情况下，`DoSpecial` 函数仅将其标志设置为 `true`。它被标记为 `virtual`，这样我们就可以为其他鸟重写该函数，让它们做一些更复杂的事情。
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `OnCollisionEnter` function works just like the one for the planks, subtracting
    health based on the strength of the collision and destroying the bird if it runs
    out of health.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnCollisionEnter` 函数与板子的函数类似，根据碰撞的强度减去健康值，如果健康值耗尽，则销毁鸟。'
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Return to Unity and add the script to the `Bird_Red` object.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 并将脚本添加到 `Bird_Red` 对象。
- en: Complete the bird's creation by turning it into a prefab and deleting it from
    the scene. The slingshot we will be creating soon will handle the creation of
    the birds when the game starts.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其转换为预制件并将其从场景中删除来完成鸟的创建。我们即将创建的弹弓将在游戏开始时处理鸟的创建。
- en: '*What just happened?*'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the red bird. It is set up just like our other physics objects. We
    also created a script to handle the bird's health that is expanded later, when
    we create the other birds for our game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了红色鸟。它的设置就像我们的其他物理对象一样。我们还创建了一个脚本来处理鸟的健康状况，这个脚本在稍后创建其他鸟时会被扩展。
- en: Controls
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制
- en: Next, we are going to give the player the ability to interact with the game.
    First, we will create a slingshot to throw the birds. Following that will be the
    creation of the camera controls. We will even create a nice background effect
    to round out the look of our game.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将给玩家提供与游戏交互的能力。首先，我们将创建一个弹弓来投掷鸟。随后将是创建相机控制。我们甚至将创建一个漂亮的背景效果，以完善我们游戏的外观。
- en: Attacking
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击
- en: To attack the pig fortress, we have our basic bird ammo. We need to create a
    slingshot to hurl that ammo at the pigs. It will also handle the spawning of the
    birds at the beginning of the level and automatically reload as birds are used.
    When the slingshot runs out of birds it will notify the `LevelTracker` script
    and the game will end. Finally, we will create a script that will keep the physics
    simulation from going on for too long. We don't want the player forced to sit
    and watch a pig slowly roll across the screen. So, the script will, after a little
    while, start damping the movement of the **Rigidbody** components to make them
    stop rather than keep rolling.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要攻击猪堡垒，我们有基本的鸟弹。我们需要创建一个弹弓来将弹药投向猪。它还将处理游戏开始时鸟的生成，并在使用鸟时自动重新装填。当弹弓的鸟用完时，它将通知
    `LevelTracker` 脚本，游戏将结束。最后，我们将创建一个脚本，以防止物理模拟进行得太久。我们不希望玩家被迫坐着看猪慢慢地滚过屏幕。因此，脚本会在一段时间后开始减慢
    **Rigidbody** 组件的运动，使它们停止而不是继续滚动。
- en: Time for action – creating the slingshot
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动起来——创建弹弓
- en: 'Most of the slingshot''s appearance will actually be an optical illusion:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 弹弓的大部分外观实际上是一种视觉错觉：
- en: To start off the creation of the slingshot, add the `slingshot` model to the
    scene and position it at the origin. Apply a light brown material to the `Fork`
    model and a dark brown one to the `Pouch` model.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始创建弹弓，将 `slingshot` 模型添加到场景中，并将其定位在原点。将浅棕色材料应用到 `Fork` 模型上，深棕色材料应用到 `Pouch`
    模型上。
- en: Next, we need four empty **GameObject**. Make them all the children of the `Slingshot`
    object.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要四个空白的 **GameObject**。将它们都设置为 `Slingshot` 对象的子对象。
- en: Name the first `FocalPoint` and center it between the fork prongs of the slingshot.
    This will be the point through which we fire all of the birds.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第一个命名为 `FocalPoint` 并将其中心对准弹弓的叉子之间。这将是我们发射所有鸟的点。
- en: The second is `Pouch`. Make the `pouch` model a child of this object, setting
    its position to `0.5` on the **X** axis and `0` on the **Y** and **Z** axes. This
    will make the pouch appear in front of the current bird without having to make
    a complete pouch model.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是 `Pouch`。将 `pouch` 模型设置为该对象的子对象，将其位置设置为 **X** 轴上的 `0.5`，**Y** 和 **Z** 轴上的
    `0`。这将使口袋出现在当前鸟的前面，而无需制作完整的口袋模型。
- en: Third is `BirdPoint`; this will position the bird that is being fired. Make
    it a child of the `Pouch` point and set its position to `0` on the **X** and **Y**
    axes and `0.3` on the **Z** axis.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三是 `BirdPoint`；这将定位被发射的鸟。将其设置为 `Pouch` 点的子项，并将其在 **X** 和 **Y** 轴上的位置设置为 `0`，在
    **Z** 轴上设置为 `0.3`。
- en: Last is `WaitPoint`; the birds waiting to be fired will be positioned behind
    this point. Set its position to `0` for the **X** axis, `0.5` for the **Y** axis,
    and `-4` for the **Z** axis.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是 `WaitPoint`；等待发射的鸟将被定位在这个点后面。将 **X** 轴的位置设置为 `0`，**Y** 轴的位置设置为 `0.5`，**Z**
    轴的位置设置为 `-4`。
- en: Next, rotate the `Fork` model so that we can see both prongs of the fork. The
    values of `270` for the **X** axis, `25` for the **Y** axis, and `0` for the **Z**
    axis will work well.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，旋转 `Fork` 模型，以便我们可以看到叉子的两个叉。对于 **X** 轴的 `270`，**Y** 轴的 `25`，**Z** 轴的 `0`
    将工作得很好。
- en: The `Slingshot` script will provide most of the interaction for the player.
    Create it now.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Slingshot` 脚本将为玩家提供大部分交互。现在创建它。'
- en: We start it with a group of variables. The first will keep a reference to the
    damper that was mentioned earlier. The second group keeps track of the birds that
    will be used in the level. Next is a group of variables that will track the current
    bird that is ready to be fired. Fourth, we have some variables to hold references
    to the points we created a moment ago. The `maxRange` variable is the distance
    from the focal point to which the player can drag the pouch. The last two variables
    define how powerfully the bird will be launched.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一组变量开始。第一个将保留之前提到的阻尼器的引用。第二个组跟踪将在关卡中使用的鸟。接下来是一组变量，将跟踪当前准备好发射的鸟。第四，我们有几个变量来保存我们刚才创建的点的引用。`maxRange`
    变量是从焦点到玩家可以拖动 pouch 的距离。最后两个变量定义了鸟将被发射的力度。
- en: '[PRE21]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As with our other scripts, we use the `Awake` function for initialization. The
    `levelBirds` variable will hold references to all of the `bird` prefabs that will
    be used in the level. We start by creating an instance of each one and storing
    it in the `currentBirds` variable. The `isKinematic` variable is set to `true`
    on each bird's **Rigidbody** so that it does not move when it is not in use. Next,
    it readies the first bird to be fired and, finally, it positions the remaining
    birds behind the `waitPoint`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们其他的脚本一样，我们使用 `Awake` 函数进行初始化。`levelBirds` 变量将保存将在关卡中使用的所有 `bird` 预制体的引用。我们首先创建每个实例并将它们存储在
    `currentBirds` 变量中。将每个鸟的 **Rigidbody** 上的 `isKinematic` 变量设置为 `true`，这样当它未被使用时就不会移动。接下来，它准备好第一只待发射的鸟，最后，将剩余的鸟定位在
    `waitPoint` 后面。
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ReadyNextBird` function first checks to see if we have run out of birds.
    If so, it calls the `LevelTracker` script to trigger the Game Over event. The
    `nextIndex` variable tracks the current location of the birds in the list to fire
    at the player. Next, the function checks to make sure the next slot actually has
    a bird, incrementing the index and trying for a new bird if it does not have one.
    If there is a bird available, it is stored in the `toFireBird` variable and made
    a child of the `BirdPoint` object we created; its position and rotation are zeroed
    out. Finally, the firing and aiming flags are reset.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadyNextBird` 函数首先检查我们是否已经用完了鸟。如果是这样，它调用 `LevelTracker` 脚本来触发游戏结束事件。`nextIndex`
    变量跟踪列表中鸟的当前位置，以便向玩家发射。接下来，函数检查下一个槽位实际上是否有鸟，如果没有，则增加索引并尝试获取新的鸟。如果有可用的鸟，它将被存储在 `toFireBird`
    变量中，并成为我们创建的 `BirdPoint` 对象的子项；其位置和旋转被设置为 `0`。最后，重置发射和瞄准标志。'
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `SetWaitingPositions` function uses the position of the `waitPoint` to position
    all of the remaining birds behind the slingshot.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetWaitingPositions` 函数使用 `waitPoint` 的位置来定位所有剩余的鸟在弹弓后面。'
- en: '[PRE24]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Update` function starts by checking to see if the player has fired a bird
    and watches the `rigidbodyDamper.allSleeping` variable to see if all of the physics
    objects have stopped moving. Once they do, the next bird is readied to fire. If
    we have not fired, the aiming flag is checked and the `DoAiming` function is called
    to handle the aiming. If the player is neither aiming nor has just fired a bird,
    we check for touch input and, if the player touches close enough to the focal
    point, we flag that the player has started aiming.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update` 函数首先检查玩家是否发射了鸟，并观察 `rigidbodyDamper.allSleeping` 变量以查看是否所有物理对象都已停止移动。一旦它们停止移动，下一只鸟就准备好发射。如果我们还没有发射，则检查瞄准标志并调用
    `DoAiming` 函数来处理瞄准。如果玩家既没有瞄准也没有刚刚发射了一只鸟，我们检查触摸输入，如果玩家触摸到足够接近焦点的地方，我们标记玩家已经开始瞄准。'
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `DoAiming` function checks to see if the player has stopped touching the
    screen and fires the current bird when they have. If they have not, we position
    the pouch at the current touch point. Finally, the pouch's position is limited
    to keep it within the maximum range.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DoAiming`函数检查玩家是否停止触摸屏幕，如果他们停止触摸，则发射当前小鸟。如果他们没有停止，我们将袋子放置在当前触摸点上。最后，限制袋子的位置以保持其在最大范围内。'
- en: '[PRE26]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `GetTouchPoint` function uses `ScreenPointToRay` to find out where the player
    is touching in 3D space. This is just as when we were shooting asteroids but,
    because this game is 2D, we can just look at the ray's origin and return it with
    a zero for its x axis value.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetTouchPoint`函数使用`ScreenPointToRay`来确定玩家在3D空间中的触摸位置。这就像我们射击小行星时一样，但由于这个游戏是2D的，我们只需查看射线的起点并将其x轴值设置为0返回。'
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, for this script, we have the `FireBird` function. This function starts
    by setting our `didFire` flag to `true`. Next, it finds out the direction to fire
    by finding the direction from the pouch's position to the `focalPoint`. It also
    uses the distance between them to determine the power to fire the bird with, clamping
    it between our min and max strengths. Then, it releases the bird by clearing its
    parent and setting its `isKinematic` flag to `false`. To launch it, we use the
    `rigidbody.AddForce` function and pass the direction multiplied by the power to
    it. `ForceMode.Impulse` is also passed to make the force applied once and immediately.
    Next, the pouch is positioned at the `focalPoint`, as if it were actually under
    tension. And finally, we call `rigidbodyDamper.ReadyDamp` to start the damping
    of the `Rigidbody` movement.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于此脚本，我们还有`FireBird`函数。此函数首先将我们的`didFire`标志设置为`true`。接下来，它通过找到从袋子位置到`focalPoint`的方向来确定发射方向。它还使用它们之间的距离来确定用多大的力量发射小鸟，将其限制在我们的最小和最大强度之间。然后，通过清除其父对象并设置其`isKinematic`标志为`false`来释放小鸟。为了发射它，我们使用`rigidbody.AddForce`函数并将方向乘以力量传递给它。`ForceMode.Impulse`也被传递以使施加的力一次性并立即生效。接下来，袋子被放置在`focalPoint`处，就像它实际上处于紧张状态一样。最后，我们调用`rigidbodyDamper.ReadyDamp`以开始`Rigidbody`运动的阻尼。
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before we can make use of the `Slingshot` script, we need to create the `RigidbodyDamper`
    script.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以使用`Slingshot`脚本之前，我们需要创建`RigidbodyDamper`脚本。
- en: This script starts with six variables. The first two define how long to wait
    before the damping movement and how much to damp it by. The next two track whether
    it can apply the damping and when it will start. Next, is a variable that will
    be filled with a list of all the rigidbodies that are currently in the scene.
    Finally, it has the `allSleeping` flag that will be set to `true` when the movement
    has stopped.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本以六个变量开始。前两个变量定义了在阻尼运动之前等待多长时间以及阻尼的程度。接下来的两个变量跟踪是否可以应用阻尼以及何时开始。接下来是一个变量，它将填充当前场景中所有刚体的列表。最后，它有一个`allSleeping`标志，当运动停止时将设置为`true`。
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ReadyDamp` function starts by using `FindObjectsOfType` to fill the list
    with all of the rigidbodies. It sets when to start damping as the sum of the current
    time and the wait length. It marks that the script can do its damping and resets
    the `allSleeping` flag. Finally, it uses `StartCoroutine` to call the `CheckSleepingRigidbodies`
    function. This is a special way of calling functions to make them run in the background
    without blocking the rest of the game from running.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadyDamp`函数首先使用`FindObjectsOfType`将所有刚体填充到列表中。它将开始阻尼的时间设置为当前时间加上等待长度。它标记脚本可以进行阻尼并重置`allSleeping`标志。最后，它使用`StartCoroutine`调用`CheckSleepingRigidbodies`函数。这是一种特殊的调用函数的方式，使它们在后台运行而不阻塞游戏的其余部分。'
- en: '[PRE30]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `FixedUpdate` function, we first check to see if we can damp the movement
    and whether it is time to do it. If it is, we loop through all of the rigidbodies,
    applying our damp to each one's rotational and linear velocity. Those that are
    kinematic, controlled by scripts, and already sleeping, meaning they stopped moving,
    are skipped.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FixedUpdate`函数中，我们首先检查是否可以阻尼运动以及是否是进行阻尼的时间。如果是，我们遍历所有刚体，对每个刚体的角速度和线速度应用我们的阻尼。那些是运动学、由脚本控制并且已经停止移动的（即它们停止了移动）的刚体将被跳过。
- en: '[PRE31]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `CheckSleepingRigidbodies` function is special and will run in the background.
    This is made possible by the `IEnumerator` flag at the beginning of the function
    and the `yield return null` line in the middle. Together, these allow the function
    to pause regularly and keep from freezing the rest of the game while it waits
    for the function to complete. The function starts by creating a check flag and
    using it to check if all of the rigidbodies have stopped moving. If one is found
    still moving, the flag is set to `false` and the function pauses until the next
    frame, when it will try again. When it reaches the end, because all of the rigidbodies
    are sleeping, it sets the `allSleeping` flag to `true`, so that the slingshot
    can ready the next bird. It also stops itself from damping while the player is
    getting ready to fire the next bird.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CheckSleepingRigidbodies` 函数是特殊的，它将在后台运行。这是通过函数开头处的 `IEnumerator` 标志和中间的 `yield
    return null` 行实现的。这两个结合允许函数定期暂停，以免在等待函数完成时冻结游戏的其余部分。该函数首先创建一个检查标志并使用它来检查所有刚体是否已停止移动。如果找到一个仍在移动的刚体，则将标志设置为
    `false` 并暂停函数，直到下一帧，届时它将再次尝试。当它到达末尾时，因为所有刚体都处于睡眠状态，它将 `allSleeping` 标志设置为 `true`，以便弹弓可以准备下一只鸟。它还阻止自己在玩家准备发射下一只鸟时进行阻尼。'
- en: '[PRE32]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, we have the `AddBodiesToCheck` function. This function will be used
    by anything that spawns new physics objects after the player has fired the bird.
    It starts by creating a temporary list and expanding the current one. Next, it
    adds all of the values from the temporary list to the expanded one. Finally, the
    list of rigidbodies is added after those of the temporary list.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有 `AddBodiesToCheck` 函数。这个函数将在玩家发射鸟之后，由任何生成新物理对象的东西使用。它首先创建一个临时列表并扩展当前列表。接下来，它将临时列表中的所有值添加到扩展列表中。最后，在临时列表之后添加刚体列表。
- en: '[PRE33]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Return to Unity and add the two scripts to the `Slingshot` object. On the `Slingshot`
    script component, connect the references to the **Rigidbody Damper** component
    and each of the points. Also, add to the **Level Birds** list as many references
    to the red bird as you want for the level.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 并将两个脚本添加到 `Slingshot` 对象中。在 `Slingshot` 脚本组件中，连接到 **Rigidbody Damper**
    组件和每个点。同时，将 **Level Birds** 列表中添加尽可能多的红色鸟的引用，以适应该关卡。
- en: To keep objects from rolling back and through the slingshot, create a **Box
    Collider** component and position it at the stock of the `Fork` model.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止物体在弹弓中滚动回滚，创建一个 **Box Collider** 组件并将其放置在 `Fork` 模型的枪托上。
- en: To finish off the look of the slingshot, we need to create the elastic bands
    that tie the pouch to the fork. We will do this by first creating the `SlingshotBand`
    script.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成弹弓的外观，我们需要创建将袋子系在叉子上的弹性带。我们将通过首先创建 `SlingshotBand` 脚本来完成这项工作。
- en: The script starts with two variables. One for the point that the band will end
    at and one to reference the `LineRenderer` that will draw it.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本开始时有两个变量。一个用于弹性带结束的点，另一个用于引用将绘制它的 `LineRenderer`。
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Awake` function makes sure the `lineRenderer` variable has only two points
    and sets their initial positions.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Awake` 函数确保 `lineRenderer` 变量只有两个点，并设置它们的初始位置。'
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the `LateUpdate` function, we set the `lineRenderer` variable's end position
    to the `endPoint` value. This point will move around with the pouch, so we need
    to constantly update the renderer.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LateUpdate` 函数中，我们将 `lineRenderer` 变量的结束位置设置为 `endPoint` 值。这个点将随着袋子移动，因此我们需要不断更新渲染器。
- en: '[PRE36]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Return to Unity and create an empty **GameObject**. Name it `Band_Near` and
    make it a child of the `Slingshot` object.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 并创建一个空的 **GameObject**。将其命名为 `Band_Near` 并使其成为 `Slingshot` 对象的子对象。
- en: As children of this new point, create a cylinder and a second empty **GameObject**,
    named `Band`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为新点的子对象，创建一个圆柱体和第二个空的 **GameObject**，命名为 `Band`。
- en: Give the cylinder a brown material and position it near the prong of the slingshot
    fork.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给圆柱体一个棕色材质并将其放置在弹弓叉子的尖端附近。
- en: To the `Band` object, add a **Line Renderer** component found under **Effects**
    in the **Component** menu. After positioning it in the center of the cylinder,
    add the `SlingshotBand` script to the object.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Line Renderer** 组件添加到 `Band` 对象中，该组件位于 **Component** 菜单下的 **Effects** 中。在将其定位在圆柱体的中心后，将
    `SlingshotBand` 脚本添加到对象中。
- en: To the **Line Renderer** under **Materials**, you can put your brown material
    in the slot to color the band. under **Parameters**. Set the **Start Width** to
    `0.5` and the **End width** to `0.2` to set the size of the line.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**材质**下的**Line Renderer**中，你可以将你的棕色材质放入槽中，以着色带子。在**参数**中，将**起始宽度**设置为`0.5`，将**结束宽度**设置为`0.2`，以设置线的尺寸。
- en: Next, create one more empty **GameObject** and name it `BandEnd_Near`. Make
    it a child of the `Pouch` object and position it inside the pouch.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个额外的空**GameObject**，并将其命名为`BandEnd_Near`。将其设置为`Pouch`对象的子对象，并将其放置在包内。
- en: Now, connect the script's references to its line renderer and end point.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将脚本的引用连接到其线渲染器和终点。
- en: To make the second band, duplicate the four objects we just created and position
    them far from the prong of the fork. The end point for this band can just be moved
    back along the x axis to keep it out of the way of the birds.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建第二个带子，复制我们刚刚创建的四个对象，并将它们放置在叉子尖端远处。这个带子的终点可以沿着x轴移动，以保持它不在鸟类的路上。
- en: Finally, turn the whole thing into a prefab so it can be easily reused in other
    levels.![Time for action – creating the slingshot](img/2014OT_07_04.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将整个系统转换成一个预制件，以便可以在其他关卡中轻松重用。![行动时间 – 创建弹弓](img/2014OT_07_04.jpg)
- en: '*What just happened?*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the slingshot that will be used to fire birds. We used techniques
    we learned in the previous chapter to handle touch input and track the player's
    finger while they aim and shoot. If you save your scene and position the camera
    to look at the slingshot, you will notice that it is complete if not entirely
    playable. Birds can be fired at the pig fortress, although we can only see the
    destruction from within Unity's **Scene** view.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了将用于发射鸟类的弹弓。我们使用了在前一章中学到的技术来处理触摸输入，并在玩家瞄准和射击时跟踪玩家的手指。如果你保存场景并将相机定位到观察弹弓，你会注意到它已经完成，尽管可能不完全可玩。可以朝向猪堡垒发射鸟类，尽管我们只能从Unity的**场景**视图中看到破坏。
- en: Watching
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察
- en: The game is technically playable at this point, but it is kind of hard to see
    what is going on. Next, we will create a system to control the camera. It will
    allow the player to drag the camera left and right, follow the bird when it is
    launched and return to the slingshot when everything stops moving. There will
    also be a set of limits to keep the camera from going too far and viewing things
    we do not want the player to see.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，游戏在技术上是可以玩的，但看不清楚发生了什么。接下来，我们将创建一个控制系统来控制相机。这将允许玩家左右拖动相机，当鸟类被发射时跟随鸟类，并在一切停止移动时返回弹弓。同时，也会有一套限制，以防止相机移动得太远，看到我们不希望玩家看到的东西。
- en: Time for action – controlling the camera
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 控制相机
- en: 'We will only need one, fairly short script to control and manage our camera:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个相对简短的脚本就能控制和管理工作中的相机：
- en: To start and to keep everything organized, create a new empty **GameObject**
    and name it `CameraRig`. Also, to keep it simple, set its position to zero on
    each axis.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了开始并保持一切井然有序，创建一个新的空**GameObject**，并将其命名为`CameraRig`。为了简化，将其在每个轴上的位置设置为零。
- en: Next, create three more empty **GameObject** and name them `LeftPoint`, `RightPoint`,
    and `TopPoint`. Set their **X** axis positions to `5`. Position the `LeftPoint`
    to be in front of the slingshot and at `3` on the **Y** axis. The `RightPoint`
    needs to be positioned in front of the `pig` structure you created. The `TopPoint`
    can be over the slingshot, but needs to set to `8` on the **Y** axis. These three
    points will define the limits of where our camera can move when being dragged
    and following birds.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建三个更多的空**GameObject**，并将它们命名为`LeftPoint`、`RightPoint`和`TopPoint`。将它们的**X**轴位置设置为`5`。将`LeftPoint`放置在弹弓前方，并在**Y**轴上设置为`3`。`RightPoint`需要放置在你创建的`pig`结构前方。`TopPoint`可以位于弹弓上方，但需要在**Y**轴上设置为`8`。这三个点将定义相机在被拖动和跟随鸟类时可以移动的范围。
- en: Make all three points, and the `Main Camera` object, children of the `CameraRig`
    object.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有三个点和`Main Camera`对象设置为`CameraRig`对象的子对象。
- en: Now, we create the `CameraControl` script. This script will control all of the
    movement and interaction with the camera.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建`CameraControl`脚本。这个脚本将控制所有与相机的移动和交互。
- en: Our variables for this script start with a reference to the slingshot; we need
    this so we can follow the current bird when it is fired. Next are the references
    to the points we just created. The next group of variables control how long the
    camera will sit without input before returning to look at the slingshot and how
    fast it will return. The `dragScale` variable controls how fast the camera actually
    moves when the player drags their finger across the screen, allowing us to keep
    the scene moving with the finger. The last group is to control whether the camera
    can follow the current bird and how fast it can do so.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本的变量从对弹弓的引用开始；我们需要这个引用以便在发射当前鸟时跟随它。接下来是引用我们刚刚创建的点。下一组变量控制相机在没有输入的情况下会坐多久然后返回查看弹弓，以及返回的速度有多快。`dragScale`
    变量控制玩家在屏幕上拖动手指时相机实际移动的速度，使我们能够保持场景随着手指移动。最后一组变量用于控制相机是否可以跟随当前鸟以及它跟随的速度有多快。
- en: '[PRE37]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `Awake` function, we first make certain the camera is not following a
    bird and make it wait before heading to look at the slingshot. This allows us
    to initially point the camera to the pig fortress when the level starts and move
    to the slingshot after giving the player a chance to see what they are up against.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Awake` 函数中，我们首先确保相机没有跟随鸟，并在前往查看弹弓之前让它等待。这允许我们在关卡开始时将相机指向猪堡垒，并在给玩家机会看到他们面对什么之后移动到弹弓。
- en: '[PRE38]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `StartWait` function sets the time when it will start to head back to the
    slingshot and records the position that it is heading back from. This allows us
    to create a smooth transition.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StartWait` 函数设置开始返回弹弓的时间，并记录它返回的位置。这允许我们创建一个平滑的过渡。'
- en: '[PRE39]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, we have the `Update` function. This one starts by checking whether the
    slingshot has fired. If it hasn't, it checks to see whether the player has started
    aiming, signaling that the bird should be followed and zeroing out the velocity
    if they have. If they have not, the `followBird` flag is cleared. Next, the function
    checks whether it should follow and does so if it should, also calling the `StartWait`
    function in case this is the frame in which the bird is destroyed. If it should
    not follow the bird, it checks for touch input and drags the camera if it finds
    any. The wait is again started in case the player removes their finger in this
    frame. Finally, it checks to see if the slingshot is done firing the current bird
    and if it is time to head back. Should both be true, the camera moves back to
    pointing at the slingshot.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有 `Update` 函数。这个函数首先检查弹弓是否已经发射。如果没有，它检查玩家是否开始瞄准，这表示应该跟随鸟，如果他们已经瞄准，则将速度归零。如果没有，则清除
    `followBird` 标志。接下来，函数检查是否应该跟随，如果应该跟随，则执行跟随操作，并在鸟被销毁的帧中调用 `StartWait` 函数。如果不应该跟随鸟，它检查触摸输入，并在找到任何输入时拖动相机。如果玩家在这个帧中移除手指，则再次开始等待。最后，它检查弹弓是否已经完成当前鸟的发射，以及是否是返回的时间。如果两者都为真，则相机返回指向弹弓。
- en: '[PRE40]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `FollowBird` function starts by making sure there is a bird to follow by
    checking the `toFireBird` variable on the `Slingshot` script and stops following
    if a bird is not found. Should there be a bird, the function then determines a
    new point to move to that will look directly at the bird. It then uses the `Vector3.SmoothDamp`
    function to smoothly follow the bird. This function works similar to a spring—the
    farther away it is from its target position, the faster it moves the object. The
    `followVelocity` variable is used to keep it moving smoothly. Finally, it calls
    another function to limit the camera's position within those bounding points we
    set up earlier.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FollowBird` 函数首先确保有一个鸟需要跟随，通过检查 `Slingshot` 脚本中的 `toFireBird` 变量，如果找不到鸟则停止跟随。如果存在鸟，函数随后确定一个新位置移动到那里，以便直接看向鸟。然后它使用
    `Vector3.SmoothDamp` 函数平滑地跟随鸟。这个函数的工作原理类似于弹簧——它离目标位置越远，移动物体的速度就越快。`followVelocity`
    变量用于保持其平滑移动。最后，它调用另一个函数来限制相机在之前设置的边界点内的位置。'
- en: '[PRE41]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `DragCamera` function, we use the `deltaPosition` value of the current
    touch to determine how far it has moved since the last frame. By scaling this
    value and subtracting the vector from the camera's position, the function moves
    the camera as the player drags across the screen. This function also calls upon
    the function to clamp the camera's position.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DragCamera` 函数中，我们使用当前触摸的 `deltaPosition` 值来确定自上一帧以来它移动了多远。通过缩放这个值并从相机的位置减去向量，该函数在玩家在屏幕上拖动时移动相机。此函数还调用了限制相机位置的函数。
- en: '[PRE42]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ClampPosition` function starts by taking the camera's current position.
    It then clamps the z position to be between those of the `leftPoint` and `rightPoint`
    variables' `z` positions. Next, the `y` position is clamped between the `leftPoint`
    and `topPoint` variables' positions. Finally, the new position is reapplied to
    the camera's transform.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClampPosition` 函数首先获取摄像机的当前位置。然后，它将 z 位置限制在 `leftPoint` 和 `rightPoint` 变量的
    `z` 位置之间。接下来，`y` 位置被限制在 `leftPoint` 和 `topPoint` 变量的位置之间。最后，新的位置被重新应用到摄像机的变换中。'
- en: '[PRE43]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, we have the `BackToLeft` function. It starts by using the time and
    our duration variable to determine how much progress in returning to the slingshot
    the camera will have made. It records the camera's current position and uses `Mathf.SmoothStep`
    on both the z and y axes to find a new position that is the appropriate distance
    between the `waitPosition` variable and the `leftPoint` variable. Finally, the
    new position is applied.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有 `BackToLeft` 函数。它首先使用时间和我们的持续时间变量来确定摄像机返回弹弓的进度。它记录摄像机的当前位置，并在 z 和 y 轴上使用
    `Mathf.SmoothStep` 找到一个新的位置，这个位置是 `waitPosition` 变量和 `leftPoint` 变量之间适当距离的位置。最后，应用新的位置。
- en: '[PRE44]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, return to Unity and add the new script to the `Main Camera` object. Connect
    the references to the slingshot and each of the points to finish it off.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，回到 Unity 并将新脚本添加到 `Main Camera` 对象中。连接到弹弓和每个点的引用以完成设置。
- en: Position the camera to point at your pig fortress and turn the whole rig into
    a prefab.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将摄像机定位指向你的猪堡垒，并将整个装置转换成预制件。
- en: '*What just happened?*'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the camera rig that will let the player watch all of the action as
    they play the game. The camera will now follow the birds as they are fired from
    the slingshot and can now be dragged by the player. By keying off the positions
    of a few objects, this movement is limited to keep the player from seeing things
    we don't want them to. If the camera is left idle long enough, it will also return
    to look at the slingshot.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个摄像机装置，让玩家在玩游戏时观看所有的动作。现在，摄像机将跟随从弹弓发射出的鸟，并且现在可以被玩家拖动。通过几个物体的位置来锁定这个动作，以防止玩家看到我们不希望他们看到的东西。如果摄像机闲置时间足够长，它也会返回到观察弹弓的位置。
- en: Have a go hero – more levels
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 更多关卡
- en: Now that we have all of the pieces needed to make a complete level, we need
    some more levels. We need at least two more levels. You can use the blocks and
    pigs to create any level you might want. It is a good idea to keep the pig structures
    centered at about `30` on the **Z** axis. Also, think about the difficulty of
    the level while making it, so that you can end up with an easy, medium, and hard
    level.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了制作完整关卡所需的所有部件，我们需要更多关卡。我们需要至少两个更多关卡。你可以使用方块和猪来创建你想要的任何关卡。保持猪结构在 `Z` 轴大约
    `30` 处是不错的选择。同时，在制作关卡时要考虑难度，这样你就可以得到简单、中等和困难关卡。
- en: A better background
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的背景
- en: A great feature of many 2D games is a parallax scrolling background. This simply
    means that the background is created in layers that scroll by at different speeds.
    Think of it as if looking out the window of your car. The objects that are far
    away appear to hardly move, while the ones that are near move by quickly. In a
    2D game, it gives the illusion of depth and adds a nice touch to the look of the
    game. For this background, we will be layering several materials on a single plane.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 2D 游戏的一个出色功能是透视滚动背景。这仅仅意味着背景是在不同速度下滚动的层中创建的。想象一下，就像从你的汽车窗户向外看。远处的物体几乎不动，而近处的物体则快速移动。在
    2D 游戏中，这会产生深度错觉，并为游戏的外观增添美感。对于这个背景，我们将在单个平面上叠加几个材质。
- en: Time for action – creating the parallax background
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动起来 - 创建透视背景
- en: 'There is an alternative method of creating and utilizing a second camera, but
    ours will make use of a single script that additionally allows us to control the
    speed of each layer:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种创建和利用第二个摄像机的替代方法，但我们的方法将使用一个额外的脚本，该脚本还允许我们控制每个层的速度：
- en: We will start this section with the creation of the `ParallaxScroll` script.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从这个部分的创建 `ParallaxScroll` 脚本开始。
- en: This script starts with three variables. The first two keep track of each material
    and how fast they should scroll. The third keeps track of the camera's last position,
    so we can track how far it moves in each frame.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从三个变量开始。前两个跟踪每个材质及其滚动速度。第三个跟踪摄像机的最后位置，这样我们就可以跟踪它在每一帧中移动的距离。
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the `Start` function, we record the camera's beginning position. We use `Start`
    instead of `Awake` here, in case the camera needs to do any special movement at
    the beginning of the game.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`函数中，我们记录相机的初始位置。我们在这里使用`Start`而不是`Awake`，以防相机需要在游戏开始时进行任何特殊移动。
- en: '[PRE46]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Next, we use the `LateUpdate` function to make changes after the camera has
    moved about. It starts by finding the camera's new position and comparing the
    z axis values to determine how far it moved. Next, it loops through the list of
    materials. The loop first gathers the current offset of its texture using `mainTextureOffset`.
    Next, the camera's movement multiplied by the material's speed is subtracted from
    the offset's x axis to find a new horizontal position. Then, the new offset is
    applied to the material. Finally, the function records the camera's last position
    for the next frame.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`LateUpdate`函数在相机移动后进行更改。它首先找到相机的新的位置，并比较z轴的值以确定它移动了多远。然后，它遍历材质列表。循环首先使用`mainTextureOffset`收集其纹理的当前偏移量。然后，从偏移量的x轴中减去相机移动乘以材质的速度，以找到新的水平位置。然后，将新的偏移量应用到材质上。最后，该函数记录相机在下一帧的最后位置。
- en: '[PRE47]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Return to Unity and create six new materials. One for each of the background
    textures: `sky`, `hills_tall`, `hills_short`, `grass_light`, `grass_dark`, and
    `fronds`. All of the materials, except for the sky, need to use the **Diffuse**
    shader under **Transparent** in the **Shader** drop-down list. If they do not,
    we will not be able to see all of the textures when they are layered.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity并创建六个新的材质。每个背景纹理一个：`sky`、`hills_tall`、`hills_short`、`grass_light`、`grass_dark`和`fronds`。除了天空之外的所有材质，都需要在**着色器**下拉列表中的**透明**下的**漫反射**着色器中使用。如果不这样做，当它们分层时，我们将无法看到所有纹理。
- en: We also need to adjust the **Tiling** of each of these new materials. For all
    of them, leave the **Y** axis as `1`. For the **X** axis, set `5` for the `sky`,
    `6` for `hills_tall`, `7` for `hills_short`, `8` for `grass_dark`, `9` for `fronds`,
    and `10` for `grass_light`. This will offset all of the features of the textures
    so a long pan does not see features regularly lining up.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要调整这些新材料的**平铺**。对于所有这些，将**Y**轴保留为`1`。对于**X**轴，将`5`设置为`sky`，`6`设置为`hills_tall`，`7`设置为`hills_short`，`8`设置为`grass_dark`，`9`设置为`fronds`，`10`设置为`grass_light`。这将使纹理的所有特征偏移，这样在长距离平移时不会看到特征有规律地排列。
- en: Next, create a new plane. Name it `Background` and remove its **Mesh Collider**
    component.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的平面。将其命名为`Background`并移除其**网格碰撞器**组件。
- en: Position it at `-5` on the **X** axis, `7` on the **Y** axis, and `30` on the
    **Z** axis. Set its rotation to `90` for both the **X** and **Y** axes and `0`
    for **Z**. Also, set the scale to `10` for the **X** axis, `1` for the **Y** axis,
    and `1.5` for the **Z** axis. Altogether, these position the plane as facing the
    camera and filling the background.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**X**轴上将其定位为`-5`，在**Y**轴上为`7`，在**Z**轴上为`30`。将**X**轴的旋转设置为`90`，将**Y**轴的旋转设置为`90`，将**Z**轴的旋转设置为`0`。此外，将**X**轴的缩放设置为`10`，将**Y**轴的缩放设置为`1`，将**Z**轴的缩放设置为`1.5`。总的来说，这些位置将平面定位为面向相机并填充背景。
- en: In the plane's **Mesh Renderer** component, expand the **Materials** list and
    set the **Size** to `6`. Add each of our new materials to the list slots in the
    order of `sky`, `hills_tall`, `hills_short`, `grass_dark`, `fronds`, `grass_light`.
    Do the same for the **Materials** list in the **Parallax Scroll** script component.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在平面的**网格渲染器**组件中，展开**材质**列表并将**大小**设置为`6`。按`sky`、`hills_tall`、`hills_short`、`grass_dark`、`fronds`、`grass_light`的顺序将我们的新材料添加到列表槽中。同样，在**视差滚动**脚本组件中的**材质**列表中也进行相同的操作。
- en: Finally, in the **Parallax Scroll** script component, set the **Size** of the
    **Speeds** list to `6` and input the following values in the order of `0.03`,
    `0.024`, `0.018`, `0.012`, `0.006`, `0`. These values will move the materials
    gently and evenly.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**视差滚动**脚本组件中，将**速度**列表的**大小**设置为`6`，并按以下顺序输入以下值：`0.03`、`0.024`、`0.018`、`0.012`、`0.006`、`0`。这些值将使材料平稳均匀地移动。
- en: Turning the background into a prefab, at this point, will make it easy to reuse
    later.![Time for action – creating the parallax background](img/2014OT_07_05.jpg)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，将背景转换为预制件，将便于稍后重用。![行动时间 - 创建视差背景](img/2014OT_07_05.jpg)
- en: '*What just happened?*'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a parallax scroll effect. This effect will pan a series of background
    textures, giving the illusion of depth in our 2D game. To easily see it in action,
    hit play and grab the camera in the **Scene** view, moving it along the z axis
    to see the background change.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个视差滚动效果。此效果将平移一系列背景纹理，给我们的2D游戏带来深度感。为了更容易看到它的效果，按播放并抓取**场景**视图中的相机，沿着z轴移动以查看背景变化。
- en: Have a go hero – dark of the night
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试——夜晚的黑暗
- en: We have two other levels to add backgrounds to. Your challenge here is to create
    your own background. Use the techniques you learned in this section to create
    a night-style background. It could include a stationary moon while everything
    else scrolls in the shot. For an added trick, create a cloud layer that slowly
    pans across the screen as well as with the camera and the rest of the background.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个其他关卡需要添加背景。你的挑战是创建自己的背景。使用你在本节中学到的技术创建一个夜幕风格的背景。它可以包括一个静止的月亮，而其他所有东西都在镜头中滚动。为了增加技巧，创建一个云层，它以缓慢的速度在屏幕上以及与相机和其他背景一起移动。
- en: The flock variety
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群体多样性
- en: 'There is one last set of assets we need to create for our levels, the other
    birds. We will create three more birds that each have a unique special ability:
    a yellow bird that accelerates, a blue bird that splits into multiple birds, and
    a black bird that explodes. With these our flock will be complete.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的关卡创建最后一组资产，即其他鸟。我们将创建另外三只鸟，每只鸟都有独特的特殊能力：一只加速的黄色鸟，一只分裂成多只鸟的蓝色鸟，以及一只爆炸的黑色鸟。有了这些，我们的鸟群就完整了。
- en: To make the creation of these birds easier, we will be making use of a concept
    called **inheritance**. Inheritance allows a script to expand upon the functions
    it is inheriting without the need to rewrite them. If used correctly, this can
    be very powerful and, in our case, will aid in the quick creation of multiple
    characters that are largely similar.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些鸟的创建更容易，我们将利用一个称为**继承**的概念。继承允许脚本在不重写它们的情况下扩展它继承的功能。如果使用得当，这将非常强大，在我们的案例中，将有助于快速创建大量相似的角色。
- en: The yellow bird
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黄色鸟
- en: First, we will create the yellow bird. Largely, this bird functions exactly
    as the red bird. However, when the player touches the screen, the bird's speed
    increases. By extending the `Bird` script that we created earlier, this bird's
    creation becomes quite simple.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建黄色鸟。基本上，这只鸟的功能与红色鸟完全相同。然而，当玩家触摸屏幕时，鸟的速度会增加。通过扩展我们之前创建的`Bird`脚本，这只鸟的创建变得相当简单。
- en: Time for action – creating the yellow bird
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建黄色鸟
- en: 'Because of the power of inheritance, the script we are creating here consists
    of only a handful of lines of code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于继承的力量，我们在这里创建的脚本只有几行代码：
- en: Start by creating the yellow bird in the same way as the red bird, using the
    `YellowBird` model instead.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，以与红色鸟相同的方式创建黄色鸟，使用`YellowBird`模型。
- en: Instead of using the `Bird` script, we will create the `YellowBird` script.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不使用`Bird`脚本，而是创建`YellowBird`脚本。
- en: 'This script needs to extend the `Bird` script, so replace `MonoBehaviour` with
    `Bird` on line four. It should look similar to the following code snippet:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本需要扩展`Bird`脚本，因此需要在第四行将`MonoBehaviour`替换为`Bird`。它应该看起来类似于以下代码片段：
- en: '[PRE48]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This script adds a single variable that will be used to multiply the bird's
    current velocity.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本添加了一个单变量，它将被用来乘以鸟的当前速度。
- en: '[PRE49]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we override the `DoSpecial` function and multiply the bird''s `rigidbody.velocity`
    when it is called:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重写`DoSpecial`函数，并在调用时乘以鸟的`rigidbody.velocity`：
- en: '[PRE50]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Return to Unity, add the script to your new bird, and turn it into a prefab.
    Add some to the list on your slingshot to use the bird in your level.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，将脚本添加到你的新鸟中，并将其转换为预制体。将其添加到弹弓上的列表中，以便在关卡中使用这只鸟。
- en: '*What just happened?*'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the yellow bird. This bird is simple. It directly modifies its velocity
    to suddenly gain a boost of speed when the player touches the screen. As you will
    soon see, we use this same style of script creation to create all of our birds.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了黄色鸟。这只鸟很简单。它直接修改其速度，在玩家触摸屏幕时突然获得速度提升。正如你很快就会看到的，我们使用这种相同的脚本创建风格来创建我们所有的鸟。
- en: The blue bird
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝色鸟
- en: Next, we create the blue bird. This bird splits into three birds when the player
    touches the screen. It will also extend the `Bird` script.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建蓝色鸟。当玩家触摸屏幕时，这只鸟会分裂成三只鸟。它也将扩展`Bird`脚本。
- en: Time for action – creating the blue bird
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建蓝色鸟
- en: 'The blue bird will again make use of inheritance, reducing the amount of code
    that needs to be written to create the bird:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色鸟将再次利用继承，减少创建鸟时需要编写的代码量：
- en: Again, start building your blue bird the same way as the previous two, substituting
    the appropriate model. You should also adjust the **Radius** of the **Sphere Collider**
    component to align appropriately with the smaller size of this bird.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，以与前面两个相同的方式开始构建你的蓝色鸟，替换适当的模型。你还应该调整**Sphere Collider**组件的**Radius**，以便与这只鸟较小的尺寸相匹配。
- en: Next, we create the `BlueBird` script.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`BlueBird`脚本。
- en: Again, adjust line four so the script extends `Bird` instead of `MonoBehaviour`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调整第四行，使脚本扩展到`Bird`而不是`MonoBehaviour`。
- en: '[PRE51]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This script has three variables. The first is a list of prefabs to spawn when
    the bird splits. Next is the angle difference between each new bird that will
    be launched. Finally is a value to spawn the birds a little ahead of their current
    position to keep them from getting stuck inside each other.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本有三个变量。第一个是在鸟分裂时生成预制体的列表。接下来是每个新发射的鸟之间的角度差。最后是一个值，用于在当前位置前方生成鸟，以防止它们互相卡住。
- en: '[PRE52]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, we override the `DoSpecial` function and start, as with the others, by
    marking that we made our special move. Next, it calculates half of the number
    of birds to spawn and creates an empty list for storing the rigidbodies of the
    newly spawned birds.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重写`DoSpecial`函数，并像其他人一样，标记我们已经做出了特殊动作。接下来，它计算要生成的鸟的数量的一半，并为存储新生成的鸟的刚体创建一个空列表。
- en: '[PRE53]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The function continues by looping through the list of birds, skipping the slots
    that are empty. It spawns the new birds at its position, continuing to the next
    if there is a missing **Rigidbody** component. The new **Rigidbody** component
    is then stored in the list.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数继续通过鸟的列表进行循环，跳过空槽位。它在当前位置生成新鸟，如果缺少**Rigidbody**组件，则继续到下一个。然后，新的**Rigidbody**组件被存储在列表中。
- en: '[PRE54]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using `Quaternion.Euler`, a new rotation is created that will angle the new
    bird along a path split off from the main path. The new bird's velocity is set
    to the rotated velocity of the current bird. It is then moved forward along its
    new path to get out of the way of the other birds being spawned.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Quaternion.Euler`创建一个新的旋转，这将使新鸟沿着从主路径分叉的路径旋转。新鸟的速度被设置为当前鸟旋转后的速度。然后它沿着新路径向前移动，以避开正在生成的其他鸟。
- en: '[PRE55]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After the loop, the function uses `FindObjectOfType` to find the slingshot that
    is currently in the scene. If found, it is changed to track the first new bird
    spawned as the one that was fired. The new list of rigidbodies is also set to
    the `rigidbodyDamper` variable to be added to its list of rigidbodies. Finally,
    the script destroys the bird it is attached to, completing the illusion that the
    bird has split apart.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，函数使用`FindObjectOfType`在场景中找到当前存在的弹弓。如果找到，它将改变以跟踪第一个新生成的鸟作为被发射的鸟。新的刚体列表也被设置为`rigidbodyDamper`变量，以便添加到其刚体列表中。最后，脚本销毁其附加的鸟，完成鸟分裂的幻觉。
- en: '[PRE56]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Before you add the script to your new bird, we actually need two blue birds:
    one that splits and one that does not. Duplicate your bird and name one `Bird_Blue_Split`
    and the other `Bird_Blue_Normal`. To the split bird add the new script and to
    the normal bird add the `Bird` script.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将脚本添加到你的新鸟之前，我们实际上需要两只蓝色鸟：一只负责分裂，另一只不分裂。复制你的鸟，将一个命名为`Bird_Blue_Split`，另一个命名为`Bird_Blue_Normal`。将新脚本添加到分裂的鸟上，将`Bird`脚本添加到正常的鸟上。
- en: Turn both birds into prefabs and add the normal bird to the other's list of
    birds to be split into.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两只鸟都转换为预制体，并将正常的鸟添加到另一只鸟的分裂鸟列表中。
- en: '*What just happened?*'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the blue bird. This bird splits into multiple birds when the user
    taps the screen. The effect actually requires two birds that look identical. One
    that does the splitting and another that is split into but does nothing special.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了蓝色鸟。当用户点击屏幕时，这只鸟会分裂成多只鸟。实际上，这个效果需要两只看起来完全相同的鸟。一只负责分裂，另一只被分裂但没有任何特殊动作。
- en: Have a go hero – creating a rainbow bird
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——创建彩虹鸟
- en: It is actually possible to add anything we want to spawn to the blue bird's
    list of things to split into. Your challenge here is to create a rainbow bird.
    This bird could split into different types of birds, not just blue ones. Or, perhaps
    it is a stone bird that splits into stone blocks. For an extended challenge, create
    a mystery bird that picks a bird from its list randomly when it splits.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以将任何我们想要生成的物品添加到蓝色鸟的分裂物品列表中。这里的挑战是创建一只彩虹鸟。这只鸟可以分裂成不同类型的鸟，而不仅仅是蓝色鸟。或者，也许它是一只石头鸟，分裂成石头块。作为一个更高级的挑战，创建一只神秘鸟，当它分裂时，会从其列表中随机选择一只鸟。
- en: The black bird
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑色鸟
- en: Finally, we have the black bird. This bird explodes when the player touches
    the screen. As with all the birds discussed previously, it will extend the `Bird`
    script.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有黑色鸟。当玩家触摸屏幕时，这只鸟会爆炸。和之前讨论的所有鸟一样，它将扩展`Bird`脚本。
- en: Time for action – creating the black bird
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——创建黑色鸟
- en: 'As with the two birds discussed earlier, inheriting from the red bird makes
    the black bird''s creation much easier:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前讨论的两只鸟一样，从红色鸟继承使得黑色鸟的创建变得容易得多：
- en: As with the others, this bird is initially created in the same way as the red
    bird, readjusting the **Radius** for its increased size.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和其他鸟一样，这只鸟最初是以与红色鸟相同的方式创建的，重新调整**半径**以适应其增大的尺寸。
- en: Again, we create a new script to extend the `Bird` script. This time it is called
    `BlackBird`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们创建一个新的脚本以扩展`Bird`脚本。这次它被称为`BlackBird`。
- en: Do not forget to adjust line four to extend the `Bird` script and not `MonoBehaviour`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记调整第四行，以扩展`Bird`脚本而不是`MonoBehaviour`。
- en: '[PRE57]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This script has two variables. The first is the size of the explosion and the
    second is its strength.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本有两个变量。第一个是爆炸的大小，第二个是它的强度。
- en: '[PRE58]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Once more we override the `DoSpecial` function, first marking that we did it.
    Next, we use `Physics.OverlapSphere` to acquire a list of all of the objects that
    are within the range of the bird's explosion. The function then loops through
    the list, skipping any empty slots and those without rigidbodies. If the object
    does exist and has a **Rigidbody** component attached, we call `AddExplosionForce`
    to simulate the way an explosion's strength against you is reduced the further
    you are from it. We give the function the explosion's strength, followed by the
    bird's position and radius. The value `3` is a vertical modifier. It does not
    interfere with the distance an object is from the explosion but, instead, adjusts
    the angle the explosion hits it at. This `3` moves the force to below the object,
    because explosions that throw debris up are cooler than ones that push out. `ForceMode.Impulse`
    is again used to apply the force immediately. Finally, the function destroys the
    exploded bird.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们重写了`DoSpecial`函数，首先标记我们已经做了。接下来，我们使用`Physics.OverlapSphere`获取所有在鸟的爆炸范围内的对象的列表。该函数然后遍历列表，跳过任何空槽位和没有刚体组件的对象。如果对象确实存在并且附加了**Rigidbody**组件，我们调用`AddExplosionForce`来模拟爆炸的强度随着距离的增加而减少。我们给函数提供爆炸的强度，然后是鸟的位置和半径。值`3`是一个垂直修正器。它不会干扰对象与爆炸的距离，而是调整爆炸击中对象的角度。这个`3`将力量移动到对象的下方，因为将碎片抛向天空的爆炸比将其推出去的爆炸更酷。再次使用`ForceMode.Impulse`来立即应用力量。最后，该函数销毁爆炸的鸟。
- en: '[PRE59]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As with the last two, apply your new script to your new bird and turn it into
    a prefab. You now have four birds to choose from when selecting the slingshot
    arsenal for each level.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和前两只一样，将你的新脚本应用到你的新鸟上，并将其转换为预制体。你现在有四只鸟可供选择，当选择每个级别的弹弓武器库时。
- en: '*What just happened?*'
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created our fourth and last bird, the black bird. This bird explodes when
    the user touches the screen, throwing anything that might be near into the sky.
    This can be a fun bird to play around with and effective for destroying your pig
    forts.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了我们的第四只也是最后一只鸟，黑色鸟。当用户触摸屏幕时，这只鸟会爆炸，将附近的所有东西都抛向天空。这是一只很有趣的鸟，可以用来玩耍，并且对于摧毁你的猪堡非常有效。
- en: Have a go hero – explosive blocks
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——爆炸方块
- en: Now that you know how to cause explosions, we have another challenge. Create
    an explosive crate. Extend the `Plank` script to make it. When enough damage is
    done to the crate, trigger the explosion. For an added challenge, instead of making
    the crate explode, configure it to throw out a few bombs that explode when they
    hit something.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何引发爆炸，我们又有了一个新的挑战。创建一个爆炸箱。扩展`Plank`脚本以制作它。当对箱子的伤害足够时，触发爆炸。作为一个额外的挑战，而不是让箱子爆炸，配置它抛出几颗炸弹，当它们撞击到某物时会爆炸。
- en: '![Have a go hero – explosive blocks](img/2014OT_07_06.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![英雄试炼 – 爆炸方块](img/2014OT_07_06.jpg)'
- en: Level selection
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关卡选择
- en: Finally, we need to create our level selection. From this scene, we will be
    able to access and start playing all of the levels we created earlier. We will
    also display the current high scores for each level.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建我们的关卡选择。从这个场景，我们将能够访问并开始玩我们之前创建的所有关卡。我们还将显示每个关卡当前的最高分。
- en: Time for action – creating the level selection
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建关卡选择
- en: 'A new scene and a single script will serve us well in managing our level selection:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的场景和单个脚本将很好地帮助我们管理关卡选择：
- en: This last section begins by saving your current scene and hitting *Ctrl* + *N*
    to create a new one, named `LevelSelect`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这最后一部分首先保存你的当前场景，然后按*Ctrl* + *N*创建一个新的场景，命名为`LevelSelect`。
- en: For this scene, we need to create a single, short script also named `LevelSelect`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个场景，我们需要创建一个单独的、简短的脚本，也命名为`LevelSelect`。
- en: The first and only variable defines the size of the buttons that will appear
    on screen.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个且唯一的变量定义了将出现在屏幕上的按钮大小。
- en: '[PRE60]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The only function is the `OnGUI` function. This function starts with a loop.
    It will loop through three times for the three levels we should have created earlier.
    A `Rect` variable is created and initialized to the `buttonSize`. The x and y
    values are then set to position the buttons in a row, centered on the screen.
    Next, the current high score for the level is retrieved, using `PlayerPrefs.GetInt`
    and the same key creation that we used in our `LevelTracker` script. Then, the
    function creates a string to hold the message that will appear on the button.
    Finally, the button is drawn and, when clicked, `Application.LoadLevel` is used
    to load the scene and start the user playing that level.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一的功能是`OnGUI`函数。这个函数从一个循环开始。它将循环三次，对应于我们之前应该创建的三个关卡。创建了一个`Rect`变量并将其初始化为`buttonSize`。然后设置x和y值以将按钮排成一行，居中在屏幕上。接下来，使用`PlayerPrefs.GetInt`和我们在`LevelTracker`脚本中使用的相同键创建方法检索当前关卡的最高分。然后，函数创建一个字符串来保存将出现在按钮上的消息。最后，绘制按钮，当点击时，使用`Application.LoadLevel`加载场景并开始用户玩该关卡。
- en: '[PRE61]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Return to Unity and add the script to the `Main Camera` object.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity并将脚本添加到`Main Camera`对象。
- en: Finally, open the **Build Settings** and add your scenes to the **Scenes in
    Build** list. Clicking and dragging on the scenes in the list will let you reorder
    them. Make sure your **LevelSelect** scene is first and has the index of zero
    to the right of it. The rest of your scenes can appear in whatever order you desire.
    But be aware that they will be associated with the buttons in the same order.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开**构建设置**并将你的场景添加到**构建中的场景**列表中。在列表中点击并拖动场景可以重新排列它们。确保你的**LevelSelect**场景排在第一位，并且它的索引为零。其余的场景可以按照你希望的任何顺序出现。但请注意，它们将与按钮以相同的顺序关联。
- en: '*What just happened?*'
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a level-selection screen. It uses a loop to create a list of buttons
    associated with the levels in our game. When a button is pressed, `Application.LoadLevel`
    starts that level. We also made use of `PlayerPrefs.GetInt` to retrieve the high
    scores for each of the levels.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个关卡选择屏幕。它使用循环创建与游戏中的关卡关联的按钮列表。当按下按钮时，`Application.LoadLevel`启动该关卡。我们还使用了`PlayerPrefs.GetInt`来检索每个关卡的最高分。
- en: Have a go hero – adding some style
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼 – 添加一些风格
- en: Here, the challenge is to use GUI styles to make the screen look great. A logo
    and a background would help a lot. Additionally, take a look at `GUI.BeginScrollView`
    if you have more than three levels. This function will let the user scroll through
    a list of levels that is far greater in size than can be easily seen on screen.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，挑战是使用GUI样式使屏幕看起来很棒。一个标志和背景会有很大帮助。此外，如果你有超过三个关卡，请查看`GUI.BeginScrollView`。这个函数将使用户能够滚动查看一个关卡列表，其大小远大于屏幕上容易看到的。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about physics in Unity and recreated the incredibly
    popular mobile game, Angry Birds. By using Unity's physics system, we are able
    to make all of the levels that we could ever want to play. With this game, we
    also explored options for creating a 2D game in a 3D environment. Our birds and
    slingshot are 3D assets, giving us the ability to light and shade them. The pigs
    and the background, however, are 2D images, reducing our lighting options, but
    can allow for some greater detail in the assets. The 2D images were also crucial
    in the creation of the parallax scrolling effect of the background. Finally, the
    building's blocks appear to be 2D, but are actually 3D blocks. We also created
    a level-selection screen. From there, the player can see their high scores and
    pick any of the levels that we created to play.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在Unity中使用物理知识，并重新制作了广受欢迎的移动游戏《愤怒的小鸟》。通过使用Unity的物理系统，我们能够制作出我们想要玩的所有关卡。在这个游戏中，我们还探索了在3D环境中创建2D游戏的可能性。我们的鸟和弹弓是3D资产，这使得我们能够对它们进行光照和阴影处理。然而，猪和背景是2D图像，这减少了我们的光照选项，但可以在资产中提供一些更详细的细节。2D图像在创建背景的视差滚动效果中也至关重要。最后，建筑块看起来是2D的，但实际上是3D块。我们还创建了一个关卡选择屏幕。从那里，玩家可以看到他们的高分，并选择我们创建的任何关卡来玩。
- en: In the next chapter, we return to the Space Fighter game we started in the previous
    chapter. We are going to create and add all of the special effects that finish
    off a game. We will add the shooting and explosion sound effects that every space
    game needs. We will also add various particle effects. When ships are shot at,
    they will actually explode, rather than just disappearing.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到上一章开始的空间战斗机游戏。我们将创建并添加所有完成游戏的特殊效果。我们将添加每个太空游戏都需要的开火和爆炸音效。我们还将添加各种粒子效果。当船只被射击时，它们实际上会爆炸，而不仅仅是消失。
