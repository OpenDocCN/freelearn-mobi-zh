- en: Chapter 7. Throwing Your Weight Around – Physics and a 2D Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we learned about the special features of a mobile
    device and how to create touch and tilt controls. We also created a Space Fighter
    game to use these new controls. The steering of the ship was done by tilting the
    device and shooting by touching the screen. Using some special movement tricks,
    we gave the player an infinite amount of space to fly and enemies to fight.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter, we take a short break from the Space Fighter game to explore
    Unity''s physics engine. We will also take a look at options for creating a 2D
    game experience. To do all of this, we will be recreating one of the most popular
    mobile games on the market, Angry Birds. We will use physics to throw birds and
    destroy structures. We will also take a look at the creation of a level-selection
    screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unity Physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallax scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isometric camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be creating a new project for this chapter, so start up Unity and let's
    begin!
  prefs: []
  type: TYPE_NORMAL
- en: 2D games in a 3D world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most underrealized thing when developing games is the fact that
    it's possible to create 2D-style games in a 3D game engine such as Unity. As with
    everything else, it comes with its own set of advantages and disadvantages, but
    the choice can be well worth it for generating a pleasing game experience. The
    foremost of the advantages is that one can use 3D assets for the game. This allows
    dynamic lighting and shadows to be easily included. However, if using a 2D engine,
    any shadow would need to be painted directly into the assets and you would be
    hard-pressed to make it dynamic. On the disadvantage side is the use of 2D assets
    in the 3D world. It is completely possible to use them, but large file sizes become
    necessary to achieve the desired detail and keep it from appearing pixelated.
    Most 2D engines, however, make use of vector art that will keep the image's lines
    smooth as it is scaled up and down. Also, one is able to use normal animations
    for the 3D assets, but frame-by-frame animation is generally required for any
    2D asset. Altogether, the advantages have outweighed the disadvantages for many
    developers, creating a large selection of great looking 2D games that you may
    never realize were actually made in a 3D game engine. Now, we shall design another
    game by recreating the highly popular Angry Birds.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – preparing the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with preparing the world for the Angry Birds game:'
  prefs: []
  type: TYPE_NORMAL
- en: To start it all off, we need to create a new project in Unity. Naming it `Ch7_AngryBirds`
    will work well. Be sure to change the target platform to **Android** and set the
    **Bundle Identifier** to an appropriate value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, import the starting assets for this chapter and create some folders to
    keep everything organized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, it is very easy to turn a game from 3D to 2D. Simply select the **Main
    Camera** object that is by default present in every new scene, find the **Projection**
    value, and select **Orthographic** from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Every camera has two options for how to render the game. **Perspective** renders
    everything utilizing the distance from the camera, imitating the real world; objects
    that are farther away from the camera are drawn smaller than objects that are
    closer. **Orthographic** renders everything without this consideration; objects
    are not scaled based on their distance from the camera.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initially, the amount of the scene that the camera views is far too large. To
    change this, set the **Size** value to `5`. This reduces the amount of space the
    camera will render. This value will keep us focused on the action as the game
    is played.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the camera properly usable, set its **Position** to `10` for the **X**
    axis, `3` for the **Y** axis, and `0` for the **Z** axis. Also, set its **Rotation**
    for the **Y** axis to `-90`. Everything is going to be positioned along the z
    axis, so our camera needs to be set to watch the axis and be far away enough so
    that it is not in the action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we are going to need a ground. So, go to the menu bar of Unity and click
    on **GameObject**, followed by **Create Other**, and finally, click on **Cube**.
    This will suit well enough as a simple ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make it look a little like a ground, create a green material and apply it
    to the **Cube**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ground cube needs to be large enough to cover the whole of our field of
    play. To do this, set its **Scale** to `5` for the **X** axis, `10` for the **Y**
    axis, and `100` for the **Z** axis. Also, set its **Position** to `0` for the
    **X** and **Y** axes, and `30` for the **Z** axis. Since nothing will be moving
    along the x axis, the ground only needs to be large enough for the other objects
    that will be in our scene to land on. It does, however, need to be wide and tall
    enough to keep the camera from seeing the edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right now, the ground looks rather dark due to the lack of light. From the menu
    bar of Unity, click on **GameObject**, followed by **Create Other**, and lastly
    click on **Directional Light** to add some brightness to the scene. It should
    be positioned to shine on the side of the cube that faces the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to keep all of the objects that will be flying around the scene
    from straying too far and causing problems. To do this, we need to create some
    trigger volumes. The simplest way to do this is to create three more cubes. Position
    one at each end of the ground object and the last cube at about 50 units above.
    Then, scale them to form a box with the ground. Each should be no thicker than
    a single unit, and they need to be five units deep, the same as the ground. Next,
    remove their **Mesh Renderer** and **Mesh Filter** components. This removes the
    visible box, while leaving the collider volume. To change them to trigger volumes,
    check the **Is Trigger** checkbox on each **Box Collider** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the volumes actually keep objects from straying too far, we need to
    create a new script. Create it and name it `GoneTooFar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script has a single, short function, `OnTriggerEnter`. We use it to destroy
    any object that might enter the volume. This function is used by Unity's physics
    system to detect when an object has entered a trigger volume. We will go into
    more detail later but, for now, know that one of the two objects, either the volume
    or the object entering it, needs a **Rigidbody** component. In our case, everything
    we might want to remove when they enter the trigger will have a **Rigidbody**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, return to Unity and add the script to the three trigger-volume objects.![Time
    for action – preparing the world](img/2014OT_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We did the initial setup for our 2D game. By changing our camera view to **Orthographic**,
    the view switches from a 3D game to a 2D one. We also created a ground and some
    trigger volumes for our scene. Together, these will keep our birds and anything
    else from straying too far.
  prefs: []
  type: TYPE_NORMAL
- en: Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, physics simulation primarily focuses on the use of the **Rigidbody**
    component. When the **Rigidbody** component is attached to any object, it will
    be taken over by the physics engine. The object will fall with gravity and bump
    into any object that has a collider. In our scripts, making use of the `OnCollision`
    function and the `OnTrigger` function requires a **Rigidbody** component to be
    attached to at least one of the two interacting objects. However, a **Rigidbody**
    component can interfere with any specific movement we might cause the object to
    take. Every **Rigidbody**, though, can be marked as kinematic, meaning the physics
    engine will not move it. The **CharacterController** component that we used for
    our tank is a special, modified **Rigidbody**. In this chapter, we will be making
    heavy use of the **Rigidbody** component to tie all of our birds, blocks, and
    pigs into the physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our first physics objects, we will create the blocks that the pig castles
    are built out of. We will be creating three types of blocks: wood, glass, and
    rubber. With these few simple blocks, we will be able to easily create a large
    variety of levels and structures to smash with birds.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating planks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of the blocks we will be creating will be largely similar:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create the plank of wood. To do this, we need another cube. Rename
    it `Plank_Wood`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the plank's **Scale** to `2` for the **X** and **Y** axes, and `0.25` for
    the **Z** axis. Its scale on the y and z axis define its size as seen by the player.
    The scale on the x axis makes sure that it will be hit by other physics objects
    in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a new material using the `plank_wood` texture and apply it to the
    cube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To convert this new wood plank into a physics object, add a **Rigidbody** component.
    Make sure your plank is selected, go to the menu bar of Unity and click on **Component**,
    followed by **Physics**; finally, click on **Rigidbody**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to keep the plank from moving along the x axis and out of alignment
    with our other physics objects as well as keeping it from rotating to show its
    other sides to the player. To do this, we make use of the **Constraints** group
    of checkboxes on the **Rigidbody** component. Check the checkbox for the **X**
    axis next to **Freeze Position** and the **Y** and **Z** checkboxes next to **Freeze
    Rotation**. These will keep the object from moving in ways we don't want it to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the plank function properly within our game, we need to create a new
    script and name it `Plank`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script begins with a bunch of variables. The first two are for tracking
    the health of the plank. We need to separate the total amount of health from the
    current health, so we will be able to detect when the object has been reduced
    to half health. At that point, we will make use of our next three variables to
    change the object's material to one that shows damage. The last variable is used
    when the object runs out of health and is destroyed. We will use it to increase
    the player's score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the script's first function, we use `Awake` for initialization. We make
    sure the object's current health is the same as its total health, and we make
    sure the `didSwap` flag is set to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we make use of the `OnCollisionEnter` function. This is a special function,
    triggered by the **Rigidbody** component, that gives us information about what
    the object collided with and how. We use this information to find `collision.relativeVelocity.magnitude`.
    This is the speed at which the objects collided, and we use it as damage to reduce
    the current health. Next, the function checks to see if the health has been reduced
    to half and calls the `SwapToDamaged` function if it has. By using the `didSwap`
    flag, we make sure the function will only be called once. Finally, for the function,
    it checks to see if the health has dropped below zero. If it has, the object is
    destroyed and we call the `LevelTracker` script, which we will soon be making,
    to add to the player's score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally for the script, we have the `SwapToDamaged` function. It starts by setting
    the `didSwap` flag to `true`. Next, it checks to make sure the `plankRenderer`
    and `damageMaterial` variables have references to other objects. Ultimately, it
    uses the `plankRenderer.sharedMaterial` value to change to the damaged looking
    material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we can add our `Plank` script to our objects, we need to create the `LevelTracker`
    script that was mentioned earlier. Create it now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script is fairly short and starts with a single variable. The variable
    will track the player's score for the level and is `static` so that it can be
    easily changed as objects are destroyed for points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we use the `Awake` function to make sure the player starts at zero when
    beginning a level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally for the script, we add the `AddScore` function. This function simply
    takes the amount of points passed to it and increases the player's score. It is
    also `static`, so that it can be called by any object in the scene without needing
    a reference to the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in Unity, we need to create a new material using the `plank_wood_damaged`
    texture. This will be the material that the script will swap to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Plank` script to our `Plank_Wood` object. Connect the **Damaged Material**
    reference to the new material and the **Plank Renderer** reference to the object's
    **Mesh Renderer** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we create different types of planks, we can adjust the **Total Health** value
    to give them different strengths. A value of `25` works pretty well for the wood
    planks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create an empty **GameObject** and rename it `LevelTracker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `LevelTracker` script to the object and it will begin to track the player's
    score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to see the wood plank in action, position it above the ground and
    hit the play button. As soon as the game starts, Unity's physics will take over
    and drop the plank with gravity. If it started out high enough, you will be able
    to see it switch textures as it loses health.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the other two planks that we need, select the `Plank_Wood` object and
    press *Ctrl* + *D* twice to duplicate it. Rename one to `Plank_Glass` and the
    other to `Plank_Rubber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create three new materials. One should be purple for the rubber plank,
    one should use the `plank_glass` texture for the glass plank, and the last material
    should use the `plank_glass_damaged` texture for when the glass plank is damaged.
    Apply the new materials to the proper locations for the new planks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As for the health of the new planks, a value of `15` for the glass and `100`
    for the rubber will work well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, turn your three planks into prefabs and use them to build a structure
    for us to knock down. Feel free to scale them to make different-sized blocks,
    but leave the x axis alone. Also, all of the blocks should be positioned at zero
    on the x axis and your structure should be centered around about `30` on the z
    axis.![Time for action – creating planks](img/2014OT_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the building blocks we needed for the structures that are going to
    be knocked down in our game. We used a **Rigidbody** component to tie them into
    the physics engine. Also, we created a script that keeps track of their health
    and swaps materials when it drops below half.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – creating a stone block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wood and glass work well as basic blocks. But, if we are going to make harder
    levels, we need something a little stronger. Try your hand at making a stone block.
    Create two textures and materials for it to show its pristine and damaged states.
  prefs: []
  type: TYPE_NORMAL
- en: Physics materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Physics materials are special types of materials that specifically tell the
    physics engine how two objects should interact. This does not affect the appearance
    of an object. It defines the friction and bounciness of a collider. We will use
    them to give our rubber plank some bounce and the glass plank some slide.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – sliding and bouncing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Physics materials are quick enough to implement and will allow us to complete
    this section in four short steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Physics materials are created like everything else, in the **Project** panel.
    Right-click inside the **Project** panel and click on **Create** | **Physic Material**.
    Create two physic materials and name one `Glass` and the other `Rubber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select one of them and take a look at it in the **Inspector** window. Right
    now, we are only concerned with the first three values. The others are used for
    more complex situations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dynamic Friction**: This property is the amount of friction used when the
    object is moving. A value of zero is no friction, such as ice, and a value of
    one is a lot of friction, such as rubber.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static Friction**: This property functions the same as **Dynamic Friction**,
    the difference being that it is used when the object is not moving.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounciness**: This property is how much of an object''s energy is reflected
    when it hits something or is hit by something. Zero means none of the energy is
    reflected, while a value of one will reflect all of it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `Glass` material, set the two friction values to `0.1` and **Bounciness**
    to `0`. For the `Rubber` material, set the two friction values to `1` and **Bounciness**
    to `0.8`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select your `Plank_Glass` prefab and take a look at its **Box Collider**
    component. To apply your new physics materials, simply drag-and-drop one from
    the **Project** to the **Material** slot. Do the same for your `Plank_Rubber`
    prefab and, any time an object hits one of them, the materials will be used to
    control their interaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a pair of physics materials. They control how two colliders interact
    when they run into each other. Using them, we are given control over the amount
    of friction and bounciness that is possessed by any collider.
  prefs: []
  type: TYPE_NORMAL
- en: Characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a bunch of generic blocks is just the beginning of this game. Next, we
    are going to create a few characters to add some life to the game. We are going
    to need some evil pigs to destroy and some good birds to throw at them.
  prefs: []
  type: TYPE_NORMAL
- en: The enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first character will be the enemy pig. On their own, they don't actually
    do anything. So, they are really just the wooden blocks we made earlier that happen
    to look like pigs. To make their destruction the goal of the game, however, we
    are going to expand our `LevelTracker` script to watch them and trigger a Game
    Over event if they are all destroyed. We will also expand it to draw the score
    on the screen and make it save the score for later use. To demonstrate the use
    of 2D assets in the 3D environment, the pigs are also created as flat textures.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the pigs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with creating the pigs for the Angry Birds game:'
  prefs: []
  type: TYPE_NORMAL
- en: The pigs are created in a manner similar to that of the the wood planks. Start
    by creating an empty **GameObject** and naming it `Pig`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a plane, make it a child of the `Pig` object, and remove its **Mesh
    Collider** component. We do this because of the rotation the plane will need to
    face the camera. Being a child of the empty **GameObject** allows us to ignore
    that rotation when working with the pig.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the plane's local **Position** to `0` on each axis and set its **Rotation**
    to `90` on the **X** axis, `270` on the **Y** axis, and `0` on the **Z** axis.
    This will make the plane face the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create two materials. Name one `Pig_Fresh` and the other `Pig_Damage`.
    From their **Shader** drop-down list, select **Transparent**, followed by **Cutout**,
    and finally **Soft Edge Unlit**. This allows us to make use of the the texture's
    alpha channel and provide some transparency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish off the materials by adding the `pig_damage` and `pig_fresh` textures
    to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the `Pig` object, add a **Sphere Collider** component, a **Rigidbody** component,
    and the `Plank` script. We make use of the **Sphere Collider** component, rather
    than the **Mesh Collider** component the plane came with, because the plane has
    zero thickness and will, therefore, have many issues colliding with other objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To complete the pig's creation, apply your material to the plane and connect
    the references in the `Plank` script. Finally, set the **Constraints** parameters
    on the **Rigidbody** component just as we did for the other planks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, turn the pig into a prefab and add it to your structure. Remember, leave
    them at zero on the x axis, but feel free to adjust their size, health, and score
    values to give them some variety.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to expand the `LevelTracker` script. Open it up and we can add
    some more code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we add some more variables at the beginning of the script. The first
    one, as its name suggests, will hold a list of all the pigs in our scene. Next
    is a flag for signaling that the game has ended. And finally, a string for telling
    the player why the game has ended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to add a line to the `Awake` function. This simply makes sure
    that the `gameOver` flag is `false` when the level starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `OnGUI` function to draw a Game Over screen when the game has ended,
    or for drawing the current score if it is still continuing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DrawScore` function takes the current score and uses `GUI.Label` to draw
    it in the top-right corner of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `DrawGameOver` function first uses the `GUI.Box` function to draw a dark
    box over the whole of the screen, simultaneously drawing the Game Over message
    on the screen. Next, it draws the player''s final score in the middle of the screen.
    Below that, it draws a button. This button will save the player''s current score
    and load the level-selection screen we will create later. The `Application.LoadLevel`
    function is used to load any other scene in your game. All of the scenes you intend
    to load have to be added to the **Build Settings** window found in the **File**
    menu and can be loaded by using either their name or their index, as used here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `LateUpdate` function, we call another function to check whether all
    the pigs have been destroyed if the game is not yet over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we add the `CheckPigs` function. This function loops through the list
    of pigs to see if they are all destroyed. Should it find one that is still around,
    it exits the function. Otherwise, the game is flagged as being over and the message
    is set to tell the player that they succeeded in destroying all of the pigs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `OutOfBirds` function will be called by the slingshot we are going to create
    later, when the player runs out of birds to launch at the pigs. If the game has
    not yet ended, the function ends the game and sets an appropriate message for
    the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we have the `SaveScore` function. Here, we use the `PlayerPrefs` class.
    It lets us easily store and retrieve small amounts of data, perfect for our current
    needs. We just need to provide it with a unique key to save the data under. For
    that, we use a short string combined with the level's index as provided by `Application.loadedLevel`.
    Next, we use `PlayerPrefs.GetInt` to retrieve the last score that was saved. If
    there isn't one, the zero that we passed to the function is returned as a default
    value. Finally, we compare the new score with the old score and use `PlayerPrefs.SetInt`
    to save the new score if it is higher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in Unity, the pigs need to be added to the `LevelTracker` script's list.
    With the `LevelTracker` script selected, drag-and-drop each pig to the `Pigs`
    value in the **Inspector** window to add them.![Time for action – creating the
    pigs](img/2014OT_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the pigs and updated our `LevelTracker` script to track them. The
    pigs are really just like the planks of wood, but are spheres instead of boxes.
    The updated `LevelTracker` script watches for the instance when all of the pigs
    are destroyed and triggers a Game Over screen when they are. It also handles the
    drawing of the score while the game is being played and the saving of that score
    when the level is over.
  prefs: []
  type: TYPE_NORMAL
- en: The ally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need something to throw at the pigs and their fortification. Here,
    we will create the simplest of the birds. The red bird is essentially just a rock.
    He has no special powers and nothing particularly special about his code, besides
    health. You will also notice that the bird is a 3D model, giving it the shadows
    that the pigs are missing.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the red bird
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with creating the red bird:'
  prefs: []
  type: TYPE_NORMAL
- en: Although the red bird model is 3D, it is set up in a manner similar to that
    of the pig. Create an empty **GameObject**, naming it `Bird_Red`, and add the
    appropriate model from the `birds` model as a child, zeroing out its position.
    The model should be rotated to align it along the z axis. If turned a little more
    toward the camera, the player is able to see the bird's face while still giving
    the impression of looking down the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, give it a **Sphere Collider** component and a **Rigidbody** component,
    and set the **Constraints** parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to create a new script named `Bird`. This script will be a base
    for all of our birds, tracking their health and triggering their special powers
    when appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It starts with two variables. The first will keep track of the bird's current
    health. The second is a flag so that the bird will only use its special power
    once. It is marked as `protected` so the class that extends this script can use
    it while keeping it from interference from outside the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Update` function does three checks before activating the bird's special
    power. First, it checks whether it has already been done, then whether the screen
    has been touched, and finally whether the bird has a **Rigidbody** component and
    that it is not being controlled by another script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the case of the red bird, the `DoSpecial` function only sets its flag to
    `true`. It is marked as `virtual` so that we can override the function for the
    other birds and make them do some fancier things.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `OnCollisionEnter` function works just like the one for the planks, subtracting
    health based on the strength of the collision and destroying the bird if it runs
    out of health.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to Unity and add the script to the `Bird_Red` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the bird's creation by turning it into a prefab and deleting it from
    the scene. The slingshot we will be creating soon will handle the creation of
    the birds when the game starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the red bird. It is set up just like our other physics objects. We
    also created a script to handle the bird's health that is expanded later, when
    we create the other birds for our game.
  prefs: []
  type: TYPE_NORMAL
- en: Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we are going to give the player the ability to interact with the game.
    First, we will create a slingshot to throw the birds. Following that will be the
    creation of the camera controls. We will even create a nice background effect
    to round out the look of our game.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To attack the pig fortress, we have our basic bird ammo. We need to create a
    slingshot to hurl that ammo at the pigs. It will also handle the spawning of the
    birds at the beginning of the level and automatically reload as birds are used.
    When the slingshot runs out of birds it will notify the `LevelTracker` script
    and the game will end. Finally, we will create a script that will keep the physics
    simulation from going on for too long. We don't want the player forced to sit
    and watch a pig slowly roll across the screen. So, the script will, after a little
    while, start damping the movement of the **Rigidbody** components to make them
    stop rather than keep rolling.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the slingshot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the slingshot''s appearance will actually be an optical illusion:'
  prefs: []
  type: TYPE_NORMAL
- en: To start off the creation of the slingshot, add the `slingshot` model to the
    scene and position it at the origin. Apply a light brown material to the `Fork`
    model and a dark brown one to the `Pouch` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need four empty **GameObject**. Make them all the children of the `Slingshot`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the first `FocalPoint` and center it between the fork prongs of the slingshot.
    This will be the point through which we fire all of the birds.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is `Pouch`. Make the `pouch` model a child of this object, setting
    its position to `0.5` on the **X** axis and `0` on the **Y** and **Z** axes. This
    will make the pouch appear in front of the current bird without having to make
    a complete pouch model.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Third is `BirdPoint`; this will position the bird that is being fired. Make
    it a child of the `Pouch` point and set its position to `0` on the **X** and **Y**
    axes and `0.3` on the **Z** axis.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Last is `WaitPoint`; the birds waiting to be fired will be positioned behind
    this point. Set its position to `0` for the **X** axis, `0.5` for the **Y** axis,
    and `-4` for the **Z** axis.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, rotate the `Fork` model so that we can see both prongs of the fork. The
    values of `270` for the **X** axis, `25` for the **Y** axis, and `0` for the **Z**
    axis will work well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Slingshot` script will provide most of the interaction for the player.
    Create it now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start it with a group of variables. The first will keep a reference to the
    damper that was mentioned earlier. The second group keeps track of the birds that
    will be used in the level. Next is a group of variables that will track the current
    bird that is ready to be fired. Fourth, we have some variables to hold references
    to the points we created a moment ago. The `maxRange` variable is the distance
    from the focal point to which the player can drag the pouch. The last two variables
    define how powerfully the bird will be launched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with our other scripts, we use the `Awake` function for initialization. The
    `levelBirds` variable will hold references to all of the `bird` prefabs that will
    be used in the level. We start by creating an instance of each one and storing
    it in the `currentBirds` variable. The `isKinematic` variable is set to `true`
    on each bird's **Rigidbody** so that it does not move when it is not in use. Next,
    it readies the first bird to be fired and, finally, it positions the remaining
    birds behind the `waitPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ReadyNextBird` function first checks to see if we have run out of birds.
    If so, it calls the `LevelTracker` script to trigger the Game Over event. The
    `nextIndex` variable tracks the current location of the birds in the list to fire
    at the player. Next, the function checks to make sure the next slot actually has
    a bird, incrementing the index and trying for a new bird if it does not have one.
    If there is a bird available, it is stored in the `toFireBird` variable and made
    a child of the `BirdPoint` object we created; its position and rotation are zeroed
    out. Finally, the firing and aiming flags are reset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SetWaitingPositions` function uses the position of the `waitPoint` to position
    all of the remaining birds behind the slingshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Update` function starts by checking to see if the player has fired a bird
    and watches the `rigidbodyDamper.allSleeping` variable to see if all of the physics
    objects have stopped moving. Once they do, the next bird is readied to fire. If
    we have not fired, the aiming flag is checked and the `DoAiming` function is called
    to handle the aiming. If the player is neither aiming nor has just fired a bird,
    we check for touch input and, if the player touches close enough to the focal
    point, we flag that the player has started aiming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DoAiming` function checks to see if the player has stopped touching the
    screen and fires the current bird when they have. If they have not, we position
    the pouch at the current touch point. Finally, the pouch's position is limited
    to keep it within the maximum range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GetTouchPoint` function uses `ScreenPointToRay` to find out where the player
    is touching in 3D space. This is just as when we were shooting asteroids but,
    because this game is 2D, we can just look at the ray's origin and return it with
    a zero for its x axis value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, for this script, we have the `FireBird` function. This function starts
    by setting our `didFire` flag to `true`. Next, it finds out the direction to fire
    by finding the direction from the pouch's position to the `focalPoint`. It also
    uses the distance between them to determine the power to fire the bird with, clamping
    it between our min and max strengths. Then, it releases the bird by clearing its
    parent and setting its `isKinematic` flag to `false`. To launch it, we use the
    `rigidbody.AddForce` function and pass the direction multiplied by the power to
    it. `ForceMode.Impulse` is also passed to make the force applied once and immediately.
    Next, the pouch is positioned at the `focalPoint`, as if it were actually under
    tension. And finally, we call `rigidbodyDamper.ReadyDamp` to start the damping
    of the `Rigidbody` movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we can make use of the `Slingshot` script, we need to create the `RigidbodyDamper`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script starts with six variables. The first two define how long to wait
    before the damping movement and how much to damp it by. The next two track whether
    it can apply the damping and when it will start. Next, is a variable that will
    be filled with a list of all the rigidbodies that are currently in the scene.
    Finally, it has the `allSleeping` flag that will be set to `true` when the movement
    has stopped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ReadyDamp` function starts by using `FindObjectsOfType` to fill the list
    with all of the rigidbodies. It sets when to start damping as the sum of the current
    time and the wait length. It marks that the script can do its damping and resets
    the `allSleeping` flag. Finally, it uses `StartCoroutine` to call the `CheckSleepingRigidbodies`
    function. This is a special way of calling functions to make them run in the background
    without blocking the rest of the game from running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `FixedUpdate` function, we first check to see if we can damp the movement
    and whether it is time to do it. If it is, we loop through all of the rigidbodies,
    applying our damp to each one's rotational and linear velocity. Those that are
    kinematic, controlled by scripts, and already sleeping, meaning they stopped moving,
    are skipped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `CheckSleepingRigidbodies` function is special and will run in the background.
    This is made possible by the `IEnumerator` flag at the beginning of the function
    and the `yield return null` line in the middle. Together, these allow the function
    to pause regularly and keep from freezing the rest of the game while it waits
    for the function to complete. The function starts by creating a check flag and
    using it to check if all of the rigidbodies have stopped moving. If one is found
    still moving, the flag is set to `false` and the function pauses until the next
    frame, when it will try again. When it reaches the end, because all of the rigidbodies
    are sleeping, it sets the `allSleeping` flag to `true`, so that the slingshot
    can ready the next bird. It also stops itself from damping while the player is
    getting ready to fire the next bird.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we have the `AddBodiesToCheck` function. This function will be used
    by anything that spawns new physics objects after the player has fired the bird.
    It starts by creating a temporary list and expanding the current one. Next, it
    adds all of the values from the temporary list to the expanded one. Finally, the
    list of rigidbodies is added after those of the temporary list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to Unity and add the two scripts to the `Slingshot` object. On the `Slingshot`
    script component, connect the references to the **Rigidbody Damper** component
    and each of the points. Also, add to the **Level Birds** list as many references
    to the red bird as you want for the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep objects from rolling back and through the slingshot, create a **Box
    Collider** component and position it at the stock of the `Fork` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish off the look of the slingshot, we need to create the elastic bands
    that tie the pouch to the fork. We will do this by first creating the `SlingshotBand`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script starts with two variables. One for the point that the band will end
    at and one to reference the `LineRenderer` that will draw it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Awake` function makes sure the `lineRenderer` variable has only two points
    and sets their initial positions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `LateUpdate` function, we set the `lineRenderer` variable's end position
    to the `endPoint` value. This point will move around with the pouch, so we need
    to constantly update the renderer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to Unity and create an empty **GameObject**. Name it `Band_Near` and
    make it a child of the `Slingshot` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As children of this new point, create a cylinder and a second empty **GameObject**,
    named `Band`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the cylinder a brown material and position it near the prong of the slingshot
    fork.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the `Band` object, add a **Line Renderer** component found under **Effects**
    in the **Component** menu. After positioning it in the center of the cylinder,
    add the `SlingshotBand` script to the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the **Line Renderer** under **Materials**, you can put your brown material
    in the slot to color the band. under **Parameters**. Set the **Start Width** to
    `0.5` and the **End width** to `0.2` to set the size of the line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create one more empty **GameObject** and name it `BandEnd_Near`. Make
    it a child of the `Pouch` object and position it inside the pouch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, connect the script's references to its line renderer and end point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the second band, duplicate the four objects we just created and position
    them far from the prong of the fork. The end point for this band can just be moved
    back along the x axis to keep it out of the way of the birds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, turn the whole thing into a prefab so it can be easily reused in other
    levels.![Time for action – creating the slingshot](img/2014OT_07_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the slingshot that will be used to fire birds. We used techniques
    we learned in the previous chapter to handle touch input and track the player's
    finger while they aim and shoot. If you save your scene and position the camera
    to look at the slingshot, you will notice that it is complete if not entirely
    playable. Birds can be fired at the pig fortress, although we can only see the
    destruction from within Unity's **Scene** view.
  prefs: []
  type: TYPE_NORMAL
- en: Watching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game is technically playable at this point, but it is kind of hard to see
    what is going on. Next, we will create a system to control the camera. It will
    allow the player to drag the camera left and right, follow the bird when it is
    launched and return to the slingshot when everything stops moving. There will
    also be a set of limits to keep the camera from going too far and viewing things
    we do not want the player to see.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – controlling the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will only need one, fairly short script to control and manage our camera:'
  prefs: []
  type: TYPE_NORMAL
- en: To start and to keep everything organized, create a new empty **GameObject**
    and name it `CameraRig`. Also, to keep it simple, set its position to zero on
    each axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create three more empty **GameObject** and name them `LeftPoint`, `RightPoint`,
    and `TopPoint`. Set their **X** axis positions to `5`. Position the `LeftPoint`
    to be in front of the slingshot and at `3` on the **Y** axis. The `RightPoint`
    needs to be positioned in front of the `pig` structure you created. The `TopPoint`
    can be over the slingshot, but needs to set to `8` on the **Y** axis. These three
    points will define the limits of where our camera can move when being dragged
    and following birds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make all three points, and the `Main Camera` object, children of the `CameraRig`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we create the `CameraControl` script. This script will control all of the
    movement and interaction with the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our variables for this script start with a reference to the slingshot; we need
    this so we can follow the current bird when it is fired. Next are the references
    to the points we just created. The next group of variables control how long the
    camera will sit without input before returning to look at the slingshot and how
    fast it will return. The `dragScale` variable controls how fast the camera actually
    moves when the player drags their finger across the screen, allowing us to keep
    the scene moving with the finger. The last group is to control whether the camera
    can follow the current bird and how fast it can do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Awake` function, we first make certain the camera is not following a
    bird and make it wait before heading to look at the slingshot. This allows us
    to initially point the camera to the pig fortress when the level starts and move
    to the slingshot after giving the player a chance to see what they are up against.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `StartWait` function sets the time when it will start to head back to the
    slingshot and records the position that it is heading back from. This allows us
    to create a smooth transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we have the `Update` function. This one starts by checking whether the
    slingshot has fired. If it hasn't, it checks to see whether the player has started
    aiming, signaling that the bird should be followed and zeroing out the velocity
    if they have. If they have not, the `followBird` flag is cleared. Next, the function
    checks whether it should follow and does so if it should, also calling the `StartWait`
    function in case this is the frame in which the bird is destroyed. If it should
    not follow the bird, it checks for touch input and drags the camera if it finds
    any. The wait is again started in case the player removes their finger in this
    frame. Finally, it checks to see if the slingshot is done firing the current bird
    and if it is time to head back. Should both be true, the camera moves back to
    pointing at the slingshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `FollowBird` function starts by making sure there is a bird to follow by
    checking the `toFireBird` variable on the `Slingshot` script and stops following
    if a bird is not found. Should there be a bird, the function then determines a
    new point to move to that will look directly at the bird. It then uses the `Vector3.SmoothDamp`
    function to smoothly follow the bird. This function works similar to a spring—the
    farther away it is from its target position, the faster it moves the object. The
    `followVelocity` variable is used to keep it moving smoothly. Finally, it calls
    another function to limit the camera's position within those bounding points we
    set up earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `DragCamera` function, we use the `deltaPosition` value of the current
    touch to determine how far it has moved since the last frame. By scaling this
    value and subtracting the vector from the camera's position, the function moves
    the camera as the player drags across the screen. This function also calls upon
    the function to clamp the camera's position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ClampPosition` function starts by taking the camera's current position.
    It then clamps the z position to be between those of the `leftPoint` and `rightPoint`
    variables' `z` positions. Next, the `y` position is clamped between the `leftPoint`
    and `topPoint` variables' positions. Finally, the new position is reapplied to
    the camera's transform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we have the `BackToLeft` function. It starts by using the time and
    our duration variable to determine how much progress in returning to the slingshot
    the camera will have made. It records the camera's current position and uses `Mathf.SmoothStep`
    on both the z and y axes to find a new position that is the appropriate distance
    between the `waitPosition` variable and the `leftPoint` variable. Finally, the
    new position is applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, return to Unity and add the new script to the `Main Camera` object. Connect
    the references to the slingshot and each of the points to finish it off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the camera to point at your pig fortress and turn the whole rig into
    a prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the camera rig that will let the player watch all of the action as
    they play the game. The camera will now follow the birds as they are fired from
    the slingshot and can now be dragged by the player. By keying off the positions
    of a few objects, this movement is limited to keep the player from seeing things
    we don't want them to. If the camera is left idle long enough, it will also return
    to look at the slingshot.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – more levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have all of the pieces needed to make a complete level, we need
    some more levels. We need at least two more levels. You can use the blocks and
    pigs to create any level you might want. It is a good idea to keep the pig structures
    centered at about `30` on the **Z** axis. Also, think about the difficulty of
    the level while making it, so that you can end up with an easy, medium, and hard
    level.
  prefs: []
  type: TYPE_NORMAL
- en: A better background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great feature of many 2D games is a parallax scrolling background. This simply
    means that the background is created in layers that scroll by at different speeds.
    Think of it as if looking out the window of your car. The objects that are far
    away appear to hardly move, while the ones that are near move by quickly. In a
    2D game, it gives the illusion of depth and adds a nice touch to the look of the
    game. For this background, we will be layering several materials on a single plane.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the parallax background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an alternative method of creating and utilizing a second camera, but
    ours will make use of a single script that additionally allows us to control the
    speed of each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start this section with the creation of the `ParallaxScroll` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script starts with three variables. The first two keep track of each material
    and how fast they should scroll. The third keeps track of the camera's last position,
    so we can track how far it moves in each frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Start` function, we record the camera's beginning position. We use `Start`
    instead of `Awake` here, in case the camera needs to do any special movement at
    the beginning of the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we use the `LateUpdate` function to make changes after the camera has
    moved about. It starts by finding the camera's new position and comparing the
    z axis values to determine how far it moved. Next, it loops through the list of
    materials. The loop first gathers the current offset of its texture using `mainTextureOffset`.
    Next, the camera's movement multiplied by the material's speed is subtracted from
    the offset's x axis to find a new horizontal position. Then, the new offset is
    applied to the material. Finally, the function records the camera's last position
    for the next frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return to Unity and create six new materials. One for each of the background
    textures: `sky`, `hills_tall`, `hills_short`, `grass_light`, `grass_dark`, and
    `fronds`. All of the materials, except for the sky, need to use the **Diffuse**
    shader under **Transparent** in the **Shader** drop-down list. If they do not,
    we will not be able to see all of the textures when they are layered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to adjust the **Tiling** of each of these new materials. For all
    of them, leave the **Y** axis as `1`. For the **X** axis, set `5` for the `sky`,
    `6` for `hills_tall`, `7` for `hills_short`, `8` for `grass_dark`, `9` for `fronds`,
    and `10` for `grass_light`. This will offset all of the features of the textures
    so a long pan does not see features regularly lining up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a new plane. Name it `Background` and remove its **Mesh Collider**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position it at `-5` on the **X** axis, `7` on the **Y** axis, and `30` on the
    **Z** axis. Set its rotation to `90` for both the **X** and **Y** axes and `0`
    for **Z**. Also, set the scale to `10` for the **X** axis, `1` for the **Y** axis,
    and `1.5` for the **Z** axis. Altogether, these position the plane as facing the
    camera and filling the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the plane's **Mesh Renderer** component, expand the **Materials** list and
    set the **Size** to `6`. Add each of our new materials to the list slots in the
    order of `sky`, `hills_tall`, `hills_short`, `grass_dark`, `fronds`, `grass_light`.
    Do the same for the **Materials** list in the **Parallax Scroll** script component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the **Parallax Scroll** script component, set the **Size** of the
    **Speeds** list to `6` and input the following values in the order of `0.03`,
    `0.024`, `0.018`, `0.012`, `0.006`, `0`. These values will move the materials
    gently and evenly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turning the background into a prefab, at this point, will make it easy to reuse
    later.![Time for action – creating the parallax background](img/2014OT_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a parallax scroll effect. This effect will pan a series of background
    textures, giving the illusion of depth in our 2D game. To easily see it in action,
    hit play and grab the camera in the **Scene** view, moving it along the z axis
    to see the background change.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – dark of the night
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have two other levels to add backgrounds to. Your challenge here is to create
    your own background. Use the techniques you learned in this section to create
    a night-style background. It could include a stationary moon while everything
    else scrolls in the shot. For an added trick, create a cloud layer that slowly
    pans across the screen as well as with the camera and the rest of the background.
  prefs: []
  type: TYPE_NORMAL
- en: The flock variety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one last set of assets we need to create for our levels, the other
    birds. We will create three more birds that each have a unique special ability:
    a yellow bird that accelerates, a blue bird that splits into multiple birds, and
    a black bird that explodes. With these our flock will be complete.'
  prefs: []
  type: TYPE_NORMAL
- en: To make the creation of these birds easier, we will be making use of a concept
    called **inheritance**. Inheritance allows a script to expand upon the functions
    it is inheriting without the need to rewrite them. If used correctly, this can
    be very powerful and, in our case, will aid in the quick creation of multiple
    characters that are largely similar.
  prefs: []
  type: TYPE_NORMAL
- en: The yellow bird
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will create the yellow bird. Largely, this bird functions exactly
    as the red bird. However, when the player touches the screen, the bird's speed
    increases. By extending the `Bird` script that we created earlier, this bird's
    creation becomes quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the yellow bird
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because of the power of inheritance, the script we are creating here consists
    of only a handful of lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating the yellow bird in the same way as the red bird, using the
    `YellowBird` model instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of using the `Bird` script, we will create the `YellowBird` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script needs to extend the `Bird` script, so replace `MonoBehaviour` with
    `Bird` on line four. It should look similar to the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script adds a single variable that will be used to multiply the bird's
    current velocity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we override the `DoSpecial` function and multiply the bird''s `rigidbody.velocity`
    when it is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to Unity, add the script to your new bird, and turn it into a prefab.
    Add some to the list on your slingshot to use the bird in your level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the yellow bird. This bird is simple. It directly modifies its velocity
    to suddenly gain a boost of speed when the player touches the screen. As you will
    soon see, we use this same style of script creation to create all of our birds.
  prefs: []
  type: TYPE_NORMAL
- en: The blue bird
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we create the blue bird. This bird splits into three birds when the player
    touches the screen. It will also extend the `Bird` script.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the blue bird
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The blue bird will again make use of inheritance, reducing the amount of code
    that needs to be written to create the bird:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, start building your blue bird the same way as the previous two, substituting
    the appropriate model. You should also adjust the **Radius** of the **Sphere Collider**
    component to align appropriately with the smaller size of this bird.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create the `BlueBird` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, adjust line four so the script extends `Bird` instead of `MonoBehaviour`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script has three variables. The first is a list of prefabs to spawn when
    the bird splits. Next is the angle difference between each new bird that will
    be launched. Finally is a value to spawn the birds a little ahead of their current
    position to keep them from getting stuck inside each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we override the `DoSpecial` function and start, as with the others, by
    marking that we made our special move. Next, it calculates half of the number
    of birds to spawn and creates an empty list for storing the rigidbodies of the
    newly spawned birds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function continues by looping through the list of birds, skipping the slots
    that are empty. It spawns the new birds at its position, continuing to the next
    if there is a missing **Rigidbody** component. The new **Rigidbody** component
    is then stored in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `Quaternion.Euler`, a new rotation is created that will angle the new
    bird along a path split off from the main path. The new bird's velocity is set
    to the rotated velocity of the current bird. It is then moved forward along its
    new path to get out of the way of the other birds being spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the loop, the function uses `FindObjectOfType` to find the slingshot that
    is currently in the scene. If found, it is changed to track the first new bird
    spawned as the one that was fired. The new list of rigidbodies is also set to
    the `rigidbodyDamper` variable to be added to its list of rigidbodies. Finally,
    the script destroys the bird it is attached to, completing the illusion that the
    bird has split apart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before you add the script to your new bird, we actually need two blue birds:
    one that splits and one that does not. Duplicate your bird and name one `Bird_Blue_Split`
    and the other `Bird_Blue_Normal`. To the split bird add the new script and to
    the normal bird add the `Bird` script.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn both birds into prefabs and add the normal bird to the other's list of
    birds to be split into.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the blue bird. This bird splits into multiple birds when the user
    taps the screen. The effect actually requires two birds that look identical. One
    that does the splitting and another that is split into but does nothing special.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – creating a rainbow bird
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is actually possible to add anything we want to spawn to the blue bird's
    list of things to split into. Your challenge here is to create a rainbow bird.
    This bird could split into different types of birds, not just blue ones. Or, perhaps
    it is a stone bird that splits into stone blocks. For an extended challenge, create
    a mystery bird that picks a bird from its list randomly when it splits.
  prefs: []
  type: TYPE_NORMAL
- en: The black bird
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we have the black bird. This bird explodes when the player touches
    the screen. As with all the birds discussed previously, it will extend the `Bird`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the black bird
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the two birds discussed earlier, inheriting from the red bird makes
    the black bird''s creation much easier:'
  prefs: []
  type: TYPE_NORMAL
- en: As with the others, this bird is initially created in the same way as the red
    bird, readjusting the **Radius** for its increased size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, we create a new script to extend the `Bird` script. This time it is called
    `BlackBird`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not forget to adjust line four to extend the `Bird` script and not `MonoBehaviour`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script has two variables. The first is the size of the explosion and the
    second is its strength.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once more we override the `DoSpecial` function, first marking that we did it.
    Next, we use `Physics.OverlapSphere` to acquire a list of all of the objects that
    are within the range of the bird's explosion. The function then loops through
    the list, skipping any empty slots and those without rigidbodies. If the object
    does exist and has a **Rigidbody** component attached, we call `AddExplosionForce`
    to simulate the way an explosion's strength against you is reduced the further
    you are from it. We give the function the explosion's strength, followed by the
    bird's position and radius. The value `3` is a vertical modifier. It does not
    interfere with the distance an object is from the explosion but, instead, adjusts
    the angle the explosion hits it at. This `3` moves the force to below the object,
    because explosions that throw debris up are cooler than ones that push out. `ForceMode.Impulse`
    is again used to apply the force immediately. Finally, the function destroys the
    exploded bird.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with the last two, apply your new script to your new bird and turn it into
    a prefab. You now have four birds to choose from when selecting the slingshot
    arsenal for each level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created our fourth and last bird, the black bird. This bird explodes when
    the user touches the screen, throwing anything that might be near into the sky.
    This can be a fun bird to play around with and effective for destroying your pig
    forts.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – explosive blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to cause explosions, we have another challenge. Create
    an explosive crate. Extend the `Plank` script to make it. When enough damage is
    done to the crate, trigger the explosion. For an added challenge, instead of making
    the crate explode, configure it to throw out a few bombs that explode when they
    hit something.
  prefs: []
  type: TYPE_NORMAL
- en: '![Have a go hero – explosive blocks](img/2014OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Level selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we need to create our level selection. From this scene, we will be
    able to access and start playing all of the levels we created earlier. We will
    also display the current high scores for each level.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the level selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new scene and a single script will serve us well in managing our level selection:'
  prefs: []
  type: TYPE_NORMAL
- en: This last section begins by saving your current scene and hitting *Ctrl* + *N*
    to create a new one, named `LevelSelect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this scene, we need to create a single, short script also named `LevelSelect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first and only variable defines the size of the buttons that will appear
    on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only function is the `OnGUI` function. This function starts with a loop.
    It will loop through three times for the three levels we should have created earlier.
    A `Rect` variable is created and initialized to the `buttonSize`. The x and y
    values are then set to position the buttons in a row, centered on the screen.
    Next, the current high score for the level is retrieved, using `PlayerPrefs.GetInt`
    and the same key creation that we used in our `LevelTracker` script. Then, the
    function creates a string to hold the message that will appear on the button.
    Finally, the button is drawn and, when clicked, `Application.LoadLevel` is used
    to load the scene and start the user playing that level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to Unity and add the script to the `Main Camera` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, open the **Build Settings** and add your scenes to the **Scenes in
    Build** list. Clicking and dragging on the scenes in the list will let you reorder
    them. Make sure your **LevelSelect** scene is first and has the index of zero
    to the right of it. The rest of your scenes can appear in whatever order you desire.
    But be aware that they will be associated with the buttons in the same order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a level-selection screen. It uses a loop to create a list of buttons
    associated with the levels in our game. When a button is pressed, `Application.LoadLevel`
    starts that level. We also made use of `PlayerPrefs.GetInt` to retrieve the high
    scores for each of the levels.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – adding some style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, the challenge is to use GUI styles to make the screen look great. A logo
    and a background would help a lot. Additionally, take a look at `GUI.BeginScrollView`
    if you have more than three levels. This function will let the user scroll through
    a list of levels that is far greater in size than can be easily seen on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about physics in Unity and recreated the incredibly
    popular mobile game, Angry Birds. By using Unity's physics system, we are able
    to make all of the levels that we could ever want to play. With this game, we
    also explored options for creating a 2D game in a 3D environment. Our birds and
    slingshot are 3D assets, giving us the ability to light and shade them. The pigs
    and the background, however, are 2D images, reducing our lighting options, but
    can allow for some greater detail in the assets. The 2D images were also crucial
    in the creation of the parallax scrolling effect of the background. Finally, the
    building's blocks appear to be 2D, but are actually 3D blocks. We also created
    a level-selection screen. From there, the player can see their high scores and
    pick any of the levels that we created to play.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we return to the Space Fighter game we started in the previous
    chapter. We are going to create and add all of the special effects that finish
    off a game. We will add the shooting and explosion sound effects that every space
    game needs. We will also add various particle effects. When ships are shot at,
    they will actually explode, rather than just disappearing.
  prefs: []
  type: TYPE_NORMAL
