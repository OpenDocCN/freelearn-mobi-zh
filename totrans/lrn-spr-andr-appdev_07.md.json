["```kt\njcenter()\n```", "```kt\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.30.2'\n```", "```kt\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:0.30.2'\n```", "```kt\nkotlin {\n    experimental {\n        coroutines \"enable\"\n    }\n}\n```", "```kt\nimplementation 'org.springframework.android:spring-android-rest-template:2.0.0.M3'\nimplementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.8.6'\n```", "```kt\nrepositories {\n    maven {\n        url 'https://repo.spring.io/libs-milestone'\n    }\n}\n```", "```kt\nclass Image\n\nfun loadImage() : Image {\n    Thread.sleep(3000)\n    return Image()\n}\n```", "```kt\nfun showImages(image1: Image, image2: Image, image3: Image) {\n    // .......\n}\n```", "```kt\nval subTask1 = GlobalScope.async { loadImage() }\nval subTask2 = GlobalScope.async { loadImage() }\nval subTask3 = GlobalScope.async { loadImage() }\n```", "```kt\nshowImages(subTask1.await(), subTask2.await(), subTask3.await())\n```", "```kt\nclass ExampleUnitTest {\n\n    @Test\n    fun comicLoading() = runBlocking {\n        val image = async { loadImage() }.await()\n        assertNotNull(image)\n    }\n}\n```", "```kt\n@Throws(InterruptedException::class)\npublic fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T {\n    val currentThread = Thread.currentThread()\n    val contextInterceptor = context[ContinuationInterceptor]\n    val privateEventLoop = contextInterceptor == null // create private event loop if no dispatcher is specified\n    val eventLoop = if (privateEventLoop) BlockingEventLoop(currentThread) else contextInterceptor as? EventLoop\n    val newContext = GlobalScope.newCoroutineContext(\n        if (privateEventLoop) context + (eventLoop as ContinuationInterceptor) else context\n    )\n    val coroutine = BlockingCoroutine<T>(newContext, currentThread, eventLoop, privateEventLoop)\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n    return coroutine.joinBlocking()\n}\n```", "```kt\npublic interface CoroutineScope {\n\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Deprecated in favor of top-level extension property\")\n    public val isActive: Boolean\n        get() = coroutineContext[Job]?.isActive ?: true\n\n    public val coroutineContext: CoroutineContext\n}\n```", "```kt\nobject GlobalScope : CoroutineScope {\n\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Deprecated in favor of top-level extension property\")\n    override val isActive: Boolean\n        get() = true\n\n    override val coroutineContext: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n```", "```kt\nclass XKCDActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_xkcd)\n    }\n}\n```", "```kt\nclass XKCDActivity : AppCompatActivity(), CoroutineScope {\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Main\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_xkcd)\n    }\n}\n```", "```kt\npublic interface CoroutineScope {\n\n    @Deprecated(level = DeprecationLevel.HIDDEN, message = \"Deprecated in favor of top-level extension property\")\n    public val isActive: Boolean\n        get() = coroutineContext[Job]?.isActive ?: true\n\n    public val coroutineContext: CoroutineContext\n}\n```", "```kt\nclass XKCDActivity : AppCompatActivity(), CoroutineScope {\n    private lateinit var lifecycleAwareJob: Job\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Main + lifecycleAwareJob\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_xkcd)\n        lifecycleAwareJob = Job()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        lifecycleAwareJob.cancel()\n    }\n}\n```", "```kt\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_xkcd)\n    lifecycleAwareJob = Job()\n    launch {\n        val image = async(Dispatchers.IO) { loadImage() }.await()\n        showImage(image)\n    }\n}\n```", "```kt\npublic interface Channel<E> : SendChannel<E>, ReceiveChannel<E> {\n    //.....\n}\n```", "```kt\npublic interface SendChannel<in E> {\n\n    @ExperimentalCoroutinesApi\n    public val isClosedForSend: Boolean\n\n    @ExperimentalCoroutinesApi\n    public val isFull: Boolean\n\n    public suspend fun send(element: E)\n\n    public val onSend: SelectClause2<E, SendChannel<E>>\n\n    public fun offer(element: E): Boolean\n\n    public fun close(cause: Throwable? = null): Boolean\n\n    @ExperimentalCoroutinesApi\n    public fun invokeOnClose(handler: (cause: Throwable?) -> Unit)\n}\n```", "```kt\npublic interface ReceiveChannel<out E> {\n\n    @ExperimentalCoroutinesApi\n    public val isClosedForReceive: Boolean\n\n    @ExperimentalCoroutinesApi\n    public val isEmpty: Boolean\n\n    public suspend fun receive(): E\n\n    public val onReceive: SelectClause1<E>\n\n    @ExperimentalCoroutinesApi\n    public suspend fun receiveOrNull(): E?\n\n    @ExperimentalCoroutinesApi\n    public val onReceiveOrNull: SelectClause1<E?>\n\n    public fun poll(): E?\n\n    public operator fun iterator(): ChannelIterator<E>\n\n    public fun cancel(): Boolean\n\n    @ExperimentalCoroutinesApi\n    public fun cancel(cause: Throwable? = null): Boolean\n}\n```", "```kt\nfun channelBasics() = runBlocking<Unit> {\n    val channel = Channel<Int>()\n    launch {\n        println(\"send 0 ${Date().toGMTString()}\")\n        channel.send(0)\n        delay(1000)\n        println(\"send 1 ${Date().toGMTString()}\")\n        channel.send(1)\n    }\n    delay(3000)\n    val theFirstElement = channel.receive()\n    println(\"receive $theFirstElement ${Date().toGMTString()}\")\n    delay(4000)\n    val theSecondElement = channel.receive()\n    println(\"receive $theSecondElement ${Date().toGMTString()}\")\n}\n```", "```kt\nsend 0 21 Oct 2018 13:30:12 GMT\n receive 0 21 Oct 2018 13:30:15 GMT\n send 1 21 Oct 2018 13:30:16 GMT\n receive 1 21 Oct 2018 13:30:19 GMT\n```", "```kt\nfun channelIterator() = runBlocking<Unit> {\n    val channel = Channel<Int>()\n    launch {\n        (0..5).forEach {\n            channel.send(it)\n        }\n    }\n    for (value in channel) {\n        println(value)\n    }\n}\n```", "```kt\n 0\n 1\n 2\n 3\n 4\n 5\n```", "```kt\n@ExperimentalCoroutinesApi\npublic fun <E> CoroutineScope.produce(\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 0,\n    block: suspend ProducerScope<E>.() -> Unit\n): ReceiveChannel<E> {\n    val channel = Channel<E>(capacity)\n    val newContext = newCoroutineContext(context)\n    val coroutine = ProducerCoroutine(newContext, channel)\n    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)\n    return coroutine\n}\n```", "```kt\npublic interface ProducerScope<in E> : CoroutineScope, SendChannel<E> {\n    val channel: SendChannel<E>\n}\n```", "```kt\nsuspend fun numbersProduce(): ReceiveChannel<Int> = GlobalScope.produce {\n    launch {\n        (0..10).forEach {\n            send(it)\n        }\n    }\n}\n```", "```kt\nfun producerExample() = runBlocking<Unit> {\n    val numbers = numbersProduce()\n    for (value in numbers) {\n        println(value)\n    }\n}\n\n```", "```kt\npublic fun <E> CoroutineScope.actor(\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 0,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    onCompletion: CompletionHandler? = null,\n    block: suspend ActorScope<E>.() -> Unit\n): SendChannel<E> {\n    val newContext = newCoroutineContext(context)\n    val channel = Channel<E>(capacity)\n    val coroutine = if (start.isLazy)\n        LazyActorCoroutine(newContext, channel, block) else\n        ActorCoroutine(newContext, channel, active = true)\n    if (onCompletion != null) coroutine.invokeOnCompletion(handler = onCompletion)\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n```", "```kt\npublic interface ActorScope<E> : CoroutineScope, ReceiveChannel<E> {\n    val channel: Channel<E>\n}\n```", "```kt\nsuspend fun numberConsumer() = GlobalScope.actor<Int> {\n    var counter = 0\n    for (value in channel) {\n        counter += value\n        println(counter)\n    }\n}\n```", "```kt\n@Test\nfun actorExample() = runBlocking<Unit> {\n    val actor = numberConsumer()\n    (0..10).forEach {\n        launch {\n            actor.send(it)\n        }\n    }\n}\n```", "```kt\n 0\n 1\n 3\n 6\n 10\n 15\n 21\n 28\n 36\n 45\n 55\n```", "```kt\nsuspend fun loadUserDetails(): User {\n    delay(3000)\n    return User(0, \"avatar\")\n}\n```", "```kt\nsuspend fun loadImage(avatar: String): Image {\n    delay(3000)\n    return Image()\n}\n```", "```kt\nfun main(args: Array<String>) = runBlocking {\n    val user = async { loadUserDetails() }.await()\n    val image = async { loadImage(user.avatar) }.await()\n    showImage(image)\n}\n```", "```kt\nfun loadImage(callback: (Image) -> Unit) {\n    executor.submit {\n        Thread.sleep(3000)\n        callback(Image())\n    }\n}\n```", "```kt\nfun main(args: Array<String>) {\n    loadImage { image ->\n        showImage(image)\n    }\n}\n```", "```kt\nfun loadListOfFriends(callback: (List<ShortUser>) -> Unit) {\n    executor.submit {\n        Thread.sleep(3000)\n        callback(listOf(ShortUser(0), ShortUser(1)))\n    }\n}\n```", "```kt\nfun loadUserDetails(id: Int, callback: (User) -> Unit) {\n    executor.submit {\n        Thread.sleep(3000)\n        callback(User(id, \"avatar\"))\n    }\n}\n```", "```kt\nfun loadImage(avatar: String, callback: (Image) -> Unit) {\n    executor.submit {\n        Thread.sleep(3000)\n        callback(Image())\n    }\n}\n\n```", "```kt\nfun main(args: Array<String>) {\n    loadListOfFriends {users ->\n        loadUserDetails(users.first().id) {user ->\n            loadImage(user.avatar) {image ->\n                showImage(image)\n            }\n        }\n    }\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val executor = Executors.newSingleThreadExecutor()\n    executor.submit { loadImage() }\n    executor.submit { loadImage() }\n}\n```"]