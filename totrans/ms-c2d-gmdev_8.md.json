["```swift\n[object someMethodWithParam:param1 andOtherParam:param2];\n```", "```swift\nobject.someMethodWithParam(param1, andOtherParam:param2)\n```", "```swift\n#import \"TurretGame-Swift.h\"\n```", "```swift\n- (CCScene*) startScene\n{\n  // Capital \"I\"\n  [[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@\"Images.plist\"];\n//[CCBReader loadAsScene:@\"MainScene\"];\n  return [MainScene node]; \n}\n```", "```swift\nclass MainScene: CCScene {\n\n  let winSize = CCDirector.sharedDirector().viewSize()\n  var background = CCNodeColor(color: CCColor.whiteColor())\n\n  //a value of \"527\" to make sure it's working. It'll get auto-set later, don't worry.\n  var lblScore = CCLabelBMFont(string: \"527\", fntFile: \"bmFont.fnt\")\n\n  //\"Images/turret.png\" because the turret image was located inside the Images folder\n  //also making sure to Downcast to a CCSprite from AnyObject!\n//We want to downcast because the variable we're setting should be a sprite, so because the spriteFrameByName() method returns AnyObject (as an explicitly unwrapped optional), we must downcast the ambiguous type to CCSprite for better use of the variable later on.\n  var turret = CCSprite.spriteWithSpriteFrame(CCSpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName(\"Images/turret.png\")) as CCSprite\n\n  override init() {\n    super.init()\n\n    //simply add the background color\n    self.addChild(background)\n\n    //position and add the score label\n    self.lblScore.position = ccp(self.winSize.width/2, self.winSize.height * 0.1)\n    self.addChild(self.lblScore)\n\n    //position and add the turret (z:1 so the bullets can spawn underneath it)\n    self.turret.position = ccp(self.winSize.width/2, self.winSize.height/2)\n    self.addChild(self.turret, z: 1)\n\n  }\n}\n```", "```swift\nclass MainScene: CCScene {\n  ...\n    var touchPos = ccp(0, 0)\n  ...\n}\n```", "```swift\n//records touches\nself.userInteractionEnabled = true\n```", "```swift\n// a method that will be called when a touch is registered on the device\n\noverride func touchBegan(touch: CCTouch!, withEvent event: CCTouchEvent!) {\n    // grab the touch's location within the scene, and set it to our variable\n    self.touchPos = touch.locationInNode(self)\n    // calculate the angle of the touch relative to the turret's current position\n    var angle = ccpToAngle( ccpSub( self.touchPos, self.turret.position ) )    \n// set the rotation of the turret based on the calculated angle (converted to degrees because Cocos2D doesn't use radians)\n    self.turret.rotation = CC_RADIANS_TO_DEGREES(Float(angle)) * -1\n}\n\n// a method called when a touch is dragged across the screen\noverride func touchMoved(touch: CCTouch!, withEvent event: CCTouchEvent!) {\n// grab the location of the touch and set it again\n    self.touchPos = touch.locationInNode(self)\n    // calculate the angle again based on the new touch position\n    var angle = ccpToAngle( ccpSub( self.touchPos, self.turret.position ) )\n    // set the rotation of the turret again based on the new angle\n    self.turret.rotation = CC_RADIANS_TO_DEGREES(Float(angle)) * -1\n}\n\noverride func touchEnded(touch: CCTouch!, withEvent event: CCTouchEvent!) {\n    // do nothing at the moment\n}\n```", "```swift\nfunc shootBullet() {\n\n  //create the bullet. Again, \"Images/bullet.png\" because of the Images folder\n    var bullet = CCSprite.spriteWithSpriteFrame(CCSpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName(\"Images/bullet.png\")) as CCSprite\n\n    //position the bullet underneath the turret\n    bullet.position = ccp(self.winSize.width/2, self.winSize.height/2)\n\n    //calculate the distance to move based on similar triangles\n    let xDist = self.touchPos.x - self.turret.position.x;\n    let yDist = self.touchPos.y - self.turret.position.y;\n    let zDist = ccpDistance(self.touchPos, self.turret.position)\n\n    let newX = (xDist * winSize.width) / zDist;\n    let newY = (yDist * winSize.width) / zDist;\n\n    //assign that distance to a CGPoint variable\n    let moveDistance = ccp(newX, newY)\n\n    //create an action that will move the bullet, then after 0.5 seconds, it will remove it from the screen\n    var moveAndRemoveAction = CCActionSequence.actionOne(CCActionMoveBy.actionWithDuration(0.5, position: moveDistance) as CCActionFiniteTime, two: CCActionCallBlock.actionWithBlock({\n\n      self.removeChild(bullet)\n    }) as CCActionFiniteTime) as CCAction\n\n    //add the bullet\n    self.addChild(bullet)\n\n    //run the move action\n    bullet.runAction(moveAndRemoveAction)\n}\n```", "```swift\noverride func touchBegan(touch: CCTouch!, withEvent event: CCTouchEvent!) {\n  ...\n    //call it once, then schedule it\n    shootBullet()\n    self.schedule(Selector(\"shootBullet\"), interval: 0.125)\n}\n```", "```swift\noverride func touchEnded(touch: CCTouch!, withEvent event: CCTouchEvent!) {\n    self.unschedule(Selector(\"shootBullet\"))\n}\n```", "```swift\nfunc spawnEnemy() {\n    //create the enemy. Again, \"Images/enemy.png\" because of the Images folder\n    var enemy = CCSprite.spriteWithSpriteFrame(CCSpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName(\"Images/enemy.png\")) as CCSprite\n\n    //position the enemy randomly along the left or right wall\n    let yPos = arc4random() % UInt32(winSize.height)\n    let xPos = arc4random() % 2 == 0 ? -50 : winSize.width + 50\n    enemy.position = ccp(CGFloat(xPos),CGFloat(yPos))\n\n    //add the enemy to the screen\n    self.addChild(enemy)\n\n    //move to exactly 1 enemy-length away from the center (calculated with triangle ratios)\n    let distanceToCenter = ccpDistance(self.turret.position, enemy.position)\n    let xDistance = self.turret.position.x - xPos\n    let yDistance = self.turret.position.y - CGFloat(yPos)\n\n    let newDistanceToCenter = distanceToCenter - enemy.boundingBox().size.width\n    let newX = (newDistanceToCenter * xDistance) / distanceToCenter\n    let newY = (newDistanceToCenter * yDistance) / distanceToCenter\n\n    let centerPosDistance = ccp(newX,newY)\n\n    //create a move action that, after 3 seconds, will do something (nothing at the moment)\n    let moveAndEndGameAction = CCActionSequence.actionOne(CCActionMoveBy.actionWithDuration(3, position: centerPosDistance) as CCActionFiniteTime, two: CCActionCallBlock.actionWithBlock({\n      //do nothing at the moment\n    }) as CCActionFiniteTime) as CCAction\n\n    //run the move action\n    enemy.runAction(moveAndEndGameAction)\n}\n```", "```swift\noverride init() {\n    super.init()\n\n    ...\n\n    self.schedule(Selector(\"spawnEnemy\"), interval: 0.35)\n}\n```", "```swift\nclass GameOverScene: CCScene {\n\n  override init() {\n\n    super.init()\n\n    let winSize = CCDirector.sharedDirector().viewSize()\n\n    var background = CCNodeColor(color: CCColor.whiteColor())\n    self.addChild(background)\n\n    var label = CCLabelBMFont(string: \"Tap anywhere to restart\", fntFile: \"bmFont.fnt\")\n    label.position = ccp(winSize.width/2, winSize.height/2)\n    self.addChild(label)\n\n    self.userInteractionEnabled = true\n  }\n\n  override func touchBegan(touch: CCTouch!, withEvent event: CCTouchEvent!) {\n\n    CCDirector.sharedDirector().replaceScene(MainScene.node() as CCScene)\n  }\n}\n```", "```swift\nfunc spawnEnemy() {\n...\n    //create a move action that, after 3 seconds, will do something (nothing at the moment)\n    let moveAndEndGameAction = CCActionSequence.actionOne(CCActionMoveBy.actionWithDuration(3, position: centerPosDistance) as CCActionFiniteTime, two: CCActionCallBlock.actionWithBlock({\n\n  //add this line â€“ it will transition to the GameOverScene (in other words, the enemy was not killed)\n    CCDirector.sharedDirector().replaceScene(GameOverScene.node() as CCScene)\n\n}) as CCActionFiniteTime) as CCAction\n\n    //run the move action\n    enemy.runAction(moveAndEndGameAction)\n}\n```", "```swift\nclass MainScene: CCScene {\n\n  ...\n\n  //arrays to hold our bullets and enemies\n  var bullets : NSMutableArray = []\n  var enemies : NSMutableArray = []\n\n  override init() {\n    ...\n```", "```swift\nfunc shootBullet() {\n\n...\n\n    var moveAndRemoveAction = CCActionSequence.actionOne(CCActionMoveBy.actionWithDuration(0.5, position: moveDistance) as CCActionFiniteTime, two: CCActionCallBlock.actionWithBlock({\n\n      //remove the bullet from the array\n      //before removing it from the screen\n      self.bullets.removeObject(bullet)\n      self.removeChild(bullet)\n    }) as CCActionFiniteTime) as CCAction\n\n    //add the bullet\n    self.bullets.addObject(bullet)\n    self.addChild(bullet)\n\n...\n}\n\nfunc spawnEnemy() {\n...\n\n//add the enemy to the enemies array before adding it to the screen\n    self.enemies.addObject(enemy)\n//add the enemy to the screen\n    self.addChild(enemy)\n\n...\n}\n```", "```swift\nfunc checkForCollisions() {\n\n    //check for collisions\n    for bullet in self.bullets {\n      for enemy in self.enemies {\n\n        //if the two bounding boxes are overlapping/intersecting/colliding\n        if CGRectIntersectsRect(bullet.boundingBox(),\n        enemy.boundingBox()) {\n          self.bullets.removeObject(bullet)\n          self.enemies.removeObject(enemy)\n\n          self.removeChild(bullet as CCSprite)\n          self.removeChild(enemy as CCSprite)\n\n          break;\n        }\n      }\n    }\n}\n```", "```swift\noverride init() {\n    ...\n    self.schedule(Selector(\"checkForCollisions\"), interval: 1.0/60.0)\n}\n```", "```swift\nclass MainScene: CCScene {\n\n  ... \n//a variable to hold the score. The value of 0.0 sets it to a Float type by default, not Int\n  var score = 0.0   \n  override init() {\n    ...\n  }\n}\n```", "```swift\noverride func update(delta: CCTime) {\n    //some obscure score increment over time...\n    self.score += 0.47\n\n    //set the label using String Interpolation\n  self.lblScore.setString(\"\\(Int(self.score))\")\n}\n```", "```swift\nfunc checkForCollisions() {\n...\n  if CGRectIntersectsRect(bullet.boundingBox(), enemy.boundingBox()) {\n     ...\n     self.score += 100   \n     break;\n  }\n}\n```", "```swift\nclass MainScene: CCScene {\n  ...\n  //variables for enemy spawn rate (aka, difficulty)\n  var spawnRate = 0.35\n  var scoreSinceLastIncrease = 0.0\n\n  override init() {\n```", "```swift\noverride init() {\n  ...\n  self.schedule(Selector(\"spawnEnemy\"), interval: self.spawnRate)\n}\n```", "```swift\nfunc checkForCollisions() {\n  ...     \n  if CGRectIntersectsRect(bullet.boundingBox(), enemy.boundingBox()) {\n    ...\n    self.score += 100\n    self.scoreSinceLastIncrease += 100\n\n    break;\n  }\n}\n\noverride func update(delta: CCTime) {\n    //some random score increment over time...\n    self.score += 0.47\n    self.scoreSinceLastIncrease += 0.47\n\n    //set the label using String Interpolation\n    self.lblScore.setString(\"\\(Int(self.score))\")\n\n}\n```", "```swift\noverride func update(delta: CCTime) {\n    ...\n    if self.scoreSinceLastIncrease > 2000 {\n\n      //unschedule and re-schedule the spawnEnemy method\n      //using the new spawn rate\n      self.unschedule(Selector(\"spawnEnemy\"))\n\n      spawnRate -= 0.025\n      if (spawnRate < 0.005) {\n        spawnRate = 0.005\n      }\n\n      self.schedule(Selector(\"spawnEnemy\"), interval: self.spawnRate)\n\n      //subtract 2000, the amount of the difficulty\n      self.scoreSinceLastIncrease -= 2000\n    }\n}\n```"]