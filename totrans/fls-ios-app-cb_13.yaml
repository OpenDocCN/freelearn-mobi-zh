- en: Chapter 13. Connectivity, Persistence, and URI Schemes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章. 连接性、持久性和 URI 方案
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Monitoring Internet connectivity
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控互联网连接
- en: Specifying a persistent Wi-Fi connection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定持久的 Wi-Fi 连接
- en: Referencing an app's common directories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用应用的公共目录
- en: Writing files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写文件
- en: Reading files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件
- en: Launching system applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动系统应用
- en: Launching the App Store
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 App Store
- en: Launching the Maps application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动地图应用
- en: Declaring device capabilities
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明设备功能
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Significant ground has been covered during the course of the book but a few
    topics that we have touched upon deserve a little more attention. In this chapter,
    we will tie up those loose ends by exploring some additional uses for the application
    descriptor file, spending time understanding how to access the device's file system,
    and seeing how to open native iOS apps from Flash.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们已经覆盖了很多内容，但有一些我们触及的话题值得更多关注。在本章中，我们将通过探索应用描述符文件的一些额外用途，花时间了解如何访问设备的文件系统，以及如何从
    Flash 打开原生 iOS 应用来整理这些悬而未决的问题。
- en: Monitoring Internet connectivity
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控互联网连接
- en: It is a common occurrence for mobile applications to connect to the Internet
    at some point or another. For many, it will be for simple tasks, such as submitting
    a user's score or posting to a social network site. More sophisticated apps may
    attempt, for example, to aggregate data from various sources or even stream video
    from a Flash Media Server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动应用来说，在某个时刻连接到互联网是一种常见现象。对于许多人来说，这将是简单的任务，例如提交用户的分数或发布到社交网络网站。更复杂的应用可能试图从各种来源聚合数据，甚至从
    Flash 媒体服务器流式传输视频。
- en: It is good practice to check that the device has an active Internet connection
    before trying to send or receive data. If an active connection cannot be found,
    then the app can adjust accordingly. For example, a game may hide its online leaderboards
    and remove any facilities for uploading scores.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试发送或接收数据之前检查设备是否具有活跃的互联网连接是一种良好的做法。如果找不到活跃的连接，则应用可以相应地调整。例如，一个游戏可能会隐藏其在线排行榜并移除上传分数的任何设施。
- en: This recipe will show you how to use AIR's `URLMonitor` class to check for the
    availability of an URL before calling it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将向您展示如何使用 AIR 的 `URLMonitor` 类在调用之前检查 URL 的可用性。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供了一个 FLA 作为起点。
- en: From the book's accompanying code bundle, open `chapter13\recipe1\recipe.fla`
    into Flash Professional.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将 `chapter13\recipe1\recipe.fla` 打开到 Flash Professional。
- en: A dynamic text field named `output` covers the stage. We will write some ActionScript
    to check for Internet connectivity and display the results within the text field.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `output` 的动态文本字段覆盖了舞台。我们将编写一些动作脚本以检查互联网连接并在文本字段中显示结果。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The `URLMonitor` class belongs to the `air.net` package and is not defined in
    the AIR runtime. Instead the class is included in the `aircore.swc` file, which
    must be statically linked to your FLA before it can be used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`URLMonitor` 类属于 `air.net` 包，并在 AIR 运行时中未定义。相反，该类包含在 `aircore.swc` 文件中，在使用之前必须将其静态链接到您的
    FLA。'
- en: Linking the SWC file
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接 SWC 文件
- en: Let us link `aircore.swc` to the FLA before going on to write this recipe's
    ActionScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此菜谱的动作脚本之前，让我们将 `aircore.swc` 链接到 FLA。
- en: Select **File** | **ActionScript Settings** from Flash Professional's drop-down
    menu. This will open the ActionScript 3.0 Settings panel where you can add the
    SWC.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Flash Professional 的下拉菜单中选择 **文件** | **动作脚本设置**。这将打开动作脚本 3.0 设置面板，您可以在其中添加
    SWC。
- en: Select the **Library path** tab. Click on the **Add New Path** icon, which is
    represented by a **+** symbol.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **库路径** 选项卡。点击 **添加新路径** 图标，它由一个 **+** 符号表示。
- en: 'Now click on the **Browse to SWC file** icon and select `aircore.swc` from
    your Flash installation folder. Its location depends on your version of Flash
    Professional. For CS5, browse to: `Adobe Flash CS5\AIK2.5\frameworks\libs\air\aircore.swc`.
    If you are using CS5.5, it is at: `Adobe Flash CS5.5\AIR2.6\frameworks\libs\air\aircore.swc.`'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击 **浏览到 SWC 文件** 图标，并从您的 Flash 安装文件夹中选择 `aircore.swc`。其位置取决于您使用的 Flash Professional
    版本。对于 CS5，浏览到：`Adobe Flash CS5\AIK2.5\frameworks\libs\air\aircore.swc`。如果您使用的是
    CS5.5，它位于：`Adobe Flash CS5.5\AIR2.6\frameworks\libs\air\aircore.swc`。
- en: Note
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Microsoft Windows, your installation of Flash Professional can be found at
    `C:\Program Files (x86)\Adobe`. On 32-bit versions of Windows, the path will be
    `C:\Program Files\Adobe`.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Microsoft Windows上，你的Flash Professional安装可以在`C:\Program Files (x86)\Adobe`找到。在32位Windows版本上，路径将是`C:\Program
    Files\Adobe`。
- en: 'If you are using Mac OS X, then your Flash installation can be found at: `Macintosh
    HD/Applications`.'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在使用Mac OS X，那么你的Flash安装可以在以下位置找到：`Macintosh HD/Applications`。
- en: '![Linking the SWC file](img/1383_14_01.jpg)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![链接SWC文件](img/1383_14_01.jpg)'
- en: The SWC will be added to a list of libraries that will be used when publishing
    your app. Expand the SWC file's entry by clicking the icon to the left of its
    path, and ensure that its **Link Type** option is set to **Merged into code**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SWC将被添加到在发布应用程序时使用的库列表中。通过单击其路径左侧的图标展开SWC文件的条目，并确保其**链接类型**选项设置为**合并到代码**。
- en: Click on **OK** to close the panel.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以关闭面板。
- en: Checking connectivity
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查连接性
- en: With `aircore.swc` linked to your FLA, you can now use the API provided by the
    `URLMonitor` class. Okay, now let us write some ActionScript.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将`aircore.swc`链接到你的FLA文件后，你现在可以使用`URLMonitor`类提供的API。好的，现在让我们编写一些ActionScript代码。
- en: Create a document class and name it `Main`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为`Main`。
- en: 'Add the following three import statements, and a `URLMonitor` member variable:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下三个导入语句，以及一个`URLMonitor`成员变量：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a `URLMonitor` instance that checks for the availability of a specific
    HTTP request, and listen for it dispatching `StatusEvent.STATUS:`
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个检查特定HTTP请求可用性的`URLMonitor`实例，并监听其`dispatching` `StatusEvent.STATUS`：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Write a handler for the `URLMonitor` object''s `STATUS` event:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`URLMonitor`对象的`STATUS`事件编写一个处理程序：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the class as `Main.as` and move back to your FLA.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该类保存为`Main.as`，然后返回到你的FLA文件。
- en: 'Publish the FLA and test the app on your device. The following text should
    be output to the screen:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA文件并在你的设备上测试应用程序。以下文本应显示在屏幕上：
- en: '**Internet connection available.**'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**互联网连接可用**。'
- en: 'Try changing your document class to monitor a URL that doesn''t exist. Republish
    and test your app. This time you will receive the following message:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将你的文档类更改为监控一个不存在的URL。重新发布并测试你的应用程序。这次你将收到以下消息：
- en: '**Internet connection unavailable.**'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**互联网连接不可用**。'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `URLMonitor` class monitors and detects changes in HTTP or HTTPS connectivity
    for a specified URL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`URLMonitor`类监控并检测指定URL的HTTP或HTTPS连接变化。'
- en: Its constructor accepts a `URLRequest` as a parameter, which contains the URL
    to probe. After creating the `URLMonitor` object, call its `start()` method to
    begin monitoring.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其构造函数接受一个`URLRequest`作为参数，其中包含要探测的URL。在创建`URLMonitor`对象后，调用其`start()`方法开始监控。
- en: When the URL's availability is determined, the `URLMonitor` object dispatches
    `StatusEvent.STATUS`. You can query the `StatusEvent` object's `available` property
    to determine whether or not a connection to the URL can be made.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当确定URL的可用性时，`URLMonitor`对象将派发`StatusEvent.STATUS`。你可以查询`StatusEvent`对象的`available`属性以确定是否可以建立到URL的连接。
- en: Monitoring continues until the `URLMonitor.stop()` method is called. It is also
    possible to determine if monitoring is currently taking place by checking the
    `URLMonitor.running` property.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 监控将持续进行，直到调用`URLMonitor.stop()`方法。也可以通过检查`URLMonitor.running`属性来确定是否正在进行监控。
- en: For more information, perform a search for `air.net.URLMonitor` within Adobe
    Community Help.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请在Adobe社区帮助中搜索`air.net.URLMonitor`。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here is some additional detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的细节。
- en: Monitoring sockets
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控套接字
- en: The `air.net.SocketMonitor` class is similar to `URLMonitor` but detects connectivity
    changes for a host at a specified port. This is useful for applications, such
    as multiplayer games, where a socket server connection is required.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`air.net.SocketMonitor`类与`URLMonitor`类似，但检测指定端口的主机连接变化。这对于需要套接字服务器连接的应用程序，如多人游戏，非常有用。'
- en: 'The `SocketMonitor` class'' constructor expects the name of the host and its
    port to monitor:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`SocketMonitor`类的构造函数期望传入要监控的主机名和端口号：'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once instantiated, the `SocketMonitor` object is used in an identical manner
    to `URLMonitor`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化，`SocketMonitor`对象的使用方式与`URLMonitor`相同。
- en: Polling interval
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮询间隔
- en: Both `URLMonitor` and `SocketMonitor` provide a `pollInterval` property that
    can be used to specify an interval, measured in milliseconds, for periodically
    polling the server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`URLMonitor`和`SocketMonitor`都提供了一个`pollInterval`属性，可以用来指定一个以毫秒为单位的间隔，用于定期轮询服务器。'
- en: By default, its value is `0`, meaning the server is polled immediately after
    `start()` is called, and thereafter only when the network status changes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，其值为 `0`，这意味着在调用 `start()` 后，服务器将立即轮询，之后仅在网络状态改变时才会轮询。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Specifying a persistent Wi-Fi connection*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定持久的 Wi-Fi 连接*'
- en: Specifying a persistent Wi-Fi connection
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定持久的 Wi-Fi 连接
- en: While many applications periodically connect to the Internet, there are some,
    such as chat clients and multiuser games that require a constant connection. These
    types of applications can be rendered useless if a persistent connection isn't
    available. By editing its application descriptor file, it is possible to stipulate
    that your app requires a persistent connection to a Wi-Fi network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多应用程序定期连接到互联网，但也有一些，如聊天客户端和多用户游戏，需要持续连接。如果没有持续连接，这类应用程序可能会变得毫无用处。通过编辑其应用程序描述符文件，您可以指定您的应用程序需要连接到
    Wi-Fi 网络的持续连接。
- en: Let us see how to do this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做这件事。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter13\recipe2\recipe.fla`
    into Flash Professional and work from there. Its document class contains the code
    from the previous recipe, *Monitoring Internet connectivity*. Don't worry if you
    haven't attempted this recipe, as an understanding of it isn't required.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将 `chapter13\recipe2\recipe.fla` 打开到 Flash Professional 中，并从这里开始工作。其文档类包含上一个示例中的代码，*监控互联网连接性*。如果您没有尝试过这个示例，请不要担心，因为理解它不是必需的。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You can edit your application descriptor file from an external text editor or
    from Flash Professional. We will use Flash Professional.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从外部文本编辑器或从 Flash Professional 中编辑您的应用程序描述符文件。我们将使用 Flash Professional。
- en: Open the application descriptor file by selecting **File** | **Open** *(Ctrl
    + O* | *Cmd* + *O)* from Flash Professional's drop-down menu. From the file browser,
    select `recipe-app.xml`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从 Flash Professional 的下拉菜单中选择 **文件** | **打开** *(Ctrl + O* | *Cmd* + *O)* 打开应用程序描述符文件。从文件浏览器中，选择
    `recipe-app.xml`。
- en: 'Scroll down the file until you find the following XML fragment:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件向下滚动，直到找到以下 XML 片段：
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within the `CDATA` node, add the following key-value pair to the XML:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CDATA` 节点中，将以下键值对添加到 XML 中：
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the file.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Now publish the FLA, and install the resultant `.ipa` to your device.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在发布 FLA，并将生成的 `.ipa` 文件安装到您的设备上。
- en: Before launching the app, stop your device from automatically connecting to
    your Wi-Fi network. From your device's Settings, select **Wi-Fi** then tap on
    the icon to the far-right of your network's name. Doing so will take you to the
    settings page for that network. From here, press the **Forget this Network** button
    followed by **Forget**.![How to do it...](img/1383_14_02.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动应用程序之前，停止您的设备自动连接到您的 Wi-Fi 网络。从您的设备设置中，选择 **Wi-Fi**，然后点击网络名称右侧的图标。这样做将带您进入该网络的设置页面。从这里，按
    **忘记此网络** 按钮，然后按 **忘记**。![如何操作...](img/1383_14_02.jpg)
- en: Now move back to the device's home screen and launch your app. iOS will notice
    that the app requires a persistent Wi-Fi connection and will display a native
    dialog box asking you to **Select a Wireless Network**. Select your network from
    the list and enter its password when prompted.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在返回到设备的主屏幕并启动您的应用程序。iOS 会注意到应用程序需要持久的 Wi-Fi 连接，并将显示一个原生对话框，要求您 **选择无线网络**。从列表中选择您的网络，并在提示时输入其密码。
- en: 'Initially your app will report the following:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始时，您的应用程序将报告以下内容：
- en: '**Internet connection unavailable.**'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**互联网连接不可用**。'
- en: 'But after a brief moment, it will detect your network connection and will update
    its status to the following:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但在短暂的瞬间后，它将检测到您的网络连接，并将状态更新如下：
- en: '**Internet connection available.**'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**互联网连接可用**。'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Your FLA's application descriptor is an XML file that contains a list of iOS
    specific settings. Within the`<iPhone>` node is the`<infoAdditions>` node where
    you can set custom key-value pairs that can't be set within Flash. These are used
    to describe an app or used directly by it when launched.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 FLA 应用描述符是一个包含 iOS 特定设置的 XML 文件。在 `<iPhone>` 节点中是 `<infoAdditions>` 节点，您可以在其中设置不能在
    Flash 中设置的自定义键值对。这些用于描述应用程序或当应用程序启动时直接使用。
- en: 'For this recipe, we used the following key-value pair to alert the user when
    a persistent Wi-Fi connection could not be found:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们使用了以下键值对来提醒用户当找不到持久的 Wi-Fi 连接时：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When launched, the app detects the presence of this key and, therefore, checks
    to see if the device is connected to an active Wi-Fi network. If not, it will
    perform a search and display a network selection dialog containing a list of active
    Wi-Fi hot spots for the user to select from. Alternatively, if the device is in
    Airplane mode, then a dialog box is displayed informing the user of that fact.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用启动时，它会检测这个键的存在，因此会检查设备是否连接到活动的 Wi-Fi 网络。如果没有，它将执行搜索并显示一个网络选择对话框，其中包含用户可以选择的活跃
    Wi-Fi 热点列表。或者，如果设备处于飞行模式，则显示一个对话框通知用户这一点。
- en: Wi-Fi hardware can consume significant power. To preserve battery, iOS automatically
    switches off its Wi-Fi hardware after 30 minutes. If your app uses the `UIRequiresPersistentWiFi`
    key, then the Wi-Fi hardware will stay enabled for as long as the app remains
    active. If the device's screen locks, then the app is considered inactive and
    the Wi-Fi connection may be lost.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi 硬件可能会消耗大量电力。为了节省电池，iOS 会自动在 30 分钟后关闭其 Wi-Fi 硬件。如果你的应用使用了 `UIRequiresPersistentWiFi`
    键，那么 Wi-Fi 硬件将保持开启状态，直到应用保持活跃。如果设备的屏幕锁定，那么应用将被视为不活跃，Wi-Fi 连接可能会丢失。
- en: You can switch the `UIRequiresPersistentWiFi` key off by setting its value to`<false/>`.
    Alternatively, remove the entire entry from the application descriptor file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将其值设置为 `<false/>` 来关闭 `UIRequiresPersistentWiFi` 键。或者，也可以从应用程序描述符文件中删除整个条目。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Editing the application descriptor file, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编辑应用程序描述符文件，[第 3 章](ch03.html "第 3 章。编写你的第一个应用程序")*'
- en: Referencing an app's common directories
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用应用程序的常用目录
- en: An iOS app resides within its own directory and has access to common sub-directories
    that are contained within it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 应用位于其自己的目录中，并可以访问包含在其内部的常用子目录。
- en: This recipe will show you how to reference each of these directories.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向你展示如何引用这些目录中的每一个。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use `chapter13\recipe3\recipe.fla` from the book's accompanying code
    bundle as a starting point. Open it into Flash Professional.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用书中附带代码包中的 `chapter13\recipe3\recipe.fla` 作为起点。将其打开到 Flash Professional
    中。
- en: A dynamic text field named `output` can be found on the stage. We will use this
    text field to display the native file path of each of the app's common directories.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在舞台上可以找到一个名为 `output` 的动态文本字段。我们将使用这个文本字段来显示应用程序每个常用目录的本地文件路径。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a new document class and name it `Main`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文档类，并将其命名为 `Main`。
- en: 'Import the `File` class:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `File` 类：
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Within the constructor, write each directory''s native path to the `output`
    text field:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将每个目录的本地路径写入 `output` 文本字段：
- en: '[PRE8]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the class and when prompted, name the file `Main.as`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类，并在提示时将文件命名为 `Main.as`。
- en: Finally, publish the FLA and test it on your device. The paths for all four
    directories will be shown on screen.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，发布 FLA 文件并在你的设备上测试它。所有四个目录的路径将在屏幕上显示。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The directory that an app is stored within is known as **Application Home**
    and has a path similar to: `/var/mobile/Applications/97C9F144-E97A-40BB-A4CD-82FF31CA2A3C`.
    The string at the end of the path is an ID that uniquely identifies the application
    and is used to name the home directory during installation.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 存储应用的目录被称为 **应用程序主页**，其路径类似于：`/var/mobile/Applications/97C9F144-E97A-40BB-A4CD-82FF31CA2A3C`。路径末尾的字符串是一个唯一标识应用程序的
    ID，并在安装期间用于命名主目录。
- en: 'The `flash.filesystem.File` class makes several constants available that can
    be used to reference Application Home and its various sub-directories. These constants
    let you access the directories in a platform-independent manner, eliminating the
    need to remember lengthy native paths. They are:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.filesystem.File` 类提供了几个常量，可用于引用应用程序主页及其各种子目录。这些常量允许你以平台无关的方式访问目录，从而消除了记住长串本地路径的需要。它们是：'
- en: '`File.userDirectory:` The Application Home directory'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.userDirectory:` 应用程序主页目录'
- en: '`File.applicationDirectory:` A read-only directory that contains the application
    binary and any files bundled with it, such as the default launch screen'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.applicationDirectory:` 一个只读目录，包含应用程序的二进制文件以及与之捆绑的任何文件，例如默认启动屏幕'
- en: '`File.applicationStorageDirectory:` Any local shared object data is stored
    here'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.applicationStorageDirectory:` 任何本地共享对象数据都存储在这里'
- en: '`File.documentsDirectory:` Any application-specific data can be written to
    and retrieved from this directory'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File.documentsDirectory:` 任何应用程序特定的数据都可以写入并从这个目录中检索'
- en: Of the four, `applicationDirectory` and `documentsDirectory` are perhaps the
    two that are used most often. Although you can't write to the Application directory,
    you can read from it and even copy files from it to other locations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四个中，`applicationDirectory` 和 `documentsDirectory` 可能是使用最频繁的两个。虽然您不能向应用程序目录写入，但您可以从中读取，甚至可以将文件从其中复制到其他位置。
- en: The Documents directory is useful for state management, allowing data files
    required by the application to be stored. These files can be anything, from simple
    preference files to images created by the user. This directory's contents are
    backed-up by iTunes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文档目录对于状态管理很有用，允许存储应用程序所需的数据文件。这些文件可以是任何东西，从简单的偏好文件到用户创建的图像。此目录的内容由 iTunes 备份。
- en: 'If you wish to temporarily store files, then a `tmp` sub-directory is provided
    within Application Home. To reference folders that aren''t provided as constants,
    use the `File` class'' `resolvePath()` method to modify an existing `File` object.
    For example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望临时存储文件，则应用程序主目录中提供了一个 `tmp` 子目录。要引用未作为常量提供的文件夹，请使用 `File` 类的 `resolvePath()`
    方法修改现有的 `File` 对象。例如：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A `nativePath` property is also provided, allowing you to retrieve a directory''s
    native path from a `File` object reference:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了一个 `nativePath` 属性，允许您从 `File` 对象引用中检索目录的本地路径：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is useful when using an API that expects a native path rather than a `File`
    object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用期望本地路径而不是 `File` 对象的 API 时，这很有用。
- en: For more information, perform a search for `flash.filesystem.File` within Adobe
    Community Help.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请在 Adobe Community Help 中搜索 `flash.filesystem.File`。
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are some more options when working with the `File` class and directories.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `File` 类和目录时，还有一些其他选项。
- en: Creating directories
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建目录
- en: 'As well as referencing existing directories, the `File` class lets you create
    them using its `createDirectory()` method. The following two lines of code create
    a directory named `images` within the app''s Documents directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引用现有目录外，`File` 类还允许您使用其 `createDirectory()` 方法创建目录。以下两行代码在应用程序的 Documents
    目录中创建了一个名为 `images` 的目录：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can also delete a directory using either `deleteDirectory()` or `deleteDirectoryAsync()`.
    Listen for `Event.COMPLETE` when deleting a directory asynchronously.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `deleteDirectory()` 或 `deleteDirectoryAsync()` 删除目录。在异步删除目录时，监听 `Event.COMPLETE`
    事件。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing files*'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*写入文件*'
- en: '*Reading files*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取文件*'
- en: Writing files
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: AIR provides a file system API that can be used to write files of any type to
    the device.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: AIR 提供了一个文件系统 API，可以用于将任何类型的文件写入设备。
- en: Let us see how to write a text file containing simple preferences data that
    might, for example, be used by a game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何写入包含简单偏好数据的文本文件，例如，可能被游戏使用。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point for this recipe.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供一个 FLA 作为本菜谱的起点。
- en: From the book's accompanying support files, open `chapter13\recipe4\recipe.fla`
    into Flash Professional.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套支持文件中，将 `chapter13\recipe4\recipe.fla` 打开到 Flash Professional。
- en: Sitting on the stage is a dynamic text field named `output`. We will write some
    preferences data to the device and use the text field to indicate when the data
    has been written.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段上有一个名为 `output` 的动态文本字段。我们将向设备写入一些偏好数据，并使用文本字段来指示数据已被写入。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The `flash.filesystem` package contains classes that provide file system access.
    Let us make use of some of those classes to write to the device.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.filesystem` 包包含提供文件系统访问的类。让我们利用其中的一些类将数据写入设备。'
- en: Create a document class and name it `Main`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Main` 的文档类。
- en: 'Import the following classes:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下类：
- en: '[PRE12]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a `File` and `FileStream` member variable:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `File` 和 `FileStream` 成员变量：
- en: '[PRE13]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a method that writes the preferences data to the device, and call it
    from the constructor:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将偏好数据写入设备的方法，并在构造函数中调用它：
- en: '[PRE14]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a handler that gets called if an error occurs when writing the preferences
    data:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个处理程序，如果写入偏好数据时发生错误，则会调用它：
- en: '[PRE15]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a second handler that gets called once the file has been successfully written
    to the device''s file system:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个处理程序，一旦文件已成功写入设备文件系统，则会调用它：
- en: '[PRE16]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the class file and when prompted name it `Main.as`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类文件，并在提示时将其命名为 `Main.as`。
- en: 'Publish the FLA and test it on your device. The preferences file will be written
    and the following text will be shown on screen:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备上发布 FLA 并进行测试。偏好文件将被写入，屏幕上将显示以下文本：
- en: '**File Saved**'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**文件已保存**'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe took advantage of the `flash.filesystem.File` and `flash.filesystem.FileStream`
    classes to write data to the device's file system. The data was represented by
    a series of name-value pairs that were written to the app's Documents directory
    as a text file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方利用了`flash.filesystem.File`和`flash.filesystem.FileStream`类将数据写入设备的文件系统。数据通过一系列写入应用程序文档目录的文本文件中的名称-值对表示。
- en: When writing to a file, a reference representing it must first be obtained using
    the `File` class—this is true even for files that have yet to be created. As well
    as representing files, the `File` class can also be used to represent directories.
    A directory reference can also be refined by using `File.resolvePath()` to target
    a file or sub-folder relative to it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在向文件写入时，必须首先使用`File`类获取表示它的引用——即使对于尚未创建的文件也是如此。除了表示文件外，`File`类还可以用来表示目录。通过使用`File.resolvePath()`，可以进一步细化目录引用，以指向相对于它的文件或子目录。
- en: 'The following line of code shows a `File` object being created for the preferences
    file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码展示了为偏好文件创建的`File`对象：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to instantiate a `FileStream` object and use the `openAsync()`
    method to initialize it for writing:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实例化一个`FileStream`对象，并使用`openAsync()`方法对其进行初始化以进行写入：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see above, the `File` object is passed to `openAsync()`. As a second
    argument, the `FileMode.WRITE` constant is also passed, and indicates that data
    is to be written to the file. If the specified file doesn't exist, then `openAsync()`
    will create it. If it already exists, then its contents will be wiped.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`File`对象被传递给`openAsync()`。作为第二个参数，还传递了`FileMode.WRITE`常量，表示数据将被写入文件。如果指定的文件不存在，则`openAsync()`将创建它。如果它已经存在，则其内容将被清除。
- en: 'The `FileStream` class dispatches various events when writing data. It dispatches
    `IOErrorEvent.IO_ERROR` if it can''t create or find the file, and `Event.CLOSE`
    once it has finished writing data to it. Listeners for both events should be added:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`类在写入数据时触发各种事件。如果它无法创建或找到文件，则触发`IOErrorEvent.IO_ERROR`事件，一旦它已将数据写入文件，则触发`Event.CLOSE`事件。应添加对这两个事件的监听器：'
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the file opened for writing, `writeUTFBytes()` is called to actually write
    text to the file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 文件打开用于写入后，调用`writeUTFBytes()`实际上将文本写入文件：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final step is to close the `FileStream` object, preventing any more data
    from being written:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是关闭`FileStream`对象，以防止更多数据被写入：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is important to understand that the file is not guaranteed to have been fully
    written by the time you call the `close()` method. When writing a significant
    amount of data to the device, it may take some time. If this is the case, then
    the `FileStream` object will delay closing the file until after all the data is
    written. Once it is finished, the `FileStream` object will dispatch `Event.CLOSE`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，在您调用`close()`方法时，文件不一定已经完全写入。当向设备写入大量数据时，可能需要一些时间。如果是这种情况，则`FileStream`对象将延迟关闭文件，直到所有数据都写入完毕。一旦完成，`FileStream`对象将触发`Event.CLOSE`事件。
- en: While you can write files anywhere within the Application Home directory, due
    to sandbox restrictions, you can't write outside of it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在应用程序主目录内的任何位置写入文件，但由于沙盒限制，您不能在目录外写入。
- en: You can obtain more information regarding the `flash.filesystem.FileStream,
    flash.filesystem.File`, and `flash.filesystem.FileMode` classes from Adobe Community
    Help.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Adobe社区帮助中获取有关`flash.filesystem.FileStream, flash.filesystem.File`和`flash.filesystem.FileMode`类的更多信息。
- en: There's more...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here is some more detail that should come in handy when writing to the device's
    local file system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更详细的说明，这些说明在向设备的本地文件系统写入时可能很有用。
- en: Working with data formats
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理数据格式
- en: The `FileStream` class provides many methods for writing data. Your choice of
    method depends on the data format you wish to use.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`类提供了许多用于写入数据的方法。您选择的方法取决于您希望使用的数据格式。'
- en: For example, when working with text, you have the `writeUTF(), writeUTFBytes()`,
    and `writeMultiByte()` methods available. If you opt to work with byte arrays,
    then there are `writeByte()` and `writeBytes()` methods. You can even write primitives
    using `writeBoolean(), writeDouble(), writeFloat(), writeInt()`, and `writeShort()`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当处理文本时，您有`writeUTF(), writeUTFBytes()`和`writeMultiByte()`方法可用。如果您选择使用字节数组，则还有`writeByte()`和`writeBytes()`方法。您甚至可以使用`writeBoolean(),
    writeDouble(), writeFloat(), writeInt()`和`writeShort()`来写入原始数据。
- en: Writing synchronously
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步写入
- en: This recipe used `openAsync()`, meaning data could be written to the device
    asynchronously. Asynchronous operations take place in the background, allowing
    the execution of your ActionScript to continue rather than being blocked until
    the operation completes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱使用了`openAsync()`，这意味着数据可以异步写入设备。异步操作在后台进行，允许您的ActionScript代码继续执行，而不是在操作完成之前被阻塞。
- en: 'As an alternative to `openAsync()`, the `FileStream` class also provides `open()`,
    which allows data to be handled synchronously. Although execution will be blocked
    until the operation is complete, working synchronously is more straight forward
    as you aren''t required to register for events. In the following code snippet,
    you can see an alternative version of `savePreferences()` method, which writes
    data synchronously:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`openAsync()`的替代方案，`FileStream`类还提供了`open()`，它允许以同步方式处理数据。尽管执行将在操作完成之前被阻塞，但同步工作更直接，因为您不需要注册事件。在以下代码片段中，您可以看到`savePreferences()`方法的替代版本，它以同步方式写入数据：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Examples throughout this book that write to the device's file system, do so
    synchronously to help maintain focus on the task at hand.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例在写入设备文件系统时，都是同步进行的，以帮助保持对当前任务的关注。
- en: Monitoring progress
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控进度
- en: When asynchronously writing to a file, the `FileStream` object will periodically
    dispatch `OutputProgressEvent.OUTPUT_PROGRESS`. From this event object, you can
    monitor the progress of the write operation by checking its `bytesPending` and
    `bytesTotal` properties. The `bytesPending` property specifies the number of bytes
    that have still to be written, while `bytesTotal` represents the number of bytes
    that have been written so far.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步写入文件时，`FileStream`对象将定期触发`OutputProgressEvent.OUTPUT_PROGRESS`事件。从该事件对象中，您可以通过检查其`bytesPending`和`bytesTotal`属性来监控写入操作的进度。`bytesPending`属性指定了还需要写入的字节数，而`bytesTotal`表示到目前为止已写入的字节数。
- en: Persistence
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化
- en: Writing to the file system allows you to save your application's state to the
    device. When the app is re-launched, it can use this saved data to start from
    where it previously left off.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件系统允许您将应用程序的状态保存到设备上。当应用重新启动时，它可以使用这些保存的数据从上次离开的地方继续。
- en: As an alternative to AIR's file system API you can also use Flash's `SharedObject`
    class to manage state. In addition, small amounts of private data can be stored
    using the `EncryptedLocalStore` class introduced to iOS in AIR 3.0\. Detail regarding
    encrypted local storage can be found within Adobe Community Help.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为AIR文件系统API的替代方案，您还可以使用Flash的`SharedObject`类来管理状态。此外，可以使用在AIR 3.0中引入的`EncryptedLocalStore`类存储少量私有数据。有关加密本地存储的详细信息，请参阅Adobe社区帮助。
- en: Another option is to store your data within a local SQLite database and use
    ActionScript to access it. Apple itself uses SQLite databases on iOS devices to
    store information, such as contacts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将您的数据存储在本地SQLite数据库中，并使用ActionScript来访问它。苹果本身在iOS设备上使用SQLite数据库来存储信息，例如联系人。
- en: 'Relational database theory and the SQLite API are outside the scope of this
    book. However, you can find more information on the subject from Adobe Community
    Help or by visiting the SQLite website at: [sqlite.org](http://sqlite.org).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库理论和SQLite API不在此书的范围之内。然而，您可以从Adobe社区帮助或访问SQLite网站获取更多关于此主题的信息：[sqlite.org](http://sqlite.org)。
- en: See also
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Saving application state, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保存应用程序状态，[第4章](ch04.html "第4章。将Flash项目移植到iOS")*'
- en: '*Referencing an app''s common directories*'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引用应用程序的常见目录*'
- en: '*Reading files*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取文件*'
- en: Reading files
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文件
- en: AIR provides a file system API that can be used to read files of any type from
    the device.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: AIR提供了一个文件系统API，可以用来从设备读取任何类型的文件。
- en: In this recipe, we will see how to load a file previously written to the device.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将看到如何加载之前写入设备上的文件。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already done so, complete the *Writing files* recipe before proceeding.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请在继续之前完成*写入文件*食谱。
- en: You can continue to work with the code you wrote during that recipe. Alternatively,
    from the book's accompanying code bundle, open `chapter13\recipe5\recipe.fla`
    into Flash Professional and work from there.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续使用在该食谱中编写的代码。或者，从本书的配套代码包中，将`chapter13\recipe5\recipe.fla`打开到Flash Professional中，并从那里开始工作。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us update the FLA's document class to load and display the preferences that
    were written to the device.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新FLA的文档类，以加载并显示写入到设备上的首选项。
- en: Open the document class.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文档类。
- en: 'Add a method that will load the preferences data:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个将加载首选项数据的方法：
- en: '[PRE23]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alter the class'' `fileSaved()` handler, making it call the preceding method:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类的 `fileSaved()` 处理程序，使其调用前面的方法：
- en: '[PRE24]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A `COMPLETE` event will be dispatched when the file has been loaded. Add a
    handler for it that parses and displays the file''s preferences data:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文件已加载时，将分派一个 `COMPLETE` 事件。添加一个处理程序来解析和显示文件的偏好数据：
- en: '[PRE25]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `fileLoaded()` handler makes use of Flash''s `URLVariables` class to decode
    the preferences data. Add `URLVariables` to the document class'' list of import
    statements:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fileLoaded()` 处理程序使用 Flash 的 `URLVariables` 类来解码首选项数据。将 `URLVariables` 添加到文档类的导入语句列表中：'
- en: '[PRE26]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save `Main.as`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `Main.as`。
- en: Publish the FLA and test it on your device.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并在您的设备上测试它。
- en: The app will first write the preferences data to the file system before loading
    it back and displaying the preferences on screen.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将首先将首选项数据写入文件系统，然后再将其加载回并显示在屏幕上的首选项。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The steps required for reading data from the device's file system are almost
    identical to writing data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备文件系统读取数据所需的步骤几乎与写入数据相同。
- en: 'First a `File` object is created that references the target file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个 `File` 对象，它引用目标文件：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then a `FileStream` object is instantiated and initialized using the `openAsync()`
    method. When a file is being read rather than written, `FileMode.READ` is passed
    as the method''s second argument:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `openAsync()` 方法实例化并初始化 `FileStream` 对象。当正在读取文件而不是写入文件时，将 `FileMode.READ`
    作为方法的第二个参数传递：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And while `FileSystem.close()` is called immediately after `openAsync()` when
    writing a file, when reading, it shouldn't be called until the file's entire data
    has been obtained. This can be determined by listening for the `FileStream` object
    dispatching `Event.COMPLETE`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当写入文件时，`FileSystem.close()` 在 `openAsync()` 后立即调用，但在读取时，不应调用它，直到获取文件的全部数据。这可以通过监听
    `FileStream` 对象分派 `Event.COMPLETE` 来确定。
- en: 'To actually obtain the data, one of the `FileSystem` class'' read methods is
    required. For this recipe, `readUTFBytes()` was used and the number of bytes to
    read from the file''s buffer was passed to it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际获取数据，需要使用 `FileSystem` 类的读取方法之一。对于此配方，使用了 `readUTFBytes()`，并将从文件缓冲区读取的字节数传递给它：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `FileStream` class' read-only `bytesAvailable` property was used when calling
    `readUTFBytes()`. This property states the size of the file once it is completely
    loaded. Also, notice that the file stream is closed after its data is read as
    there is no longer a need for it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `readUTFBytes()` 时使用了 `FileStream` 类的只读 `bytesAvailable` 属性。此属性表示文件完全加载后的大小。注意，文件流在读取数据后关闭，因为不再需要它。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: You will find AIR's file system API invaluable for many of your iOS projects.
    Before we leave the subject, here are some final pieces of information to take
    with you.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现 AIR 的文件系统 API 对于许多 iOS 项目非常有价值。在我们离开这个主题之前，这里有一些最终的信息要带在身边。
- en: Working with data formats
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理数据格式
- en: The `FileStream` class provides many methods for reading data from a file. Your
    choice of method depends on the format of the data you are reading.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream` 类提供了许多从文件读取数据的方法。您选择的方法取决于您正在读取的数据格式。'
- en: For example, when working with text, the `readUTF(), readUTFBytes(),` and `readMultiBytes()`
    methods are available. If the file contains a byte array, then you can use the
    `readByte()` and `readBytes()` methods. Primitive types can be obtained using
    `readBoolean(), readDouble(), readFloat(), readInt()`, and `readShort().`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当处理文本时，有 `readUTF(), readUTFBytes(),` 和 `readMultiBytes()` 方法可用。如果文件包含字节数组，则可以使用
    `readByte()` 和 `readBytes()` 方法。可以使用 `readBoolean(), readDouble(), readFloat(),
    readInt()`, 和 `readShort()` 获取原始类型。
- en: Reading synchronously
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步读取
- en: 'As with the previous recipe, `openAsync()` was used, meaning the file was handled
    asynchronously. The following code uses the `open()` method instead to synchronously
    read this recipe''s preferences file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方一样，使用了 `openAsync()`，这意味着文件是异步处理的。以下代码使用 `open()` 方法来同步读取此配方的首选项文件：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Examples throughout this book that read from the device's file system, do so
    synchronously to help maintain focus on the task at hand.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例从设备文件系统读取数据，这样做是为了同步，以帮助保持对当前任务的关注。
- en: Monitoring progress
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控进度
- en: When asynchronously reading from a file, the `FileStream` object will periodically
    dispatch `ProgressEvent.PROGRESS`. From this event object, you can monitor the
    reading progress by checking its `bytesLoaded` and `bytesTotal` properties. The
    `bytesLoaded` property specifies the number of bytes that have been loaded, while
    `bytesTotal` represents the number of bytes that will be loaded if the file successfully
    loads.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步读取文件时，`FileStream`对象将定期派发`ProgressEvent.PROGRESS`事件。从该事件对象中，你可以通过检查其`bytesLoaded`和`bytesTotal`属性来监控读取进度。`bytesLoaded`属性指定已加载的字节数，而`bytesTotal`表示如果文件成功加载，将加载的字节数。
- en: Deleting files
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除文件
- en: You can delete a file using the `File` class' `deleteFile()` or `deleteFileAsync()`
    method. Listen for `Event.COMPLETE` when deleting asynchronously.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`File`类的`deleteFile()`或`deleteFileAsync()`方法删除文件。在异步删除时，监听`Event.COMPLETE`事件。
- en: Other file modes
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他文件模式
- en: 'Two other file modes are available: `FileMode.APPEND` and `FileMode.UPDATE`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种其他文件模式可用：`FileMode.APPEND`和`FileMode.UPDATE`。
- en: The Append mode always writes to the end of the file, meaning that an existing
    file's data will be added to rather than destroyed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 追加模式始终将数据写入文件末尾，这意味着现有文件的数据将被添加而不是被破坏。
- en: Update mode lets you both read from and write to a file using a single file
    stream. To successfully manage this, the `FileStream` class provides the `position`
    property, which can be used to determine and set the current position within the
    file. The `position` property is incremented every time a byte is written or read.
    It is also possible to move to any point within a file by setting this property.
    When this is done, the next read or write operation will take place from that
    position.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模式允许你使用单个文件流从文件中读取和写入。为了成功管理这一点，`FileStream`类提供了`position`属性，可以用来确定和设置文件中的当前位置。每次写入或读取一个字节时，`position`属性都会增加。也可以通过设置此属性来移动到文件中的任何位置。这样做后，下一次读取或写入操作将从该位置开始。
- en: See also
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Referencing an app''s common directories*'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引用应用程序的常用目录*'
- en: '*Writing files*'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*写入文件*'
- en: Launching system applications
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动系统应用程序
- en: On occasions you may want your app to provide functionality that is already
    available from iOS's system applications. To guarantee a consistent and familiar
    experience, it is possible to launch certain system apps rather than performing
    the task internally within your own. To enable this, iOS supports various URI
    schemes which can be used to launch a specific application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望你的应用程序提供iOS系统应用程序已经提供的功能。为了保证一致和熟悉的使用体验，可以启动某些系统应用程序，而不是在应用程序内部执行任务。为了启用此功能，iOS支持各种URI方案，可以用来启动特定的应用程序。
- en: In this recipe, you will learn how to use the `mailto` URI scheme to open and
    send e-mail from the Mail application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何使用`mailto` URI方案从邮件应用程序打开和发送电子邮件。
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, load `chapter13\recipe6\recipe.fla`
    into Flash Professional and use it as a starting point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将`chapter13\recipe6\recipe.fla`加载到Flash Professional中，并将其作为起点使用。
- en: Sitting on its stage is a button with an instance name of `mailBtn`. When pressed,
    it will launch the device's Mail application and pre-populate an e-mail for the
    user to send.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在其舞台上有一个名为`mailBtn`的按钮。当按下时，它将启动设备的邮件应用程序并为用户预填充一封电子邮件以便发送。
- en: Let us write the ActionScript required to make this happen.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写实现这一功能的ActionScript代码。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We will make use of both Flash's `navigateToURL()` function and `URLRequest`
    class to launch the Mail application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Flash的`navigateToURL()`函数和`URLRequest`类来启动邮件应用程序。
- en: Create a document class and name it `Main`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为`Main`。
- en: 'Import the following:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下内容：
- en: '[PRE31]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Within the constructor, listen for the button being pressed:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，监听按钮被按下：
- en: '[PRE32]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a method that will launch the Mail application and compose an e-mail.
    Within it, initialize strings that represent the recipient''s e-mail address,
    the subject heading, and the e-mail''s body:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法，用于启动邮件应用程序并编写电子邮件。在其中，初始化表示收件人电子邮件地址、主题标题和电子邮件正文的字符串：
- en: '[PRE33]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this code, replace someone `@somewhere.com` with the e-mail address you wish
    to target. For testing purposes, use your own.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码中，将某人`@somewhere.com`替换为你希望的目标电子邮件地址。出于测试目的，请使用你自己的地址。
- en: 'Staying within the `sendMail()` method, construct a URL that uses the `mailto`
    URI scheme:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sendMail()`方法中保持，构建一个使用`mailto` URI方案的URL：
- en: '[PRE34]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, launch the Mail application by passing the URL to Flash''s `navigateToURL()`
    function:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将URL传递给Flash的`navigateToURL()`函数来启动邮件应用：
- en: '[PRE35]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save the class file and when prompted name it `Main.as`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类文件，并在提示时将其命名为`Main.as`。
- en: Publish the FLA and test the app on your device. Tapping the button will open
    the Mail application, complete with a pre-populated e-mail.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并在您的设备上测试应用。点击按钮将打开邮件应用，并包含预先填充的电子邮件。
- en: How it works...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `mailto` URI is used to launch the Mail application and compose an e-mail.
    The URI must be constructed and formatted correctly for the Mail application to
    understand it. Once constructed, pass the request to Flash's `navigateToURL()`
    package-level function to actually launch the app.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`mailto` URI用于启动邮件应用并撰写电子邮件。URI必须正确构建和格式化，以便邮件应用能够理解它。一旦构建完成，将请求传递给Flash的`navigateToURL()`包级函数以实际启动应用。'
- en: 'As a minimum, the recipient''s e-mail address must be specified within the
    `mailto` URI:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，必须在`mailto` URI中指定收件人的电子邮件地址：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also pre-fill fields within the e-mail by adding query string parameters
    to the URI. For example, the following pre-populates the e-mail''s subject and
    body fields:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在URI中添加查询字符串参数来预先填充电子邮件中的字段。例如，以下预先填充了电子邮件的主题和正文字段：
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The supported query string parameters are as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的查询字符串参数如下：
- en: '`subject:` The e-mail''s Subject field'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subject:` 电子邮件的主题字段'
- en: '`body:` The e-mail''s body'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body:` 电子邮件的主体'
- en: '`to:` Allows the addition of more than one recipient within the To field'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to:` 允许在“收件人”字段中添加多个收件人'
- en: '`cc:` Allows recipients to be added to the carbon copy field'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cc:` 允许将收件人添加到抄送字段'
- en: '`bcc:` Allows recipients to be added to the blind carbon copy field'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bcc:` 允许将收件人添加到密件抄送字段'
- en: When adding multiple recipients to a field, use a comma to separate each address.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当在字段中添加多个收件人时，使用逗号分隔每个地址。
- en: 'The e-mail''s body can be specified as plain text or HTML. Here is an example
    using HTML:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件的主体可以指定为纯文本或HTML。以下是一个使用HTML的示例：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `mailto` specification prohibits the selection of an e-mail account within
    the URI. When multiple accounts are associated with a device, the default account
    is always used. Attachments are also unsupported.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`mailto`规范禁止在URI中选择电子邮件账户。当多个账户与设备关联时，始终使用默认账户。附件也不受支持。'
- en: Launching a system application forces the current app into the background on
    iOS 4 or above. On pre-iOS 4 devices, the current app is closed completely. It
    is, therefore, advisable to store your app's state before opening a system application.
    When the user is finished using the system application, it will be their responsibility
    to re-launch your app from the device's home screen or from the fast app switcher.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 4或更高版本上启动系统应用会强制当前应用进入后台。在iOS 4之前的设备上，当前应用将完全关闭。因此，在打开系统应用之前存储您应用的状态是明智的。当用户完成使用系统应用后，他们将从设备的主屏幕或快速应用切换器重新启动您的应用。
- en: There's more...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have covered the `mailto` URI scheme, now let us look at a few other applications
    that can be opened by `navigateToURL()`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了`mailto` URI方案，现在让我们看看可以通过`navigateToURL()`打开的几个其他应用。
- en: Dialing a phone number
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拨打电话号码
- en: 'The `tel` URI scheme can be used to launch the iPhone''s telephony application
    and dial a specified number. As the following example shows, the formatting of
    the `tel` URI is simple:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`tel` URI方案可用于启动iPhone的电话应用并拨打指定的号码。以下示例显示了`tel` URI的格式非常简单：'
- en: '[PRE39]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Most valid phone numbers are accepted, but to prevent malicious behavior, URIs
    containing the `*` or `#` characters aren't. When using the `tel` URI scheme,
    a phone number must always be specified within the URI.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数有效的电话号码都被接受，但为了防止恶意行为，包含`*`或`#`字符的URI不被接受。当使用`tel` URI方案时，电话号码必须在URI中指定。
- en: Sending SMS messages
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送短信消息
- en: 'The iPhone''s Messages application can be opened using the `sms` URI scheme.
    An optional phone number can be included, indicating that a new SMS message is
    to be created:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`sms` URI方案打开iPhone的消息应用。可以包含一个可选的电话号码，表示要创建新的短信消息：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the phone number is omitted, then the Messages application will open but
    won't create a message for the user to send.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略电话号码，则消息应用将打开，但不会为用户创建要发送的消息。
- en: It is not possible to pre-fill the message with text or specify more than one
    recipient.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 无法预先填充文本消息或指定多个收件人。
- en: Playing a YouTube video
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放YouTube视频
- en: The `navigateToURL()` function can be used to launch the native YouTube application.
    There is no specific URI scheme for this; instead a URL targeting the YouTube
    server is used.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigateToURL()` 函数可以用来启动本地的 YouTube 应用。没有特定的 URI 方案；相反，使用一个针对 YouTube 服务器的
    URL。'
- en: 'Simply construct a URL containing the ID of a video you would like to play.
    The URL should take the following format: `http://www.youtube.com/watch?v=ID`.
    You can obtain a video''s ID by visiting the YouTube website and extracting it
    from the browser''s address bar.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地构造一个包含您想播放的视频 ID 的 URL。该 URL 应采用以下格式：`http://www.youtube.com/watch?v=ID`。您可以通过访问
    YouTube 网站，并从浏览器的地址栏中提取视频 ID 来获取视频的 ID。
- en: Here is an example URL that can be passed to `navigateToURL():`
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可以传递给 `navigateToURL()` 的示例 URL：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: URI schemes within HTML
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML 中的 URI 方案
- en: 'URI schemes can also be embedded as links within HTML pages. This allows the
    user to launch system applications from within a `StageWebView` object. For example,
    the following HTML link will initiate a phone call:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: URI 方案也可以嵌入到 HTML 页面中的链接。这允许用户在 `StageWebView` 对象内启动系统应用。例如，以下 HTML 链接将启动一个电话呼叫：
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For more information regarding the `StageWebView` class, refer to [Chapter 11](ch11.html
    "Chapter 11. Rendering Web Pages").
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `StageWebView` 类的更多信息，请参阅[第 11 章](ch11.html "第 11 章。渲染网页")。
- en: See also
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Exiting gracefully from an app, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优雅地退出应用，[第 3 章](ch03.html "第 3 章。编写您的第一个应用")*'
- en: '*Opening a web page within Safari, [Chapter 11](ch11.html "Chapter 11. Rendering
    Web Pages")*'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Safari 中打开网页，[第 11 章](ch11.html "第 11 章。渲染网页")*'
- en: '*Launching the App Store*'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动 App Store*'
- en: '*Launching the Maps application*'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动 Maps 应用*'
- en: Launching the App Store
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 App Store
- en: Publishers often promote their back catalogue within their latest releases,
    providing direct links to each of their products within the App Store. This not
    only makes the purchase process incredibly easy for the user, but also encourages
    impulse buying.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 出版商经常在他们最新的发布中推广他们的旧作品，在 App Store 中为他们的每个产品提供直接链接。这不仅使购买过程对用户来说极其简单，而且也鼓励冲动购买。
- en: The App Store can be launched directly from your AIR for iOS app by passing
    a specific iTunes URL to Flash's `navigateToURL()` function. Let us see how to
    do this.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接从您的 AIR for iOS 应用中启动 App Store，通过传递特定的 iTunes URL 到 Flash 的 `navigateToURL()`
    函数。让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point for this recipe.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供 FLA 文件作为本菜谱的起点。
- en: From the book's accompanying code bundle, open `chapter13\recipe7\recipe.fla`
    into Flash Professional. Sitting on its stage is a button named `storeBtn`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将 `chapter13\recipe7\recipe.fla` 打开到 Flash Professional 中。在其舞台上有名为
    `storeBtn` 的按钮。
- en: Let us write some ActionScript to launch the App Store when this button is pressed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些 ActionScript 代码，当按下此按钮时启动 App Store。
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will open the App Store page for WeeWorld's WeeMee Avatar Creator app. First
    we will obtain a URL to the app's page, then we will write the actual code to
    link to it from our app.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开 WeeWorld 的 WeeMee Avatar Creator 应用的 App Store 页面。首先，我们将获取应用页面的 URL，然后我们将编写实际的代码来从我们的应用中链接到它。
- en: Obtaining the app's URL
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取应用的 URL
- en: The URL format is complicated to construct. To simplify the process, Apple has
    created the online Link Maker tool.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 构造 URL 格式比较复杂。为了简化过程，苹果创建了在线链接制作工具。
- en: Visit its web page at [http://itunes.apple.com/linkmaker](http://itunes.apple.com/linkmaker).![Obtaining
    the app's URL](img/1383_14_03.jpg)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问其网页：[http://itunes.apple.com/linkmaker](http://itunes.apple.com/linkmaker)。![获取应用的
    URL](img/1383_14_03.jpg)
- en: Define a search by filling in the page's fields. Enter **WeeMee Avatar Creator**
    into the **Search** field, set the country to **USA**, and select **iOS Apps**
    from the **Media Type** drop-down menu.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过填写页面字段来定义搜索。在**搜索**字段中输入**WeeMee Avatar Creator**，将国家设置为**USA**，并从**媒体类型**下拉菜单中选择**iOS
    Apps**。
- en: Click on the **Search** button on the right-hand side of the page to initiate
    a search. A list of matches will be generated and shown at the bottom of the page.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面右侧的**搜索**按钮以启动搜索。将生成一个匹配列表，并显示在页面底部。
- en: Look for **WeeMee Avatar Creator** listed within the **iPhone Apps** section
    and click on **iPhone App Link** on the right-hand side of its entry. A dialog
    box will appear containing details for the app.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**iPhone Apps**部分查找**WeeMee Avatar Creator**，然后在其条目的右侧点击**iPhone App 链接**。将出现一个包含应用详细信息的对话框。
- en: Copy the **Direct Link** URL from the dialog box.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从对话框中复制**直接链接**URL。
- en: Linking to the app from ActionScript
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从ActionScript链接到应用程序
- en: Now let us write the ActionScript required to launch the App Store page.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写启动App Store页面的ActionScript。
- en: Within Flash Professional, create a new document class and name it `Main`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Flash Professional中创建一个新的文档类，并将其命名为`Main`。
- en: 'Add the required import statements and listen for `storeBtn` being pressed:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的导入语句，并监听`storeBtn`被按下：
- en: '[PRE43]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add an event handler for the button, and within it open the App Store using
    the URL obtained from the Link Maker tool:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加事件处理程序，并在其中使用从链接制作工具获取的URL打开App Store：
- en: '[PRE44]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now save the document class' file, and when prompted name it `Main.as`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存文档类的文件，并在提示时将其命名为`Main.as`。
- en: Publish and test the app on your device. Tap the button to open the WeeMee Avatar
    Creator's entry within the App Store application.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备上发布并测试应用程序。轻触按钮以在App Store应用程序中打开WeeMee头像创建器的条目。
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Passing an app's valid iTunes URL to Flash's `navigateToURL()` package-level
    function will open the App Store application for that app. The URL for a particular
    app can be retrieved from Apple's Link Maker online tool.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个应用的合法iTunes URL传递给Flash的`navigateToURL()`包级函数将打开该应用的App Store应用程序。特定应用的URL可以从苹果的链接制作在线工具中检索。
- en: It is not just the App Store that can be opened from within your app. The Link
    Maker can create links to content on the iTunes Store and the iBookstore too.
    Simply perform a search for the content in question then obtain its URL.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以从您的应用程序中打开App Store，链接制作工具还可以创建指向iTunes Store和iBookstore内容的链接。只需对相关内容进行搜索，然后获取其URL。
- en: The various stores can also be launched from an HTML link within a `StageWebView`
    object. The Link Maker provides the required HTML within the same dialog box as
    the **Direct Link** URL. You can copy it from the **HTML With Link** text box.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的商店也可以从`StageWebView`对象内的HTML链接中启动。链接制作工具在**直接链接**URL的同一对话框中提供所需的HTML。您可以从**带有链接的HTML**文本框中复制它。
- en: See also
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Rendering a web page within an app, [Chapter 11](ch11.html "Chapter 11. Rendering
    Web Pages")*'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在应用程序内渲染网页，[第11章](ch11.html "第11章。渲染网页")*'
- en: '*Launching system applications*'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动系统应用程序*'
- en: '*Launching the Maps application*'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动地图应用程序*'
- en: Launching the Maps application
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动地图应用程序
- en: Being location aware, mapping is an integral part of iOS. The native Maps application
    lets you find where you currently are, search for nearby points of interest, and
    obtain turn-by-turn directions. Many developers take advantage of Maps by opening
    it directly from their own app, providing the user with a consistent experience.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 由于iOS具有位置感知功能，因此地图是iOS的一个基本组成部分。本机地图应用程序允许您找到您当前的位置，搜索附近的兴趣点，并获得逐个转弯的指示。许多开发人员通过直接从自己的应用程序中打开地图来利用地图，为用户提供一致的经验。
- en: Let us see how to do this.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter13\recipe8\recipe.fla`
    into Flash Professional.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 从书籍的配套代码包中，将`chapter13\recipe8\recipe.fla`打开到Flash Professional中。
- en: Sitting on its stage is a button with an instance name of `mapBtn`. We will
    add code to show the location of Adobe's headquarters when this button is pressed.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在其舞台上有按钮，实例名为`mapBtn`。当按下此按钮时，我们将添加代码以显示Adobe总部的位置。
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will use Flash's `URLRequest` class and `navigateToURL()` function to open
    the Maps application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Flash的`URLRequest`类和`navigateToURL()`函数来打开地图应用程序。
- en: Create a document class and name it `Main`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为`Main`。
- en: 'Import the classes required for this recipe and listen for the button being
    pressed:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入此菜谱所需的类，并监听按钮被按下：
- en: '[PRE45]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, add an event handler for the button and within it open the Maps application
    at Adobe''s headquarters:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为按钮添加事件处理程序，并在其中打开Adobe总部的地图应用程序：
- en: '[PRE46]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Save the class and when prompted name its file `Main.as`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类，并在提示时将其文件命名为`Main.as`。
- en: Publish and test the app on your device. Tap the button. The native Maps application
    will open and the location of Adobe's headquarters will be shown.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备上发布并测试应用程序。轻触按钮。本机地图应用程序将打开，并显示Adobe总部的位置。
- en: How it works...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If your app contains address or location information, you can forward that information
    to the Maps application. To do this, construct a URL and pass it to Flash's `navigateToURL()`
    package-level function. The URL should target the Google Maps server and contain
    one or more Google Maps parameters.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序包含地址或位置信息，您可以将这些信息转发到地图应用程序。为此，构造一个URL并将其传递给Flash的`navigateToURL()`包级函数。该URL应针对Google
    Maps服务器并包含一个或多个Google Maps参数。
- en: 'For this recipe, the Google Maps query parameter was used to map the location
    of Adobe''s headquarters:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，使用了Google Maps查询参数来映射Adobe总部的位置：
- en: '[PRE47]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The Maps application supports many of the Google Maps parameters but not all
    of them. Here is a list of those that are supported:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 地图应用程序支持许多Google Maps参数，但并非全部。以下是一个支持参数的列表：
- en: '| Parameter | Description |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `q` | The query parameter. Its value is treated as if it had been typed into
    the query box on the Google Maps web page. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `q` | 查询参数。其值被视为已输入到Google Maps网页上的查询框中。 |'
- en: '| `near` | Can be used as the location part of a query. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `near` | 可以用作查询的位置部分。 |'
- en: '| `ll` | The latitude and longitude for the map''s center point. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `ll` | 地图中心点的纬度和经度。 |'
- en: '| `sll` | The latitude and longitude from where a business search should take
    place. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `sll` | 商业搜索应进行的纬度和经度。 |'
- en: '| `spn` | An approximate latitude and longitude span. The zoom level will be
    adjusted to fit. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `spn` | 大约的纬度和经度跨度。缩放级别将进行调整以适应。 |'
- en: '| `sspn` | A screen span. The zoom level will be adjusted to fit. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `sspn` | 屏幕跨度。缩放级别将进行调整以适应。 |'
- en: '| `t` | The type of map to display. Can select m for maps, k for satellite,
    or h for hybrid. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 要显示的地图类型。可以选择 m 表示地图，k 表示卫星，或 h 表示混合。 |'
- en: '| `z` | The map''s zoom level ranging from 1 to 20. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `z` | 地图的缩放级别，范围从1到20。 |'
- en: '| `saddr` | The source address to use when generating directions. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `saddr` | 生成方向时使用的源地址。 |'
- en: '| `daddr` | The destination address to use when generating directions. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `daddr` | 生成方向时使用的目标地址。 |'
- en: '| `latlng` | A custom ID format used by Google to identify businesses. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `latlng` | Google用于识别商业的自定义ID格式。 |'
- en: '| `cid` | Another custom ID format used by Google to identify businesses. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `cid` | Google用于识别商业的另一种自定义ID格式。 |'
- en: Launching the Maps application forces the current app into the background on
    iOS 4 or above. On pre-iOS 4 devices, the current app is closed completely. It
    is, therefore, advisable to store your app's state before opening Maps. When the
    user is finished with the Maps application, it will be their responsibility to
    re-launch your app from the device's home screen or from the fast app switcher.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 启动地图应用程序会将当前应用程序在iOS 4或更高版本上置于后台。在iOS 4之前的设备上，当前应用程序将完全关闭。因此，在打开地图之前存储应用程序的状态是明智的。当用户完成地图应用程序的使用后，他们将从设备的首页或快速应用程序切换器重新启动您的应用程序。
- en: Visit [http://mapki.com/wiki/Google_Map_Parameters](http://mapki.com/wiki/Google_Map_Parameters)
    for a comprehensive description of each of the Google Maps parameters.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://mapki.com/wiki/Google_Map_Parameters](http://mapki.com/wiki/Google_Map_Parameters)
    了解每个Google Maps参数的详细描述。
- en: There's more...
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some other common uses for the Maps application.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是地图应用程序的一些其他常见用途。
- en: Generating directions
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成方向
- en: 'You can instruct the Maps application to generate directions between two addresses.
    The following ActionScript snippet uses Google Maps'' `saddr` and `daddr` parameters
    to produce driving directions between Adobe''s and Apple''s headquarters:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指示地图应用程序在两个地址之间生成方向。以下ActionScript代码片段使用Google Maps的 `saddr` 和 `daddr` 参数生成Adobe和苹果公司总部的驾驶方向：
- en: '[PRE48]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Mapping your current location
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射您的当前位置
- en: You can also show the user their current location. This can be done by determining
    their approximate location using AIR's `Geolocation` class and passing that information
    to the Maps application.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以显示用户的当前位置。这可以通过使用AIR的 `Geolocation` 类确定他们的近似位置，并将该信息传递给地图应用程序来实现。
- en: 'The following ActionScript obtains the latitude and longitude from a `GeolocationEvent`
    object, and constructs a Google Maps URL:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下ActionScript从 `GeolocationEvent` 对象中获取纬度和经度，并构建Google Maps URL：
- en: '[PRE49]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `ll` property is used when specifying a location's latitude and longitude.
    Both values are separated by a comma.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`ll` 属性用于指定位置的纬度和经度。两个值之间用逗号分隔。'
- en: See also
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Determining your current location, [Chapter 9](ch09.html "Chapter 9. Geolocation
    and Accelerometer APIs")*'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定您的当前位置，[第9章](ch09.html "第9章。地理位置和加速度计API")*'
- en: '*Launching system applications*'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动系统应用程序*'
- en: '*Launching the App Store*'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动App Store*'
- en: Declaring device capabilities
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明设备功能
- en: The hardware and software capabilities of devices vary across the iOS family.
    For example, some feature a built-in camera, whereas others do not. It is important
    that your app can only be downloaded and installed on devices that are compatible
    with it. To enable this, the required capabilities can be explicitly set for your
    app.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 设备的硬件和软件功能各不相同。例如，一些设备具有内置摄像头，而另一些则没有。确保您的应用程序只能下载并安装在其兼容的设备上非常重要。为此，可以为您的应用程序显式设置所需的功能。
- en: You can't specify these capabilities directly from Flash Professional. Instead,
    you need to edit your FLA's application descriptor file. Let us see how to do
    this for an app that requires the presence of the native Messages application
    and an on-board GPS receiver.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能直接从 Flash Professional 指定这些功能。相反，您需要编辑 FLA 的应用程序描述符文件。让我们看看如何为一个需要原生消息应用程序和内置
    GPS 接收器的应用程序执行此操作。
- en: Getting ready
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter13\recipe9\recipe.fla`
    and work from there. The FLA's stage is empty but its AIR for iOS settings have
    already been applied letting you easily publish once you are ready.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 从书籍的配套代码包中打开 `chapter13\recipe9\recipe.fla` 并从那里开始工作。FLA 的舞台是空的，但其 AIR for iOS
    设置已经应用，让您准备好发布。
- en: How to do it...
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us edit your application descriptor file from within Flash Professional.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Flash Professional 内部编辑您的应用程序描述符文件。
- en: From Flash Professional, select **File** | **Open** and select `recipe-app.xml`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Flash Professional 中选择 **文件** | **打开** 并选择 `recipe-app.xml`。
- en: 'Scroll down the file until you find the following XML fragment:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件向下滚动，直到找到以下 XML 片段：
- en: '[PRE50]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Within the `CDATA` node, add the following key-value pair to the XML:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CDATA` 节点中，将以下键值对添加到 XML 中：
- en: '[PRE51]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Save the file.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'Publish the FLA. If you have an iOS device that lacks either the native Messages
    application or GPS, then try installing the `.ipa` file. You will receive an error
    message similar to the following one:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA。如果您有一部缺少原生消息应用程序或 GPS 的 iOS 设备，那么尝试安装 `.ipa` 文件。您将收到类似于以下错误消息的信息：
- en: '**The app "c13 r9" was not installed because it is not compatible with this
    device.**'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**应用程序 "c13 r9" 未安装，因为它与此设备不兼容。**'
- en: How it works...
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Your FLA's application descriptor is an XML file that contains a list of iOS
    specific settings. Within the`<iPhone>` node is the`<infoAdditions>` node where
    you can set custom key-value pairs that can't be set within Flash. These are used
    to describe an app or used directly by it when launched.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 FLA 应用程序描述符是一个包含 iOS 特定设置的 XML 文件。在 `<iPhone>` 节点内是 `<infoAdditions>` 节点，您可以在其中设置不能在
    Flash 中设置的定制键值对。这些键值对用于描述应用程序或当应用程序启动时直接使用。
- en: The `UIRequiredDeviceCapabilities` key is used to specify the capabilities required
    by your app. If the device lacks the capabilities, then the app won't be installed.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIRequiredDeviceCapabilities` 键用于指定应用程序所需的功能。如果设备缺少这些功能，则应用程序将无法安装。'
- en: 'Each capability should be listed within an`<array>` node:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 每个功能都应该列在 `<array>` 节点内：
- en: '[PRE52]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example XML snippet shows the `sms` and `gps` capabilities being listed.
    The `sms` capability stipulates that your app requires the presence of the Messages
    application, while `gps` states that the device should include GPS hardware.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例 XML 片段显示了 `sms` 和 `gps` 功能的列表。`sms` 功能规定您的应用程序需要消息应用程序的存在，而 `gps` 则表示设备应包含
    GPS 硬件。
- en: 'The following capabilities can be specified with the `UIRequiredDeviceCapabilities`
    key:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `UIRequiredDeviceCapabilities` 键指定以下功能：
- en: '| Capability | Description |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 描述 |'
- en: '| --- | --- |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `telephony` | The app requires the presence of the Phone application. |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `telephony` | 应用程序需要电话应用程序的存在。|'
- en: '| `wifi` | Networking features of the device will be accessed by the app. |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `wifi` | 应用程序将访问设备的网络功能。|'
- en: '| `sms` | The app requires the presence of the Messages application. |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `sms` | 应用程序需要消息应用程序的存在。|'
- en: '| `still-camera` | A camera is required to capture photos. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `still-camera` | 捕获照片需要摄像头。|'
- en: '| `auto-focus-camera` | A camera with auto-focus is required to capture photos.
    |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `auto-focus-camera` | 捕获照片需要具备自动对焦功能的摄像头。|'
- en: '| `front-facing-camera` | The app requires a forward-facing camera. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `front-facing-camera` | 应用程序需要前置摄像头。|'
- en: '| `camera-flash` | A camera flash is required for taking photos or shooting
    video. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `camera-flash` | 拍照或拍摄视频需要摄像头闪光灯。|'
- en: '| `video-camera` | A camera with video capabilities is required on the device.
    |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `video-camera` | 设备上需要具备视频功能的摄像头。|'
- en: '| `accelerometer` | Access to an accelerometer is required. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `accelerometer` | 需要访问加速度计。 |'
- en: '| `location-services` | The app will attempt to retrieve the device''s current
    location. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `location-services` | 应用程序将尝试获取设备的当前位置。 |'
- en: '| `gps` | The device should include GPS hardware for location tracking. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `gps` | 设备应包含用于位置跟踪的GPS硬件。 |'
- en: '| `microphone` | A built-in microphone is required by the app. |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `microphone` | 应用程序需要内置麦克风。 |'
- en: The capabilities listed within the application descriptor file are also used
    by the App Store to prevent users from downloading apps that they can't run.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序描述文件中列出的功能也被App Store用于防止用户下载无法运行的应用。
- en: 'Try to keep an eye on the official Apple documents as the list of device capabilities
    grows with each new release of iOS: [http://developer.apple.com/library/ios/#documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html](http://developer.apple.com/library/ios/#documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html).'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意官方Apple文档，随着iOS每个新版本的发布，设备功能列表也在增长：[http://developer.apple.com/library/ios/#documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html](http://developer.apple.com/library/ios/#documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html).
- en: Of course, whether you can take advantage of any new capabilities will also
    depend on future releases of AIR or any native extensions you decide to use.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您能否利用任何新功能也将取决于AIR的未来版本或您决定使用的任何原生扩展。
- en: There's more...
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A final word regarding device capabilities.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于设备功能的话。
- en: Dropped support for ARMv6 devices
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已弃用对ARMv6设备的支持
- en: Apps published using AIR 2.6 and above do not support older ARMv6 iOS devices.
    AIR automatically includes the `armv7` and `opengles-2` capabilities in the application
    descriptor file in order to prevent owners of older iOS devices from downloading
    and installing these apps.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AIR 2.6及以上版本发布的应用程序不支持较旧的ARMv6 iOS设备。为了防止旧iOS设备的用户下载和安装这些应用程序，AIR自动在应用程序描述文件中包含`armv7`和`opengles-2`功能。
- en: You do not need to explicitly add these two capabilities to the application
    descriptor file.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要明确将这些两个功能添加到应用程序描述文件中。
- en: See also
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Editing the application descriptor file, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编辑应用程序描述文件，[第3章](ch03.html "第3章。编写您的第一个应用程序")*'
