<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Behavioral Patterns – Strategy, State, and Template Method</h1></div></div></div><p>I hope you're still with us; now, we will introduce you to the third and last category of the design patterns, which is categorized as a <a class="indexterm" id="id231"/>
<strong>Gang of Four</strong> (<strong>GoF</strong>) design patterns: the behavioral pattern. Behavioral patterns are dedicated to algorithms and communication between them.</p><p>As algorithms consist of several operations that are divided into different classes, behavioral patterns can handle the organization of such classes and the ways in which they can communicate with one another.</p><p>The <a class="indexterm" id="id232"/>behavioral category contains 11 patterns that we will discuss through four chapters. In this chapter, we will discuss the following three patterns:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The strategy pattern</li><li class="listitem" style="list-style-type: disc">The state pattern</li><li class="listitem" style="list-style-type: disc">The template method pattern</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>The strategy pattern</h1></div></div></div><p>When <a class="indexterm" id="id233"/>you need to change part of an object's algorithm at runtime, without modifying the client, the strategy pattern is the appropriate pattern to be used.</p><p>It removes <a class="indexterm" id="id234"/>an algorithm from its host class and moves it to a separate class. The algorithm part that can change is the <strong>strategy</strong>. Every strategy uses the same interface. The class using the strategy pattern delegates the treatment of the algorithm to the strategy.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec90"/>Roles</h2></div></div></div><p>The <a class="indexterm" id="id235"/>strategy pattern is used to create an interchangeable family of algorithms from which the required process is chosen at runtime.</p><p>The algorithm changes don't affect the client part. This pattern can be used in the following cases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The behavior of a class can be implemented by different algorithms where some of them are better in terms of execution time or memory consumption</li><li class="listitem" style="list-style-type: disc">Choosing the appropriate algorithm with <code class="literal">if</code> conditions instruction complexify the code</li><li class="listitem" style="list-style-type: disc">A system has similar classes where only the behavior changes; in this case, the strategy pattern allows you to group these classes in only one class, which greatly simplifies the interface for clients</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec91"/>Design</h2></div></div></div><p>The generic <a class="indexterm" id="id236"/>structure of the strategy platform is as follows:</p><div><img alt="Design" src="img/4582_05_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec92"/>Participants</h2></div></div></div><p>The participants<a class="indexterm" id="id237"/> in the strategy pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">IStrategy</code>: This <a class="indexterm" id="id238"/>class defines the common interface implemented by all algorithms. This is the interface used by the <code class="literal">ClassUsingStrategy</code> class to invoke the right algorithm.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteStrategyA</code> and <code class="literal">ConcreteStrategyB</code>: These <a class="indexterm" id="id239"/>are <a class="indexterm" id="id240"/>concrete classes that implement different algorithms based on the <code class="literal">IStrategy</code> interface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ClassUsingStrategyA</code> and <code class="literal">ClassUsingStrategyB</code>: These<a class="indexterm" id="id241"/> are classes that use an algorithm from<a class="indexterm" id="id242"/> classes that implement the <code class="literal">IStrategy</code> interface. These classes have a reference to one instance of one of the concrete strategy classes. These classes can expose some internal data to the implementation classes.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec93"/>Collaboration</h2></div></div></div><p>The <a class="indexterm" id="id243"/>
<code class="literal">ClassUsingStrategy</code> and <code class="literal">ConcreteStrategy</code> classes interact to implement algorithms.</p><p>In most cases, data needed by the algorithms is sent as arguments to the constructor but can be sent by a set property too. If needed, the <code class="literal">ClassUsingStrategy</code> class can provide you some methods to allow you to access its internal data.</p><p>The <code class="literal">Client</code> instance will initiate <code class="literal">ClassUsingStrategy</code> with a <code class="literal">Strategy</code> object and call the <code class="literal">ClassUsingStrategy</code> method that uses the strategy pattern.</p><p>Then, this class will send the request received from the client to the instance that is referenced by the strategy attribute.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec94"/>Illustration</h2></div></div></div><p>We will <a class="indexterm" id="id244"/>see how to implement the strategy pattern using a simple example.</p><p>Some objects can move, but some of them don't move in the same manner. Each object has a particular manner in which it moves: some can walk and others can run and fly. The move behavior is our strategy, and we will encapsulate the <code class="literal">performMove()</code> action in the concrete strategy class that is referenced in the concrete class using the strategy.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec95"/>Implementation</h2></div></div></div><p>Open <a class="indexterm" id="id245"/>the strategy pattern Xcode project to see the organization of our code. The participants in this pattern are separated in four folders, as shown in the following screenshot:</p><div><img alt="Implementation" src="img/4582_05_02.jpg"/></div><p>The first thing that we will do is define the interface of the move strategy and then describe <code class="literal">AbstractClassUsingMoveStrategy</code>.</p><p>The interface of the move strategy is really easy; we will only tell the class implementing the strategy that we are waiting for a <code class="literal">performMove</code> method.</p><p>The <code class="literal">MoveStrategyProtocol.swift</code> file is as follows:</p><div><pre class="programlisting">//Common Interface used by algorithms
protocol MoveStrategyProtocol {
  func performMove()
}</pre></div><p>Our abstract class needs to have a role to keep a reference to the strategy that will be applied by encapsulating the call to the <code class="literal">performMove</code> method of the current strategy into its own method that we will call <code class="literal">move()</code>. The instance of the strategy object will be received in the constructor of the class implementing the <code class="literal">AbstractObjectThatMove</code> class.</p><p>For our demo, we will add an internal computed property, <code class="literal">WhoAmI</code>, where we will set or get the name of the concrete class using the strategy pattern.</p><p>Our <code class="literal">AbstractObjectThatMove.swift</code> file is as follows:</p><div><pre class="programlisting">class AbstractObjectThatMove {
  private var strategy: MoveStrategyProtocol!
  private var whoAmI:String = "Unknown Object"
  
  required init(strategy: MoveStrategyProtocol) {
    self.strategy = strategy
  }
  
  func move(){
    strategy.performMove()
  }
  
  internal var WhoAmi: String {
    get {
      return whoAmI
    }
    set {
      whoAmI = newValue
    }
  }
}</pre></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>Swift 2.0 has <a class="indexterm" id="id246"/>no support for abstract classes as yet. Here, we named the <code class="literal">AbstractObjectThatMove</code> class, even if it is not a "real" abstract class, only to be as close as possible to the general concept of the pattern. Nevertheless, there might be a way to have something that seems like an abstract class, but it differs from the general concept of the pattern where we pass a strategy to the initializer. Swift 2.0 has protocol extensions that give the opportunity to add partial implemented methods to protocols, and in "some way", make an abstract class:</p><div><pre class="programlisting">protocol AbstractObjectThatMove {
   var WhoAmi: String { get set}
}
extension AbstractObjectThatMove {
    func move(strategy: IMoveStrategy) {
       strategy.performMove()
    }
}
class Human : AbstractObjectThatMove {
    var WhoAmi: String = "i'm a human"
}</pre></div></div></div><p>Then, we can process the following code:</p><div><pre class="programlisting">print("- *** working with Human")
let strategyForHuman = WalkMoveStrategy()
let human = Human()

// Tell who am I
print(human.WhoAmi)

//perform human move:
human.move(strategyForHuman)</pre></div><p>So, we come <a class="indexterm" id="id247"/>back to the implementation of the pattern. In our current example, we have three concrete classes that implement the abstract classes: <code class="literal">Rabbit</code>, <code class="literal">Bird</code>, and <code class="literal">Human</code>. As the implementation is the same for all these three objects, I will only display the implementation of the concrete <code class="literal">Human</code> class:</p><div><pre class="programlisting">class Human: AbstractObjectThatMove {
  required init(strategy: MoveStrategyProtocol){
    super.init(strategy: strategy)
    self.WhoAmi = "i'm a human"
  }
}</pre></div><p>We want to add a value to the <code class="literal">WhoAmI</code> property while it is initializing, so we inform the <code class="literal">init</code> method that this method is required. We then set the value of the property with a simple <code class="literal">self.WhoAmi = "I'm a human"</code> statement.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>We could have done this by adding an additional parameter to the constructor defined in the <code class="literal">AbstractClass</code> that takes the value of <code class="literal">WhoAmI</code> and assigns it to the internal <code class="literal">whoAmI</code> variable too.</p></div></div><p>Now, we will implement <code class="literal">WalkMoveStrategy</code>, as defined in the <code class="literal">MoveStrategyProtocol</code> protocol:</p><div><pre class="programlisting">class WalkMoveStrategy: MoveStrategyProtocol {
  func performMove() {
    print("I am walking")
  }
}</pre></div><p>There's nothing complex here; we implement the <code class="literal">performMove</code> method and print the message of the move action. The <code class="literal">RunMoveStrategy</code> and <code class="literal">FlyMoveStrategy</code> methods are implemented in the same way; just the <code class="literal">print</code> statement changes:</p><div><pre class="programlisting">Last, to complete the example, we will make our human, bird, and rabbit perform a move according to the strategy they apply:print("- *** working with Human")
<strong>let strategyForHuman = WalkMoveStrategy()</strong>
<strong>let human = Human(strategy: strategyForHuman)</strong>

// Tell who am I
print(human.WhoAmi)

//perform human move:
<strong>human.move()</strong>


print("- *** working with Bird")
let strategyForBid = FlyMoveStrategy()
let bird = Bird(strategy: strategyForBid)

// Tell who am I
print(bird.WhoAmi)

//perform human move:
bird.move()

print("- *** working with Rabbit")
let strategyForRabbit = RunMoveStrategy()
let rabbit = Rabbit(strategy: strategyForRabbit)

// Tell who am I
print(rabbit.WhoAmi)

//perform human move:
rabbit.move()</pre></div><p>In the preceding<a class="indexterm" id="id248"/> highlighted code, you can see how we proceeded to apply the strategy to the <code class="literal">Human</code> class using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we instantiate a strategy.</li><li class="listitem">Next, we instantiate a concrete class using the strategy pattern where the strategy declared first is sent as an argument.</li><li class="listitem">Then, we perform a move action in the concrete class. The move action invokes the <code class="literal">performMove</code> method of the strategy that the concrete class has in reference.</li><li class="listitem">Click on the <strong>Run</strong> button to see the result.</li></ol></div><p>You should see the following result in the console of Xcode:</p><div><img alt="Implementation" src="img/4582_05_03.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>The state pattern</h1></div></div></div><p>In<a class="indexterm" id="id249"/> the state pattern, a class behavior changes based on its state. This type of design pattern comes under the behavior pattern.</p><p>In the state <a class="indexterm" id="id250"/>pattern, we create objects that represent various states and a context object whose behavior varies as its state object changes.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec96"/>Role</h2></div></div></div><p>The<a class="indexterm" id="id251"/> role of this pattern is to adapt its behavior depending on the internal state of an object. It can be used when implementing the dependency of the state object if the condition statement becomes complex.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec97"/>Design</h2></div></div></div><p>The <a class="indexterm" id="id252"/>generic class diagram structure of the state pattern is as follows:</p><div><img alt="Design" src="img/4582_05_04.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec98"/>Participants</h2></div></div></div><p>The participants<a class="indexterm" id="id253"/> in the state pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">StateMachine</code>: This<a class="indexterm" id="id254"/> is a concrete class that describes a state machine's objects, which means that they have a set of states that can be described in a state transition diagram. This class has a reference to an instance of a sub class that implements the state abstract class and defines the current state.</li><li class="listitem" style="list-style-type: disc"><code class="literal">IState</code>: This <a class="indexterm" id="id255"/>is an abstract class that introduces you to the methods signature of a state behavior.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteStateA</code> and <code class="literal">ConcreteStateB</code>: These <a class="indexterm" id="id256"/>are <a class="indexterm" id="id257"/>concrete subclasses that implement the behavioral methods depending on the state.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec99"/>Collaboration</h2></div></div></div><p>The <a class="indexterm" id="id258"/>
<code class="literal">StateMachine</code> object delegates the call of the method to a <code class="literal">ConcreteState</code> object depending on the current state.</p><p>The <code class="literal">StateMachine</code> object can send a reference to itself and to the <code class="literal">ConcreteState</code> object if needed. This reference can then be sent through the initialization of the <code class="literal">concreteState</code> object or each time calls are delegated.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec100"/>Illustration</h2></div></div></div><p>Your<a class="indexterm" id="id259"/> company needs to sell a new device that has only two buttons that can play the radio or some music. You need to have the following functionalities, depending on the current state of the device:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>State</p>
</th><th style="text-align: left" valign="bottom">
<p>Action button</p>
</th><th style="text-align: left" valign="bottom">
<p>Source button</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Radio</p>
</td><td style="text-align: left" valign="top">
<p>This changes to the next station and plays it</p>
</td><td style="text-align: left" valign="top">
<p>This changes to music playing mode</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Playing music</p>
</td><td style="text-align: left" valign="top">
<p>This pauses the music</p>
</td><td style="text-align: left" valign="top">
<p>This changes to standby mode</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pausing music</p>
</td><td style="text-align: left" valign="top">
<p>This plays the music</p>
</td><td style="text-align: left" valign="top">
<p>This changes to standby mode</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Standby</p>
</td><td style="text-align: left" valign="top">
<p>This changes to radio mode</p>
</td><td style="text-align: left" valign="top">
<p>This does nothing</p>
</td></tr></tbody></table></div><p>The preceding table shows us that we have four states to implement. Depending on the state, the button's behaviors will not be the same.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec101"/>Implementation</h2></div></div></div><p>First, open <a class="indexterm" id="id260"/>the <code class="literal">StatePattern.xcodeproj</code> file to see the structure of the project.</p><p>Our audio player device is represented by the <code class="literal">Player.swift</code> class in the <code class="literal">ConcreteClassWithState</code> folder.</p><p>Our common interface that defines the method signature of a state behavior is defined in the <code class="literal">IPlayerState.swift</code> file. Each state that implements the <code class="literal">IPlayerState</code> interfaces are grouped in the <code class="literal">ConcreteState</code> folder.</p><p>The <code class="literal">main.swift</code> file contains our demo client:</p><div><img alt="Implementation" src="img/4582_05_05.jpg"/></div><p>As always, we will first define our interface. Each state will implement a behavior for each of the two buttons visible on our audio player and pass the device object as an argument. This will allow the current state object to manipulate the current state of the audio player object:</p><div><pre class="programlisting">protocol IAudioPlayerState{
  func buttonAction(player:AudioPlayer)
  func buttonSource(player:AudioPlayer)
}</pre></div><p>Then, we can implement our audio player. The <code class="literal">init</code> method is waiting to receive a <code class="literal">concreteState</code> instance that we will keep in mind in the state variable.</p><p>We define our two buttons. Each of them will delegate the request to the state object by invoking the appropriate button.</p><p>We then add a computed property called <code class="literal">CurrentState</code> that allows us to return the current state of the audio player or to change it through the state objects.</p><p>The final code of the <code class="literal">AudioPlayer</code> class is as follows:</p><div><pre class="programlisting">import Foundation

class AudioPlayer {
  private var state:IAudioPlayerState!
  
  required init(state:IAudioPlayerState){
    self.state = state
  }
  
  //Press the Action Button
  func ActionButton(){
    state.buttonAction(self)
  }
  
  //Press the Source Button
  func SourceButton(){
    state.buttonSource(self)
  }
  
  var CurrentState:IAudioPlayerState{
    get{
      return state
    }
    set{
      state = newValue
    }
  }
}</pre></div><p>Our player is <a class="indexterm" id="id261"/>now ready and the interface implemented by the state's objects is defined. We can now start with coding our first state: the <code class="literal">RadioState</code> class.</p><p>This class represents the state where the audio player plays the radio:</p><div><pre class="programlisting">import Foundation

class RadioState: IAudioPlayerState {
  
  init(){
    print("RADIO MODE")
  }
  
  func buttonSource(player: AudioPlayer) {
    print("Changing to MUSIC Mode")
    player.CurrentState = MusicPlayingState()
  }
  
  func buttonAction(player: AudioPlayer) {
    print("Choosing next Station &amp; playing it")
  }
}</pre></div><p>The<a class="indexterm" id="id262"/> implementation is quite simple; we inform the <code class="literal">init()</code> method that we are in the radio mode. We implement the <code class="literal">IAudioPlayerState</code> protocol and the <code class="literal">buttonSource</code> and <code class="literal">buttonAction</code> methods.</p><p>As we are in the radio mode, pressing <code class="literal">buttonAction</code> will change it to the next station, and clicking on the source button will move it to the <code class="literal">MusicPlaying</code> state.</p><p>To change the state of the audio player, we only need to make a call to the <code class="literal">CurrentState</code> property of the player object:</p><div><pre class="programlisting">    player.CurrentState = MusicPlayingState()</pre></div><p>Using the same logical implementation and based on the table in the preceding example, we can complete our code. The following code is the implementation of the <code class="literal">MusicPlayingState</code> class:</p><div><pre class="programlisting">class MusicPlayingState: IAudioPlayerState {
  
  init(){
    print("MUSIC PLAY MODE")
  }
  
  func buttonSource(player: AudioPlayer) {
    print("Changing source to Standby Mode")
    player.CurrentState = StandByState()
  }
  
  func buttonAction(player: AudioPlayer) {
    print("Changing to Pausing Mode")
    player.CurrentState = MusicPausedState()
  }
}</pre></div><p>The following code is the implementation of the <code class="literal">MusicPausedState</code> class:</p><div><pre class="programlisting">class MusicPausedState: IAudioPlayerState {
  
  init(){
    print("MUSIC PAUSED MODE")
  }
  
  func buttonSource(player: AudioPlayer) {
    print("Changing source to Standby Mode")
    player.CurrentState = StandByState()
  }

  func buttonAction(player: AudioPlayer) {
    print("Changing to playing Mode")
    player.CurrentState = MusicPlayingState()
  }
}</pre></div><p>The following <a class="indexterm" id="id263"/>code is the implementation of  the <code class="literal">StandBySTate</code> class:</p><div><pre class="programlisting">class StandByState: IAudioPlayerState {
  
  init(){
    print("STANDBY MODE")
  }
  
  func buttonSource(player: AudioPlayer) {
    print("Changing to Radio Mode")
    player.CurrentState = RadioState()
  }
  
  func buttonAction(player: AudioPlayer) {
    print("cannot launch an action in standby mode")
  }
}</pre></div><p>Our player is now ready to work. We will code our demo case to test whether the functionalities implemented are working as described in the table given in the introduction of the sample.</p><p>Open the <code class="literal">main.swift</code> file and write the following code:</p><div><pre class="programlisting">let standbyMode = StandByState()
let player = AudioPlayer(state: standbyMode)

player.ActionButton()
player.SourceButton()

player.ActionButton()
player.SourceButton()

player.ActionButton()
player.ActionButton()
player.SourceButton()</pre></div><p>First, we instantiate the first state where our audio player will be. We decide to put it in the <code class="literal">StandBy</code> mode.</p><p>Then, we instantiate <a class="indexterm" id="id264"/>our audio player and pass the <code class="literal">standbymode</code> state as an argument. Finally, we will simulate an action on by clicking the action or source button. Let's run the code, and you will see the result, as shown in the following example:</p><div><img alt="Implementation" src="img/4582_05_06.jpg"/></div><p>We start in the standby mode. The action button tells us that we cannot use it in the standby mode. So, we click on the source button and enter in the <code class="literal">radioMode</code>. We push the action button again; this changes to the next station and plays it.</p><p>We push the source button again and change to the music mode by playing the music. We push the action button and the music is paused. We then push the action button again and the music is played again.</p><p>Finally, we push the source button and the audio player comes back in the audio mode.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>The template method</h1></div></div></div><p>The<a class="indexterm" id="id265"/> template method pattern is a simple pattern used <a class="indexterm" id="id266"/>when you need a general behavior but where the details of the algorithm must be specific to subclasses.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec102"/>Role</h2></div></div></div><p>The <a class="indexterm" id="id267"/>template method pattern isolates various parts of an algorithm. The algorithm skeleton is defined in an abstract class where some steps of the algorithm are delegated to its subclasses and some others are fixed in the abstract class itself and cannot be overridden in subclasses.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec103"/>Design</h2></div></div></div><p>The<a class="indexterm" id="id268"/> following diagram describes the generic structure of the template method:</p><div><img alt="Design" src="img/4582_05_07.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec104"/>Participants</h2></div></div></div><p>The participants<a class="indexterm" id="id269"/> of this pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">AbstractClass</code>, which defines the template method, and the signature of the sub parts of the algorithm are invoked by the template method.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ConcreteClass</code> implements abstract methods used by the template method of the <code class="literal">AbstractClass</code>. It is possible to have several concrete classes.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec105"/>Collaboration</h2></div></div></div><p>The<a class="indexterm" id="id270"/> algorithm defined in the template method is called <code class="literal">TemplateMethod()</code> in the generic UML class diagram and invokes parts of the algorithm in the subclasses.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec106"/>Illustration</h2></div></div></div><p>You <a class="indexterm" id="id271"/>are working on a new simulation game with several personage types. Each personage has several properties, such as money, happiness, fatigue, hungry, and knowledge.</p><p>Each of these personages can "Play" a day. A day is decomposed in several parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GetUp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">EatBreakFast</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DoWashingUp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GoToWork</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Work</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GoHome</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DoPersonalActivites</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">EatDinner</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Sleep</code></li></ul></div><p>We have three types of personages: <code class="literal">Student</code>, <code class="literal">Searcher</code>, and <code class="literal">FireMan</code>; each of them can "play" a day but doesn't react in the same way depending on the day phase.</p><p>So, we will override parts of the algorithm in the concrete class by defining the personage type. The only part of the algorithm that is fixed is the <code class="literal">DoWashingUp</code> function. This part will not and cannot be overridden in subclasses.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec107"/>Implementation</h2></div></div></div><p>Open <a class="indexterm" id="id272"/>the <strong>TemplateMethod</strong> project with Xcode. The project is quite simple. We will find the <code class="literal">TemplateMethod</code> folder in the <code class="literal">AbstractPersonage.Swift</code> class and all concrete subclasses that implement parts of the algorithm in the three concrete classes: <code class="literal">Searcher</code>, <code class="literal">Student</code>, and <code class="literal">FireMan</code>:</p><div><img alt="Implementation" src="img/4582_05_08.jpg"/></div><p>To implement the preceding example, we will first prepare our abstract class that defines a personage. Remember <a class="indexterm" id="id273"/>to consider this class as an abstract class. You must not instantiate it directly to your code, but you must instantiate only a subclass of <code class="literal">AbstractPersonage</code>:</p><div><pre class="programlisting">class AbstractPersonage {
  private final var fatigue = 100
  private final var money = 0
  private final var happiness = 100
  private final var hungry = 100
  private final var knowledge = 100
  private final var name:String!
  
  final var canBePaid: Bool = true
  
  required init(name: String) {
   self.name = name
  }
  
  
  func toString() {
    print("("Name: \(name) / fatigue : \(Fatigue) / happiness \(Happiness) / Hungry \(Hungry) / knowledge \(Fatigue) / money: \(Money) / ")
  }
  
  //Play a day for the Personage
  func playDay() {
    print("PLAYING DAY")
    print("Get Up!")
    getUp()
    print("Eat Breakfast")
    eatBreakfast()
    doWashingUp()
    print("Go to work")
    goToWork()
    print("Work")
    work()
    
    if canBePaid {
      print("Receive Pay")
      getPaid()
    }
    print("BackHome")
    backToHome()
    
    print("Do personal activities")
    doPersonalActivities()
    
    print("Eat dinner")
    eatDinner()
    
    print("Sleep")
    sleep()
  }
  
  
  func getUp() {
    Fatigue = 0
    Happiness = 25
    Hungry = -25
    Knowledge = 0
  }
  
  func eatBreakfast() {
    Fatigue = -5
    Happiness = 25
    Hungry = 60
    Knowledge = 0
  }
  final func doWashingUp() {
    print("do washing up")
  }
  
  func goToWork() {
    Fatigue = -15
    Happiness = -15
    Hungry = -10
    Knowledge = 0
  }
  func work(){
    Fatigue = -40
    Happiness = -25
    Hungry = -40
    Knowledge = 25
  }
  
  func getPaid() {
    Money = 1000
  }
  
  func backHome() {
    Fatigue = -15
    Happiness = 10
    Hungry = -10
    Knowledge = 0
  }
  
  func doPersonalActivities() {
    Fatigue = -15
    Happiness = 15
    Hungry = -10
    Knowledge = 0
  }
  
  func eatDinner() {
    Fatigue = -10
    Happiness = 5
    Hungry = 40
    Knowledge = 0
  }
  func sleep() {
    Fatigue = 90
    Happiness = 0
    Hungry = -5
    Knowledge = 2
  }
  
  var Fatigue: Int {
    get{
      return fatigue
    }
    set{
    fatigue += newValue
    }
  }
  
  var Hungry: Int {
    get{
      return hungry
    }
    set{
      hungry += newValue
    }
  }
  
  var Happiness: Int {
    get{
      return happiness
    }
    set{
      happiness += newValue
    }
  }
  
  var Money: Int {
    get{
      return money
    }
    set{
      money += newValue
    }
  }
  
  var Knowledge: Int {
    get{
      return knowledge
    }
    set{
      knowledge += newValue
    }
  }
}</pre></div><p>In the preceding code, we <a class="indexterm" id="id274"/>can distinguish three parts. The first part is a private variable declaration. We mark the access modifier to avoid modification in subclasses:</p><div><pre class="programlisting">  private final var fatigue = 100
  private final var money = 0
  …</pre></div><p>Our <code class="literal">playDay</code> template method invokes all the parts of the algorithm:</p><div><pre class="programlisting">//Play a day for the Personage
  func playDay() {
    print("PLAYING DAY")
    print("Get Up!")
<strong>    getUp()</strong>
    print("Eat Breakfast")
<strong>    eatBreakfast()</strong>
<strong>    doWashingUp()</strong>
    print("Go to work")
<strong>    goToWork()</strong>
    print("Work")
<strong>    work()</strong>
    
    if canBePaid {
      print("Receive Pay")
<strong>      getPaid()</strong>
    }
    print("BackHome")
<strong>    backHome()</strong>
    
    print("Do personal activities")
<strong>    doPersonalActivities()</strong>
    
    print("Eat dinner")
<strong>    eatDinner()</strong>

<strong>   doWashingUp()</strong>
    
    print("Sleep")
<strong>    sleep()</strong>
  }

… </pre></div><p>Then, we define <a class="indexterm" id="id275"/>the method signatures that are parts of the algorithm and we will eventually implement them. Here, we define a default implementation of each method:</p><div><pre class="programlisting">func eatBreakfast() {
    Fatigue = -5
    Happiness = 25
    Hungry = 60
    Knowledge = 0
  }
  
  func goToWork() {
    Fatigue = -15
    Happiness = -15
    Hungry = -10
    Knowledge = 0
  }

//others methods </pre></div><p>Finally, we define our computed properties to modify the setter behavior by making an addition to itself<a class="indexterm" id="id276"/> when a new value is assigned to the property:</p><div><pre class="programlisting">  var Fatigue: Int {
    get{
      return fatigue
    }
    set{
    fatigue += newValue
    }
  }
  
  var Hungry: Int {
    get{
      return hungry
    }
    set{
      hungry += newValue
    }
  }</pre></div><p>The following two steps make our sample better:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We add a required constructor where we inject a name to the personage that we will instantiate:<div><pre class="programlisting">  required init(name: String) {
  self.name = name
  }</pre></div></li><li class="listitem" style="list-style-type: disc">We define a <code class="literal">toString()</code> method that will print all the properties and values of the personage:<div><pre class="programlisting">  func toString() {
    print("Name: \(name) / fatigue : \(Fatigue) / happiness \(Happiness) / Hungry \(Hungry) / knowledge \(Fatigue) / money: \(Money) / ")
  }</pre></div></li></ul></div><p>Well, our abstract class that implements the template method is complete. Now, we have a skeleton to make a new concrete personage, for example, a student.</p><p>The student doesn't have a job, so he won't get paid. The student reads books during his personal activities.</p><p>So, we will create a new <code class="literal">Student</code> class that implements our abstract class that contains the template method, and we will override only parts of the algorithm that changes in the parent class:</p><div><pre class="programlisting">class Student: AbstractPersonage {
  
  required init(name: String) {
    super.init(name: name)
    //student cannot be paid
    canBePaid = false
  }
  
  override func doPersonalActivities() {
    //student Read Books during its personal activities
    //so life indicators must be updated
    Fatigue = -5
    Happiness = 15
    Hungry = -5
    Knowledge = 15
  }
}</pre></div><p>In the same way, we<a class="indexterm" id="id277"/> define the <code class="literal">Searcher</code> and <code class="literal">FireMan</code> classes that implement our abstract classes and both can be paid but not the same amount. Also, each of them must override some parts of the algorithm to be more accurate with specificity of the entity that the class represent:</p><p>For the <code class="literal">Searcher</code> class, we will implement the <code class="literal">AbstractPersonage</code> protocol as follows:</p><div><pre class="programlisting">class Searcher: AbstractPersonage {
  
  override func getPaid() {
    Money = 3000/30
  }
  
  override func sleep() {
    //Searcher sleep very well
    Fatigue = 90
    Happiness = 0
    Hungry = -5
    Knowledge = 10
  }
  
  override func doPersonalActivitie() {
    //Searcher Read ScientificBooks during its personal activities
    //so life indicators must be updated
    Fatigue = -5
    Happiness = 10
    Hungry = -5
    Knowledge = 25
  }
}</pre></div><p>For the <code class="literal">FireMan</code> class, we will implement it as follows:</p><div><pre class="programlisting">import Foundation

class FireMan: AbstractPersonage {
  
  override func getPaid() {
    Money = 2500/30
  }
  
  override func sleep() {
    //FireMan doesn't sleep a lot
    Fatigue = 80
    Happiness = 5
    Hungry = -5
    Knowledge = 0
  }
  
  override func doPersonalActivities() {
    //FireMan makes lot of sports during personal activities
    //so life indicators must be updated
    Fatigue = -10
    Happiness = 5
    Hungry = -5
    Knowledge = 15
  }
  
  override func work() {
    Fatigue = -25
    Happiness = -55
    Hungry = -45
    Knowledge = 10
  }
  
  
}</pre></div><p>Our template method <a class="indexterm" id="id278"/>and concrete classes are now ready. We can now write in the <code class="literal">main.swift</code> file. Our simple client will instantiate a student called <code class="literal">Simon</code>, a searcher called <code class="literal">Natasha</code>, and a fireman called <code class="literal">Edward</code>.</p><p>We will display the properties of each of them before simulating 30 days of their life. Then, we will tell these three personages to live for 30 days using the following code:</p><div><pre class="programlisting">student.toString()
searcher.toString()
fireMan.toString()</pre></div><p>Then, we will play 30 days of life in a <code class="literal">for</code> loop:</p><div><pre class="programlisting">for i in 1...30{
  student.playDay()
  searcher.playDay()
  fireMan.playDay()
}</pre></div><p>At the end of <a class="indexterm" id="id279"/>these 30 days of life, we will check the properties of each of them:</p><div><pre class="programlisting">print("- **** 30 days later:")
student.toString()
searcher.toString()
fireMan.toString()</pre></div><p>The final code is as follows:</p><div><pre class="programlisting">  import Foundation

let student = Student(name: "Simon")
let searcher = Searcher(name: "Natasha")
let fireMan = FireMan(name:"Edward")

print("- **** Starting with:")
student.toString()
searcher.toString()
fireMan.toString()

//Play a month
for i in 1...30{
  print("**************")
  print("Play Day \(i) ")
  print("**************")
  student.playDay()
  searcher.playDay()
  fireMan.playDay()
}
print("- **** 30 days later:")
student.toString()
searcher.toString()
fireMan.toString()</pre></div><p>Click on the <strong>Run</strong> button. On the console, you will see the results after 30 days of life:</p><div><img alt="Implementation" src="img/4582_05_09.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Summary</h1></div></div></div><p>There are similarities between the strategy and state patterns, but the main difference is one of intents:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The strategy object encapsulates an algorithm</li><li class="listitem" style="list-style-type: disc">The state object encapsulates a behavior that depends on the internal state of an object</li></ul></div><p>In both the patterns, we use polymorphism. So, for both the patterns, we define a parent interface or abstract class, and then we implement the methods defined in the parent interface or abstract class  in concrete subclasses. The pattern maintains the context and depending on it decides the appropriate object to use. The biggest difference between these two patterns is that we encapsulate an algorithm into strategy classes in the strategy pattern, but we encapsulate a state into state classes in the state pattern.</p><p>The template method pattern is more like the strategy pattern; it is based on the right application of an algorithm. In this pattern, all steps are specified in the template method and some subparts are deferred to subclasses.</p><p>In the next chapter, we will learn how to use two other behavioral patterns: chain of responsibility and command.</p><p>Both are used to pass requests for actions to appropriate objects.</p></div></body></html>