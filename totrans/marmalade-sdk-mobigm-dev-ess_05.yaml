- en: Chapter 5. Animating 3D Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now seen how to create a 3D model and display it on the screen, but we're
    currently limited to non-animated models. Sure, we can rotate or scale to our
    heart's content, but that really doesn't cut it when you want to animate something
    more complex than a cube, say for example a human figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A quick overview of the concepts involved in 3D animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting animations from a 3D modeling package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and rendering an exported 3D animation in a Marmalade project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick 3D animation primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by looking at the ways in which animation of 3D models can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with model matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By far the simplest and most obvious way of animating a 3D model is to alter
    its position, orientation, and size. All three of these properties can be specified
    using the model matrix set at the time of rendering the model.
  prefs: []
  type: TYPE_NORMAL
- en: We could store a matrix in our game class, and for each frame multiply it by
    a second matrix representing the change in position, rotation, and scale; but
    this approach is generally not reliable. Over time the matrix starts to degrade
    due to the cumulative effect of precision errors in the multiplications and additions
    involved. The matrix will often end up becoming non-orthogonal (that is, its three
    axes are no longer at right angles to each other), which yields a shearing effect
    on the 3D model. The scale can also be affected by these precision errors, causing
    the 3D model to gradually shrink in size!
  prefs: []
  type: TYPE_NORMAL
- en: A far more reliable way is to store the translation, rotation, and scale separately,
    and calculate a fresh matrix for every frame. How this can be achieved is described
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Animating by translation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our game class simply needs to maintain a position vector containing the current
    world position of the object. We can move an in-game object around the world by
    adding a velocity vector that indicates how far the game object has moved in this
    frame and in what direction, with reference to the stored position vector.
  prefs: []
  type: TYPE_NORMAL
- en: To generate the final model matrix all we need to do is copy the position vector
    into the translation part of the matrix. We normally do this as the last step,
    as the act of multiplying matrices together when generating the rotation and scale
    will affect the translation of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Animating by rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The top left 3 x 3 section of the model matrix specifies the rotation at which
    we want the model to be drawn. Our game object stores the required rotation and
    updates it on a frame-by-frame basis. When it is time to render, we just use the
    stored rotation to calculate the rotation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways in which the rotation of the object might be stored.
    Three of the most common ways are shown in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation using Euler angles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Euler angles** consist of the required angle of rotation in the x, y, and
    z axes, which we would normally store using a vector. If rotation is not desired
    around every axis, you may choose to store only those rotation values that you
    require.'
  prefs: []
  type: TYPE_NORMAL
- en: Euler angles are quite easy to both visualize and implement, which is why they
    are used so often. To convert a set of Euler angles into a rotation matrix, all
    we need to do is generate three matrices for the rotations around each of the
    axes and then multiply them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is where the problem with Euler angles lies. Matrix multiplication
    yields different results depending on the order in which you multiply the matrices;
    so when using Euler angles, it is vital that you choose the order of multiplication
    carefully, depending on what you are trying to achieve. The following diagram
    shows an example to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotation using Euler angles](img/3363OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the diagram, we are rotating an arrow that points straight along the positive
    y axis. In the first row we rotate by 90 degrees around the z axis and then by
    90 degrees around the y axis. The arrow ends up pointing along the z axis.
  prefs: []
  type: TYPE_NORMAL
- en: In the second row of the diagram, we take the same original arrow but apply
    the rotations in the opposite order. As you can see, this time the arrow finishes
    in the direction of the x axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how you can build up a complete rotation matrix
    for Euler angles applied in the order XYZ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All angles used in Marmalade are specified in radians, not degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation using axis-angle pairs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **axis-angle** method of representing a rotation requires a direction vector
    and an angle of rotation to be stored. The vector represents the direction in
    which we want an object to be orientated, while the angle allows the object to
    be rotated around that axis.
  prefs: []
  type: TYPE_NORMAL
- en: We might find this way of specifying a rotation useful when dealing with player
    characters. For example, to orient a human character we might specify the direction
    vector as being the positive y axis, which then allows the angle of rotation to
    be used to change the heading of the character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marmalade allows us to convert an axis-angle pair into a matrix for rendering,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rotation using quaternions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A **quaternion** is yet another method of representing three-dimensional rotations,
    and is a concept that, when you first come across it, seems a little mind-blowing.
    Instead of going on about four dimensional hyperspheres and making parts of your
    brain melt, I'm just going to provide a quick guide to what you need to know in
    order to use quaternions. If you want to learn more about them, I suggest you
    search for "quaternions" on Google!
  prefs: []
  type: TYPE_NORMAL
- en: 'A quaternion consists of four components: x, y, z, and w. A 3D rotation is
    represented as a **unit quaternion**, which, in a similar manner to vectors, just
    means that the magnitude of the sum of the squares of all four components is one.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying two unit quaternions is similar to multiplying two rotation matrices
    together. The result represents the first orientation rotated by the second, and
    the result is different depending on the order in which you perform the multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: The big problem with quaternions is that they are almost impossible to visualize.
    If given a set of Euler angles or an axis-angle pair, most people can form an
    image in their mind of what that rotation would look like, but the same can't
    be said of quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quaternions can however be created fairly easily from both a rotation matrix
    (and therefore Euler angles) and an axis-angle pair. The following diagram shows
    the relationship between the axis-angle pairs and quaternions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rotation using quaternions](img/3363OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Quaternions really come into their own for 3D animation of boned characters,
    a topic we will be coming to later in this chapter. This is a technique that requires
    an awful lot of rotations to be calculated every time you want to update the animation
    frame, and luckily quaternions make this far more efficient in terms of both memory
    usage and execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the theory behind quaternions may be a little scary for us mere mortals,
    there is really little need to worry about the math, as Marmalade provides us
    with a quaternion class, `CIwFQuat`, that we can use. As an example, creating
    a quaternion from an axis-angle pair and then producing a rotation matrix from
    it can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Animating by scaling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The scaling factor is normally stored either as a vector containing the required
    size in the x, y, and z axes, or alternatively as a single scale value which is
    applied equally to each axis. Often the latter is sufficient, as models tend to
    look odd when they are not scaled uniformly in each axis.
  prefs: []
  type: TYPE_NORMAL
- en: A scaling matrix is very simple to create, as all you have to do is place the
    scaling factors required for the x, y, and z axes in the diagonal going from the
    top left to the bottom right of the 3 x 3 rotation part of the matrix. All the
    other cells are left as zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since creating a scaling matrix is so simple, the `CIwFMat` class does not
    include any methods for creating a general scaling matrix. It does however provide
    some shortcut methods that make it easy to scale a matrix by the same scaling
    factor on each axis. The following code snippet provides an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code will create a rotation matrix of 90 degrees around the x axis and
    then scale up just the rotation part of the matrix by a factor of two. You can
    also choose to scale up just the translation part of the matrix or both the rotation
    and translation by using the `ScaleTrans` and `Scale` methods respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 3D model animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Model matrix animation is, of course, extremely important, as without it we
    would be unable to orient and move our 3D models in the game world; but on its
    own it doesn't make for the most exciting looking game.
  prefs: []
  type: TYPE_NORMAL
- en: Most games require more than this. For example, we might want a human or animal
    character to walk, run, jump, or perform some other type of motion. Ideally, we
    need a way of making the overall shape of our 3D model change over time.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections explain how we can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Using morph targets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple approach to 3D model animation is to use **morph targets** . For this
    we alter the vertex positions of our 3D model to yield **key frames** of the animation.
    A key frame is just a particular set of vertex positions for the model that are
    an important part of the overall animation, such as the various positions a character's
    legs move through as they walk. The key frame also has a time associated with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows a very simple example of a stick man raising his
    arm. **Key Frame 1** at time index **0** seconds has the arm in a lowered position,
    while **Key Frame 2** at time index **2** seconds has it raised. Each of these
    key frames can be thought of as an individually exported 3D model.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using morph targets](img/3363OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we want to play back this animation, we could just draw the relevant 3D model
    at the correct time, but this would yield very jerky results akin to 2D bitmap
    animation. Instead, we can calculate an **Interpolated Frame** for any time index
    between **0** and **2** seconds to give a much smoother result.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the interpolated frame is simple enough. We work out a **delta vector**
    from each vertex in the first key frame to the corresponding vertex in the second
    key frame. We then scale the delta vector by the ratio of the time index we want
    to calculate for, divided by the total time between the two key frames, and add
    the scaled result on to the position of the vertex in the first key frame.
  prefs: []
  type: TYPE_NORMAL
- en: In the diagram, we want to calculate an interpolated frame at time index **1**
    second, so we would scale the delta vectors by a factor of half. The end result
    will be the frame shown where the arm is half raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach may be easy to implement, but ultimately we find that there are
    a few problems with it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accuracy of resultant animation: Take a good look at the interpolated frame
    of the stick man in the previous diagram and you will see that the stick man''s
    arm has actually shrunk. This is because we are interpolating the vertex positions
    in a straight line, whereas we really need the end vertices to be rotated around
    the shoulder point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number of key frames required: In order to produce a good quality animation
    we need to store a good number of key frames. In the example of our stick man
    animation, we could provide additional key frames that would then minimize the
    arm shortening effect. However, since we need to store the position of every vertex
    in the model, whether it has moved or not, this soon becomes a large amount of
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The need to ensure that the vertex order does not change between key frames:
    The only way we can reliably implement morph target animation is if every vertex
    in the model is in the same position in the vertex stream for every key frame.
    When exporting a 3D model from a modeling package, the vertex stream order can
    end up changing between frames, which would then cause our animation to behave
    incorrectly as vertices interpolate between completely wrong positions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the reasons listed, Marmalade does not support morph target animations,
    though it is fairly trivial to implement such an approach if you so wish. Morph
    targets can still be extremely useful for tasks such as facial animation, which,
    with the increasing power of mobile devices, may soon be a more common feature
    in mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: Using boned animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most 3D video games will implement the animation of 3D models using a boned
    animation system. This method works by allowing an animator to set up a skeleton
    of virtual bones, which can then be used to deform the vertices of a 3D model.
    The 3D model itself often gets referred to as the **skin** for purposes of animation.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a boned animation, the first step is to use a 3D modeling package
    to create the 3D model you want to animate in its **bind pose**. The bind pose
    is normally chosen to be a position in which it is easy to access every polygon
    in the model for texturing and coloring purposes, as well as for laying out the
    skeleton. For a human character this often means a pose where the arms are held
    outstretched horizontally from the body and the feet are spaced a short distance
    apart.
  prefs: []
  type: TYPE_NORMAL
- en: With the bind pose created, the animator then starts the **rigging** process.
    This involves adding the skeleton to the model by placing bones in relevant places.
    The bones are linked together to form a **hierarchy**; so whenever a bone is moved,
    all the bones which are linked to it as children will move too. Ultimately there
    will be one top-level parent bone in the hierarchy and this is called the **root
    bone**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For performance reasons it is good to keep the number of bones to a minimum,
    but this must be balanced against having enough to allow good quality animation.
    The following diagram shows what the 3D skier character used in our example game
    project looks like after being rigged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using boned animations](img/3363_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the bones have been laid out, the next step is to bind the skin (in other
    words, the mesh of polygons) to the skeleton. This is done by allowing each vertex
    of the 3D model to be modified by one or more bones.
  prefs: []
  type: TYPE_NORMAL
- en: If a vertex is mapped to more than one bone, a weight is also defined for each
    bone that determines how much of an effect it will have on the vertex. Weights
    range from zero to one and the sum of all the weights for a particular vertex
    should add up to one.
  prefs: []
  type: TYPE_NORMAL
- en: Most 3D modeling packages will have a good first attempt at doing the binding
    process automatically, but normally the animator will need to make some adjustments
    to the binding so that the skin animates correctly when the bones of the skeleton
    are moved.
  prefs: []
  type: TYPE_NORMAL
- en: With all that done, the animator can then make the character do whatever they
    want simply by rotating and moving the bones around to define the required key
    frame positions, just like with morph targets. The boned system will produce much
    better quality in the final animation, and the amount of memory required to store
    the key frames is normally not too large, since all that needs to be stored is
    the orientation and position of each bone.
  prefs: []
  type: TYPE_NORMAL
- en: The Marmalade SDK comes complete with a boned animation system, which we will
    be learning about in the rest of this chapter. The system is very flexible and
    there are very few limitations to it.
  prefs: []
  type: TYPE_NORMAL
- en: The main things to be aware of are that you can only have a single root bone,
    a maximum of 256 bones in total, and each vertex can only be affected by a maximum
    of four bones. In most cases these limitations are unlikely to cause you any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using a 3D modeling package to create animation data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entire books have been written explaining how best to create a 3D animated character;
    so, unsurprisingly, we won't be looking at how to actually produce an animated
    3D model here. Indeed, my warning in the previous chapter about "programmer art"
    probably goes double for "programmer animation". For evidence to back this statement
    up, look no further than the graphics accompanying the example programs of this
    book, which are all examples of "programmer art" made by yours truly. I really
    should heed my own advice.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, with that tip hopefully now rammed home, let's see how we can export
    animation data from a 3D modeling package.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting an animation requires a number of new file types to be exported. These
    will be discussed in detail later, but in short they are files that represent
    the skeleton, the skin, and the actual animations themselves. The following sections
    will show how to export this data.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting animations using the Marmalade 3D exporter plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using 3DS Max or Maya to create your animations, the required animation
    files are exported using the Marmalade exporter plugin. To refresh your memory,
    the exporter plugin window is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exporting animations using the Marmalade 3D exporter plugins](img/3363_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To export an animation, just load it into your modeling package and follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the export options in the same way as we did for exporting a static model.
    Please look at the steps listed in [Chapter 4](ch04.html "Chapter 4. 3D Graphics
    Rendering"), *3D Graphics Rendering*, if you've forgotten what the various options
    are for. We'll now take a look at the additional animation-specific options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that just the **geometry**, **skeleton**, and **exportgroup** checkboxes
    are ticked in the group labeled **Enable export of**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now click on the **Export!** button to write out the GEO, MTL, and GROUP
    files for the model. Two new file types will also be exported, the SKEL and SKIN
    files, which as you can probably guess represent the skeleton and skin information
    for the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The files exported in these steps are necessary in order to animate the model,
    but they don''t actually contain any animation data as such. Here''s how we get
    hold of the data that will describe how the model is actually animated:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the exporter plugin window and click on the button to the right of
    the **Export Type** combobox. A pop-up menu should appear from which you should
    select the **anim** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The checkboxes in the **Enable export of** section should change so that only
    the **animation** checkbox is ticked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Export Flags** section, the **multianim** checkbox can be selected
    if you have several animations in the scene to export. Note that each animation
    should be for the same 3D model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Anim Range Type** option can take one of three possible values. The default
    is **Visible Range**, which will export only the range of frames that are currently
    visible on the animation track bar in the modeling package. The next option is
    **Individual Anim Range**, which will only export animation data between the first
    and last key frame of each animation. The final option, **Full Range**, is only
    available in Maya. It will export the entire animation regardless of whether a
    range of frames has been set on the animation track bar or not.![Exporting animations
    using the Marmalade 3D exporter plugins](img/3363_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Anims Ranges** option allows you to split one big animation sequence up
    into several smaller animations. If you click on the **Edit…** button, the dialog
    box just seen will be displayed. Use the **Add** button to create a new animation
    range, use the **Name** textbox to name the animation, and then drag the sliders
    to set the **Start** and **End** frames for the animation. Use the **Delete**
    button to delete an animation range from the list. The **Done** button will close
    the dialog and accept any changes made, while the **Cancel** button will discard
    any changes made before closing the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final option that affects animation export is the **Sub Anim Root** textbox.
    You can enter the name of one of the bones in the skeleton and the animation data
    will only be exported for that bone and its children. We'll learn more about sub-animations
    later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With all the animation-related options in the exporter now set up, just click
    on the **Export!** button to output one or more ANIM files. The number of files
    exported depends on how many animations were in the scene, the status of the **multianim**
    checkbox, and whether the **Anims Ranges** option was used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exporting animations using the Blender plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also export animations using the Blender plugin. The terminology used
    in Blender for animations is a little unusual, as Blender calls the skeleton an
    **armature**, but aside from that the approach to animation is the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exporting animations using the Blender plugin](img/3363_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the steps you should follow to export an animated model from Blender:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the animation you wish to export into Blender and then go to **File** |
    **Export** | **Marmalade Cross-platform Apps (.group)** to display the export
    options screen. As a reminder, the export options are shown in the previous screenshot,
    but please refer to the steps listed in [Chapter 4](ch04.html "Chapter 4. 3D Graphics
    Rendering"), *3D Graphics Rendering*, for more information about the standard
    model export settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To tell the exporter to write out all the different animation file types, ensure
    that the **Export Armatures** checkbox is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Animations Frames** combobox contains three options. **None** will export
    no animation data, **Keyframes Only** will export just the data for the key frames
    of the animation (this is the option you would normally want to select), and **Full
    Animation** will export data for every frame regardless of whether it is a key
    frame or not (this is often referred to as "baking" the animation and means you
    get the exact animation seen in the modeling package at the expense of an increase
    in animation memory footprint).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Animations Actions** combobox contains two settings. **Default Animation**
    will export only the animation that has been selected as the default for the armature.
    The other option is **All Animations**, which will export all the animations currently
    defined for the armature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final setting is the **Animation FPS** value. This dictates the playback
    speed in frames per second for the animation, so it is possible to speed up or
    slow down an animation by changing this value without the need to alter all the
    key frame timings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To export the data, ensure that you have a file location and name entered in
    the boxes at the top of the screen and then click on the **Export Marmalade**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Marmalade 3D animation file formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now export the animation data from the 3D modeling package of our choice,
    but before we actually make use of them, let's take a quick look at the new file
    types that we've just generated.
  prefs: []
  type: TYPE_NORMAL
- en: The SKEL file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **SKEL file** contains all the information pertaining to the skeleton of our
    animation. The file first defines an instance of a `CIwAnimSkel` class, which
    is a wrapper for a number of `CIwAnimBone` instances.
  prefs: []
  type: TYPE_NORMAL
- en: The `CIwAnimSkel` instance is derived from the `CIwResource` class and therefore
    has a name associated with it so that it can be looked up in the resource manager.
    The name of the instance is taken from the filename of a SKEL file, which in turn
    comes from the name of the root bone of the skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the `CIwAnimBone` instances have a name, position, and rotation associated
    with it, which defines the bind pose of the animation. The position is just a
    vector in model space, while the rotation is stored as a quaternion. Except for
    the first bone, which is the root bone, each bone will also list its parent bone,
    thus building up the skeletal hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SKEL file gets exported into the `models` sub-directory alongside the GEO
    and MTL files. An example of a SKEL file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The SKIN file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **SKIN file** is the bridge between the skeleton and the vertices of the
    3D model in its bind pose. It contains all the data representing which vertices
    are influenced by which bones.
  prefs: []
  type: TYPE_NORMAL
- en: The file starts by defining an instance of the `CIwAnimSkin` class. This instance
    contains references to the `CIwAnimSkel` instance that defines the bones of the
    required skeleton, and also the `CIwModel` instance that will be used for rendering
    the model once the new vertex positions have been calculated. As with the SKEL
    file, the name given to the `CIwAnimSkin` instance is derived from the filename
    of the SKIN file.
  prefs: []
  type: TYPE_NORMAL
- en: The file then contains a number of instances of the `CIwAnimSkinSet` class,
    which indicates which vertices are modified by which bones. This is achieved by
    first listing the bones, up to a maximum of four, then the number of vertices
    in the set. The bone weights are then specified for each vertex by providing the
    index of the vertex in the model vertex stream, followed by a weight value for
    each bone. The sum of the weight values for each vertex must total to one.
  prefs: []
  type: TYPE_NORMAL
- en: The SKIN file is also exported to the `models` subdirectory and the following
    code provides a partial example of one. These files tend to be quite large due
    to the sheer amount of data required for even a simple animation, so an extract
    should provide enough of a flavor of what these files look like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The ANIM file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final file type we need to consider is the **ANIM file**, which as its name
    suggests is the file that actually defines a particular animation.
  prefs: []
  type: TYPE_NORMAL
- en: The file first declares an instance of the `CIwAnim` class, which, as with the
    other animation class types, will be given a resource name derived from the filename.
  prefs: []
  type: TYPE_NORMAL
- en: The skeleton that this animation will be applied to is the first thing that
    the `CIwAnim` instance will specify. This is then followed by a number of `CIwAnimKeyFrame`
    declarations that detail the positions and orientations of each affected bone
    at a particular time index.
  prefs: []
  type: TYPE_NORMAL
- en: Key frames do not need to list the orientation and position of each bone in
    the skeleton. If a bone has not moved relative to its parent, its position will
    remain as it was at the previous key frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exporters will create an `anims` sub-directory to hold all the ANIM files.
    An example of an ANIM file is provided in the following code; but as with the
    SKIN file, this is just a partial example so as to not fill the pages of this
    book with lots of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Loading and rendering an exported 3D animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're now in a position to start rendering a 3D animation, and as with rendering
    a static 3D model it's also surprisingly easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the IwAnim API to a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use Marmalade's animation functionality, we first need to add
    the IwAnim API to our project. This API builds on top of the IwGraphics API required
    for rendering static 3D models.
  prefs: []
  type: TYPE_NORMAL
- en: As with all such Marmalade APIs, we add support for IwAnim to a project by listing
    `iwanim` in the `subprojects` section of the MKB file. We must then call `IwAnimInit`
    after `IwGraphicsInit` has been called, and at shutdown time we need to call `IwAnimTerminate`.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and accessing a 3D animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GROUP file format comes to our rescue once again in order to get animation
    data loaded into memory. The export process will have created a GROUP file for
    us already that will include the GEO, MTL, SKEL, and SKIN files, so we just need
    to add entries for the ANIM files that we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: With everything referenced in the GROUP file, we just need to load it into memory
    using the resource manager, and then access the resources in the same way as we
    do for any other resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates how we might load a GROUP file and then
    access the resources needed for rendering an animated 3D model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Right, now that we have the resources in memory, we need to do something with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Playing back a 3D animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to play back an animation, we need to let Marmalade know which animation
    we want to play, how fast it should be played back, and whether we want it to
    be a one shot or looping animation. All this and more is provided by the `CIwAnimPlayer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new instance of `CIwAnimPlayer`, we must provide it with a
    pointer to the skeleton instance for animation. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The player object is now ready to start animating, so we just need to pass
    it details about the animation we want to play. This can be done with just a single
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayAnim` method first takes a pointer to the `CIwAnim` instance we wish
    to play. It then expects to see a playback speed, some control flags, and a blending
    interval.
  prefs: []
  type: TYPE_NORMAL
- en: The playback speed is specified so that a value of `1` yields the normal exported
    animation speed. Doubling this value will play the animation back at twice the
    speed, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The function's third parameter is a set of control flags that are primarily
    used to indicate whether the animation should loop when it reaches the last key
    frame. If looping is desired, the flag `CIwAnimBlendSource::LOOPING_F` should
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other values defined by `CIwAnimBlendSource`, but most
    of these are intended for read-only status flags and the `CIwAnimPlayer` class
    provides other methods that should be used to determine the current status. Therefore,
    the only other flag that will be used in this method is `CIwAnimBlendSource::RESET_IF_SAME_F`,
    which will force the animation player to restart the specified animation if it
    is already the current animation. If an animation that is already being played
    is passed in to the `PlayAnim` method, the request will be ignored unless this
    flag is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animation player is now initialized, so the final thing that must be done
    is instruct it to calculate the required animation frame. This is done by calling
    the `Update` method of the `CIwAnimPlayer` instance on every iteration of the
    main game loop, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `lTimeStep` parameter is a `float` value indicating the amount of time (in
    seconds) by which the current animation state should be advanced. When this call
    completes, a copy of the skeleton will have been created with all the bones positioned
    and rotated correctly in order to render the current frame of animation.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a 3D animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the animation player now merrily updating away, the final step is to render
    the animated model. This is possibly the easiest part of the entire process, as
    the following code demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully most of this already looks familiar to you. The first step is to set
    the view and model matrices we want to use for rendering. We then need to provide
    some information about the frame of animation, namely the animated skeleton and
    the skin data.
  prefs: []
  type: TYPE_NORMAL
- en: The skeleton information is maintained by the `CIwAnimPlayer` instance and can
    be retrieved using the `GetSkel` method. The skin is just the `CIwAnimSkin` instance
    as loaded by the resource manager. We use the `IwAnimSetSkelContext` and `IwAnimSetSkinContext`
    functions to provide this data to the rendering engine.
  prefs: []
  type: TYPE_NORMAL
- en: To render the animated model to the screen, all we have to do is call the `Render`
    method on `lpFlag`, which is a pointer to a `CIwModel` instance, just as we would
    if we were rendering the model without any animation.
  prefs: []
  type: TYPE_NORMAL
- en: After rendering, we clear the skin and skeleton contexts so that future model
    rendering calls won't try and use incorrect data during rendering. This is a good
    habit to get into as determining why an unanimated model has suddenly started
    deforming wildly could be a tricky bug to track down.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring 3D animation further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You're now able to render fully animated 3D models! While this
    is a pretty cool achievement, the functionality we've seen so far has only scratched
    the surface of what the IwAnim API allows us to do. The following sections describe
    some of the other features that we have at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Playing an animation backwards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some occasions when it is useful to be able to play an animation backwards.
    As an example, imagine a character kneeling down to examine an object. Rather
    than create a whole new animation to enable them to stand up again, we could just
    play the kneeling animation backwards instead.
  prefs: []
  type: TYPE_NORMAL
- en: Playing an animation backwards is achieved simply by passing a negative animation
    speed into the call to `PlayAnim`, so a value of `-1` will play the animation
    backwards at normal speed.
  prefs: []
  type: TYPE_NORMAL
- en: Blending between animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When transitioning between two animations, we often don't want to just snap
    straight to the beginning of the new sequence, as this can result in a noticeable
    jump between the current frame of animation and the first frame of the new animation.
    We can solve this problem by blending between animations.
  prefs: []
  type: TYPE_NORMAL
- en: We touched on how to achieve this earlier, when we first introduced the `PlayAnim`
    method. The final parameter in this method is the blending time, which is specified
    as a value in seconds using a floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying a non-zero blending interval, the animation player will calculate
    the frames of animation required for both the old and new animations, then generate
    a third transition frame by interpolating between these two frames over the specified
    time. The transition frame is what is then used to draw the 3D model. Once the
    blend interval is over, the original animation will stop being calculated as it
    is no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting animation playback events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to detect when an animation has looped or has finished playing is
    important because we can start to link animations together or prevent the user
    from performing a task until an animation has completed. For instance, imagine
    a player has to reload a weapon and an animation is played to show this happening.
    We need to know when the animation has completed so we can allow the player to
    start attacking again.
  prefs: []
  type: TYPE_NORMAL
- en: The `CIwAnimPlayer` class allows us to detect when a one shot animation has
    completed, by calling the `IsCurrentAnimComplete` method that will return `true`
    when the animation has finished.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `IsCurrentBlendComplete` method that will return `true` when
    the animation player has finished blending between two animations.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting when an animation has looped is also possible, although `CIwAnimPlayer`
    does not provide us with a quick shortcut way of detecting this event. Instead,
    we have to do a little manual flag testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any time, the animation player can be updating two main animations: current
    animation (defined as the animation that was last specified using the `PlayAnim`
    method) and the previous animation (the one that was playing at the time `PlayAnim`
    was last called with a blending interval).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The current status of these two animations are stored in instances of the `CIwAnimBlendSource`
    class, which we can access using the `CIwAnimPlayer` class'' methods named `GetSourceCurr`
    and `GetSourcePrev`. The `CIwAnimBlendSource` class has a method called `GetFlags`
    that returns playback status information as a bitmask. To detect if the animation
    has looped, we just need to see if the flag `CIwAnimBlendSource::LOOPED_F` is
    set. The following source code shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer this approach, you can also use the flag `CIwAnimBlendSource::COMPLETE_F`
    to detect when a single shot animation has finished.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing animation playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember that we calculated the current animation frame by calling the
    `Update` method of `CIwAnimPlayer`? This method has to do quite a lot of work,
    some of which we might not actually need to do on a frame-by-frame basis. For
    example, if an in-game character is currently not visible on the screen, we might
    want to ensure that we still step through its animation; but calculating the bone
    positions for the current frame of animation is a waste of processor time as we
    won't be rendering the animation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update` method is actually implemented by calling three other methods of
    `CIwAnimPlayer`, which we can call independently if we so wish.
  prefs: []
  type: TYPE_NORMAL
- en: The first method is `UpdateParameters`, which takes the time increment we need
    to update the animation by as its sole parameter. This method will update the
    current time indexes of all the animations currently in use by the animation player
    and set flags to indicate whether those animations have completed or looped.
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateSources` method takes no parameters and is used to work out the current
    bone orientations for each animation, applying any blending between animations
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally there is the `UpdateMatrices` method, which again takes no parameters.
    This performs the final step of converting all the positions and orientations
    of each bone into a matrix that will be used to update the vertex stream of the
    3D model during rendering.
  prefs: []
  type: TYPE_NORMAL
- en: These methods need to be called in the order presented previously, but there
    is no need to call all three methods in every frame if we do not need the results
    of that method to be calculated.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sub-animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sub-animations** allow us to animate only a part of the entire skeleton,
    which can be useful when we want an in-game character to be able to perform two
    different actions at once. For example, a character might be able to wield several
    different weapons while moving around the game world. The main animation applied
    to the character would be an animation for walking, running, or just standing
    still. Sub-animations can then be overlaid on top of the main animation to show
    the player holding, firing, or reloading the different weapon types.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to export a sub-animation, all we need to do is specify the name of
    the bone that is the root of the sub-animation in the **Sub Anim Root** field
    of the Marmalade exporter plugin. In the example situation given previously, you
    might choose to export the sub-animation starting at a bone that has the two arm
    bones as children.
  prefs: []
  type: TYPE_NORMAL
- en: The Blender plugin does not currently support this feature unfortunately, though
    you could potentially export the entire animation and then delete by hand any
    references to bones higher in the hierarchy than the sub-animation root bone in
    the ANIM file.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the sub-animation exported, all we have to do to play it back is call
    the `PlaySubAnim` method of `CIwAnimPlayer`. An example of how to use this function
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is almost identical in structure to the `PlayAnim` method.
    The only difference is an extra initial parameter, which is the sub-animation
    index number. The animation player can support two different sub-animations at
    the same time and the index number should be `0` or `1` to indicate which sub-animation
    you wish to change.
  prefs: []
  type: TYPE_NORMAL
- en: To detect the current playback status of a sub-animation, we can get hold of
    the `CIwAnimBlendSource` instance using the `GetSourceSub` method of `CIwAnimPlayer`.
    This method takes a single parameter, which is the index number of the sub-animation
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Offset animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with animations that cause a game character to move, such as walking,
    running, or making an attacking move, it is desirable to update the position of
    the character with respect to the animation being played so that the character's
    feet do not appear to slip on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Marmalade provides a method of doing this by way of an **offset animation**,
    which is an animation that consists of a single bone whose position and rotation
    can be used to move an object around the game world. Offset animations are exported
    using the same export process as any other animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an offset animation, we use the `PlayOfsAnim` method of `CIwAnimPlayer`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The parameters of this function are pointers to the offset animation instance,
    the speed of playback (again a value of `1` will play back at normal speed), and
    the required animation flags; so it is possible to play back offset animations
    as one shot or looped.
  prefs: []
  type: TYPE_NORMAL
- en: To find the current status of the offset animation, we can use the `GetSourceOfs`
    method on `CIwAnimPlayer` to retrieve the `CIwAnimBlendSource` instance that maintains
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We can also find out position and rotation information for the start, end, and
    current offsets using the methods `GetMatOfsInitial`, `GetMatOfsFinal`, and `GetMatOfs`
    of `CIwAnimPlayer`. Each of these methods allows access to a `CIwFMat` object
    representing the current orientation of the offset. We can then use this information
    to allow us to update the position of a game character accordingly, so that other
    game functions such as collision detection continue to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining bone positions and rotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When discussing sub-animations earlier, we presented the example of a character
    being able to hold a variety of different weapons. Sub-animations will, of course,
    only provide half the solution to this problem, as they will move the character's
    arms to the correct pose; but, because the weapon is not part of the source 3D
    model, the character will just appear to be clutching at thin air.
  prefs: []
  type: TYPE_NORMAL
- en: We need some way of drawing a further model depicting the weapon, but how can
    we get it positioned in the correct place?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to ask the animation player to provide us with the current orientation
    and position of a bone that is located at the point where the weapon model would
    need to be drawn. We can do this by calling the `GetBoneNamed` method of `CIwAnimPlayer`,
    which will return a pointer to a `CIwAnimBone` instance representing the current
    orientation of the requested bone.
  prefs: []
  type: TYPE_NORMAL
- en: The position and rotation of the bone can be found using the `GetPos` and `GetRot`
    methods of `CIwAnimBone`, which allow us to generate a matrix in model space,
    or alternatively the `GetMat` method will return a model space matrix representing
    both the position and rotation of the bone if it has been calculated during the
    update of the `CIwAnimPlayer` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the bone information, we can easily calculate a model matrix for rendering
    the weapon model in the correct place. First we use the bone information to generate
    a matrix in model space, we then multiply this by any rotation matrix needed to
    orient the character in the game world. Finally, add the world position of the
    character and the weapon model can be rendered in the character's hand.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections give an overview of the sample projects accompanying
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Flag project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example demonstrates playing back both a main and sub-animation. A flag
    is rendered waving in a virtual breeze. Every few seconds the flagpole will wobble
    around but the flag on the end of the pole will continue to flap around. A screen
    grab can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Flag project](img/3363_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The animation of the flag waving is achieved as a looping sub-animation, while
    the flagpole wobble is the main animation, which is started every five seconds
    as a one-shot animation.
  prefs: []
  type: TYPE_NORMAL
- en: One of the problems with this approach is that the sub-animation will only play
    if there is a main animation currently in progress. Rather than create a one frame
    animation of the flagpole standing still, a cunning trick has been employed.
  prefs: []
  type: TYPE_NORMAL
- en: The flagpole wobble animation is actually playing continuously, but at zero
    speed. Since the first frame of the wobble animation is of the pole in an upright
    position, we have achieved our aim of a static animation frame.
  prefs: []
  type: TYPE_NORMAL
- en: Every five seconds the wobble animation is then restarted as a one-shot animation.
    When the wobble animation has completed, we return to playing it at zero speed
    to hold the flagpole steady again.
  prefs: []
  type: TYPE_NORMAL
- en: The Skiing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The changes to the Skiing project for this chapter really make it seem like
    much more of a game. The following screenshot and the following sections highlight
    the new bits and pieces that have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Skiing project](img/3363_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: New gameplay features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, there was not a great deal of actual gameplay to be had in the game.
    We could steer the little skier left and right, but aside from crashing into a
    tree there wasn't actually an awful lot to do.
  prefs: []
  type: TYPE_NORMAL
- en: To combat this, gates consisting of a couple of flags have been added. The player
    must steer the skier through these in order to increase their score, which is
    now displayed at the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the gates, a new class called `Flag` has been created. The `ModeGame`
    class picks a random position across the course and spawns a flag a short distance
    left and right of that position. The flags scroll up the screen, and when they
    scroll off the top a new random position is chosen for them at the bottom of the
    game world.
  prefs: []
  type: TYPE_NORMAL
- en: The `ModeGame` class maintains pointers to the two instances of `Flag` so that
    it can be detected when they have scrolled offscreen and need repositioning, plus
    we can also use these pointers to work out when the player has moved between them.
  prefs: []
  type: TYPE_NORMAL
- en: Randomly placed rocks have also been introduced, which must be avoided because
    colliding with them ends the game, just like steering into the trees does. These
    are represented by another new class called `Rock`. This class is very similar
    to the existing `Tree` class, the main difference being that when the rock scrolls
    off the top of the screen it is replaced at the bottom with a new horizontal position.
  prefs: []
  type: TYPE_NORMAL
- en: Animations added
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the subject matter of this chapter, it's fairly obvious that adding animations
    to the game would be one of the changes made.
  prefs: []
  type: TYPE_NORMAL
- en: Our little skier character has been given a looping animation, so the little
    chap now pushes himself along using his skiing poles. If the player collides with
    a tree or rock, the poor little fellow will also now take a tumble and end up
    in a heap on the ground. Ouch!
  prefs: []
  type: TYPE_NORMAL
- en: The other animation added to the game has been for the flag. It is the same
    animation structure demonstrated in this chapter's other example project. A sub-animation
    plays to make the flag wave in the wind, while the main animation is of the flagpole
    wobbling about.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than wobbling at set time intervals, the animation is instead triggered
    when the player skis too close to the flag.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered the topic of 3D animation quite extensively in this chapter. We
    can now move, rotate, and scale our 3D models in the game world, and we can make
    the actual shape of the model change using boned animations to make characters
    walk, run, jump, dance, or whatever we require them to do.
  prefs: []
  type: TYPE_NORMAL
- en: We've also looked at some more advanced topics, such as blending between animations,
    applying sub-animations on top of a main animation, and retrieving bone position
    and orientation information from an in-progress animation to allow us to find
    the location of a particular part of a model.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll return to just two dimensions, as we look at how we
    can make the user interface of our games look a little prettier than just using
    badly laid out debug fonts.
  prefs: []
  type: TYPE_NORMAL
