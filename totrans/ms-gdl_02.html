<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Groovy Essentials for Gradle</h1></div></div></div><p>In this chapter, we will learn some fundamental concepts of the Groovy programming language. This chapter briefly covers Groovy data types, control structures, object oriented concepts, collections, closures, and builders. This is just the tip of the iceberg. As this is not a Groovy book, we won't be able to cover all the topics. This chapter is meant for beginners who are coming from a Java background and have a basic understanding of <strong>Object-oriented programming</strong> (<strong>OOP</strong>) concepts. This will help them get started with Groovy. This chapter will also act as a tool box to proceed with Gradle scripting.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Overview</h1></div></div></div><p>Groovy is a<a id="id74" class="indexterm"/> dynamic programming language for the Java Platform. You might be wondering why we specifically mention the Java platform. By the Java platform, it means Groovy code compiles into the bytecode, and bytecodes are executed on JVM similar to any other Java class. Along with the OOP features, it also provides the capability of scripting languages such as Python and Smalltalk, making them available to use in Groovy using a Java-like syntax.</p><p>As Groovy runs on JVM, it can be easily integrated with Java and nicely fits into the existing infrastructure. For example, the build and deployment of Groovy code is the same as the build and deployment of Java code, and you can easily mix Groovy and Java together by just adding another JAR file to the library. Groovy is not the only language that runs on JVM. Some of the other languages are Scala, Clojure, JRuby, Jython, and so on. In my opinion, if you have some Java background, Groovy is much easier to learn when compared with other languages. It has a very Java-like syntax to it, and most of the Java syntaxes are valid Groovy syntaxes. It just simplifies coding. Groovy is never intended to replace Java. It is intended to supplement Java to extend it to make it easier, and also it uses modern language features such as closures, builders, and metaprogramming.</p><p>The following are some of the<a id="id75" class="indexterm"/> key features of Groovy.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec000"/>Integration with Java</h2></div></div></div><p>Many people think Groovy is a scripting language. Yes, it provides scripting support, but it's not right to say<a id="id76" class="indexterm"/> Groovy is only a scripting language. Along with scripting, it perfectly fits into the OOP world. As mentioned earlier, Groovy <a id="id77" class="indexterm"/>also provides seamless integration with Java. Calling Java from Groovy is as simple as writing Groovy code. Every Groovy type is a subtype of <code class="literal">java.lang.Object</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Minimum code</h2></div></div></div><p>One good thing about Groovy<a id="id78" class="indexterm"/> is that it reduces the amount of code required to do some complex tasks, such as parsing XML files and accessing databases. With Groovy, you can always mix in Java code. If you've been using Java for a while, I think you'll appreciate the simplicity of using Groovy since you can program more functionality by writing less code.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Simpler I/O operations</h2></div></div></div><p>I/O operations, one of the main<a id="id79" class="indexterm"/> pain points for the developer while working with Java, is made much simpler in Groovy. It's more fun to perform I/O operations in Groovy. Groovy provides simple properties to read/write from the file. It has added so many utility methods to the <code class="literal">java.io.File</code> class.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Integration with Ant</h2></div></div></div><p>Like Java, Groovy <a id="id80" class="indexterm"/>provides seamless integration with Ant. Groovy has a helper class, <code class="literal">AntBuilder</code>, which gives Groovy the power of using Ant features<a id="id81" class="indexterm"/> to make the developer's life much simpler. Be it calculating the checksum of any file or copying the content of a directory from one location to another with any filter criteria. With Ant capabilities, Groovy makes developers more productive. In <a class="link" href="ch08.html" title="Chapter 8. Migration">Chapter 8</a>, <em>Migration</em>, we will discuss more on this topic.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Builder classes</h2></div></div></div><p>Apart from AntBuilder, Groovy provides the capability of <code class="literal">NodeBuilder</code>, <code class="literal">MarkupBuilder</code>, and <code class="literal">SwingBuilder</code>. With the help of these Builders, the developer is able to achieve things in a <a id="id82" class="indexterm"/>much simpler way, as compared to life without the Builders. <code class="literal">MarkupBuilder</code> is useful while dealing with XML operations. <code class="literal">SwingBuilder</code> provides simplified API to the Swing framework that helps in building user-friendly GUI applications. <code class="literal">NodeBuilder</code> helps while working with object tree structure.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Closure</h2></div></div></div><p>The inclusion of closures was a big selling point for Groovy. A closure in Groovy is an anonymous chunk of code that may take arguments, return a value, and reference and use variables declared in its surrounding scope. Closure has usually been associated with functional languages.</p><p>A Groovy closure is like a <a id="id83" class="indexterm"/>code block that is defined and then executed at a later point. It has some special properties such as implicit variables and free variables. We will discuss <a id="id84" class="indexterm"/>Closure in detail in later section of this chapter.</p><p>Of course, there are many more features to learn. We will discuss a few in this chapter. For more details refer to the <a id="id85" class="indexterm"/>Groovy documentation at <a class="ulink" href="http://www.groovy-lang.org/">http://www.groovy-lang.org/</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Groovy script for Hello World</h1></div></div></div><p>We have discussed what Groovy is and some of its important features. Let us create a Hello World program and<a id="id86" class="indexterm"/> feel the magic with Groovy. Here we are assuming that Groovy is installed on the system, <code class="literal">GROOVY_HOME</code> is pointing to the installation directory and <code class="literal">&lt;GROOVY_HOME&gt;/bin</code> has been added to the PATH environment variable:</p><div><pre class="programlisting">file: GroovyTest.groovy
  println "Hello Groovy"</pre></div><p>And that's all. Yes, for a simple Groovy program, you don't need to declare any packaging, any main class, or any semicolons, only a simple <code class="literal">println</code> statement would create your first Groovy program.</p><p>To execute the program, use the following command:</p><div><pre class="programlisting">
<strong>$ groovy GroovyTest.groovy</strong>
<strong>  Hello Groovy</strong>
</pre></div><p>The <code class="literal">groovy</code> command is used to execute the Groovy script. The beauty of the Groovy script is that it can execute any file, not only files with the <code class="literal">.groovy</code> extension. Even you can write the preceding <code class="literal">println</code> statement in the <code class="literal">Test.text</code> file and use the groovy command to execute the file. File extension doesn't matter in groovy, but to make the file structures more readable, it is recommended to use <code class="literal">.groovy</code> extensions for Groovy files.</p><p>There is another way of executing Groovy files. You can compile Groovy files, generate class files like Java, and then execute the class files. Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To compile and generate the class file, use the following command:<div><pre class="programlisting">
<strong>$ groovyc GroovyTest.groovy</strong>
</pre></div></li><li class="listitem">To run the class file generated, you need to execute the following command on Windows. If executing on Linux/Unix environment use <code class="literal">$GROOVY_HOME</code>:<div><pre class="programlisting">
<strong>$ java -cp %GROOVY_HOME%/embeddable/groovy-all-2.3.1.jar;. GroovyTest</strong>
</pre></div></li></ol></div><p>Executing a Groovy compiled file is same as executing the Java file. Developer needs to add <code class="literal">groovy-all-&lt;version&gt;.jar</code> in its classpath. You also need to make sure that the directory in which your compiled classes are present, it should be in the classpath. In the preceding example, we have added "<code class="literal">.</code>" as the current directory to the classpath to find the <code class="literal">GroovyTest.class</code> file.</p><p>It doesn't matter <a id="id87" class="indexterm"/>which way you execute the Groovy scripts. In both the cases, Groovy scripts execute inside JVM only. Both the methods compile the Groovy scripts into bytecode. The <code class="literal">groovy &lt;filename&gt;</code> stores the classes into memory in a direct way, whereas compiling the script using the <code class="literal">groovyc</code> command creates a class file and stores it on disk, which you can later execute using Java command.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Data types</h1></div></div></div><p>The first thing you<a id="id88" class="indexterm"/> learn about any programming language are the data types; how any programming language stores the data. Similar to the other programming languages, Groovy also offers a different set of data types for numerical, strings, char, and so on. As compared to Java, there are no primitive types present in Groovy. Groovy treats everything as an object, which makes Groovy a pure Object Oriented language. The problem with primitive data types is that developers can't perform any object-level operations, such as calling methods on them. Also, you can't store them as an object in maps and sets (collections that require objects). The following table shows primitive data types and wrapper types with default values:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Data type</p>
</th><th style="text-align: left" valign="bottom">
<p>Wrapper type</p>
</th><th style="text-align: left" valign="bottom">
<p>Default values</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>byte</p>
</td><td style="text-align: left" valign="top">
<p>Byte</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>short</p>
</td><td style="text-align: left" valign="top">
<p>Short</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>int</p>
</td><td style="text-align: left" valign="top">
<p>Integer</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>long</p>
</td><td style="text-align: left" valign="top">
<p>Long</p>
</td><td style="text-align: left" valign="top">
<p>0L</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>float</p>
</td><td style="text-align: left" valign="top">
<p>Float</p>
</td><td style="text-align: left" valign="top">
<p>0.0f</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>double</p>
</td><td style="text-align: left" valign="top">
<p>Double</p>
</td><td style="text-align: left" valign="top">
<p>0.0d</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>char</p>
</td><td style="text-align: left" valign="top">
<p>Character</p>
</td><td style="text-align: left" valign="top">
<p>\u0000</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>boolean</p>
</td><td style="text-align: left" valign="top">
<p>Boolean</p>
</td><td style="text-align: left" valign="top">
<p>false</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>Not Applicable</p>
</td><td style="text-align: left" valign="top">
<p>null</p>
</td></tr></tbody></table></div><p>Groovy gives you the flexibility to even declare variables using int, byte, short, and so on, which it internally<a id="id89" class="indexterm"/> converts into its respective classes, for example, int to Integer, char to Character, and so on.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>String</h2></div></div></div><p>You may be thinking, why <a id="id90" class="indexterm"/>are we discussing only String here? This is because Groovy provides different variants to<a id="id91" class="indexterm"/> represent String compared to Java, as shown in the following code:</p><div><pre class="programlisting">def s1='This is single quote string.'

def s2="This is double quote string."

def s3="""This is multi line String.
You can write multiple lines here."""

def s4 ="Example of Gstring, You can refer to variable also like ${s1}"

def s5='''This is multi line String.
You can write multiple lines here.'''

def s6 =/ This is 'slashy' String.
It can also contains multiple lines $s1
/</pre></div><p>Here, <code class="literal">s1</code> contains String in single quotes. This String is fixed in size as we have written it.</p><p>The <code class="literal">s2</code> variable contains String in double quotes similar to Java String.</p><p>Variable <code class="literal">s3</code> contains String enclosed in three double quotes, which allows you to declare a multiline String.</p><p>In <code class="literal">s4</code>, String contains an embedded variable, which will be resolved to its value. This is formally known as GString. You can declare place holder using either <code class="literal">${variable}</code> or <code class="literal">$variable</code>.</p><p>Another format Groovy supports is String declared inside <code class="literal">/</code> (slash). It also supports multiline Strings.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Dynamic typing in Groovy</h3></div></div></div><p>Groovy provides support <a id="id92" class="indexterm"/>for both static typing and dynamic typing features. Static typing provides more checks at compile time, more memory optimization, and better support for the IDE used for Groovy. It also provides additional information about the type of variable or method parameters. However, the power of Groovy lies in dynamic typing. In many scenarios, you are not sure about the kind of value that would be stored in the variable or returned by the functions. In that scenario, Groovy provides flexibility to use dynamic typing. You can just define a variable or methods by using the <code class="literal">def</code> keyword, as shown in the following code:</p><div><pre class="programlisting">def var1
var1 ='a'     
println var1.class   // will print class java.lang.String
var1 = 1       
println var1.class   // will print class java.lang.Integer
def method1() {/*method body*/}</pre></div><p>Another use <a id="id93" class="indexterm"/>of dynamic typing is calling methods on objects that have no guaranteed type. This is often called <strong>duck typing</strong>. For example, consider the following scenario where a simple addition method is called on different data types such as Integer, List, and String. Based on different input parameters, each time the method returns different output.</p><div><pre class="programlisting">
<code class="literal">def addition(a, b) { return a + b}</code>
addition (1, 2)      // Output: 3
addition ([1,2], [4, 5])  // Output: [1, 2, 4, 5]
addition('Hi ', 3)    // Output: Hi 3</pre></div><p>As you can see, when the addition method was invoked with an Integer as an argument, it performed an arithmetic addition. With list-type arguments, the addition method creates a new list by doing a union of two lists. Similarly, on string-type arguments, it does a simple concatenation. In this example, the <code class="literal">+</code> operator was interpreted as different method calls based on the input type arguments.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>A major difference between Java and Groovy is that Groovy supports operator overloading.</p></div></div><p>So far so good. But what happens if the addition method is called on a user-defined object, say <code class="literal">Person</code>? This is shown in the following code:</p><div><pre class="programlisting">class Person{
  String name

  @Override
  public String toString() {
    return "Person [name=" + name +"]";
  }
}

p1 = new Person()
p2 = new Person()
addition(p1, p2)  // Output: groovy.lang.MissingMethodException</pre></div><p>This is expected because in the <code class="literal">Person</code> class we did not define the plus method. If we define the plus method in the <code class="literal">Person</code> class, the call to the addition (which invokes <code class="literal">p1 + p2</code> or <code class="literal">p1.plus(p2))</code> method will be successful.</p><p>Another solution is to implement <code class="literal">methodMissing</code> method. This is a very powerful concept in<a id="id94" class="indexterm"/> Groovy. In the Gradle source code, you will find reference for this method many times.</p><p>So, instead of defining a plus method, we can define a <code class="literal">methodMissing</code> method as follows:</p><div><pre class="programlisting">def methodMissing(String name, args) {
  if (name.startsWith("plus") ) {
// write your own implementation
    return "plus method intercepted"
  }
  else {
    println "Method name does not start with plus"
    throw new MissingMethodException(name, this.class, args)
  }
}</pre></div><p>Now, if we call the addition method on the <code class="literal">Person</code> object, we will find <code class="literal">plus method intercepted</code> as the new output, as shown in the following code:</p><div><pre class="programlisting">addition(p1, p2)  // Output: plus method intercepted</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Classes, beans, and methods</h1></div></div></div><p>This section introduces classes, methods, and beans. Groovy classes are similar to Java classes declared <a id="id95" class="indexterm"/>with the <code class="literal">class</code> keyword. Usually, a class definition starts with the package name, and then import package statements. One key difference with the Java counterpart is that Groovy<a id="id96" class="indexterm"/> imports six packages and two classes by default. So, if you create any class, these packages<a id="id97" class="indexterm"/> and classes are automatically available to you:</p><div><pre class="programlisting">import java.lang.* // this is the only default import in Java
import java.util.*
import java.io.*
import java.net.*
import groovy.lang.*
import groovy.util.*
import java.math.BigInteger
import java.math.BigDecimal</pre></div><p>Classes and methods in Groovy by default have public access, whereas in Java it is set to <code class="literal">package-private</code>. We<a id="id98" class="indexterm"/> will start with a sample Groovy class:</p><div><pre class="programlisting">class Order {
  int orderNo
  Customer orderedByCustomer
  String description

  static main(args) {
    Order order1 = new Order();
    order1.orderNo = 1;
    order1.orderedByCustomer = new Customer(name: "Customer1", email: "cust1@example.com")
    order1.setDescription("Ordered by Customer1")
    println order1.orderByCustomer.showMail()
  }
}

class Customer{
  String name
  String email
  String address

  String showMail(){
  email
 }
}</pre></div><p>Here we have created two classes, <code class="literal">Order</code> and <code class="literal">Customer</code>, with some fields; in the main method, we have<a id="id99" class="indexterm"/> created objects, and finally, called the <code class="literal">showMail()</code> method on the <code class="literal">Customer</code> object. Notice how objects are initialized with values. The <code class="literal">Order</code> object is created by the<a id="id100" class="indexterm"/> default constructor, then the object was initialized with the <code class="literal">setter</code> methods defined on fields.</p><p>However, for the <code class="literal">Customer</code> object, it is done with a constructor with named parameters. The <code class="literal">Customer</code> object is initialized with a property-value pair in the constructor. However, we haven't defined any parameterized constructors in the class definition. So how does it work?</p><p>We have created fields in the class with no access modifier. If fields are created with default access, then Groovy automatically creates a field with public <code class="literal">getter</code> and <code class="literal">setter</code> methods. If we specify any access modifier (<code class="literal">public</code>, <code class="literal">private</code>, or <code class="literal">protected</code>), then only fields will be created; no <code class="literal">getter</code> or <code class="literal">setter</code> method will be created. In our preceding example, <code class="literal">orderNo</code>, <code class="literal">orderByCustomer</code>, and <code class="literal">description</code> are declared with no access modifier. So, we were able to call the <code class="literal">setDescription</code> method on the <code class="literal">Order</code> object. Other fields are accessed by field names. In this scenario, Groovy calls the respective <code class="literal">getter</code> or <code class="literal">setter</code> methods internally on the fields. This feature<a id="id101" class="indexterm"/> is called <strong>Property</strong> in Groovy. So, each class in Groovy has properties and autocreated <code class="literal">getter</code> and <code class="literal">setter</code> methods for those properties. This is similar to the Java bean approach, where private fields are created with public <code class="literal">getter</code> and <code class="literal">setter</code> methods, but with less number of lines of code as, <code class="literal">getter</code> and <code class="literal">setter</code> methods are implicitly provided by Groovy. This is why, often, Groovy objects are referred to as<a id="id102" class="indexterm"/> <strong>Plain Old Groovy Object</strong> (<strong>POGO</strong>).</p><p>Coming back to the constructor declaration, when the <code class="literal">Customer</code> object was created with named parameters, actually, a default constructor was created, and then, for each of the properties in the<a id="id103" class="indexterm"/> constructor, respective <code class="literal">setter</code> methods were called to initialize the properties.</p><p>Methods in Groovy are similar to Java, but the class method's visibility is set to <code class="literal">public</code> by default. To invoke<a id="id104" class="indexterm"/> a method on a class, we need to create an object of that class. In case of Groovy scripts where you do not provide any class definition, method invocation is done by calling the method by name. If a method supports a dynamic return type, then the method declaration should start with the <code class="literal">def</code> keyword.</p><p>Groovy also<a id="id105" class="indexterm"/> supports method invocation with default parameter values. In the following example, the <code class="literal">sum</code> method is defined with three parameters <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code>, with values of <code class="literal">y</code> and <code class="literal">z</code> as <code class="literal">10</code> and <code class="literal">1</code>, respectively. The <code class="literal">sum(1)</code> and <code class="literal">sum(1,2)</code> methods should give results <code class="literal">12</code> and <code class="literal">4</code>, respectively.</p><div><pre class="programlisting">def sum(x,y=10,z=1) {x+y+z}
// x = 1
sum(1)
// x = 1, y= 2
sum(1, 2)</pre></div><p>Groovy does not require an explicit return statement in methods. By default, the last evaluated expression is returned as the method output. In the preceding example, we have not mentioned <code class="literal">return x+y+z</code>. It would be returned by default.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Control structures</h1></div></div></div><p>In this section, we will<a id="id106" class="indexterm"/> discuss the basic control structures, namely the <code class="literal">if…else</code> statement, the <code class="literal">switch</code> statement, the <code class="literal">for</code> loop, and the <code class="literal">while</code> loop.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>The if-else condition</h2></div></div></div><p>The <code class="literal">if…else</code> condition in<a id="id107" class="indexterm"/> Groovy is similar to Java with one exception, how Groovy evaluates the logical <code class="literal">if</code> condition. In the following example, the <code class="literal">if</code> condition is evaluated true for both Boolean and int values. In Groovy, non-zero integers, no<a id="id108" class="indexterm"/>n-null values, nonempty strings, initialized collections, and a valid matcher are evaluated as Boolean true values. This<a id="id109" class="indexterm"/> is known as <strong>Groovy Truths</strong>. Let's take a look at the following code:</p><div><pre class="programlisting">def condition1 = true
int condition2 = 0
if(condition1){
  println("Condition 1 satisfied")
  if(condition2){
    println("Condition 2 satisfied")
  }else{
    println("Condition 2 failed")
  }
}else{
  println("Condition 1 failed")
}</pre></div><p>Groovy also supports ternary operators <code class="literal">(x? y: z)</code>, such as Java, which can be used to write the standard <code class="literal">if-else</code> logic:</p><div><pre class="programlisting">(condition2&gt; 0 )? println("Positive") : println("Negative")</pre></div><p>Groovy also provides one additional operator known as the Elvis operator. It can be used as a shorter version of the ternary operator in the scenario, where the user wants to validate a variable against the null value. Consider the following example:</p><div><pre class="programlisting">def inputName
String username = inputName?:"guest"</pre></div><p>If inputName is not null username would be inputName else default value "guest" would be assigned to username</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>The switch statement</h2></div></div></div><p>Groovy supports Class, Object, Range, Collection, Pattern, and Closure as classifiers in the <code class="literal">switch</code> statement. Anything<a id="id110" class="indexterm"/> that implements the <code class="literal">isCase</code> <a id="id111" class="indexterm"/>method can be used as a classifier in the <code class="literal">switch</code> statement. The following example shows a case defined for various classifiers. Just try different values of input and observe the output of the <code class="literal">switch</code> statement:</p><div><pre class="programlisting">def checkInput(def input){
switch(input){    
  case [3, 4, 5]   :   println("Array Matched"); break;
  case 10..15      :   println("Range Matched"); break;
  case Integer     :   println("Integer Matched"); break;
  case ~/\w+/      :   println("Pattern Matched"); break;
  case String      :   println("String Matched"); break;
  default          :   println("Nothing Matched"); break;
}
}
checkInput(3)  // will print Array Matched
checkInput(1)  // will print Integer Matched
checkInput(10)  // will print Range Matched
checkInput("abcd abcd") // will print String Matched
checkInput("abcd")  // will print Pattern Matched</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Loops</h2></div></div></div><p>Groovy supports both <code class="literal">for (initialize; condition; increment)</code> and <code class="literal">for-each</code> type looping. The <code class="literal">for-each</code> style is expressed as <code class="literal">for(variable in Iterable) { body}</code>. As loop <a id="id112" class="indexterm"/>works on an iterable object collection, it can be easily applied to array, range, collections, and so on. Let's take a look at the following code:</p><div><pre class="programlisting">// Traditional for loop
for(int i = 0; i&lt; 3; i++) {/* do something */ }
// Loop over a Range
for(i in 1..5) println(i)
// Array iteration
def arr = ["Apple", "Banana", "Mango"]
for(i in arr) println(i)
// for applied on Set
for(i in ([10,10,11,11,12,12] as Set)) println(i)</pre></div><p>The <code class="literal">while</code> loop is similar to the Java <code class="literal">while</code> loop, though Groovy doesn't support the <code class="literal">do-while</code> style of looping. Let's demonstrate the <code class="literal">while</code> loop:</p><div><pre class="programlisting">int count = 0
while(count &lt; 5) {
  println count++
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Collections</h1></div></div></div><p>We assume you have basic knowledge<a id="id113" class="indexterm"/> on <strong>Java Collection Framework</strong> (<strong>JCF</strong>), so we are not going to discuss the fundamentals of the collection framework. We start on what Groovy provides on<a id="id114" class="indexterm"/> collection framework and frequently used utility methods provided by different collection objects.</p><p>Groovy supports different collective data types to store group of objects, such as range, lists, sets, and maps. If you are already a Java programmer, you will find how easy it is in Groovy to play<a id="id115" class="indexterm"/> with collective data types as compared to Java. Apart from sets, lists, and maps, Groovy has introduced ranges, which was not available in Java.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Set</h2></div></div></div><p>A set is an unordered collection of objects, with no duplicates. It can be considered as an unordered list with restrictions on uniqueness, and is often constructed from a list. Set can also contain at most one null<a id="id116" class="indexterm"/> element. As implied by its name, this interface models the mathematical set abstraction.</p><p>The following <a id="id117" class="indexterm"/>code snippet explains how to create a <code class="literal">Set</code>. Elements can be added or removed from the <code class="literal">Set</code> using the <code class="literal">add</code>, <code class="literal">addAll</code>, <code class="literal">remove</code>, or <code class="literal">removeAll</code> methods.</p><p>You might have learned a lot about <code class="literal">Set</code> in your math classes, where the instructor teaches you different set operations, such as union and intersection. Groovy also provides similar functionalities. The union of two sets contains all the unique elements and common elements present in both the sets without repetition. The intersection finds common elements between the two sets. The complement of <code class="literal">Set1</code> and <code class="literal">Set2</code> will contain all those elements of <code class="literal">Set1</code> that are not present in <code class="literal">Set2</code>. </p><p>Let's take a look at the following code:</p><div><pre class="programlisting">// Creating a Set
def Set1 = [1,2,1,4,5,9] as Set
Set Set2 = new HashSet( ['a','b','c','d'] )

// Modifying a Set
Set2.add(1)
Set2.add(9)
Set2.addAll([4,5])        // Set2: [1, d, 4, b, 5, c, a, 9]

Set2.remove(1)        
Set2.removeAll([4,5])    // Set2: [d, b, c, a, 9]

// Union of Set
Set Union = Set1 + Set2     // Union: [1, 2, 4, 5, 9, d, b, c, a]

// Intersection of Set
Set intersection = Set1.intersect(Set2)    // Intersection: [9]

// Complement of Set
Set Complement = Union.minus(Set1)    // Complement: [d, b, c, a]</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>List</h2></div></div></div><p>As compared to <code class="literal">Set</code>, a <code class="literal">List</code> is an ordered collection of objects, and a <code class="literal">List</code> can contain duplicate elements. A <code class="literal">List</code> can be created using <code class="literal">List list = []</code>, which creates an empty list that is an<a id="id118" class="indexterm"/> implementation of <code class="literal">java.util.ArrayList</code>.</p><p>The following code snippet<a id="id119" class="indexterm"/> shows how to create a <code class="literal">List</code>, read values from the list, and list some utility methods on the <code class="literal">List</code>:</p><div><pre class="programlisting">// Creating a List
 def list1 = ['a', 'b', 'c', 'd']
 def list2 = [3, 2, 1, 4, 5] as List

// Reading a List
println list1[1]          // Output: b
println list2.get(4)      // Output: 5
println list1.get(5)      //Throws IndexOutOfBoundsException

// Some utility method on List
//Sort a List
println list2.sort()      // Output: [1, 2, 3, 4, 5]
// Reserve a list
println list1.reverse()      // Output: [d, c, b, a]
// Finding elements
println ("Max:" + list2.max() + ":Last:" + list1.last())   
// Output: Max:5:Last:d</pre></div><p>Some of the <code class="literal">List</code> methods accept Closure. The following example shows how to find the first even number using the <code class="literal">find</code> method, and list of all the even numbers using the <code class="literal">findAll</code> method:</p><div><pre class="programlisting">println list2.find({ it %2 == 0})    // Output: 2
println list2.findAll({it %2 == 0})  // Output: [2, 4]</pre></div><p>Do not get confused by the "it" keyword inside the curly brackets. We will discuss this in the <em>Closure</em> section.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Map</h2></div></div></div><p>Map is a key-value pair collection, where the key is unique. In Groovy, key-value pairs are delimited by colons. An empty Map can be created via [<code class="literal">:</code>]. By default, a Map is of the type <code class="literal">java.util.HashMap</code>. If the keys are <a id="id120" class="indexterm"/>of type String, you can avoid the single or double<a id="id121" class="indexterm"/> quotes in the Map declaration. For example, if you want to create a Map with <code class="literal">name</code> as the key and <code class="literal">Groovy</code> as the value, you can use the following notation:</p><div><pre class="programlisting">Map m1 = [name:"Groovy"]</pre></div><p>Here, <code class="literal">[name: "Groovy"]</code> is the same as <code class="literal">["name":"Groovy"]</code>. By default, Map keys are Strings. But if you want to put some variable as the key, then use parentheses, as shown in the following code:</p><div><pre class="programlisting">String s1 = "name"
Map m1 = [(s1):"Groovy"]</pre></div><p>Alternatively, you can create a Map in the following way:</p><div><pre class="programlisting">def m2 = [id:1,title: "Mastering Groovy" ] as Map</pre></div><p>You can get the<a id="id122" class="indexterm"/> objects from the Map using <code class="literal">key m2.get("id")</code> or <code class="literal">m2["id"]</code>.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>If key is a String, then to get a value, you need to specify the key in double quotes (<code class="literal">""</code>). If you do not specify the key in double quotes, it will treat it as a variable name and will try to resolve it.</p></div></div><p>Now we will <a id="id123" class="indexterm"/>discuss some of the utility methods (each, any, and every) of Maps, which accept Closures:</p><div><pre class="programlisting">Map ageMap = [John:24, Meera:28,Kat:31,Lee:19,Harry:18]</pre></div><p>To parse every entry of <code class="literal">Map</code>, you can use <code class="literal">each</code>. It takes either entry or key-value as a parameter, as shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
</p><div><pre class="programlisting">ageMap.each {key, value -&gt;
  println "Name is "+key
  println "Age is " + value
}</pre></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>
</p><div><pre class="programlisting">ageMap.each {entry  -&gt;
  println "Name is "+entry.key
  println "Age is " + entry.value
}</pre></div><p>
</p>
</td></tr></tbody></table></div><p>If you want to validate the <code class="literal">Map</code> data, you can use either <code class="literal">.every</code> or <code class="literal">.any</code>, based on your requirements. The <code class="literal">.every</code> method checks and makes sure all records fulfil the mentioned condition, while <code class="literal">.any</code> just checks whether any one record fulfils the condition. For example, if you want to check whether there is any user who is more than 25 years old:</p><div><pre class="programlisting">ageMap.any {entry -&gt; entry.value &gt; 25 }</pre></div><p>It returns the output as a Boolean value; in this case, true, as Meera is 28.</p><p>If you want to check whether all the users are above 18:</p><div><pre class="programlisting">ageMap.every {entry -&gt; entry.value &gt; 18 }</pre></div><p>It will return false, as Harry is 18.</p><p>You can also use the <code class="literal">find</code> and <code class="literal">findAll</code> methods for <code class="literal">Map</code> in the same pattern as we used for <code class="literal">List</code> in the <em>List</em> section.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Range</h2></div></div></div><p>Apart from Java collection types, Groovy also supports a new collective data type <code class="literal">Range</code>. It is defined as two values (generally starting point and ending point) separated by two dots.</p><p>To create a <code class="literal">Range</code>, use the following code:</p><div><pre class="programlisting">def range1 = 1..10
Range range2 = 'a'..'e'</pre></div><p>To read values<a id="id124" class="indexterm"/> from <code class="literal">Range</code>, use the following code:</p><div><pre class="programlisting">range1.each { println it }</pre></div><p>You can also use the <code class="literal">.any</code> and <code class="literal">.every</code> operators to validate range for your specific requirement. It checks for the <a id="id125" class="indexterm"/>condition and returns a Boolean value. Let's take a look at the following code:</p><div><pre class="programlisting">range1.any { it &gt; 5 }
range1.every { it &gt; 0 }</pre></div><p>For modifying the range interval, use the following code. If you want to modify range interval from default 1 to any other number, you can set it via step method. It returns a list:</p><div><pre class="programlisting">List l1 = range1.step(2)    //Output: [1, 3, 5, 7, 9]</pre></div><p>To fetch the starting element and ending element of a range, use the <code class="literal">From</code> and <code class="literal">To</code> element, as shown in the following code:</p><div><pre class="programlisting">range1.getFrom()      //Output: 1
range1.getTo()        //Output: 10</pre></div><p>The <code class="literal">isReverse()</code> method is used to check the range trend to see whether the range is constructed using <code class="literal">to value</code> ( higher value) to <code class="literal">from value</code> (lower value):</p><div><pre class="programlisting">range1.isReverse()       // Output: false</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Closure</h1></div></div></div><p>Closure has usually been associated with functional languages. Groovy provides a very easy way of creating closure objects. A Groovy Closure is like a code block written in curly braces. Many people associate<a id="id126" class="indexterm"/> Closure to be an anonymous function in Java.</p><p>Closure in Groovy<a id="id127" class="indexterm"/> may accept arguments and returns a value. By default, the last statement in a Groovy Closure is the <code class="literal">return</code> statement. It means that if you are not explicitly returning any value from Closure, it will by default, returns the output of the last statement of Closure. Commonly, we define a Closure like this <code class="literal">{argument list-&gt; closure body}</code>. Here, an argument list is a comma separated value that Closure accepts. Arguments are optional. If no argument is specified, then one implicit untyped argument named <code class="literal">it</code> will be available in the Closure body. The argument <code class="literal">it</code> will be null if no argument is supplied during Closure invocation.</p><p>In the following <a id="id128" class="indexterm"/>example, for the first call of Closure <code class="literal">addTwo</code> the variable <code class="literal">it</code> is assigned is <code class="literal">2</code>, but in the second call, <code class="literal">it</code> is assigned null:</p><div><pre class="programlisting">def addTwo = {it+2 }
addTwo(2)          // Output: 4
addTwo()          // NullPointerException</pre></div><p>Alternatively, you can even declare a variable of type Closure. In Groovy, Closures are a subclass of the <code class="literal">groovy.lang.Closure</code> type:</p><div><pre class="programlisting">groovy.lang.Closure closure1 = { println it }
closure1("This will be printed") // Output: This will be printed</pre></div><p>To separate the Closure body from the argument list, we use the <code class="literal">-&gt;</code> operator. The closure body consists of zero or more Groovy statements. Like methods, it can also reference and declare variables in its scope.</p><p>In the following code snippet, the <code class="literal">addOne</code> method was able to reference the <code class="literal">constantValue</code> variable in its scope, though it was defined outside of the Closure scope. Such variables are<a id="id129" class="indexterm"/> referred to as <code class="literal">free</code> variables. A variable which is defined within the curly braces of a Closure would be treated as a local variable:</p><div><pre class="programlisting">int constantValue = 9
def addOne = { Integer a -&gt; constantValue + a }

addOne(1)         // unnamed () invocation. Output: 10
addOne.call(1)    // call() invocation. Output: 10
addOne("One")     // MissingMethodException</pre></div><p>In the preceding example, the argument of the Closure was of Integer type. With Closures, the statements within the curly braces are not executed until you explicitly invoke them, using either <code class="literal">call()</code> or by an <code class="literal">unnamed ()</code> invocation syntax of Closure. In our example, the closure is declared in the second line, but it's not evaluated at that time. It will be executed if the <code class="literal">call()</code> method is explicitly made on the Closure. This is an important differentiator between Closures and code blocks. They may look the same, but they are not. Closures are only executed if the <code class="literal">call()</code> method is invoked on the Closure; not during its definition time. Remember, Closures are first class objects in Groovy, and can be referred using untyped variables or by using Closure variables. In both the cases, it is derived from <code class="literal">groovy.lang.Closure</code>. This class has overloaded <code class="literal">call()</code> methods with no or multiple arguments to invoke Closures.</p><p>When <code class="literal">addOne</code> Closure was called with an Integer as an argument, it executed successfully. However, for String type as an argument, it throws an exception. Also observe that the compiler didn't complain when we passed a String as an argument to the <code class="literal">addOne</code> Closure. This is because all arguments are checked at runtime; there is no static type checking done by the compiler.</p><p>The <code class="literal">doCall()</code> method on this Closure is generated dynamically, which accepts only Integer as an <a id="id130" class="indexterm"/>argument. So any invocation other than Integer type will throw an exception. The <code class="literal">doCall()</code> method is the implicit method, which cannot be overridden and cannot be redefined. This method is always invoked implicitly when we invoke call method or <code class="literal">unnamed ()</code> syntax on a Closure.</p><p>We will conclude Closure by discussing the concept of delegate. This feature is widely used in Gradle. For <a id="id131" class="indexterm"/>example, when we define a repository Closure or dependency Closure in the build script, those Closures are executed in the <code class="literal">RepositoryHandler</code> or <code class="literal">DependencyHandler</code> classes. These classes are passed to the closures as delegates. You can refer to the Gradle API for more details. Let us not complicate things here. We will try to understand the concept with simple examples.</p><p>Consider the following example, where we are trying to print a <code class="literal">myValue</code> variable, which is undefined in the class. Obviously, this call will throw an exception as this variable is not defined in the scope:</p><div><pre class="programlisting">class PrintValue{
  def printClosure = {
    println myValue
  }
}
def pcl = new PrintValue().printClosure
pcl()   //Output: MissingPropertyException: No such property</pre></div><p>There could be a situation where we want to execute this closure against another class. This class can be passed to the closure as a delegate:</p><div><pre class="programlisting">class PrintHandler{
  def myValue = "I'm Defined Here"
}

def pcl = new PrintValue().printClosure
pcl.delegate = new PrintHandler()
pcl()

OUTPUT: I'm Defined Here</pre></div><p>In this example, the <code class="literal">PrintHandler</code> class has defined the <code class="literal">myValue</code> variable. We have delegated and executed the closure against the <code class="literal">PrintHandler</code> class.</p><p>So far, it is working as expected. Now, what if <code class="literal">myValue</code> is redefined in the <code class="literal">PrintValue</code> class:</p><div><pre class="programlisting">class PrintValue{
  def myValue = "I'm owner"
  def printClosure = {
    println myValue
  }
}</pre></div><p>In this scenario, on executing the Closure, we will find the output as <code class="literal">I'm owner</code>. This is because, when closure was trying to resolve the <code class="literal">myValue</code> variable, it found the variable <a id="id132" class="indexterm"/>defined within the scope of the owner (the <code class="literal">PrintValue</code> class, where the Closure is defined), so it didn't delegate the call to the <code class="literal">PrintHandler</code> class. Formally, this is known as <code class="literal">OWNER_FIRST</code> strategy, which is the default strategy. The strategy resolves this way—the closure will be checked first, followed by the closure's scope, then the owner of the closure, and, finally, the delegate. Groovy is so flexible that it provides us with the<a id="id133" class="indexterm"/> capability to change the strategy. For example, to delegate the call to the <code class="literal">PrintHandler</code> class, we should specify the strategy as <code class="literal">DELEGATE_FIRST</code>:</p><div><pre class="programlisting">def pcl = new PrintValue().printClosure
pcl.resolveStrategy = Closure.DELEGATE_FIRST
pcl.delegate = new PrintHandler()
pcl()</pre></div><p>With the <code class="literal">DELEGATE_FIRST</code> strategy, the closure will try to resolve the property or methods to the delegate first and then the owner. The other important strategies are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OWNER_ONLY</code>: It attempts to resolve the property or methods within the owner only and doesn't delegate.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DELEGATE_ONLY</code>: Closure will resolve the property references or methods to the delegate. It completely ignores the owner.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TO_SELF</code>: It will resolve the property references or methods to itself and go through the usual <code class="literal">MetaClass</code> look-up process.</li></ul></div><p>This was indeed a<a id="id134" class="indexterm"/> very short description. I suggest you to refer to the Groovy documentation for more details at: <a class="ulink" href="http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html">http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Builder</h1></div></div></div><p>Another important feature in <a id="id135" class="indexterm"/>Groovy is Builder. Groovy Builders allow you to<a id="id136" class="indexterm"/> create complex tree-like hierarchical object structures. For example, SwingUI or XML documents can be created very easily using the DSL or Closure-like features in Groovy, with the support of the <code class="literal">BuilderSupport</code> class and its subclasses, <code class="literal">MarkupBuilder</code> and <code class="literal">SwingBuilder</code>.</p><p>Let's try to understand with an example. We created the <code class="literal">Order</code> class earlier in this chapter. Assume we have a list of orders and we want to store the details in a file called <code class="literal">orders.xml</code>. So every <code class="literal">Order</code> object in our list should be saved as a node in the XML file. Each of<a id="id137" class="indexterm"/> these <code class="literal">Order</code> nodes, again should contain child nodes, grand children<a id="id138" class="indexterm"/> nodes, and so on. Creating this tree-like structure can be complex if we try to implement a DOM-like parser in Java:</p><div><pre class="programlisting">&lt;orders&gt;
  &lt;order&gt;
    &lt;no&gt;1&lt;/no&gt;
    &lt;description&gt;Ordered by customer 1&lt;/description&gt;
    &lt;customer&gt;
      &lt;name firstname='Customer1' /&gt;
      &lt;email&gt;cust1@example.com&lt;/email&gt;
    &lt;/customer&gt;
  &lt;/order&gt;
  &lt;order&gt;
    &lt;no&gt;2&lt;/no&gt;
    &lt;description&gt;Ordered by customer 2&lt;/description&gt;
    &lt;customer&gt;
      &lt;name firstname='Customer2' /&gt;
      &lt;email&gt;cust2@example.com&lt;/email&gt;
    &lt;/customer&gt;
  &lt;/order&gt;
  ….
&lt;/orders&gt;</pre></div><p>But in Groovy, this is just few lines of code with some method calls combined with Closure and named parameters. In the following example, we have created a <code class="literal">builder</code> object from the <code class="literal">MarkupBuilder</code> class to create the XML document. Then we have defined <code class="literal">orders</code> as the root of the document. However, <code class="literal">builder</code> has no method defined as <code class="literal">orders</code>. So then, how does this work?</p><p>As mentioned earlier, the <code class="literal">MarkupBuilder</code> class is a subclass of the <code class="literal">BuilderSupport</code> class. <code class="literal">BuilderSupport</code> has methods such as <code class="literal">createNode</code>, <code class="literal">invokeMethod</code>, <code class="literal">nodeCompleted</code>, <code class="literal">setCurrent</code>, <code class="literal">setParent</code>, and a few more. In runtime, an object is created by calling the <code class="literal">createNode</code> method on the builder with the name <code class="literal">orders</code>. In a similar fashion, for each <code class="literal">order</code> object, <code class="literal">no</code>, <code class="literal">description</code>, and <code class="literal">customer</code> nodes are created. Finally, each <code class="literal">order</code> node is attached to the parent <code class="literal">orders</code> node by calling the <code class="literal">setParent</code> method of the builder object:</p><div><pre class="programlisting">def builder = new groovy.xml.MarkupBuilder(new FileWriter("orders.xml"))

  builder.orders{
    for(i in orderlist){
      order{
        no(i.orderNo)
        description(i.description)
        customer{
          name(firstname : i.orderedBy.name)
          email(i.orderedBy.email)
        }
      }
    }
  }</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we discussed some basic fundamental concepts. We learned about concepts of classes, methods, beans, collection frameworks, and closures. We also developed a markup builder to produce XML files. This was indeed a very short introduction to Groovy. However, in my opinion this introduction should be good enough to write Gradle scripts for your projects.</p><p>From the next chapter onwards, we will start exploring the core features of Gradle. In the next chapter, we will learn task management in Groovy. We will take a close look at the different in-built tasks supported by Gradle. We will also learn about task dependencies and task configurations. Then we will create some custom tasks for build scripts.</p></div></body></html>