["```swift\nupdate\ndidEvaluateActions\ndidSimulatePhysics\ndidApplyConstraints\ndidFinishUpdate\n```", "```swift\nlet menuscene = NodeMenuScene()\n```", "```swift\nlet menuscene = MenuScene(size: view.bounds.size, playbutton: \"Play\", background:\"BG\")\n```", "```swift\n    class GameScene: SKScene, SKPhysicsContactDelegate\n    ```", "```swift\n    let backgroundNode = SKSpriteNode(imageNamed: \"BG\")\n        var spriteWithoutTexture : SKSpriteNode?\n        let myAtlas = SKTextureAtlas(named: \"idle.atlas\")\n        var player:SKSpriteNode = SKSpriteNode(imageNamed:\"bro5_idle0001@2x\")\n        var currentno = 0\n\n        // SETTING UP \"RUNNING BAR\", \"BLOCK 1\", \"Block 2\n        let runningBar = SKSpriteNode(imageNamed:\"bar\")\n        let block1 = SKSpriteNode(imageNamed:\"block1\")\n        let block2 = SKSpriteNode(imageNamed:\"block2\")\n        var origRunningBarPositionX = CGFloat(0)\n        var maxBarX = CGFloat(0)\n        var groundSpeed = 5\n        var playerBaseline = CGFloat(0)\n        var onGround = true\n\n        // INITIALIZING PHYSICAL PROPERTIES VALUES\n        var velocityY = CGFloat(0)\n        let gravity = CGFloat(0.6)\n        var blockMaxX = CGFloat(0)\n        var origBlockPositionX = CGFloat(0)\n        var blockStatuses:Dictionary<String,BlockStatus> = [:]\n\n        //COLLISION TYPE BETWEEN \"BLOCKS\" AND \"PLAYER\"\n        enum ColliderType:UInt32\n        {\n            case player = 1\n            case Block = 2\n        }\n    ```", "```swift\n        override func didMoveToView(view: SKView)\n        {\n            self.physicsWorld.contactDelegate = self\n\n            //#1\n            addBackGround()\n            addRunningBar()\n            addPlayer()\n            addBlocks()\n\n        }\n    ```", "```swift\n    func random() -> UInt32\n        {\n            var range = UInt32(50)..<UInt32(200)\n            return range.startIndex + arc4random_uniform(range.endIndex - range.startIndex + 1)\n    //CREATING BLOCKS FROM LIBRARY METHOD OF iOS\n        }\n    ```", "```swift\n    func addSpriteWithoutTexture()\n        {\n            spriteWithoutTexture = SKSpriteNode(texture: nil, color:UIColor.redColor(), size: CGSizeMake(100, 100))\n            addChild(spriteWithoutTexture!)\n        }\n    ```", "```swift\n    func addBackGround()\n        {\n            backgroundNode.zPosition = 0\n            var scaleX =  self.size.width/backgroundNode.size.width\n            var scaleY =  self.size.height/backgroundNode.size.height\n            backgroundNode.xScale = scaleX\n            backgroundNode.yScale = scaleY\n            addChild(backgroundNode)\n        }\n    ```", "```swift\n    func addPlayer()\n        {\n\n            player.zPosition = 2;\n            player.name = \"Player\"\n\n            // PHYSICS PROPERTIES FOR player\n            self.playerBaseline = self.runningBar.position.y + (self.runningBar.size.height / 2) + (self.player.size.height / 2)\n            self.player.position = CGPointMake(CGRectGetMinX(self.frame) + self.player.size.width + (self.player.size.width / 4), self.playerBaseline)\n            self.player.physicsBody = SKPhysicsBody(circleOfRadius: CGFloat(self.player.size.width / 2))\n            self.player.physicsBody?.affectedByGravity = false\n            self.player.physicsBody?.categoryBitMask = ColliderType.player.rawValue\n    // Will become '1' because its defined in \"ColliderType\" enum\n            self.player.physicsBody?.contactTestBitMask = ColliderType.Block.rawValue\n            self.player.physicsBody?.collisionBitMask = ColliderType.Block.rawValue\n\n            self.addChild(player)\n        }\n    ```", "```swift\n    func addRunningBar()\n       {\n            self.runningBar.anchorPoint = CGPointMake(0, 0.5)\n            self.runningBar.position = CGPointMake(CGRectGetMinX(self.frame),CGRectGetMinY\n    (self.frame) + (self.runningBar.size.height / 2))\n            self.origRunningBarPositionX = self.runningBar.position.x\n            self.maxBarX = self.runningBar.size.width - self.frame.size.width\n            self.maxBarX *= -1\n            self.addChild(self.runningBar)\n        }\n    ```", "```swift\n    func addBlocks()\n        {\n            // PHYSICS PROPERTIES FOR BLOCK 1\n            self.block1.position = CGPointMake(CGRectGetMaxX(self.frame) + self.block1.size.width, self.playerBaseline)\n            self.block2.position = CGPointMake(CGRectGetMaxX(self.frame) + self.block2.size.width, self.playerBaseline + (self.block1.size.height / 2))\n            self.block1.physicsBody = SKPhysicsBody(rectangleOfSize: self.block1.size)\n            self.block1.physicsBody?.dynamic = false\n            self.block1.physicsBody?.categoryBitMask = ColliderType.Block.rawValue\n            self.block1.physicsBody?.contactTestBitMask = ColliderType.player.rawValue\n            self.block1.physicsBody?.collisionBitMask = ColliderType.player.rawValue\n\n            // PHYSICS PROPERTIES FOR BLOCK 2\n            self.block2.physicsBody = SKPhysicsBody(rectangleOfSize: self.block1.size)\n            self.block2.physicsBody?.dynamic = false\n            self.block2.physicsBody?.categoryBitMask = ColliderType.Block.rawValue\n            self.block2.physicsBody?.contactTestBitMask = ColliderType.player.rawValue\n            self.block2.physicsBody?.collisionBitMask = ColliderType.player.rawValue\n\n            self.origBlockPositionX = self.block1.position.x //ORIGINAL BLOCK POSITION (0,0)\n            self.block1.name = \"block1\"   // SETTING BLOCK NAMES\n            self.block2.name = \"block2\"\n\n            // ADDING BLOCK 1 and BLOCK 2 to DICTIONARY BLOCKSTATUS\n            blockStatuses[\"block1\"] = BlockStatus(isRunning: false, timeGapForNextRun: random(), currentInterval: UInt32(0))\n            blockStatuses[\"block2\"] = BlockStatus(isRunning: false, timeGapForNextRun: random(), currentInterval: UInt32(0))\n\n            self.blockMaxX = 0 - self.block1.size.width / 2\n\n            self.addChild(self.block1)\n            self.addChild(self.block2)\n        }\n    ```", "```swift\n    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {\n            for touch: AnyObject in touches\n            {\n                let location = touch.locationInNode(self)\n                let node = self.nodeAtPoint(location)\n                if node.name == player.name\n                {\n                    currentno++\n                    //changeSpriteFromTextureAtlas()\n\n                    if self.onGround\n                    {\n                           self.velocityY = -18.0\n                           self.onGround = false\n                     }\n                }\n            }\n        }\n    ```", "```swift\n    override func touchesEnded(touches: NSSet, withEvent event: UIEvent)\n        {\n            if self.velocityY < -9.0    //SETTING VELOCITY FOR JUMP ACTION IS FINISHED\n            {\n                self.velocityY = -9.0\n            }\n        }\n    ```", "```swift\n    override func update(currentTime: NSTimeInterval)\n        {\n            if self.runningBar.position.x <= maxBarX\n                {\n                        self.runningBar.position.x = self.origRunningBarPositionX\n                }\n\n                // JUMP ACTION\n                self.velocityY += self.gravity\n                self.player.position.y -= velocityY\n                if self.player.position.y < self.playerBaseline // STOPPING PLAYER TO FALLDOWN FROM BASELINE\n                {\n                    self.player.position.y = self.playerBaseline\n                    velocityY = 0.0\n                    self.onGround = true\n                }\n                //move the ground\n                runningBar.position.x -= CGFloat(self.groundSpeed)\n                blockRunner()\n\n        }\n    ```", "```swift\n    func blockRunner()\n        {\n            // LOOP FOR THE DICTIONARY TO GET BLOCKS\n            for(block, blockStatus) in self.blockStatuses\n            {\n                var thisBlock = self.childNodeWithName(block)!\n                if blockStatus.shouldRunBlock()\n                {\n                    blockStatus.timeGapForNextRun = random()\n                    blockStatus.currentInterval = 0\n                    blockStatus.isRunning = true\n                }\n\n                if blockStatus.isRunning\n                {\n\n                    if thisBlock.position.x > blockMaxX\n    // IF IT IS POSITIVE (KEEP MOVING BLOCKS FROM RIGHT TO LEFT)\n                    {\n                        thisBlock.position.x -= CGFloat(self.groundSpeed) \n                    }\n                    else\n    // IF ITS TIME TO OFF THE SCREEN ie when BLOCKS should DISAPPEAR\n                    {\n                        thisBlock.position.x = self.origBlockPositionX\n                        //blockStatus.isRunning = false\n                    }\n                }\n                else\n                {\n                    blockStatus.currentInterval++\n                }\n            }\n        }\n    ```", "```swift\n    class BlockStatus            //\n    {\n        var isRunning = false                 //CURRENTLY RUNNING ON SCREEN OR NOT\n        var timeGapForNextRun = UInt32(0)      // HOW LONG WE IT SHOULD WAIT FOR NEXT RUN\n        var currentInterval = UInt32(0)         //TOTAL INTERVAL WAITED\n\n        // INITIALIZING BLOCK STATUS\n        init(isRunning:Bool, timeGapForNextRun:UInt32, currentInterval:UInt32) {\n            self.isRunning = isRunning\n            self.timeGapForNextRun = timeGapForNextRun\n            self.currentInterval = currentInterval\n        }\n\n        // RUNNING BLOCKS\n        func shouldRunBlock() -> Bool\n        {\n            return self.currentInterval > self.timeGapForNextRun\n        }\n    }\n    ```"]