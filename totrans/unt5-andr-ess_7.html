<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Troubleshooting and Best Practices"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Troubleshooting and Best Practices</h1></div></div></div><p>Primarily, this chapter will explore how to enhance the quality of games and applications using different techniques and physically-based shaders. Secondly, this chapter will describe global illumination in Unity 5. At the end of the chapter, you will optimize a shader code.</p><p>The topics that will be covered in the chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Measuring performance with the built-in Android profiler</li><li class="listitem" style="list-style-type: disc">Debugging Android devices with the Unity profiler tool</li><li class="listitem" style="list-style-type: disc">Best practices in scripts and shaders</li></ul></div><div class="section" title="Measuring performance with the built-in Android profiler"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec31"/>Measuring performance with the built-in Android profiler</h1></div></div></div><p>Let's look at what kind of <a id="id368" class="indexterm"/>information we<a id="id369" class="indexterm"/> can see from the built-in Android profiler in Unity 5.</p><div class="section" title="General CPU activity"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec70"/>General CPU activity</h2></div></div></div><p>Next, we're going to talk about the<a id="id370" class="indexterm"/> information we can get from the built-in profiler. To make it easier to understand the structure of these messages, we'll cover them in groups. The first group includes the general information or in other words the overall performance statistics on the CPU.</p><p>You will see the total time that was spent by the CPU in the parameter value called <code class="literal">cpu-player</code>. The time that was spent on the CPU side by the OpenGLES driver code will be seen in the value of the parameter called <code class="literal">cpu-ogles-drv</code>. Next, let's consider the following parameter, known as <code class="literal">cpu-waits-gpu</code>. This option will not appear in the built-in profiler for very small values. This value shows how much CPU time was spent waiting for the end of rendering on the GPU side. Next, let's consider the following parameter, known as <code class="literal">msaa-resolve</code>. This value shows how much CPU time was spent on anti-aliasing methods. Let's consider the following parameter, known as <code class="literal">cpu-present</code>. This value shows how much CPU time was spent on executing the OpenGLES <code class="literal">presentRenderbuffer</code> function. Let's also look at the value of the last parameter in this group, known as <code class="literal">frametime</code>. This<a id="id371" class="indexterm"/> value shows the time spent on the CPU side for frame execution.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Refresh rate of the Android hardware is locked at about 60 Hz, so you will have the frame time at about ~16.7 ms (approximately 16.7 milliseconds we get from computing—1000 milliseconds divided by 60 Hz).</p></div></div></div><div class="section" title="Rendering statistics"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec71"/>Rendering statistics</h2></div></div></div><p>Now let's consider the following group of<a id="id372" class="indexterm"/> statistics based on the rendering. This group contains only four parameters. The first parameter is called a <code class="literal">draw call</code>. The true meaning of this value is to show draw calls quantified per frame. The second parameter of this group is known as <code class="literal">tris</code>. This value indicates how many triangles the renderer will process. The third parameter of this group is known as <code class="literal">verts</code>. This value shows how many vertices the renderer will process. The upper limit number for static geometry is 10,000 vertices and much lower for skinned geometry. Finally, the last parameter, which we will study in this group, is called <code class="literal">batched</code>. The value of this parameter greatly affects your performance, so try to reduce this value as much as possible. This value demonstrates the number of automatically batched draw calls, triangles, and vertices by the Unity engine.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>In order to improve Unity engine batching, you should use shared materials everywhere possible for all available objects.</p></div></div></div><div class="section" title="Detailed Unity player statistics"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Detailed Unity player statistics</h2></div></div></div><p>Now, consider the following group of <a id="id373" class="indexterm"/>statistics, which is more detailed. The first parameter in the detailed statistics of the built-in profiler is known as <code class="literal">physx</code>. This value indicates the time spent on physics engine execution. The text parameter is called <code class="literal">animation</code>. This value indicates the time spent on bone animations. The third parameter in the detailed statistics is called <code class="literal">culling</code>. This value indicates how much time was spent culling the object's execution. The fourth parameter in the detailed statistics of the built-in profiler is known as <code class="literal">skinning</code>. This value indicates the time we need to apply animations to skinned meshes. The fifth parameter in this detailed statistics is called <code class="literal">batching</code>. This value shows the time spent on batching geometry execution.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Batching static geometry is less expensive versus batching dynamic geometry.</p></div></div><p>The sixth parameter in the <a id="id374" class="indexterm"/>detailed statistics is called <code class="literal">render</code>. This value represents the execution time spent on rendering visible objects. The seventh parameter is called <code class="literal">fixed-update-count</code>. This value shows the upper and lower values of the <code class="literal">FixedUpdate</code> execution time for the current frame. Try to decrease this value as much as possible because it can decrease your performance.</p></div><div class="section" title="Detailed script statistics"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec73"/>Detailed script statistics</h2></div></div></div><p>There are just three obtainable<a id="id375" class="indexterm"/> parameters. The first one is known as <code class="literal">update</code>. This value determines the time used for execution per <code class="literal">Update</code> function in your scripts. The next parameter is called <code class="literal">fixedUpdate</code>. This value demonstrates the time used for all executions per <code class="literal">FixedUpdate</code> function in your scripts. The following parameter is known as <code class="literal">coroutines</code>. This value determines the time utilized for coroutines execution in your scripts.</p></div><div class="section" title="Detailed statistics on memory allocated by scripts"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec74"/>Detailed statistics on memory allocated by scripts</h2></div></div></div><p>Let's cover the following <a id="id376" class="indexterm"/>group of statistics based on detailed statistics for memory allocation by your scripts. There are only four parameters. The first parameter is called <code class="literal">allocated heap</code>. </p><p>This value represents available memory for allocation. If we need more memory than is available in the heap, a garbage collector will be called. However, if the garbage collector cannot free up more memory for us, then the heap will be increased in size. The next parameter is known as <code class="literal">used heap</code>. This value indicates the allocated heap by objects. It will be increased for each new class instance, and not for structs before the garbage collector will be called one more time. The following parameter is known as <code class="literal">max numbers of collections</code>. This value shows the quantity of the garbage collector calls within the last 30 frames. The last parameter in this group, and the last one in the built-in profiler, is called <code class="literal">collection total duration</code>. This value displays the summarized milliseconds used for the garbage collector calls within the last 30 frames.</p></div></div></div>
<div class="section" title="Debugging Android devices with the Unity profiler tool"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec32"/>Debugging Android devices with the Unity profiler tool</h1></div></div></div><p>We can open the <a id="id377" class="indexterm"/>Unity profiler window <a id="id378" class="indexterm"/>from the menu, which presents the whole Unity profiler tool. In the upcoming sections, we will explore more about the Unity profiler areas.</p><p>Before starting, we need to know how this tool is works and how simple it is to use. Firstly, let's look more at the Unity profiler tool window structure and separate its parts. As we can see in the next screenshot, there are four main visual parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Profiler controls</li><li class="listitem" style="list-style-type: disc">Usage area</li><li class="listitem" style="list-style-type: disc">Profiler timeline</li><li class="listitem" style="list-style-type: disc">Information table</li></ul></div><p>The upcoming sections focus on these distinctive parts of the Unity profiler tool. Let's dive into the most interesting thing in this instrument.</p><p>Regarding the visual profiler, you can connect to access devices on which your application is performing in order to further analyze the performance of your software. In order to connect to the other device, it is necessary (but not just sufficient) for the profiler to be on the same local network. The <span class="strong"><strong>Active Profiler</strong></span> option allows you to select your device from a list of the desired connections. Besides that, your application should be launched with the <span class="strong"><strong>Development Build enabled</strong></span> checkbox from <span class="strong"><strong>Build Settings</strong></span>. Also in these settings, you will see the <span class="strong"><strong>Autoconnect profiler</strong></span> option, which is necessary to signal whether Unity should or should not be connected to the profiler every time you start your application.</p><p>The following are the Unity profiler buttons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Record</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Deep Profiler</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Profile Editor</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Active Profiler</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Clear</strong></span></li></ul></div><div class="mediaobject"><img src="graphics/9191OT_07_01.jpg" alt="Debugging Android devices with the Unity profiler tool"/></div><p>If you look at the top of the profiler window, you will see there is a toolbar, which we will examine in more detail later in the chapter. Using the buttons on the toolbar, you can enable or disable the profiler recording data. Also, you can clear the collected information or navigate in the frame set and much more; we will talk more about this later. Right in the toolbar, we see the <span class="strong"><strong>Current</strong></span> button. After clicking on this button, we will automatically get on a frame and the last detail of its implementation. If your game was played in the Unity editor, it will be suspended, meaning it will be paused. It will also be suspended when switching frames forward or backward, using the arrows buttons, which are not far away from the <span class="strong"><strong>Current</strong></span> button. Also, be aware that the profiler does not preserve all the frames, but only a certain number of the most recent frames. Furthermore, if you go from left to right on the toolbar profiler, we see a <span class="strong"><strong>Clear</strong></span> button to clear all the data that was collected. After this, we see a <span class="strong"><strong>Active Profiler</strong></span> button, which allows you to select a device or the Unity editor for further performance analysis. </p><p>Next, we see a button called <span class="strong"><strong>Profile Editor</strong></span>; if you click on this button, you will begin to get detailed statistics execution for the Unity editor. To the left of this button, you will see the <span class="strong"><strong>Deep Profile</strong></span> button. When this button is activated, it will provide information about all of your scripts and function calls. Deep profiling<a id="id379" class="indexterm"/> can significantly slow down<a id="id380" class="indexterm"/> your application or your game, as it will be necessary to spend most of the time processing and requires a huge amount of memory space. Remember that very deep profiling will only work if you use it for small projects, otherwise you run the risk that Unity will not be able to obtain the necessary resources and hang, following which you will have to restart the Unity editor. Also, deep profiling is well suited not only for small projects, but is also very useful for testing key aspects of your game or application. You can use the code in deep profiling, and that is switched ON and OFF for specific pieces of code in your scripts. Only the necessary parts of the code will be profiled and analyzed. </p><p>The <code class="literal">Profiler.BeginSample</code> and <code class="literal">Profiler.EndSample</code> calls are the beginning and endpoints, respectively, of profiling your code, which means that the code between these two function calls will be profiled and detailed statistics will be displayed in the bottom profiler window. We will talk about profiler scripting a little later in this chapter. On the left from the <span class="strong"><strong>Deep Profile</strong></span> button is a button that is called <span class="strong"><strong>Record</strong></span>, and it is needed to enable or disable profiling as we mentioned earlier. Well, the left-most button in the toolbar is called <span class="strong"><strong>Add Profiler,</strong></span> and it is needed to display different profiler areas: <span class="strong"><strong>CPU</strong></span>, <span class="strong"><strong>GPU</strong></span>, <span class="strong"><strong>Rendering</strong></span>, <span class="strong"><strong>Memory</strong></span>, <span class="strong"><strong>Audio</strong></span>, <span class="strong"><strong>Physics 3D</strong></span>, and <span class="strong"><strong>Physics2D</strong></span>. We will talk about these profiler areas later in this chapter.</p><p>If your game or your application is running at a specific frame rate or is synchronized with the vertical blank, then Unity will keep the average time waiting for the synchronization of all frames in a parameter called <code class="literal">Wait For Target FPS</code>, which is displayed in the profiler. By default, the information on waiting times will not be published in the Unity profiler. To change the specified default behavior, you need to enable <code class="literal">View SyncTime</code>.</p><div class="section" title="Profiler timeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec75"/>Profiler timeline</h2></div></div></div><p>In the upper part of the profiler window is<a id="id381" class="indexterm"/> a graph that shows the profiler load data in<a id="id382" class="indexterm"/> real time. Statistics are processed in each frame and are saved only in the history of the last couple of hundred frames. If you select one of the frames for further consideration, you will see details at the bottom profiler, which in turn will depend on the selected timeline area (for example, <span class="strong"><strong>CPU</strong></span>, <span class="strong"><strong>GPU,</strong></span> or <span class="strong"><strong>Audio</strong></span>). You can both add and remove various timeline areas. Also, note that the colored squares on the left display different timeline areas. In fact, it is not just the colored squares; they are radio buttons. Thus, it will be much easier to eliminate unnecessary data when optimizing your application.</p></div><div class="section" title="The CPU area"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec76"/>The CPU area</h2></div></div></div><p>The CPU area clearly <a id="id383" class="indexterm"/>shows which specific place and how much total time was<a id="id384" class="indexterm"/> spent on the CPU side of course. If you choose it, then you will have hit on the CPU area. After that, you will see that the bottom profiler displays enough details solely about the execution of your application on the CPU. Also, you can choose two different modes of displaying detailed information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Hierarchy</strong></span> mode displays the information in a hierarchy, by grouping the data</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Group Hierarchy</strong></span> mode displays information on groups that were distributed logically; for example, the <span class="strong"><strong>Rendering</strong></span> group, the <span class="strong"><strong>Scripts</strong></span> group, the <span class="strong"><strong>Physics</strong></span> group, and many more groups</li></ul></div><p>The <span class="strong"><strong>Others</strong></span> area of the CPU profiler incorporates <span class="strong"><strong>Loading</strong></span>, <span class="strong"><strong>Audio</strong></span>, <span class="strong"><strong>Animation</strong></span>, <span class="strong"><strong>Particles</strong></span>, <span class="strong"><strong>Playerloop</strong></span>, <span class="strong"><strong>AI</strong></span>, and <span class="strong"><strong>Networking</strong></span>.</p></div><div class="section" title="The Rendering area"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec77"/>The Rendering area</h2></div></div></div><p>The <span class="strong"><strong>Rendering</strong></span> area <a id="id385" class="indexterm"/>displays rendering statistics as shown in the<a id="id386" class="indexterm"/> following screenshot. The timeline graphically presents the number of rendered <span class="strong"><strong>Draw Calls</strong></span>, <span class="strong"><strong>Triangles</strong></span>, and <span class="strong"><strong>Vertices</strong></span>. As we can see, the bottom part of the following screenshot and <span class="strong"><strong>Game View Rendering Statistics</strong></span> shown in the next figure are very similar. Further, we will cover the information shown in the following screenshot in details:</p><div class="mediaobject"><img src="graphics/9191OT_07_02.jpg" alt="The Rendering area"/></div><p>The following screenshot is very<a id="id387" class="indexterm"/> similar to the same statistics<a id="id388" class="indexterm"/> information:</p><div class="mediaobject"><img src="graphics/9191OT_07_03.jpg" alt="The Rendering area"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Time per frame and FPS</p>
</td><td style="text-align: left" valign="top">
<p>The time spent rendering one frame in milliseconds; represents quantity of frames per second.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Draw calls</p>
</td><td style="text-align: left" valign="top">
<p>The amount of rendered meshes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Batched (draw Calls)</p>
</td><td style="text-align: left" valign="top">
<p>The number of batched draw calls.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Tris and verts</p>
</td><td style="text-align: left" valign="top">
<p>The amount of drawn geometry (triangles and vertices).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Used textures</p>
</td><td style="text-align: left" valign="top">
<p>This indicates how many textures were used and the amount of memory needed per frame.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Render textures</p>
</td><td style="text-align: left" valign="top">
<p>This shows the amount of times active render texture was switched per frame; furthermore it demonstrates how much memory is used to render texture, and how many render textures there were.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Screen</p>
</td><td style="text-align: left" valign="top">
<p>This shows the screen size with its anti-aliasing level and memory usage.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>VRAM usage</p>
</td><td style="text-align: left" valign="top">
<p>This roughly indicates the amount of video memory (VRAM) usage; furthermore, represents how much memory your graphic card has.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>VBO total</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Vertex Buffers Objects</strong></span> (<span class="strong"><strong>VBO</strong></span>)<a id="id389" class="indexterm"/> is the number of uploaded meshes to the graphics card.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Visible Skinned Meshes</p>
</td><td style="text-align: left" valign="top">
<p>This shows<a id="id390" class="indexterm"/> the amount of rendered skinned<a id="id391" class="indexterm"/> meshes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Animations</p>
</td><td style="text-align: left" valign="top">
<p>This represents how many animations can be played.</p>
</td></tr></tbody></table></div></div><div class="section" title="The Memory area"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec78"/>The Memory area</h2></div></div></div><p>While profiling this area, you can choose<a id="id392" class="indexterm"/> one of the two available modes for different <a id="id393" class="indexterm"/>displaying modes. The first mode is to display very simple statistics, and the second mode is for displaying very detailed statistics. We cover these two modes in more detail in the following sections:</p><div class="section" title="The simple view"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec22"/>The simple view</h3></div></div></div><p>We begin with the simplest <a id="id394" class="indexterm"/>display mode statistics (as shown in the following screenshot). This shows the usage of memory for each profiled frame in a simpler form than it does in the detailed statistics:</p><div class="mediaobject"><img src="graphics/9191OT_07_04.jpg" alt="The simple view"/><div class="caption"><p>The simple view of the Unity profiler</p></div></div><p>In order to use memory efficiently, Unity tries to keep a certain amount of memory in advance in the form of a pool, or in other words, as a backup buffer, which greatly improves performance. Statistics memory, or rather information about how much memory is consumed, and for what is the described method of reservation, will be shown at the bottom profiler window. Here <a id="id395" class="indexterm"/>are the parameters of these statistics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unity</strong></span>: This indicates the amount of memory used for allocations in the native Unity code</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mono</strong></span>: This shows how big the heap size was, and the amount of memory used for the garbage collector</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Gfx Driver</strong></span>: This indicates the amount of memory used by the driver on shaders, meshes, render targets, and textures</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FMOD</strong></span>: This shows the amount of memory used on audio drivers</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Profiler</strong></span>: This indicates the amount of memory used for the Unity's profiler</li></ul></div><p>The memory area displays information for fundamental types of objects and assets: textures, meshes, materials, animations, audio, and object count.</p></div><div class="section" title="The detailed view"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec23"/>The detailed view</h3></div></div></div><p>In a detailed view, you can<a id="id396" class="indexterm"/> save the current state for further analysis using the <span class="strong"><strong>Take Sample</strong></span> button. In order to obtain such detailed information about the memory usage, the Unity profiler should take time to collect all information needed, and that's why you should not think that you can receive information in real time.</p><div class="mediaobject"><img src="graphics/9191OT_07_05.jpg" alt="The detailed view"/></div><p>The profiler will show information about where and on what the memory was consumed. The following is a list of groups of objects that will be spent in memory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Referenced from native code</li><li class="listitem" style="list-style-type: disc">Scene object</li><li class="listitem" style="list-style-type: disc">Built-in resources</li><li class="listitem" style="list-style-type: disc">Marked as don't save</li></ul></div><p>After you click on one<a id="id397" class="indexterm"/> of the objects in the list, Unity will highlight the selected items in the <span class="strong"><strong>Project</strong></span> view or in the <span class="strong"><strong>Scene</strong></span> view. When profiling your application in the Unity editor, the statistics will be less accurate than it could be on a particular device. Some of the costs associated with the Unity editor execution will also be displayed in the average values that will not be true for your application. Therefore, for a more precise analysis of your application, it is the best decision to connect to real devices and profile statistics in that case.</p></div></div><div class="section" title="The audio area"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec79"/>The audio area</h2></div></div></div><p>This<a id="id398" class="indexterm"/> shows the information <a id="id399" class="indexterm"/>displayed in the audio area.</p></div><div class="section" title="The physics area"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec80"/>The physics area</h2></div></div></div><p>The following is a list <a id="id400" class="indexterm"/>of information <a id="id401" class="indexterm"/>displayed in the Physics 3D area (as shown in following screenshot):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Active Bodies</strong></span>: This indicates the number of awake Rigidbodies</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sleeping Bodies</strong></span>: This displays the number of sleeping Rigidbodies</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Number of Contacts</strong></span>: This shows the total amount of contact points in the scene between all colliders</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Static Colliders</strong></span>: This represents how many colliders were attached on non-Rigidbody objects</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dynamic Colliders</strong></span>: This demonstrates how many colliders were attached on Rigidbody objects</li></ul></div><div class="mediaobject"><img src="graphics/9191OT_07_06.jpg" alt="The physics area"/><div class="caption"><p>The detailed view of the Unity profiler</p></div></div></div><div class="section" title="The GPU area"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec81"/>The GPU area</h2></div></div></div><p>Statistics that are displayed in <a id="id402" class="indexterm"/>the profiler window for the GPU area are <a id="id403" class="indexterm"/>very similar to the displayed statistics for CPU area.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>On the Mac, only OSX 10.7 Lion and later versions support GPU profiling.</p></div></div></div></div>
<div class="section" title="Real-practice techniques"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec33"/>Real-practice techniques</h1></div></div></div><p>There are two different performance <a id="id404" class="indexterm"/>optimization techniques that are used by many professional developers from all over the world.</p><div class="section" title="The high-speed, off-screen particles technique in Unity"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec82"/>The high-speed, off-screen particles technique in Unity</h2></div></div></div><p>The next technique is to <a id="id405" class="indexterm"/>optimize the particle system, which was introduced by NVIDIA, GPU Gems 3. The first step in order to achieve the goal is to render particles into <code class="literal">RenderTexture</code> or, in other words, into another render target with smaller size than screen. The second step in this idea is to blend the particles back into screen. First, we need depth buffer. When we render into another render target, we need depth buffer for its z-testing. In the following line of code, you can register in the <code class="literal">Awake</code> or <code class="literal">Start</code> callbacks just as examples:</p><div class="informalexample"><pre class="programlisting">this.camera.depthTextureMode = DepthTextureMode.depth;</pre></div><p>Let's consider following code for high-speed, off-screen particles:</p><div class="informalexample"><pre class="programlisting">// create the off-screen particles textureRenderTexture yourParticlesRenderTexture = RenderTexture.GetTemporary(
  Screen.width, // yourLowerResolutionIntegerValue 
  Screen.height, // yourLowerResolutionIntegerValue 
  0
);</pre></div><p>The <code class="literal">yourLowerResolutionIntegerValue</code> determines the quality. The highest value means the worst <a id="id406" class="indexterm"/>quality and the best performance and vice versa.</p><p>The second part is very simple and means just tuning your main camera's properties as shown here:</p><div class="informalexample"><pre class="programlisting">yourMainCamera.targetTexture = yourParticlesRenderTexture;
yourMainCamera.backgroundColor = Color.black;
yourMainCamera.cullingMask = yourLayerMask.value;
yourMainCamera.depthTextureMode = DepthTextureMode.None;
yourMainCamera.clearFlags = CameraClearFlags.SolidColor;</pre></div><p>The next step includes rendering and blending particles into the scene:</p><div class="informalexample"><pre class="programlisting">Shader.SetGlobalVector(
  "_Your_Camera_Depth_Texture_Size",
  Vector4(
    this.camera.pixelWidth, this.camera.pixelHeight, 0.0, 0.0
  )
);
depthCamera.RenderWithShader(
  Shader.Find("Pro/Unity/Performance/Particles/Off-Screen"), 
  "RenderType"
);
Material yourMixedMaterial = YouClassHelper.GetMaterialByShader(
  Shader.Find("Pro/Unity/Performance/Particles/Off-Screen")
);
Vector2 yourTexelOffset = Vector2.Scale(
  source.GetTexelOffset(), 
  Vector2(source.width, source.height)
);
Graphics.BlitMultiTap(
  yourParticlesRenderTexture, source, yourMixedMaterial,  yourTexelOffset
);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Always release the particles render texture for better performance.</p></div></div><p>You can <a id="id407" class="indexterm"/>render (after postprocessing) your <code class="literal">RenderTexture</code> to your destination as shown here:</p><div class="informalexample"><pre class="programlisting">RenderTexture.ReleaseTemporary(yourParticlesRenderTexture);
Graphics.Blit(source, destination);</pre></div></div><div class="section" title="The pool technique"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec83"/>The pool technique</h2></div></div></div><p>The next technique is a basic <a id="id408" class="indexterm"/>pooling system (as shown in Listing 3-1) for Unity in addition for Shuriken particles. Put the pool component on your GameObject and set the name and prefab. The pool summons the <code class="literal">OnCreateEvent</code> strategy on entities when they are <span class="emphasis"><em>made</em></span> in the pool (so put your initialization that typically will go in the <code class="literal">Start</code> or <code class="literal">Awake</code> callback) and an <code class="literal">OnLiberationEvent</code> system when reused items go into the pool. The <code class="literal">OnCreateEvent</code> strategy provides the pool that made the occurrence so that you can store it away and reuse your <span class="strong"><strong>GameObject</strong></span>
<a id="id409" class="indexterm"/> later:</p><div class="informalexample"><pre class="programlisting">YourPoolClass.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class YourPoolClass : MonoBehaviour
{
      private static readonly Dictionary&lt;string, YourPoolClass&gt; 
      namesOfObjects = new Dictionary&lt;string, YourPoolClass&gt;();

      public static YourPoolClass GetPoolByName(string name) { 
    return namesOfObjects[name]; 
  }

      [SerializeField]
      private string nameOfYourPool = string.Empty;

      [SerializeField]
      private Transform yourPoolPrefab = null;

      [SerializeField]
      private int initialObjectCounter = 23;

      [SerializeField]
      private bool isParentEnabled = true;

      private readonly Stack&lt;Transform&gt; yourObjectsStack = new Stack&lt;Transform&gt;();

      void Awake()
      {
    System.Diagnostics.Debug.Assert(yourPoolPrefab);
    namesOfObjects[nameOfYourPool] = this;

          for (int i = 0; i &lt; initialObjectCounter; i++)
          {
                var t = Instantiate(yourPoolPrefab) as Transform;
                AdjustingYourObject(t);
                LiberationObject(t);
          }
      }

      public Transform GetObject(Vector3 position = new Vector3())
      {
          Transform t = null;

          if (yourObjectsStack.Count &gt; 0) 
    {
                t = yourObjectsStack.Pop();
          } 
    else 
    {
                Debug.LogWarning(
        nameOfYourPool + " pool error!", this
      );
                t = Instantiate(yourPoolPrefab) as Transform;
          }

          t.position = position;
          AdjustingYourObject(t);

          return t;
      }

      private void AdjustingYourObject(Transform obj)
      {
         if (isParentEnabled)
         {
                obj.parent = transform;
          }

          obj.gameObject.SetActiveRecursively(true);
          obj.BroadcastMessage(
      "OnCreateEvent", 
      this, 
      SendMessageOptions.DontRequireReceiver
    );
      }

      public void LiberationObject(Transform obj)
      {
         obj.BroadcastMessage(
      "OnLiberationEvent", 
      this, 
      SendMessageOptions.DontRequireReceiver
    );
          obj.gameObject.SetActiveRecursively(false);
          yourObjectsStack.Push(obj);
      }
}</pre></div><p>This is how to use <a id="id410" class="indexterm"/>this pooling system:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class YourPoolExampleUsage : MonoBehaviour {
  void Start() {
    YourPoolClass pool = YourPoolClass.GetPoolByName("Bang");
    Transform obj = pool.GetObject(Vector3.zero);
  }
}</pre></div><p>In event of using a particle system with <code class="literal">YourPoolClass</code>, you should use the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

[RequireComponent(typeof(ParticleSystem))]
public class YourPoolParticleSystem : MonoBehaviour
{
    private YourPoolClass yourPoolClass;
    
    void OnCreateEvent(YourPoolClass ypc)
    {
        yourPoolClass = ypc;

        particleSystem.renderer.enabled = true;
        particleSystem.time = 0;
        particleSystem.Clear(true);
        particleSystem.Play(true);
    }

    void OnLiberationEvent()
    {
        particleSystem.Stop();
        particleSystem.time = 0;
        particleSystem.Clear(true);
        particleSystem.renderer.enabled = false;
    }

    void Update()
    {
        if (!particleSystem.IsAlive(true) &amp;&amp; particleSystem.renderer.enabled)
        {
            yourPoolClass.LiberationObject(transform);
        }
    }
}</pre></div></div></div>
<div class="section" title="The scriptable profiler tool"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec34"/>The scriptable profiler tool</h1></div></div></div><p>The fact that developers <a id="id411" class="indexterm"/>can use the Unity profiler for profiling their own code or certain pieces of code is very important. In order to display statistics information about some of your function or for some part of your code in the Unity profiler, you just need to include your code between two calls, <code class="literal">Profiler.BeginSample</code> and <code class="literal">Profiler.EndSample</code>. After that you can use the visual Unity profiler tool to search for bottlenecks and spikes in your code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>The profiler is only available in Unity Pro. In standalone games, the profiler can dump all profiling information using <code class="literal">Profiler.log</code> and <code class="literal">Profiler.enabled</code>.</p></div></div><p>To create your own tool, you can utilize the following Unity API calls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FindObjectsOfTypeAll</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">FindObjectsOfType</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GetRuntimeMemorySize</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GetMonoHeapSize</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GetMonoUsedSize</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Profiler.BeginSample</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Profiler.EndSample</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UnloadUnusedAssets</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">System.GC.GetTotalMemory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Profiler.usedHeapSize</code></li></ul></div><div class="section" title="Unity profiler tricks"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec84"/>Unity profiler tricks</h2></div></div></div><p>There is the capability to export the <a id="id412" class="indexterm"/>profiling information to a binary file, which can then be imported again later. This is empowered through scripting by means of:</p><div class="informalexample"><pre class="programlisting">  function Start () {
        Profiler.logFile = "yourName.log";

        Profiler.enableBinaryLog = true; // writes to "yourName.log.data"

        Profiler.enabled = true;
  }</pre></div><p>And reimported into the profiler:</p><div class="informalexample"><pre class="programlisting">Profiler.AddFramesFromFile ("yourName.log");</pre></div><p>The API to get to the profiler frame information into the script is uncovered in:</p><div class="informalexample"><pre class="programlisting">UnityEditorInternal.ProfilerDriver</pre></div><p>Not documented, yet totally open in the <code class="literal">UnityEditorInternal</code> namespace. Other suitable APIs:</p><div class="informalexample"><pre class="programlisting">Profiler.BeginSample("Your Label Name");
Profiler.EndSample();
Profiler.GetRuntimeMemorySize(o : Object) : int</pre></div></div><div class="section" title="Creating a simple profiler"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec85"/>Creating a simple profiler</h2></div></div></div><p>Now is the time to develop <a id="id413" class="indexterm"/>our own simple and very useful profiler tool from scratch. In the future, you will be able to use these scripts from our simple profiler for all of your projects as well as any other examples discussed in this book. Of course, you can modify all methods to meet your specific problem if you have a strong desire or if you have to do it, or you can use them all in their original form if this functionality will be enough for your tasks. First, let's look at a very simple class, which is a core class in our simple code profiler<a id="id414" class="indexterm"/> tool. In the following code you can see a very simple <code class="literal">ExampleProfilerClass</code>:</p><p>Listing 1-3. ExampleProfilerClass.cs</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class ExampleProfilerClass
{
  int counter = 0;
  
  float startedTime = 0;
  float totalTime = 0;
  float endTime = 0;
  float elapsedTime = 0;
  
  bool wasStartedFlag = false;
  
  public string indexStr;
  
  public float TotalTime {
    get { 
      return totalTime; 
    }
  }
  
  public int Counter {
    get { 
      return counter;
    }
  }
  
  public ExampleProfilerClass(string indexStr)
  {
    this.indexStr = indexStr;
  }

  void ShowError() {
    Debug.LogError("ExampleProfilerClass {START / END} ERROR: [index] = [" + indexStr + "]");  
  }
  
  public void Start() {
    if (wasStartedFlag) { 
      ShowError(); 
    }
    
    counter++;

    wasStartedFlag = true;

    startedTime = Time.realtimeSinceStartup;
  }
  
  public void End() {
    endTime = Time.realtimeSinceStartup;
    
    if (false == wasStartedFlag) { 
      ShowError(); 
    }
    
    wasStartedFlag = false;

    elapsedTime = (endTime - startedTime);

    totalTime += elapsedTime;
  }
  
  public void ClearStatistics() {
    wasStartedFlag = false;

    totalTime = 0;

    counter = 0;
  }
}</pre></div><p>You need to attach the <code class="literal">ExampleProfilerClass</code> script to one of the objects in your scene. The code is very<a id="id415" class="indexterm"/> straightforward and simple, as are all the other examples in this book. The entire code of our profiler is shown in Listing 1-4:</p><p>Listing 1-4. SimpleProfiler.cs</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections.Generic;

public class SimpleProfiler : MonoBehaviour {
  float startedTime = 0;
  float followingTime = 1;
  float totalTimeInMilliSeconds = 0;
  float averageTimeInMilliSeconds = 0;
  float framesPerSecond = 0;
  float savedTimeInMilliSeconds = 0;
  float percentageSavedFromTotal = 0;
  float timeInMilliSecondsPerFrame = 0;
  float timeInMilliSecondsPerCall = 0;
  float callsNumberPerFrame = 0;

  int frameCount = 0;
  int colWidth = 30;

  static Dictionary&lt;string, ExampleProfilerClass&gt; statistics = new Dictionary&lt;string, ExampleProfilerClass&gt;();

  string profilerInfo = "ALREADY STARTED !";

  Rect windowRect = new Rect(25, 25, 800, 300);
  
  void Awake() {
    startedTime = Time.time;
  }
  
  void OnGUI() {
    GUI.Box(windowRect,"Simple Profiler");
    GUI.Label(windowRect, profilerInfo);
  }
  
  public static void Start(string indexStr) {
    if (false == statistics.ContainsKey(indexStr)) {
      statistics[indexStr] = new ExampleProfilerClass(indexStr);
    }
    
    statistics[indexStr].Start();
  }
  
  public static void End(string indexStr) {
    statistics[indexStr].End();
  }
  
  void Update() {
    frameCount++;
    
    if (Time.time &gt; followingTime)
    {
      profilerInfo = "\n\n\n";

      totalTimeInMilliSeconds = (Time.time - startedTime) * 1000;
      averageTimeInMilliSeconds = (totalTimeInMilliSeconds / frameCount);
      framesPerSecond = (1000 / (totalTimeInMilliSeconds / frameCount));

      profilerInfo += "Frames per Second: ";
      profilerInfo += framesPerSecond.ToString("0.#") + " frames; \nAverage Frame Time: ";
      profilerInfo += averageTimeInMilliSeconds.ToString("0.#") + " ms \n\n\n";
      profilerInfo += "Time Percentages".PadRight(colWidth);
      profilerInfo += "ms per Frame".PadRight(colWidth);
      profilerInfo += "ms per Call".PadRight(colWidth);
      profilerInfo += "Calls number per Frame".PadRight(colWidth);
      profilerInfo += "NameIndex";
      profilerInfo += "\n";
      
      foreach(ExampleProfilerClass statisticsRecord in statistics.Values)
      {
        savedTimeInMilliSeconds = (statisticsRecord.TotalTime * 1000);
        percentageSavedFromTotal = (savedTimeInMilliSeconds * 100) / totalTimeInMilliSeconds;
        callsNumberPerFrame = statisticsRecord.Counter / (float)frameCount;
        timeInMilliSecondsPerCall = savedTimeInMilliSeconds / statisticsRecord.Counter;
        timeInMilliSecondsPerFrame = savedTimeInMilliSeconds / frameCount;
        
        profilerInfo += (percentageSavedFromTotal.ToString("0.000") + "%").PadRight(colWidth);
        profilerInfo += (timeInMilliSecondsPerFrame.ToString("0.000") + " ms").PadRight(colWidth);
        profilerInfo += (timeInMilliSecondsPerCall.ToString("0.0000") + " ms").PadRight(colWidth);
        profilerInfo += (callsNumberPerFrame.ToString("0.000")).PadRight(colWidth);
        profilerInfo += (statisticsRecord.indexStr);
        profilerInfo += "\n";
        
        statisticsRecord.ClearStatistics();
      }
      
      frameCount = 0;

      startedTime = Time.time;

      followingTime = Time.time + 1;
    }   
  }
}</pre></div><p>The following is a simple<a id="id416" class="indexterm"/> test code, which performs mathematical operations in a cycle. You can hang this script on any object (or on multiple objects simultaneously) in your scene, just for testing your <code class="literal">SimpleCodeProfiler</code> tool.</p><p>Listing 1-5. TestProfilerCode.cs</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class TestProfilerCode : MonoBehaviour {
  float tmpFloat;

  void Update () {
    SimpleProfiler.Start("YOUR_UNIQUE_LABEL_1");

    for (int i = 0; i &lt; 10; i++) {
      for (int degree = 0; degree &lt; 360; degree++) {
        tmpFloat = Mathf.Cos(degree * Mathf.Deg2Rad);
      }
    }

    SimpleProfiler.End("YOUR_UNIQUE_LABEL_1");

    ///////////////////////////////////////////////////

    SimpleProfiler.Start("YOUR_UNIQUE_LABEL_2");
    
    for (int i = 0; i &lt; 50; i++) {
      for (int degree = 0; degree &lt; 180; degree++) {
        tmpFloat = Mathf.Sqrt(Mathf.Cos(degree * Mathf.Deg2Rad) + Mathf.Sin(degree * Mathf.Deg2Rad));
      }
    }
    
    SimpleProfiler.End("YOUR_UNIQUE_LABEL_2");
  }
}</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we researched our choices for optimization in Unity. We first discovered different Unity performance areas. We explored the in-built Unity profiler and it's log information structure. In this chapter, we particularly discussed the Unity's profiler tool and its window parts. We discovered how to attach the profiler to different platforms and devices. At the end of this chapter, we talked about best practices that are used by many professionals. We also discovered the Unity profiler programming area and created our own very simple profiler tool.</p><p>In the bonus chapter, which is available online, I will show you how easy it is to develop the most popular game on Android Play Store (Glow Hockey has about 100,000,000–500,000,000 downloads at <a class="ulink" href="https://play.google.com/store/apps/details?id=com.natenai.glowhockey&amp;hl=en">https://play.google.com/store/apps/details?id=com.natenai.glowhockey&amp;hl=en</a>) in Unity 5 from scratch. You will see how to create a camera for any screen resolutions and any screen sizes. Also, there you will see, in practice, how easy it is to use physics. You will learn in practice how to design beautiful effects, animations, physical behaviors, and other different real-world features and techniques for your Android games and applications. You will see how to optimize your project and any other real-world projects for Android devices. Many more useful things and features will be covered in the chapter.</p></div></body></html>