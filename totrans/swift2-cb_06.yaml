- en: Chapter 6. Working with Playgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the first playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching some graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching a temperature with color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stretching an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beautifying your text with Pangrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving JSONs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our own class representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating pages in playgrounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've ever programmed with an interpreted language such as Python, Perl,
    Ruby, or JavaScript, you probably have noticed an advantage with these languages
    over native languages such as C, Objective-C, or C++, which is the possibility
    of testing a code without the need of adding an extra code to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a developer needs to test a code before adding it to the project,
    mainly when you are learning the way Swift works. But even if you are very experienced
    with Swift, there will be times when you will have new ideas and you probably
    will need to check whether this is a valid idea before coding it into your project.
  prefs: []
  type: TYPE_NORMAL
- en: For situations like the previously mentioned, Apple has released playground,
    a place where you can play with your code, test it, visualize it, and of course,
    take a decision on the code before adding it to your application.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite impressive that Swift is a compiled language, but you can use playground
    to test your code as you go, like if you were on an interpreted language, watching
    the results in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the first playground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you are going to get familiarized with the **Xcode playground**,
    here you are going to learn some basics of this Xcode feature, and after that
    you will be able to test your own code using this new friend.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your Xcode, but this time, instead of creating a new project, now you
    have to choose **Get started with playground**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have done it, you are going to see that the next dialog is a very
    simple one, which will ask only the project name and the platform (iOS, Mac OS,
    or tvOS). Call it `Chapter 6 First Playground` and select **iOS**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then you will see the famous dialog, which asks you where to store your app.
    Choose the folder that you want for it. If you have doubts, choose the documents
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start with our playground, open the **Finder** window corresponding
    to the folder where you saved your project, right-click (or control click) on
    your playground project, and choose **Show package contents**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can see that there are three files there: `contents.xcplayground`,
    `results.playgrounddata`, and `section-1.swift`. Right now, you can imagine what
    these files do but I would like to emphasize that, as your playground grows, the
    number of files also increases. Remember that playground has its own bundle in
    which you can add pictures and other stuff.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create the first playground:'
  prefs: []
  type: TYPE_NORMAL
- en: Return to your Xcode, have a look at your playground. It started importing the
    UIKit and a string variable, which says **Hello, playground**. You can also see,
    on the right-hand side, the result of this variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start defining another variable called `name`, before the `str` variable,
    and change the `str` variable to have an interpolation, something like the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you will see that on your right you have both variables processed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00052.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once you''ve understood this, let''s complete this code with an `if` statement,
    so after the previous code, add an `if` statement like this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After coding it, see to it that you have the result for one statement but not
    for the other one:![How to do it…](img/00053.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s time to try a loop, let''s calculate, for example, the famous Fibonacci
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you can appreciate the result in a different way, instead of displaying
    the variable value, you can see the number of times that the instruction was executed.
    If you move your mouse pointer over the result of each instruction, you can see
    that two small icons will appear.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first one, which is like an eye, is for watching the variable result representation,
    the other one is for the timeline, which shows the values assigned to the variable
    on each loop iteration. We will talk about this later in the recipes *Watching
    some graphics* and *Beautifying your text using Pangrams*:![How to do it…](img/00054.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason why we wrote the variable `fib_n` alone at the end of our code is
    because that is the way you can visualize the final of a variable, in this case
    we can see that the result of our code is **55**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can compare this code with the equivalent one as a recursive function,
    then we can take a decision about which code is going to be used on our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After coding it, you can check two important pieces of information; the first
    one is the result, which is the same as the previous code. The second one is the
    number of times the function was called, as you can see in this case we had 54
    times on the recursive function against 8 of the interactive function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, every time you write a code it is recompiled and executed; the
    advantage is that it gives you information about your code, you can use it to
    compare different codes, and also check whether the idea you have in mind is the
    right one for your application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you have a basic idea about how to use the playground. The next thing we
    are going to learn is how to visualize the information and its progress in a graphical
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Watching some graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing that a loop iterates 8 times instead of 54 is fine. It gives you a good
    idea about the best algorithm to choose, but there are times when we need to visualize
    the variable values during the loop iterations. For cases like this Apple has
    created the timeline.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can open your Xcode and click on **Get started with playground**, or if
    you already have your Xcode opened, you can click on the file menu, then on the
    **New** option, and then click on **Playground**.
  prefs: []
  type: TYPE_NORMAL
- en: Name your project `Chapter 6 Timeline` and save it in your workspace folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s type a code where we print some output, in this case we are going
    to print a triangle with stars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you've typed this code, you wouldn't appreciate the triangle yet. Go to
    the icon that looks like two overlapped circles and click on it:![How to do it…](img/00055.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behold the Xcode split in to two parts. The new part on the right is called
    the timeline. Now you should see the console output, which should be similar to
    the following screenshot:![How to do it…](img/00056.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If for any reason you close the console output, you can reopen it by just re-running
    your code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s see the values of a variable; in this case we don''t have many
    options, so we are going to check the value of the j variable. To do it, just
    type j after the print instruction, something like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now click on the round icon on the same level as the `j` variable:![How to do
    it…](img/00057.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can see the values of `j` according to the iteration on the following
    graphic:![How to do it…](img/00058.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to see the value of your variable more clearly, you can slide the
    red bar that is on the bottom of your Xcode screen:![How to do it…](img/00059.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If for any reason you have lots of graphs, you can close them to save space,
    but if you would like to keep some graphs, you can collapse them by double-clicking
    on their titles, and of course you can expand them just by double-clicking again:![How
    to do it…](img/00060.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, in this case you've got only the title **j // <- yes only the
    letter "j"** instead of the whole graph.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The timeline has three different editors: the Standard Editor, which gives
    us more space to code and watch our code routine; the Assistant Editor, which
    gives us more information about our code execution, and the Version Editor, which
    shows us the modifications that our playground has.'
  prefs: []
  type: TYPE_NORMAL
- en: The Assistant Editor gives us more accuracy about the variables evolution and
    their values. Using a graph helps us to know how a variable is changing its value.
  prefs: []
  type: TYPE_NORMAL
- en: The console output is also important; pay attention that if you try to visualize
    the print instruction only, you are going to see lots of stars, each of them on
    a different line. This kind of information is not useful for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playground isn't limited to displaying graphics only; you can also add some
    colors to it. In the next recipe, you are going to work with colors on your playground.
  prefs: []
  type: TYPE_NORMAL
- en: Watching a temperature with color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Xerox engineers created the window system based on Smalltalk, they brought
    a big concept to the computer world, the idea of analog representation on digital
    devices (computer).
  prefs: []
  type: TYPE_NORMAL
- en: It means that for us human beings, it is easier to understand how long a process
    will take watching a progress bar instead of by watching a percentage on a screen.
    Here we are going to watch some colors instead of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to watch the color of a temperature instead of
    watching its value; this way you can have a better idea about the chill.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Xcode and create a new playground called `Chapter 6 Color`, remove
    the `str` string but leave the UIKit import.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let''s make an array with temperatures, in this case the temperatures
    are measured in degrees celsius:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is iterating over the array. For each iteration, we are going
    to store the result into a variable called color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you have to add the color variable from the last loop sentence to the timeline;
    you can see a result similar to the following one:![How to do it…](img/00061.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Timeline is not only about displaying numbers, it's also about giving us information
    where we could have a better idea about the code. Watching numbers such as 13
    degrees Celsius is something that doesn't give us a good idea of temperature,
    but watching a color can give us a better idea if it is cold or hot, mainly if
    you work with Fahrenheit values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, your computer screen works with three primary colors: red, green
    and blue. UIColor also has a fourth factor, which is the alpha factor, zero means
    transparent and one means opaque.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we kept alpha as one and green as zero in every case, but for
    cold days we assumed that we need a high level of blue and a low level of red.
    For warm days we had to create a color with a high level of red and low level
    of blue. This means that a very blue color is saying that we had a very low temperature,
    and a very red color means a very high temperature.
  prefs: []
  type: TYPE_NORMAL
- en: What about the intermediate temperature? In this case, we will have a purple
    color, which is the color created with 50% red and 50% blue.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look that this kind of measure is more useful using playgrounds rather
    than using it on an app. Presumably, in a real app you won't store a color, you
    would store the real temperature, but you can get an idea if the values you have
    are to your liking or not before coding it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, we used the colors for getting a better idea about our values,
    but what else can we use? In the next recipe, you are going to learn how to use
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Stretching an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it's necessary to have more than one sample of a picture to see which
    ratio is the desired one. Let's imagine that we have a message, but we don't want
    to show it to the user, we only want to show something that gives him an idea
    that there is something, and the application is going to show the correct ratio
    later.
  prefs: []
  type: TYPE_NORMAL
- en: For cases like this, you can use `UIImage` and `ImageView`, and visualize it
    on the playground.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new playground called `Chapter 6 Stretching Image` and also have an
    image ready for this recipe, I would recommend to download the image `secret_message.png`,
    which is included in the resources files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Close the Xcode and open a **Finder** window, go to the folder where you saved
    the playground, click on the project that you created, and right-click (or control
    click) on it. In the menu, choose the option **Show Package Contents** as we learned
    in the beginning of this chapter:![How to do it…](img/00062.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a folder called `Resources` and copy your image file into it. After
    that, reopen your playground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the `str` variable because we are not going to use it. Let''s create
    a new class where we have a `ImageView`, its size, and the number of times that
    the `ImageView` was stretched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you''ve coded it, we need to create an object of this type, so add the
    following to your playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good, now you have an object but the image is still in its original size. If
    you call the `stretch` method, you are going to see the image stretched only once,
    so let''s repeat this to get a better idea about how much we should stretch the
    picture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For visualizing the different results, you can click on the value history icon,
    and then you can see lots of samples.![How to do it…](img/00063.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For having a better idea of the `ImageView`, you can click on the right-hand
    side of the sample row, where there is an eye icon. Click on the number **10**
    for example, and see what you've got:![How to do it…](img/00064.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views are allowed to be used on the playground; you can pre-visualize for example,
    how your `UIImageView`, `UILabel`, `UITextField,` and so on will be drawn. In
    this case, we had to repeat it a few times; it means that only the `ImageView`
    wouldn't give us the complete information.
  prefs: []
  type: TYPE_NORMAL
- en: The best way is by creating our own class and storing the information we need,
    such as how many times we've stretched the `ImageView` and the current size of
    the `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side of the result, as you can see there is a small eye icon
    (quick look), it will show you how the view was at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's very common to work with a framework called **CoreImage** when you want
    to user a filter on an image (like hiding a secret message), unfortunately this
    framework doesn't work with playground yet.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to store information with your playground, you probably want to
    print the constant `XCPSharedDataDirectoryPath`. It will show you where the playground
    stores this information.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we would like to hide a message and sometimes we would like to make
    it more readable. In the next recipe, we are going to learn how you can pre-visualize
    a text with different fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Beautifying your text using Pangrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever seen the phrase "The quick brown fox jumps over the lazy dog"?
    Why is it so famous? The reason is that it is an English Pangram; it means a phrase
    with every letter from the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: Pangrams are useful when you want to visualize properties of a font, such as
    size, color, or boldness. In this recipe, we are going to check different fonts,
    using `NSAttributedString` and playground.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new playground called `Chapter 6 Text` and remove the string that comes
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create our attributed string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that you will see a new icon with the letter **a** appearing. It means
    that the playground has recognized it as an attributed string. Click on the Quick
    Look icon and you will see the current string with its attributes:![How to do
    it…](img/00065.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s choose some font sizes and colors for our text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we also would like to choose a few different fonts, we need to create another
    array; however, it can''t be a simple array of strings because we are going to
    call different methods. So we will need to create an array of closures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we''ve done it, we have our playground ready to execute the main part.
    To do it, let''s create three nested loops, each of which will iterate over one
    of our arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you prefer, instead of using `for` loops, you can use a more swift way of
    iterating over an array, using the `map` closure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It doesn't matter which procedure you've chosen, click on the value history
    of the line that only contains the word `string`. Now you can appreciate the samples
    of the attributed string.![How to do it…](img/00066.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributed strings are accepted by playground, and this procedure is very useful
    when you have to choose a configuration for your app without running the full
    application.
  prefs: []
  type: TYPE_NORMAL
- en: If we were using Objective-C instead of Swift we probably would have created
    an array of selectors rather than blocks. However, Swift doesn't follow this philosophy
    anymore, and the function `performSelector` now asks for a delay time to start.
  prefs: []
  type: TYPE_NORMAL
- en: Using blocks or closures is more flexible and it also makes the code easier
    to maintain. One limitation that you can see here is that you can't copy the array
    of functions from the quick look. Better saying, you can do it, but the only text
    that you are going to copy is Function, which is not very useful.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we had our own text, but what if we need some text from a remote server?
    In the next recipes, we are going to learn how to treat HTTP requests on playground.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving JSONs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asking for remote information is something very common today. What happens if
    your playground finishes before you receive a server response? In this recipe,
    we are going to learn how to deal with this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new playground called `Chapter 6 Requesting JSONs`, and just in case,
    check your Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to locate a URL, which can return us more websites. In this
    case we are going to use this URL: [https://api.github.com/users/mralexgray/repos](https://api.github.com/users/mralexgray/repos).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a constant with the URL mentioned previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the quick look icon and check that you have received a JSON response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the quick look with NSURL for checking websites. If you are testing
    something that is modifying a website, you can use quick look to check the new
    website look.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s create a request for our URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is requesting the content of the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the playground result. Unfortunately, the playground finished before
    we got the response. Go to the beginning of your playground and add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will be able to receive a response, however as you can see, the response
    isn''t the one we were waiting for. Fixing this issue will require us to implement
    a new class and set it as `NSURLConnectionDelegate`. Place this code before sending
    your asynchronous request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `total` variable will be used afterwards, now the only thing you need to
    do is check that we could receive the response as we expected. Only one request
    might not be enough to do a benchmark, in which case we need to go to the line
    where we are inspecting the `data` argument and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Good, now as you can see we have a more acceptable result. If you'd like to
    get a better result for your benchmarking, reduce the running time of your playground
    by changing the number of seconds, located at the lower-right-hand corner to **3**
    seconds.![How to do it…](img/00067.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now check how many times you received a response, that's your real statistic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playground has its own framework called `XCPlayground`. It was created to add
    some features to your playground according to your test needs. In this case we
    started using the function `XCPSetExecutionShouldContinueIndefinitely`, which
    keeps playground running even if it has reached the last code line.
  prefs: []
  type: TYPE_NORMAL
- en: The `XCPlayground` framework also helped us with the `XCPCaptureValue` function.
    This function allows us to store a value from different parts of our code and
    create a single graph for it, as we did with the `total` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We also had to fix an issue about the connection, which was being denied by
    the HTTPS protocol. In this case, we tried to create the connection and we could
    see that it was being rejected, that's a good reason for using playground before
    coding into your app, so we can solve this issue much faster.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we could change the execution limit time of our playground, by default
    it starts with 30 seconds but it might be too much for cases like this. Reducing
    this time allowed us to get a better idea about how many requests our app is able
    to do in a second.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, playground has its own framework. It allows us to control and
    get better results from playground. To complete it, in the next recipe we are
    going to learn how to create personalized quick looks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own class representations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quick look is a good tool that helps us to visualize the current status of an
    object, but sometimes when we create our own class with its own logic, quick look
    won't be able to draw something that represents the object without your help.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to create our own class representation,
    and to do it we are going to create a class that represents a checkers board.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new playground called `Chapter 6 Checkers` with the iOS option selected.
    If you select Mac OS, remember to import Cocoa and replace some types with the
    equivalent ones, such as `NSBezierPath` instead of `UIBezierPath`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start creating a class that inherits from `NSObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we go any further, we need to define the status of each square; as you
    know it could have a black piece, a white piece, or it could be empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s define the board. In this case, it''s a two-dimensional array attribute,
    and the initial value of each square must be `.FREE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we never know whether the board has the right size, we are going to create
    a constant that represents the size of a square. You can change this value if
    you think the board is too big or too small:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is creating a method called `debugQuickLookObject`. It is not
    a random name, it must be called like that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `debugQuickLookObject` method in your application, Swift and Objective-C
    debuggers also use this method to give you an idea of your object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start creating an image context with the size of the checkers board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two loops that will draw each square of the board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside these loops, we need to calculate where the current position is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we need to know whether we are going to draw a black square or
    a white one. To do it, the `row` and `col` variables will help us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, fill the square with the current color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have painted the square, we are going to draw a circle that represents
    a player piece:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The loops are done, we can now finish them, return the image, and finish the
    board class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you may imagine, we need to test our class by instantiating it, adding some
    pieces to the board, and visualizing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now click on Quick Look of the board (last line) and you should see a result
    like the following one:![How to do it…](img/00068.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For displaying a custom Quick Look, you have to create a class that inherits
    from `NSObject` and implements the method `debugQuickLookObject`. Although this
    method returns an object of type `AnyObject`, on its declaration, it should return
    anything that could be represented by playground, such as colors, bezier paths,
    views, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used a bezier path, which has a different coordinate system
    from the traditional views. Bezier paths have the initial point (`x = 0` and `y
    = 0`) on the lower-left-hand corner. It didn't affect us because we used only
    squares and circles, but bear this problem in mind, because you can get wrong
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '`UIColor` has some methods that indicate the color that should be used in the
    current context for filling a shape (`setFill`), and to draw the border of it
    (`setStroke`). These colors are going to be applied when you call the corresponding
    action to use them, such as `bezier.fill()`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we need to indicate that we want to show a view on our playground,
    to do that we have a function called `XCPShowView`, so it's another way to visualize
    an object. In the next chapter, we are going to learn how to debug our app; it
    is very useful when we have too much code and we are not able to test it on the
    playground.
  prefs: []
  type: TYPE_NORMAL
- en: Rich documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing clean and concise documentation will result in direct insight into
    the structure and functionality of your code. This greatly benefits collaborators
    who work with your code, as well as yourself when revisiting previous code you
    have worked on. Additionally, Xcode can leverage this documentation and provide
    instant quick look information anywhere your code is used, keeping you from having
    to switch between multiple files for reference.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will take a generic class declaration and document its methods
    and properties using the new documentation syntax in Xcode 7 with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new playground and name it `Documentation`. This recipe will not require
    a project file so do not worry about any project settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the following code into your playground as our starting point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, this class contains a couple of variables and two methods; one
    with parameters and a return value, and another without either.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To start, let''s add documentation to the class itself. Add the following code
    above the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`///` represents a single line comment. This is convenient for documentation
    that does not require any parameters or return values. Xcode will recognize `///`
    and parse the information for quick look access.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test it out, option click on `SomeSimpleClass` and you should see the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00069.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the following code to the line just above the `doSomething()` method and
    option click to verify it is working properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have covered the single line documentation, let''s add documentation
    to the `doSomethingWithStuff()` method. Add the following code just above the
    method declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For multiline documentation, we want to place all documentation between `/**
    */`. Xcode will parse these lines accordingly for quick look. Additionally, we
    are able to explicitly define both parameters and return type. Option click on
    the `doSomethingWithStuff()` method to see the following Quick Look view:![How
    to do it…](img/00070.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the code block in the previous step to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When dealing with multiple parameters, it is good practice (and easier to read)
    to specify the parameter's section rather than each individual parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Swift also allows for additional description fields. Add the following code
    to the `doSomethingWithStuff()` documentation block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00071.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an extensive list of available fields, visit the Apple documentation found
    here: [https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Xcode also allows headers, formatting, and ordered/unordered lists. Add the
    following code to the documentation block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Xcode supports three headings: `#` represents heading 1; `##` and `###` represent
    heading two and three respectively:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00072.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xcode will automatically parse the added documentation and organize it according
    to the keywords used in the documentation block. This requires no additional settings
    and will work on anyone's computer running Xcode 7.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes documentation may need to be formatted similarly to an instruction
    manual, with multiple pages for better organization. With the power of playgrounds,
    you can provide detailed documentation with multiple pages and link between them
    for easy access. This will be covered in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating pages in playgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playgrounds are proving to be more and more powerful, as Apple continues to
    add functionality. One great new feature is the ability to navigate through pages
    in a single playground. Doing so allows you to format your documentation in a
    more organized way. Additionally, you can even structure your documentation and
    code similarly to a digital book and allow readers to navigate with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new playground and name it `Paging`. This recipe will not require
    a project file so do not worry about any project settings. Next, select **File**
    | **New** | **Playground** **Page**. In the navigator on the right, you should
    see two pages: `Untitled Page` and `Untitled Page 2`. Rename these `Intro` and
    `Start Now` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code to the bottom of the Intro page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Xcode will recognize `//:` as a markup command similar to `///`. The navigation
    between pages uses a standard format of `[Link Title](location to link to)`. In
    this instance, we name the link `Next`, and use the standard `@next` option to
    let Xcode know to navigate to the next page (based on project order).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Editor** | **Show Rendered Markup** from the top menu. In order to
    view our navigation, we will need Xcode to render it based on the supplied markup.
    You should see something similar to this:![How to do it…](img/00073.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting the next button will automatically bring you to the `Start` page previously
    created. You will notice the boilerplate code for a new page automatically produces
    its own previous and next links. Select **Editor** | **Show Raw Markup** to see
    the code. Everything is identical, with the exception of using `@previous` as
    the link location for the previous link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate back to the `Intro` page and add the following code to the end of
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By specifying the name of a page as the location, we can navigate directly to
    the specified page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that page names with spaces require the `%20` ASCII space code to work
    properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like all other documentation and markup, Xcode will automatically parse the
    text into the proper commands and link everything properly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although we covered all of the basics, there are still additional features
    provided by Apple for dealing with documentation and playgrounds. For more information,
    visit this link: [https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
