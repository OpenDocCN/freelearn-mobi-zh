- en: Chapter 11. Graphics and Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines and curves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple drawing app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to discuss custom drawing and animations. The
    iOS SDK contains two very useful frameworks for these tasks: Core Graphics and
    Core Animation.'
  prefs: []
  type: TYPE_NORMAL
- en: These two frameworks simplify the process of animating UI elements and drawing
    2D graphics on them. The effective usage of these two frameworks will make a difference
    between a dull and stunning app. After all, these two frameworks play a very important
    role in making the iOS platform unique in its kind.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to provide simple or even more complicated animations for
    controls to provide a unique user experience. We will also see how to custom draw
    lines, curves, shapes, and text on the screen. Finally, with all the examples
    provided, we will create two drawing apps.
  prefs: []
  type: TYPE_NORMAL
- en: Animating views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to take advantage of UIKit animations to move
    a `UILabel` on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `ViewAnimationApp`.
    Add a label and button on the view of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap on the **Animate!** button and
    watch the label transitioning to the lower part of the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIView` class contains a number of various static methods that provide
    animation functionality. In this example, we simply change the position of a label
    with an animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To animate the change of the view, we call the static `UIView.Animate` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list explains the parameters of the `UIView.Animate` method,
    individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Duration**: This specifies the duration of the animation in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delay**: This indicates the number of seconds before the animation starts.
    Set it to zero for the animation to start immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**: This includes the various options for animation. In this example,
    we pass `UIViewAnimationOptions.CurveEaseInOut`, which applies an easing curve
    to the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation**: This is an `NSAction` delegate with the changes that will be
    animated. In this example, we set the modified frame to the label as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Completion**: This is an `NSAction` delegate, which will be called after
    the animation is complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can combine multiple `UIViewAnimationOptions` values. For example, if we
    wanted the animation to repeat indefinitely, we would pass `UIViewAnimationOptions.CurveEaseInOut
    | UIViewAnimationOptions.Repeat`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Xamarin.iOS also offers an asynchronous method for `UIView` animations. This
    method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, there are no `delay` and `options` parameters with the asynchronous
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Animatable properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UIKit animations support a specific set of `UIView` properties. These properties
    are called **animatable** properties. Following is a list of `UIView` properties
    that can be animated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Frame`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bounds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Center`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Transform`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Alpha`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BackgroundColor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContentStretch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will rotate a `UILabel` by applying a transformation. Furthermore,
    the rotation will be animated.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `TransformViewApp`.
    Add a label and a button on the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `MonoTouch.CoreGraphics` namespace in the `TransformViewAppViewController.cs`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following `ViewDidLoad` method in the `TransformViewAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap the button and watch the label
    rotate. The following screenshot displays that the label rotated 270 degrees:![How
    to do it...](img/8924OT_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.CoreGraphics` namespace is a wrapper around the `CoreGraphics`
    framework. This framework is the basic graphics framework of iOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To rotate a view, we need a transformation object that will be applied to the
    view through its `Transform` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The transformation object is an instance of the `CGAffineTransform` class and
    is initialized through the `MakeRotation` static method. This method accepts a
    float value of the angle of rotation we want to be applied, in radians. The `DegreesToRadians`
    method can be used to convert degrees to radians. After creating the transformation
    object, we assign it to the label''s `Transform` property inside the animation
    handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to increment the rotation angle each time the button is pressed,
    because the transformation we apply is not being autoincremented. If we apply
    another rotational transformation object with the same angle, there will be no
    effect since it is basically the same transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the label has been rotated to a full circle (360 degrees), we reset the
    `rotationAngle` value and the transformation object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `MakeIdentity` static method creates an identity transformation object,
    which is the default transformation of all views, before applying transformation
    objects to them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CGAffineTransform` class contains various static methods for creating
    transformation objects. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CGAffineTransformInvert`: This inverts a current transformation and returns
    the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeIdentity`: This creates an identity transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeRotation`: This creates a rotation transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeScale`: This creates a scaling transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeTranslation`: This creates a translation transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Multiply`: This multiplies two transformations and returns the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation and Frame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After applying transformations on a view, its `Frame` property must not be taken
    into account, as its value will be undefined. If there is a need for altering
    the view's size or position after a transformation has been applied, use the `Bounds`
    and `Center` properties, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Animating views* and *Animating layers* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a simple slideshow of images using the built-in
    animation feature of `UIImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `ImageAnimationApp`.
    Add a `UIImageView` and two buttons on the controller. The sample project for
    this task contains three images. Add two or more images to the project and make
    sure that their **Build Action** is set to **Content**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap the **Start animating** button
    to start the animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIImageView` class can accept an array of `UIImage` objects and automatically
    display them in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the images that the view will animate, assign an array of the images
    to its `AnimationImages` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The sequence in which the images will be displayed is defined by their order
    in the array. After setting the images that will be animated, we set the duration
    of the animation in seconds and the number of times it will occur as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To start or stop the animation, call the `StartAnimating` or `StopAnimating`
    methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no relation between the `AnimationImages` and `Image` properties of
    the `UIImageView` class. The image set to the `Image` property of the `UIImageView`
    class will not be displayed while the animation takes place.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To determine if an animation is taking place, check the `IsAnimating` property
    of `UIImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Animating views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Displaying images* recipe in [Chapter 2](ch02.html "Chapter 2. User Interface
    – Views"), *User Interface – Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the Core Animation framework to copy
    a `UILabel` on the screen by animating its layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `LayerAnimation`.
    Add two labels and a button on the controller. Set the text and background color
    for the first label and a different background color for the second label.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `MonoTouch.CoreAnimation` namespace in the `LayerAnimationViewController.cs`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a field of the `CALayer` type in the class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap the **Copy label** button to copy
    the contents of the first label to the second label, with animation. The following
    screenshot was captured while the process of copying was taking place:![How to
    do it...](img/8924OT_11_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.CoreAnimation` namespace is a wrapper around the Core Animation
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Every view has a `Layer` property, which returns the view's `CALayer` object.
    In this task, we are creating an animation that graphically displays the contents
    of the label that are being copied from one label to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating another label and moving it with a `UIView` animation,
    we will create a layer and move that instead. We create the layer by setting its
    `Frame` and `Contents` property; the latter is set from the source label''s layer.
    We then add the layer to the main view''s layer with the `AddSublayer` method.
    After this point, the main view contains a layer that displays the same contents
    and is on top of the source label. We will do all this with the help of the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To animate the transition from the source label to the target label, we will
    use the `CABasicAnimation` class. The highlighted part of the code in step 3 shows
    how to initialize and set up the instances of the class. The `FromKeyPath` static
    method creates a new instance, accepting the name of the layer's property as a
    parameter; this name will be animated. The `To` property represents the value
    to which the property will be animated. The `Duration` property represents the
    duration of the animation in seconds, while the `RemovedOnCompletion` property
    declares that the animation object should be removed from the layer when the animation
    finishes. The `TimingFunction` property sets the behavior of the animation. The
    `AnimationStopped` event is triggered when the animation finishes. Inside the
    handler we assign to it, we set the contents of the source label to the target
    label, thus completing the copy. The `AutoReverses` property states that when
    the value of the `To` property has been reached, the animation should be reversed.
    It is this property that gives the effect of the label getting bigger and subsequently
    smaller when it reaches its final position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animations start when they are added to the layer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A list of strings that the `FromKeyPath` method accepts can be found at [https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the `To` property, the `CABasicAnimation` class has two more properties
    for defining the animation: `From` and `By`. They are all of the `NSObject` type,
    but the actual values that should be assigned to them should be of the `NSValue`
    type. The `NSValue` class contains various static methods for creating instances
    of it.'
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Layers are very powerful and efficient objects that can be used for both drawing
    and animations. Using layers to perform animations on views, instead of the actual
    views themselves, is strongly suggested.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Animating views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines and curves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will implement custom drawing to draw two lines on a `UIView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `DrawLineApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class to the project and name it `DrawingView`. Derive it from `UIView`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `using` directives in the `DrawingView.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following constructor to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `Draw` method of `UIView` and implement it with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` override of `DrawLineAppViewController`, initialize and
    add the view as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. The result should be similar to the
    one shown in the following screenshot:![How to do it...](img/8924OT_11_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.CoreGraphics` namespace is a wrapper around the native Core Graphics
    framework. The Core Graphics framework contains the necessary objects for custom
    drawing on views.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw on a view, we have to override its `Draw(RectangleF)` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Draw` method, we need an instance of the current graphics context
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A graphics context is represented by the `CGContext` class. The `UIGraphics.GetCurrentContext`
    static method returns an instance of the current context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CGContext` class contains various methods that allow us to draw on the
    view. We need to set the line width, the color, and then add the type of drawing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a line, we use the `AddLines` method that accepts an array of `PointF`
    structs, containing the start and end points of each line. Just adding the lines
    to the context is not enough. To present the drawing on the view, we call the
    `StrokePath` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To add another item to the drawing, we repeat the steps accordingly. The `MoveTo`
    method moves the current point so that the additional item will have a starting
    point for the curve.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Draw` method is being called by the runtime when it needs to draw the contents
    of a view. We can only get the instance of the current graphics context inside
    the `Draw` method. We should not call it directly, since the `UIGraphics.GetCurrentContext`
    method will return `null` if we do. If we need to force the runtime to call the
    `Draw` method, we need to call `SetNeedsDisplay()`. Care should be taken when
    calling it, since drawing operations are expensive in terms of CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: When there is no need for causing the entire view area to be redrawn, we can
    call the `SetNeedsDisplayInRect` method, passing a `RectangleF` object in the
    coordinate system of the view area that we want to update.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics context on a UIImageView class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current graphics context of a `UIImageView` object is reserved for drawing
    the contents of the image. Calling `SetNeedsDisplay` on a custom view deriving
    from `UIImageView` has the same effect as calling the `Draw` method directly.
    If we need to draw on a custom image view, we have to either add another view
    on top of it and draw on that or draw on a custom layer and add it to the view's
    main layer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Drawing text* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a custom view* recipe in [Chapter 2](ch02.html "Chapter 2. User
    Interface – Views"), *User Interfaces – Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the example from the previous recipe, we will draw a circle and square
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `DrawShapeApp`.
    Add a custom view to the project, like we did in the previous task, and name it
    `DrawingView`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Override the `Draw` method of the `DrawingView` class and implement it with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` method of the `DrawShapeAppViewController` class, initialize
    and display the view with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. The result on the screen should be
    similar to the one shown in the following screenshot:![How to do it...](img/8924OT_11_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To draw shapes on a view, we need to call the appropriate method. We first
    set the fill color of the `CGContext` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw a circle, we call the `AddEllipseInRect` method, passing a `RectangleF`
    object that contains the bounding rectangle of the circle as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether the shape will be an ellipse or an absolute circle is defined through
    the bounding rectangle''s size. We then call the `FillPath` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The shadow effect is defined by the `SetShadow` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, which is of the `SizeF` type, defines the offset of the
    shadow, while the second parameter defines the amount of blur, in points.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `SetShadow` method is called, all objects that are added to the context
    are displayed with a shadow. To remove the shadow, call the `SetShadowWithColor`
    method, passing either a fully transparent color or null for the color parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To fill a shape with a transparent color, create a `CGColor` instance with
    the appropriate values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will create a red color with its alpha value set to 50 percent.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Drawing lines and curves* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to draw styled text with an outline on a view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `DrawTextApp`.
    Add a custom view to the project, similar to the one we created in the previous
    recipe, and name it `DrawingView`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the following `Draw` method override in the `DrawingView` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` method of the controller, initialize and display the `DrawingView`
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. The text will be displayed on the
    screen. The result should be similar to the following screenshot:![How to do it...](img/8924OT_11_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NSString` class contains the very useful `DrawString` method, which draws
    the text it contains to the current context. To provide the outline effect, we
    call the `SetTextDrawingMode` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the `CGTextDrawingMode.Stroke` value. We then set the color and width
    of the outline to the graphics context and draw it text on the screen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `SetStrokeColorWithColor` method sets the color of the stroke, and the `SetLineWidth`
    method sets the width of the stroke. Calling the `DrawString` method of `NSString`
    draws the text in the graphics context in the specified location and with the
    specified font.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to fill the text, we set the text drawing mode to `Fill` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For the fill, we are not concerned about the line''s width, so we just need
    to call the `DrawString` method once more as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `DrawString` method is overloaded. The overload we use here accepts a `PointF`
    struct, which represents the location of the string in the view's coordinate system
    and a `UIFont` instance that represents the font by which the text will be rendered
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing text on the screen with the `DrawString` method is very simple and the
    quickest way to do it. For more complex functionality, such as customizing the
    layout of the text, its appearance, and many more, we need to use the **CoreText
    framework**. This is accessible in Xamarin.iOS through the `MonoTouch.CoreText`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Size of the drawn text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `DrawString` method of the `NSString` class returns the size of the bounding
    rectangle of the text. We can, however, get the size of the text before drawing
    it through the `StringSize` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Drawing lines and curves* and *Drawing shapes* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple drawing app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the techniques we learned to create a drawing app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `FingerDrawingApp`.
    Once again, we will need a custom view. Add a class deriving from `UIView` and
    name it `CanvasView`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `CanvasView` class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` method of the `FingerDrawingAppViewController` class,
    initialize and show the canvas as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator or on the device. Touch-and-drag your
    finger (or click-and-drag with the cursor) and start drawing. The following screenshot
    displays a sketch drawn in this app:![How to do it...](img/8924OT_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we are combining touch events and custom drawing to create a simple
    drawing app. When the user touches and moves the finger on the screen, we keep
    the information of the touch location points and use them in the `Draw` method
    to draw lines.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the touch locations to the class fields, we call `SetNeedsDisplay`
    to force the `Draw` method to be called. The `fingerDraw` variable is used to
    determine that the `Draw` method was called by a touch on the screen and not by
    the runtime when the view is first loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we call a method to draw something to a graphics context, the previous
    drawings in this context are cleared. To avoid this behavior, we use a `CGPath`
    object. We can add various drawing objects in `CGPath` and display these object
    on the screen by adding it to the graphics context. So, every time the user moves
    their finger on the screen, the new lines defined by the touch location points
    are added to the path, and the path is drawn on the current context.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we need to hold information of both the current touch location and
    the previous one. This is because the `AddLineToPoint` method accepts one point,
    which defines the end point of the line, assuming that there already is a point
    in the path. The starting point of each line is defined by calling `MoveToPoint`,
    passing the previous touch location point.
  prefs: []
  type: TYPE_NORMAL
- en: The path that is drawn on the screen by sliding the finger on it is basically
    comprised of a series of consecutive straight lines. The result, however, is a
    smooth path that follows the finger movement, because the `TouchesMoved` method
    is triggered every time there is a single movement of the finger on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the line to the path, we add it to the context and draw it in
    the graphics context, hence showing it on the screen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two new `CGContext` methods are introduced in this task: `SetLineJoin` and
    `SetLineCap`. The `SetLineJoin` method sets how each line will be joined to the
    previous one, while the `SetLineCap` method sets the appearance of the endpoint
    of a line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values that they accept are explained in the following two tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SetLineJoin | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CGLineJoin.Miter` | Joins two lines with an angled corner |'
  prefs: []
  type: TYPE_TB
- en: '| `CGLineJoin.Round` | Joins two lines with a rounded end |'
  prefs: []
  type: TYPE_TB
- en: '| `CGLineJoin.Bevel` | Joins two lines with a squared end |'
  prefs: []
  type: TYPE_TB
- en: '| SetLineCap | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CGLineCap.Butt` | The line will end with a squared edge on the endpoint
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CGLineCap.Round` | The line will end with a rounded edge that expands beyond
    the endpoint |'
  prefs: []
  type: TYPE_TB
- en: '| `CGLineCap.Square` | The line will end with a squared edge that expands beyond
    the endpoint |'
  prefs: []
  type: TYPE_TB
- en: Clear the drawing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To clear the drawing, we simply have to set the `fingerDraw` variable to `false`
    and call `SetNeedsDisplay`. This way, the `Draw` method will be called without
    our custom drawing code, clearing the current context.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Drawing lines and curves*, *Drawing shapes*, and *Drawing text* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will extend the finger-drawing app we created earlier by
    providing a save functionality for the drawings that the user will create.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `ImageContextApp`.
    Add the `CanvasView` class we created in the earlier task to the project. Don't
    forget to change the namespace in the `CanvasView.cs` file to correspond to the
    namespace of the new project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following methods in the `CanvasView` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add two buttons on the view of the controller. One button will be used for saving
    the drawing and the other one for clearing the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `ViewDidLoad` method of the `ImageContextAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Draw something on the canvas and tap
    the **Save drawing** button to save your drawing. Tap on the **Clear canvas**
    button to clear the canvas. You can then check the simulator's photo albums for
    your drawing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `UIGraphics` class, we can create an image context through which we
    can retrieve our drawing in a `UIImage` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an image context, we call the `BeginImageContext` static method inside
    the `GetDrawingImage` method, passing the size that we want the image context
    to have, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The current context is now the image context we created with the `BeginImageContext`
    call. We then repeat the code we have in the `Draw` method; only this time, there
    is no need to add new lines to the path. We simply add the path that we already
    have to the context and draw it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the path, we get the context image by calling the `GetImageFromCurrentContext`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to end the image context block and return the `UIImage` object
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To clear the drawing from the screen, we simply have to set the `fingerDraw`
    variable to `false` and dispose and prepare our `CGPath` object for reuse inside
    the `ClearDrawing` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To reflect the clearing on the screen immediately, we call the `SetNeedsDisplay`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot create an image context inside the `Draw` method. This is because
    when we call the `BeginImageContext` method, a context is actually created, but
    the view's default context remains as the current context. Hence, the `GetImageFromCurrentImageContext`
    method would return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on UIImageView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The technique discussed here can be used to draw on custom `UIImageView` objects.
    To display the drawing when the finger slides on the screen, we would simply have
    to set its `Image` property to the image we get from the image context.
  prefs: []
  type: TYPE_NORMAL
- en: Background on saved drawings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that although we are setting the `CanvasView` background to
    gray, the saved drawings are with a white background. This is because the view's
    background color is not included in the drawing. To include it, we would just
    have to draw a rectangle to the graphics context. This rectangle should be of
    the same color as the background color.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Drawing lines and curves*, *Drawing shapes*, *Drawing text*, and *A simple
    drawing app* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
