<html><head></head><body>
  <div id="_idContainer082">
    <h1 class="chapterNumber">14</h1>
    <h1 id="_idParaDest-240" class="chapterTitle">Working with Closures</h1>
    <p class="normal">Today, most major programming languages have functionalities similar to those of closures in Swift. Some of these implementations are really hard to use (Objective-C blocks), while others are easy (Java lambdas and C# delegates). I have found that the functionality that closures provide is especially useful when developing frameworks. I have also used them extensively when communicating with remote services over a network connection. While blocks in Objective-C are incredibly useful, the syntax used to declare a block is absolutely horrible. Luckily, when Apple was developing the Swift language, they made the syntax of closures much easier to use and understand.</p>
    <p class="normal">In this chapter, we will cover the following topics: </p>
    <ul>
      <li class="bullet">What are closures?</li>
      <li class="bullet">How to create a closure</li>
      <li class="bullet">How to use a closure</li>
      <li class="bullet">What are some examples of useful closures?</li>
      <li class="bullet">How to avoid strong reference cycles within closures</li>
    </ul>
    <h1 id="_idParaDest-241" class="title">An introduction to closures</h1>
    <p class="normal">Closures are self-contained blocks of code that can be passed around and used throughout <a id="_idIndexMarker562"/>our application. We can think of the <code class="Code-In-Text--PACKT-">Int</code> type as a type that contains an integer, and the <code class="Code-In-Text--PACKT-">String</code> type as a type that contains a string. In this context, a closure can be thought of as a type that contains a block of code. This means that we can assign closures to a variable, pass them as arguments to functions, and return them from a function.</p>
    <p class="normal">Closures can capture and store references to any variable or constant from the context in which they were defined. This is known as closing over the variables or constants and, for the most part, Swift will handle the memory management for us. The only exception is in creating a strong reference cycle, and we will look at how to resolve this in the <em class="italic">Creating strong reference cycles with closures</em> section of <em class="chapterRef">Chapter 18</em>, <em class="italic">Memory Management</em>.</p>
    <p class="normal">Closures in Swift are similar to blocks in Objective-C; however, closures in Swift are a lot easier to use and understand. Let's look at the syntax used to define a closure in Swift:</p>
    <pre class="programlisting code"><code class="hljs-code">{
(&lt;#parameters#&gt;) -&gt; &lt;#<span class="hljs-keyword">return</span>-type#&gt; <span class="hljs-keyword">in</span> &lt;#statements#&gt;
}
</code></pre>
    <p class="normal">The syntax used to create a closure looks very similar to the syntax we use to create functions, and in Swift, global and nested functions are closures. The biggest difference in the format between closures and functions is the <code class="Code-In-Text--PACKT-">in</code> keyword. The <code class="Code-In-Text--PACKT-">in</code> keyword is used in place of <a id="_idIndexMarker563"/>curly brackets to separate the definition of the closure's parameter and return types from the body of the closure.</p>
    <p class="normal">There are many uses for closures, and we will go over a number of them later in this chapter, but first, we need to understand the basics of closures. Let's start by looking at some very basic closures so that we can get a better understanding of what they are, how to define them, and how to use them.</p>
    <h1 id="_idParaDest-242" class="title">Simple closures</h1>
    <p class="normal">We will begin by creating a very simple closure that does not accept any arguments and does not <a id="_idIndexMarker564"/>return any value. All it does is print <code class="Code-In-Text--PACKT-">Hello World</code> to the console. Let's look at the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> clos1 = { () -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span>
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Hello World"</span>)
}
</code></pre>
    <p class="normal">In this example, we create a closure and assign it to the <code class="Code-In-Text--PACKT-">clos1</code> constant. Since there are no parameters defined between the parentheses, this closure will not accept any parameters. Also, the return type is defined as <code class="Code-In-Text--PACKT-">Void</code>; therefore, this closure will not return any value. The body of the closure contains one line, which prints <code class="Code-In-Text--PACKT-">Hello World</code> to the console.</p>
    <p class="normal">There are many ways to use closures; in this example, all we want to do is execute it. We can execute the closure as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">clos1()
</code></pre>
    <p class="normal">After executing the closure, we will see that <code class="Code-In-Text--PACKT-">Hello World</code> is printed to the console. At this point, closures may not seem that useful, but as we get further along in this chapter, we will see how useful and powerful they can be.</p>
    <p class="normal">Let's look at another simple example. This closure will accept one <code class="Code-In-Text--PACKT-">String</code> parameter named <code class="Code-In-Text--PACKT-">name</code> but will not return a value. Within the body of the closure, we will print out a greeting to the name passed into the closure through the <code class="Code-In-Text--PACKT-">name</code> parameter. Here is the code for this second closure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> clos2 = {
    (name: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Hello \(name)"</span>)
}
</code></pre>
    <p class="normal">The big difference between the <code class="Code-In-Text--PACKT-">clos2</code> closure and the <code class="Code-In-Text--PACKT-">clos1</code> closure is that we define a single <code class="Code-In-Text--PACKT-">String</code> parameter between the parentheses. As we can see, we define parameters <a id="_idIndexMarker565"/>for closures just like we define parameters for functions. We can execute this closure in the same way in which we executed the <code class="Code-In-Text--PACKT-">clos1</code> closure. The following code shows how this is done:</p>
    <pre class="programlisting code"><code class="hljs-code">clos2(<span class="hljs-string">"Jon"</span>)
</code></pre>
    <p class="normal">This example, when executed, will print the <code class="Code-In-Text--PACKT-">Hello Jon</code> message to the console. Let's look at another way we can use the <code class="Code-In-Text--PACKT-">clos2</code> closure. One thing to note in this example is that the named parameters in a closure do not require the parameter name to be used. </p>
    <p class="normal">Our original definition of closures stated that Closures are self-contained blocks of code that can be passed around and used throughout our application. This tells us that we can pass our closures from the context that they were created into other parts of our code. Let's look at how to pass our <code class="Code-In-Text--PACKT-">clos2</code> closure into a function. We will define a function that accepts our <code class="Code-In-Text--PACKT-">clos2</code> closure, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testClosure</span><span class="hljs-params">(handler: (String)</span> -&gt; <span class="hljs-type">Void</span>) { 
    handler(<span class="hljs-string">"Dasher"</span>)
}
</code></pre>
    <p class="normal">We define the function just like we would any other function; however, in the parameter list, we define a parameter named <code class="Code-In-Text--PACKT-">handler</code>, and the type defined for the <code class="Code-In-Text--PACKT-">handler</code> parameter is <code class="Code-In-Text--PACKT-">(String) -&gt; Void</code>. If we look closely, we can see that the <code class="Code-In-Text--PACKT-">(String) -&gt; Void</code> definition of the <code class="Code-In-Text--PACKT-">handler</code> parameter matches the parameter and return types that we defined for the <code class="Code-In-Text--PACKT-">clos2</code> closure. This means that we can pass the <code class="Code-In-Text--PACKT-">clos2</code> closure into the function. Let's look at how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code">testClosure(handler: clos2)
</code></pre>
    <p class="normal">We call the <code class="Code-In-Text--PACKT-">testClosure()</code> function just like any other function, and the closure that is being passed in looks like any other variable. Since the <code class="Code-In-Text--PACKT-">clos2</code> closure is executed in the <code class="Code-In-Text--PACKT-">testClosure()</code> function, we will see the message <code class="Code-In-Text--PACKT-">Hello Dasher</code> printed to the console when this code is executed. As we will see a little later in this chapter, the ability to pass closures to functions is what makes closures so exciting and powerful. As the final piece to the closure puzzle, let's look at how to return a value from a closure. The following example shows this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> clos3 = {
    (name: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello \(name)"</span>
}
</code></pre>
    <p class="normal">The definition of the <code class="Code-In-Text--PACKT-">clos3</code> closure looks very similar to how we defined the <code class="Code-In-Text--PACKT-">clos2 </code>closure. The difference is that we changed the <code class="Code-In-Text--PACKT-">Void</code> return type to a <code class="Code-In-Text--PACKT-">String</code> type. Then, in the body of the closure, instead of printing the message to the console, we used the return statement <a id="_idIndexMarker566"/>to return the message. We can now execute the <code class="Code-In-Text--PACKT-">clos3</code> closure just like the previous two closures or pass the closure to a function like we did with the <code class="Code-In-Text--PACKT-">clos2</code> closure. The following example shows how to execute the <code class="Code-In-Text--PACKT-">clos3</code> closure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> message = clos3(<span class="hljs-string">"Buddy"</span>)
</code></pre>
    <p class="normal">After this line of code is executed, the message variable will contain the <code class="Code-In-Text--PACKT-">Hello Buddy</code> string. The previous three examples of closures demonstrate the format and how to define a typical closure. Those who are familiar with Objective-C can see that the format of closures in Swift is a lot cleaner and easier to use. The syntax for creating closures that we have shown so far in this chapter is pretty short; however, we can shorten it even more. In this next section, we will look at how to do this.</p>
    <h1 id="_idParaDest-243" class="title">Shorthand syntax for closures</h1>
    <p class="normal">In this <a id="_idIndexMarker567"/>section, we will look at a couple of ways to shorten the syntax.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Using the shorthand syntax for closures is really a matter of personal preference. A lot of developers like to make their code as small and compact as possible, and they take great pride in doing so. However, at times this can make the code hard to read and understand for other developers.</p>
    </div>
    <p class="normal">The first shorthand syntax for closures that we are going to look at is one of the most popular, which is the syntax we saw when we were using algorithms with arrays in <em class="chapterRef">Chapter 5</em>, Using Swift Collections. This format is mainly used when we want to send a really small (usually one line) closure to a function, like we did with the algorithms for arrays. Before we look at this shorthand syntax, we need to write a function that will accept a closure as a parameter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testFunction</span><span class="hljs-params">(num: Int, handler:()</span> -&gt; <span class="hljs-type">Void</span>) { 
    <span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;num {
        handler()
    }
}
</code></pre>
    <p class="normal">This function accepts two parameters; the first parameter is an integer named <code class="Code-In-Text--PACKT-">num</code>, and the second parameter is a closure named <code class="Code-In-Text--PACKT-">handler</code>, which does not have any parameters and does not <a id="_idIndexMarker568"/>return any value. Within the function, we create a <code class="Code-In-Text--PACKT-">for</code> loop that will use the <code class="Code-In-Text--PACKT-">num</code> integer to define how many times it loops. Within the <code class="Code-In-Text--PACKT-">for</code> loop, we call the <code class="Code-In-Text--PACKT-">handler</code> closure that was passed into the function. Now let's create a closure and pass it to <code class="Code-In-Text--PACKT-">testFunction()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> clos = { () -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span>
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Hello from standard syntax"</span>)
}
testFunction(num: <span class="hljs-number">5</span>, handler: clos)
</code></pre>
    <p class="normal">This code is very easy to read and understand; however, it does take five lines of code. Now let's look at how to shorten it by writing the closure inline within the function call:</p>
    <pre class="programlisting code"><code class="hljs-code">testFunction(num: 5,handler: {print("Hello from Shorthand closure")})
</code></pre>
    <p class="normal">In this example, we created the closure inline within the function call, using the same syntax that we used with the algorithms for arrays. The closure is placed in between two curly brackets (<code class="Code-In-Text--PACKT-">{}</code>), which means the code to create the closure is <code class="Code-In-Text--PACKT-">{print("Hello from Shorthand closure")}</code>. When this code is executed, it will print out the <code class="Code-In-Text--PACKT-">Hello from Shorthand closure</code> message five times on the screen. The ideal way to call the <code class="Code-In-Text--PACKT-">testFunction()</code> with a closure, for both compactness and readability, would be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">testFunction(num: <span class="hljs-number">5</span>) {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Hello from Shorthand closure"</span>)
}
</code></pre>
    <p class="normal">Having the closure as the final parameter allows us to leave off the label when calling the function. This example gives us both compact and readable code. Let's look at how to use parameters with this shorthand syntax. We will begin by creating a new function that will accept a closure with a single parameter. We will name this function <code class="Code-In-Text--PACKT-">testFunction2</code>. The following example shows what the new <code class="Code-In-Text--PACKT-">testFunction2</code> function does:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testFunction2</span><span class="hljs-params">(num: Int, handler: (</span><span class="hljs-number">_</span><span class="hljs-params"> : String)</span>-&gt;<span class="hljs-type">Void</span>) { 
    <span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;num {
        handler(<span class="hljs-string">"Me"</span>)
    }
}
</code></pre>
    <p class="normal">In <code class="Code-In-Text--PACKT-">testFunction2</code>, we define the closure like this: <code class="Code-In-Text--PACKT-">(_ : String)-&gt;Void</code>. This definition means that <a id="_idIndexMarker569"/>the closure accepts one parameter and does not return any value. Now let's look at how to use the same shorthand syntax to call this function:</p>
    <pre class="programlisting code"><code class="hljs-code">testFunction2(num: <span class="hljs-number">5</span>){ 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Hello from \($0)"</span>)
}
</code></pre>
    <p class="normal">The difference between this closure definition and the previous one is <code class="Code-In-Text--PACKT-">$0</code>. The <code class="Code-In-Text--PACKT-">$0</code> parameter is shorthand for the first parameter passed into the function. If we execute this code, it prints out the <code class="Code-In-Text--PACKT-">Hello from Me</code> message five times. Using the dollar sign (<code class="Code-In-Text--PACKT-">$</code>) followed by a number with inline closures allows us to define the closure without having to create a parameter list in the definition. The number after the dollar sign defines the position of the parameter in the parameter list. Let's examine this format a bit more, because we are not limited to only using the dollar sign (<code class="Code-In-Text--PACKT-">$</code>) and number shorthand format with inline closures. This shorthand syntax can also be used to shorten the closure definition by allowing us to leave the parameter names off. The following example demonstrates this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> clos5: (<span class="hljs-type">String</span>, <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span> = { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"\($0) \($1)"</span>)
}
</code></pre>
    <p class="normal">In this example, the closure has two string parameters defined; however, we do not give them names. The parameters are defined like this: (<code class="Code-In-Text--PACKT-">String</code>, <code class="Code-In-Text--PACKT-">String</code>). We can then access the parameters within the body of the closure using <code class="Code-In-Text--PACKT-">$0</code> and <code class="Code-In-Text--PACKT-">$1</code>. Also, note that the closure definition is after the colon (<code class="Code-In-Text--PACKT-">:</code>), using the same syntax that we use to define a variable type rather than inside the curly brackets. When we use anonymous arguments, this is how we would define the closure. It will not be valid to define the closure as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> clos5b = { (<span class="hljs-type">String</span>, <span class="hljs-type">String</span>) <span class="hljs-keyword">in</span> 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"\($0) \($1)"</span>)
}
</code></pre>
    <p class="normal">In this example, we will receive an error letting us know that this format is not valid. Next, let's look at how we would use the <code class="Code-In-Text--PACKT-">clos5</code> closure:</p>
    <pre class="programlisting code"><code class="hljs-code">clos5(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Kara"</span>)
</code></pre>
    <p class="normal">Since <code class="Code-In-Text--PACKT-">Hello</code> is the first string in the parameter list, it is accessed with <code class="Code-In-Text--PACKT-">$0</code>, and as <code class="Code-In-Text--PACKT-">Kara</code> is the second string in the parameter list, it is accessed with <code class="Code-In-Text--PACKT-">$1</code>. When we execute this code, we will see the <code class="Code-In-Text--PACKT-">Hello Kara</code> message printed to the console. This next example is used when <a id="_idIndexMarker570"/>the closure doesn't return any value. Rather than defining the return type as <code class="Code-In-Text--PACKT-">Void</code>, we can use parentheses, as the following example shows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> clos6: () -&gt; () = { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Howdy"</span>)
}
</code></pre>
    <p class="normal">In this example, we define the closure as <code class="Code-In-Text--PACKT-">() -&gt; ()</code>. This tells Swift that the closure does not accept any parameters and also does not return a value. We will execute this closure as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">clos6()
</code></pre>
    <p class="normal">As a personal preference, I am not very fond of this shorthand syntax. I think the code is much easier to read when the <code class="Code-In-Text--PACKT-">Void</code> keyword is used rather than the parentheses.</p>
    <p class="normal">We have one more shorthand closure example to demonstrate before we begin showing some really useful examples of closures. In this last example, we will demonstrate how we can return a value from the closure without the need to include the <code class="Code-In-Text--PACKT-">return</code> keyword. If the entire closure body consists of only a single statement, we can omit the <code class="Code-In-Text--PACKT-">return</code> keyword, and the results of the statement will be returned. Let's look at an example of this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> clos7 = {(first: <span class="hljs-type">Int</span>, second: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> first + second }
</code></pre>
    <p class="normal">In this example, the closure accepts two parameters of the <code class="Code-In-Text--PACKT-">Int</code> type and will return an instance of the <code class="Code-In-Text--PACKT-">Int</code> type. The only statement within the body of the closure adds the first parameter to the second parameter. However, if you notice, we do not include the <code class="Code-In-Text--PACKT-">return</code> keyword before the additional statement. Swift will see that this is a single-statement closure and will automatically return the results, just as if we put the <code class="Code-In-Text--PACKT-">return</code> keyword before <a id="_idIndexMarker571"/>the additional statement. We do need to make sure the result type of our statement matches the return type of the closure.</p>
    <p class="normal">All of the examples shown in the previous two sections were designed to show how to define and use closures. On their own, these examples do not really show off the power of closures and they do not show how incredibly useful closures are. The remainder of this chapter will demonstrate the power and usefulness of closures in Swift.</p>
    <h1 id="_idParaDest-244" class="title">Using closures with Swift arrays</h1>
    <p class="normal">In <em class="chapterRef">Chapter 5</em>, <em class="italic">Using Swift Collections</em>, we looked at several built-in algorithms that we can use with Swift's arrays. In that chapter, we briefly looked at how to add simple rules to each <a id="_idIndexMarker572"/>of these algorithms with very basic closures. Now <a id="_idIndexMarker573"/>that we have a better understanding of closures, let's look at how we can expand on these algorithms using more advanced closures.</p>
    <h2 id="_idParaDest-245" class="title">Using closures with Swift's array algorithms</h2>
    <p class="normal">In this section, we will primarily be using the <code class="Code-In-Text--PACKT-">map</code> algorithm for consistency purposes; however, we can <a id="_idIndexMarker574"/>use the basic ideas demonstrated <a id="_idIndexMarker575"/>with any of the algorithms. We will start by defining an array to use:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> guests = [<span class="hljs-string">"Jon"</span>, <span class="hljs-string">"Kailey"</span>, <span class="hljs-string">"Kara"</span>]
</code></pre>
    <p class="normal">This array contains a list of names and the array is named <code class="Code-In-Text--PACKT-">guests</code>. This array will be used for the majority of the examples in this section. Now that we have our <code class="Code-In-Text--PACKT-">guests</code> array, let's add a closure that will print a greeting to each of the names in the array:</p>
    <pre class="programlisting code"><code class="hljs-code">guests.<span class="hljs-built_i">map</span> { name <span class="hljs-keyword">in</span> 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Hello \(name)"</span>)
}
</code></pre>
    <p class="normal">Since the <code class="Code-In-Text--PACKT-">map</code> algorithm applies the closure to each item of the array, this example will print out a greeting for each name within the array. After the first section in this chapter, we should have a pretty good understanding of how this closure works. Using the shorthand syntax that we saw in the previous section, we could reduce the preceding example down to the following single line of code:</p>
    <pre class="programlisting code"><code class="hljs-code">guests.<span class="hljs-built_i">map</span> {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Hello \($0)"</span>)}
</code></pre>
    <p class="normal">This is one of the few times, in my opinion, where the shorthand syntax may be easier to read than the standard syntax. Now, let's say that rather than printing the greeting to the console, we wanted to return a new array that contained the greetings. For this, we would <a id="_idIndexMarker576"/>return a <code class="Code-In-Text--PACKT-">String</code> type from our closure, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> messages = guests.<span class="hljs-built_i">map</span> { 
    (name:<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Welcome \(name)"</span>
}
</code></pre>
    <p class="normal">When <a id="_idIndexMarker577"/>this code is executed, the <code class="Code-In-Text--PACKT-">messages</code> array will contain a greeting to each of the names in the <code class="Code-In-Text--PACKT-">guests</code> array, while the array will remain unchanged. We could access the greetings as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> messages { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(message)"</span>)
}
</code></pre>
    <p class="normal">The preceding examples in this section showed how to add a closure to the <code class="Code-In-Text--PACKT-">map</code> algorithm inline. This is good if we only had one closure that we wanted to use with the <code class="Code-In-Text--PACKT-">map</code> algorithm, but what if we had more than one closure that we wanted to use, or if we wanted to use the closure multiple times or reuse it with different arrays? For this, we could assign the closure to a constant or variable and then pass in the closure, using its constant or variable name, as needed. Let's look at how to do this. We will begin by defining two closures. </p>
    <p class="normal">One of the closures will print a greeting for each element in the array, and the other closure will print a goodbye message for each element in the array:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> greetGuest = { (name:<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Hello guest named \(name)"</span>)
}
<span class="hljs-keyword">let</span> sayGoodbye = { (name:<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Goodbye \(name)"</span>)
}
</code></pre>
    <p class="normal">Now that we have two closures, we can use them with the <code class="Code-In-Text--PACKT-">map</code> algorithm as needed. The following code shows how to use these closures interchangeably with the <code class="Code-In-Text--PACKT-">guests</code> array:</p>
    <pre class="programlisting code"><code class="hljs-code">guests.<span class="hljs-built_i">map</span>(greetGuest)
guests.<span class="hljs-built_i">map</span>(sayGoodbye)
</code></pre>
    <p class="normal">When we use the <code class="Code-In-Text--PACKT-">greetGuest</code> closure with the <code class="Code-In-Text--PACKT-">guests</code> array, the greeting message is printed to the console, and when we use the <code class="Code-In-Text--PACKT-">sayGoodbye</code> closure with the <code class="Code-In-Text--PACKT-">guests</code> array, the goodbye message is printed to the console. If we had another array named <code class="Code-In-Text--PACKT-">guests2</code>, we could <a id="_idIndexMarker578"/>use the same closures for that array, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">guests.<span class="hljs-built_i">map</span>(greetGuest)
guests2.<span class="hljs-built_i">map</span>(greetGuest)
guests.<span class="hljs-built_i">map</span>(sayGoodbye)
guests2.<span class="hljs-built_i">map</span>(sayGoodbye)
</code></pre>
    <p class="normal">All of the <a id="_idIndexMarker579"/>examples in this section so far have either printed a message to the console or returned a new array from the closure. We are not limited to such basic functionality in our closures. For example, we can filter the array within the closure, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> greetGuest2 = { 
    (name:<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">if</span> (name.hasPrefix(<span class="hljs-string">"K"</span>)) {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(name) is on the guest list"</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(name) was not invited"</span>)
    }
}
</code></pre>
    <p class="normal">In this example, we print out a different message depending on whether the name starts with the letter <code class="Code-In-Text--PACKT-">K</code>.</p>
    <p class="normal">As mentioned earlier in the chapter, closures have the ability to capture and store references to any variable or constant from the context in which they were defined. Let's look at an example of this. Let's say that we have a function that contains the highest temperature for the last seven days at a given location and this function accepts a closure as a parameter. This function will execute the closure on the array of temperatures. The function can be written as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">temperatures</span><span class="hljs-params">(calculate:(Int)</span>-&gt;<span class="hljs-type">Void</span>) { 
    <span class="hljs-keyword">var</span> tempArray = [<span class="hljs-number">72</span>,<span class="hljs-number">74</span>,<span class="hljs-number">76</span>,<span class="hljs-number">68</span>,<span class="hljs-number">70</span>,<span class="hljs-number">72</span>,<span class="hljs-number">66</span>] 
    tempArray.<span class="hljs-built_i">map</span>(calculate)
}
</code></pre>
    <p class="normal">This function accepts a closure, defined as <code class="Code-In-Text--PACKT-">(Int)-&gt; Void</code>. We then use the <code class="Code-In-Text--PACKT-">map</code> algorithm to execute this closure for each item of the <code class="Code-In-Text--PACKT-">tempArray</code> array. The key to using a closure correctly in this situation is to understand that the <code class="Code-In-Text--PACKT-">temperatures</code> function does not know, or care, about what goes on inside the <code class="Code-In-Text--PACKT-">calculate</code> closure. Also, be aware that the closure <a id="_idIndexMarker580"/>is also unable to update or change <a id="_idIndexMarker581"/>the items within the function's context, which means that the closure cannot change any other variable within the temperature's function; however, it can update variables in the context that it was created in.</p>
    <p class="normal">Let's look at the function that we will create the closure in. We will name this function <code class="Code-In-Text--PACKT-">testFunction</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testFunction</span><span class="hljs-params">()</span> { 
    <span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> <span class="hljs-built_i">count</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> addTemps = {
        (num: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span> 
        total += num 
        <span class="hljs-built_i">count</span> += <span class="hljs-number">1</span>
    }
    temperatures(calculate: addTemps) 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Total: \(total)"</span>)
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Count: \(count)"</span>) 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Average: \(total/count)"</span>)
}
</code></pre>
    <p class="normal">In this function, we begin by defining two variables, named <code class="Code-In-Text--PACKT-">total</code> and <code class="Code-In-Text--PACKT-">count</code>, where both variables are of the <code class="Code-In-Text--PACKT-">Int</code> type. We then create a closure named <code class="Code-In-Text--PACKT-">addTemps</code> that will be used to add all the temperatures from the <code class="Code-In-Text--PACKT-">temperatures</code> function together. The <code class="Code-In-Text--PACKT-">addTemps</code> closure will also count how many temperatures there are in the array. To do this, the <code class="Code-In-Text--PACKT-">addTemps</code> closure calculates the sum of each item in the array and keeps the total in the <code class="Code-In-Text--PACKT-">total</code> variable that was defined at the beginning of the function. The <code class="Code-In-Text--PACKT-">addTemps</code> closure also keeps track of the number of items in the array by incrementing the <code class="Code-In-Text--PACKT-">count</code> variable for each item. Notice that neither the <code class="Code-In-Text--PACKT-">total</code> nor <code class="Code-In-Text--PACKT-">count</code> variables are defined within the closure; however, we are able to use them within the closure because they were defined in the same context as the closure.</p>
    <p class="normal">We then call the <code class="Code-In-Text--PACKT-">temperatures</code> function and pass it the <code class="Code-In-Text--PACKT-">addTemps</code> closure. Finally, we print the <code class="Code-In-Text--PACKT-">Total</code>, <code class="Code-In-Text--PACKT-">Count</code>, and <code class="Code-In-Text--PACKT-">Average</code> temperature to the console. When <code class="Code-In-Text--PACKT-">testFunction</code> is executed, we will see the following output to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Total: 498
Count: 7
Average: 71
</code></pre>
    <p class="normal">As we can see from the output, the <code class="Code-In-Text--PACKT-">addTemps</code> closure is able to update and use items that are <a id="_idIndexMarker582"/>defined within the context that it <a id="_idIndexMarker583"/>was created in, even when the closure is used in a different context.</p>
    <p class="normal">Now that we have looked at using closures with the array <code class="Code-In-Text--PACKT-">map</code> algorithm, let's look at using closures by themselves. We will also look at the ways we can clean up our code to make it easier to read and use.</p>
    <h2 id="_idParaDest-246" class="title">Non-contiguous elements from an array</h2>
    <p class="normal">In <em class="chapterRef">Chapter 5</em>, <em class="italic">Using Swift Collections</em>, we showed how to retrieve non-contiguous sub-elements <a id="_idIndexMarker584"/>from an array using <a id="_idIndexMarker585"/>the <code class="Code-In-Text--PACKT-">subrange</code> method with a closure. Now that we know a little more about closures, let's take a look at this again. </p>
    <p class="normal">The <a id="_idIndexMarker586"/>code we used in <em class="chapterRef">Chapter 5</em>, <em class="italic">Using Swift Collections</em>, retrieved the even numbers from an array of integers. Let's look at this code again:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]
<span class="hljs-keyword">let</span> evenNum = numbers.subranges(<span class="hljs-keyword">where</span>: { $<span class="hljs-number">0</span>.isMultiple(of: <span class="hljs-number">2</span>) })
<span class="hljs-comment">//numbers[evenNum] contains 2,4,6,8,10</span>
</code></pre>
    <p class="normal">In this example, we used <code class="Code-In-Text--PACKT-">isMultiple(of: )</code> from the <code class="Code-In-Text--PACKT-">Int</code> type to retrieve all elements that are even numbers. Since the <code class="Code-In-Text--PACKT-">subranges(where: )</code> method takes a closure, we can use other logic as well. For example, if we wanted to retrieve all elements that were equal to or less than 6, we could use the following line of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> newNumbers = numbers.subrange(<span class="hljs-keyword">where</span>: { $<span class="hljs-number">0</span> &lt;= <span class="hljs-number">6</span> })
</code></pre>
    <p class="normal">Now that we are familiar with closures, we can see some of the possibilities of the <code class="Code-In-Text--PACKT-">subrange(where: )</code> method.</p>
    <h2 id="_idParaDest-247" class="title">Uninitialized arrays</h2>
    <p class="normal">Swift 5.2 with SE-0245 introduced a new initializer for arrays that does not pre-fill the values <a id="_idIndexMarker587"/>with a default value. This initializer enables us to provide a closure to fill in the values however we like. Let's take a look at how to do this by <a id="_idIndexMarker588"/>creating an array that will contain the value of 20 dice rolls:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> capacity = <span class="hljs-number">20</span>
<span class="hljs-keyword">let</span> diceRolls = <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Int</span>&gt;(unsafeUninitializedCapacity: capacity) { buffer, initializedCount <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;capacity {
        buffer[x] = <span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">1</span>...<span class="hljs-number">6</span>)
    }
    initializedCount = capacity
}
</code></pre>
    <p class="normal">We begin by setting a constant that contains the capacity for the array. We do this because we need to provide that value in several spots within the initializer and by using the constant, if we need to change this capacity at a later time, then it only needs to be changed in one spot.</p>
    <p class="normal">The rest of the code initializes the array. The closure provides an unsafe mutable buffer pointer, which we named <code class="Code-In-Text--PACKT-">buffer</code> in the previous code, that can be used to write the values for the array too. We use a <code class="Code-In-Text--PACKT-">for</code> loop to populate the array with random integer values from 1 to 6.</p>
    <p class="normal">There are some general rules when you are using this initializer:</p>
    <ul>
      <li class="bullet">You do not need to use the full capacity that you ask for; however, you cannot use more. In our example, we ask for a capacity of 20 elements, which means we can use less than 20, but we cannot use more than 20.</li>
      <li class="bullet">If you do not initialize an element, then it will probably be filled with random data (very bad idea). In our example, where we request a capacity of 20 elements, if we only populated the first 10 elements then the second 10 elements would contain random garbage.</li>
      <li class="bullet">If <code class="Code-In-Text--PACKT-">initializedCount</code> is not set then it will default to <code class="Code-In-Text--PACKT-">0</code> and all of the data will be lost.</li>
      <li class="bullet">This is a very handy initializer to use but it is also very easy to make a mistake with it. We could also rewrite the <code class="Code-In-Text--PACKT-">diceRolls</code> initializer using the <code class="Code-In-Text--PACKT-">map</code> array algorithm, as the following code shows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> diceRolls = (<span class="hljs-number">0</span>…<span class="hljs-number">20</span>).<span class="hljs-built_i">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">1</span>…<span class="hljs-number">6</span>) }
</code></pre>
        <p class="bullet-para">However, this would be less efficient because initializing the array as shown in the first <a id="_idIndexMarker589"/>example is internally optimized for better <a id="_idIndexMarker590"/>performance. If you are not worried about the best performance, then the map algorithm is much easier to read and understand.</p>
      </li>
    </ul>
    <p class="normal">Now let's look at how we can use closures to change functionality at runtime.</p>
    <h1 id="_idParaDest-248" class="title">Changing functionality</h1>
    <p class="normal">Closures also give us the ability to change the functionality of types on the fly. In <em class="chapterRef">Chapter 11</em>, <em class="italic">Generics</em>, we saw that generics give us the ability to write functions that are valid for <a id="_idIndexMarker591"/>multiple types. With closures, we are able to write functions and types whose functionality can change, based on the closure that is passed in. In this section, we will show you how to write a function whose functionality can be changed with a closure.</p>
    <p class="normal">Let's begin by defining a type that will be used to demonstrate how to swap out a functionality. We will name this type <code class="Code-In-Text--PACKT-">TestType</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">TestType</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">GetNumClosure</span> = ((<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>)
    <span class="hljs-keyword">var</span> numOne = <span class="hljs-number">5</span> 
    <span class="hljs-keyword">var</span> numTwo = <span class="hljs-number">8</span>
    <span class="hljs-keyword">var</span> results = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getNum</span><span class="hljs-params">(handler: GetNumClosure)</span> -&gt; <span class="hljs-type">Int</span> { 
        results = handler(numOne,numTwo)
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Results: \(results)"</span>)
        <span class="hljs-keyword">return</span> results
    }
}
</code></pre>
    <p class="normal">We begin this type by defining a <code class="Code-In-Text--PACKT-">typealias</code> for our closure, which is named <code class="Code-In-Text--PACKT-">GetNumClosure</code>. Any closure that is defined as a <code class="Code-In-Text--PACKT-">GetNumClosure</code> closure will take two integers and return a single integer. Within this closure, we assume that it does something with the integers that we pass in to get the value to return, but it really doesn't have to do anything with the integers. To be honest, this class doesn't really care what the closure does as long as it conforms to the <code class="Code-In-Text--PACKT-">GetNumClosure</code> type. Next, we define three integers, named <code class="Code-In-Text--PACKT-">numOne</code>, <code class="Code-In-Text--PACKT-">numTwo</code>, and <code class="Code-In-Text--PACKT-">results</code>.</p>
    <p class="normal">We also <a id="_idIndexMarker592"/>define a method named <code class="Code-In-Text--PACKT-">getNum()</code>. This method accepts a closure that conforms to the <code class="Code-In-Text--PACKT-">GetNumClosure</code> type as its only parameter. Within the <code class="Code-In-Text--PACKT-">getNum()</code> method, we execute the closure by passing in the <code class="Code-In-Text--PACKT-">numOne</code> and <code class="Code-In-Text--PACKT-">numTwo</code> variables, and the integer that is returned is put into the <code class="Code-In-Text--PACKT-">results</code> class variable. Now let's look at several closures that conform to the <code class="Code-In-Text--PACKT-">GetNumClosure</code> type that we can use with the <code class="Code-In-Text--PACKT-">getNum()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> <span class="hljs-built_i">max</span>: <span class="hljs-type">TestType</span>.<span class="hljs-type">GetNumClosure</span> = { 
    <span class="hljs-keyword">if</span> $<span class="hljs-number">0</span> &gt; $<span class="hljs-number">1</span> {
        <span class="hljs-keyword">return</span> $<span class="hljs-number">0</span>
    } <span class="hljs-keyword">else</span> { 
        <span class="hljs-keyword">return</span> $<span class="hljs-number">1</span>
    }
}
<span class="hljs-keyword">var</span> <span class="hljs-built_i">min</span>: <span class="hljs-type">TestType</span>.<span class="hljs-type">GetNumClosure</span> = { 
    <span class="hljs-keyword">if</span> $<span class="hljs-number">0</span> &lt; $<span class="hljs-number">1</span> {
        <span class="hljs-keyword">return</span> $<span class="hljs-number">0</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> $<span class="hljs-number">1</span>
    }
}
<span class="hljs-keyword">var</span> multiply: <span class="hljs-type">TestType</span>.<span class="hljs-type">GetNumClosure</span> = { 
    <span class="hljs-keyword">return</span> $<span class="hljs-number">0</span> * $<span class="hljs-number">1</span>
}
<span class="hljs-keyword">var</span> second: <span class="hljs-type">TestType</span>.<span class="hljs-type">GetNumClosure</span> = { 
    <span class="hljs-keyword">return</span> $<span class="hljs-number">1</span>
}
<span class="hljs-keyword">var</span> answer: <span class="hljs-type">TestType</span>.<span class="hljs-type">GetNumClosure</span> = { 
    <span class="hljs-keyword">var</span> <span class="hljs-number">_</span> = $<span class="hljs-number">0</span> + $<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>
}
</code></pre>
    <p class="normal">In this code, we define five closures that conform to the <code class="Code-In-Text--PACKT-">GetNumClosure</code> type:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">max</code>: This returns the maximum value of the two integers that are passed</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">in min</code>: This returns the minimum value of the two integers that are passed</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">in multiply</code>: This multiplies both the values that are passed in and returns the product</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">second</code>: This returns the second parameter that was passed in</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">answer</code>: This returns the answer to life, the universe, and everything</li>
    </ul>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">answer</code> closure, we have an extra line that looks like it does not have a purpose:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> <span class="hljs-number">_ </span>= $<span class="hljs-number">0</span> + $<span class="hljs-number">1</span>
</code></pre>
    <p class="normal">We do <a id="_idIndexMarker593"/>this deliberately because the following code is not valid:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> answer: <span class="hljs-type">TestType</span>.<span class="hljs-type">GetNumClosure</span> = {
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>
}
</code></pre>
    <p class="normal">This type gives us the error Contextual type for closure argument list expects two arguments, which cannot be implicitly ignored. As we can see by the error, Swift will not let us ignore the expected parameters within the body of the closure. In the second closure, Swift assumes that there are two parameters because <code class="Code-In-Text--PACKT-">$1</code> specifies the second parameter. We can now pass each one of these closures to the <code class="Code-In-Text--PACKT-">getNum()</code> method to change the functionality of the function to suit our needs. The following code illustrates this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myType = <span class="hljs-type">TestType</span>()
myType.getNum(handler: <span class="hljs-built_i">max</span>)
myType.getNum(handler: <span class="hljs-built_i">min</span>)
myType.getNum(handler: multiply)
myType.getNum(handler: second)
myType.getNum(handler: answer)
</code></pre>
    <p class="normal">When this code is run, we will receive the following results for each of the closures:</p>
    <pre class="programlisting con"><code class="hljs-con">For Max: 
Results: 8
For Min: 
Results: 5
For Multiply: 
Results: 40
For Second: 
Results: 8
For Answer: 
Results: 42
</code></pre>
    <p class="normal">The last <a id="_idIndexMarker594"/>example we are going to show you is one that is used a lot in frameworks, especially ones that have a functionality that is designed to be run asynchronously.</p>
    <h1 id="_idParaDest-249" class="title">Selecting a closure based on results</h1>
    <p class="normal">In the <a id="_idIndexMarker595"/>final example, we will pass two closures to a method, and then, depending on some logic, one or possibly both of the closures will be executed. Generally, one of the closures is called if the method was successfully executed and the other closure is called if the method failed.</p>
    <p class="normal">Let's start by creating a type that will contain a method that will accept two closures and then execute one of the closures based on the defined logic. We will name this type <code class="Code-In-Text--PACKT-">TestType</code>. Here is the code for the <code class="Code-In-Text--PACKT-">TestType</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestType</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">ResultsClosure</span> = ((<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span>)
    
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">isGreater</span><span class="hljs-params">(numOne: Int, numTwo: Int, successHandler: ResultsClosure,failureHandler: ResultsClosure)</span> {
        <span class="hljs-keyword">if</span> numOne &gt; numTwo {
            successHandler(<span class="hljs-string">"\(numOne) is greater than \(numTwo)"</span>)
        }
        <span class="hljs-keyword">else</span> {
            failureHandler(<span class="hljs-string">"\(numOne) is not greater than \(numTwo)"</span>)
        }
        
    }
}
</code></pre>
    <p class="normal">We begin this type by creating a <code class="Code-In-Text--PACKT-">typealias</code> that defines the closure that we will use for both the successful and failure closures. We will name this <code class="Code-In-Text--PACKT-">typealiasResultsClosure</code>. This example also illustrates why you should use a <code class="Code-In-Text--PACKT-">typealias</code> rather than retyping the closure definition. It saves us a lot of typing and prevents us from making mistakes. In this example, if we do not use a <code class="Code-In-Text--PACKT-">typealias</code>, we would need to retype the closure definition four times, and if we need to change the closure definition, we would need to change it in four spots. With the type alias, we only need to type the closure definition once and then use the alias throughout the remaining code.</p>
    <p class="normal">We then create a method named <code class="Code-In-Text--PACKT-">isGreater</code>, which takes two integers as the first two parameters, and two closures as the next two parameters. The first closure is named <code class="Code-In-Text--PACKT-">successHandler</code>, and the second closure is named <code class="Code-In-Text--PACKT-">failureHandler</code>. Within this method, we check <a id="_idIndexMarker596"/>whether the first integer parameter is greater than the second. If the first integer is greater, the <code class="Code-In-Text--PACKT-">successHandler</code> closure is executed; otherwise, the <code class="Code-In-Text--PACKT-">failureHandler</code> closure is executed. Now, let's create two closures outside of the <code class="Code-In-Text--PACKT-">TestType</code> structure. The code for these two closures is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> success: <span class="hljs-type">TestType</span>.<span class="hljs-type">ResultsClosure</span> = { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Success: \($0)"</span>)
}
<span class="hljs-keyword">var</span> failure: <span class="hljs-type">TestType</span>.<span class="hljs-type">ResultsClosure</span> = {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Failure: \($0)"</span>)
}
</code></pre>
    <p class="normal">Note that both closures are defined as the <code class="Code-In-Text--PACKT-">TestClass.ResultsClosure</code> type. In each closure, we simply print a message to the console to let us know which closure was executed. Normally, we would put some functionality in the closure. We will then call the method with both the closures, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> test = <span class="hljs-type">TestType</span>()
test.isGreater(numOne: <span class="hljs-number">8</span>, numTwo: <span class="hljs-number">6</span>, successHandler: success, failureHandler: failure)
</code></pre>
    <p class="normal">Note that in the method call, we are sending both the success closure and the failure closure. In this example, we will see the <code class="Code-In-Text--PACKT-">Success: 8 is greater than 6</code> message. If we reversed the numbers, we would see the <code class="Code-In-Text--PACKT-">Failure: 6 is not greater than 8</code> message. This use case is really good when we call asynchronous methods, such as loading data from a web service. If the web service call was successful, the success closure is called; otherwise, the failure closure is called.</p>
    <p class="normal">One big advantage of using closures like this is that the UI does not freeze while we wait for the asynchronous call to complete. This also involves a concurrency piece, which we will be covering in <em class="chapterRef">Chapter 16</em>, <em class="italic">Concurrency and Parallelism in Swift</em>. As an example, imagine we tried to retrieve data from a web service as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> data = myWebClass.myWebServiceCall(someParameter)
</code></pre>
    <p class="normal">Our UI would freeze while we waited for the response, or we would have to make the call in a separate <a id="_idIndexMarker597"/>thread so that the UI would not hang. With closures, we pass the closures to the networking framework and rely on the framework to execute the appropriate closure when it is done. This relies on the framework to implement concurrency correctly, to make the calls asynchronously, but a decent framework should handle that for us.</p>
    <h1 id="_idParaDest-250" class="title">Summary</h1>
    <p class="normal">In this chapter, we saw that we can define a closure just like we can define an integer or string type. We can assign closures to a variable, pass them as an argument to functions, and return them from functions. Closures capture strong references to any constants or variables from the context in which the closure was defined. We do have to be careful with this functionality, to make sure that we do not create a strong reference cycle, which would lead to memory leaks in our applications.</p>
    <p class="normal">Swift closures are very similar to blocks in Objective-C, but they have a much cleaner and more eloquent syntax. This makes them a lot easier to use and understand. Having a good understanding of closures is vital to mastering the Swift programming language and will make it easier to develop great applications that are easy to maintain. They are also essential for creating first-class frameworks that are easy both to use and to maintain.</p>
    <p class="normal">The use cases that we looked at in this chapter are by no means the only useful use cases for closures. I can promise you that the more you use closures in Swift, the more uses you will find for them. Closures are definitely one of the most powerful and useful features of the Swift language, and Apple did a great job by implementing them.</p>
    <p class="normal">In the next chapter, we will look at how we can use the advanced bitwise operators provided by Swift and how we can create our own custom operators.</p>
  </div>
</body></html>