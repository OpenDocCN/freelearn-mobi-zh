- en: Chapter 8. Adding Watch Support
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple released watchOS to the public with the release of the Apple Watch in
    April 2015\. However, with the release of watchOS 2 in September 2015, developers
    have been able to write extensions that run on the watch itself rather than relying
    on a companion iOS device being available. This chapter will show how to add watch
    support to the existing Repository Browser application (created in [Chapter 7](part0050_split_000.html#1FLS41-d7e55eb5242648e89c396442afe4f84b
    "Chapter 7. Building a Repository Browser"), *Building a Repository Browser*.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will present the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Adding a watch extension to an existing project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of watch interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tables, text, and images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to transition between screens with selected context
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for watch applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watch applications
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A watch application consists of code that can execute on the watch itself. A
    watch application is developed in Swift and run as a *watch extension* and a *watch
    app*. For watchOS 2, both run on the watch. (On watchOS 1, the watch extension
    ran on the companion iPhone.) This chapter will assume watchOS 2 is being used
    in order to run Swift-compiled code directly on the watch.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the first version of watchOS did not allow code to be executed on the watch,
    the code was bundled up into a watch extension, which ran as part of the companion
    application on the iPhone. The watch app contained resources and other images
    which were presented directly on the watch. With watchOS 2, the separation became
    less relevant. A future version of Xcode or watchOS may result in the two concepts
    becoming combined.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Adding a watch target
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add watch support for an existing application, a new target must be created
    for the watch. Open the existing **Repository Browser** application, navigate
    to **File** | **New** | **Target**, and select **WatchKit App** from the **watchOS**
    section:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a watch target](img/00096.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: 'Once this is created, it will ask for the name of the watch application. This
    can''t be the same name as the enclosing project, so call it `RepositoryBrowserWatch`
    instead. The language should be **Swift**; the other user interface elements (**Complications**,
    **Glance**, and **Notifications**) are not relevant to this project, and so, it
    can be deselected:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a watch target](img/00097.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'When **Finish** is pressed, the following new elements will be created in the
    project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`RepositoryBrowserWatch`: This is the watch application, which provides the
    interface descriptions for the application'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RepositoryBrowserWatch Extension`: This is the content corresponding to the
    watch application''s executable code'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InterfaceController.swift`: This is the Swift file corresponding to the user
    interface element that gets automatically created'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtensionDelegate.swift`: This is the Swift file corresponding to the user
    application as a whole (similar to an `AppDelegate` on a traditional iOS application)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the GitHubAPI to the watch target
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to allow the watch application to use the `GitHubAPI` that was developed
    in [Chapter 7](part0050_split_000.html#1FLS41-d7e55eb5242648e89c396442afe4f84b
    "Chapter 7. Building a Repository Browser"), *Building a Repository Browser*,
    the following code should be added to the `ExtensionDelegate`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will initially generate a compile-time error because the `GitHubAPI` class
    (and the dependent classes) is not currently associated to the watch target. To
    resolve this, select the `GitHubAPI`, `Threads`, `NSURLExtensions`, and `URITemplate`
    Swift files and open the file inspector by pressing *Command* + *Option* + *1*
    or by navigating to **View | Utilities | Show File Inspector**. Ensure these are
    added to the **RepositoryBrowserWatch Extension** target by selecting the appropriate
    checkbox:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the GitHubAPI to the watch target](img/00098.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Now when the watch target is built and run, a watch simulator will show up
    with a black screen and the time at the top-right of the application. If this
    is not displayed, verify that the target selected is for the watch application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the GitHubAPI to the watch target](img/00099.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Creating watch interfaces
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A watch's user interface is built up of elements in a similar way to iOS applications,
    except that the user toolkit is built using `WatchKit` instead of `UIKit`. In
    the same way that classes, such as `UITableView`, exist, corresponding classes,
    such as `WKInterfaceTable`, also exist. There are minor differences; for example,
    the `UITableView` will dynamically populate the elements upon display, but the
    `WKInterfaceTable` will expect to be told in advance how many rows exist and what
    these rows are.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Adding a list of users to the watch
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the `UITableView`, which provides section headers to group rows, a `WKInterfaceTable`
    only permits a single list of items. Instead, the application will be designed
    so that the first screen will show a list of users, and then the second screen
    will show the selected user's repositories.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing purposes, add the following into the `applicationDidFinishLaunching`
    method of the `ExtensionDelegate` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will allow other classes to query the `ExtensionDelegate` property `users`
    to show some content. As with the `AppDelegate` of an iOS application, there is
    a global singleton that can be accessed. Add the following to the `InterfaceController`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To display a list of users, the interface itself must have a table. Each table
    row has its own controller class, which can be a simple `NSObject` subclass. To
    display a list of user names, create a `UserRowController` class that has a single
    label. As this is a private implementation detail of the `InterfaceController`,
    it makes sense to include it in the same file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following to the `InterfaceController` class, which will be connected
    to the interface later:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, the table can be populated in the `awakeWithContext` method. This involves
    setting the number of rows, and the type of the rows. Add the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the application is run at this point, several errors will occur because the
    `IBOutlet` references have not been connected, and the row type user has not been
    associated with the `UserRowController` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the interface
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having generated the content for the users, the interface must be wired to the
    implementation detail. Open `Interface.storyboard` in the `RepositoryBrowserWatch`
    folder and go to **Interface Controller Scene**. This will present a black watch
    surrounded with a clock and **Any Screen Size** displayed at the bottom. Like
    iOS application interfaces, they can come in different sizes (38mm or 42mm at
    the time of writing).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the object library by pressing *Command* + *Option* + *Control* + *3*
    or by navigating to **View | Utilities | Show Object Library**. Type `table` into
    the search field and then drag it into the watch interface:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the interface](img/00100.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'From the **Interface Controller** in the document outline on the left, press
    *Control* and drag down to the table to create a connection to the `usersTable`
    outlet that is defined in the interface controller:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the interface](img/00101.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'When the `InterfaceController` is instantiated, the `usersTable` will be wired
    up to the outlet. However, there are still no connections to the rows. To do this,
    drag a label into the dotted area with the **Table Row** placeholder. To ensure
    that the label takes up all the available space, set the size to **Relative to
    Container** with a factor of **1** for both **Width** and **Height**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the interface](img/00102.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: In order to connect the label's text with the `UserRowController`, two things
    have to be done. Firstly, the type of the row must be set to correspond to the
    `UserRowController` class, which will allow the label to be wired up to the name
    outlet. Secondly, the row must be given the identifier user to allow it to be
    connected with the `rowType` that was specified in the previous section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the row controller''s class, open the **Identity Inspector** by pressing
    the *Command* + *Option* + *3* keys or by navigating to **View | Utilities | Show
    Identity Inspector**. Choose **UserRowController** from the dropdown, which should
    also set the module name **RepositoryBrowserWatch_Extension**. Once this is done,
    the user controller can make a connection to the label by pressing *Control* and
    dragging to the label, followed by choosing the **name** outlet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the interface](img/00103.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'To set the row controller''s type, switch to the **Attributes Inspector** by
    pressing the *Command* + *Option* + *4* keys or by navigating to **View | Utilities
    | Show Attributes Inspector**, and entering the `rowType` that was used previously,
    which is `user`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the interface](img/00104.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'Now when the application is run the list of users should be seen, which includes
    `alblue`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the interface](img/00105.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Adding an image
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to use the existing API to return an image for the user, and
    this can be displayed using a `WKInterfaceImage` in a similar way to the text
    name. First, an outlet needs to be created in the `UserRowController` so that
    it can be connected to the interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The interface now needs to be updated to add the image. This can be done by
    searching for **image** in the object library and then dragging it into the user
    row.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The watch prefers that image sizes are known in advance, so the size of the
    image can be fixed with a size of 32 by 32 pixels, which will be sufficient for
    both the larger and smaller watch sizes. Marking the image as **Aspect Fit** will
    ensure that the image doesn't get resized inappropriately, and that the whole
    image will be displayed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to click the **+** icon next to the **size** and then specify
    different dimensions for the two different watches.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Aligning the image on the right and on the center will give the same impression
    for both sizes of watch. Changing the alignment to **Right** and **Center** will
    allow the display to adjust to different sizes. It may also make sense to modify
    the user''s name width from **Relative to Container** to **Size to Fit**, but
    this is not strictly necessary. Finally, connect the outlet from the **user**
    row with the image using *Control* and dragging the mouse, followed by choosing
    the **icon** outlet. The resulting user interface will look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an image](img/00106.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'Having created and wired up the image, the last step is to populate the data.
    In the `InterfaceController` method `awakeFromContext`, after setting the user''s
    name, add a call to the API to acquire the image similar to the `DetailViewController`
    in the last chapter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now when the application is run, after a brief pause, the user''s avatar will
    be seen:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an image](img/00107.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Responding to user interaction
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, a watch user interface will present information to the user or let
    them select or manipulate it in some way. When items are presented in a table,
    then it is natural to let the user tap on the row to show a subsequent screen.
    Watch applications use **segues** to move from one screen to another in a similar
    way to iOS applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will involve creating a new controller file called `RepositoryListController.swift`.
    This will be used to hold the `RepositoryListController` and `RepositoryRowController`
    classes, in a very similar way to the existing `InterfaceController`. As with
    the other view, there will be a table to store the rows, and each row will have
    a `name` label:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to add the `RepositoryListController.swift` file to the `RepositoryBrowserWatch
    Extension` target, or it will not be possible to use that as the implementation
    class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Once these classes have been created, the `Interface.storyboard` can be opened
    and a new **Interface Controller** dragged in from the object library. This will
    create an empty screen, which can have other objects added.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure that the **Interface Controller** is selected, instead of the **Glance
    Interface Controller** or the **Notification Interface Controller** as these are
    used for different purposes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Once the interface controller has been created, drag a **Table** from the object
    library onto the interface controller, and then drag a **Label** from the object
    library into the row placeholder in the same way as in the previous interface
    controller example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The interface controller will need to be updated to point to the `RepositoryListController`
    class; this can be done by selecting the interface controller and going to the
    **Identity Inspector** as before. Once the `RepositoryListController` implementation
    is defined, press *Control* and drag it from the interface controller icon to
    the table and wire it to the `repositoriesTable`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These connections are made in the same way as they were for the `usersTable`
    in the previous section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The row placeholder's class can be defined by selecting the placeholder under
    the **Repositories Table** in the document outline, and then setting the row controller's
    identity to `repository` in the **Attributes Inspector**. This will allow the
    repository row placeholder to connect the name attribute to the label in the scene.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The last connection is to add a **segue** from the users screen to the repositories
    screen. Press *Control* and drag from the **user** row in the **Users Table**
    to the repository list controller, and in the popup, select a **Push Segue**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The final connection will look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Responding to user interaction](img/00108.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: When the user is selected in the first screen, the second screen should slide
    over. At the moment this will be empty but the repositories will be populated
    in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Adding context and showing repositories
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To pass data from one screen to another requires a context to be set. Each `WKInterface`
    screen has an `awakeWithContext` function that can be used to pass an arbitrary
    object into the screen when it is displayed. This can be used to supply a user
    object, which in turn can be used to look up a set of repositories.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The first element is setting the context object when transitioning out of a
    screen. In the `InterfaceController` class, add a new method `contextForSegueWithIdentifier`,
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now when the `RepositoryListController` is displayed, the currently-selected
    user will be passed through. To receive the object, create an `awakeWithContext`
    method in the `RepositoryListController` class, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will allow the code to be debugged at this point to verify that the object
    is being passed through as expected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Displaying a list of repositories requires using the API to generate a list
    of data, creating the appropriate number of rows, and then setting the row contents
    as before. This can be implemented by updating the `awakeWithContext` method in
    the `RepositoryListController`, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now when the watch application is run, and a user selected, a list of repositories
    should be populated in the second screen:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding context and showing repositories](img/00106.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Adding a detail screen
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final part of the watch application is to create a modal screen that is
    similar to the `DetailViewController` in the iOS application. When the user selects
    a repository, details about the repository should be presented modally.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be implemented with a new `RepositoryController.swift` file, which
    will contain a `WKInterfaceController` and have four labels that can be wired
    up in the interface:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to add the `RepositoryController.swift` file to the `RepositoryBrowserWatch
    Extension` target, or it will not be possible to use that as the implementation
    class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: To add the screen, open the `Interface.storyboard` and drag another **Interface
    Controller** from the object library onto the canvas. In the **Identity Inspector**,
    set `RepositoryController` as the **Class** type, which will allow the labels
    to be wired up subsequently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Drag four **Label** objects into the watch interface. They will line up automatically
    in a row, one under each other. These can be given placeholder text of `Repo`,
    `Issues`, `Watchers`, and `Forks`—although the content of these will be changed
    programmatically. By dragging and dropping from the **Repository Controller**
    onto each of the labels, wire up the connections for the outlets so that they
    can be controlled programmatically.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, wire up the segue from the repository list controller so that when
    the **repository** row controller under the **Repositories Table** is selected,
    a **Modal** selection segue is chosen. The completed set of connections should
    look like this in Xcode:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a detail screen](img/00109.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: At this point the application can be tested, and selecting a repo should transition
    into the new screen although the correct content won't be displayed yet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Populating the detail screen
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To wire up the labels in the detail screen, a similar process has to be followed
    for the previous screen: the context needs to be set from the transitioning screen,
    and then the data needs to be populated into the receiving screen.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In the `RepositoryListController`, the selected repository information needs
    to be passed on through the `contextForSegueWithIdentifier` method. However, unlike
    the `users` list (which is persisted in the `ExtensionDelegate`), there is no
    such stored repositories data list. As a result, it is necessary to persist a
    temporary copy of the repositories when the screen is woken.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `awakeWithContext` method of the `RepositoryListController` class
    to store entries in the `repos` property so that when one is selected it can be
    used to set the context when transitioning out of the screen:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now when the repository is selected, the key/value pairs will be passed on through
    the cached content from before.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in filling in the details screen is to use this context object
    to set up the labels. In the `RepositoryController` class, add an `awakeWithContext`
    method that receives the key/value dictionary, and uses the fields to display
    information about the repository:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now when the application is run, the user should be able to step through each
    of the three screens to see the content.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating the detail screen](img/00110.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Best practice for watch applications
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As watches are very low-powered devices with limited networking, care should
    be taken to reduce networking where possible. The example application shown here
    (using several REST-based calls to a backend server) is sending and receiving
    more data than needed; if this was being designed as a custom application, then
    the protocol should be minimized to avoid unnecessary data transmission.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The example application also presented user information as a list of text data,
    which may not be the most appropriate way of showing data. Consider other mechanisms
    to present information in a more graphical way where appropriate.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: UI thread considerations
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is generally bad practice to perform any networking on the main thread, such
    as the lookups for the API, and for the query for a user's repositories. Instead,
    the lookups should be run in a background thread, switching back to the UI thread
    where necessary to perform updates.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the API lookup for the connection, the connect method looks
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This uses optional initializers to return a `GitHubAPI` whether the network
    connection succeeded or not, but this means that the call has to block before
    it can be used. This means that the `GitHubAPI()` initializer called in the `applicationDidFinishLaunching`
    will be blocking the application''s startup, which is not excellent user experience.
    Instead, it is better to do something like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding background threads increases the complexity, but this means that the
    application will start faster. It may be necessary to update the UI initialization
    logic such that the calls to the API are deferred until the network service is
    available, or show other loading progress indicators to give the user feedback
    that something is happening.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Stored data
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user list in the example application only stores a single variable, which
    is hardcoded into the application. Normally, this won't be the case, but the watch
    is not set up for data input. Instead, the companion iOS application should be
    used to define a list of users (with appropriate error checking and interface)
    and then communicate that with the watch application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of achieving this. The best way is to use the iCloud infrastructure
    and have the document updated on the iOS device and then mirrored to the watch
    automatically. This will allow the user to transition to new iOS devices or watches
    in the future without needing to recreate the list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: An alternative way is to send messages between the watch and the iOS device
    using the `WatchConnectivity` module and the `WCSession` type. This provides a
    singleton that is accessible through the `WCSession.defaultSession()`, which can
    be used to send and receive messages between the iOS device and the paired watch.
    Please note that the session may not be supported, so it should be checked with
    `session.isSupported()` first; and if it is, then it must be activated with `session.activate()`
    before any messages can be sent or received. Incoming messages are routed to the
    associated `delegate`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The watch can also persist data using the session's `watchDirectoryURL`, which
    returns the location that temporary data can be written to. This can be used to
    add additional information which is loaded at startup. For example, the GitHubAPI
    could cache the API once it has been initially retrieved, then used for subsequent
    requests, and reloaded automatically if necessary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Appropriate use of complications and glances
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The watch's interface predominantly uses different types of widgets for different
    interactions. A *complication* is a small utility widget that's displayed on the
    screen of the watch face (for example, the rising sun or a stopwatch timer). A
    *notification* is a small brief information update (similar to the notifications
    on iOS such as an incoming message), which can be used to perform simple actions
    (such as responding with a yes/no/maybe) or to launch the full application. A
    *glance* is a simple location-derived item that may give the user a way of telling
    them that something is nearby when they raise their wrist.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of application created, there may be appropriate ways
    that these can be used in order to give the user specific information on demand.
    However, they shouldn't be used just for the sake of using them; if they aren't
    going to provide any useful information, they should not be used.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: There are also other ways of interacting with the application; for example,
    watchOS 2 has support for direct interaction of the digital crown and force pushes.
    For more information, see the Apple Watch Human Interface Guidelines.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Watch applications can run code in the same way that they run on an iOS device
    although the way in which they are uploaded to the watch is slightly different.
    Running code on the simulator is very different to running on a real device; the
    network and processor are much more limited than will be expected for a desktop
    class machine (or even an iOS device). As a result, testing on a real device is
    essential in order to test the full experience.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presented how watch applications and extensions are built, how
    they are packaged in the form of watch extensions and watch apps, and how they
    can share code with a parent application to avoid code duplication. The watch
    interface demonstrated how to transition between screens using segues to implement
    a watch extension of the iOS application that was created in the previous chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. References to Swift-related Websites, Blogs, and Notable Twitter
    Users
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning any language initially focuses on the syntax and semantics of the language,
    but it quickly moves on to learning the suite of both standard and additional
    libraries that allow programmers to be productive. A single book cannot hope to
    list all possible libraries that will be needed; this book is intended to be the
    start of a learning journey.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: For further reading, this appendix presents a number of additional resources
    that may be useful to the reader in order to continue this journey. In addition,
    look out for other books by Packt Publishing that present different aspects of
    Swift. This list of resources is necessarily incomplete; new resources will become
    available after the publication of this book, but you may be able to find new
    developments as they occur by following the feeds and posts of the resources given
    here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Language
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Swift language is developed by Apple, and a number of documents are available
    from the Swift developer page at [https://developer.apple.com/swift/](https://developer.apple.com/swift/).
    This includes a language reference guide and an introduction to the standard library:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The Swift programming language can be found at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Swift standard library reference can be found at [https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/](https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Swift and Cocoa can be found at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swifter provides a list of all Swift functions at [http://swifter.natecook.com](http://swifter.natecook.com)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Swift language was open sourced in December 2015 and has a new home at [https://swift.org](https://swift.org),
    along with the new Swift blog at [https://swift.org/blog/](https://swift.org/blog/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Twitter users
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of active Twitter users that use Swift; in many cases posts
    will be marked with the `#swift` hashtag, and can be found at [http://twitter.com/search?q=%23swift](http://twitter.com/search?q=%23swift).
    Popular users that the author follows include (in alphabetical Twitter handle
    name):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '`@AirspeedSwift:` This twitter has a good selection of tweets and retweets
    of Swift-related subjects'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ChrisEidhof`: This is author of the *Functional Swift* book and `@objcio`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CodeWithChris`: This twitter is a collection of tutorials on iOS programming'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CodingInSwift:` This twitter contains cross-posts by a collection of Swift
    resources'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CompileSwift`: This twitter contains posts on Swift'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@cwagdev`: Chris Wagner writes some of the iOS tutorials with Ray Wenderlich'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@FunctionalSwift`: This is a selection of functional snippets, along with
    a Functional Swift book'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@LucasDerraugh`: This is the creator of video tutorials on YouTube'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NatashaTheRobot:` This twitter contains a great summary of what''s happening,
    along with newsletters and cross references'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@nnnnnnnn`: Nate Cook, who reviewed an earlier version of this book and provides
    the Swifter list just mentioned'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PracticalSwift`: This is a good collection of blog posts talking about the
    Swift language'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@rwenderlich`: Ray Wenderlich has many posts relating to iOS development;
    a wealth of information and more recently Swift topics as well'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SketchyTech`: This is a collection of blog posts on Swift'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SwiftCastTV`: These are video tutorials of Swift'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SwiftEssentials`: This is the twitter feed for this book'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SwiftLDN`: This Twitter posts Swift meetups based in London, also invites
    great Swift talks and presenters'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the Swift-focused Twitter users, there are a number of other
    Cocoa (Objective-C) developers who blog regularly on topics relating to the iOS
    and OS X platforms. Given that any Objective-C framework can be integrated into
    a Swift app (and vice versa), quite often, there will be useful information from
    reading these posts:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`@Cocoanetics`: Oliver Drobnik writes about iOS and provides training'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CocoaPods`: CocoaPods is a dependency management system for Objective-C frameworks
    (pods) and is being extended into the Swift domain'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Mattt`: Mattt Thompson writes about many iOS subjects, is the author of the
    AFNetworking and AlamoFire networking libraries, and who moved to Apple to write
    the Swift package manager'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@MikeAbdullah`:Mike Abdullah writes about general iOS development'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@MikeAsh`: Mike Ash knows everything there is to know, and what he doesn''t
    know, he finds out'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@MZarra`: Marcus S. Zarra has written a lot about Core Data and synching'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NSHipster`: This is a collection of assembled iOS and Cocoa posts that are
    organised by Mattt Thompson'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@objcio`: This is a monthly publication on Objective-C topics with some Swift'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PerlMunger`: Matt Long posts about Swift, Cocoa, and iOS'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reviewers of this book included:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`@AnilVrgs`: Anil Varghese'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Ant_Bello`: Antonio Bello'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ArvidGerstmann`: Arvid Gerstmann'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@jiaaro`: James Robert'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@nnnnnnnn`: Nate Cook'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The author''s personal and book twitter accounts are:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`@AlBlue` is the author''s twitter account'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SwiftEssentials` is the book''s twitter account'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meetups such as `@SwiftLdn` keep a track of interesting Swift writers in a Twitter
    list at [https://twitter.com/SwiftLDN/lists/swift-writers/members](https://twitter.com/SwiftLDN/lists/swift-writers/members),
    which may have more up-to-date recommendations than this section, as well as the
    Ray Wenderlich team at [https://twitter.com/rwenderlich/lists/raywenderlich-com-team/members](https://twitter.com/rwenderlich/lists/raywenderlich-com-team/members).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Blogs and tutorial sites
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of blogs that cover Swift and related technologies. Here
    are a selection that you may be interested in:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/)
    is the official Apple Swift blog'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://airspeedvelocity.net](http://airspeedvelocity.net) is the blog for
    `@AirspeedSwift`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://alblue.bandlem.com/Tag/swift/](http://alblue.bandlem.com/Tag/swift/)
    is the author''s blog on Swift'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mikeabdullah.net](http://mikeabdullah.net) is Mike Abdullah''s blog'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mikeash.com](http://mikeash.com) writes the Friday Q&A series on all
    things iOS and OS X'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://natecook.com/blog/tags/swift/](http://natecook.com/blog/tags/swift/)
    is Nate Cook''s blog on Swift'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://nshipster.com](http://nshipster.com) is the blog for `@NSHipster`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://objc.io](http://objc.io) is the blog for `@objcio`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://practicalswift.com](http://practicalswift.com) is collected by `@PracticalSwift`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://sketchytech.blogspot.co.uk](http://sketchytech.blogspot.co.uk) is a
    collected blog of Swift articles by `@SketychTech`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://swiftessentials.org](http://swiftessentials.org) is the companion site
    for this book, along with the repository at [https://github.com/alblue/com.packtpub.swift.essentials/](https://github.com/alblue/com.packtpub.swift.essentials/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://swiftnews.curated.co](http://swiftnews.curated.co) is collected by
    `@NatashaTheRobot`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cimgf.com](http://www.cimgf.com) presents a collection of topics
    on Cocoa, by Marcus S Zarra and others'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.raywenderlich.com](http://www.raywenderlich.com) has a collection
    of tutorials about iOS development, including both Cocoa and Swift'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meetups
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of local iOS developer groups existed before Swift was created; they
    have since been supplanted by Swift-specific groups. These will of course vary
    by geographic location, but a few meetup sites exist, such as EventBrite at [http://www.eventbrite.co.uk](http://www.eventbrite.co.uk),
    and Meetup at [http://www.meetup.com](http://www.meetup.com).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: There are also likely to be Twitter groups or meetups near you; for example,
    in London, there is `@SwiftLDN` at [https://twitter.com/SwiftLDN](https://twitter.com/SwiftLDN)
    who have regular meetings listed at [http://www.meetup.com/swiftlondon/](http://www.meetup.com/swiftlondon/).
    In New York, the [http://www.meetup.com/NYC-Swift-Developers/](http://www.meetup.com/NYC-Swift-Developers/)
    group is fairly active. In San Francisco, both [http://www.meetup.com/swift-language/](http://www.meetup.com/swift-language/)
    and [http://www.meetup.com/San-Francisco-SWIFT-developers/](http://www.meetup.com/San-Francisco-SWIFT-developers/)
    are active.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你附近可能也有Twitter群组或聚会；例如，在伦敦，有`@SwiftLDN`在[https://twitter.com/SwiftLDN](https://twitter.com/SwiftLDN)，他们定期在[http://www.meetup.com/swiftlondon/](http://www.meetup.com/swiftlondon/)列出会议。在纽约，[http://www.meetup.com/NYC-Swift-Developers/](http://www.meetup.com/NYC-Swift-Developers/)群组相当活跃。在旧金山，[http://www.meetup.com/swift-language/](http://www.meetup.com/swift-language/)和[http://www.meetup.com/San-Francisco-SWIFT-developers/](http://www.meetup.com/San-Francisco-SWIFT-developers/)都是活跃的。
- en: Afterword
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后记
- en: '*A journey of a thousand miles begins with a single step*. Your journey to
    writing great Swift applications has just begun. As with any journey, traveling
    companions can provide support, assistance, and encouragement; and many of the
    companions given here can provide connections to many more. I hope you enjoy your
    journey.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*千里之行，始于足下*。你编写优秀的Swift应用程序的旅程才刚刚开始。就像任何旅程一样，旅伴可以提供支持、帮助和鼓励；这里提到的许多旅伴可以为你提供通往更多资源的连接。我希望你享受你的旅程。'
