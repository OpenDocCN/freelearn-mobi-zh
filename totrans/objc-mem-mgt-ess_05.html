<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Managing Your Application Data"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Managing Your Application Data</h1></div></div></div><p class="calibre8">In this chapter, you will be introduced to the concept of managing your<a id="id104" class="calibre1"/> application data to ensure that your application will perform at an optimal level during runtime. The following topics will be covered:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Resource optimization</li><li class="listitem">Disk and memory caching</li><li class="listitem">Serialization</li><li class="listitem">Different forms of data saving</li><li class="listitem">Pros and cons of various data saving methods</li></ul></div><p class="calibre8">We will also cover some common pitfalls and assumptions that people commonly associate with the development of iOS applications. One example will be image loading, where if the developers are not careful in planning the proper architecture of their application, they will encounter situations where the application will lag or run out of memory and lead to an application crash.</p></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Managing Your Application Data">
<div class="book" title="Device memory"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec40" class="calibre1"/>Device memory</h1></div></div></div><p class="calibre8">As with <a id="id105" class="calibre1"/>all computing devices, iPads and iPhones have <a id="id106" class="calibre1"/>a finite amount of memory and you may be tempted to develop applications without any concern about the memory usage. Doing so is not ideal for development as memory optimizing and management should always be at the top of your mind when doing any type of development, regardless of whatever platform you will be developing on. </p><p class="calibre8">Let's take a look at the amount of memory that each of the iOS devices have, and we will start with iPhones:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18"> </th><th valign="bottom" class="calibre18">
<p class="calibre19">iPhone 4S</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPhone 5</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPhone 5C</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPhone 5S</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<span><strong class="calibre24">RAM</strong></span>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">512 MB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">1 GB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">1 GB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">1 GB</p>
</td></tr></tbody></table></div><p class="calibre8">Here is the RAM for iPads:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18"> </th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad Air</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad Mini 2</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad Mini Wi-Fi + Cellular</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad 2 Wi-Fi + 3G</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad Mini Wi-Fi</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad 3 Wi-Fi</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad 3 Wi-Fi + Cellular</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad 4 Wi-Fi</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">iPad 2 Wi-Fi</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<span><strong class="calibre24">RAM</strong></span>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">1 GB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">1 GB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">512 MB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">512 MB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">512 MB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">1 GB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">1 GB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">1 GB</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">512 MB</p>
</td></tr></tbody></table></div><p class="calibre8">Now, the amount of memory does look impressive as you fondly remember the days of old, where your old<a id="id107" class="calibre1"/> desktop ran on 256 MB of RAM, but do remember that iOS does not let you play with the full 512 MB or 1 GB RAM. The OS will allocate some to system processes in your device, and you will only get a subset of the available RAM for your application.</p><p class="calibre8">In your<a id="id108" class="calibre1"/> application, everything will occupy memory and storage space. Some of the biggest culprits are binary assets, such as videos and images, which can be total resource hogs to even your class objects that can take up precious space if you do not take note of them when doing your development. So, let's start with image optimization as almost every application will make use of images in one way or another. </p></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Managing Your Application Data">
<div class="book" title="Device memory">
<div class="book" title="Image optimization"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec11" class="calibre1"/>Image optimization</h2></div></div></div><p class="calibre8">Any<a id="id109" class="calibre1"/> application will look boring and drab without the usage of <code class="email">.png</code> and some nice images. However, one thing about images is that they take up much more memory than their file size implies. A single 1 MB <code class="email">.png</code> file can occupy double or triple their memory size when loaded into the memory. The reason is because PNG is basically a compressed file format, such as a ZIP file. So, all the image data is compressed into a PNG file and when your application needs to display your PNG image. It needs to load the PNG file into memory, uncompress it, and then it will be able to get the image data to be used by your code and will consume more memory in the process. So, if your application has 20 MB of PNG files, you are easily looking at 40 MB or more of RAM allocation just for images. So, a few <a id="id110" class="calibre1"/>tips for image optimization are:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Save your image as PNG-8 instead of PNG-24 as PNG-8 consumes less RAM than their equivalent PNG-24. Only use PNG-24 if you need the alpha channel for transparency. The difference between PNG-8 and PNG-24 is the image quality and the number of colors that you can have. The 8 and 24 means 8-bits per pixel and 24-bits per pixel respectively. So, PNG-8 can only support up to 256 colors while PNG-24 can support up to 16 million colors, so PNG-24 is the best option if you need to display images with a lot of colors <a id="id111" class="calibre1"/>such as photographs, while logos and user interface elements such as icons can probably get by with PNG-8. PNG-24 also supports alpha transparency, which is good for images that need to have a transparent background. So, knowing which format to use in which situation will help you in reducing the memory consumption of your application.</li><li class="listitem">If you can use JPG files, then use them as they are a lossy format, and it means that you will get a bit of image degradation, but generally the image degradation is almost invisible to the naked eye. However, note that JPG files do not support alpha transparency.</li></ul></div><p class="calibre8">PNG is a<a id="id112" class="calibre1"/> lossless format, which means that there is no image degradation when you use PNG files, but it comes at a price that it consumes more RAM when loaded into your device compared to a JPG, which is a lossy format.</p><p class="calibre8">So, keep PNG files and JPG files to an absolute minimum if you can and only use them if you have to.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Managing Your Application Data">
<div class="book" title="Device memory">
<div class="book" title="Lazy loading"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec12" class="calibre1"/>Lazy loading</h2></div></div></div><p class="calibre8">What<a id="id113" class="calibre1"/> is<a id="id114" class="calibre1"/> lazy loading? It is a design pattern or a way of doing things in software design where you load a resource such as a PNG, MP3 file, and so on only at the time when it is needed. This helps to mitigate the problem of insufficient memory instead of loading all your resources at once. You only load it when you need it in a "lazy" manner. There is also one more advantage, that is, it minimizes the start up time of your application since you only load the resources on demand and this takes less time to load. So, you gain a speed boost in terms of time.</p><p class="calibre8">Imagine you have multiple UIViews where each view has 10 UIImages, but only one view can be seen at any one time. Without proper thought, you will be tempted to write code to load all 10 UIImages for all the UIViews at once. However, upon further reflection, the question arises as to whether there is a need to do so. It would be better if you refactor your code to load the 10 UIImages only when that UIView is visible to the user and then clean it up once the user is not viewing it and load the next batch of UIImages from the next UIView, which will be visible to the user. This will add a bit more of coding for you, but the trade-off in terms of efficient memory usage will be worth it.</p><p class="calibre8">This is one of the <a id="id115" class="calibre1"/>simplest implementations where we just override the getter method of a class:</p><div class="informalexample"><pre class="programlisting">- (A_Class *)aObject {
    if (aObject == nil) {//Check if the object exists and if not
        aObject = [[A_Class alloc] init];//then create the object
    }
 
    return aObject;//returns the object
}</pre></div><p class="calibre8">You can put<a id="id116" class="calibre1"/> the preceding code in place of the normal getter method of your class. The preceding code checks whether the object does or does not exists, and if it does not exist, then it will create the object. However, if the object already exists, then it will not create it again.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Managing Your Application Data">
<div class="book" title="Device memory">
<div class="book" title="Control creation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec13" class="calibre1"/>Control creation</h2></div></div></div><p class="calibre8">Controls <a id="id117" class="calibre1"/>are<a id="id118" class="calibre1"/> part and parcel of every iOS application and they also consume memory on your device and every instance will consume bytes and bits of memory. When you are creating a lot of <code class="email">UITableViewCell</code> class, for example, you will be looking at a control that is consuming a lot of memory sooner or later.</p><p class="calibre8">Also, tasks <a id="id119" class="calibre1"/>such as loading images and getting data from a remote server are considered as slow processes and will slow down your application. I am sure that you have used iOS apps where when you scroll down a <code class="email">UITableView</code> view object you will see a noticeable lag as new images are loaded into the newly revealed cells. In this world, where people are used to images loading quickly on their desktop and mobile phones, such slowness and laggy UI are not acceptable and can mean the difference between a user staying engaged with your application or uninstalling your application.</p><p class="calibre8">The fundamental mantra is that you must not let your users wait for 1 second or even 1 millisecond more than what is absolutely necessary. One tip to compensate for the perceived slowness of an application is to have a simple animation such as fading in an image after showing a spinner in order to give the user the perception that the application is not actually very slow since there is an animation playing.</p><p class="calibre8">Reusing<a id="id120" class="calibre1"/> your controls is a must if you are experiencing huge memory usage, which is impacting the usability of your iOS application. Later on, we will cover how to use<a id="id121" class="calibre1"/> the tool called <span class="strong"><strong class="calibre2">Instrument</strong></span> in Xcode to monitor the memory usage. Creating objects is an expensive process and has a performance cost. </p><p class="calibre8">If you need to create an object on the fly over a short period of time, such as scrolling quickly through a <code class="email">UITableView</code> view object, you will experience some lag as your code will be creating new <code class="email">UITableViewCell</code> class instead of reusing old ones.</p><p class="calibre8">Reusing <code class="email">UITableViewCell</code> is a lot faster and will enhance the performance of your application. Luckily, Apple has already created code for us to reuse a cell, which can be implemented easily with a few lines of code. So, let's look at the <code class="email">dequeueReusableCellWithIdentifier</code> method as a good example with the following code:</p><div class="informalexample"><pre class="programlisting">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"Cell"];
    if (!cell) {
        //create a new cell
    }

    //Do what we need with our cell here

    return cell;
}</pre></div><p class="calibre8">Looking at the preceding code, you can see that we attempt to assign a cell using the <code class="email">dequeueReusableCellWithIdentifier</code> method, then it will return a pointer to that cell if it already exists. Next, our code (<code class="email">!cell</code>) will check whether that pointer is not nil, then it will create the cell. This is the exact same technique we used in the previous section <span class="strong"><em class="calibre9">Lazy loading</em></span>, except that we apply this technique to an iOS control, which in this case, is a <code class="email">UITableViewCell</code> object. These few lines of code serve three functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">This helps to prevent a situation where your app is lagging when you are scrolling up as it eliminates the need to create new instances of <code class="email">UITableViewCell</code>.</li><li class="listitem">If you have 1,000 rows of data and only 4 rows are visible on screen at any given time, then it makes no sense to create 1,000 <code class="email">UITableViewCell</code> when you only need to create five. A few other cells can be partially visible and hence need to be created too. So, the five cells will only be created as it needs to be visible to the user while the remaining cells are not loaded.</li><li class="listitem">While a single <code class="email">UITableViewCell</code> class occupies a lot of memory, storing 1,000 of them is not <a id="id122" class="calibre1"/>easy, and through a few extra lines of code, you can avoid unnecessary memory usage and use the memory you save for other parts of your code.</li></ul></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Caching"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec41" class="calibre1"/>Caching</h1></div></div></div><p class="calibre8">Caching <a id="id123" class="calibre1"/>is a<a id="id124" class="calibre1"/> concept where you store resources on disk or memory for faster access. Caching will occupy more space, but in situations where you need to worry more about loading speed than memory, caching can be a very good technique to use. Consider this common scenario:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Downloading a large file such as an image or even a movie</li><li class="listitem">Write the file to a disk</li><li class="listitem">Read the files from the disk and display them</li></ul></div><p class="calibre8">If you follow the normal method as mentioned earlier, a bottleneck that you will face is slow loading of the file from disk. Disk access can be as slow as 10,000 or even 1,000,000 slower than memory access and it won't make a good user experience as the user will be kept waiting while your app is loading the files from disk. Caching will help slow this problem as your file is saved to memory where read access is faster.</p><p class="calibre8">This is good from a user point of view as they do not need to wait a long time for the file to be loaded and can help to optimize the user experience of your application since every second wasted can lead to the user moving away from your application. Caching on disk or memory has its pros and cons as illustrated in the following table:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18"> </th><th valign="bottom" class="calibre18">
<p class="calibre19">Disk</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Memory</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<span><strong class="calibre24">Storage</strong></span>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Persistent, as data is not lost when device is switched off</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Ephemeral, as data is lost when device is switched off</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<span><strong class="calibre24">Speed</strong></span>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Slow</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Fast</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<span><strong class="calibre24">Storage size</strong></span>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Large</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Small, as memory is generally lesser than disk storage</p>
</td></tr></tbody></table></div><p class="calibre8">So as a rule of thumb, it will be best to do all caching on memory first and then move to caching on disk only when your application is running low on memory or you experience memory warning errors. If you are downloading large files such as movies, you will need to store the movie file on disk since the file normally will not be able to fit into memory.</p><p class="calibre8">As a sidenote, caching <a id="id125" class="calibre1"/>uses a few algorithms for implementation, such as <span class="strong"><strong class="calibre2">Most Recently Used</strong></span> (<span class="strong"><strong class="calibre2">MRU</strong></span>) or <span class="strong"><strong class="calibre2">Least Recently Used</strong></span> (<span class="strong"><strong class="calibre2">LRU</strong></span>). MRU means the cache will discard the most recently used items first when the cache is full, while LRU is the reverse opposite where the least recently used items will be discarded instead. The implementation strategy is out of the scope of this book and it is up to the manufacturer to decide.</p><p class="calibre8">Fortunately, we do not need to write a lot of code to implement efficient caching. There are a few iOS caching libraries that we can use and they are available for us to use. So, in this section, we will look at one of the most popular caching libraries.</p></div>

<div class="book" title="Caching">
<div class="book" title="SDWebImage"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec14" class="calibre1"/>SDWebImage</h2></div></div></div><p class="calibre8">The first<a id="id126" class="calibre1"/> library<a id="id127" class="calibre1"/> we will be looking at is called SDWebImage. The source code can be downloaded via a Git clone from <a class="calibre1" href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a>, and <a id="id128" class="calibre1"/>it comes with a demo project too. So, let's look at the important parts of this demo project. I have summarized the steps for you:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the Xcode project.</li><li class="listitem" value="2">Open up <code class="email">masterviewcontroller</code>.</li><li class="listitem" value="3">Import <code class="email">UIImageView</code>+<code class="email">WebCache.h</code>.</li><li class="listitem" value="4">Look for the <code class="email">cellforrowatindexpath</code> method.</li><li class="listitem" value="5">Call this method <code class="email">setImageWithURL:placeholderImage</code>.</li></ol><div class="calibre22"/></div><p class="calibre8">Now, let's look into each of these steps in detail:</p><p class="calibre8">Open the <code class="email">SDWebImage Demo.xcodeproj</code> project and run it. You should see the following screen, which is a list of table view cells with images and text:</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="SDWebImage" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">If you tap<a id="id129" class="calibre1"/> on a<a id="id130" class="calibre1"/> table view cell, it will show this screen, which shows the larger size of the image that you tapped on:</p><div class="mediaobject"><img src="../images/00025.jpeg" alt="SDWebImage" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Next, open<a id="id131" class="calibre1"/> up <code class="email">MasterViewController</code> and look for the following <a id="id132" class="calibre1"/>piece of code:</p><div class="informalexample"><pre class="programlisting">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier = @"Cell";
    
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil)
    {
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];
    }

    cell.textLabel.text = [NSString stringWithFormat:@"Image #%d", indexPath.row];
    cell.imageView.contentMode = UIViewContentModeScaleAspectFill;
    [cell.imageView setImageWithURL:[NSURL URLWithString:[_objects objectAtIndex:indexPath.row]]
                   placeholderImage:[UIImage imageNamed:@"placeholder"] options:indexPath.row == 0 ? SDWebImageRefreshCached : 0];
    return cell;
}</pre></div><p class="calibre8">This is where the code will get the image from the server and then cache it on the device.</p><p class="calibre8">To implement<a id="id133" class="calibre1"/> this in your own code, you need to import <code class="email">UIImageView</code>+<code class="email">WebCache.h</code> and then call the <code class="email">setImageWithURL:placeholderImage</code>: method, where you can add in your own placeholder PNG and JPG image to replace <code class="email">@"placeholder"</code>.</p><p class="calibre8">So, when you run <a id="id134" class="calibre1"/>the app again you will notice that images are not pulled from server again, but are instead served from the cache on the device, so you will see that the images load faster as a result.</p></div></div>

<div class="book" title="Caching">
<div class="book" title="Object serialization"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec15" class="calibre1"/>Object serialization</h2></div></div></div><p class="calibre8">What<a id="id135" class="calibre1"/> is serialization? This<a id="id136" class="calibre1"/> is a question that a lot of people find hard to explain or understand. Serialization is the method or concept where we convert data structures or objects into a format <a id="id137" class="calibre1"/>for it to be stored in memory or disk for storage, or to be transmitted across a network link. It can also assist in memory management as it provides an alternative mechanism where we save some files to disk instead of memory, which is usually the case for big files, such as movie files. Serialization formats include JSON, XML, YAML, and so on. And luckily for iOS developers, Apple <a id="id138" class="calibre1"/>provides us with a robust framework that helps us take away the low-level code when we want to do serialization. So, when we want to store our data structures or objects in memory or disk, we can use Apple's frameworks such as Core Data or NSCoding, which provides an abstraction layer and hides away the lower-level coding for us.</p><p class="calibre8">When it comes<a id="id139" class="calibre1"/> to data saving or serialization, we tend to stick with the one method that we are most familiar with. However, this is not a good way of doing things as various methods have their pros and cons, and we should consider our use case before we decide on the best method. To this extent, Apple has provided us with a few different methods for data serialization and it is up to us, the developers, to decide which method suits us best. One of the simplest ways is to use NSCoding. What is NSCoding? NSCoding is basically a protocol provided by Apple for you to encode and decode your data into a buffer, which can then be persisted to disk for persistent storage.</p><p class="calibre8">Usage of the <code class="email">NSCoding</code> protocol also involves the <code class="email">NSKeyedArchiver</code> and <code class="email">NSKeyedUnarchiver</code> methods as <code class="email">NSCoding</code> is a protocol with delegate methods for serializing our data structure and custom object into a format that can be stored in memory or disk.  <code class="email">NSKeyedArchiver</code> and <code class="email">NSKeyedUnarchiver</code> are the methods that will actually do the work of storing our serialized data into disk for persistent storage. So to kick things off, we will use an example to help us understand how serializing and archiving works for iOS applications.</p><p class="calibre8">Use the listed steps for the following example:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add the <code class="email">NSCoding</code> protocol to your custom object.</li><li class="listitem" value="2">Implement <code class="email">encodeWithCoder</code> and <code class="email">initWithCoder</code> and assign the values you wish to store.</li><li class="listitem" value="3">Call the <code class="email">archiveRootObject</code> and <code class="email">unarchiveObjectWithFile</code> methods to save your serialized data to disk and load it from the disk respectively.</li><li class="listitem" value="4">For example, we create a custom object called <code class="email">OurCustomObject</code>, and then to use the <code class="email">NSCoding</code> protocol, we need to add it to our interface declaration:<div class="informalexample"><pre class="programlisting">@interface OurCustomObject : NSObject &lt;NSCoding&gt;
{
    bool isReset;
    NSString *userName;
    int score;
}
@property (nonatomic, retain) NSString *userName;
@property (nonatomic, assign) bool  isReset;
@property (nonatomic, assign) int score;
@end</pre></div></li><li class="listitem" value="5">Then, we <a id="id140" class="calibre1"/>need to write the <code class="email">encodeWithCoder</code> method to save the data:<div class="informalexample"><pre class="programlisting">- (void)encodeWithCoder:(NSCoder *)coder {
    //do encoding to save the data
    [coder encodeBool:isReset forKey:@"isReset"];
    [coder encodeObject:userName    forKey:@"userName"];
    [coder encodeInt:score forKey:@"score"];
}
To load the data back into our objects, we add in the initWithCoder method:
- (id)initWithCoder:(NSCoder *)decoder {
    if (self = [super init]) {
        self.isReset = [decoder decodeBoolForKey:@"isReset"];
        self.userName = [decoder decodeObjectForKey:@"userName"];
        self.score = [decoder decodeIntForKey:@"score"];
    }
    return self;
}</pre></div></li><li class="listitem" value="6">Now that we<a id="id141" class="calibre1"/> have the code to encode and decode the data into a serialized format, we need to put in the actual code to save it to disk on our device, so we can use <code class="email">NSKeyedArchiver</code> to do the actual writing to disk, while we use <code class="email">NSKeyedUnarchiver</code> to get the data from the disk:<div class="informalexample"><pre class="programlisting">OurCustomObject *ourObj = [[OurCustomObject alloc] init];
    ourObj.userName = @"John Doe";
    ourObj.isReset   = true;
    ourObj.score = 99;    
   //get our file path
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectoryPath = [paths objectAtIndex:0];
    NSString *filePath = [documentsDirectoryPath stringByAppendingPathComponent:@"OurData"];
    [NSKeyedArchiver archiveRootObject: ourObj toFile:filePath];</pre></div></li><li class="listitem" value="7">Then to load our object from disk, we just use the following code:<div class="informalexample"><pre class="programlisting">    OurCustomObject *ourObj2 = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];
    NSLog(@"Score is %d", [ourObj2 score]);
    NSLog(@"Name is %@", [ourObj2 userName]);</pre></div></li></ol><div class="calibre22"/></div><p class="calibre8">There is no<a id="id142" class="calibre1"/> need<a id="id143" class="calibre1"/> to call <code class="email">initWithCoder</code> and <code class="email">encodeWithCoder</code> anywhere in our code as those method calls are called when you call <code class="email">unarchiveObjectWithFile</code> and <code class="email">archiveRootObject</code>. However, you need to implement <code class="email">initWithCoder</code> and <code class="email">encodeWithCoder</code> as these two methods need to contain the necessary code to encode and decode the <code class="email">isReset</code>, <code class="email">userName</code>, and <code class="email">score</code> variables that form <code class="email">OurCustomObject</code>. As you can see, <code class="email">NSCoding</code> is a relatively powerful way to store data to disk compared to <code class="email">NSUserDefaults</code>, and the code is quite easy to understand and write. However, if you need more power features for data storage, NSCoding will not be the best choice and Core Data will be the better option as it has more features such as being able to perform queries, being optimized for speed, support for different serialization formats such as XML, SQLite, or NSDate, among other benefits.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="SQLite"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec42" class="calibre1"/>SQLite</h1></div></div></div><p class="calibre8">SQLite, for <a id="id144" class="calibre1"/>those familiar with <a id="id145" class="calibre1"/><span class="strong"><strong class="calibre2">Relational DataBase Management System</strong></span> (<span class="strong"><strong class="calibre2">RDBMS</strong></span>), is a<a id="id146" class="calibre1"/> database based on the relational model. A SQLiteis, a RDBMS that is available for us in iOS, has a lot of the features and functions of RDBMS that many people are familiar with, such as ACID properties, queries, and so on. Core Data is Apple's framework for data storage and you can use Core Data to store data into a SQLite database. However, there are some cases when you need to use SQLite instead <a id="id147" class="calibre1"/>of Core Data. So, I will elaborate further on this:</p><div class="book"><ul class="itemizedlist"><li class="listitem">SQLite as a database is available on multiple platforms besides iOS. So this means that if you are developing an application that runs on multiple platforms or has the possibility to run on other non-iOS platforms, SQLite will be the option for you to seriously consider since you will avoid framework lock-in using Core Data. SQLite also is faster than NSCoding, plus it adds querying functionality, which is not possible if you use <code class="email">NSUserDefaults</code>.</li><li class="listitem">Also, if you have experience with SQLite and your use case for data storage is very straightforward along with no experience with Core Data, then you should choose SQLite.</li><li class="listitem">It does not require a <span class="strong"><strong class="calibre2">Model-View-Controller</strong></span> (<span class="strong"><strong class="calibre2">MVC</strong></span>)<a id="id148" class="calibre1"/> conceptual model.</li></ul></div><p class="calibre8">Now, this does<a id="id149" class="calibre1"/> not mean that SQLite should be the default data storage solution for you when you need to store data to disk. This is because there are other options such as Core Data and various other factors such as speed and ease of coding, which will play a big part in your decision-making as we will see later in this chapter and the chapter on Core Data later on.</p></div>

<div class="book" title="SQLite">
<div class="book" title="SQLite versus Core Data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec16" class="calibre1"/>SQLite versus Core Data</h2></div></div></div><p class="calibre8">Core Data<a id="id150" class="calibre1"/> is a rich <a id="id151" class="calibre1"/>and sophisticated <a id="id152" class="calibre1"/>object graph management framework with a lot of bells and whistles that you require for complex use cases. In the <span class="strong"><em class="calibre9">Introduction to Core Data Programming Guide</em></span>, Apple mentions that the Core Data framework provides generalized and automated solutions to common tasks associated with object life cycle and object graph management, including persistence, which means it prevents you from writing a lot of code to do your everyday data storage tasks.</p><p class="calibre8">Core Data uses models that are your objects and these are the model in the commonly used MVC architecture. These enable you to store whole objects and it ties in very closely with the controller and view classes of your iOS application. So, developers who are using MVC architectures will have no problem absorbing the Core Data concepts and models.</p><p class="calibre8">The tools for development using the Core Data framework is tied in deeply into Xcode and it enables developers to quickly write code and lay out their data models in a fast and efficient manner, and thus, save you time, which allows you to spend it on other parts of the project.</p><p class="calibre8">Core Data framework is also available for the Mac OS, and this enables reusability of your code if you intend to create a Mac version of your application.</p><p class="calibre8">With Apple's iCloud storage and computing platform, you can use Core Data to take advantage of iCloud to sync your application and user data across multiple devices such as iPads and so on. iOS 8 has tighter integration with iCloud with the introduction of the CloudKit framework, which has new functionality such as allowing partial download of datasets and all this is only possible using Core Data.</p><p class="calibre8">SQLite<a id="id153" class="calibre1"/> is a pure<a id="id154" class="calibre1"/> RDBMS and many people confuse Core Data with SQLite. SQLite is a RDBMS, pure and simple. So, it has a lot of the features that you will associate with RDBMSes, such as ACID properties, queries, and so on. However, that is where it ends. Core Data is an abstraction layer on top of a data store, which can be SQLite or other forms of data persistence, such as XML files. So, using Core Data will still enable you to store data in SQLite, but there will be some occasions when you prefer to use SQLite over Core Data.</p><p class="calibre8">If data portability is <a id="id155" class="calibre1"/>an important feature for you, then using SQLite should be your preferred choice as SQLite is platform-independent, while Core Data is for Apple platforms only. So, if you use SQLite, you can be assured that your data files can be moved and accessed on almost any platform that supports SQLite, not only Apple-supported platforms.</p><p class="calibre8">Core Data ultimately is an abstraction layer between your code and the database. However, sometimes you want to get down to the lower levels of your code and avoid abstraction layers to understand how the code works. So, using SQLite will allow you to do that, as it allows you to do low level optimization if you are working with large datasets. Core Data can also be used to abstract the Sqlite access to save on development time and make your code cleaner.</p><p class="calibre8">Ultimately, there are no hard and fast rules on when and where to use Core Data or SQLite. On every engineering project, there are questions and decisions to be made, which encompass factors such as amount of resources and platform scalability since Core Data only supports Apple platforms and if you intend to support non-Apple platforms. Core Data might not be a good choice. So, using the Core Data framework allows you to have a rapid solution for simple applications, but it also ties you into Apple's framework, which impedes data portability as if you create an application where a user's data such as game data needs to be present on another non-Apple device. You will encounter a technical lock-in if you use Core Data. </p><p class="calibre8">On the other hand, SQLite allows ease of tweaking and optimization for various reasons. In the end, the complexity of your use case, data model, and requirements of your platform will be the factors that will help you make a good decision on the right option to choose.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec43" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In summary, this chapter covered the management of your application data with regards to caching data to memory and data storage on to disk. We also covered the pros and cons of using the various storage frameworks for various situations and did a few code examples on using the NSCoding protocol and the SDWebImage open source caching framework.</p><p class="calibre8">This chapter covers a bit of Core Data, which will help us in the next chapter as we deep dive into Core Data along with some code examples. The next chapter will be all about Core Data and its uses.</p></div></body></html>