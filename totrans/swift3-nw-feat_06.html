<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Extra, Extra Collection and Closure Changes That Rock!"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Extra, Extra Collection and Closure Changes That Rock!</h1></div></div></div><p>In this chapter, we are focusing on collection and closure changes in Swift 3. Collections are important to all programming languages because they allow you hold groups of related items. Closures are also important to Swift because they give you the ability to pass around functionality to be used in a different location of your code. There are several nice additions that will make working with collections even more fun. We will also explore some of the confusing side effects of creating closures in Swift 2.2 and how those have been fixed in Swift 3.</p><div class="section" title="Collection and sequence type changes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Collection and sequence type changes</h1></div></div></div><p>Let's begin our discussion with Swift 3 changes to Collection and Sequence types. Some of the changes are subtle and others are bound to require a decent amount of refactoring to your custom implementations. Swift provides three main collection types for warehousing your values: arrays, dictionaries, and sets. Arrays allow you to store values in an ordered list. Dictionaries provide unordered key-value storage for your data. Finally, sets provide an unordered list of unique values (that is, no duplicates allowed).</p><div class="section" title="Lazy FlatMap for sequence of optional [SE-0008]"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec16"/>Lazy FlatMap for sequence of optional [SE-0008]</h2></div></div></div><p>Arrays, dictionaries, and sets are implemented as generic types in Swift. They each implement the new Collection protocol, which implements the Sequence protocol. Along this path from top-level type to Sequence protocol, you will find various other protocols that are also implemented in this inheritance chain. For our discussion on <code class="literal">flatMap</code> and lazy <code class="literal">flatMap</code> changes, I want to focus on Sequences.</p><p>Sequences contain a group of values that allow the user to visit each value one at a time. In Swift, you might consider using a for-in loop to iterate through your collection. The Sequence protocol provides implementations of many operations that you might want to perform on a list using sequential access; all of which you can override when you adopt the protocol in your custom collections. One such operation is the <code class="literal">flatMap</code> function, which returns an array containing the flattened, or rather concatenated, values resulting from a transforming operation applied to each element of the sequence. Let's consider how we could use the <code class="literal">flatMap</code> method.</p><pre class="programlisting">let scores = [0, 5, 6, 8, 9] &#13;
         .flatMap{ [$0, $0 * 2] } &#13;
print(scores)  // [0, 0, 5, 10, 6, 12, 8, 16, 9, 18] &#13;
</pre><p>In our example above, we take a list of scores and call <code class="literal">flatMap</code> with our transforming closure. Each value is converted into a sequence containing the original value and a doubled value. Once the transforming operations complete, the <code class="literal">flatMap</code> method flattens the intermediate sequences into a single sequence.</p><p>We can also use the <code class="literal">flatMap</code> method with <span class="emphasis"><em>Sequences</em></span> that contain optional values to accomplish a similar outcome. This time we are omitting values from the Sequence we flatten by return nil on the transformation. In the next example, we use the <code class="literal">flatMap</code> method to remove all nil values from our collection.</p><pre class="programlisting">let oddSquared = [1, 2, 3, 4, 5, 10].flatMap { n in &#13;
    n % 2 == 1 ? n*n : nil &#13;
} &#13;
print(oddSquared) // [1, 9, 25] &#13;
</pre><p>The previous two examples were fairly basic transformations on small sets of values. In a more complex situation, the collections that you need to work with might be very large with expensive transformation operations. Under those parameters, you would not want to perform the <code class="literal">flatMap</code> operation or any other costly operation until it was absolutely needed. Luckily, in Swift we have lazy operations for this use case. Sequences contain a <code class="literal">lazy</code> property that returns a <code class="literal">LazySequence</code> that can perform lazy operations on Sequence methods. Using our first example above, we can obtain a lazy sequence and call <code class="literal">flatMap</code> to get a lazy implementation. Only in the lazy scenario, the operation isn't completed until scores is used sometime later in code. To demonstrate lazy operations, we define a collection that uses the <code class="literal">lazy</code> property with our <code class="literal">flatMap</code> method.</p><pre class="programlisting">let scores = [0, 5, 6, 8, 9] &#13;
    .lazy &#13;
    .flatMap{ [$0, $0 * 2] } // lazy assignment has not executed &#13;
 &#13;
for score in scores{  &#13;
    print(score) &#13;
} &#13;
</pre><p>The <code class="literal">lazy</code> operation works as we would expect in our test above. However, when we use the <code class="literal">lazy</code> form of <code class="literal">flatMap</code> with our second example that contains optionals, our <code class="literal">flatMap</code> executes immediately in Swift 2. Using the lazy version of <code class="literal">oddSquared</code> should delay execution of our <code class="literal">flatMap</code> operation until we use the variable. However, the <code class="literal">flatMap</code> method executes immediately, as if the lazy form didn't exist..</p><pre class="programlisting">let oddSquared = [1, 2, 3, 4, 5, 10] &#13;
    .lazy               // lazy assignment but has not executed &#13;
    .flatMap { n in &#13;
    n % 2 == 1 ? n*n : nil &#13;
} &#13;
 &#13;
for odd in oddSquared{ &#13;
    print(odd) &#13;
} &#13;
</pre><p>Essentially, this was a feature in Swift that has been changed in Swift 3 to behave similar to other lazy implementations.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>You can read the proposal at the following link <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md">https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md</a>
</p></div></div></div><div class="section" title="Adding a first(where:) method to Sequence [SE-0032]"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec17"/>Adding a first(where:) method to Sequence [SE-0032]</h2></div></div></div><p>A common task for working with collections is to find the first element that matches a condition. An example would be to ask for the first student in an array of students whose test scores contain  100. You could accomplish this by using a predicate to return the filtered sequence that matched the criteria and then just give back the first student in the sequence. However, it would be much easier to just call a single method that could return the item without the two-step approach. This functionality was missing in Swift 2, but was voted in by the community and has been added for this release. In Swift 3 there is now a method on the Sequence protocol to implement <code class="literal">first(where:).</code>
</p><pre class="programlisting">["Jack", "Roger", "Rachel", "Joey"].first { (name) -&gt; Bool in&#13;
name.contains("Ro")&#13;
} // =&gt;returns Roger</pre><p>This <code class="literal">first(where:)</code> extension is a nice addition to the language because it ensures that a simple and common task is actually easy to perform in Swift.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>You can read the proposal at the following link <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md">https://github.com/apple/swift-evolution/blob/master/proposals/0032-sequencetype-find.md</a>
</p></div></div></div><div class="section" title="Add sequence(first: next:) and sequence(state: next:) [SE-0094]"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec18"/>Add sequence(first: next:) and sequence(state: next:) [SE-0094]</h2></div></div></div><p>Swift 3 introduces two new global functions that operate on sequences: <code class="literal">sequence(first:next:)</code>
</p><p> and <code class="literal">(state:next:)</code>.</p><p>Let's look at the full definitions below:</p><pre class="programlisting">public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt; &#13;
 &#13;
public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt; &#13;
 &#13;
public struct UnfoldSequence&lt;Element, State&gt; : Sequence, IteratorProtocol &#13;
</pre><p>These two functions were added as replacements to the C-style for loops that were removed in Swift 3 and to serve as a compliment to the global reduce function that already exists in Swift 2. What's interesting about the additions is that each function has the capability of generating and working with infinite sized sequences. Let's examine the first sequence function to get a better understanding of how it works:</p><pre class="programlisting">/// - Parameter first: The first element to be returned from the sequence. &#13;
/// - Parameter next: A closure that accepts the previous sequence element and &#13;
///   returns the next element. &#13;
/// - Returns: A sequence that starts with `first` and continues with every &#13;
///   value returned by passing the previous element to `next`. &#13;
/// &#13;
func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt; &#13;
</pre><p>The first sequence method returns a sequence that is created from repeated invocations of the <span class="emphasis"><em>next</em></span> parameter, which holds a closure that will be lazily executed. The return value is an <code class="literal">UnfoldSequence</code> that contains the <code class="literal">first</code> parameter passed to the sequence method plus the result of applying the <span class="emphasis"><em>next</em></span> closure on the previous value. The sequence is finite if <code class="literal">next</code> eventually returns <code class="literal">nil</code> and is infinite if <code class="literal">next</code> never returns <span class="emphasis"><em>nil</em></span>. In the example that follows, we create and assign our sequence using the trailing closure form of <code class="literal">sequence(first: next:)</code>.</p><pre class="programlisting">let mysequence = sequence(first: 1.1) { $0 &lt; 2 ? $0 + 0.1 : nil } &#13;
for x in mysequence{ &#13;
    print (x) &#13;
} // 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 &#13;
</pre><p>Our finite sequence will begin with 1.1 and will call <code class="literal">next</code> repeatedly until our next result is greater than 2 at which case <code class="literal">next</code> will return <code class="literal">nil</code>. We could easily convert this to an infinite sequence by removing our condition that our previous value must not be greater than 2. The second sequence function maintains mutable state that is passed to all lazy calls of <code class="literal">next</code> to create and return a sequence. Let's consider an example using the second method:</p><pre class="programlisting">/// - Parameter state: The initial state that will be passed to the closure. &#13;
/// - Parameter next: A closure that accepts an `inout` state and returns the &#13;
///   next element of the sequence. &#13;
/// - Returns: A sequence that yields each successive value from `next`. &#13;
/// &#13;
public func sequence&lt;T, State&gt;(state: State, next: (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt; &#13;
 &#13;
</pre><p>This version of the sequence function uses a passed in closure that allows you to update the mutable state each time <code class="literal">next</code> is called. As was the case with our first sequence function, a finite sequence ends when <code class="literal">next</code> returns a <code class="literal">nil</code>. You can turn a finite sequence into an infinite one by never returning <code class="literal">nil</code> when <code class="literal">next</code> is called.</p><p>Let's create an example of how this version of the sequence method might be used. Traversing a hierarchy of views with nested views or any list of nested types is a perfect task for using the second version of the sequence function. Let's create a an Item class that has two properties. A name property and an optional parent property to keep track of the item's owner. The ultimate owner will not have a parent, meaning the parent property will be <code class="literal">nil</code>.</p><p>Let's define an Item class to use in our example to demonstrate usage of these new concepts.</p><pre class="programlisting">class Item{ &#13;
    var parent: Item? &#13;
    var name: String = "" &#13;
} &#13;
</pre><p>Next, we create a parent and two nested children items. Parent of <code class="literal">child1</code> will be the parent item and parent of <code class="literal">child2</code>  will be <code class="literal">child1</code>.</p><pre class="programlisting">let parent = Item() &#13;
parent.name = "parent" &#13;
 &#13;
let child1 = Item() &#13;
child1.name = "child1" &#13;
child1.parent = parent &#13;
 &#13;
let child2 = Item() &#13;
child2.name = "child2" &#13;
child2.parent = child1 &#13;
</pre><p>Now it's time to create our sequence. The sequence needs two parameters from us: a <code class="literal">state</code> parameter and a <code class="literal">next</code> closure. I made the state an <code class="literal">Item</code> with an initial value of <code class="literal">child2</code>. The reason for this is because I want to start at the lowest leaf of my tree and traverse to the ultimate parent. Our example only has three levels, but you could have lots of levels in a more complex example. As for the <span class="emphasis"><em>next</em></span> parameter, I'm using a closure expression that expects a mutable Item as its state. My closure will also return an optional Item. In the body of our closure, I use our current Item (mutable state parameter) to access the Item's parent. I update the state and return the parent.</p><pre class="programlisting">let itemSeq = sequence(state: child2, next: { &#13;
    (next: inout Item)-&gt;Item? in &#13;
    let parent = next.parent &#13;
    next = parent != nil ? parent! : next &#13;
    return parent &#13;
}) &#13;
 &#13;
 &#13;
for item in itemSeq{ &#13;
    print("name: \(item.name)") &#13;
} &#13;
</pre><p>There are some gotchas here that I want to address so that you will better understand how to define your own next closure for this sequence method.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The state parameter could really be anything you want it to be. It's for your benefit in helping you determine the next element of the sequence and to give you relevant information about where you are in the sequence. One idea to improve our example above would be to track how many levels of nesting we have. We could have made our state a tuple that contained an integer counter for the nesting level along with the current item.</li><li class="listitem" style="list-style-type: disc">The next closure needs to be expanded to show the signature. Because of Swift's expressiveness and conciseness when it comes to closures, you might be tempted to convert the <span class="emphasis"><em>next</em></span> closure into a shorter form and omit the signature. Do not do this unless your <span class="emphasis"><em>next</em></span> closure is extremely simple and you are positive that the compiler will be able to infer your types. Your code will be harder to maintain when you use the short closure format and you won't get extra points for style when someone else inherits it.</li><li class="listitem" style="list-style-type: disc">Don't forget to update your state parameter in the body of your closure. This really is your best chance to know where you are in your sequence. Forgetting to update the state will probably cause you to get unexpected results when you try to step through your sequence.</li><li class="listitem" style="list-style-type: disc">Make a clear decision ahead of time about whether you are creating a finite or infinite sequence. This decision is evident in how you return from your next closure. An infinite sequence is not bad to have when you are expecting it, however, if you iterate over this sequence using a <code class="literal">for…in</code> loop, you could get more than you bargained for, provided you were assuming this loop would end.</li></ul></div></div></div></div>
<div class="section" title="A new model for collections and indices [SE-0065]"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>A new model for collections and indices [SE-0065]</h1></div></div></div><p>Swift 3 introduces a new model for collections that moves the responsibility of the index traversal from the index to the collection itself. To make this a reality for collections, the Swift team introduced four areas of change:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Index property of a collection can be any type that implements the <span class="emphasis"><em>Comparable</em></span> protocol</li><li class="listitem" style="list-style-type: disc">Swift removes any distinction between intervals and ranges; leaving just ranges</li><li class="listitem" style="list-style-type: disc">Private index traversal methods are now public</li><li class="listitem" style="list-style-type: disc">Changes to ranges make closed ranges work without the potential for errors</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>You can read the proposal at the following link <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md">https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md</a>
</p></div></div><div class="section" title="Introducing the Collection protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec19"/>Introducing the Collection protocol</h2></div></div></div><p>In Swift 3, Foundation collection types such as Arrays, Dictionaries, and Sets are generic types that implement the newly created Collection protocol. This change was needed in order to support traversal on the collection. If you want to create custom collections of your own, you will need to understand the Collection protocol and where it lives in the Collection protocol hierarchy. We are going to cover the important aspects to the new collection model to ease you transition and to get your ready to create custom collection types of your own.</p><p>The Collection protocol builds on the Sequence protocol to provide methods for accessing specific elements when using a collection. For example, you can use a collection's <code class="literal">index(_:offsetBy:)</code> method to return an index that is a specified distance away from the reference index.</p><pre class="programlisting">let numbers = [10, 20, 30, 40, 50, 60] &#13;
let twoAheadIndex = numbers.index(numbers.startIndex, offsetBy: 2) &#13;
print(numbers[twoAheadIndex]) //=&gt; 30   &#13;
 &#13;
</pre><p>In our example above, we create the <code class="literal">twoAheadIndex</code> constant to hold the position in our numbers collection that is two positions away from our starting index. We simply use this index to retrieve the value from our collection using subscript notation.</p></div><div class="section" title="Conforming to the Collection protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec20"/>Conforming to the Collection protocol</h2></div></div></div><p>If you would like to create your own custom collections, you need to adopt the Collection protocol by declaring <code class="literal">startIndex</code> and <code class="literal">endIndex</code> properties, a subscript to support access to your elements, and the <code class="literal">index(after: )</code> method to facilitate traversing your collection's indices.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>When we are migrating existing types over to Swift 3, the migrator has some known issues with converting custom collections. It's likely that you can easily resolve the compiler issues by checking the imported types for conformance to the Collection protocol.</p></div></div><p>Additionally, you need to conform to the Sequence and IndexableBase protocols as the Collection protocol adopts them both.</p><pre class="programlisting">public protocol Collection : Indexable, Sequence { ... } &#13;
</pre><p>A simple custom collection could look like the following example. Notice that I have defined my <code class="literal">Index</code> type to be an <code class="literal">Int.</code> In Swift 3, you define the index to be any type that implements the Comparable protocol:</p><pre class="programlisting">struct MyCollection&lt;T&gt;: Collection{ &#13;
    typealias Index = Int &#13;
    var startIndex: Index &#13;
    var endIndex: Index &#13;
     &#13;
    var _collection: [T] &#13;
     &#13;
    subscript(position: Index) -&gt; T{ &#13;
        return _collection[position] &#13;
    } &#13;
     &#13;
    func index(after i: Index) -&gt; Index { &#13;
        return i + 1 &#13;
    } &#13;
     &#13;
    init(){ &#13;
        startIndex = 0 &#13;
        endIndex = 0 &#13;
        _collection = [] &#13;
    } &#13;
     &#13;
    mutating func add(item: T){ &#13;
        _collection.append(item) &#13;
    } &#13;
} &#13;
 &#13;
var myCollection: MyCollection&lt;String&gt; = MyCollection() &#13;
myCollection.add(item: "Harry") &#13;
myCollection.add(item: "William") &#13;
myCollection[0] &#13;
</pre><p>The Collection protocol has default implementations for most of its methods, the Sequence protocols methods, and the IndexableBase protocols methods. This means you are only required to provide a few things of your own. You can, however, implement as many of the other methods that make sense for your collection.</p></div><div class="section" title="New Range and associated indices types"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec21"/>New Range and associated indices types</h2></div></div></div><p>Swift 2's <code class="literal">Range&lt;T&gt;</code>, <code class="literal">ClosedInterval&lt;T&gt;</code>, and <code class="literal">OpenInterval&lt;T&gt;</code> are going away in Swift 3. These types are being replaced with four new types. Two of the new range types support general ranges with bounds that implement the Comparable protocol: <code class="literal">Range&lt;T&gt;</code> and <code class="literal">ClosedRange&lt;T&gt;</code>. The other two range types conform to <code class="literal">RandomAccessCollection</code>. These types support ranges whose bounds implement the Strideable protocol.</p><p>Last, ranges are no longer iterable since ranges are now represented as a pair of indices. To keep legacy code working, the Swift team introduced an associated Indices type, which is iterable. In addition, three generic types were created to provide a default <span class="emphasis"><em>Indices</em></span> type for each type of collection traversal category. The generics are <code class="literal">DefaultIndices&lt;C&gt;</code>, <code class="literal">DefaultBidirectionalIndices&lt;C&gt;</code>, and <code class="literal">DefaultRandomAccessIndices&lt;C&gt;</code>; each stores its underlying collection for traversal.</p></div></div>
<div class="section" title="Quick takeaways"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Quick takeaways</h1></div></div></div><p>I covered a lot of stuff in a just a few pages on collection types in Swift 3. Here are the highlights to keep in mind about the collections and indices.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collection types (built-in and custom) implement the Collection protocol.</li><li class="listitem" style="list-style-type: disc">Iterating over collections has moved to the Collection - the index no longer has that ability.</li><li class="listitem" style="list-style-type: disc">You can create your own collections by adopting the Collection protocol. You need to implement:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">startIndex</code> and <code class="literal">endIndex</code> properties,</li><li class="listitem" style="list-style-type: disc">The subscript method to support access to your elements</li><li class="listitem" style="list-style-type: disc">And the <code class="literal">index(after: )</code> method to facilitate traversing your collection's indices.</li></ul></div><p>
</p></li></ul></div></div>
<div class="section" title="Closure changes for Swift 3"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Closure changes for Swift 3</h1></div></div></div><p>A closure in Swift is a block of code that can be used in a function call as a parameter or assigned to a variable to execute their functionality at a later time. Closures are a core feature to Swift and are familiar to developers that are new to Swift as they may remind them of lambda functions in other programming languages. For Swift 3, there were two notable changes that I will highlight in this section. The first change deals with inout captures. The second is a change that makes non-escaping closures the default.</p><div class="section" title="Limiting inout Capture of @noescape Closures [SE-0035]"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec22"/>Limiting inout Capture of @noescape Closures [SE-0035]</h2></div></div></div><p>In Swift 2, capturing <code class="literal">inout</code> parameters in an escaping closure is difficult for developers to understand. Some closures are assigned to variables and then passed to functions as arguments. If the function that contains the closure parameter returns from its call and the passed in closure is used later, then you have an escaping closure. On the other hand, if the closure is only used within the function to which it is passed and not used later, then you have a non-escaping closure. The distinction is important here because of the mutating nature of <code class="literal">inout</code> parameters.</p><p>When we pass an <code class="literal">inout</code> parameter to a closure, there is a possibility that we will not get the result we expect due to how the <code class="literal">inout</code> parameter is stored. The <code class="literal">inout</code> parameter is captured as a shadow copy and is only written back to the original if the value changes. This works fine most of the time. However, when the closure is called at a later time (that is, when it escapes), we don't get the result we expect. Our shadow copy can't write back to the original. Let's look at an example.</p><pre class="programlisting">var seed = 10 &#13;
let simpleAdderClosure = { (inout seed: Int)-&gt;Int in &#13;
    seed += 1 &#13;
    return seed * 10 &#13;
} &#13;
 &#13;
var result = simpleAdderClosure(&amp;seed)  //=&gt; seed = 11; result = 110 &#13;
print(seed) // =&gt; 11 &#13;
</pre><p>In the example above, we get what we expect. We have created a closure to increment our passed in <code class="literal">inout</code> parameter and then return the new parameter multiplied by 10. When we check the value of <span class="emphasis"><em>seed</em></span> after the closure is called, we see that the value has increased to <code class="literal">11</code>.</p><p>In our second example, we modify our closure to return a function instead of just an <code class="literal">Int</code> value. We move our logic to the closure that we are defining as our return value.</p><pre class="programlisting">let modifiedClosure = { (inout seed: Int)-&gt; (Int)-&gt;Int in &#13;
    return { (Int)-&gt; Int in &#13;
        seed += 1 &#13;
        return seed * 10 &#13;
    } &#13;
} &#13;
 &#13;
print(seed)  //=&gt; 11 &#13;
var resultFn = modifiedClosure(&amp;seed) &#13;
var result = resultFn(1) &#13;
print(seed) // =&gt; 11 &#13;
</pre><p>This time when we execute the <code class="literal">modifiedClosure</code> with our <code class="literal">seed</code> value we get a function as the result. After executing this intermediate function, we check our <span class="emphasis"><em>seed</em></span> value and see that the value is unchanged; even though we are still incrementing the <code class="literal">seed</code> value.</p><p>These two slight differences in syntax when using <code class="literal">inout</code> parameters generate different results. Without knowledge of how shadow copy works, it would be hard to understand the difference in results. Ultimately, this is just another situation where you receive more harm than good by allowing this feature to remain in the language.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>You can read the proposal at the following link <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md">https://github.com/apple/swift-evolution/blob/master/proposals/0035-limit-inout-capture.md</a>
</p></div></div></div><div class="section" title="Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec23"/>Resolution</h2></div></div></div><p>In Swift 3, the compiler now limits <code class="literal">inout</code> parameter usage with closures to non-escaping (<code class="literal">@noescape</code>). You will receive an error if the compiler detects that your closure escapes when it contains <code class="literal">inout</code> parameters.</p></div><div class="section" title="Making non-escaping closures the default [SE-0103]"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec24"/>Making non-escaping closures the default [SE-0103]</h2></div></div></div><p>In previous versions of Swift, the default behavior of function parameters whose type was a closure was to allow escaping. This made sense as most of the Objective-C blocks (closures in Swift) imported into Swift were escaping. The delegation pattern in Objective-C, as implemented as blocks, was composed of delegate blocks that escaped. So why would the Swift team want to change the default to non-escaping as the default? Let's look at examples in Swift 2.2 and Swift 3 to get a better understanding of why this change makes sense.</p><p>In Swift 2.2:</p><pre class="programlisting">var callbacks:[String : ()-&gt;String] = [:] &#13;
func myEscapingFunction(name:String, callback:()-&gt;String){ &#13;
    callbacks[name] = callback &#13;
} &#13;
myEscapingFunction("cb1", callback: {"just another cb"}) &#13;
for cb in callbacks{ &#13;
    print("name: \(cb.0) value: \(cb.1())")  &#13;
} &#13;
</pre><p>In Swift 3:</p><pre class="programlisting">var callbacks:[String : ()-&gt;String] = [:] &#13;
func myEscapingFunction(name:String, callback: @escaping ()-&gt;String){ &#13;
    callbacks[name] = callback &#13;
} &#13;
myEscapingFunction(name:"cb1", callback: {"just another cb"}) &#13;
for cb in callbacks{ &#13;
    print("name: \(cb.0) value: \(cb.1())")  &#13;
} &#13;
</pre><p>The Swift team believes you can write better functional algorithms with non-escaping closures. An additional supporting factor is the change to require non-escaping closures when using <code class="literal">inout</code> parameters with the closure <span class="emphasis"><em>[SE-0035]</em></span>. All things considered, this change will likely have little impact on your code. When the compiler detects that you are attempting to create an escaping closure, you will get a warning that you are possibly creating an escaping closure. You can easily correct the error by adding <code class="literal">@escaping</code> or via the <code class="literal">fixit</code> that accompanies the error.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>You can read the proposal at the following link <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md">https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md</a>
</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter we covered changes to collections and closures. We learned about the new Collection protocol that forms the base of the new collection model and how to adopt the protocol in our own custom collections. The new collection model made a significant change in moving collection traversal from the index to the collection itself. The new collection model changes are necessary in order to support Objective-C interactivity and to provide a mechanism to iterate over the collections items using the collections itself. As for closures, we also explored the motivation for the language moving to non-escaping closures as the default. We also learned how to properly use <code class="literal">inout</code> parameters with closures in Swift 3. In the next chapter, we are will cover more type changes and type aliases within protocols and protocol extensions.</p></div></body></html>