<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Linux Access Controls"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Linux Access Controls</h1></div></div></div><p>Android is <a id="id0" class="indexterm"/>an operating system composed of two distinct components. The first component is a forked mainline Linux kernel and shares almost everything in common with Linux. The second component, which will be discussed later, is the user space portion, which is very custom and Android specific. Since the Linux kernel underpins this system and is responsible for the majority of access control decisions, it is the logical place to begin a detailed look at Android.</p><p>In this chapter we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Examine the basics of Discretionary Access Control</li><li class="listitem" style="list-style-type: disc">Introduce Linux permissions flags and capabilities</li><li class="listitem" style="list-style-type: disc">Trace syscalls as we validate access policies</li><li class="listitem" style="list-style-type: disc">Make the case for more robust access control technology</li><li class="listitem" style="list-style-type: disc">Discuss Android exploits that leverage problems with Discretionary Access Control</li></ul></div><p>Linux's default and familiar access control mechanism is called <span class="strong"><strong>Discretionary Access Control</strong></span> (<span class="strong"><strong>DAC</strong></span>). This is just a term that means permissions regarding access to an object are at the discretion of its creator/owner.</p><p>In Linux, when<a id="id1" class="indexterm"/> a process invokes most system calls, a permission check is performed. As an example, a process wishing to open a file would invoke the <code class="literal">open()</code> syscall. When this syscall is invoked, a context switch is performed, and the operating system code is executed. The OS has the ability to determine whether a file descriptor should be returned to the requesting process or not. During this decision-making process, the OS checks the access permissions of both the requesting process and the target file it wishes to obtain the file descriptor to. Either the file descriptor or EPERM is returned, dependent on whether the permission checks pass or fail respectively.</p><p>Linux maintains data structures in the kernel for managing these permission fields, which are accessible from user space, and ones that should be familiar to Linux and *NIX users alike. The first set of access control metadata belongs to the process, and forms a portion of its credential set. The common credentials are user and group. In general, we use the term group to mean both primary group and possible secondary group(s). You can view these permissions by running the <code class="literal">ps</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ps -eo pid,comm,user,group,supgrp</strong></span>
<span class="strong"><strong>PID COMMAND         USER     GROUP    SUPGRP</strong></span>
<span class="strong"><strong>1 init            root     root     -</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong> 2993 system-service- root     root     root </strong></span>
<span class="strong"><strong> 3276 chromium-browse bookuser sudo fuse bookuser </strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>As you can see, we have processes running as the users <code class="literal">root</code> and <code class="literal">bookuser</code>. You can also see that their primary group is only one part of the equation. Processes also have a secondary <a id="id2" class="indexterm"/>set of groups called supplementary groups. This set might be<a id="id3" class="indexterm"/> empty, indicated by the dash in the <code class="literal">SUPGRP</code> field.</p><p>The file we wish to open, referred to as the target object, target, or object also maintains a set of permissions. The object maintains <code class="literal">USER</code> and <code class="literal">GROUP</code>, as well as a set of permission bits. In the context of the target object, <code class="literal">USER</code> can be referred to as <span class="emphasis"><em>owner </em></span>or <span class="emphasis"><em>creator</em></span>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls -la</strong></span>
<span class="strong"><strong>total 296</strong></span>
<span class="strong"><strong>drwxr-xr-x 38 bookuser bookuser  4096 Aug 23 11:08 .</strong></span>
<span class="strong"><strong>drwxr-xr-x  3 root     root      4096 Jun  8 18:50 ..</strong></span>
<span class="strong"><strong>-rw-rw-r--  1 bookuser bookuser   116 Jul 22 13:13 a.c</strong></span>
<span class="strong"><strong>drwxrwxr-x  4 bookuser bookuser  4096 Aug  4 16:20 .android</strong></span>
<span class="strong"><strong>-rw-rw-r--  1 bookuser bookuser   130 Jun 19 17:51 .apport-ignore.xml</strong></span>
<span class="strong"><strong>-rw-rw-r--  1 bookuser bookuser   365 Jun 23 19:44 hello.txt</strong></span>
<span class="strong"><strong>-rw-------  1 bookuser bookuser 19276 Aug  4 16:36 .bash_history</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>If we look at the preceding command's output, we can see that <code class="literal">hello.txt</code> has a <code class="literal">USER</code> of <code class="literal">bookuser</code> and <code class="literal">GROUP</code> as <code class="literal">bookuser</code>. We can also see the permission bits or flags on the left-hand side of the output. There are seven fields to consider as well. Each empty field is denoted with a dash. When printed with <code class="literal">ls</code>, the first fields can get convoluted by semantics. For this reason, let's use <code class="literal">stat</code> to investigate the file permissions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ stat hello.txt</strong></span>
<span class="strong"><strong>  File: `hello.txt'</strong></span>
<span class="strong"><strong>  Size: 365         Blocks: 8          IO Block: 4096   regular file</strong></span>
<span class="strong"><strong>Device: 801h/2049d  Inode: 1587858     Links: 1</strong></span>
<span class="strong"><strong>Access: (0664/-rw-rw-r--)  Uid: ( 1000/bookuser)   Gid: ( 1000/bookuser)</strong></span>
<span class="strong"><strong>Access: 2014-08-04 15:53:01.951024557 -0700</strong></span>
<span class="strong"><strong>Modify: 2014-06-23 19:44:14.308741592 -0700</strong></span>
<span class="strong"><strong>Change: 2014-06-23 19:44:14.308741592 -0700</strong></span>
<span class="strong"><strong> Birth: -</strong></span>
</pre></div><p>The first access line is the most compelling. It contains all the important information for the access controls. The second line is just a timestamp letting us know when the file was last accessed. As we can see, <code class="literal">USER</code> or <code class="literal">UID</code> of the object is <code class="literal">bookuser</code>, and <code class="literal">GROUP</code> is <code class="literal">bookuser</code> as well. The permission flags, (<code class="literal">0664/-rw-rw-r--</code>), identify the two ways that permission flags are represented. The first, the octal form <code class="literal">0664</code>, condenses each three-flag field into one of the three base-8 (octal) digits. The second is the friendly form, <code class="literal">-rw-rw-r--</code>, equivalent to the octal form but easier to interpret visually. In either case, we can see the leftmost field is 0, and the rest of our discussions will ignore it. That field is for <code class="literal">setuid</code> and <code class="literal">setgid</code> capabilities, which is not important for this discussion. If we convert the remaining octal digits, 664, to binary, we get 110 110 100. This binary representation directly relates to the friendly form. Each triple maps to read, write, and execute permissions. Often you will see this permission triple represented as <code class="literal">RWX</code>. The first triple are the permissions given to <code class="literal">USER</code>, the second are the permissions given to <code class="literal">GROUP</code>, and the third is what is given to <code class="literal">OTHERS</code>. Translating to conventional English would yield, "The user, <code class="literal">bookuser</code>, has permission to read from and write to <code class="literal">hello.txt</code>. The group, <code class="literal">bookuser</code>, has permission to read from and write to <code class="literal">hello.txt</code>, and everyone else has permission only to read from <code class="literal">hello.txt</code>." Let's test this with some real-world examples.</p><div class="section" title="Changing permission bits"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Changing permission bits</h1></div></div></div><p>Let's<a id="id4" class="indexterm"/> test the access controls in the example running processes as user <code class="literal">bookuser</code>. Most processes run in the context of the user that invoked them (excluding <code class="literal">setuid</code> and <code class="literal">getuid</code> programs), so any command we invoke should inherit our user's permissions. We can view it by issuing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ groups bookuser</strong></span>
<span class="strong"><strong>bookuser : bookuser sudo fuse</strong></span>
</pre></div><p>My user, <code class="literal">bookuser</code>, is <code class="literal">USER bookuser</code>, <code class="literal">GROUP bookuser</code> and <code class="literal">SUPGRP sudo</code> and <code class="literal">fuse</code>.</p><p>To test for read access, we can use the <code class="literal">cat</code> command, which opens the file and prints its content to <code class="literal">stdout</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat hello.txt </strong></span>
<span class="strong"><strong>Hello, "Exploring SE for Android"</strong></span>
<span class="strong"><strong>Here is a simple text file for</strong></span>
<span class="strong"><strong>your enjoyment.</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>We <a id="id5" class="indexterm"/>can introspect the syscalls executed by running the <code class="literal">strace</code> command and viewing the output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace cat hello.txt </strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>open("hello.txt", O_RDONLY)                   = 3</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>read(3, "Hello, \"Exploring SE for Android\"\n"..., 32768) = 365</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>The output can be quite verbose, so I am only showing the relevant parts. We can see that <code class="literal">cat</code> invoked the <code class="literal">open</code> syscall and obtained the file descriptor <code class="literal">3</code>. We can use that descriptor to find other accesses via other syscalls. Later we will see a read occurring on file descriptor <code class="literal">3</code>, which returns <code class="literal">365</code>, the number of bytes read. If we didn't have permission to read from <code class="literal">hello.txt</code>, the open would fail, and we would never have a valid file descriptor for the file. We would additionally see the failure in the <code class="literal">strace</code> output.</p><p>Now that read permission is verified, let's try write. One simple way to do this is to write a simple program that writes something to the existing file. In this case, we will write the line <code class="literal">my new text\n</code> (refer to <code class="literal">write.c</code>.)</p><p>Compile the program using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gcc -o mywrite write.c</strong></span>
</pre></div><p>Now run using the newly compiled program:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace ./mywrite hello.txt</strong></span>
</pre></div><p>On verification, you will see:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>open("hello.txt", O_WRONLY)                   = 3</strong></span>
<span class="strong"><strong>write(3, "my new text\n", 12)           = 12</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>As you can see, the write succeeded and returned <code class="literal">12</code>, the number of bytes written to <code class="literal">hello.txt</code>. No errors were reported, so the permissions seem in check so far.</p><p>Now let's attempt to execute <code class="literal">hello.txt</code> and see what happens. We are expecting to see an error. Let's execute it like a normal command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./hello.txt</strong></span>
<span class="strong"><strong>bash: ./hello.txt: Permission denied</strong></span>
</pre></div><p>This is<a id="id6" class="indexterm"/> exactly what we expected, but let's invoke it with <code class="literal">strace</code> to gain a deeper understanding of what failed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace ./hello.txt</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>execve("./hello.txt", ["./hello.txt"], [/* 39 vars */]) = -1 EACCES (Permission denied)</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>The <code class="literal">execve</code> system call, which launches processes, failed with <code class="literal">EACCESS</code>. This is just the sort of thing one would hope for when no execute permission is given. The Linux access controls worked as expected!</p><p>Let's test the access controls in the context of another user. First, we'll create a new user called <code class="literal">testuser</code> using the <code class="literal">adduser</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo adduser testuser</strong></span>
<span class="strong"><strong>[sudo] password for bookuser: </strong></span>
<span class="strong"><strong>Adding user `testuser' ...</strong></span>
<span class="strong"><strong>Adding new group `testuser' (1001) ...</strong></span>
<span class="strong"><strong>Adding new user `testuser' (1001) with group `testuser' ...</strong></span>
<span class="strong"><strong>Creating home directory `/home/testuser' ...</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>Verify the <code class="literal">USER</code>, <code class="literal">GROUP</code>, and <code class="literal">SUPGRP</code> of <code class="literal">testuser</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ groups testuser</strong></span>
<span class="strong"><strong>testuser : testuser</strong></span>
</pre></div><p>Since the <code class="literal">USER</code> and <code class="literal">GROUP</code> do not match any of the permissions on <code class="literal">a.S</code>, all accesses will be subject to the <code class="literal">OTHERS</code> permissions checks, which if you recall, is read only (<code class="literal">0664</code>).</p><p>Start by temporarily working as <code class="literal">testuser</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ su testuser</strong></span>
<span class="strong"><strong>Password: </strong></span>
<span class="strong"><strong>testuser@ubuntu:/home/bookuser$ </strong></span>
</pre></div><p>As you can see, we are still in bookuser's home directory, but the current user has been changed to <code class="literal">testuser</code>.</p><p>We will start by testing <code class="literal">read</code> with the <code class="literal">cat</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace cat hello.txt</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>open("hello.txt", O_RDONLY)                   = 3</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>read(3, "my new text\n", 32768)         = 12</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>Similar to the earlier example, <code class="literal">testuser</code> can read the data just fine, as expected.</p><p>Now let's move on to write. The expectation is that this will fail without appropriate access:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace ./mywrite hello.txt</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>open("hello.txt", O_WRONLY)                   = -1 EACCES (Permission denied)</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>As<a id="id7" class="indexterm"/> expected, the syscall operation failed. When we attempt to execute <code class="literal">hello.txt</code> as <code class="literal">testuser</code>, this should fail as well:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace ./hello.txt</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>execve("./hello.txt", ["./hello.txt"], [/* 40 vars */]) = -1 EACCES (Permission denied)</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>Now we need to test the group access permissions. We can do this by adding a supplementary group to <code class="literal">testuser</code>. To do this, we need to exit to <code class="literal">bookuser</code>, who has permissions to execute the <code class="literal">sudo</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ exit</strong></span>
<span class="strong"><strong>exit</strong></span>
<span class="strong"><strong>$ sudo usermod -G bookuser testuser</strong></span>
</pre></div><p>Now let's check the groups of <code class="literal">testuser</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ groups testuser</strong></span>
<span class="strong"><strong>testuser : testuser bookuser</strong></span>
</pre></div><p>As a result of the previous <code class="literal">usermod</code> command <code class="literal">testuser</code> now belongs to two groups: <code class="literal">testuser</code> and <code class="literal">bookuser</code>. That means when <code class="literal">testuser</code> accesses a file or other object (such as a socket) with the group <code class="literal">bookuser</code>, the <code class="literal">GROUP</code> permissions, rather than <code class="literal">OTHERS</code>, will apply to it. In the context of <code class="literal">hello.txt</code>, <code class="literal">testuser</code> can now read from and write to the file, but not execute it.</p><p>Switch to <code class="literal">testuser</code> by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ su testuser</strong></span>
</pre></div><p>Test <code class="literal">read</code> by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace cat ./hello.txt</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>open("./hello.txt", O_RDONLY)                 = 3</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>read(3, "my new text\n", 32768)         = 12</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>As before, <code class="literal">testuser</code> is able to read the file. The only difference is that it can now <code class="literal">read</code> the file through the access permissions of <code class="literal">OTHERS</code> and <code class="literal">GROUP</code>.</p><p>Test <code class="literal">write</code> by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace ./mywrite hello.txt</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>open("hello.txt", O_WRONLY)                   = 3</strong></span>
<span class="strong"><strong>write(3, "my new text\n", 12)           = 12</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>This time, <a id="id8" class="indexterm"/><code class="literal">testuser</code> was able to write the file as well, instead of failing with the <code class="literal">EACCESS</code> permission error shown before.</p><p>Attempting to execute the file should still fail:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ strace ./hello.txt</strong></span>
<span class="strong"><strong>execve("./hello.txt", ["./hello.txt"], [/* 40 vars */]) = -1 EACCES (Permission denied)</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>These concepts are the foundation of Linux access control permission bits, users and groups.</p></div></div>
<div class="section" title="Changing owners and groups"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Changing owners and groups</h1></div></div></div><p>Using <code class="literal">hello.txt</code> for exploratory work in the previous sections, we have shown how the owner<a id="id9" class="indexterm"/> of an object can allow various forms of access by managing<a id="id10" class="indexterm"/> the permission bits of the object. Changing the permissions is accomplished using the <code class="literal">chmod</code> syscall. Changing the user and/or group is done with the <code class="literal">chown</code> syscall. In this section, we will investigate the details of these operations in action.</p><p>Let's start by granting read and write permissions only to the owner of <code class="literal">hello.txt</code> file, <code class="literal">bookuser</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chmod 0600 hello.txt</strong></span>
<span class="strong"><strong>$ stat hello.txt</strong></span>
<span class="strong"><strong>  File: `hello.txt'</strong></span>
<span class="strong"><strong>  Size: 12          Blocks: 8          IO Block: 4096   regular file</strong></span>
<span class="strong"><strong>Device: 801h/2049d  Inode: 1587858     Links: 1</strong></span>
<span class="strong"><strong>Access: (0600/-rw-------)  Uid: ( 1000/bookuser)   Gid: ( 1000/bookuser)</strong></span>
<span class="strong"><strong>Access: 2014-08-23 12:34:30.147146826 -0700</strong></span>
<span class="strong"><strong>Modify: 2014-08-23 12:47:19.123113845 -0700</strong></span>
<span class="strong"><strong>Change: 2014-08-23 12:59:04.275083602 -0700</strong></span>
<span class="strong"><strong> Birth: -</strong></span>
</pre></div><p>As we can see, the file permissions are now set to only allow read and write access for <code class="literal">bookuser</code>. A thorough reader could execute the commands from earlier sections in this chapter to verify that permissions work as expected.</p><p>Changing<a id="id11" class="indexterm"/> the group can be done in a similar fashion with <code class="literal">chown</code>. Let's<a id="id12" class="indexterm"/> change the group to <code class="literal">testuser</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chown bookuser:testuser hello.txt</strong></span>
<span class="strong"><strong>chown: changing ownership of `hello.txt': Operation not permitted</strong></span>
</pre></div><p>This did not work as we intended, but what is the issue? In Linux, only privileged processes can change the <code class="literal">USER</code> and <code class="literal">GROUP</code> fields of objects. The initial <code class="literal">USER</code> and <code class="literal">GROUP</code> fields are set during object creation from the effective <code class="literal">USER</code> and <code class="literal">GROUP</code>, which are checked when attempting to execute that process. Only processes create objects. Privileged processes come in two forms: those running as the almighty <code class="literal">root</code> and those that have their capabilities set. We will dive into the details of capabilities later. For now, let's focus on the <code class="literal">root</code>.</p><p>Let's change the user to <code class="literal">root</code> to ensure executing the <code class="literal">chown</code> command will change the group of that object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo su</strong></span>
<span class="strong"><strong># chown bookuser:testuser hello.txt </strong></span>
<span class="strong"><strong>Now, we can verify the change occurred successfully:</strong></span>
<span class="strong"><strong># stat hello.txt</strong></span>
<span class="strong"><strong>  File: `hello.txt'</strong></span>
<span class="strong"><strong>  Size: 12          Blocks: 8          IO Block: 4096   regular file</strong></span>
<span class="strong"><strong>Device: 801h/2049d  Inode: 1587858     Links: 1</strong></span>
<span class="strong"><strong>Access: (0600/-rw-------)  Uid: ( 1000/bookuser)   Gid: ( 1001/testuser)</strong></span>
<span class="strong"><strong>Access: 2014-08-23 12:34:30.147146826 -0700</strong></span>
<span class="strong"><strong>Modify: 2014-08-23 12:47:19.123113845 -0700</strong></span>
<span class="strong"><strong>Change: 2014-08-23 13:08:46.059058649 -0700</strong></span>
<span class="strong"><strong> Birth: -</strong></span>
</pre></div></div>
<div class="section" title="The case for more"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>The case for more</h1></div></div></div><p>You can see the <code class="literal">GROUP</code> (<code class="literal">GID</code>) is now <code class="literal">testuser</code>, and things seem reasonably secure because in order to change the user and group of an object, you need to be privileged. You can <a id="id13" class="indexterm"/>only change the permission bits on an object if you own it, with the exception of the <code class="literal">root</code> user. This means that if you're running as <code class="literal">root</code>, you can do whatever you like to the system, even without permission. This absolute authority is why a successful attack or an error on a root running process can cause grave damage to the system. Also, a successful attack on a non-root process could also cause damage by inadvertently changing the permissions bits. For example, suppose there is an unintended <code class="literal">chmod 0666</code> command on your SSH private key. This would expose your <a id="id14" class="indexterm"/>secret key to all users on the system, which is almost certainly something you would never want to happen. The root limitation is partially addressed by the capabilities model.</p></div>
<div class="section" title="Capabilities model"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Capabilities model</h1></div></div></div><p>For many<a id="id15" class="indexterm"/> operations on Linux, the object permission model doesn't quite fit. For instance, changing <code class="literal">UID</code> and <code class="literal">GID</code> requires some magical <code class="literal">USER</code> known as <code class="literal">root</code>. Suppose you have a long running service that needs to utilize some of these capabilities. Perhaps this service listens to kernel events and creates the device nodes for you? Such a service exists, and it's called <code class="literal">ueventd</code> or user event daemon. This daemon traditionally runs as <code class="literal">root</code>, which means if it is compromised, it could potentially read your private keys from your home directory and send them back to the attacker. This might be an extraordinary example, but it's meant to showcase that running processes as <code class="literal">root</code> can be dangerous. Suppose you could start a service as the <code class="literal">root</code> user and have the process change its <code class="literal">UID</code> and <code class="literal">GID</code> to something not privileged, but retain some smaller set of privileged capabilities to do its job? This is exactly what the capabilities model in Linux is.</p><p>The capabilities model in Linux is an attempt to break down the set of permissions that <code class="literal">root</code> has into smaller subsets. This way, processes can be confined to the set of minimum privileges they need to perform their intended function. This is known as least privilege, a key ideology when securing systems that minimizes the amount of damage a successful attack can do. In some instances, it can even prevent a successful attack from occurring by blocking an otherwise open attack vector.</p><p>There are many capabilities. The man page for capabilities is the de facto documentation. Let's take a look at the <code class="literal">CAP_SYS_BOOT</code> capability:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man capabilities</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>CAP_SYS_BOOT</strong></span>
<span class="strong"><strong>       Use reboot(2) and kexec_load(2).</strong></span>
</pre></div><p>This means a process running with this capability can reboot the system. However, that process can't arbitrarily change <code class="literal">USERS</code> and <code class="literal">GROUP</code> as it could if it was running as <code class="literal">root</code> or with <code class="literal">CAP_DAC_READ_SEARCH</code>. This limits what an attacker can do:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;FROM MAN PAGE&gt;</strong></span>
<span class="strong"><strong>CAP_DAC_READ_SEARCH</strong></span>
<span class="strong"><strong>      Bypass file read permission checks and directory read and execute permission checks.</strong></span>
</pre></div><p>Now suppose the case where our restart process runs with <code class="literal">CAP_CHOWN</code>. Let's say it uses this capability to ensure that when a restart request is received, it backs up a file from each user's home directory to a server before restarting. Let's say this file is <code class="literal">~/backup</code>, the permissions are 0600, and <code class="literal">USER</code> and <code class="literal">GROUP</code> are the respective user of that home directory. In<a id="id16" class="indexterm"/> this case, we have minimized the permissions as best we can, but the process could still access the users SSH keys and upload those either by error or attack. Another approach to this would be to set the group to <code class="literal">backup</code> and run the process with <code class="literal">GROUP backup</code>. However, this has limitations. Suppose you want to share this file with another user. That user would require a supplementary group of <code class="literal">backup</code>, but now the user can read <span class="emphasis"><em>all</em></span> of the backup files, not just the ones intended. An astute reader might think about the <code class="literal">bind</code> mounts, however the process doing the <code class="literal">bind</code> mounts and file permissions also runs with some capability, and thus suffers from this granularity problem as well.</p><p>The major issue, and the case for another access control system can be summarized by one word, <span class="emphasis"><em>granularity</em></span>. The DAC model doesn't have the granularity required to safely handle complex access control models or to minimize the amount of damage a process can do. This is particularly important on Android, where the entire isolation system is dependent on this control, and a rogue root process can compromise the whole system.</p></div>
<div class="section" title="Android's use of DAC"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Android's use of DAC</h1></div></div></div><p>In the <a id="id17" class="indexterm"/>Android sandbox model, every application runs as its own <code class="literal">UID</code>. This <a id="id18" class="indexterm"/>means that each app can separate its stored data from one another. The user and group are set to the <code class="literal">UID</code> and <code class="literal">GID</code> of that application, so no app can access the private files of an application without the application explicitly performing <code class="literal">chmod</code> on its objects. Also, applications in Android cannot have capabilities, so we don't have to worry about capabilities such as <code class="literal">CAP_SYS_PTRACE</code>, which is the ability to debug another application. In Android, in a perfect world, only system components run with privileges, and applications don't accidentally <code class="literal">chmod</code> private files for all to read. This issue was not corrected by the current AOSP SELinux policy due to app compatibility, but could be closed with SELinux. The proper way to share data between applications on Android is via binder, and sharing file descriptors. For smaller amounts of data, the provider model suffices.</p></div>
<div class="section" title="Glancing at Android vulnerabilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Glancing at Android vulnerabilities</h1></div></div></div><p>With <a id="id19" class="indexterm"/>our newly found understanding of the DAC permission model and some of its limitations, let's look at some Android exploits against it. We will cover only a few exploits to understand how the DAC model failed.</p><div class="section" title="Skype vulnerability"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Skype vulnerability</h2></div></div></div><p>CVE-2011-1717 was released in 2011. In this exploit, the Skype application left a SQLite3<a id="id20" class="indexterm"/> database world readable (something analogous to 0666 permissions). This database contained usernames and chat logs, and<a id="id21" class="indexterm"/> personal data such as name and e-mail. An application called Skypwned was able to demonstrate this capability. This is an example of how being able to change the permissions on your objects could be bad, especially when the case opens <code class="literal">READ</code> to <code class="literal">OTHERS</code>.</p></div><div class="section" title="GingerBreak"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>GingerBreak</h2></div></div></div><p>CVE-2011-1823 showcases a root attack on Android. The volume management daemon (vold) on Android<a id="id22" class="indexterm"/> is responsible for the mounting and <a id="id23" class="indexterm"/>unmounting of the external SD card. The daemon listens for messages over a NETLINK socket. The daemon never checked where the messages were sourced from, and any application could open and create a NETLINK socket to send messages to vold. Once the attacker opened the NETLINK socket, they sent a very carefully crafted message to bypass a sanity check. The check tested a signed integer for a maximum bound, but never checked it for negativity. It was then used to index an array. This negative access would lead to memory corruption and, with a proper message, could result in the execution of arbitrary code. The GingerBreak implementation resulted in an arbitrary user gaining root privileges, a textbook privilege execution attack. Once rooted, the device's sandboxes were no longer valid.</p></div><div class="section" title="Rage against the cage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Rage against the cage</h2></div></div></div><p>CVE-2010-EASY is a <code class="literal">setuid</code> exhaustion via fork bomb attack. It successfully attacks the <code class="literal">adb</code> daemon<a id="id24" class="indexterm"/> on Android, which starts life <a id="id25" class="indexterm"/>as root and downgrades its permissions if root is not needed. This attack keeps <code class="literal">adb</code> as <code class="literal">root</code> and returns a root shell to the user. In Linux kernel 2.6, the <code class="literal">setuid</code> system call returns an error when the number of running processes <code class="literal">RLIMIT_NPROC</code> is met. The <code class="literal">adb</code> daemon code does not check the return of <code class="literal">setuid</code>, which leaves a small race window open for the attacker. The attacker needs to fork enough processes to reach <code class="literal">RLIMIT_NPROC</code> and then kill the daemon. The <code class="literal">adb</code> daemon downgrades to shell <code class="literal">UID</code> and the attacker runs the program as shell <code class="literal">USER</code>, thus the kill will work. At this point, the <code class="literal">adb</code> service is respawned, and if <code class="literal">RLIMIT_NPROC</code> is maxed out, <code class="literal">setuid</code> will fail and <code class="literal">adb</code> will stay running as root. Then, running <code class="literal">adb</code> shell from a host returns a nice root shell to the user.</p></div><div class="section" title="MotoChopper"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>MotoChopper</h2></div></div></div><p>CVE-2013-2596 is a vulnerability in the <code class="literal">mmap</code> functionality of a Qualcomm video driver. Access<a id="id26" class="indexterm"/> to the GPU is provided by apps to do advanced<a id="id27" class="indexterm"/> graphics rendering such as in the case of OpenGL calls. The vulnerability in <code class="literal">mmap</code> allows the attacker to <code class="literal">mmap</code> kernel address space, at which point the attacker is able to directly change their kernel credential structure. This exploit is an example where the DAC model was not at fault. In reality, outside of patching the code or removing direct graphics access, nothing but programming checks of the <code class="literal">mmap</code> bounds could have prevented this attack.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>The DAC model is extremely powerful, but its lack of fine granularity and use of an extraordinarily powerful <code class="literal">root</code> user leaves something to be desired. With the increasing sensitivity of mobile handset use, the case to increase the security of the system is well-founded. Thankfully, Android is built on Linux and thus benefits from a large ecosystem of engineers and researchers. Since the Linux Kernel 2.6, a new access control model called <span class="strong"><strong>Mandatory Access Controls (MAC)</strong></span> was added. This is a framework by which modules can be loaded into the kernel to provide a new form of access control model. The very first module was called SELinux. It is used by Red Hat and others to secure sensitive government systems. Thus, a solution was found to enable such access controls for Android.</p></div></body></html>