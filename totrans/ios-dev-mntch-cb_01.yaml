- en: Chapter 1. Development Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 开发工具
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Installing pre-requisites
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: Creating an iPhone project with MonoDevelop
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MonoDevelop 创建 iPhone 项目
- en: Interface builder
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界面构建器
- en: Creating the UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UI
- en: Accessing the UI with outlets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 outlets 访问 UI
- en: Adding actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加动作
- en: Compiling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译
- en: Debugging our application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试我们的应用程序
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most important things professionals care about is the tools that
    are required to perform their work. Just as carpenters need a chisel to scrape
    wood, or photographers need a camera to capture light, we as developers need certain
    tools that we cannot work without.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 专业人士最关心的一件重要事情是完成工作所需的工具。正如木匠需要凿子来刮木料，或者摄影师需要相机来捕捉光线一样，我们作为开发者需要某些工具，没有这些工具我们无法工作。
- en: In this chapter, we will provide information on what **Integrated Development
    Environments (IDEs)** and **Software Development Kits (SDKs)** are needed to develop
    applications for iOS, Apple's operating system for the company's mobile devices.
    We will describe what every tool's role is in the development cycle and step through
    each one's important features that are essential to develop our first application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提供有关开发 iOS 应用程序所需的信息，iOS 是苹果公司移动设备的操作系统。我们将描述每个工具在开发周期中的作用，并逐步介绍每个工具的重要特性，这些特性对于开发我们的第一个应用程序至关重要。
- en: 'The tools needed to develop applications for iOS are the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 iOS 应用程序所需的工具如下：
- en: '**An Intel-based Mac computer running Snow Leopard (10.6.*) or Lion (10.7.*)
    operating system:** The essential programs we need cannot be installed on other
    computer platforms.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于英特尔处理器的运行 Snow Leopard (10.6.*) 或 Lion (10.7.*) 操作系统的 Mac 计算机：** 我们需要的必要程序无法安装在其他计算机平台上。'
- en: '**iOS SDK version 3.2 or higher:** To be able to download iOS SDK, a developer
    must be registered as an Apple developer. iOS SDK, among other things, includes
    two essential components.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS SDK 版本 3.2 或更高：** 要能够下载 iOS SDK，开发者必须注册为苹果开发者。iOS SDK 包括两个基本组件。'
- en: '**Xcode:** Apple''s IDE for developing native applications for iOS and Mac
    with the Objective-C programming language.'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xcode：** 苹果公司使用 Objective-C 编程语言开发 iOS 和 Mac 原生应用程序的 IDE。'
- en: '**iOS Simulator:** An essential program to debug iOS apps on the computer,
    without the need of a device. Note that there are many iOS features that do not
    work on the simulator; hence, a device is needed if an app uses these features.'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS 模拟器：** 在计算机上调试 iOS 应用程序的一个基本程序，无需设备。请注意，许多 iOS 功能在模拟器上无法工作；因此，如果应用程序使用这些功能，则需要设备。'
- en: Both the registration and SDK download are free of charge from Apple's Developer
    portal ([http://developer.apple.com](http://developer.apple.com) ). If we want
    to run and debug our applications on the device or distribute them on the App
    Store, we need to enroll with the iOS developer program, which requires a subscription
    fee.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在苹果开发者门户（[http://developer.apple.com](http://developer.apple.com)）上注册和 SDK 下载都是免费的。如果我们想在设备上运行和调试我们的应用程序或在
    App Store 上分发它们，我们需要注册 iOS 开发者计划，该计划需要订阅费。
- en: '**Mono for Mac:** Mono is an open source implementation of Microsoft''s .NET
    framework. It provides a multi-platform set of tools, libraries, and compilers
    to develop .NET applications on all mainstream computer operating systems (Linux,
    Mac, and Windows). We need the latest Mac installer, available from Mono''s website.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mono for Mac：** Mono 是微软 .NET 框架的开源实现。它提供了一套跨平台工具、库和编译器，用于在所有主流计算机操作系统（Linux、Mac
    和 Windows）上开发 .NET 应用程序。我们需要从 Mono 的网站上获取的最新 Mac 安装程序。'
- en: '**MonoTouch:** MonoTouch is an SDK, based on Mono. It provides .NET developers
    with the ability to develop applications for iOS, using C# as a programming language.
    A free evaluation version is available on the MonoTouch website ([http://ios.xamarin.com](http://ios.xamarin.com)
    ), which has all the features of the commercial versions to debug and run applications
    on iOS Simulator, without an expiration limit. For deploying applications on a
    device, or distributing on Apple''s App Store, purchasing a commercial license
    is required.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MonoTouch：** MonoTouch 是基于 Mono 的 SDK，它为 .NET 开发者提供了使用 C# 作为编程语言开发 iOS 应用程序的能力。MonoTouch
    网站上提供免费评估版本（[http://ios.xamarin.com](http://ios.xamarin.com)），具有商业版本的所有功能，可以在
    iOS 模拟器上调试和运行应用程序，没有过期限制。要在设备上部署应用程序或在 Apple 的 App Store 上分发，需要购买商业许可证。'
- en: '**MonoDevelop:** MonoDevelop is an open source IDE for .NET development. It
    provides developers with lots of features, such as code completion, database browsing,
    debuggers, and so on. The Mac version provides iOS project templates and MonoTouch
    integration.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MonoDevelop：** MonoDevelop 是一个用于 .NET 开发的开源 IDE。它为开发者提供了许多功能，例如代码补全、数据库浏览、调试器等。Mac
    版本提供了 iOS 项目模板和 MonoTouch 集成。'
- en: This chapter will also describe how to create our first iPhone project with
    MonoDevelop, construct its UI with Interface Builder, and how to access the application's
    user interface from within our code, with the concepts of **Outlets** and **Actions**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将介绍如何使用 MonoDevelop 创建我们的第一个 iPhone 项目，使用 Interface Builder 构建其 UI，以及如何在我们的代码中访问应用程序的用户界面，包括
    **Outlets** 和 **Actions** 的概念。
- en: Last but not least, we will learn how to compile our application, the available
    compilation options we have, and how to debug on the simulator.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将学习如何编译我们的应用程序，可用的编译选项，以及如何在模拟器上进行调试。
- en: Installing pre-requisites
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: Information on how to download and install the necessary tools to develop with
    MonoTouch.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何下载和安装使用 MonoTouch 进行开发的必要工具的信息。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download all the necessary components on our computer. The first
    thing to do is register as an Apple Developer on[http://developer.apple.com](http://developer.apple.com)
    . The registration is free and easy and provides access to all necessary development
    resources. After the registration is confirmed through e-mail, we can log in and
    download the iOS SDK from the address `https://developer.apple.com/devcenter/ios/index.action#downloads`.
    At the time of writing, Xcode's latest version is 4.2, and iOS SDK's latest version
    is 5.0.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的计算机上下载所有必要的组件。首先，需要在 [http://developer.apple.com](http://developer.apple.com)
    上注册为苹果开发者。注册是免费且简单的，并提供访问所有必要开发资源的权限。通过电子邮件确认注册后，我们可以登录并从地址 `https://developer.apple.com/devcenter/ios/index.action#downloads`
    下载 iOS SDK。在撰写本文时，Xcode 的最新版本是 4.2，iOS SDK 的最新版本是 5.0。
- en: At times, when Apple introduces beta versions of its components, they are made
    available through its portal. Although everyone registered can download and use
    these components, our already installed version of MonoTouch might not work correctly
    with the beta version of iOS SDK or Xcode. So, this must be taken into account
    when downloading and installing new beta versions from Apple Developer portal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当苹果推出其组件的测试版时，它们将通过其门户提供。尽管所有注册用户都可以下载和使用这些组件，但我们的已安装的 MonoTouch 版本可能无法正确与
    iOS SDK 或 Xcode 的测试版兼容。因此，在从苹果开发者门户下载和安装新测试版时必须考虑这一点。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To prepare our computer for iOS development, we need to download and install
    the necessary components in the following order:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们的计算机进行 iOS 开发，我们需要按照以下顺序下载和安装必要的组件：
- en: '**Xcode and iOS SDK on OS X Snow Leopard:** After downloading the image file,
    mount it, and in the window that will pop up, double-click on the Xcode and iOS
    SDK icon to start the installation. For the installation to proceed, it is necessary
    to read and accept the two licensing agreements that will be shown. After that,
    all you need to do is select the destination of the installation and click on
    **Continue**.![How to do it...](img/1468EXP_01_01.jpg)'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 OS X Snow Leopard 上的 Xcode 和 iOS SDK：** 下载镜像文件后，将其挂载，然后在将弹出的窗口中双击 Xcode
    和 iOS SDK 图标以开始安装。为了继续安装，必须阅读并接受将显示的两个许可协议。之后，您只需选择安装位置并点击 **继续**。![如何操作...](img/1468EXP_01_01.jpg)'
- en: '**Xcode and iOS SDK on OS X Lion:** To install Xcode and the SDK, a login to
    the Mac App Store is required. The downloaded files are basically an installer
    for Xcode and the SDK. When the download completes, run the Install Xcode application,
    and follow the installation instructions.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 OS X Lion 上的 Xcode 和 iOS SDK：** 要安装 Xcode 和 SDK，需要登录 Mac App Store。下载的文件基本上是
    Xcode 和 SDK 的安装程序。下载完成后，运行 Install Xcode 应用程序，并按照安装说明进行操作。'
- en: '**Download and install Mono for Mac:** The Mac version of Mono can be downloaded
    through the Mono Project''s website: [http://www.mono-project.com](http://www.mono-project.com).'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载和安装 Mono for Mac：** Mono 的 Mac 版本可以通过 Mono 项目网站：[http://www.mono-project.com](http://www.mono-project.com)
    下载。'
- en: '**Download and install MonoTouch:** The latest evaluation version can be downloaded
    from [http://ios.xamarin.com/DownloadTrial](http://ios.xamarin.com/DownloadTrial)
    by providing an e-mail address.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载和安装 MonoTouch：** 可以通过提供电子邮件地址从 [http://ios.xamarin.com/DownloadTrial](http://ios.xamarin.com/DownloadTrial)
    下载最新的评估版本。'
- en: '**Download and install MonoDevelop 2.8+:** Although creating iOS applications
    with MonoTouch does not require MonoDevelop, installing it will make developing
    much easier. It can be downloaded from [http://monodevelop.com/Download](http://monodevelop.com/Download).'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载并安装 MonoDevelop 2.8+**：尽管使用 MonoTouch 创建 iOS 应用程序不需要 MonoDevelop，但安装它会使开发变得更加容易。可以从
    [http://monodevelop.com/Download](http://monodevelop.com/Download) 下载。'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Now that we have everything ready, let's see what each component is needed for.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有东西，让我们看看每个组件需要什么。
- en: As stated in the introduction of this chapter, the iOS SDK contains three important
    components. The first component, **Xcode,** is Apple's IDE for developing applications
    for both iOS and Mac platforms. It is targeted on the Objective-C programming
    language, which is the main language to program in, with the iOS SDK. Since MonoTouch
    is an SDK for the C# language, one might wonder what we need Xcode for. Apart
    from providing various tools for debugging iOS applications, Xcode provides us
    with three important components that we need. The first one is a device information
    window, called **Organizer**, shown in the following screenshot, which is necessary
    to install the various certificates and provisioning profiles that are required
    for deploying our application on a device or distributing through the App Store.
    From within the Organizer, we can view debugging information of our applications,
    crash logs, and even take screenshots from the device! Of course, these are only
    a few of the many features Xcode provides, but they are outside of the scope of
    this book to discuss.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，iOS SDK 包含三个重要组件。第一个组件是 **Xcode**，它是 Apple 为 iOS 和 Mac 平台开发应用程序的 IDE。它针对
    Objective-C 编程语言，这是在 iOS SDK 中编程的主要语言。由于 MonoTouch 是 C# 语言的 SDK，人们可能会 wonder 我们为什么需要
    Xcode。除了提供各种调试 iOS 应用程序的工具外，Xcode 还为我们提供了三个重要的组件。第一个是一个设备信息窗口，称为 **组织者**，如图所示，这是在设备上部署我们的应用程序或通过
    App Store 分发所必需的证书和配置文件。在组织者内部，我们可以查看我们应用程序的调试信息、崩溃日志，甚至从设备上获取截图！当然，这些只是 Xcode
    提供的许多功能中的一部分，但它们超出了本书的讨论范围。
- en: '![How it works...](img/1468EXP_01_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1468EXP_01_02.jpg)'
- en: The second component is **Interface Builder.** This is the user interface designer,
    which was formerly a standalone application. Starting with Xcode 4.0, it is integrated
    into the IDE. Interface Builder provides all the necessary functionality to construct
    an application user interface. It is also quite different to what .NET developers
    have been accustomed to.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件是 **界面构建器**。这是一个用户界面设计器，以前是一个独立的应用程序。从 Xcode 4.0 开始，它被集成到 IDE 中。界面构建器提供了构建应用程序用户界面所需的所有必要功能。它也与
    .NET 开发者所习惯的不同。
- en: 'The third component is **iOS Simulator**. It is exactly what its name suggests:
    a device simulator, which we can use to run our applications on, without the need
    for an actual device. The important thing of iOS Simulator is that it has the
    option of simulating older iOS versions (if they are installed on the computer);
    both iPhone and iPad interfaces and device orientations. But, the simulator lacks
    some device features that are dependent on hardware, such as the compass or accelerometer.
    Applications using these features must be tested and debugged on an actual device.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个组件是 **iOS 模拟器**。正如其名称所暗示的那样：一个设备模拟器，我们可以用它来运行我们的应用程序，而无需实际设备。iOS 模拟器的重要之处在于它可以选择模拟较旧的
    iOS 版本（如果它们已安装在计算机上）；包括 iPhone 和 iPad 的界面和设备方向。但是，模拟器缺少一些依赖于硬件的设备功能，例如指南针或加速度计。使用这些功能的应用程序必须在实际设备上进行测试和调试。
- en: 'Mono is an open source implementation of the .NET framework. It has been around
    for quite some time now and provides .NET developers the ability to program applications
    with .NET languages, while targeting all mainstream operating systems: Linux,
    Mac, and Windows. Both MonoTouch and MonoDevelop depend heavily on Mono, making
    it a necessary asset.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Mono 是 .NET 框架的开源实现。它已经存在一段时间了，并为 .NET 开发者提供了使用 .NET 语言编程应用程序的能力，同时针对所有主流操作系统：Linux、Mac
    和 Windows。MonoTouch 和 MonoDevelop 都高度依赖于 Mono，使其成为一项必要的资产。
- en: MonoDevelop is an open source IDE for developing applications with Mono (and
    the .NET framework on Windows). It provides code completion, database browser,
    GTK# designer, debuggers, and, in our case, the necessary components to develop
    iOS applications easily and effectively. It integrates with MonoTouch perfectly,
    classifying both as a complete iOS development environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: MonoDevelop 是一个开源 IDE，用于使用 Mono（以及 Windows 上的 .NET 框架）开发应用程序。它提供代码补全、数据库浏览器、GTK#
    设计器、调试器，以及在我们的情况下，开发 iOS 应用程序所需的各种组件，以便轻松有效地开发。它与 MonoTouch 完美集成，将两者都归类为完整的 iOS
    开发环境。
- en: 'MonoTouch is the SDK that allows .NET developers to develop applications for
    the iOS, using the C# programming language. There is a common misconception, mostly
    among new developers: since MonoTouch provides the ability to program with C#,
    one can install and use it on a Windows computer. This is totally wrong, since
    MonoTouch is wrapped around iOS SDK''s libraries, which can only be installed
    on a Mac computer. Another misconception is that applications developed with MonoTouch
    being ".NET capable" require a virtual machine of some kind to be installed on
    the device to run, and they will run slower due to this virtual machine. This
    is also wrong, since MonoTouch''s advanced compiler takes care of it by compiling
    our C# ".NET powered" code to native machine code. Also, a virtual machine being
    installed on a device is against Apple''s guidelines.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: MonoTouch 是一个 SDK，允许 .NET 开发者使用 C# 编程语言为 iOS 开发应用程序。有一个常见的误解，尤其是在新开发者中：由于 MonoTouch
    提供了使用 C# 编程的能力，因此可以在 Windows 计算机上安装并使用它。这是完全错误的，因为 MonoTouch 是围绕 iOS SDK 的库构建的，这些库只能在
    Mac 计算机上安装。另一个误解是，使用 MonoTouch 开发的 ".NET 兼容" 应用程序需要在设备上安装某种类型的虚拟机才能运行，并且由于这个虚拟机，它们将运行得更慢。这也是错误的，因为
    MonoTouch 的先进编译器通过将我们的 C# ".NET 驱动的" 代码编译成原生机器代码来处理这个问题。此外，在设备上安装虚拟机违反了苹果的指导方针。
- en: There's more...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Applications developed with MonoTouch have the same chances of making it to
    the App Store as all other applications developed with the native Objective-C
    programming language! Meaning, if an application does not conform to Apple's strict
    policy about application acceptance, it will fail, whether it is written in either
    Objective-C or C#. The MonoTouch team has done a great job in creating an SDK
    that leaves the developer to only worry about the design and best practice of
    the code and nothing else. In April 2010, Apple made a modification on its application
    submission policy, which actually banned all applications from being submitted
    to the App Store that weren't created with the company's development tools. MonoTouch
    was one of them. Apart from the concern that emerged among developers who had
    already invested in MonoTouch, applications created with it were normally accepted
    on the App Store. In September 2010, Apple modified its policy and relaxed the
    matter, bringing relief to C# developers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MonoTouch 开发的应用程序进入 App Store 的机会与其他使用原生 Objective-C 编程语言开发的应用程序一样！这意味着，如果一个应用程序不符合苹果关于应用程序接受度的严格政策，它将失败，无论它是用
    Objective-C 还是 C# 编写的。MonoTouch 团队在创建一个让开发者只需担心代码的设计和最佳实践，而无需担心其他事情的 SDK 方面做得非常出色。2010
    年 4 月，苹果对其应用程序提交政策进行了修改，实际上禁止了所有未使用公司开发工具创建的应用程序提交到 App Store。MonoTouch 就是其中之一。除了已经投资于
    MonoTouch 的开发者中出现的担忧之外，使用它创建的应用程序通常会被 App Store 接受。2010 年 9 月，苹果修改了其政策，放宽了这一规定，为
    C# 开发者带来了安慰。
- en: Useful links
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用链接
- en: 'The following is a list of the links that contain the tools and information
    for installing them:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一份包含安装所需工具和信息的链接列表：
- en: '**Apple iOS developer portal:**[http://developer.apple.com/devcenter/ios/ index.action](http://developer.apple.com/devcenter/ios/%20index.action)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**苹果 iOS 开发者门户**：[http://developer.apple.com/devcenter/ios/index.action](http://developer.apple.com/devcenter/ios/%20index.action)'
- en: '**Mono:**[http://www.mono-project.com](http://www.mono-project.com)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mono**：[http://www.mono-project.com](http://www.mono-project.com)'
- en: '**MonoDevelop:**[http://www.monodevelop.com](http://www.monodevelop.com)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MonoDevelop**：[http://www.monodevelop.com](http://www.monodevelop.com)'
- en: '**MonoTouch:**[http://ios.xamarin.com](http://ios.xamarin.com)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MonoTouch**：[http://ios.xamarin.com](http://ios.xamarin.com)'
- en: '**MonoTouch installation guide:**[http://ios.xamarin.com/Documentation/ Installation](http://ios.xamarin.com/Documentation/%20Installation)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MonoTouch 安装指南**：[http://ios.xamarin.com/Documentation/Installation](http://ios.xamarin.com/Documentation/%20Installation)'
- en: '**Info about Apple developer tools:** [http://developer.apple.com/ technologies/tools/xcode.html](http://developer.apple.com/%20technologies/tools/xcode.html)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于苹果开发者工具的信息**：[http://developer.apple.com/technologies/tools/xcode.html](http://developer.apple.com/%20technologies/tools/xcode.html)'
- en: Updates
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: MonoDevelop has a feature for checking for available updates. Whenever the program
    starts, it checks for updates of MonoDevelop itself, MonoTouch, and the Mono framework.
    It can be turned off, but it is not recommended, since it helps staying up-to-date
    with the latest versions. It can be found under **MonoDevelop | Check for Updates**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MonoDevelop 有一个检查可用更新的功能。每次程序启动时，它都会检查 MonoDevelop 本身、MonoTouch 和 Mono 框架的更新。它可以关闭，但并不推荐，因为它有助于保持与最新版本的同步。可以在**MonoDevelop
    | 检查更新**下找到。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Compiling*'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译*'
- en: '*Debugging our application*'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试我们的应用程序*'
- en: '[Chapter 14](ch14.html "Chapter 14. Deploying"),Deploying:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 14 章](ch14.html "第 14 章。部署"),部署：'
- en: '*Debugging on other devices*'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在其他设备上调试*'
- en: '*Preparing our application for the App Store*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为 App Store 准备我们的应用程序*'
- en: Creating an iPhone project with MonoDevelop
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MonoDevelop 创建 iPhone 项目
- en: In this task, we will discuss creating our first iPhone project with the MonoDevelop
    IDE.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将讨论使用 MonoDevelop IDE 创建我们的第一个 iPhone 项目。
- en: Getting ready...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中...
- en: Now that we have all the pre-requisites installed, we will discuss how to create
    our first iPhone project with MonoDevelop.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有先决条件，我们将讨论如何使用 MonoDevelop 创建我们的第一个 iPhone 项目。
- en: Start MonoDevelop. It can be found in the `Applications` folder. MonoDevelop's
    default project location is the folder `/Users/{yourusername}/Projects`. If it
    does not exist on the hard disk, it will be created when we create our first project.
    If we want to change the folder, go to **MonoDevelop | Preferences** from the
    menu bar.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 MonoDevelop。它位于 `Applications` 文件夹中。MonoDevelop 的默认项目位置是文件夹 `/Users/{yourusername}/Projects`。如果硬盘上不存在，则在创建我们的第一个项目时创建。如果我们想更改文件夹，可以从菜单栏选择**MonoDevelop
    | 首选项**。
- en: Select **Load/Save** in the pane on the left, enter the preferred location for
    the projects in the field **Default Solution** location, and click on **OK**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧面板中选择**加载/保存**，在**默认解决方案位置**字段中输入项目首选位置，然后点击**确定**。
- en: '![Getting ready...](img/1468EXP_01_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![准备中...](img/1468EXP_01_03.jpg)'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The first thing that is loaded when starting MonoDevelop is its **Start** page.
    Select **File | New | Solution...**. from the menu bar. A window will be shown
    that provides us with the available project options.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 MonoDevelop 时，首先加载的是其**起始**页面。从菜单栏选择**文件 | 新建 | 解决方案...**。将显示一个窗口，提供给我们可用的项目选项。
- en: In this window, on the pane on the left, select **C# | MonoTouch | iPhone**.
    The iPhone project templates will be presented on the middle pane.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个窗口中，在左侧面板中选择**C# | MonoTouch | iPhone**。iPhone 项目模板将在中间面板中显示。
- en: 'Select **iPhone Single View Application**. Finally, enter `MyFirstiPhoneProject`
    for **Solution name** and click on **Forward**. The following screenshot displays
    the **New Solution** window:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**iPhone 单视图应用程序**。最后，为**解决方案名称**输入 `MyFirstiPhoneProject` 并点击**前进**。以下截图显示了**新解决方案**窗口：
- en: '![How to do it...](img/1468EXP_01_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_01_04.jpg)'
- en: That was it! You have just created your first iPhone project! You can build
    and run it. The **iOS Simulator** will start, with just a blank light-gray screen
    nevertheless.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就这样！你已经创建了你的第一个 iPhone 项目！你可以构建并运行它。**iOS 模拟器**将启动，但屏幕上仍然只有一个空白浅灰色屏幕。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the MonoTouch section on the left pane is not shown for some reason, it means
    that something went wrong with the installation of MonoTouch and/or MonoDevelop.
    Refer to the previous recipe for proper installation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因左侧面板中没有显示 MonoTouch 部分，这意味着 MonoTouch 和/或 MonoDevelop 的安装出了问题。请参考前面的配方进行正确安装。
- en: If the project templates in the middle are different than what is shown in this
    screenshot, it must be because you have a different version of MonoTouch and/or
    MonoDevelop than what was used for this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中间的模板与这个截图中的不同，那是因为你使用的 MonoTouch 和/或 MonoDevelop 版本与本书中使用的版本不同。
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's see what goes on behind the scenes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后发生了什么。
- en: When MonoDevelop creates a new iPhone, or better, iOS project, it creates a
    series of files. The solution structure is the same as if a .NET/Mono project
    was created, but with some extra files. The solution files can be viewed in the
    **Solution** pad on the left side of the MonoDevelop window. If the **Solution**
    pad is not visible, it can be activated by checking on **View | Pads | Solution**
    from the menu bar.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MonoDevelop 创建一个新的 iPhone 项目，或者更好的，iOS 项目时，它会创建一系列文件。解决方案的结构与创建 .NET/Mono
    项目时相同，但有一些额外的文件。解决方案文件可以在 MonoDevelop 窗口的左侧的 **Solution** 面板上查看。如果 **Solution**
    面板不可见，可以通过从菜单栏选择 **View | Pads | Solution** 来激活它。
- en: 'These files are the essential files that form an iPhone project:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是构成 iPhone 项目的必要文件：
- en: '![How it works...](img/1468EXP_01_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1468EXP_01_05.jpg)'
- en: MyFirstiPhoneProjectViewController.xib
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MyFirstiPhoneProjectViewController.xib
- en: This file is the file that contains the view of the application. `XIB` files
    are basically XML files with a specific structure that is readable from Interface
    Builder. They contain various information about the user interface, such as the
    type of controls it contains, their properties, Outlets, and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含应用程序视图的文件。`XIB` 文件基本上是具有特定结构的 XML 文件，可以从 Interface Builder 中读取。它们包含有关用户界面的各种信息，例如它包含的控件类型、它们的属性、出口等。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If `MyFirstiPhoneProjectViewController.xib`, or any other file with the `.xib`
    suffix is double-clicked, then MonoDevelop starts Xcode with the contents of the
    `XIB` file open in Interface Builder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果双击 `MyFirstiPhoneProjectViewController.xib` 或任何具有 `.xib` 后缀的文件，MonoDevelop
    将启动 Xcode，并在 Interface Builder 中打开 `XIB` 文件的内容。
- en: When we create a new interface with Interface Builder and save it, it is saved
    in the XIB format.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Interface Builder 创建一个新的界面并保存时，它将以 XIB 格式保存。
- en: MyFirstiPhoneProjectViewController.cs
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MyFirstiPhoneProjectViewController.cs
- en: 'This is the file that implements the view''s functionality. These are the contents
    of the file when it is created:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现视图功能的文件。创建时，文件的内容如下：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code in this file contains the class that corresponds to the view that
    will be loaded, along with some default method overrides. These methods are the
    ones that we will be using more frequently when we create view controllers. A
    brief description of each method is listed as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的代码包含与将要加载的视图相对应的类，以及一些默认方法的重写。这些是我们创建视图控制器时将更频繁使用的方法。以下是每个方法的简要描述：
- en: '`ViewDidLoad:` This method is called when the view of the controller is loaded.
    This is the method we use to initialize any additional components.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidLoad:` 当控制器视图加载时，会调用此方法。这是我们用来初始化任何附加组件的方法。'
- en: '`ViewDidUnload:` This method is called when the view is unloaded from memory.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidUnload:` 当视图从内存中卸载时，会调用此方法。'
- en: '`DidReceiveMemoryWarning:` This method is called when the application receives
    a memory warning. This method is responsible for unloading the view.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DidReceiveMemoryWarning:` 当应用程序收到内存警告时，会调用此方法。此方法负责卸载视图。'
- en: '`ShouldAutorotateToInterfaceOrientation:` We implement this method when we
    want our application to support multiple orientations.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShouldAutorotateToInterfaceOrientation:` 当我们希望我们的应用程序支持多种方向时，我们会实现此方法。'
- en: MyFirstiPhoneProjectViewController.designer.cs
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MyFirstiPhoneProjectViewController.designer.cs
- en: This is the file that holds our main window's class information in C# code.
    MonoDevelop creates one `.designer.cs` file for every `XIB` that is added in a
    project. The file is auto-generated every time we save a change in our `XIB` through
    Interface Builder. This is being taken care of by MonoDevelop, so that the changes
    we make in our interface are reflected right away in our code. We must not make
    changes to this file directly, since when the corresponding XIB is saved with
    Interface Builder, they will be lost. Also, if nothing is saved through Interface
    Builder, if changes are made to it manually, it will most likely result in a compilation
    error.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含我们的主窗口类信息的文件，使用 C# 代码编写。MonoDevelop 为项目中添加的每个 `XIB` 创建一个 `.designer.cs`
    文件。每次我们通过 Interface Builder 保存对 `XIB` 的更改时，该文件都会自动生成。这是由 MonoDevelop 负责的，以确保我们在界面中做出的更改能够立即反映到代码中。我们不得直接修改此文件，因为当相应的
    XIB 使用 Interface Builder 保存时，这些更改将会丢失。另外，如果通过 Interface Builder 没有保存任何内容，如果手动修改它，很可能会导致编译错误。
- en: 'These are the contents of the file when a new project is created:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新项目时，文件的内容如下：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Just like any other .NET project, a namespace is created with the name of the
    solution:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他 .NET 项目一样，会创建一个与解决方案名称相同的命名空间：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file contains the other partial declaration of our `MyFirstiPhoneProjectViewController`
    class. It is decorated with the `RegisterAttribute`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含我们`MyFirstiPhoneProjectViewController`类的其他部分声明。它被`RegisterAttribute`装饰。
- en: The `RegisterAttribute` is used to expose classes to the underlying Objective-C
    runtime. The string parameter declares by what name our class will be exposed
    to the runtime. It can be whatever name we want it to be, but it is a good practice
    to always set it to our C# class' name. The attribute is used heavily in the internals
    of MonoTouch, since it is what binds all native `NSObject` classes with their
    C# counterparts.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterAttribute`用于将类暴露给底层的Objective-C运行时。字符串参数声明了我们的类将以什么名称暴露给运行时。它可以是我们想要的任何名称，但始终将其设置为我们的C#类名称是一个好习惯。该属性在MonoTouch的内部使用得非常频繁，因为它将所有本地的`NSObject`类与其C#对应类绑定在一起。'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`NSObject` is a root class or base class. It is the equivalent of `System.Object`
    in the .NET world. The only difference between the two is that all .NET objects
    inherit from `System.Object`, but most, not all, Objective-C objects inherit from
    `NSObject` in Objective-C. The C# counterparts of all native objects that inherit
    from `NSObject` also inherit from its MonoTouch `NSObject` counterpart.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSObject`是一个根类或基类。在.NET世界中，它相当于`System.Object`。两者之间的唯一区别是，所有.NET对象都继承自`System.Object`，但在Objective-C中，大多数（而不是所有）Objective-C对象继承自`NSObject`。所有继承自`NSObject`的本机对象的C#对应类也继承自其MonoTouch
    `NSObject`对应类。'
- en: AppDelegate.cs
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AppDelegate.cs
- en: 'This file contains the class `AppDelegate`. The contents of the file are listed
    below:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含`AppDelegate`类。文件内容如下：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first part is familiar to .NET developers and consists of the appropriate
    `using` directives that import the required namespaces to use.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分对.NET开发者来说很熟悉，它包含适当的`using`指令，用于导入使用所需的命名空间。
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first three `using` directives allow us to use the specific and familiar
    namespaces from the .NET/Mono world with MonoTouch!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个`using`指令使我们能够使用.NET/Mono世界的特定和熟悉的命名空间与MonoTouch一起使用！
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the functionality the three namespaces (System, `System.Collections.Generic,
    System.Linq)` provide is almost identical to their well-known .NET/Mono counterparts,
    they are included in assemblies specifically created for use with MonoTouch and
    shipped with it, of course. An assembly compiled with .NET or Mono cannot be directly
    used in a MonoTouch project.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三个命名空间（System, `System.Collections.Generic, System.Linq`）提供的功能几乎与它们知名的.NET/Mono对应项相同，但它们被包含在专门为与MonoTouch一起使用而创建的程序集内，并且当然与它一起分发。使用.NET或Mono编译的程序集不能直接用于MonoTouch项目。
- en: The `MonoTouch.Foundation` namespace is a wrapper around the native Objective-C
    foundation framework, which contains classes that provide basic functionality.
    These objects' names share the same "NS" prefix that is found in the native foundation
    framework. Some examples are `NSObject, NSString, NSValue`, and so on. Apart from
    `NS-prefixed` objects, the `MonoTouch.Foundation` namespace contains all of the
    attributes that are used for binding to native objects, such as the `RegisterAttribute`
    that we saw earlier. The `MonoTouch.UIKit` namespace is a wrapper around the native
    Objective-C `UIKit` framework. As its name suggests, the namespace contains classes,
    delegates, and events that provide us with interface functionality. Except for
    two classes, `DraggingEventArgs` and `ZoomingEventArgs`, all the objects' names
    share the same "UI" prefix. It should be clear at this point that these two namespaces
    are essential for all MonoTouch applications, and their objects will be used quite
    frequently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.Foundation`命名空间是对原生Objective-C基础框架的包装，其中包含提供基本功能的类。这些对象的名称与原生基础框架中找到的相同“NS”前缀相同。一些例子是`NSObject,
    NSString, NSValue`等等。除了`NS-前缀`对象外，`MonoTouch.Foundation`命名空间还包含用于绑定到原生对象的属性，例如我们之前看到的`RegisterAttribute`。`MonoTouch.UIKit`命名空间是对原生Objective-C
    `UIKit`框架的包装。正如其名称所暗示的，该命名空间包含提供界面功能的类、委托和事件。除了两个类`DraggingEventArgs`和`ZoomingEventArgs`外，所有对象的名称都共享相同的“UI”前缀。此时应该很清楚，这两个命名空间对于所有MonoTouch应用都是必不可少的，并且它们的对象将被频繁使用。'
- en: The class inherits from the `UIApplicationDelegate` class, qualifying it as
    our application's `UIApplication` **Delegate** object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该类继承自`UIApplicationDelegate`类，使其成为我们应用的`UIApplication` **Delegate**对象。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The concept of a Delegate object in the Objective-C world is somewhat different
    than a delegate in C#. It will be explained in detail in [Chapter 2](ch02.html
    "Chapter 2. User Interface: Views"), User Interface: Views.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 世界中，委托对象的概念与 C# 中的委托有所不同。这将在第 2 章[用户界面：视图](ch02.html "第 2 章。用户界面：视图")中详细解释。
- en: 'The `AppDelegate` class contains two fields and one method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppDelegate` 类包含两个字段和一个方法：'
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `UIWindow` object defines the main window of our application, while the
    `MyFirstiPhoneProjectViewController` is the variable, which will hold the application's
    view controller.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWindow` 对象定义了我们应用程序的主窗口，而 `MyFirstiPhoneProjectViewController` 是一个变量，它将持有应用程序的视图控制器。'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An iOS application typically has only one window, of type `UIWindow`. The concept
    of a `UIWindow` is somewhat different from a .NET `System.Windows.Form`. The `UIWindow`
    is the first control that is displayed when an application starts, and every subsequent
    views are hierarchically added below it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 应用程序通常只有一个窗口，类型为 `UIWindow`。`UIWindow` 的概念与 .NET `System.Windows.Form` 有所不同。`UIWindow`
    是应用程序启动时首先显示的控制，所有后续视图都按层次添加在其下方。
- en: The `FinishedLaunching` method, as its name suggests, is called when the application
    has completed its initialization process. This is the method where we must present
    the user interface to the user. The implementation of this method must be lightweight,
    since if it does not return in time from the moment it is called, iOS will terminate
    the application. This is for providing faster user interface loading times to
    the user by preventing developers from performing complex and long-running tasks
    upon initialization, such as connecting to a web service to receive data. The
    application parameter is the application's `UIApplication` object, which is also
    accessible through the static property `UIApplication.SharedApplication`. The
    options parameter may or may not contain information about the way the application
    was launched. We do not need it for now.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`FinishedLaunching` 方法在应用程序完成初始化过程时被调用。这是我们必须向用户展示用户界面的方法。此方法的实现必须轻量级，因为如果它不能在调用后及时返回，iOS
    将终止应用程序。这是为了通过防止开发者在初始化时执行复杂和长时间运行的任务（例如连接到网络服务以接收数据）来为用户提供更快的用户界面加载时间。应用程序参数是应用程序的
    `UIApplication` 对象，也可以通过静态属性 `UIApplication.SharedApplication` 访问。选项参数可能包含有关应用程序启动方式的信息，也可能不包含。目前我们不需要它。
- en: The `FinishedLaunching` method, as its name suggests, is called when the application
    has completed its initialization process. This is the method where we must present
    the user interface to the user. The implementation of this method must be lightweight,
    since if it does not return in time from the moment it is called, iOS will terminate
    the application. This is for providing faster user interface loading times to
    the user by preventing developers from performing complex and long-running tasks
    upon initialization, such as connecting to a web service to receive data. The
    application parameter is the application's `UIApplication` object, which is also
    accessible through the static property `UIApplication.SharedApplication`. The
    options parameter may or may not contain information about the way the application
    was launched. We do not need it for now.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`FinishedLaunching` 方法在应用程序完成初始化过程时被调用。这是我们必须向用户展示用户界面的方法。此方法的实现必须轻量级，因为如果它不能在调用后及时返回，iOS
    将终止应用程序。这是为了通过防止开发者在初始化时执行复杂和长时间运行的任务（例如连接到网络服务以接收数据）来为用户提供更快的用户界面加载时间。应用程序参数是应用程序的
    `UIApplication` 对象，也可以通过静态属性 `UIApplication.SharedApplication` 访问。选项参数可能包含有关应用程序启动方式的信息，也可能不包含。目前我们不需要它。
- en: 'The default implementation of the `FinishedLaunching` method for this type
    of project is the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型项目的 `FinishedLaunching` 方法的默认实现如下：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `UIWindow` object is initialized with the size of the screen.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWindow` 对象使用屏幕大小进行初始化。'
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The view controller is initialized and set as the window's root view controller.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器被初始化并设置为窗口的根视图控制器。
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The window is displayed on the screen with the `window.MakeKeyAndVisible()`
    call and the method returns. This method must be called inside the `FinishedLaunching`
    method, otherwise the application's user interface will not be presented as it
    should to the user. Last but not least, the `return true` line returns the method
    by marking its execution completion.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口通过`window.MakeKeyAndVisible()`调用显示在屏幕上，并且该方法返回。此方法必须在`FinishedLaunching`方法内部调用，否则应用程序的用户界面将不会按预期向用户展示。最后但同样重要的是，`return
    true`行通过标记其执行完成来返回方法。
- en: Main.cs
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Main.cs
- en: 'Inside the `Main.cs` file is where the runtime life-cycle of the program starts:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main.cs`文件中是程序运行时生命周期的开始：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Much like the following call in a .NET `System.Windows.Forms` application, the
    `UIApplication.Main` method starts the message loop, or run loop that is responsible
    for dispatching notifications to the application through the `AppDelegate` class,
    with event handlers that we can override.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于在.NET `System.Windows.Forms`应用程序中的以下调用，`UIApplication.Main`方法启动消息循环，或运行循环，负责通过`AppDelegate`类将通知派发到应用程序，其中包含我们可以重写的处理程序。
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Event handlers such as `FinishedLaunching, ReceiveMemoryWarning`, or `DidEnterBackground`
    are only some of these notifications. Apart from the notification dispatching
    mechanism, the `UIApplication` object holds a list of all `UIWindow` objects that
    exist; typically one. An iOS application must have one `UIApplication` object,
    or a class that inherits from it, and this object must have a corresponding `UIApplicationDelegate`
    object. This is the `AppDelegate` class implementation we saw earlier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序，如`FinishedLaunching`、`ReceiveMemoryWarning`或`DidEnterBackground`，只是这些通知中的一些。除了通知派发机制之外，`UIApplication`对象包含所有存在的`UIWindow`对象的列表；通常是其中一个。iOS应用程序必须有一个`UIApplication`对象，或者从它继承的类，并且该对象必须有一个相应的`UIApplicationDelegate`对象。这是我们之前看到的`AppDelegate`类实现。
- en: Info.plist
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Info.plist
- en: 'This file is basically the application''s settings file. It has a simple structure
    of properties with values that define various settings for an iOS application,
    such as the orientations it supports, its icon, supported iOS versions, what devices
    it can be installed on, and so on. If we double-click on this file in MonoDevelop,
    it will open in the embedded editor, specifically designed for `.plist` files.
    This is what our file in a new project looks like:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件基本上是应用程序的设置文件。它具有一个简单的属性值结构，定义了iOS应用程序的各种设置，例如它支持的朝向、图标、支持的iOS版本、它可以安装的设备等等。如果我们在这个文件上双击MonoDevelop，它将在嵌入的编辑器中打开，该编辑器专门设计用于`.plist`文件。这是新项目中我们的文件看起来像：
- en: '![Info.plist](img/1468EXP_01_06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Info.plist](img/1468EXP_01_06.jpg)'
- en: The `Info.plist` is an XML file. Although we can edit the file manually in a
    text editor, for example, it is not recommended. The embedded editor is the best
    way of editing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Info.plist`是一个XML文件。虽然我们可以在文本编辑器中手动编辑该文件，例如，但不建议这样做。嵌入的编辑器是编辑的最佳方式。'
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'MonoDevelop provides many different project templates for developing iOS applications.
    Here is a list that describes what each project template is for:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: MonoDevelop为开发iOS应用程序提供了许多不同的项目模板。以下是一个列表，描述了每个项目模板的用途：
- en: '**Empty project:** It is an empty project without any views.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空项目**: 它是一个没有任何视图的空项目。'
- en: '**Utility application:** It is a utility application is a special type of iOS
    application that provides one screen for functionality, and in many cases another
    one for configuration.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用应用程序**: 实用应用程序是一种特殊的iOS应用程序，它提供一屏功能，在许多情况下还提供另一屏进行配置。'
- en: '**Master-detail application:** This type of project creates a template that
    supports navigating through multiple screens. It contains two view controllers.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主从应用**: 这种类型的项目创建了一个支持在多个屏幕间导航的模板。它包含两个视图控制器。'
- en: '**Single view application:** This template type is the one we used in this
    recipe.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单视图应用**: 这种模板类型是我们在这个菜谱中使用的。'
- en: application:**Tabbed** It is a template that adds a tab bar controller that
    manages two view controllers in a tab-like interface.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签页应用**: 这是一个添加标签栏控制器以在类似标签的界面中管理两个视图控制器的模板。'
- en: '**OpenGL application:** It is a template for creating OpenGL-powered applications
    or games.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL应用**: 这是一个用于创建由OpenGL驱动的应用程序或游戏的模板。'
- en: These templates are available for the iPhone, the iPad, and Universal (both
    iPhone and iPad) projects. They are also available in Interface Builder's **Storyboarding**
    application design.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模板适用于iPhone、iPad和通用（iPhone和iPad）项目。它们也适用于Interface Builder的**Storyboarding**应用程序设计。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unless otherwise stated, all project templates referring to the iPhone are suitable
    for the iPod Touch as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，所有针对iPhone的项目模板也适用于iPod Touch。
- en: List of MonoTouch assemblies
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MonoTouch组件列表
- en: 'MonoTouch supported assemblies can be found in the following link: [http://ios.xamarin.com/Documentation/Assemblies](http://ios.xamarin.com/Documentation/Assemblies).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: MonoTouch支持的组件可以在以下链接中找到：[http://ios.xamarin.com/Documentation/Assemblies](http://ios.xamarin.com/Documentation/Assemblies)。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Creating the UI*'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建UI*'
- en: '*Accessing the UI with outlets*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过出口访问UI*'
- en: 'In this book:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中：
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"), User Interface:
    Views:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章 用户界面：视图")，用户界面：视图：'
- en: '*Adding and customizing views*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图*'
- en: Interface builder
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 界面构建器
- en: Introduction to Apple's user interface designer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果用户界面设计师简介。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: If you have installed the iOS SDK, then you already have Xcode with Interface
    Builder installed on your computer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装iOS SDK，那么您已经在计算机上安装了带有Interface Builder的Xcode。
- en: Go to MonoDevelop and open the project `MyFirstiPhoneProject` that we created
    earlier.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往MonoDevelop并打开我们之前创建的项目`MyFirstiPhoneProject`。
- en: In the **Solution** pad on the left, double-click on **MyFirstiPhoneProjectViewController.xib**.
    MonoDevelop starts Xcode with the file loaded in Interface Builder!
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的**解决方案**面板上，双击**MyFirstiPhoneProjectViewController.xib**。MonoDevelop会启动Xcode，并在Interface
    Builder中加载文件！
- en: 'On the right side of the toolbar, on the top of the Xcode window, select the
    appropriate editor and viewing options, as shown below:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏的右侧，在Xcode窗口的顶部，选择适当的编辑和查看选项，如下所示：
- en: '![How to do it...](img/1468EXP_01_07.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1468EXP_01_07.jpg)'
- en: 'The following screenshot demonstrates what Interface Builder looks like with
    a XIB file open:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图展示了打开XIB文件时的Interface Builder外观：
- en: '![How to do it...](img/1468EXP_01_08.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1468EXP_01_08.jpg)'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now that we have loaded Interface Builder with the view controller of our application,
    let's familiarize ourselves with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了带有我们应用程序视图控制器的Interface Builder，让我们熟悉一下它。
- en: 'The user interface designer is directly connected to an Xcode project. When
    we add an object, Xcode automatically generates code to reflect the change we
    made. MonoDevelop takes care of this for us, as when we double-click on a XIB
    file, it automatically creates a temporary Xcode project so that we can make the
    changes we want in the user interface. Therefore, we have nothing more to do than
    just design the user interface for our application:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面设计师直接连接到Xcode项目。当我们添加一个对象时，Xcode会自动生成代码来反映我们所做的更改。MonoDevelop会为我们处理这件事，因为当我们双击XIB文件时，它会自动创建一个临时Xcode项目，以便我们可以在用户界面中进行我们想要的更改。因此，我们除了设计我们应用程序的用户界面之外，没有更多的事情要做：
- en: Interface Builder is divided into three areas. A brief description of each area
    is described below.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 界面构建器分为三个区域。下面简要描述每个区域。
- en: '**Navigator area:** In this area, we can see the files included in the Xcode
    project.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导航区域**：在这个区域，我们可以看到Xcode项目中的文件。'
- en: '**Editor area:** This area is where we design the user interface.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑区域**：这个区域是我们设计用户界面的地方。'
- en: '**Utility area:** This area contains the **Inspector** and **Library** panes.
    The **Inspector** is where we configure each object, while the **Library** pane
    is where we find the objects.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实用区域**：这个区域包含**检查器**和**库**面板。**检查器**是我们配置每个对象的地方，而**库**面板是我们查找对象的地方。'
- en: The Editor area is divided into two sections. The one on the left is the **Designer**,
    while the one on the right is the **Assistant** editor. Inside the assistant editor,
    we see the underlying Objective-C source code file that corresponds to the selected
    item in the designer. Although we do not need to edit the Objective-C source,
    we will need the assistant editor later.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑区域分为两个部分。左侧的是**设计师**，而右侧的是**辅助**编辑器。在辅助编辑器内部，我们可以看到与设计师中选定的项目对应的底层Objective-C源代码文件。尽管我们不需要编辑Objective-C源代码，但我们稍后需要辅助编辑器。
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'We saw what a `XIB` file looks like in Interface Builder. But, there is more
    as far as these files are concerned. We mentioned earlier that `XIB` files are
    XML files with appropriate information readable by Interface Builder. The thing
    is that when a project is compiled, the compiler also compiles the `XIB` file,
    converting it to its binary equivalent: the `NIB` file. Both `XIB` and `NIB` files
    contain the exact same information. The only difference between them is that `XIB`
    files are in a human-readable form, while the `NIB` files are not. For example,
    when we compile the project we created, the `MyFirstiPhoneProjectViewController.xib`
    file will become `MyFirstiPhoneProjectViewController.nib` in the output folder.
    Apart from the binary conversion, the compiler also performs a compression on
    `NIB` files. So, NIB files will be significantly smaller in size than `XIB` files.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Interface Builder中看到了`XIB`文件的样子。但是，关于这些文件还有更多内容。我们之前提到，`XIB`文件是Interface
    Builder可读取的带有适当信息的XML文件。问题是，当项目编译时，编译器也会编译`XIB`文件，将其转换为二进制等效文件：`NIB`文件。`XIB`和`NIB`文件包含完全相同的信息。它们之间的唯一区别是，`XIB`文件是可读的，而`NIB`文件则不是。例如，当我们编译创建的项目时，`MyFirstiPhoneProjectViewController.xib`文件将在输出文件夹中变为`MyFirstiPhoneProjectViewController.nib`。除了二进制转换外，编译器还会对`NIB`文件进行压缩。因此，`NIB`文件的大小将比`XIB`文件小得多。
- en: That's not all about `XIB` files. The way a developer manages the `XIB` files
    in a project is very important in an application's performance and stability.
    It is better to have many, smaller in size `XIB` files, instead of one or two
    large ones. This can be accomplished by dividing the user interface in many `XIB`
    files. It may seem a bit difficult, but as we'll see later in this book, it is
    actually very easy. We need many, smaller `XIB` files instead of few and large
    ones because of the way iOS manages its memory. When an application starts, iOS
    loads the `NIB` files as a whole in memory, and thereafter, all the objects in
    it are instantiated. So, it is a waste of memory to keep objects in `NIB` files
    that are not always going to be used. Also, remember that you are developing for
    a mobile device whose available resources are not a match against desktop computers',
    no matter what its capabilities are.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`XIB`文件，还有更多内容。开发者如何管理项目中的`XIB`文件对于应用程序的性能和稳定性非常重要。最好有多个、较小的`XIB`文件，而不是一个或两个大的文件。这可以通过将用户界面分割成多个`XIB`文件来实现。这可能看起来有点困难，但正如我们将在本书后面看到的，这实际上非常简单。我们需要许多较小的`XIB`文件而不是少数几个大的文件，这是因为iOS管理内存的方式。当应用程序启动时，iOS会将`NIB`文件作为一个整体加载到内存中，然后，其中的所有对象都会被实例化。因此，保留那些不一定总是会被使用的对象在`NIB`文件中是一种内存浪费。此外，请记住，你正在为移动设备开发，其可用资源与桌面计算机相比并不匹配，无论其能力如何。
- en: More info
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多信息
- en: You may have noticed that in the **Attributes** tab in the **Inspector** pane,
    there is a section called **Simulated Metrics**. Options under this section help
    us see directly in the designer what our interface looks like with the device's
    status bar, a toolbar, or a navigation bar. Although these options are saved in
    the `XIB` files, they have nothing to do with the actual application at runtime.
    For example, if we set the **Status Bar** option to **None**, it does not mean
    that our application will start without a status bar.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在**检查器**面板的**属性**选项卡中，有一个名为**模拟度量**的部分。该部分下的选项帮助我们直接在设计器中看到我们的界面在设备的状态栏、工具栏或导航栏下的样子。尽管这些选项保存在`XIB`文件中，但它们与实际运行时的应用程序无关。例如，如果我们将**状态栏**选项设置为**无**，这并不意味着我们的应用程序将没有状态栏启动。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Status Bar** is the bar that is shown on the top portion of the device''s
    screen, which displays certain information to the user, such as the current time,
    battery status, carrier name on the iPhone, and so on.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态栏**是显示在设备屏幕顶部的一部分，向用户显示某些信息，如当前时间、电池状态、iPhone上的运营商名称等。'
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章：
- en: '*Creating the UI*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建UI*'
- en: '*Accessing the UI with outlets*'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过输出访问UI*'
- en: '*Adding actions*'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加动作*'
- en: 'In this book:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"), User Interface:Views:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。用户界面：视图"), 用户界面：视图：'
- en: '*Adding and customizing views*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图*'
- en: '[Chapter 3](ch03.html "Chapter 3. User Interface: View Controllers"): User
    Interface:View Controllers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面：视图控制器"): 用户界面：视图控制器：'
- en: '*View controllers and views*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视图控制器和视图*'
- en: Creating the UI
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建UI
- en: In this recipe, we will learn how to add and manage controls in the user interface.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在用户界面中添加和管理控件。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's add a few controls in an interface. Start by creating a new iPhone Single
    View Application project in MonoDevelop. Name the project `ButtonInput`. When
    it opens, double-click on `ButtonInputViewController.xib` in the **Solution**
    pad to open it with Interface Builder.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在界面中添加一些控件。首先，在MonoDevelop中创建一个新的iPhone单视图应用程序项目。将项目命名为`ButtonInput`。当它打开时，双击**解决方案**面板中的`ButtonInputViewController.xib`以使用Interface
    Builder打开它。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Now that we have a new project and Interface Builder has opened the `ButtonInputViewController.xib`
    file, we'll add some controls to it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新项目，Interface Builder已打开`ButtonInputViewController.xib`文件，我们将向其中添加一些控件。
- en: Add a label
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个标签
- en: Go to the **Library** pane and select **Objects** from the drop-down list, if
    it is not already selected. Select the **Label** object.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未选择，转到**库**面板并从下拉列表中选择**对象**。选择**标签**对象。
- en: Drag-and-drop the **Label** onto the gray space of the view in the designer,
    somewhere in the top half.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**标签**拖放到设计器中视图的灰色空间，位于上半部分。
- en: Select and resize the **Label** from both the left and right side, so that it
    snaps to the dashed line that will show up when you reach close to the edges of
    the view.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧和右侧选择并调整**标签**的大小，使其吸附到当您接近视图边缘时出现的虚线上。
- en: Again, with the **Label** selected, go to the **Inspector** pane, select the
    **Attributes** tab, and in the **Layout** section, click on the middle alignment
    button. Congratulations, you have just added a **Label** in your application's
    main view!
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，选择**标签**后，转到**检查器**面板，选择**属性**选项卡，然后在**布局**部分，点击中间的对齐按钮。恭喜你，你已经在应用程序的主视图中添加了一个**标签**！
- en: Add a button
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个按钮
- en: We will perform similar steps to add a button in our interface.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行类似的步骤来在我们的界面中添加按钮。
- en: Again, in the **Library** pane, in the **Objects** section, select the **Button**
    object. It is next to the **Label** object.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在**库**面板中，在**对象**部分，选择**按钮**对象。它位于**标签**对象旁边。
- en: Drag-and-drop it onto the bottom half of the view. Align its center with the
    center of the **Label** we added earlier. A dashed line will show up, and the
    **Button** will snap to it when the centers of the two controls are almost aligned.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其拖放到视图的下半部分。将其中心与之前添加的**标签**的中心对齐。会出现一条虚线，当两个控件的中心几乎对齐时，**按钮**会自动吸附到它上。
- en: Resize the **Button** to the same width of the **Label**. Since the **Label**
    has a transparent background and you cannot see how wide it is exactly, you will
    know when the **Button** is the same width when three dashed lines will show up
    while you are resizing it.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**按钮**调整到与**标签**相同的宽度。由于**标签**具有透明背景，您无法确切地看到它的宽度，因此当您调整大小并出现三条虚线时，您就会知道**按钮**的宽度相同。
- en: Now, let's add some text to the **Button**. Select it and go to the **Inspector**
    pane. In the **Attributes** tab, in the **Title** field, enter `Tap here please!`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们向**按钮**添加一些文本。选择它并转到**检查器**面板。在**属性**选项卡中，在**标题**字段中输入`请点击此处！`。
- en: 'After adding the button, save the document through **File | Save** in the menu
    bar. The main view should now look like the following screenshot (shown resized
    here):'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加按钮后，通过菜单栏中的**文件 | 保存**保存文档。主视图现在应该看起来像以下截图（在此处显示已调整大小）：
- en: '![Add a button](img/1468EXP_01_09.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![添加一个按钮](img/1468EXP_01_09.jpg)'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, although some concepts of Interface Builder seem difficult,
    it is quite easy to use. It also provides a lot of feedback. When we drag objects,
    a green-circled cross appears on the cursor to declare that we can drop the object
    there. Also, when we resize a control, we see its dimensions next to it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管Interface Builder的一些概念似乎很难，但它使用起来相当简单。它还提供了很多反馈。当我们拖动对象时，光标上会出现一个绿色的圆形十字，表示我们可以将对象放在那里。此外，当我们调整控件大小时，我们会在其旁边看到其尺寸。
- en: You can also resize and position the controls by modifying the values in the
    **Size** tab of the **Inspector** pane. Another useful feature in the **Size**
    tab is **Autosizing. Autosizing** provides layout options for the controls and
    can be very useful when we want our application to support different device orientations.
    You can select a control you want, and then click on the lines that are outside
    or inside of the square on the left in the **Autosizing** section. The image next
    to it animates to give you an impression of how the control will behave when the
    layout changes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过修改**检查器**面板中**大小**选项卡中的值来调整控件的大小和位置。**大小**选项卡中的另一个有用功能是**自动调整大小**。**自动调整大小**为控件提供布局选项，当我们的应用程序需要支持不同的设备方向时，这可以非常有用。您可以选择一个控件，然后点击**自动调整大小**部分中左边的正方形外部或内部的线条。旁边的图像会动画显示，给您一个印象，当布局改变时控件将如何表现。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Now, let's try running the application on the iOS Simulator. Back at MonoDevelop,
    select the project configuration at **Debug | iPhoneSimulator** if it is not already
    selected. No need to do anything else in the code for now; just click on the **Run**
    button. It is the third button on the right of the configuration combo box, with
    the double gear icon. When the compilation finishes, iOS Simulator will start
    automatically and will run the application we just created! You can even "tap"
    on the **Button** by clicking on it with the mouse and see it responding. Of course,
    our application does not have any other functionality right now.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在iOS模拟器上运行应用程序。回到MonoDevelop，如果尚未选择，请选择**调试 | iPhoneSimulator**的项目配置。现在代码中不需要做任何事情；只需点击**运行**按钮。它是配置组合框右侧的第三个按钮，带有双齿轮图标。当编译完成后，iOS模拟器将自动启动并运行我们刚刚创建的应用程序！您甚至可以用鼠标点击**按钮**来“点击”它，并看到它的响应。当然，我们的应用程序目前没有任何其他功能。
- en: Setting titles on buttons
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置按钮标题
- en: Setting the title of a **Button** or a **Label** can easily be done just by
    double-clicking on it and typing the preferable title. Do it, and watch how Interface
    Builder behaves to show you what action is to be performed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双击并输入首选标题，可以轻松地设置**按钮**或**标签**的标题。这样做，并观察Interface Builder如何显示要执行的操作。
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Compiling*'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译*'
- en: '*Debugging our application*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试我们的应用程序*'
- en: 'In this book:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"), User Interface:
    Views:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。用户界面：视图"), 用户界面：视图：'
- en: '*Receiving user input with buttons*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用按钮接收用户输入*'
- en: '*Using labels to display text*'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标签显示文本*'
- en: Accessing the UI with outlets
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过出口访问UI
- en: In this recipe, we will discuss the concept of **Outlets** and their usage with
    MonoTouch.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论**出口**的概念以及它们与MonoTouch的用法。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the previous task, we learned how to add controls to form a basic interface
    for our application. In this task, we will discuss how to access and use these
    controls in our code. Launch MonoDevelop, and open the project `ButtonInput` that
    we created earlier. Open the project's `ButtonInputViewController.xib` in Interface
    Builder by double-clicking on it in the **Solution** pad.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个任务中，我们学习了如何添加控件来形成我们应用程序的基本界面。在本任务中，我们将讨论如何在代码中访问和使用这些控件。启动MonoDevelop，并打开我们之前创建的项目`ButtonInput`。通过在**解决方案**面板中双击它来在Interface
    Builder中打开项目的`ButtonInputViewController.xib`。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With the **Assistant Editor** open, *Ctrl-drag* from the label to the Objective-C
    source file, as displayed in the following screenshot:![How to do it...](img/1468EXP_01_10.jpg)
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**辅助编辑器**，*Ctrl-drag*从标签到Objective-C源文件，如图下所示：![如何操作...](img/1468EXP_01_10.jpg)
- en: 'When you release the cursor, a context window will appear, similar to the one
    in the following screenshot:'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您释放鼠标时，会出现一个上下文窗口，类似于以下截图：
- en: '![How to do it...](img/1468EXP_01_11.jpg)'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_01_11.jpg)'
- en: In the **Name** field of the context window, enter `labelStatus,` and click
    on **Connect**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上下文窗口的**名称**字段中输入`labelStatus,`，然后点击**连接**。
- en: Do the same for the button, and name it `buttonTap`. Save the Interface Builder
    document by selecting **File | Save** in the menu bar, or by pressing *Option*
    - *S* on the keyboard.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对按钮也做同样的操作，命名为`buttonTap`。通过在菜单栏中选择**文件 | 保存**或按键盘上的*Option* - *S*来保存Interface
    Builder文档。
- en: 'Back in MonoDevelop, enter the following code in the `ViewDidLoad` method of
    the `ButtonInputViewController` class:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到MonoDevelop，在`ButtonInputViewController`类的`ViewDidLoad`方法中输入以下代码：
- en: '[PRE11]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code snippet adds a handler to the button's TouchUpInside event. This event
    is similar to the Clicked event of a Button control in System.Windows.Forms. It
    also displays the usage of an anonymous method, which just shows how MonoTouch
    provides C# features to .NET developers. That's it! Our application is now ready
    with functional controls.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码片段为按钮的TouchUpInside事件添加了一个处理程序。这个事件类似于System.Windows.Forms中按钮控制的Clicked事件。它还展示了匿名方法的使用，这仅仅显示了MonoTouch如何为.NET开发者提供C#功能。就是这样！我们的应用程序现在已经准备好了，带有功能性的控件。
- en: Compile and run it on the simulator. See the label changing its text when you
    tap on the button.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行它。当你点击按钮时，你会看到标签文本的变化。
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The outlet mechanism is basically a way of connecting Interface Builder objects
    with the code. They are necessary, since it is the only way we can access user
    interface objects that we create with Interface Builder. This is how Interface
    Builder works, and it is not just a MonoTouch workaround. An outlet of an object
    provides a variable of this object, so that we will be able to use it in a project.
    MonoTouch makes a developer''s life much easier, because when we create outlets
    in Interface Builder and connect them, MonoDevelop works in the background by
    auto-generating code regarding those outlets. This is what the `ButtonInputViewController.designer.cs`
    has added to provide us access to the controls we created:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 出口机制基本上是一种将Interface Builder对象与代码连接起来的方式。它们是必要的，因为这是我们访问使用Interface Builder创建的用户界面对象的唯一方式。这就是Interface
    Builder的工作方式，它不仅仅是MonoTouch的解决方案。一个对象的出口提供了一个变量，这样我们就能在项目中使用它。MonoTouch使开发者的生活变得更加容易，因为当我们创建Interface
    Builder中的出口并将它们连接时，MonoDevelop会在后台自动生成与这些出口相关的代码。这就是`ButtonInputViewController.designer.cs`添加的内容，为我们提供了访问我们创建的控件：
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are the properties that provide us access to the controls. They are decorated
    with the `OutletAttribute`. You can see that the names of the properties are the
    exact same names we entered for our outlets. This is very important, since we
    only have to provide names once for the outlets and do not have to worry about
    repeating the same naming conventions in different parts of our code. Notice also
    that the types of the variables of the controls are exactly the same as the types
    of controls we dragged-and-dropped in our user interface. This information is
    stored in the `XIB` file, and MonoDevelop reads this information accordingly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性为我们提供了访问控制的功能。它们被装饰了`OutletAttribute`。你可以看到属性的名称与我们为出口输入的确切名称完全相同。这非常重要，因为我们只需要为出口提供一次名称，就不必担心在代码的不同部分重复相同的命名约定。注意，控制变量的类型与我们在用户界面中拖放的控制类型完全相同。这些信息存储在`XIB`文件中，MonoDevelop会相应地读取这些信息。
- en: There's more...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To remove outlets, you first have to disconnect them. For example, to remove
    the `buttonTap` outlet, *Ctrl* - click on the button. In the panel that will appear,
    click on the small **(x)** next to the outlet. This will disconnect the outlet.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除出口，你首先必须断开连接。例如，要删除`buttonTap`出口，在按钮上*Ctrl* - 点击。在出现的面板中，点击出口旁边的小**（x）**。这将断开出口的连接。
- en: '![There''s more...](img/1468EXP_01_12.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1468EXP_01_12.jpg)'
- en: 'After that, delete the following code from the Objective-C source file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，从Objective-C源文件中删除以下代码：
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you save the document, the outlet will be removed from the MonoDevelop
    project.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存文档时，出口将从MonoDevelop项目中移除。
- en: Adding outlets through code
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过代码添加出口
- en: Another way of adding outlets is to create a property in your C# class and decorate
    it with the `OutletAttribute:`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 添加出口的另一种方式是在你的C#类中创建一个属性，并用`OutletAttribute`装饰它：
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you open the `XIB` file in Interface Builder, the outlet will have been
    added to the user interface. However, you would still have to connect it to the
    corresponding control. The easiest way to do this is to *Ctrl* - click on the
    control the outlet corresponds to and click-drag from **New Referencing Outlet**
    to the **File''s Owner** object on the left of the designer area:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Interface Builder中打开`XIB`文件时，出口已经被添加到用户界面中。然而，你仍然需要将其连接到相应的控制。最简单的方法是在控制上*Ctrl*
    - 点击，然后从**新引用出口**拖动到设计区域左侧的**文件所有者**对象：
- en: '![Adding outlets through code](img/1468EXP_01_13.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![通过代码添加出口](img/1468EXP_01_13.jpg)'
- en: When you release the cursor, select the **ButtonTap** outlet from the small
    context menu that will appear.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当你释放光标时，从出现的迷你上下文菜单中选择**ButtonTap**出口。
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that it is MonoDevelop that monitors for changes made in Interface Builder
    and not the other way around. When making changes in the MonoDevelop project,
    make sure to always open the `XIB` file from inside MonoDevelop.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，是 MonoDevelop 监控在 Interface Builder 中所做的更改，而不是反过来。当在 MonoDevelop 项目中做更改时，请确保始终从
    MonoDevelop 内部打开 `XIB` 文件。
- en: See also
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中：
- en: '*Interface builder*'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*界面构建器*'
- en: '*Creating the UI*'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 UI*'
- en: '*Adding actions*'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加动作*'
- en: 'In this book:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中：
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"),User Interface: Views:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章 用户界面：视图")，用户界面：视图：'
- en: '*Adding and customizing views*'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图*'
- en: Adding actions
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动作
- en: In this recipe, we discuss the concept of **Actions** and their usage with MonoTouch.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们讨论了 **动作** 的概念及其与 MonoTouch 的使用。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this task, we will discuss how to use actions with the controls of the user
    interface. Create a new iPhone Single View Application project in MonoDevelop,
    and name it `ButtonInputAction`. Open `ButtonInputActionViewController.xib` in
    Interface Builder, and add the same controls, outlets, and connections as the
    ones from project `ButtonInput` from the previous task. Do not add any code in
    the project for now.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将讨论如何使用用户界面控件中的动作。在 MonoDevelop 中创建一个新的 iPhone 单视图应用程序项目，并将其命名为 `ButtonInputAction`。在
    Interface Builder 中打开 `ButtonInputActionViewController.xib`，并添加与上一个任务中 `ButtonInput`
    项目相同的控件、出口和连接。现在不要在项目中添加任何代码。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Adding actions to interface objects is similar to adding outlets.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 向界面对象添加动作类似于添加出口。
- en: In Interface Builder, *Ctrl-drag* from the button to the source code file. In
    the context window that will be shown, change the **Connection** field from **Outlet**
    to **Action**.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中，*Ctrl-drag* 从按钮到源代码文件。在将显示的上下文窗口中，将 **连接** 字段从 **出口**
    更改为 **动作**。
- en: Enter `OnButtonTap` in the **Name** field, and select **Touch Up** Inside in
    the **Event** field, if it is not already selected.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **名称** 字段中输入 `OnButtonTap`，并在 **事件** 字段中选择 **触摸抬起**，如果尚未选择。
- en: Click on the **Connect** button, and save the document.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **连接** 按钮，并保存文档。
- en: 'In the `ButtonInputActionViewController` class, add the following method:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ButtonInputActionViewController` 类中，添加以下方法：
- en: '[PRE15]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The application is ready! Compile and run in the simulator.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已准备就绪！在模拟器中编译并运行。
- en: Tap on the button, and see the text in the label change, just like in the previous
    application we created.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮，你会看到标签中的文本发生变化，就像我们在上一个应用程序中创建的那样。
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Actions in Objective-C are the equivalent of control events in C#. They are
    responsible for delivering notification signals of various objects. In this example,
    instead of hooking up a handler on the `TouchUpInside` event of the button, we
    have added an action for it. As you may already have noticed, the method we added
    to act as a handler for the action was declared as `partial`. That is because
    MonoDevelop already declared a partial method declaration for us. This is the
    code that was produced when we saved the document in Interface Builder:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 中的动作相当于 C# 中的控制事件。它们负责传递各种对象的通告信号。在这个例子中，我们不是在按钮的 `TouchUpInside`
    事件上连接一个处理程序，而是为它添加了一个动作。你可能已经注意到了，我们添加的作为动作处理程序的方法被声明为 `partial`。这是因为 MonoDevelop
    已经为我们声明了一个部分方法声明。这是我们在 Interface Builder 中保存文档时产生的代码：
- en: '[PRE16]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The partial declaration of the method is marked with the `ActionAttribute`.
    This is another attribute from the `MonoTouch.Foundation` namespace that allows
    us to expose methods as Objective-C actions. You see that the string parameter
    passed in the attribute is exactly the same as the action name we entered in Interface
    Builder, with an appended colon (:) to it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的部分声明用 `ActionAttribute` 标记。这是来自 `MonoTouch.Foundation` 命名空间的其他属性之一，它允许我们将方法公开为
    Objective-C 动作。你看到传递给属性的字符串参数与我们输入到 Interface Builder 中的动作名称完全相同，并在其后面附加了一个冒号（:）。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Colons in Objective-C indicate the presence of parameters. For example, `doSomething`
    is different than `doSomething:`. Their difference is that the first one does
    not accept any parameters, while the second accepts one parameter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 中的冒号表示参数的存在。例如，`doSomething` 与 `doSomething:` 不同。它们的区别在于第一个不接受任何参数，而第二个接受一个参数。
- en: 'The colon at the end of the action name indicates that there is one parameter;
    in this case, the parameter `MonoTouch.UIKit.NSObject` sender. This is what our
    application looks like when we have tapped on the button in the simulator:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 动作名称末尾的冒号表示有一个参数；在这种情况下，参数是`MonoTouch.UIKit.NSObject` sender。这是我们在模拟器中点击按钮时应用程序的外观：
- en: '![How it works...](img/1468EXP_01_14.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1468EXP_01_14.jpg)'
- en: There's more...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The previous example was created just to show how to implement actions in MonoTouch
    projects. Replacing an event with an action is basically at the discretion of
    the developer.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例只是为了展示如何在MonoTouch项目中实现动作。用动作替换事件基本上取决于开发者。
- en: See also
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'In this chapter:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Interface builder*'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*界面构建器*'
- en: '*Creating the UI*'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建用户界面*'
- en: '*Accessing the UI with outlets*'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过出口访问用户界面*'
- en: Compiling
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译
- en: In this recipe, we will discuss how to compile a project with MonoDevelop.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何使用MonoDevelop编译项目。
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: MonoDevelop provides many different options for compiling. In this task, we
    will discuss these options. We will be working with the project `ButtonInput`
    that we created earlier in this chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: MonoDevelop提供了许多不同的编译选项。在本任务中，我们将讨论这些选项。我们将使用本章中较早创建的`ButtonInput`项目进行工作。
- en: How to do it...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With the project loaded in MonoDevelop, go to **Project | ButtonInput Options**.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MonoDevelop中加载项目后，转到**项目 | ButtonInput选项**。
- en: In the window that appears, select **iPhone Build** from the **Build** section
    on the left pad. Select **Debug** as project configuration and **iPhoneSimulator**
    as a platform. In the **Linker behavior** field, select **Link all assemblies**
    from the combo box. In the **SDK version** field, select **Default**, if it is
    not already selected.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的窗口中，从左侧面板的**构建**部分选择**iPhone构建**。将项目配置设置为**调试**，平台设置为**iPhoneSimulator**。在**链接器行为**字段中，从下拉菜单中选择**链接所有程序集**。在**SDK版本**字段中，如果尚未选择，请选择**默认**。
- en: Now, go to **iPhone Application** on the left pad.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到左侧面板上的**iPhone应用程序**。
- en: In the **Summary** tab, enter `Button Input` in the **Application name** field
    and `1.0` in the **Version** field. Select version **3.0** in the **Deployment
    Target** combo box. The **iPhone Application** options window is shown in the
    following screenshot:![How to do it...](img/1468EXP_01_15.jpg)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**摘要**选项卡中，在**应用程序名称**字段中输入`Button Input`，在**版本**字段中输入`1.0`。在**部署目标**下拉菜单中选择**3.0**版本。以下截图显示了**iPhone应用程序**选项窗口：![如何操作...](img/1468EXP_01_15.jpg)
- en: Click on the **OK** button, and compile the project by clicking on **Build |
    Build All** in the menu bar.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**按钮，然后在菜单栏中点击**构建 | 构建全部**来编译项目。
- en: How it works...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have set up some options for our project. Let's see what these options provide
    for compilation customization.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为项目设置了一些选项。让我们看看这些选项为编译定制提供了什么。
- en: iPhone build options
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iPhone构建选项
- en: 'The first option we set up regards the Linker. The **Linker** is a tool that
    was developed by the MonoTouch team and is provided in the SDK. Every time a MonoTouch
    project is compiled, the compiler does not only compile the project, but all the
    assemblies of the MonoTouch framework it needs, so that the final application
    will be able to run on the device (or the simulator). This actually means that
    every application comes with its own compiled version of the MonoTouch framework.
    Doing so means the final application bundle is quite large in size. This is where
    the Linker comes in. What it does is to strip down the assemblies of all the unused
    code so that the compiler will only compile what is needed and used by the application.
    This results in much smaller application bundles: a precious asset when it comes
    to mobile applications. Especially since Apple has a download limitation of 20
    MB per file through the cellular network. The Linker options are the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的第一个选项是关于链接器。**链接器**是由MonoTouch团队开发的一个工具，并在SDK中提供。每次编译MonoTouch项目时，编译器不仅编译项目，还会编译它需要的所有MonoTouch框架的程序集，这样最终的应用程序才能在设备（或模拟器）上运行。这意味着每个应用程序都附带其自己的MonoTouch框架编译版本。这样做意味着最终的应用程序包大小相当大。这就是链接器的作用所在。它所做的就是删除所有未使用的代码的程序集，这样编译器就只会编译应用程序需要和使用的代码。这导致应用程序包的大小大大减小：在移动应用程序中这是一个宝贵的资产。特别是，由于苹果通过蜂窝网络对每个文件有20MB的下载限制。链接器选项如下：
- en: 'The first option we set up regards the Linker. The **Linker** is a tool that
    was developed by the MonoTouch team and is provided in the SDK. Every time a MonoTouch
    project is compiled, the compiler does not only compile the project, but all the
    assemblies of the MonoTouch framework it needs, so that the final application
    will be able to run on the device (or the simulator). This actually means that
    every application comes with its own compiled version of the MonoTouch framework.
    Doing so means the final application bundle is quite large in size. This is where
    the Linker comes in. What it does is to strip down the assemblies of all the unused
    code so that the compiler will only compile what is needed and used by the application.
    This results in much smaller application bundles: a precious asset when it comes
    to mobile applications. Especially since Apple has a download limitation of 20
    MB per file through the cellular network. The Linker options are the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置的选项是关于链接器的。**链接器**是由 MonoTouch 团队开发的一个工具，并在 SDK 中提供。每次编译 MonoTouch 项目时，编译器不仅编译项目，还会编译它需要的所有
    MonoTouch 框架的程序集，以便最终应用程序能够在设备（或模拟器）上运行。这意味着每个应用程序都附带其自己的编译版本的 MonoTouch 框架。这样做意味着最终的应用程序包大小相当大。这就是链接器发挥作用的地方。它所做的就是精简所有未使用的代码，以便编译器只编译应用程序需要和使用的代码。这导致应用程序包的大小大大减小：在移动应用程序中这是一笔宝贵的财富。特别是，由于苹果通过蜂窝网络对每个文件有
    20 MB 的下载限制。链接器选项如下：
- en: '**Don''t Link:** Use this option when debugging on the simulator. The Linker
    is turned off, and all the assemblies are compiled as they are. This provides
    faster compilation times.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不链接**：当在模拟器上调试时使用此选项。链接器被关闭，所有程序集都按原样编译。这提供了更快的编译时间。'
- en: '**Link SDK assemblies only:** Here, the Linker only strips down the MonoTouch
    Framework assemblies. The project assemblies remain intact. This option also effectively
    reduces the final size of the application.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅链接 SDK 程序集**：在这里，链接器仅精简 MonoTouch 框架的程序集。项目程序集保持完整。此选项也有效地减小了最终的应用程序大小。'
- en: '**Link all assemblies:** Here, the Linker is activated on all assemblies. it
    reduces the size a bit more. Care needs to be taken when using this option, if
    **Reflection** or **Serialization** is used in the code. Types and methods that
    are used through Reflection in the code are transparent to the Linker. If a situation
    like this exists in the code, decorate these types or methods with the `PreserveAttribute`.
    This attribute basically informs the Linker to be left out of the stripping down
    process.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接所有程序集**：在这里，链接器在所有程序集上被激活。这会稍微减少一些大小。当在代码中使用**反射**或**序列化**时，需要小心使用此选项。代码中通过反射使用的类型和方法对链接器是透明的。如果代码中存在这种情况，请使用`PreserveAttribute`对这些类型或方法进行装饰。此属性基本上是通知链接器不要参与精简过程。'
- en: In the SDK version field, we set the **iOS SDK version** that will be used to
    compile the application. Setting it to **Default** automatically selects the highest
    SDK version installed on the system.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SDK 版本字段中，我们设置了编译应用程序将使用的**iOS SDK 版本**。将其设置为**默认**将自动选择系统上安装的最高 SDK 版本。
- en: iPhone application options
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iPhone 应用程序选项
- en: In the **iPhone Application** window of the **Build** section in the project
    options, we have set up three options. The first option is the **Application name**.
    This is the name of the application bundle that will be displayed on the simulator,
    the device, and on the App Store. As we can see here, we can normally add spaces
    to the name. The second option, **Version**, defines the version of the application.
    It is what will be displayed as the application's version when it is finally distributed
    through the App Store. The third option, **Deployment target**, is the minimum
    iOS version the application can be installed on.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目选项中“构建”部分的**iPhone 应用程序**窗口中，我们设置了三个选项。第一个选项是**应用程序名称**。这是将在模拟器、设备和 App Store
    上显示的应用程序包的名称。正如我们所看到的，我们通常可以在名称中添加空格。第二个选项**版本**定义了应用程序的版本。这是当应用程序最终通过 App Store
    分发时将显示的版本。第三个选项**部署目标**是应用程序可以安装的最小 iOS 版本。
- en: There's more...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are two more option windows. These are **iPhone Bundle Signing** and **iPhone
    IPA** options. They will be discussed thoroughly in the recipes of [Chapter 14](ch14.html
    "Chapter 14. Deploying"),Deploying.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外两个选项窗口。这些是**iPhone 包签名**和**iPhone IPA**选项。它们将在第 14 章的配方中详细讨论，[第 14 章。部署](ch14.html
    "第 14 章。部署")。
- en: Linker usage
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接器使用
- en: Note
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When compiling for the simulator, turning the Linker on is not suggested. That
    is because the compiler is not compiling the MonoTouch assemblies in the `iPhoneSimulator`
    platform; hence they are being used directly. Turning the Linker on only causes
    compilation to take more time to complete. It has no effect in reducing the final
    application bundle size.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当为模拟器编译时，不建议开启链接器。这是因为编译器不会在`iPhoneSimulator`平台上编译MonoTouch组件；因此它们是直接使用的。开启链接器只会导致编译完成所需的时间更长，对减少最终应用程序包的大小没有影响。
- en: See also
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this book:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 14](ch14.html "Chapter 14. Deploying"),Deploying:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。部署"), 部署：'
- en: '*Preparing our application for the App Store*'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为应用商店准备我们的应用程序*'
- en: Debugging our application
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试我们的应用程序
- en: In this recipe, we will discuss information on debugging a MonoTouch application
    on the simulator.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论在模拟器上调试MonoTouch应用程序的信息。
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: MonoTouch, in combination with MonoDevelop, provides a debugger for debugging
    applications either on the simulator or on the device. In this task, we'll see
    how to use the debugger for debugging MonoTouch applications. Open MonoDevelop,
    and load the `ButtonInput` project. Make sure the debugger toolbar is activated
    by checking on **View | Toolbars | Debugger** in the menu bar. Also, set the project
    configuration to **Debug | iPhoneSimulator**.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: MonoTouch与MonoDevelop结合使用，为在模拟器或设备上调试应用程序提供调试器。在本任务中，我们将了解如何使用调试器调试MonoTouch应用程序。打开MonoDevelop，并加载`ButtonInput`项目。确保通过在菜单栏上检查**视图
    | 工具栏 | 调试器**来激活调试器工具栏。此外，将项目配置设置为**调试 | iPhoneSimulator**。
- en: How to do it...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'MonoDevelop supports breakpoints. To activate a breakpoint on a line, click
    on the space on the left of the line number to set it. Set a breakpoint on the
    following line in the `Main.cs` file:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MonoDevelop支持断点。要激活一行上的断点，请点击行号左侧的空间来设置它。在`Main.cs`文件的以下行设置断点：
- en: '[PRE17]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is what a breakpoint in MonoDevelop looks like:![How to do it...](img/1468EXP_01_16.jpg)
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是MonoDevelop中的断点看起来像：![如何操作...](img/1468EXP_01_16.jpg)
- en: Compile and debug the project by clicking on the second button with the double
    gears icon from the left, or by clicking **Run | Debug** on the menu bar. MonoDevelop
    will display a message box with the message, **Waiting for debugger to connect**.
    When the simulator is open and the app is loaded, watch the information that is
    provided in the **Application Output** pad. Tap on the app button. Execution will
    pause, and MonoDevelop will highlight the breakpoint in yellow. Move the mouse
    over the `labelStatus` variable in the breakpoint line. MonoDevelop will then
    display a window with all the evaluated variable's members:![How to do it...](img/1468EXP_01_17.jpg)
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击从左侧开始的第二个带有双齿轮图标的按钮，或通过点击菜单栏上的**运行 | 调试**来编译和调试项目。MonoDevelop将显示一个消息框，显示消息，**等待调试器连接**。当模拟器打开且应用程序加载时，请关注**应用程序输出**面板中提供的信息。点击应用程序按钮。执行将暂停，MonoDevelop将以黄色突出显示断点。将鼠标移至断点行中的`labelStatus`变量上。然后MonoDevelop将显示一个窗口，其中包含所有已评估变量的成员：![如何操作...](img/1468EXP_01_17.jpg)
- en: To stop debugging, click on the **stop** button on the toolbar, marked with
    a white (X) in a red circle.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止调试，请点击工具栏上的**停止**按钮，按钮上有一个红色的圆圈中白色的(X)标记。
- en: How it works...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: MonoTouch, in combination with MonoDevelop, uses a debugger called **Soft Debugger**.
    It is called this, because it depends on both the runtime and MonoDevelop combined
    to provide one unified debugging platform. When the debugging process starts,
    MonoDevelop begins listening for debugging information from the application. The
    same applies for debugging on both the simulator and the device. When the application
    executes, it starts sending information back to MonoDevelop, which then displays
    that information in the **Application Output** pad, which is automatically activated.
    A typical application output when debugging is the information on the assemblies
    that are loaded, the threads that begin execution, and the breakpoints, if any,
    that are available.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: MonoTouch与MonoDevelop结合使用，使用一个名为**Soft Debugger**的调试器。之所以称为这个名字，是因为它依赖于运行时和MonoDevelop的组合，以提供一个统一的调试平台。当调试过程开始时，MonoDevelop开始监听来自应用程序的调试信息。在模拟器和设备上调试也是如此。当应用程序执行时，它开始将信息发送回MonoDevelop，然后MonoDevelop在**应用程序输出**面板中显示这些信息，该面板会自动激活。调试时的典型应用程序输出是加载的组件信息、开始执行的所有线程，以及如果有，可用的断点。
- en: There's more...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `Console.WriteLine()` method can also be used for debugging purposes. The
    debugger takes care of this and redirects the output of the method to MonoDevelop's
    **Application Output** pad.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console.WriteLine()` 方法也可以用于调试目的。调试器会处理这个问题，并将方法的输出重定向到 MonoDevelop 的 **应用程序输出**
    窗格。'
- en: Application performance when debugging
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试时的应用程序性能
- en: When compiling for debugging purposes, the compiler produces larger and slower
    code. That is because it generates extra code that is needed to provide the appropriate
    debugging information. That is why when debugging an application, the execution
    of the application is much slower than on simple running situations. Before producing
    a release copy of the application, remember to compile it with the **Release |
    iPhone project configuration** to avoid slow runtime execution.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当为了调试目的进行编译时，编译器会产生更大、更慢的代码。这是因为它生成了额外的代码，这些代码是提供适当调试信息所需的。这就是为什么在调试应用程序时，应用程序的执行速度比简单运行情况慢得多。在生成应用程序的发布副本之前，请记住使用
    **Release | iPhone 项目配置** 编译它，以避免运行时执行缓慢。
- en: Breakpoints in the FinishedLaunching method
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`FinishedLaunching` 方法中的断点'
- en: One more reason not to have complicated code in the `FinishedLaunching` method
    is that in most cases, you will not be able to debug it. If you set a breakpoint
    in `FinishedLaunching`, application execution will pause, but iOS will terminate
    the application when the time limit is reached.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 不在 `FinishedLaunching` 方法中编写复杂代码的另一个原因是，在大多数情况下，你将无法对其进行调试。如果你在 `FinishedLaunching`
    中设置断点，应用程序执行将暂停，但当时间限制达到时，iOS 将终止应用程序。
- en: See also
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this book:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 14](ch14.html "Chapter 14. Deploying"),Deploying:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。部署"), 部署：'
- en: '*Creating profiles*'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建配置文件*'
- en: '*Debugging on other devices*'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在其他设备上进行调试*'
