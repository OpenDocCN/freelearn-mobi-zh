<html><head></head><body>
        

            
                <h1 class="header-title">Managing Inputs</h1>
            

            
                
<p>Now that we have learned how to run a program on the Android Emulator, it is time for us to do some more cool stuff, which will equip us with the knowledge required to make our game. In this chapter, we will continue with XML files and will step into the territory of taking user inputs. In a gist, we will be learning the following:</p>
<ul>
<li>Exploring different types of XML files and the resource folder further</li>
<li>Creating buttons and linking them to take inputs</li>
<li>Working with accelerometer readings</li>
<li>Mobile touch inputs</li>
</ul>
<p>So, let's get started.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Resource folder in detail</h1>
            

            
                
<p>In the last chapter, we used the <kbd>activity_fullscreen.xml</kbd> file to edit the frontend of our application. Now, we will take a look at some more of these XML files and understand how they can be useful to us for making games. To understand these type of files, we must first know a little bit about them. To start off, the very basic information about XML is that it's a short form of <em>Extensible Markup Language</em>. Now, if you have studied HTML, you will know that its full form is quite similar to it--HyperText Markup Language. It's quite similar in syntax as well, but the function of an XML file is to hold data. If you go by the definition of an XML file, it goes something like this: XML is a software and hardware-independent tool for storing and transporting data.</p>
<p>You can read more about XML files at <a href="https://en.wikipedia.org/wiki/XML">https://en.wikipedia.org/wiki/XML</a>.<br/>
We have not yet seen an XML file in the code yet, so let's do that. Click on Text as shown in the following screenshot:</p>
<p><img class="image-border" height="369" src="img/B05066_01_33.png" width="691"/></p>
<p>The Text mode for code editing is just besides the Design button<br/></p>
<p class="CDPAlignLeft CDPAlign">Now, you can actually see the XML code opened up:</p>
<div><img class="image-border" height="369" src="img/B05066_01_34.png" width="691"/></div>
<p>This is your default XML code</p>
<p class="CDPAlignLeft CDPAlign">Pay close attention to this code, and you will find something like this:</p>
<div><pre>
&lt;TextView<br/>    android:text="Hello World!"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:id="@+id/TextView"<br/>    tools:text="helloWorld"<br/>    android:textAppearance="@style/TextAppearance.AppCompat.Headline" /&gt;
</pre></div>
<p class="CDPAlignLeft CDPAlign">If you see this, you can observe your <kbd>Hello World!</kbd> text on the very first line of this code. The data that we changed visually in our previous chapter can be changed through code over here. It is almost the same for all components, and you will learn about different components as you practice further.</p>
<p class="CDPAlignLeft CDPAlign">Now, this is not the only type of XML file. As we read in the definition, XML files are used to store data. Let's see the other kinds of XML files, which can be used to store data. We can use these files for storing game scores, filenames, text data, and so much more. Let's take one such new type of XML file, which is already available in our project folder to understand further:</p>
<div><img class="image-border" height="373" src="img/B05066_01_35.png" width="699"/></div>
<p>The strings.xml file contains all your string data and is in the res/values/ folder</p>
<p class="CDPAlignLeft CDPAlign">Navigate to the <kbd>app/res/values/</kbd> folder and double-click on the strings.xml file.</p>
<p class="CDPAlignLeft CDPAlign">You can see the code for this file when you open it. Here, you can observe that there are multiple values and an ID to each value in the form of a <kbd>name</kbd>. Observe carefully the second line that reads as follows:</p>
<div><pre>
&lt;string name="app_name"&gt;First Game&lt;/string&gt;
</pre></div>
<p class="CDPAlignLeft CDPAlign">Remember this name? We had set this as our app name when we started the project. It is stored in the value <kbd>app_name</kbd>. Also, if you go back and search for <kbd>app_name</kbd> using <em>Ctrl</em> + <em>F </em>on your <kbd>activity_fullscreen.xml</kbd> file, you will find this entry. Go ahead and explore a little for yourself.</p>
<p class="CDPAlignLeft CDPAlign">Also, check out the other files to get an understanding. Here's a basic explanation for the four XML files in our project folder:</p>
<ul>
<li><kbd>attrs.xml</kbd>: This declares custom theme attributes that allow changing the styles that are used for button bars, depending on the API level</li>
<li><kbd>colors.xml</kbd>: This defines colors that can be used in hex code</li>
<li><kbd>strings.xml</kbd>: This holds data for all string-related values</li>
<li><kbd>styles.xml</kbd>: This sets the base theme of the application</li>
</ul>
<p class="CDPAlignLeft CDPAlign">So, that's it about XML files. Let's now move on to something even more interesting--inputs.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Taking user inputs</h1>
            

            
                
<p class="CDPAlignLeft CDPAlign">There are multiple ways in which you can take inputs from your Android device. Here are a few ways:</p>
<ul>
<li>UI buttons: Buttons drawn on your app's UI</li>
<li>Hardware buttons: The keys on your Android device</li>
<li>Touch screen inputs: Touches mapped based on the screen coordinates</li>
<li>Accelerometer readings: Motion sensor readings</li>
</ul>
<p>We will be taking a look at each of these input types. So, let's start with the very first type of input, UI buttons.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Button input</h1>
            

            
                
<p>The button input is one of the most common type of components used in an Android project. Let's come back to our design mode and create a button on the screen:</p>
<div><img class="image-border" height="373" src="img/B05066_01_36.png" width="699"/></div>
<p>Reverting back to Design mode from Text mode</p>
<p class="CDPAlignLeft CDPAlign">Click on the Design button and switch back to our visual editor mode on our activity_fullscreen.xml file.</p>
<p class="CDPAlignLeft CDPAlign">Here, we will need to do some changes to our XML file. Follow the steps as mentioned:</p>
<ol>
<li>From the Palette, scroll down and find Linear Layout(Horizontal) and drag and drop it inside the fullscreen_content_controls.</li>
<li>In the Component Tree window below the Palette, drag and drop your TextView under your newly created LinearLayout(horizontal).</li>
<li>Select the Button component from your Palette and drag and drop it in into your Component Tree window's LinearLayout(horizontal).</li>
</ol>
<p>Once you do this, you will get an output like this:</p>
<p><img class="image-border" src="img/B05066_03_05.png"/></p>
<p class="CDPAlignLeft CDPAlign">You now have a button and text on the screen.</p>
<p class="CDPAlignLeft CDPAlign">If we had not used the Linear Layout component, then our button and text would have overlapped each other since if you observe in your Component Tree our TextView was initially inside FrameLayout, which does not have alignment options. You can try dragging your button and text inside the FrameLayout and see for yourself.</p>
<p class="CDPAlignLeft CDPAlign">Now, let's proceed toward making this button work. Click on your newly created button, and in the properties window on right side, take a look at the ID property. This is the property that lets your code know which button to interact with; change it to <kbd>myFirstButton</kbd>:</p>
<div><img class="image-border" height="522" src="img/B05066_03_06.png" width="293"/></div>
<p class="CDPAlignLeft CDPAlign">You have now given a custom ID to your button.</p>
<p class="CDPAlignLeft CDPAlign">Repeat the same for your TextView by changing its ID to <kbd>myTextView</kbd>. Keep these two IDs in mind, and let's move on to our next step. Now, we will actually link this visual button to our code, so we can change the text of our TextView component. Go to your <kbd>app/java/nikhil.nikmlnkr.game</kbd> folder and open up the FullscreenActivity.</p>
<p>Note that <kbd>nikhil.nikmlnkr.game</kbd> is the package name used in this book. Your package name might be different based on what you set it initially, so navigate to the folder based on your package name. For the purpose of this book, we will assume the package name is <kbd>nikhil.nikmlnkr.game</kbd>.</p>
<p class="CDPAlignLeft CDPAlign">After we open that file, we will have opened the main Java code for our application. You can see that there is already a lot of code written over there. Don't get overwhelmed by it because soon you will understand on your own what each code block is about. Let's start by writing some code of our own to get started to link our button to our code file; search for the <kbd>void onCreate</kbd> function.</p>
<p class="CDPAlignLeft CDPAlign">The <kbd>onCreate()</kbd> method is where you initialize your activity. If the activity is started and the application is not loaded, then both <kbd>onCreate()</kbd> methods will be called. You can initialize your variables and methods over here.<br/>
You can see something like this:</p>
<div><pre>
    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/><br/>        setContentView(R.layout.activity_fullscreen);<br/><br/>        mVisible = true;<br/>        mControlsView = findViewById<br/>        (R.id.fullscreen_content_controls);<br/>        mContentView = findViewById(R.id.fullscreen_content);<br/><br/>        // Manually show or hide the System UI<br/>        mContentView.setOnClickListener(new View.OnClickListener(){<br/>            @Override<br/>            public void onClick(View view) {<br/>                toggle();<br/>            }<br/>        });<br/><br/>        /* Upon interacting with UI controls, delay any scheduled hide() <br/>        operations to prevent the jarring behavior of controls going away while <br/>        interacting with the UI.*/<br/><br/>        findViewById(R.id.dummy_button).<br/>        setOnTouchListener(mDelayHideTouchListener);<br/>    }
</pre></div>
<p class="CDPAlignLeft CDPAlign">Now, modify it to look somewhat like this; changes are marked in bold:</p>
<div><pre>
    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/><br/>        setContentView(R.layout.activity_fullscreen);<br/><strong>        // Declare variable references for our TextView and Button with<br/></strong><strong>        // their IDs<br/></strong><strong>        final TextView tv = <br/>        (TextView)findViewById(R.id.myTextView);<br/></strong><strong>        final Button button = <br/>        (Button) findViewById(R.id.myFirstButton);</strong><br/><strong><br/>        // Make an OnClickListener to listen to button click events<br/></strong><strong>        button.setOnClickListener(new View.OnClickListener() {<br/></strong><strong>            public void onClick(View v) {<br/></strong><strong>                // Perform action on click<br/>                tv.setText("Button Clicked");</strong><br/><strong>            }<br/></strong><strong>        });<br/></strong>        mVisible = true;<br/>        mControlsView = <br/>        findViewById(R.id.fullscreen_content_controls);<br/>        mContentView = <br/>        findViewById(R.id.fullscreen_content);<br/><br/><br/>        // Manually show or hide the System UI<br/>        mContentView.setOnClickListener(new View.OnClickListener(){<br/>            @Override<br/>            public void onClick(View view) {<br/>                toggle();<br/>            }<br/>        });<br/><br/>        // Upon interacting with UI controls, delay any scheduled hide()<br/>        // operations to prevent the jarring behavior of controls going<br/>        // away while interacting with the UI.<br/><br/>        findViewById(R.id.dummy_button).<br/>        setOnTouchListener(mDelayHideTouchListener);<br/>    }
</pre></div>
<p class="CDPAlignLeft CDPAlign">By writing this code, you have done the following:</p>
<ul>
<li>Linked your button's ID to your code</li>
<li>Linked your text view's ID to your code</li>
<li>Created a button click listener, which is needed, to take input from a button</li>
</ul>
<p>Once you are ready with this, run your app on the emulator with the steps we learned in the preceding chapter: </p>
<div><img class="image-border" height="395" src="img/B05066_03_07.png" width="216"/></div>
<p class="CDPAlignLeft CDPAlign">On pressing our Button, the text will change to Button Clicked, as we coded in our file.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Hardware button input</h1>
            

            
                
<p>Now, let's test out our hardware buttons along with a Toast example. Don't feel hungry yet reading Toast! It's not the one that you are going to eat. A Toast is a message that gets displayed on your screen for a few seconds and disappears. You will see what it is in a few minutes. So, now open up your <kbd>FullscreenActivity.java</kbd> file where you typed your <kbd>onCreate</kbd> code, and after your <kbd>onCreate</kbd> method, type the following:</p>
<pre>
    @Override<br/>    public void onBackPressed() {<br/>        // your code.<br/>        Toast.makeText(FullscreenActivity.this, <br/>        "Back button pressed", Toast.LENGTH_SHORT).show();<br/>    }
</pre>
<p>Observe the code here. In the first line, we have used the keyword <kbd>@Override</kbd>. This is because we are overriding the parent class functionality, which is the default Android behavior to do something else that we want. If you do not override the function, then by default Android will close the app since that is the function of the back button.</p>
<p>If you are getting an error on Toast with a red underline, then click on the text where you are getting the error and then press <em>Alt</em> + <em>Enter</em>. This will add the missing imports that are required to be included for running it. Once you are done with it, run your app again on the emulator, and you will see the following output:</p>
<div><img class="image-border" height="530" src="img/B05066_03_08.png" width="288"/></div>
<p>So, now you have successfully mapped your hardware button to display a Toast message. Bravo! Let's move ahead and try to track our touch coordinates.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Touch input</h1>
            

            
                
<p>Now that we have seen how to map our hardware buttons, let's dive deeper into the most commonly used input on Android: touch input. However, before we understand touch input, we must understand the coordinate system used to track touches on the screen. Let's take a look at the following illustration to understand this:</p>
<div><img class="image-border" height="195" src="img/B05066_03_09.png" width="329"/></div>
<p>Coordinates system in Android</p>
<p class="CDPAlignLeft CDPAlign">In order to track our touches, we must have a basic understanding of how screen coordinates are mapped on our device. As you can see in the preceding image, our screen's coordinates start from (0,0) at the top-left corner and end at the bottom-right corner with <strong>(w,h)</strong> where w is the screen width and h is the screen height. So, let's say if your phone's resolution is 480 x 850, then your bottom-right corner coordinates will be <kbd>w=480</kbd>, <kbd>h=850</kbd>. Thus, your extreme coordinates will be mapped as (480,850). Just keep this in mind, and you will understand the reason why we need to know this shortly.</p>
<p class="CDPAlignLeft CDPAlign">Now, open up your XML file and drag and drop another TextView component:</p>
<div><img class="image-border" src="img/B05066_03_10.png"/></div>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Give it an ID <kbd>coords</kbd> and text as <kbd>Coords</kbd>:</p>
<div><img class="image-border" src="img/B05066_03_11.png"/></div>
<p class="CDPAlignLeft CDPAlign">Now, click on your LinearLayout from the Component Tree view and give it an ID as <kbd>parent</kbd>.</p>
<p class="CDPAlignLeft CDPAlign">Now, go to your <kbd>FullscreenActivity.java</kbd> code file and modify your <kbd>onCreate</kbd> function to look like this:</p>
<pre>
    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/><br/>        setContentView(R.layout.activity_fullscreen);<br/>        final TextView tv = <br/>        (TextView) findViewById(R.id.myTextView);<br/>        final Button button = <br/>        (Button) findViewById(R.id.myFirstButton);<br/><br/>        button.setOnClickListener(new View.OnClickListener() {<br/>            public void onClick(View v) {<br/>                // Perform action on click<br/>                tv.setText("Button Clicked");<br/>            }<br/>        });<br/>        mVisible = true;<br/>        mControlsView =<br/>        findViewById(R.id.fullscreen_content_controls);<br/>        mContentView =<br/>        findViewById(R.id.fullscreen_content);<br/>        <br/>        final LinearLayout parent = <br/>        (LinearLayout) findViewById(R.id.parent);<br/><br/>        final TextView text = (TextView) findViewById(R.id.coords);<br/><br/>        parent.setOnTouchListener(new View.OnTouchListener() {<br/>            public boolean onTouch(View v, MotionEvent ev) {<br/>                text.setText<br/>                ("Touch at " + ev.getX() + ", " + ev.getY());<br/>                return true;<br/>        }<br/>    });<br/><br/>    // Set up the user interaction to manually show or hide the system UI.<br/>    mContentView.setOnClickListener(new View.OnClickListener() {<br/>        @Override<br/>        public void onClick(View view) {<br/>            toggle();<br/>        }<br/>    });<br/><br/>    // Upon interacting with UI controls, delay any scheduled hide()<br/>    // operations to prevent the jarring behavior of controls going<br/>    // away while interacting with the UI.<br/> <br/>    findViewById(R.id.dummy_button).<br/>    setOnTouchListener(mDelayHideTouchListener);<br/>    }
</pre>
<p>To give an explanation for the preceding code, what we have done over here is quite simple: we have declared a reference for our LinearLayout as <kbd>parent</kbd> and then another reference for our newly created coords(TextView). Now, after our declaration, we instructed the <kbd>parent</kbd> class to have a <kbd>Touch listener</kbd> property on it. This will help us get the coordinates that we touched. As you can see in the preceding code, we have a <kbd>MotionEvent</kbd> variable <kbd>ev</kbd>, which will give us the coordinates. Then, in the next line, we fetched the value in the form of <em>x</em> and <em>y</em> coordinates, which will then be set as text on our coords(TextView).</p>
<p>Go ahead and run your code now, and when the emulator starts, try clicking randomly anywhere; that will give you coordinates that you just touched:</p>
<div><img class="image-border" src="img/B05066_03_12.png"/></div>
<p class="CDPAlignLeft CDPAlign">It will show you where you touched on the screen.</p>
<p>Now, by this time, you must have observed that it is pretty tedious to drag and drop and align all the texts properly, right? That is because we are working with LinearLayout. There is a way through which you can organize all your texts properly. That is through RelativeLayout. Let's take a look at a working example to help you get a better understanding of the same. Go to the TextView of your XML file as we learned to do in the preceding chapter, and wherever you see LinearLayout change it to RelativeLayout. Here is a reference code for the same:</p>
<pre>
&lt;RelativeLayout<br/>    android:orientation="horizontal"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:id="@+id/parent"&gt;<br/><br/>    &lt;Button<br/>        android:text="Button"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:id="@+id/myFirstButton"<br/>        android:layout_weight="1" /&gt;<br/><br/>    &lt;TextView<br/>        android:text="Hello World!"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:id="@+id/myTextView"<br/>        tools:text="helloWorld"<br/>        android:textAppearance="@style/TextAppearance.AppCompat.Headline"<br/>        android:layout_weight="1"<br/>        android:layout_alignBaseline="@+id/myFirstButton"<br/>        android:layout_alignBottom="@+id/myFirstButton"<br/>        android:layout_toRightOf="@+id/myFirstButton"<br/>        android:layout_toEndOf="@+id/myFirstButton" /&gt;<br/><br/>    &lt;TextView<br/>        android:text="Coords"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:id="@+id/coords"<br/>        android:layout_weight="1"<br/>        android:textAppearance="@style/TextAppearance.AppCompat.Headline"<br/>        android:layout_below="@+id/myFirstButton"<br/>        android:layout_alignRight="@+id/myFirstButton"<br/>        android:layout_alignEnd="@+id/myFirstButton" /&gt;<br/>&lt;/RelativeLayout&gt;
</pre>
<p>Now, you have successfully converted your LinearLayout to RelativeLayout, which will give you more control over your design options. You can now adjust your components on screen with more ease, and so you can align them nicely as follows:</p>
<div><img class="image-border" src="img/B05066_03_13.png"/></div>
<p>Once you do this, you can easily adjust your texts by simply dragging them anywhere you want. You won't mess up the layouts when you use RelativeLayouts. Now, let's move on to the next example for getting accelerometer inputs, and take another TextView component on screen for that as you see in the preceding code and give it an ID <kbd>accel</kbd> with a text <kbd>Accelerometer</kbd>. However, before we proceed with the code for the same, there is a minor change that we need to do in our existing code.</p>
<p>Since we just changed our LinearLayout to RelativeLayout, we also have to reference the same for our touch function in our Java code file. Open up your Java code file, and there you will observe that it is already giving you an error prompt on LinearLayout. That is because there is actually no LinearLayout in our project with the ID parent because we changed it to RelativeLayout. Don't worry about this though; simply type in RelativeLayout instead of LinearLayout, and you are sorted. Here is how:</p>
<pre>
    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/><br/>        setContentView(R.layout.activity_fullscreen);<br/>        final TextView tv = <br/>        (TextView) findViewById(R.id.myTextView);<br/>        final Button button =<br/>        (Button) findViewById(R.id.myFirstButton);<br/><br/>        button.setOnClickListener(new View.OnClickListener() {<br/>            public void onClick(View v) {<br/>                // Perform action on click<br/>                tv.setText("Button Clicked");<br/>            }<br/>        });<br/>        mVisible = true;<br/>        mControlsView =<br/>        findViewById(R.id.fullscreen_content_controls);<br/><br/>        mContentView = <br/>        findViewById(R.id.fullscreen_content);<br/><br/>        final RelativeLayout parent = <br/>        (RelativeLayout) findViewById(R.id.parent);<br/><br/>        final TextView text = <br/>        (TextView) findViewById(R.id.coords);<br/>        parent.setOnTouchListener(new View.OnTouchListener() {<br/>            public boolean onTouch(View v, MotionEvent ev) {<br/>                text.setText<br/>                ("Touch at " + ev.getX() + ", " + ev.getY());<br/>                return true;<br/>            }<br/>        });<br/>        <br/>        // Set up the user interaction to manually show or hide the system UI.<br/>        mContentView.setOnClickListener(new View.OnClickListener(){<br/>            @Override<br/>            public void onClick(View view) {<br/>                toggle();<br/>            }<br/>        });<br/><br/>        // Upon interacting with UI controls, delay any scheduled hide()<br/>        // operations to prevent the jarring behavior of controls going<br/>        // away while interacting with the UI.<br/>   <br/>        findViewById(R.id.dummy_button).<br/>        setOnTouchListener(mDelayHideTouchListener);<br/>    }
</pre>
<p>Run your app once, and you can see how neat it looks now:</p>
<div><img class="image-border" src="img/B05066_03_14.png"/></div>
<p>Now, we have successfully made pretty neat adjustments to our layout as well as implemented a touch listener to detect touches.</p>
<p>Now, we move on to our final type of input for this chapter, <em>The Accelerometer input</em>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">The Accelerometer input</h1>
            

            
                
<p>We will now take a look at the accelerometer component on Android. If you don't know what an accelerometer is, it is something that is used to detect movement in Android. In layman terms, we can call it the motion sensor. The best example for this is any racing game that lets you control the car based on your phone's movement. This is something really interesting, which you can use in further chapters to apply motion to objects, so make sure that you grasp this properly. Type in the code you see in the following block starting from <kbd>sensorManager</kbd>:</p>
<pre>
    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/><br/>        setContentView(R.layout.activity_fullscreen);<br/>        final TextView tv = <br/>        (TextView) findViewById(R.id.myTextView);<br/><br/>        final Button button = <br/>        (Button) findViewById(R.id.myFirstButton);<br/><br/>        button.setOnClickListener(new View.OnClickListener() {<br/>            public void onClick(View v) {<br/>                // Perform action on click<br/>                tv.setText("Button Clicked");<br/>            }<br/>        });<br/>        mVisible = true;<br/>        mControlsView =<br/>        findViewById(R.id.fullscreen_content_controls);<br/>        mContentView =<br/>        findViewById(R.id.fullscreen_content);<br/><br/>        final RelativeLayout parent =<br/>        (RelativeLayout) findViewById(R.id.parent);<br/>        <br/>        final TextView text = <br/>        (TextView) findViewById(R.id.coords);<br/><br/>        parent.setOnTouchListener(new View.OnTouchListener() {<br/>            public boolean onTouch(View v, MotionEvent ev) {<br/>                text.setText<br/>                ("Touch at " + ev.getX() + ", " + ev.getY());<br/>                return true;<br/>            }<br/>        });<br/>        SensorManager sensorManager = <br/>        (SensorManager) getSystemService(Context.SENSOR_SERVICE);<br/>        Sensor sensor =<br/>        sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);<br/><br/>        sensorManager.registerListener(new SensorEventListener() {<br/>            @Override<br/>            public void onSensorChanged(SensorEvent event) {<br/><br/>                float x = event.values[0];<br/>                float y = event.values[1];<br/>                float z = event.values[2];<br/>                TextView acc = (TextView) findViewById(R.id.accel);<br/>                acc.setText("x: "+x+", y: "+y+", z: "+z);<br/><br/>            }<br/><br/>            @Override<br/>            public void onAccuracyChanged(Sensor sensor, <br/>            int accuracy){<br/>            }<br/>        }, sensor, SensorManager.SENSOR_DELAY_FASTEST);<br/>        // Set up the user interaction to manually show or hide the system UI.<br/>        mContentView.setOnClickListener(new View.OnClickListener(){<br/>            @Override<br/>            public void onClick(View view) {<br/>                toggle();<br/>            }<br/>        });<br/>        // Upon interacting with UI controls, delay any scheduled hide()<br/>        // operations to prevent the jarring behavior of controls going <br/>        // away while interacting with the UI.<br/><br/>        findViewById(R.id.dummy_button).<br/>        setOnTouchListener(mDelayHideTouchListener);<br/>    }
</pre>
<p>Again, over here if you get an error related to import statements while typing, then press <em>Alt</em> + <em>Enter</em> and you will be prompted with suggestions. Select the corresponding import statement from the list to solve the error. Now, the code will be explained. We made a variable for our <kbd>sensorManager</kbd> component of Android, which is responsible for tracking our <kbd>accelerometer</kbd> values. As you can see after the line following it, we have taken the sensor type as <kbd>TYPE_ACCELEROMETER</kbd>. Next, we created another listener for our component and then we took in the <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> values. After that, we simply took a reference to the accel TextView component in our XML file and set its text to display those values.</p>
<p>Now, it is obvious that you won't be able to see accelerometer values changing on your emulator, so you will have to test it on your mobile device. However, just for curiosity's sake, try and run the code on your computer:</p>
<div><img class="image-border" src="img/B05066_03_15.png"/></div>
<p class="CDPAlignLeft CDPAlign">You will see some values, but they will not be changing because our PC does not have a motion sensor.</p>
<p>So, let's run our app on our mobile now. We can do this in two ways:</p>
<ul>
<li>Build and deploy directly to our device through USB, which will allow us to run the app directly on a physical device</li>
<li>Build an apk and then transfer the apk file to our phone and install it</li>
</ul>
<p>Let's start!</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Building and deploying through USB</h1>
            

            
                
<p class="CDPAlignLeft CDPAlign">To make your device ready for debugging you need to enable your device for debugging first. In order to enable your device for debugging in Developer options. To access these settings, open the Developer options in the system settings. On Android 4.2 and higher versions, the Developer options screen is hidden by default. To make it visible, go to Settings | About phone and tap on Build number seven times:</p>
<div><img class="image-border" height="476" src="img/B05066_03_21.png" width="267"/></div>
<p class="CDPAlignLeft CDPAlign">After this, return to the previous screen to find Developer options at the bottom:</p>
<div><img class="image-border" height="414" src="img/B05066_03_22.png" width="233"/></div>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Now, enable the USB debugging option on your device:</p>
<div><img class="image-border" height="496" src="img/B05066_03_23.png" width="279"/></div>
<p>With an Android-powered device, you can develop and debug your Android applications just as you would on the emulator. Before you can start, there are just a few things to do:</p>
<p>Verify that your application is debuggable in your manifest or <kbd>build.gradle</kbd> file.</p>
<p>In the build file, make sure that the <kbd>debuggable</kbd> property in the <kbd>debug</kbd> build type is set to true. The build type property overrides the manifest setting:</p>
<pre>
android {<br/>    buildTypes {<br/>        debug {<br/>            debuggable true<br/>        }
</pre>
<p>In the <kbd>AndroidManifest.xml</kbd> file, add <kbd>android:debuggable="true"</kbd> to the <kbd>&lt;application&gt;</kbd> element.</p>
<p>Note: If you manually enable debugging in the manifest file, ensure that you disable it in your release build (your published application should usually <em>not</em> be debuggable).</p>
<ol>
<li>Enable USB debugging in the device system settings, under Settings | Developer options.
<p>Note: On Android 4.2 and newer versions, Developer options is hidden by default. To make it available, go to Settings | About phone and tap on Build number seven times. Return to the previous screen to find Developer options.</p>
</li>
<li>Set up your system to detect your device:
<ul>
<li>If you're developing on Windows, you need to install a USB driver for ADB. For an installation guide and links to OEM drivers, refer to the <a href="https://developer.android.com/tools/extras/oem-usb.html">OEM USB Drivers</a> document.</li>
<li>If you're developing on macOS X, it just works, so skip this step.</li>
<li>If you're developing on Ubuntu Linux, you need to add a udev rules file that contains a USB configuration for each type of device you want to use for development. In the rules file, each device manufacturer is identified by a unique vendor ID, as specified by the ATTR{idVendor} property. For a list of vendor IDs, refer to <a href="https://developer.android.com/studio/run/device.html#VendorIds">USB Vendor IDs</a>, as follows. To set up device detection on Ubuntu Linux, perform the following:
<ol>
<li>Log in as root and create this file: <kbd>/etc/udev/rules.d/51-android.rules</kbd>.
<p>Use the following format to add each vendor to the file:<br/>
<kbd>SUBSYSTEM=="usb", ATTR{idVendor}=="0bb4", MODE="0666", GROUP="plugdev"</kbd><br/>
<br/>
In this example, the vendor ID is for HTC. The MODE assignment specifies read/write permissions, and GROUP defines which Unix group owns the device node.</p>
<p>Note: The rule syntax may vary slightly depending on your environment. Consult the udev documentation for your system as needed. For an overview of rule syntax, refer to this guide at <a href="http://www.reactivated.net/writing_udev_rules.html">writing udev rules</a>.</p>
</li>
<li>Now, execute <kbd>chmod a+r /etc/udev/rules.d/51-android.rules</kbd>.</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>Note: When you connect a device running Android 4.2.2 or higher versions to your computer, the system shows a dialog asking whether to accept an RSA key that allows debugging through this computer. This security mechanism protects user devices because it ensures that USB debugging and other ADB commands cannot be executed unless you're able to unlock the device and acknowledge the dialog. This requires that you have ADB version 1.0.31 (available with SDK Platform-tools r16.0.1 and higher) in order to debug on a device running Android 4.2.2 or higher versions.</p>
<p>When plugged in over USB, you can verify that your device is connected by executing ADB devices from your SDK platform-tools/ directory. If connected, you'll see the device name listed as a device.</p>
<p>On pressing run or debugging your application, you will be presented with a Device Chooser dialog that lists the available emulator(s) and connected device(s). Select the device on which you want to install and run the application.</p>
<p>If using the <strong>Android Debug Bridge</strong> (<strong>ADB</strong>), you can issue commands with the <kbd>-d</kbd> flag to target your connected device.<br/>
You can find the vendor IDs at <a href="https://developer.android.com/studio/run/device.html">https://developer.android.com/studio/run/device.html</a>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Building an apk and installing on device</h1>
            

            
                
<p>From the top task bar where you see File, Edit, and so on, click on Build and then click on Generate APK. Once you have done this, it will start generating an apk for you. Once it is finished right-click on your app folder, which is on the left-hand side, as seen in the following screenshot, and click on Show in Explorer:</p>
<div><img class="image-border" src="img/B05066_03_16.png"/></div>
<p class="CDPAlignLeft CDPAlign">Show in Explorer will open the window in which your project folder is located:</p>
<div><img class="image-border" src="img/B05066_03_17.png"/></div>
<p>In your project folder, navigate to the <kbd>app/build/outputs/apk/</kbd> folder, and there you will see your <kbd>app-debug.apk</kbd> file. Transfer this onto your mobile phone and install the apk and run it:</p>
<div><img class="image-border" height="471" src="img/B05066_03_18.png" width="264"/></div>
<p class="CDPAlignLeft CDPAlign">Click on Install:</p>
<div><img class="image-border" height="475" src="img/B05066_03_19.png" width="267"/></div>
<p class="CDPAlignLeft CDPAlign">Click on Open:</p>
<div><img class="image-border" height="321" src="img/B05066_03_20.png" width="180"/></div>
<p class="CDPAlignLeft CDPAlign">Accelerometer values will change as you move your phone around.</p>
<p>Congratulations! You also learned how to create an apk and run it on your actual device.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, you have learned how to take different types of user inputs and also how to generate an apk and run it on your actual device. You also learned the various types of XML files.</p>
<p>In the next chapter, we will learn how to create sprites--no, not the cold drink! We will learn how to create images as well as play with colors. The next chapter will be our entry into creating graphics on screen and will be a big step for you.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>