- en: Chapter 4. Object Creation and Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover objects and classes in more depth, showing the
    mechanisms behind their creation, handling, and customization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Object creation and initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object mutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience initializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using @property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format specifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation and initialization of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a developer, building iOS and OS X applications requires a lot of time in
    creating and handling objects. In Objective-C, like any other object-oriented
    programming language, the object acts like a data package with predefined behaviors.
    We can think about an application as an environment containing objects that connect
    with each other, passing and receiving information such as how to build a graphical
    interface, how to proceed with user interactions, how and where to store and take
    data from, how to perform calculations, and much more. The complexity of tasks
    that can be performed by an object can be very large, but it's not reflected on
    the complexity to create an object.
  prefs: []
  type: TYPE_NORMAL
- en: Cocoa (for OS X) and Cocoa Touch (iOS) already provide a library containing
    an extensive list of objects for you to use as they are or create your own objects
    based on them—we call it code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important development processes is thinking about the app base
    structure, when you decide which object to use, combine, customize, how they will
    communicate in order to generate the expected output, and so on. Some of them
    are provided by Cocoa and Cocoa Touch for immediate use such as NSString, NSArray,
    NSDictionary, UIView, and UILabel, but such importance is due to others who might
    need customization to act as required and/or in order to create an unique framework—features
    for your application.
  prefs: []
  type: TYPE_NORMAL
- en: What is a class?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming approaches, an object is an instance of a class.
    The class will determine the behavior of the object, the messages (methods) it
    receives, and sometimes who has access to send these messages in order to obtain
    a response.
  prefs: []
  type: TYPE_NORMAL
- en: A class describes the properties and behaviors of a specified object, just like
    the blueprint of a house will describe the properties of the house, such as the
    number of doors in the house. Similarly, for a number, an instance of a class
    named `NSNumber`, its class provides many ways to obtain, analyze, compare, and
    convert the object's internal numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Except the internal contents stored in multiple instances of a class, all the
    properties and actions behave identically. Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Our numeric object, `firstNumber`, now has the numeric value `3`, which is an
    integer, after sending the message `intValue`, which is predefined in the `NSNumber`
    class. The object will behave as expected by converting its value to an integer.
    Any object instance of the class will act in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects are created to be used in different expected ways, but it''s not a
    requirement for you to know how the internal mechanisms of their behavior happens,
    which is also known as encapsulation. Instead, the single requirement is to know
    how to handle the objects in order to behave in the way you want. It means you
    need to know the predefined messages to send to your object. If you have a string,
    an instance of the `NSString` class containing six uppercase characters, and you
    want them to be lowercase, all you have to know is the message to be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To specify how an object is intended to be used, we use the class interface.
    It defines a public interface to be used in other parts of your code, outside
    the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create your own class, go to **File** | **New** in the menu bar
    or just click *Command* + *N*, select **iOS** or **OS X** based on your project
    and select **Cocoa Class** or **Cocoa Touch Class**. After this, you can name
    your class and select its super class (from which it will inherit). Xcode will
    automatically create a header and an implementation file for you, `.h` and `.m`.
    As in other programming languages, the header file is kind of a summary, a quick
    view about the contents in the class, what will be used, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your public methods and properties will be declared in the header file. Here,
    you can see a sample of a newly created header file (`mySpecialTableViewController.h`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our class is named `mySpecialTableViewController`, a subclass of `UITableViewController`.
    It creates a UI element, as its name suggests, a table view, which is very common
    in iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in our header file, we will create a public property, `NSArray`, to receive
    and hold the data that will be shown on each `UITableViewCell`. Our table view
    will show a list of programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By specifying the superclass during the creation, Xcode already prepared your
    class with the built-in methods available/required to run it. As we can see in
    our implementation file (`mySpecialTableViewController.m`), we just need to implement
    our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our table view will be simple, only showing each programming language stored
    in the `myProgrammingLanguages` array on a different cell. It will only have one
    section, which means we are free to return this number in the `numberOfSectionsInTableView:`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next modification is to specify the number of rows, which means the number
    of cells. If it relies on a property where this number might be different, we
    can''t hardcode it as we did with the number of sections; instead, we return the
    number of objects our array is holding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step when creating a table view in Objective-C is to set the content
    of the cells. We use the `tableView:cellForRowAtIndexPath:` method (already provided
    in the implementation file). By default, it comes commented. Uncomment the method
    in order to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing you should notice is that it creates `UITableViewCell` and returns
    it to be seen on the table view. It is between these two steps that we will configure
    our cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UITableViewCell` class already comes with a property called `textLabel`.
    We will use it to show the values stored in the `myProgrammingLanguages` array.
    Once the `tableView:numberOfRowsInSection:` method returns the number of elements
    in the array, for each iteration, it configures and returns a cell for the respective
    item in the array. The first cell is for the first item, the second cell for second
    item, and so on. Inside this method, the current cell is already the correct cell
    for `indexPath`, but in order to get the correct value set to it, we use `indexPath.row`
    to select the proper item in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code sets the first item in the `myProgrammingLanguages` array
    to the `textLabel` property of the first cell and so on until it reaches the number
    of rows in the table view (the number of the elements in the array).
  prefs: []
  type: TYPE_NORMAL
- en: 'By hardcoding our array, setting the items of `myProgrammingLanguages` inside
    the `viewDidLoad` method, and building our project, we are able to see a table
    view with the items of the array on each cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can see our custom `UITableViewController` with three `UITableViewCell`
    classes, the items of the `myProgrammingLanguages` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a cell with `[tableView:dequeueReusableCellWithIdentifier:@"anyReusableIdentifier"
    forIndexPath:indexPath]` sets an identifier to the cell in order to reuse it with
    other content when it's no longer visible on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if there is a table view with 15 elements, and in your iOS device,
    there are 12 cells visible in the screen, when you scroll up to see the other
    3 elements, there will still be 12 cells visible. In this case, using reuse identifiers,
    instead of creating 15 `UITableViewCells`, it will create at least 13 different
    cells (11 fully visible cells and 2 partially visible cells), and when a cell
    disappears from the screen (scroll up), it is reused to load the newest visible
    element, appearing at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Object immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the classes provided by Cocoa and Cocoa Touch create objects with immutable
    values. In short, an immutable object has its contents set only once, and can
    never modify its values after that. These objects have their contents specified
    during their creation. The object's creation might occur in the initialization
    process or later, but it happens once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see an array that is initialized and created at the same time.
    Its contents are immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, `[sampleArray addObject:@"Item 3"];` will show
    you a compile time error as `sampleArray` is declared as an `NSArray` and not
    as an `NSMutableArray`, so `sampleArray` cannot have any objects added to it after
    it is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create another array, firstly initializing it before its creation,
    which might happen somewhere later in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we set `secondSampleArray` to `nil`, and in Objective-C, `nil`
    means that `secondSampleArray` has no value or an address. It is only later that
    we insert the two NSStrings `"Item 1"` and `"Item 2"` into `secondSampleArray`
    to make the size of the array 2.
  prefs: []
  type: TYPE_NORMAL
- en: Object mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cocoa and Cocoa Touch also provide some mutable versions of its immutable classes.
    Once a mutable object is created, its contents can be partially or completely
    removed or modified. As we saw immutable array objects—an instance of NSArray—in
    the previous topic, I will now show you its mutable version, the `NSMutableArray`
    class, from which we will create our objects as an instance, as you can see in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The mutable versions of a class (in our example, `NSMutableArray`) have many
    similarities with the original immutable version, `NSArray`; however, they are
    different classes. Intending to use methods from one that is not available for
    the other will generate compilation errors. Generally, immutability is what you
    should try to use as immutability provides a guarantee that an object won't have
    its value changed while you are using it. Immutability also brings performance
    benefits when used in things such as strings and dictionaries as mutability will
    bring some overhead due to the need to allocate and deallocate chunks of memory
    when the string or dictionary is modified.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `NSArray` and `NSMutableArray`, `NSMutableArray` is not thread-safe
    and can present weird bugs if you use multithreading. So, generally, try to use
    `NSArray` as the de facto array to use unless you really need `NSMutableArray`.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand inheritance, think about it as a perfect biological tree, where
    you have inherited some behavioral traits from your father, but more than that
    you have your own. Something like this happens in Objective-C when a class is
    inherited from another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic samples are the classes whose names start with `NS` provided by Cocoa
    and Cocoa Touch, such as `NSString`, `NSArray`, and `NSDictionary`. They are all
    inherited from `NSObject`. Each of them has their particular methods to handle
    the different types of contents they hold, but everyone shares methods such as
    `alloc` and `init`. These two class methods, inherited from `NSObject`, respectively
    allocate memory and initialize the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `alloc` method will rarely be overridden, performing a single task and
    allocating memory to the object being created. However, another inheritance example
    is the `init` method, which is also inherited from `NSObject`. It received modifications
    in each child class, creating other initialization methods to quickly assign content
    to the object. These new `init` methods are inherited from the original `init`
    method. This is an example for `NSString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Inheritance](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Convenience initializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The allocation and initialization methods will allocate a chunk of memory to
    hold the object''s content and set an empty value to it, until you assign a value
    yourself. The empty value differs depending on the object''s type: Boolean (BOOL)
    objects receive the value `NO`, integers (int) receive `0`, float numbers (float)
    receive `0.0`, and the rest of the objects receive `nil`.'
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to first allocate memory for your object, and later in the code,
    initialize it, but it's not recommended at all.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you can use or even create what we call convenience initializers,
    which are initialization methods that receive arguments to assign different and/or
    additional values for instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding, we will now create our own object class and create
    convenience initializers to be used in different scenarios. First, we will create
    a class, inherited from `NSObject`. It will return a float number, which is a
    result of a fraction of a multiplication; we will call it `MultiFraction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Convenience initializers](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our header file, `MultiFraction.h`, we will specify the instance variables
    to be included in our object. It will have three values and we will use the `property`
    keyword to define the information that the `MultiFraction` class intends to encapsulate,
    which in this case are the objects of the type `NSInteger`, which are named `firstNumerator`,
    `secondNumerator`, and `denominator` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Convenience initializers](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the implementation file, `MultiFraction.m`, by omitting the `init` method,
    it will use the inherited initialization method from the superclass, in our case,
    `NSObject`, which will return a `nil` value. However, we want to implement a convenience
    initializer to take three arguments, save the values to be used by another method
    in order to perform a calculation, and return its result. Our initialization method
    will be named `initWithFirstNumerator:`, `secondNumerator:`, `denominator:`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Convenience initializers](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside our initialization method, we will store the arguments passed to our
    object on its respective instance variables in case we want to access any of these
    values in the future, instead of calculating the result directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Convenience initializers](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can create our object elsewhere in our Xcode project, by importing
    our header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An Objective-C programmer's responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have experience in other programming languages, such as Java, and are
    coming to Objective-C now, forget about constructors, they don''t exist in Objective-C.
    Constructors are language-level constructs that merge the allocation and initialization
    actions, but they have restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: They don't return anything. While the Objective-C class initialization method,
    + (`void`) initialize, does not return anything, the default—(`id`) `init` method
    of an Objective-C class returns an object of the type `id`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor's name must be identical with the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you call the superclass, being the first statement is a must.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point ensures you won't deal with garbage data, but this is a restriction.
    In Objective-C, as in C, without this restriction, you, the programmer, have more
    flexibility and power, but it is also your responsibility to deal with garbage
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides taking responsibility for garbage management, a good programmer should
    also be aware of programming design patterns. Design patterns are solutions, mostly
    reusable code solutions, to solve and prevent common issues. It makes a developer's
    life easier. In this section, I'll show you the singleton pattern. Singletons
    are useful if you need a single instance and need to manage that single instance
    such as writing to a log file. However, singletons can be misused as global variables,
    which makes for bad programming practice. Singletons are also implemented using
    static methods, which is not good for unit testing as they cannot be mocked or
    stubbed. So, only use a singleton in the correct context and not in every situation
    that you encounter.
  prefs: []
  type: TYPE_NORMAL
- en: In Objective-C, it's completely possible to have more than one instance of a
    class (objects) at a time. However, what if you don't need it? What if, for some
    reason, you need only one instance and nothing more and want to avoid multiple
    instances for that class? In this case, you use the singleton pattern. It ensures
    that there is only a single instance of a class and there is a method globally
    available for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example already implemented by Apple in the `UIScreen` class is the `mainScreen`
    method. It''s globally available and returns a instance of its class, ensuring
    it''s the only one. The reason is obvious, we don''t need more than one main screen.
    It''s called from anywhere in your project, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you first call the method, the instance is not created yet. It will then
    be initialized and returned as expected; however, from the second time the method
    is called, it doesn''t create a new instance but returns the existing one. That''s
    how it ensures only one instance exists. Let''s go through the following sample
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header file, we will first create a global method to access its instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your implementation file, implement the method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can initialize and access this instance from anywhere in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating @property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to store data in objects, they are properties and instance
    variables. The latter should be used just for objects and values exclusively handled
    by the class itself, not from outside. Properties, on the other hand, for objects
    and values are accessible from outside (by other classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'While using instance variables, you can create public or private ones. The
    difference is basically where you declare them as sometimes you need them to be
    accessible by other classes, while in other situations, there is no need to expose
    them to other classes. If they are declared in the header file as part of the
    `@interface` block, they have public scope and if declared in the implementation
    file as part of the `@implementation` block, they have private scope. Generally,
    they should be private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To easily understand your code, instance variable starts with an underscore;
    it doesn't affect the way they work, but it's a convention highly recommended
    to be followed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instance variables are private and accessible only by the class or subclass,
    plus it is encapsulated by the class, which contains it, while a property is public
    and can be accessed by other classes. Properties can also be private when declared
    as part of the class extension, but they are often public since you want to access
    them from the outside. By accessing, there are two options, get or set their content.
    Objective-C automatically generates getters and setters for each declared property.
    In order to declare a property with public scope, do it in your header file as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code mostly tells other classes that the `Book` class has a public
    property, which can be accessed by `chapterNote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Objective-C, methods when declared start with `–` or `+`, as you will see
    in this section. The latter declares a static method, while the former, `–` ,
    declares instance methods. As a developer, you won't declare static methods (starting
    with `+`) regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods are generally used if you don't need an instance of a class in
    that method, while instance methods are used when you need that instance to modify
    its state. Instance methods are more commonly used as instance methods give you
    access to a class instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a method, you follow a syntax. You will need the following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: The symbol to specify the type of the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the data it will return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method's name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of parameter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of parameter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code inside the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following our example, in `mySpecialTableViewController`, let's declare an instance
    method that will take one parameter, a string (`NSString`). Our method will return
    the content of the `myProgrammingLanguages` array as a single string. Each object
    will be followed by the parameter given. Our method will be called `convertToStringWith`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go to the implementation file, the method must be declared in the
    header file, not doing this may cause errors when calling the method because the
    header file defines what methods are exposed to the outside.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom methods](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, move to the implementation file and implement the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom methods](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, when calling the method, if the `myProgrammingLanguages` array
    contains the string values: `"Objective-C", "Swift", and "PHP"`, the result would
    be a unique string with the passed parameter between the values, as shown in the
    following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom methods](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are occasions when you don''t want to pass any parameter to a method.
    It''s possible; you just need the type of the data returned and the name of the
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two special cases about the type of the data retuned by a method,
    when you don''t know it and when you won''t return anything. In the first case,
    you should use `id`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, if you don't want to return nothing, use `void`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: String formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with different types of objects, especially inserting/appending
    them into a string, you need to specify their types inside the string, for which
    we use format specifiers. Printing to the console, for example, requires a string
    to be printed; it''s the only accepted format. Let''s see how to insert different
    objects inside it, to be properly printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want to print a value stored in a property or instance variable,
    you should specify its type inside in order to properly replace it with the value
    outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice `%@` inside the message. It specifies that the value is a string. This
    is how we can specify the object's type, using a percentage sign, `%`, followed
    by a specific keyword (conversion specifier). Using a different conversion specifier
    for a string will result in compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mostly, specifiers support more than one data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| The format specifier | Supported object''s type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Integer (signed int), 32-bit |'
  prefs: []
  type: TYPE_TB
- en: '| `%u` | Integer (unsigned int), 32-bit |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | Integer (unsigned int) as hexadecimal value, 32-bit |'
  prefs: []
  type: TYPE_TB
- en: '| `%o` | Integer (unsigned int) as octal value, 32-bit |'
  prefs: []
  type: TYPE_TB
- en: '| `%%` | `print "%"` |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Float, double (point float number), 64-bit |'
  prefs: []
  type: TYPE_TB
- en: '| `%e` | Float, double (point float number) in scientific notation, 64-bit
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%g` | Float, double (point float number) as `%e` if the exponent is less
    than –4, otherwise as `%f`, 64 bit |'
  prefs: []
  type: TYPE_TB
- en: '| `%c` | Unsigned character (unsigned char), 8 bit |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | An array of 16-bit Unicode characters, which terminates with a null
    pointer |'
  prefs: []
  type: TYPE_TB
- en: '| `%p` | A void pointer character (`void *`) in hexadecimal, starting with
    0x |'
  prefs: []
  type: TYPE_TB
- en: '| `%a` | Double (point float number) in scientific notation, starting with
    0x and one hexadecimal digit before the decimal point using a lowercase `p` to
    introduce the exponent, 64 bit |'
  prefs: []
  type: TYPE_TB
- en: '| `%F` | Double (point float number) in decimal notation |'
  prefs: []
  type: TYPE_TB
- en: '| `%hhd` | BOOL |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were able to see objects in detail, how inheritance works
    and how you can use it to create even more powerful classes. You learned about
    an object's mutability and immutability, how instance variables and property work,
    what they are, and how to create them besides allocation, initialization, and
    custom methods, and how to create your own. In the next chapter, we will cover
    application data management such as resource optimization, caching, and data saving.
    So, see you in the next chapter.
  prefs: []
  type: TYPE_NORMAL
