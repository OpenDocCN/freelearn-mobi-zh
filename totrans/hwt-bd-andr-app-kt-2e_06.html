<html><head></head><body>
		<div><h1 id="_idParaDest-104" class="chapter number"><a id="_idTextAnchor353"/><a id="_idTextAnchor354"/><a id="_idTextAnchor355"/><a id="_idTextAnchor356"/><a id="_idTextAnchor357"/>6</h1>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor358"/>Adding and Interacting with RecyclerView</h1>
			<p><a id="_idTextAnchor359"/>In this chapter, you will learn how to add lists and grids of items to your apps and effectively leverage the recycling power of <code>RecyclerView</code>. You’ll also learn how to handle user interaction with the item views on the screen and support different item view types – for example, for titles. Later in the chapter, you’ll add and remove items dynamically.</p>
			<p>By the end of the chapter, you will have the skills required to present your users with interactive lists of rich items.</p>
			<p><a id="_idTextAnchor360"/>In the previous chapter, we learned how to fetch data, including lists of items and image URLs, from APIs, and how to load images from URLs. Combining that knowledge with the ability to display lists of items is the goal of this chapter.</p>
			<p>Quite often, you will want to present your users with a list of items. For example, you might want to show them a list of pictures on their device or let them select their country from a list of all countries. To do that, you would need to populate multiple views, all sharing the same layout but presenting different content.</p>
			<p>Historically, this was achieved by using <code>ListView</code> or <code>GridView</code>. While both are still viable options, they do not offer the robustness and flexibility of <code>RecyclerView</code>. For example, they do not support large datasets well, they do not support horizontal scrolling, and they do not offer rich divider customization.</p>
			<p class="callout heading">Note</p>
			<p class="callout">Customizing the divider between items in <code>RecyclerView</code> can be easily achieved using <code>RecyclerView.ItemDecorator</code>.</p>
			<p>So, what does <code>RecyclerView</code> do? <code>RecyclerView</code> orchestrates the creation, population, and reuse (hence the name) of views representing lists of items. To use <code>RecyclerView</code>, you need to familiarize yourself with two of its dependencies – the adapter (and through it, the view holder) and the layout manager. These dependencies provide our <code>RecyclerView</code> with the content to show, as well as tell it how to present that content and lay it out on the screen.</p>
			<p>The adapter provides <code>RecyclerView</code> with child views (nested Android views within <code>RecyclerView</code> used to represent individual data items) to draw on the screen, binds those views to data (via <code>ViewHolder</code> instances), and reports user interaction with those views.</p>
			<p>The layout manager tells <code>RecyclerView</code> how to lay its children out. We are provided with three layout types by default – linear, grid, and staggered grid – managed by <code>LinearLayoutManager</code>, <code>GridLayoutManager</code>, and <code>StaggeredGridLayoutManager</code> respectively.</p>
			<p class="callout heading">Note</p>
			<p class="callout">This chapter relies on the use of the Jetpack RecyclerView library: <a href="https://packt.link/FBX4d">https://packt.link/FBX4d</a>.</p>
			<p>In this chapter, we will develop an app that lists secret agents and whether they are currently active or sleeping (and, thus, unavailable). The app will then allow us to add new agents or delete existing ones by swiping them away. There is a twist, though – as you saw in <a href="B19411_05.xhtml#_idTextAnchor312"><em class="italic">Chapter 5</em></a>, <em class="italic">Essential Libraries: Retrofit, Moshi, and Glide</em>, all our agents will be cats.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Adding <code>RecyclerView</code> to our layout</li>
				<li>Populating <code>RecyclerView</code></li>
				<li>Responding to clicks in <code>RecylerView</code></li>
				<li>Supporting different item types</li>
				<li>Swiping to remove items</li>
				<li>Adding items interactively</li>
			</ul>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor361"/><a id="_idTextAnchor362"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/IJbeG">https://packt.link/IJbeG</a></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor363"/>Adding RecyclerView to our layout</h1>
			<p>In <a href="B19411_03.xhtml#_idTextAnchor163"><em class="italic">Chapter 3</em></a>, <em class="italic">Developing the UI with Fragments</em>, we saw how we can add views<a id="_idIndexMarker520"/> to our layouts<a id="_idIndexMarker521"/> to be inflated by activities, fragments, or custom views. <code>RecyclerView</code> is just another such view. To add it to our layout, we need to add the following tag to our layout:</p>
			<pre class="source code">
&lt;androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recycler_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:listitem="@layout/item_sample" /&gt;</pre>
			<p>You should already be able to recognize the <code>android:id</code> attribute, as well as the <code>android:layout_width</code> and <code>android:layout_height</code> ones.</p>
			<p>We can use the optional <code>tools:listitem</code> attribute to tell Android Studio which layout to inflate as a list item in our preview toolbar. This will give us an idea of how <code>RecyclerView</code> might look in our app.</p>
			<p>Adding a <code>RecyclerView</code> tag to our layout means we now have an empty container to hold the child views representing our list items. Once populated, it will handle the presenting, scrolling, and recycling of child views for us<a id="_idTextAnchor364"/><a id="_idTextAnchor365"/>.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor366"/>Exercise 6.01 – adding an empty RecyclerView to your main activity</h2>
			<p>To use <code>RecyclerView</code> in your app, you first need<a id="_idIndexMarker522"/> to add it to one of your layouts. Let’s add<a id="_idIndexMarker523"/> it to the layout inflated by our main activity:</p>
			<ol>
				<li>Start by creating a new empty activity project (<code>My RecyclerView App</code>. Make sure your package name is <code>com.example.myrecyclerviewapp</code>.</li>
				<li>Set the save location to where you want to save your project. Leave everything else at their default values and click <strong class="bold">Finish</strong>. Make sure you are on the <strong class="bold">Android</strong> view in your <strong class="bold">Project</strong> pan<a id="_idTextAnchor367"/>e:</li>
			</ol>
			<div><div><img src="img/B19411_06_01.jpg" alt="Figure 6.1 – The Android view in the Project pane"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The Android view in the Project pane</p>
			<ol>
				<li value="3">Open your <code>activity_main.xml</code> file in <strong class="bold">Text</strong> mode.</li>
				<li>To turn your label<a id="_idIndexMarker524"/> into a title at the top of the screen<a id="_idIndexMarker525"/> under which you can add your <code>RecyclerView</code>, add an ID to <code>TextView</code> and align it to the top, like so:<pre class="source code">
&lt;TextView
<strong class="bold">    android:id="@+id/hello_label"</strong>
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
<strong class="bold">    app:layout_constraintTop_toTopOf="parent" /&gt;</strong></pre></li>
				<li>Add the following after the <code>TextView</code> tag to add an empty <code>RecyclerView</code> element to your layout, constrained below your <code>hello_label</code> <code>TextView</code> title:<pre class="source code">
&lt;androidx.recyclerview.widget.RecyclerView
  android:id="@+id/recycler_view"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  app:layout_constraintTop_toBottomOf="@+id/hello_label" /&gt;</pre></li>
			</ol>
			<p>Your layout file should<a id="_idIndexMarker526"/> now look something<a id="_idIndexMarker527"/> like this:</p>
			<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
  ...&gt;
  &lt;TextView
    android:id="@+id/hello_label"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toTopOf="parent" /&gt;
  &lt;androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recycler_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:layout_constraintTop_toBottomOf="@+id/hello_label" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre>
			<ol>
				<li value="6">Run your app by clicking the <strong class="bold">Run app</strong> button or pressing <em class="italic">Ctrl</em> + <em class="italic">R</em> (<em class="italic">Shift</em> + <em class="italic">F10</em> in Windows). On the emulator, it should look like <a id="_idTextAnchor368"/>this:</li>
			</ol>
			<div><div><img src="img/B19411_06_02.jpg" alt="Figure 6.2 – The app with an empty RecyclerView (image cropped for space)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The app with an empty RecyclerView (image cropped for space)</p>
			<p>As you can see, our app runs, and our layout is presented on the screen. However, we do not see our <code>RecyclerView</code>. Why is that? At this stage, our <code>RecyclerView</code> has no content. <code>RecyclerView</code> with no content does not render by default – so, while our <code>RecyclerView</code> is indeed<a id="_idIndexMarker528"/> on the screen, it is not visible. This brings<a id="_idIndexMarker529"/> us to the next step – populating <code>RecyclerView</code> with content that we can actual<a id="_idTextAnchor369"/><a id="_idTextAnchor370"/>ly see.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor371"/>Populating RecyclerView</h1>
			<p>So, we added <code>RecyclerView</code> to our layout. For <a id="_idIndexMarker530"/>us to benefit from <code>RecyclerView</code>, we need to add content to it. Let’s see how we go about doing that.</p>
			<p>As we mentioned before, to add content to our <code>RecyclerView</code>, we would need to implement an adapter. An adapter binds our data to child views. In simpler terms, this means it tells <code>RecyclerView</code> how to plug data into views designed to present that data.</p>
			<p>For example, let’s say we want to present a list of employees.</p>
			<p>First, we need to design<a id="_idIndexMarker531"/> our UI model. This will be a data object holding all the information needed by our view to present a single employee. Because this is a UI model, one convention is to suffix its name with <code>UiModel</code>:</p>
			<pre class="source code">
data class EmployeeUiModel(
    val name: String,
    val biography: String,
    val role: EmployeeRole,
    val gender: Gender,
    val imageUrl: String
)</pre>
			<p>We will define <code>EmployeeRole</code> and <code>Gender</code> as follows:</p>
			<pre class="source code">
enum class EmployeeRole {
    HumanResources,
    Management,
    Technology
}
enum class Gender {
    Female,
    Male,
    Unknown
}</pre>
			<p>The values are provided as an example, of course. Feel free to add more of y<a id="_idTextAnchor372"/>our own!</p>
			<div><div><img src="img/B19411_06_03.jpg" alt="Figure 6.3 – The model’s hierarchy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The model’s hierarchy</p>
			<p>Now, we know what data to expect<a id="_idIndexMarker532"/> when binding to a view, so we can design our view to present this data (this is a simplified version of the actual layout, which we’ll save as <code>item_employee.xml</code>). We’ll start with <code>ImageView</code>:</p>
			<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout ...&gt;
    &lt;ImageView
        android:id="@+id/item_employee_photo"
        android:layout_width="60dp"
        android:layout_height="60dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:background="@color/colorPrimary" /&gt;</pre>
			<p>Then, we will add a <code>TextView</code> for each field:</p>
			<pre class="source code">
  &lt;TextView
    android:id="@+id/item_employee_name"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginStart="16dp"
    android:layout_marginLeft="16dp"
    android:textStyle="bold"
    app:layout_constraintStart_toEndOf="@+id/item_employee_photo"
    app:layout_constraintTop_toTopOf="parent"
    tools:text="Oliver" /&gt;
  &lt;TextView
    android:id="@+id/item_employee_role"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textColor="@color/colorAccent"
    app:layout_constraintStart_toStartOf="@+id/item_employee_name"
    app:layout_constraintTop_toBottomOf="@+id/
        item_employee_name"
    tools:text="Exotic Shorthair" /&gt;
  &lt;TextView
    android:id="@+id/item_employee_biography"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:layout_constraintStart_toStartOf="@+id/item_employee_role"
    app:layout_constraintTop_toBottomOf="@+id/item_employee_role"
    tools:text="Stealthy and witty. Better avoid in dark alleys." /&gt;
  &lt;TextView
    android:id="@+id/item_employee_gender"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textSize="30sp"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintTop_toTopOf="parent"
    tools:text="&amp;#9794;" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre>
			<p>So far, there is nothing new. You should<a id="_idIndexMarker533"/> be able to recognize all of the different view types from <a href="B19411_02.xhtml#_idTextAnchor103"><em class="italic">Chapter 2</em></a>, <em class="italic">Building User </em><em class="italic">Scre<a id="_idTextAnchor373"/>en Flows</em>:</p>
			<div><div><img src="img/B19411_06_04.jpg" alt="Figure 6.4 – A preview of the item_cat.xml layout file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – A preview of the item_cat.xml layout file</p>
			<p>With a data model and a layout, we now have everything we need to bind our data to the view. To do that, we will implement a view holder. Usually, a view holder has two responsibilities – it holds a reference to a view (as its name implies), but it also binds data to that view. We will implement<a id="_idIndexMarker534"/> our view holder as follows:</p>
			<pre class="source code">
private const val FEMALE_SYMBOL = "\u2640"
private const val MALE_SYMBOL = "\u2642"
private const val UNKNOWN_SYMBOL = "?"
class EmployeeViewHolder(
  containerView: View,
  private val imageLoader: ImageLoader
) : ViewHolder(containerView) {
<strong class="bold">  </strong>private val employeeNameView: TextView<strong class="bold"> </strong>by lazy {
    containerView.findViewById(R.id.item_employee_name) }
<strong class="bold">  </strong>private val employeeRoleView: TextView<strong class="bold"> </strong>by lazy {
    containerView.findViewById(R.id.item_employee_role) }
<strong class="bold">  </strong>private val employeeBioView: TextView<strong class="bold"> </strong>by lazy {
    containerView.findViewById(R.id.item_employee_bio) }
<strong class="bold">  </strong>private val employeeGenderView: TextView<strong class="bold"> </strong>by lazy {
    containerView.findViewById(R.id.item_employee_gender) }
  fun bindData(employeeData: EmployeeUiModel) {
    imageLoader.loadImage(employeeData.imageUrl,
      employeePhotoView)
    employeeNameView.text = employeeData.name
    employeeRoleView.text = when (employeeData.role) {
      EmployeeRole.HumanResources -&gt; "Human Resources"
      EmployeeRole.Management -&gt; "Management"
      EmployeeRole.Technology -&gt; "Technology"
    }
    employeeBioView.text = employeeData.biography
    employeeGenderView.text = when (employeeData.gender) {
      Gender.Female -&gt; FEMALE_SYMBOL
      Gender.Male -&gt; MALE_SYMBOL
      else -&gt; UNKNOWN_SYMBOL
    }
  }
}</pre>
			<p>There are a few things<a id="_idIndexMarker535"/> worth noting in the preceding code. First, by convention, we suffixed the name of our view holder with <code>ViewHolder</code>. Second, note that <code>EmployeeViewHolder</code> needs to implement the abstract <code>RecyclerView.ViewHolder</code> class.</p>
			<p>This is required so that the generic type of our adapter can be our view holder. Lastly, we lazily keep references to the views we are interested in. The first time <code>bindData(EmployeeUiModel)</code> is called, we will find these views in the layout and keep references to them.</p>
			<p>Next, we introduced a <code>bindData(EmployeeUiModel)</code> function. This function will be called by our adapter to bind the data to the view held by the view holder. The last but most important thing to note is that we always make sure to set a state for all modified views for every possible input.</p>
			<p>With our view holder set up, we can proceed to implement our adapter. We will start by implementing the minimum required functions, plus a function to set the data. Our adapter will look something like this:</p>
			<pre class="source code">
class EmployeesAdapter(
  private val layoutInflater: LayoutInflater,
  private val imageLoader: ImageLoader
) : RecyclerView.Adapter&lt;EmployeeViewHolder&gt;() {
  private val employees = mutableListOf&lt;EmployeeUiModel&gt;()
  fun setData(newEmployees: List&lt;EmployeeUiModel&gt;) {
    employees.clear()
    employees.addAll(newEmployees)
    notifyDataSetChanged()
  }
  override fun onCreateViewHolder(parent: ViewGroup,
    viewType: Int): EmployeeViewHolder {
    val view = layoutInflater.inflate(
      R.layout.item_employee, parent, false)
    return EmployeeViewHolder(view, imageLoader)
  }
  override fun getItemCount() = employees.size
  override fun onBindViewHolder(
    holder: EmployeeViewHolder, position: Int) {
    holder.bindData(employees [position])
  }
}</pre>
			<p>Let’s go over this implementation. First, we inject<a id="_idIndexMarker536"/> our dependencies into the adapter via its constructor. This will make testing our adapter much easier but will also allow us to change some of its behavior (for example, replace the image loading library) painlessly. In fact, we would not need to change the adapter at all in that case.</p>
			<p>Then, we define a private mutable list of <code>EmployeeUiModel</code> to store the data currently provided by the adapter to <code>RecyclerView</code>. We also introduce a method (<code>setData</code>) to populate that list. Note that we keep a local list and set its contents, rather than allowing <code>employees</code> to be set directly.</p>
			<p>This is mainly because Kotlin, just like Java, passes variables by reference. Passing variables by reference means changes to the content of the list passed into the adapter would change the list held by the adapter. So, for example, if an item was removed outside of the adapter, the adapter would have that item removed as well.</p>
			<p>This becomes a problem because the adapter would not be aware of that change, and so would not be able to notify <code>RecyclerView</code>. There are other risks around a list being modified outside of the adapter, but covering them is beyond the scope of this book.</p>
			<p>Another benefit of encapsulating<a id="_idIndexMarker537"/> the modification of data in a function is that we avoid the risk of forgetting to notify <code>RecyclerView</code> that a dataset has changed, which we do by calling <code>notifyDataSetChanged()</code>.</p>
			<p>We proceed to implement the adapter’s <code>onCreateViewHolder(ViewGroup, Int)</code> function. This function is called when <code>RecyclerView</code> needs a new <code>ViewHolder</code> to render data on a screen. It provides us with a <code>ViewGroup</code> container and a view type (we’ll look into view types later in this chapter).</p>
			<p>The function then expects us to return a view holder initialized with a view (in our case, an inflated one). So, we inflate the view we designed earlier, passing it to a new <code>EmployeeViewHolder</code> instance. Note that the last argument to the inflated function is <code>false</code>.</p>
			<p>This makes sure we do not attach the newly inflated view to the parent. Attaching and detaching views will be managed by the layout manager. Setting the view to <code>true</code> or omitting it would result in <code>IllegalStateException</code> being thrown. Finally, we return the newly created <code>EmployeeViewHolder</code>.</p>
			<p>To implement <code>getItemCount()</code>, we simply return the size of our <code>employees</code> list.</p>
			<p>Lastly, we implement <code>onBindViewHolder(EmployeeViewHolder, Int)</code>. This is done by passing <code>EmployeeUiModel</code>, stored in <code>employees</code>, at the given position to the <code>bindData(EmployeeUiModel)</code> function of our view holder. Our adapter is now ready.</p>
			<p>If we tried to plug our adapter into our <code>RecyclerView</code> at this point and run our app, we would still see no content. This is because we are still missing two small steps – setting data on our adapter and assigning a layout manager to our <code>RecyclerView</code>. The complete working code would look like this:</p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {  
    private val employeesAdapter  
        by lazy { EmployeesAdapter(layoutInflater, 
        GlideImageLoader(this)) }  
    private val recyclerView: RecyclerView 
        by lazy { findViewById(R.id.main_recycler_view) }  
    override fun onCreate(savedInstanceState: Bundle?) {  
        super.onCreate(savedInstanceState)  
        setContentView(R.layout.activity_main)  
        recyclerView.adapter = employeesAdapter  
        recyclerView.layoutManager = LinearLayoutManager(  
            this, LinearLayoutManager.VERTICAL, false)  
        employeesAdapter.setData(  
            listOf(  
                EmployeeUiModel(  
                    "Robert",  
                    "Rose quickly through the organization",  
                    EmployeeRole.Management,  
                    Gender.Male,  
                    "https://images.pexels.com/photos/220453/
                    pexels-photo-220453.jpeg?  
                    auto=compress&amp;cs=tinysrgb&amp;h=650&amp;w=940"  
                 ),  
                 EmployeeUiModel(  
                    "Wilma",  
                    "A talented developer",  
                    EmployeeRole.Technology,  
                    Gender.Female,  
                    "https://images.pexels.com/photos/3189024/
                    pexels-photo-3189024.jpeg?  
                    auto=compress&amp;cs=tinysrgb&amp;h=650&amp;w=940"  
                 ),  
                 EmployeeUiModel( 
                    "Curious George",  
                    "Excellent at retention",  
                    EmployeeRole.HumanResources,  
                    Gender.Unknown,  
                    "https://images.pexels.com/photos/771742/
                    pexels-photo-771742.jpeg? 
                    auto=compress&amp;cs=tinysrgb&amp;h=750&amp;w=1260"  
                 )  
             )  
        )  
    }  
} </pre>
			<p>Running our app now, we would see a list of our employees.</p>
			<p>Note that we hardcoded<a id="_idIndexMarker538"/> the list of employees. In a production app, following a <code>ViewModel</code>. It is also important to note that we kept a reference to <code>employeesAdapter</code>.</p>
			<p>This is so that we could, later on, set the data to different values. Some implementations rely on reading the adapter from <code>RecyclerView</code> itself – this can potentially result in unnecessary casting operations and unexpected states where the adapter is not yet assigned to <code>RecyclerView</code>, so this is generally not a recommended approach.</p>
			<p>Lastly, note that we chose to use <code>LinearLayoutManager</code>, providing<a id="_idIndexMarker539"/> it with the activity for context, a <code>VERTICAL</code> orientation flag, and <code>false</code> to tell it that we do not want the order of the items in the<a id="_idTextAnchor374"/><a id="_idTextAnchor375"/> list reversed.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor376"/>Exercise 6.02 – populating your RecyclerView</h2>
			<p><code>RecyclerView</code> is not very interesting without<a id="_idIndexMarker540"/> any content. It is time to populate <code>RecyclerView</code> by adding your secret cat agents to it.</p>
			<p>A quick recap before you dive in – in the previous exercise, we introduced an empty list designed to hold a list of secret cat agents that users have at their disposal. In this exercise, you will be populating that list to present the users with the available secret cat agents in the agency:</p>
			<ol>
				<li>To keep our file structure tidy, we will start by creating a model package. Right-click on the package name of our app, and then select<a id="_idTextAnchor377"/> <strong class="bold">New</strong> | <strong class="bold">Package</strong>:</li>
			</ol>
			<div><div><img src="img/B19411_06_05.jpg" alt="Figure 6.5 – Creating a new package"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Creating a new package</p>
			<ol>
				<li value="2">Name the new package <code>model</code>. Click <strong class="bold">OK</strong> to create the package.</li>
				<li>To create our first model data class, right-click on the newly created model package, and then select <strong class="bold">New</strong> | <strong class="bold">Kotlin File/Class</strong>.</li>
				<li>Under <code>CatUiModel</code>. Leave <strong class="bold">kind</strong> as <strong class="bold">File</strong> and click on <strong class="bold">OK</strong>. This will be the class holding the data we have about every individual cat agent.</li>
				<li>Add the following to the newly created <code>CatUiModel.kt</code> file to define the data class with all the relevant properties of a cat agent:<pre class="source code">
data class CatUiModel(
    val gender: Gender,
    val breed: CatBreed,
    val name: String,
    val biography: String,
    val imageUrl: String
)</pre></li>
			</ol>
			<p>For each cat agent, other than<a id="_idIndexMarker541"/> their name and photo, we want to know their gender, breed, and biography. This will help us choose the right agent for a mission.</p>
			<ol>
				<li value="6">Again, right-click on the model package, and then navigate to <strong class="bold">New</strong> | <strong class="bold">Kotlin File/Class</strong>.</li>
				<li>This time, name the new file <code>CatBreed</code> and set <code>kind</code> to the <code>Enum</code> class. This class will hold our different cat breeds.</li>
				<li>Update your newly created <code>enum</code> with some initial values, as follows:<pre class="source code">
enum class CatBreed {
    AmericanCurl, BalineseJavanese, ExoticShorthair
}</pre></li>
				<li>Repeat <em class="italic">step 6</em> and <em class="italic">step 7</em>, only this time call your file <code>Gender</code>. This will hold the accepted values for a cat agent’s gender.</li>
				<li>Update the <code>Gender</code> enum, like so:<pre class="source code">
enum class Gender {
    Female, Male, Unknown
}</pre></li>
				<li>Now, to define the layout of the view holding the data about each cat agent, create a new layout resource file by right-clicking on <code>layout</code> and then selecting <strong class="bold">New</strong> | <strong class="bold">Layout<a id="_idTextAnchor378"/> </strong><strong class="bold">resource file</strong>:</li>
			</ol>
			<div><div><img src="img/B19411_06_06.jpg" alt="Figure 6.6 – Creating a new layout resource file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Creating a new layout resource file</p>
			<ol>
				<li value="12">Name your resource <code>item_cat</code>. Leave all the other fields as they are and click <strong class="bold">OK</strong>.</li>
				<li>Update the contents<a id="_idIndexMarker542"/> of the newly created <code>item_cat.xml</code> file (the following code block has been truncated for space, so use the following link to see the full code that you need to add):</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">item_cat.xml</p>
			<pre class="source code">
    &lt;ImageView
        android:id="@+id/item_cat_photo"
        android:layout_width="60dp"
        android:layout_height="60dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:background="@color/colorPrimary" /&gt;
    &lt;TextView
        android:id="@+id/item_cat_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:layout_marginLeft="16dp"
        android:textStyle="bold"
        app:layout_constraintStart_toEndOf="@+id/
            item_cat_photo"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="Oliver" /&gt;</pre>
			<p>The complete code for this step can be found at <a href="http://packt.live/3sopUjo">http://packt.live/3sopUjo</a>.</p>
			<p>This will create a layout<a id="_idIndexMarker543"/> with an image and text fields for a name, breed, and biography to be used in our list.</p>
			<ol>
				<li value="14">You will need a copy of <code>ImageLoader.kt</code>, introduced in <a href="B19411_05.xhtml#_idTextAnchor312"><em class="italic">Chapter 5</em></a>, <em class="italic">Essential Libraries: Retrofit, Moshi, and Glide</em>, so right-click on the package name of your app, navigate to <code>ImageLoader</code> and <strong class="bold">kind</strong> to <strong class="bold">Interface</strong>, and click <strong class="bold">OK</strong>.</li>
				<li>Similar to <a href="B19411_05.xhtml#_idTextAnchor312"><em class="italic">Chapter 5</em></a>, <em class="italic">Essential Libraries: Retrofit, Moshi, and Glide</em>, you only need to add one function here:<pre class="source code">
interface ImageLoader {
  fun loadImage(imageUrl: String, imageView: ImageView)
}</pre></li>
			</ol>
			<p>Make sure to import <code>ImageView</code>.</p>
			<ol>
				<li value="16">Right-click on the package name of your app again, and then select <strong class="bold">New</strong> | <strong class="bold">Kotlin File/Class</strong>.</li>
				<li>Call the new file <code>CatViewHolder</code>. Click <strong class="bold">OK</strong>.</li>
				<li>To implement <code>CatViewHolder</code>, which will bind the cat agent data to your views, replace<a id="_idIndexMarker544"/> the contents of the <code>CatViewHolder.kt</code> file with the following:<pre class="source code">
private val FEMALE_SYMBOL = "\u2640"
private val MALE_SYMBOL = "\u2642"
private const val UNKNOWN_SYMBOL = "?"
class CatViewHolder(
  containerView: View,
  private val imageLoader: ImageLoader
) : ViewHolder(containerView) {
  private val catBiographyView: TextView by lazy {
    containerView
      .findViewById(R.id.item_cat_biography) }
  private val catBreedView: TextView by lazy {
    containerView.findViewById(R.id.item_cat_breed) }
  private val catGenderView: TextView by lazy {
    containerView.findViewById(R.id.item_cat_gender) }
  private val catNameView: TextView by lazy {
    containerView.findViewById(R.id.item_cat_name) }
  private val catPhotoView: ImageView by lazy {
    containerView.findViewById(R.id.item_cat_photo) }
  fun bindData(cat: CatUiModel) {
    imageLoader.loadImage(cat.imageUrl, catPhotoView)
    catNameView.text = cat.name
    catBreedView.text = when (cat.breed) {
      AmericanCurl -&gt; "American Curl"
      BalineseJavanese -&gt; "Balinese-Javanese"
      ExoticShorthair -&gt; "Exotic Shorthair"
    }
    catBiographyView.text = cat.biography
    catGenderView.text = when (cat.gender) {
      Female -&gt; FEMALE_SYMBOL
      Male -&gt; MALE_SYMBOL
      else -&gt; UNKNOWN_SYMBOL
    }
  }
}</pre></li>
				<li>Still under our app package name, create a new Kotlin file named <code>CatsAdapter</code>.</li>
				<li>To implement <code>CatsAdapter</code>, which is responsible<a id="_idIndexMarker545"/> for storing the data for <code>RecyclerView</code>, as well as creating instances of your view holder and using them to bind data to views, replace the contents of the <code>CatsAdapter.kt</code> file with this:<pre class="source code">
package com.example.myrecyclerviewapp
import { ... }
class CatsAdapter(
    private val layoutInflater: LayoutInflater,
    private val imageLoader: ImageLoader
) : RecyclerView.Adapter&lt;CatViewHolder&gt;() {
    private val cats = mutableListOf&lt;CatUiModel&gt;()
    fun setData(newCats: List&lt;CatUiModel&gt;) {
        cats.clear()
        cats.addAll(newCats)
        notifyDataSetChanged()
    }
    override fun onCreateViewHolder(parent: ViewGroup,
      viewType: Int): CatViewHolder {
        val view = layoutInflater
          .inflate(R.layout.item_cat, parent, false)
        return CatViewHolder(view, imageLoader)
    }
    override fun getItemCount() = cats.size
    override fun onBindViewHolder(
        holder: CatViewHolder, position: Int) {
        holder.bindData(cats[position])
    }
}</pre></li>
				<li>At this point, you need to include Glide<a id="_idIndexMarker546"/> in your project. Start by adding the following line of code to the <code>dependencies</code> block inside your app’s <code>gradle.build</code> file:<pre class="source code">
implementation 'com.github.bumptech.glide:glide:4.14.2'</pre></li>
				<li>Create a <code>GlideImageLoader</code> class in your app package path, containing the following:<pre class="source code">
package com.example.myrecyclerviewapp
[imports]
class GlideImageLoader(context: Context) : ImageLoader {
    private val glide by lazy { Glide(context) }
    override fun loadImage(imageUrl: String,
    imageView: ImageView) {
        glide.load(imageUrl)
            .centerCrop().into(imageView)
    }
}</pre></li>
			</ol>
			<p>This is a simple implementation assuming<a id="_idIndexMarker547"/> the loaded image should always be center-cropped.</p>
			<ol>
				<li value="23">Update your <code>MainActivity</code> file:<pre class="source code">
class MainActivity : AppCompatActivity() {
  private val recyclerView: RecyclerView by lazy {
    findViewById(R.id.recycler_view) }
  private val catsAdapter by lazy { CatsAdapter(
    layoutInflater, GlideImageLoader(this)) }
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    recyclerView.adapter = catsAdapter
    recyclerView.layoutManager = LinearLayoutManager(
      this, LinearLayoutManager.VERTICAL, false)
    catsAdapter.setData(
      listOf(
        CatUiModel(Gender.Male,
          CatBreed.BalineseJavanese, "Fred",
          "Silent and deadly",
          "https://cdn2.thecatapi.com/image/DBmIBhhyv.
          jpg"
        ),
        CatUiModel(Gender.Female,
          CatBreed.ExoticShorthair, "Wilma",
          "Cuddly assassin",
          "https://cdn2.thecatapi.com/images/KJF8fB_20.
          jpg"
        ),
        CatUiModel(Gender.Unknown,
          CatBreed.AmericanCurl, "Curious George",
          "Award winning investigator",
          "https://cdn2.thecatapi.com/images/vJB8rwfdX.
          jpg"
        )
      )
    )
  }
}</pre></li>
			</ol>
			<p>This will define<a id="_idIndexMarker548"/> your adapter, attach it to <code>RecyclerView</code>, and populate it with some hardcoded data.</p>
			<ol>
				<li value="24">In your <code>AndroidManifest.xml</code> file, add the following in the <code>manifest</code> tag before the application tag:<pre class="source code">
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</pre></li>
			</ol>
			<p>Having this tag will allow your app to download images from the internet.</p>
			<ol>
				<li value="25">For some final touches, such as giving our title view a proper<a id="_idIndexMarker549"/> name and text, update your <code>activity_main.xml</code> file, like so:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
  ...&gt;
  &lt;TextView
    android:id="@+id/main_label"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/main_title"
    android:textSize="24sp"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toTopOf="parent" /&gt;
  &lt;androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recycler_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:layout_constraintTop_toBottomOf="@+id/main_label" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
				<li>Also, update your <code>strings.xml</code> file to give your app a proper name and title:<pre class="source code">
&lt;resources&gt;
  &lt;string name="app_name"&gt;SCA - Secret Cat Agents&lt;/string&gt;
  &lt;string name="main_title"&gt;Our Agents&lt;/string&gt;
&lt;/resources&gt;</pre></li>
				<li>Run your app. It <a id="_idTextAnchor379"/>should look like this:</li>
			</ol>
			<div><div><img src="img/B19411_06_07.jpg" alt="Figure 6.7 – RecyclerView with hardcoded secret cat agents"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – RecyclerView with hardcoded secret cat agents</p>
			<p>As you can see, <code>RecyclerView</code> now has content, and your app is starting to take shape. Note how the same layout is used to present different items based on the data bound to each instance. As you would<a id="_idIndexMarker550"/> expect, if you add enough items for them to go off screen, scrolling works. Next, we’ll look into allowing a user to interact with the items i<a id="_idTextAnchor380"/><a id="_idTextAnchor381"/>nside our <code>RecyclerView</code>.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor382"/>Responding to clicks in RecyclerView</h1>
			<p>What if we want<a id="_idIndexMarker551"/> to let our users select<a id="_idIndexMarker552"/> an item from a presented list? To achieve that, we need to communicate clicks back to our app.</p>
			<p>The first step in implementing click interaction is to capture clicks on items at the <code>ViewHolder</code> level. To maintain separation between our view holder and the adapter, we define a nested <code>OnClickListener</code> interface in our view holder. We choose to define the interface within the view holder because that and the listener are tightly coupled.</p>
			<p>The interface will, in our case, have only one function. The purpose of this function is to inform the owner of the view holder about the clicks. The owner of a view holder is usually a <code>Fragment</code> or an <code>Activity</code>. Since we know that a view holder can be reused, we know that it can be challenging to define it at construction time in a way that would tell us which item was clicked (since that item will change over time with reuse).</p>
			<p>We work around that by passing the currently presented item back to the owner of the view holder on clicking. This means our interface would look like this:</p>
			<pre class="source code">
interface OnClickListener {
    fun onClick(cat: CatUiModel)
}</pre>
			<p>We will also add this listener as a parameter to our <code>ViewHolder</code> constructor:</p>
			<pre class="source code">
class CatViewHolder(
    containerView: View,
    private val imageLoader: ImageLoader<strong class="bold">,</strong>
<strong class="bold">    private val onClickListener: OnClickListener</strong>
) : ViewHolder(containerView) {
    ...
}</pre>
			<p>It will be used like this:</p>
			<pre class="source code">
containerView.setOnClickListener {
    onClickListener.onClick(cat) }</pre>
			<p>Now, we want our adapter to pass in a listener. In turn, that listener will be responsible for informing the owner of the adapter about the click. This means our adapter, too, would need a nested listener interface, quite similar to the one we implemented in our view holder.</p>
			<p class="callout heading">Note</p>
			<p class="callout">While this seems like duplication that can be avoided by reusing the same listener, that is not a great idea, as it leads to tight coupling between the view holder and the adapter through the listener. What happens when you want your adapter to also report other events through the listener? You would have to handle those events coming from the view holder, even though they would not actually be implemented in the view holder.</p>
			<p>Finally, to handle the click event and show a dialog, we define a listener in our activity and pass it to our adapter. We set that listener to show a dialog on clicking. In an MVVM implementation, you would be notifying the <code>ViewModel</code> of the click<a id="_idIndexMarker553"/> at this point instead. <code>ViewModel</code> would then update its state, telling<a id="_idIndexMarker554"/> the view (our activity) that it<a id="_idTextAnchor383"/><a id="_idTextAnchor384"/> should display the dialog.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor385"/>Exercise 6.03 – responding to clicks</h2>
			<p>Your app already shows<a id="_idIndexMarker555"/> the user a list of secret cat agents. It is time to allow<a id="_idIndexMarker556"/> your user to choose a secret cat agent by clicking on its view. Click events are delegated from the view holder to the adapter to the activ<a id="_idTextAnchor386"/>ity, as shown in <em class="italic">Figure 6</em><em class="italic">.9</em>:</p>
			<div><div><img src="img/B19411_06_08.jpg" alt="Figure 6.8 – The flow of click events"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The flow of click events</p>
			<p>The following are the steps<a id="_idIndexMarker557"/> that you need to follow to complete<a id="_idIndexMarker558"/> this exercise:</p>
			<ol>
				<li>Open your <code>CatViewHolder.kt</code> file. Add a nested interface to it right before the final closing curly bracket:<pre class="source code">
interface OnClickListener {
    fun onClick(cat: CatUiModel)
}</pre></li>
			</ol>
			<p>This will be the interface that a listener will have to implement in order to register for click events on individual cat items.</p>
			<ol>
				<li value="2">Update the <code>CatViewHolder</code> constructor to accept <code>OnClickListener</code> and make <code>containerView</code> accessible:<pre class="source code">
class CatViewHolder(
    <strong class="bold">private val</strong> containerView: View,
    private val imageLoader: ImageLoader<strong class="bold">,</strong>
<strong class="bold">    private val onClickListener: OnClickListener</strong>
) : ViewHolder(containerView) {</pre></li>
			</ol>
			<p>Now, when constructing a <code>CatViewHolder</code> constructor, you also register<a id="_idIndexMarker559"/> for clicks<a id="_idIndexMarker560"/> on item views.</p>
			<ol>
				<li value="3">At the top of your <code>bindData(CatUiModel)</code> function, add the following to intercept clicks and report them to the provided listener:<pre class="source code">
containerView.setOnClickListener {
    onClickListener.onClick(cat) }</pre></li>
				<li>Now, open your <code>CatsAdapter.kt</code> file. Add this nested interface right before the final closing curly bracket:<pre class="source code">
interface OnClickListener {
    fun onItemClick(cat: CatUiModel)
}</pre></li>
			</ol>
			<p>This defines the interface that listeners will have to implement to receive item click events from the adapter.</p>
			<ol>
				<li value="5">Update the <code>CatsAdapter</code> constructor to accept a call implementing the <code>OnClickListener</code> adapter you just defined:<pre class="source code">
class CatsAdapter(
    private val layoutInflater: LayoutInflater,
    private val imageLoader: ImageLoader<strong class="bold">,</strong>
<strong class="bold">    private val onClickListener: OnClickListener</strong>
) : RecyclerView.Adapter&lt;CatViewHolder&gt;() {</pre></li>
				<li>In <code>onCreateViewHolder(ViewGroup, Int)</code>, update the creation of the view holder, as follows:<pre class="source code">
return CatViewHolder(view, imageLoader, <strong class="bold">object :</strong>
<strong class="bold">CatViewHolder.OnClickListener {</strong>
<strong class="bold">override fun onClick(cat: CatUiModel) =</strong>
<strong class="bold">onClickListener.onItemClick(cat)</strong>
<strong class="bold">}</strong>)</pre></li>
			</ol>
			<p>This will add an anonymous class<a id="_idIndexMarker561"/> that delegates the <code>ViewHolder</code> click events<a id="_idIndexMarker562"/> to the adapter listener.</p>
			<ol>
				<li value="7">Finally, open your <code>MainActivity.kt</code> file. Update your <code>catsAdapter</code> construction as follows to provide the required dependencies to the adapter, in the form of an anonymous listener handling click events by showing a dialog:<pre class="source code">
private val catsAdapter by lazy {
  CatsAdapter(layoutInflater, GlideImageLoader(this)<strong class="bold">,</strong>
<strong class="bold">    object : CatsAdapter.OnClickListener {</strong>
<strong class="bold">      override fun onClick(cat: CatUiModel) =</strong>
<strong class="bold">        onClickListener.onItemClick(cat)</strong>
<strong class="bold">    }</strong>
  )
}</pre></li>
				<li>Add the following function right before the final closing curly bracket:<pre class="source code">
private fun showSelectionDialog(cat: CatUiModel) {
  AlertDialog.Builder(this)
    .setTitle("Agent Selected")
    .setMessage("You have selected agent ${cat.name}")
    .setPositiveButton("OK") { _, _ -&gt; }.show()
}</pre></li>
			</ol>
			<p>This function will show a dialog with the name of the cat whose data was passed in.</p>
			<ol>
				<li value="9">Make sure to import the right version of <code>AlertDialog</code>, which is <code>androidx.appcompat.app.AlertDialog</code>, not <code>android.app.AlertDialog</code>.</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The AppCompat version is usually a better choice because it offers backward compatibility.</p>
			<ol>
				<li value="10">Run your app. Clicking on one of t<a id="_idTextAnchor387"/>he cats<a id="_idIndexMarker563"/> should now<a id="_idIndexMarker564"/> open a dialog:</li>
			</ol>
			<div><div><img src="img/B19411_06_09.jpg" alt="Figure 6.9 – A dialog showing an agent was selected"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – A dialog showing an agent was selected</p>
			<p>Try clicking the different items, and note the<a id="_idIndexMarker565"/> different messages presented. You now know how to respond<a id="_idIndexMarker566"/> to users clicking on items inside your <code>RecyclerView</code>. Next, we will look at how we can suppo<a id="_idTextAnchor388"/><a id="_idTextAnchor389"/>rt different item types in our lists.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor390"/>Supporting different Item types</h1>
			<p>In the previous sections, we learned<a id="_idIndexMarker567"/> how to handle a list of items of a single type (in our case, all our items were <code>CatUiModel</code>). What happens if you want to support more than one type of item? A good example of this would be having group titles on our list.</p>
			<p>Let’s say that instead of getting a list of cats, we get a list containing happy cats and sad cats. Each of the two groups of cats is preceded by a title of the corresponding group. Instead of a list of <code>CatUiModel</code> instances, our list would now contain <code>ListItem</code> instances. <code>ListItem</code> might look like this:</p>
			<pre class="source code">
sealed class ListItem {
    data class Group(val name: String) : ListItem()
    data class Cat(val cat: CatUiModel) : ListItem()
}</pre>
			<p>Our list of items may look like this:</p>
			<pre class="source code">
listOf(
  ListItem.Group("Happy Cats"),
  ListItem.Cat(
    CatUiModel(Gender.Female, CatBreed.AmericanCurl,
      "Kitty", "Kitty is warm and fuzzy.",
      "https://cdn2.thecatapi.com/images/..."
    )
  ),
  ListItem.Cat(
    CatUiModel(Gender.Male, CatBreed.ExoticShorthair,
      "Joey", "Loves to cuddle.",
      "https://cdn2.thecatapi.com/images/..."
    )
  ),
  ListItem.Group("Sad Cats"),
  ListItem.Cat(
    CatUiModel(Gender.Unknown, CatBreed.AmericanCurl,
      "Ginger", "Just not in the mood.",
      "https://cdn2.thecatapi.com/images/..."
    )
  ),
  ListItem.Cat(
      CatUiModel(Gender.Female, CatBreed.ExoticShorthair,
      "Butters", "Sleeps most of the time.",
      "https://cdn2.thecatapi.com/images/..."
    )
  )
)</pre>
			<p>In this case, having just one layout<a id="_idIndexMarker568"/> type will not do. Luckily, as you may have noticed in our earlier exercises, <code>RecyclerView.Adapter</code> provides us with a mechanism to handle this (remember the <code>viewType</code> parameter used in the <code>onCreateViewHolder(ViewGroup, </code><code>Int)</code> function?).</p>
			<p>To help the adapter determine which view type is needed for each item, we override its <code>getItemViewType(Int)</code> function. An example of an implementation that would do the trick for us is the following:</p>
			<pre class="source code">
override fun getItemViewType(position: Int) =
  when (listData[position]) {
    is ListItem.Group -&gt; VIEW_TYPE_GROUP
    is ListItem.Cat -&gt; VIEW_TYPE_CAT
  }</pre>
			<p>Here, <code>VIEW_TYPE_GROUP</code> and <code>VIEW_TYPE_CAT</code> are defined as follows:</p>
			<pre class="source code">
private const val VIEW_TYPE_GROUP = 0
private const val VIEW_TYPE_CAT = 1</pre>
			<p>This implementation maps<a id="_idIndexMarker569"/> the data type at a given position to a constant value, representing one of our known layout types. In our case, we know about titles and cats, thus the two types. The values we use can be any integer values as they’re passed back to us, as is the case in the <code>onCreateViewHolder(ViewGroup, Int)</code> function. All we need to do is make sure not to repeat the same value more than once.</p>
			<p>Now that we have told the adapter which view types are supported, we also need to tell it which view holder to use for each view type. This is done by implementing the <code>onCreateViewHolder(ViewGroup, </code><code>Int)</code> function:</p>
			<pre class="source code">
override fun onCreateViewHolder(parent: ViewGroup,
viewType: Int) = when (viewType) {
    VIEW_TYPE_GROUP -&gt; {
        val view = layoutInflater.inflate(
            R.layout.item_title, parent, false)
        GroupViewHolder(view)
    }
    VIEW_TYPE_CAT -&gt; {
        val view = layoutInflater.inflate(
            R.layout.item_cat, parent, false)
        CatViewHolder(view, imageLoader, object :
        CatViewHolder.OnClickListener {
        override fun onClick(cat: CatUiModel) =
            onClickListener.onItemClick(cat)
        })
    }
    else -&gt; throw IllegalArgumentException(
      "Unknown view type requested: $viewType")
}</pre>
			<p>Unlike the earlier implementations<a id="_idIndexMarker570"/> of this function, we now take the value of <code>viewType</code> into account.</p>
			<p>As we now know, <code>viewType</code> is expected to be one of the values we returned from <code>getItem</code><strong class="source inline">
</strong><code>ViewType(Int)</code>.</p>
			<p>For each of these values (<code>VIEW_TYPE_GROUP</code> and <code>VIEW_TYPE_CAT</code>), we inflate the corresponding layout and construct a suitable view holder. Note that we never expect to receive any other value, so we throw an exception if such a value is encountered.</p>
			<p class="callout heading">Note</p>
			<p class="callout">Depending on your needs, you could instead return a default view holder with a layout, showing an error or nothing at all. It may also be a good idea to log such values to allow you to investigate why you received them and decide how to handle them.</p>
			<p>For our group title layout, a simple <code>TextView</code> may be sufficient. For a cat, the <code>item_cat.xml</code> layout can be used as is.</p>
			<p>Now, let’s move on to the view holder. We need to create a view holder for the group title. This means we will now have two different view holders. However, our adapter only supports one adapter type. The easiest solution is to define a common view holder that both <code>GroupViewHolder</code> and <code>CatViewHolder</code> will extend.</p>
			<p>Let’s call it <code>ListItemViewHolder</code>. The <code>ListItemViewHolder</code> class can be abstract, as we never intend to use it directly. To make it easy to bind data, we can also introduce a function in our abstract view holder – <code>abstract fun </code><code>bindData(listItem: ListItemUiModel)</code>.</p>
			<p>Our concrete implementations can expect to receive a specific type, and so we can add the following lines to both <code>GroupViewHolder</code> and <code>CatViewHolder</code> respectively:</p>
			<pre class="source code">
require(listItem is ListItemUiModel.Group)
    { "Expected ListItemUiModel.Group" }
require(listItem is ListItemUiModel.Cat)
    { "Expected ListItemUiModel.Cat" }</pre>
			<p>Specifically, in <code>CatViewHolder</code>, thanks to some Kotlin magic, we can then use <code>define val cat = listItem.cat</code> and leave the rest of the class unchanged.</p>
			<p>Having made those changes, we can now expect<a id="_idIndexMarker571"/> to see the <code>Happy Cats</code> and <code>Sad Cats</code> group t<a id="_idTextAnchor391"/><a id="_idTextAnchor392"/>itles, each followed by the relevant cats.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor393"/>Exercise 6.04 – adding titles to RecyclerView</h2>
			<p>We now want to be able to present<a id="_idIndexMarker572"/> our secret cat agents in two groups – active agents<a id="_idIndexMarker573"/> that are available for us to deploy to the field and sleeper agents that cannot currently be deployed. We will do that by adding a title above the active agents and another above the sleeper agents:</p>
			<ol>
				<li>Under <code>com.example.myrecyclerviewapp.model</code>, create a new Kotlin file called <code>ListItemUiModel</code>.</li>
				<li>Add the following to the <code>ListItemUiModel.kt</code> file, defining our two data types – titles and cats:<pre class="source code">
sealed class ListItemUiModel {
    data class Title(val title: String) :
        ListItemUiModel()
    data class Cat(val cat: CatUiModel) :
        ListItemUiModel()
}</pre></li>
				<li>Create a new Kotlin file in <code>com.example.myrecyclerviewapp</code> named <code>ListItem</code><strong class="source inline">
ViewHolder</strong>. This will<a id="_idIndexMarker574"/> be our base<a id="_idIndexMarker575"/> view holder.</li>
				<li>Populate the <code>ListItemViewHolder.kt</code> file with the following:<pre class="source code">
abstract class ListItemViewHolder(containerView: View
) : RecyclerView.ViewHolder(containerView) {
    abstract fun bindData(listItem: ListItemUiModel)
}</pre></li>
				<li>Open the <code>CatViewHolder.kt</code> file.</li>
				<li>Make <code>CatViewHolder</code> extend <code>ListItemViewHolder</code>:<pre class="source code">
class CatViewHolder(...) :
    ListItemViewHolder(containerView) {</pre></li>
				<li>Replace the <code>bindData(CatUiModel)</code> parameter with <code>ListItemUiModel</code> and make it override the <code>ListItemViewHolder</code> abstract function:<pre class="source code">
override fun bindData(listItem: ListItemUiModel)</pre></li>
				<li>Add the following two lines to the top of the <code>bindData(ListItemUiModel)</code> function to enforce casting <code>ListItemUiModel</code> to <code>ListItemUiModel.Cat</code> and to fetch the cat data from it:<pre class="source code">
require(listItem is ListItemUiModel.Cat)
    { "Expected ListItemUiModel.Cat" }
val cat = listItem.cat</pre></li>
			</ol>
			<p>Leave the rest of the file untouched.</p>
			<ol>
				<li value="9">Create a new layout file. Name your layout <code>item_title</code>.</li>
				<li>Replace the default content<a id="_idIndexMarker576"/> of the newly created <code>item_title.xml</code> file with the<a id="_idIndexMarker577"/> following:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;TextView
  xmlns:android=
    "http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:id="@+id/item_title_title"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:padding="8dp"
  android:textSize="16sp"
  android:textStyle="bold"
  app:layout_constraintStart_toStartOf="parent"
  app:layout_constraintTop_toTopOf="parent"
  tools:text="Sleeper Agents" /&gt;</pre></li>
			</ol>
			<p>This new layout, containing only a <code>TextView</code> with<a id="_idTextAnchor394"/> a 16 sp-sized bold font, will host our titles:</p>
			<div><div><img src="img/B19411_06_010.jpg" alt="Figure 6.10 – A preview of the item_title.xml layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – A preview of the item_title.xml layout</p>
			<ol>
				<li value="11">Implement <code>TitleViewHolder</code> in a new file<a id="_idIndexMarker578"/> with the same name<a id="_idIndexMarker579"/> under <code>com.example.myrecyclerviewapp</code>:<pre class="source code">
class TitleViewHolder(
  containerView: View
) : ListItemViewHolder(containerView) {
  private val titleView: TextView by lazy {
    containerView.findViewById(R.id.item_title_title)
  }
  override fun bindData(listItem: ListItemUiModel) {
    require(listItem is ListItemUiModel.Title)
      { "Expected ListItemUiModel.Title" }
    titleView.text = listItem.title
  }
}</pre></li>
			</ol>
			<p>This is very similar to <code>CatViewHolder</code>, but since we only set the text on <code>TextView</code>, it is also much simpler.</p>
			<ol>
				<li value="12">Now, to make things tidier, select <code>CatViewHolder</code>, <code>ListItemViewHolder</code>, and <code>TitleViewHolder</code>.</li>
				<li>Move all the files to a new namespace; right-click on one<a id="_idIndexMarker580"/> of the files, and<a id="_idIndexMarker581"/> then select <strong class="bold">Refactor</strong> | <strong class="bold">Move</strong> (or press <em class="italic">F6</em>).</li>
				<li>Append <code>/viewholder</code> to the prefilled <strong class="bold">To directory</strong> field. Leave <strong class="bold">Search references</strong> and <strong class="bold">Update package directive (Kotlin files)</strong> checked and <strong class="bold">Open moved files in editor</strong> unchecked. Click <strong class="bold">OK</strong>.</li>
				<li>Open the <code>CatsAdapter.kt</code> file.</li>
				<li>Now, rename <code>CatsAdapter</code> <code>ListItemsAdapter</code>. Right-click on the <code>CatsAdapter</code> class name in the code window, and then select <strong class="bold">Refactor</strong> | <strong class="bold">Rename</strong> (or <em class="italic">Shift</em> + <em class="italic">F6</em>).</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">It is important to maintain the naming of variables, functions, and classes to reflect their actual usage to avoid future confusion.</p>
			<ol>
				<li value="17">When <code>CatsAdapter</code> is highlighted, type <code>ListItemsAdapter</code> and press <em class="italic">Enter</em>.</li>
				<li>Change the adapter generic type to <code>ListItemViewHolder</code>:<pre class="source code">
class ListItemsAdapter(...) :
    RecyclerView.Adapter&lt;<strong class="bold">ListItemViewHolder</strong>&gt;() {</pre></li>
				<li>Update <code>listData</code> and <code>setData(List&lt;CatUiModel&gt;)</code> to handle <code>ListItemUiModel</code> instead:<pre class="source code">
private val <strong class="bold">listData</strong> = mutableListOf&lt;<strong class="bold">ListItemUiModel</strong>&gt;()
fun setData(new<strong class="bold">ListData</strong>: List&lt;<strong class="bold">ListItemUiModel</strong>&gt;) {
    <strong class="bold">listData</strong>.clear()
    <strong class="bold">listData</strong>.addAll(new<strong class="bold">ListData</strong>)
    notifyDataSetChanged()
}</pre></li>
				<li>Update <code>onBindViewHolder(CatViewHolder)</code> to comply with the adapter contract change:<pre class="source code">
override fun onBindViewHolder(holder:
    <strong class="bold">ListItemViewHolder</strong>, position: Int) {
    holder.bindData(<strong class="bold">listData</strong>[position])
}</pre></li>
				<li>At the top of the file, after the imports<a id="_idIndexMarker582"/> and before the class<a id="_idIndexMarker583"/> definition, add the view type constants:<pre class="source code">
private const val VIEW_TYPE_TITLE = 0
private const val VIEW_TYPE_CAT = 1</pre></li>
				<li>Implement <code>getItemViewType(Int)</code>, like so:<pre class="source code">
override fun getItemViewType(position: Int) =
    when (listData[position]) {
        is ListItemUiModel.Title -&gt; VIEW_TYPE_TITLE
        is ListItemUiModel.Cat -&gt; VIEW_TYPE_CAT
    }</pre></li>
				<li>Lastly, change your <code>onCreateViewHolder(ViewGroup, Int)</code> implementation, as follows:<pre class="source code">
override fun onCreateViewHolder(parent: ViewGroup,
  viewType: Int) = when (viewType) {
  VIEW_TYPE_TITLE -&gt; {
    val view = layoutInflater.inflate(
      R.layout.item_title, parent, false)
    TitleViewHolder(view)
  }
  VIEW_TYPE_CAT -&gt; {
    val view = layoutInflater.inflate(
      R.layout.item_cat, parent, false)
    CatViewHolder(
      view,
      imageLoader,
      object : CatViewHolder.OnClickListener {
        override fun onClick(cat: CatUiModel) =
          onClickListener.onItemClick(catData)
      })
  }
  else -&gt; throw IllegalArgumentException("Unknown view type requested: $viewType")
}</pre></li>
				<li>Update <code>MainActivity</code> to populate the adapter<a id="_idIndexMarker584"/> with appropriate data, replacing<a id="_idIndexMarker585"/> the previous <code>catsAdapter.setData(List&lt;CatUiModel&gt;)</code> call (note that the following code has been truncated for space; refer to the link after the code block to access the full code that you need to add):</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">MainActivity.kt</p>
			<pre class="source code">
listItemsAdapter.setData(
  listOf(
      ListItemUiModel.Title("Sleeper Agents"),
      ListItemUiModel.Cat(
        CatUiModel(Gender.Male,
          CatBreed.ExoticShorthair, "Garvey",
          "Garvey is as a lazy, fat, and cynical orange 
          cat.",
          "https://cdn2.thecatapi.com/images/FZpeiLi4n.jpg"
        )
      ),
      ListItemUiModel.Cat(
        CatUiModel(Gender.Unknown,
          CatBreed.AmericanCurl, "Curious George",
          "Award winning investigator",
          "https://cdn2.thecatapi.com/images/vJB8rwfdX.
          jpg"
        )
      ),
      ListItemUiModel.Title("Active Agents"),</pre>
			<p>The complete code<a id="_idIndexMarker586"/> for this step<a id="_idIndexMarker587"/> can be found at <a href="http://packt.live/3icCrSt">http://packt.live/3icCrSt</a>.</p>
			<ol>
				<li value="25">Since <code>catsAdapter</code> is no longer holding <code>CatsAdapter</code> but <code>ListItemsAdapter</code>, rename it accordingly. Name it <code>listItemsAdapter</code>.</li>
				<li>Run the<a id="_idTextAnchor395"/> app. You should see something similar to the following:</li>
			</ol>
			<div><div><img src="img/B19411_06_011.jpg" alt="Figure 6.11 – RecyclerView with the Sleeper Agents and Active Agents header views"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – RecyclerView with the Sleeper Agents and Active Agents header views</p>
			<p>As you can see, we now have titles<a id="_idIndexMarker588"/> above our two agent groups. Unlike the <code>RecyclerView</code>.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor398"/>Swiping to remove Items</h1>
			<p>In the previous sections, we learned<a id="_idIndexMarker590"/> how to present different<a id="_idIndexMarker591"/> view types. However, up until now, we have worked with a fixed list of items. What if you want to be able to remove items from the list? There are a few common mechanisms to achieve that – fixed <strong class="bold">delete</strong> buttons on each item, swiping to delete, and long-clicking to select and then a tapping a <strong class="bold">delete</strong> button, to name a few. In this section, we will focus on the <em class="italic">swiping to </em><em class="italic">delete</em> approach.</p>
			<p>Let’s start by adding the deletion functionality to our adapter. To tell the adapter to remove an item, we need to indicate which item we want to remove. The simplest way to achieve this is by providing the position of the item. In our implementation, this will directly correlate to the position of the item in our <code>listData</code> list. So, our <code>removeItem(Int)</code> function should look like this:</p>
			<pre class="source code">
fun removeItem(position: Int) {
    listData.removeAt(position)
    notifyItemRemoved(position)
}</pre>
			<p class="callout heading">Note</p>
			<p class="callout">Just like when setting data, we need to notify <code>RecyclerView</code> that the dataset has changed – in this case, an item was removed.</p>
			<p>Next, we need to define swipe gesture<a id="_idIndexMarker592"/> detection. This is done<a id="_idIndexMarker593"/> by utilizing <code>ItemTouchHelper</code>, which handles certain touch events, namely dragging and swiping, by reporting them to us via a callback. We handle these callbacks by implementing <code>ItemTouchHelper.Callback</code>. Also, <code>RecyclerView</code> provides <code>ItemTouchHelper.SimpleCallback</code>, which takes away the writing of a lot of boilerplate code.</p>
			<p>We want to respond to swipe gestures but ignore move gestures. More specifically, we want to respond to swipes to the right. Moving is used to reorder items, which is beyond the scope of this chapter. So, our implementation of <code>SwipToDeleteCallback</code> will look as follows:</p>
			<pre class="source code">
inner class SwipeToDeleteCallback :
  ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.RIGHT) {
  override fun onMove(
    recyclerView: RecyclerView,
    viewHolder: RecyclerView.ViewHolder,
    target: RecyclerView.ViewHolder
  ): Boolean = false
  override fun getMovementFlags(
    recyclerView: RecyclerView,
    viewHolder: RecyclerView.ViewHolder
  ) = if (viewHolder is CatViewHolder) {
    makeMovementFlags(
      ItemTouchHelper.ACTION_STATE_IDLE,
      ItemTouchHelper.RIGHT
    ) or makeMovementFlags(
      ItemTouchHelper.ACTION_STATE_SWIPE,
      ItemTouchHelper.RIGHT
    )
  } else { 0 }
  override fun onSwiped(viewHolder: RecyclerView.ViewHolder,
    direction: Int) {
    val position = viewHolder.adapterPosition
    removeItem(position)
  }
}</pre>
			<p>Because our implementation is tightly<a id="_idIndexMarker594"/> coupled to our adapter<a id="_idIndexMarker595"/> and its view types, we can comfortably define it as an inner class. The benefit we gain is the ability to directly call methods on the adapter.</p>
			<p>As you can see, we return <code>false</code> from the <code>onMove(RecyclerView, ViewHolder, ViewHolder)</code> function. This means we ignore move events.</p>
			<p>Next, we need to tell <code>ItemTouchHelper</code> which items can be swiped. We achieve this by overriding <code>getMovementFlags(RecyclerView, ViewHolder)</code>. This function is called when a user is about to start a drag or swipe gesture. <code>ItemTouchHelper</code> expects us to return the valid gestures for the provided view holder.</p>
			<p>We check the <code>ViewHolder</code> class, and if it is <code>CatViewHolder</code>, we want to allow swiping; otherwise, we do not. We use <code>makeMovementFlags(Int, Int)</code>, which is a helper function used to construct flags in a way that <code>ItemTouchHelper</code> can decipher them.</p>
			<p>Note that we define rules for <code>ACTION_STATE_IDLE</code>, which is the starting<a id="_idIndexMarker596"/> state of a gesture, thus allowing a gesture to start from the left<a id="_idIndexMarker597"/> or the right. We then combine it (using <code>or</code>) with the <code>ACTION_STATE_SWIPE</code> flags, allowing the ongoing gesture to swipe left or right. Returning <code>0</code> means neither swiping nor moving will occur for the provided view holder.</p>
			<p>Once a swipe action is completed, <code>onSwiped(ViewHolder, Int)</code> is called. We then obtain the position from the passed-in view holder by calling <code>adapterPosition</code>. Now, <code>adapterPosition</code> is important because it is the only reliable way to obtain the real position of the item presented by the view holder.</p>
			<p>With the correct position, we can remove the item by calling <code>removeItem(Int)</code> in the adapter.</p>
			<p>To expose our newly created <code>SwipeToDeleteCallback</code> implementation, we define a read-only variable within our adapter named <code>swipeToDeleteCallback</code>, and set it to a new instance of <code>SwipeToDeleteCallback</code>.</p>
			<p>Finally, to plug our <code>callback</code> mechanism to <code>RecyclerView</code>, we need to construct a new <code>ItemTouchHelper</code> and attach it to our <code>RecyclerView</code>. We should do this when setting up our <code>RecyclerView</code>, which we do in the <code>onCreate(Bundle?)</code> function of our main activity. This is how the creation and attaching looks:</p>
			<pre class="source code">
val itemTouchHelper =
  ItemTouchHelper(listItemsAdapter.swipeToDeleteCallback)
itemTouchHelper.attachToRecyclerView(recyclerView)</pre>
			<p>We can now swipe items to remove them from the list. Note how our titles cannot be swiped, just as we intended.</p>
			<p>You may have noticed a small glitch – the last item is cut off as it animates upward. This is happening because <code>RecyclerView</code> shrinks to accommodate the new (smaller) number of items before the animation starts. A quick fix to this would be to fix the height of our<a id="_idTextAnchor399"/><a id="_idTextAnchor400"/> <code>RecyclerView</code> by confining its bottom<a id="_idIndexMarker598"/> to the bottom<a id="_idIndexMarker599"/> of its parent.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor401"/>Exercise 6.05 – adding swipe to delete functionality</h2>
			<p>We previously added <code>RecyclerView</code> to our app and then added<a id="_idIndexMarker600"/> items of different types to it. We will now allow users to delete some items (we want to let the users remove secret cat agents but not titles) by swiping them left or right:</p>
			<ol>
				<li>To add item removal functionality to our adapter, add the following function to <code>ListItemsAdapter</code> right after the <code>setData(List&lt;ListItemUiModel&gt;)</code> function:<pre class="source code">
fun removeItem(position: Int) {
    listData.removeAt(position)
    notifyItemRemoved(position)
}</pre></li>
				<li>Next, right before the closing curly bracket of your <code>ListItemsAdapter</code> class, add the following <code>callback</code> implementation to handle the user swiping a cat agent left or right:<pre class="source code">
inner class SwipeToDeleteCallback :
  ItemTouchHelper.SimpleCallback(0,
  ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT) {
  override fun onMove(
    recyclerView: RecyclerView,
    viewHolder: RecyclerView.ViewHolder,
    target: RecyclerView.ViewHolder
  ): Boolean = false
    override fun getMovementFlags(
      recyclerView: RecyclerView,
    viewHolder: RecyclerView.ViewHolder
  ) = if (viewHolder is CatViewHolder) {
    makeMovementFlags(
      ItemTouchHelper.ACTION_STATE_IDLE,
      ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT
    ) or makeMovementFlags(
      ItemTouchHelper.ACTION_STATE_SWIPE,
      ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT
    )
  } else { 0 }
  override fun onSwiped(viewHolder:
    RecyclerView.ViewHolder, direction: Int) {
    val position = viewHolder.adapterPosition
    removeItem(position)
  }
}</pre></li>
			</ol>
			<p>We have implemented an <code>ItemTouchHelper.SimpleCallback</code> instance, passing in the directions<a id="_idIndexMarker601"/> we were interested in – <code>LEFT</code> and <code>RIGHT</code>. Joining the values is achieved by using the <code>or</code> Boolean operator.</p>
			<p>We have overridden the <code>getMovementFlags</code> function to make sure we have only handled swiping on a cat agent view and not on a title. Creating flags for both <code>ItemTouchHelper.ACTION_STATE_SWIPE</code> and <code>ItemTouchHelper.ACTION_STATE_IDLE</code> allows us to intercept both swipe and release events respectively.</p>
			<p>Once a swipe is completed (the user has lifted their finger from the screen), <code>onSwiped</code> will be called, and in response, we remove the item at the position provided by the dragged view holder.</p>
			<ol>
				<li value="3">At the top of your adapter, expose<a id="_idIndexMarker602"/> an instance of the <code>SwipeToDeleteCallback</code> class you just created:<pre class="source code">
class ListItemsAdapter(...) :
  RecyclerView.Adapter&lt;ListItemViewHolder&gt;() {
<strong class="bold">  val swipeToDeleteCallback = SwipeToDeleteCallback()</strong></pre></li>
				<li>Lastly, tie it all together by implementing <code>ItemViewHelper</code> and attaching it to our <code>RecyclerView</code>. Add the following code to the <code>onCreate(Bundle?)</code> function of your <code>MainActivity</code> file right after assigning the layout manager to your adapter:<pre class="source code">
recyclerView.layoutManager = ...
val itemTouchHelper = ItemTouchHelper(listItemsAdapter
  .swipeToDeleteCallback)
itemTouchHelper.attachToRecyclerView(recyclerView)</pre></li>
				<li>To address the small visual glitch you would get when items are removed, scale <code>RecyclerView</code> to fit the screen by updating the code in <code>activity_main.xml</code>, as follows. The changes are in the <code>RecyclerView</code> tag, right before the <code>app:layout_constraintTop_toBottomOf</code> attribute:<pre class="source code">
android:layout_height="<strong class="bold">0dp</strong>"
<strong class="bold">app:layout_constraintBottom_toBottomOf="parent"</strong>
app:layout_constraintTop_toBottomOf="@+id/main_label" /&gt;</pre></li>
			</ol>
			<p>Note that there are two changes – we added a constraint at the bottom of the view to the bottom of the parent, and we set the layout height to <code>0dp</code>. The latter change tells our<a id="_idTextAnchor402"/> app<a id="_idIndexMarker603"/> to calculate the height of <code>RecyclerView</code> based on its constraints:</p>
			<div><div><img src="img/B19411_06_012.jpg" alt="Figure 6.12 – RecyclerView taking the full height of the layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – RecyclerView taking the full height of the layout</p>
			<ol>
				<li value="6">Run your app. You should now be able to swipe secret cat agents left or right to remove them from the<a id="_idTextAnchor403"/> list. Note that <code>RecyclerView</code> handles the collapsing animation for us:</li>
			</ol>
			<div><div><img src="img/B19411_06_013.jpg" alt="Figure 6.13 – A cat being swiped to the right"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – A cat being swiped to the right</p>
			<p>Note how even though titles are item views, they cannot be swiped. You have implemented a callback for swiping gestures that distinguishes between different item types and responds to a swipe by deleting<a id="_idIndexMarker604"/> the swiped item. Now, you know how to remove <a id="_idTextAnchor404"/><a id="_idTextAnchor405"/>items interactively. Next, you will learn how to add new items as well.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor406"/>Adding items interactively</h1>
			<p>We have just learned how to remove items<a id="_idIndexMarker605"/> interactively. What about adding new items? Let’s look into it.</p>
			<p>Similar to the way we implemented the removal of items, we start by adding a function to our adapter:</p>
			<pre class="source code">
fun addItem(position: Int, item: ListItemUiModel) {
    listData.add(position, item)
    notifyItemInserted(position)
}</pre>
			<p>Note that the implementation is very similar to the <code>removeItem(Int)</code> function we implemented earlier. This time, we also receive an item to add and a position to add it to. We then add it to our <code>listData</code> list and notify <code>RecyclerView</code> that we added an item in the requested position.</p>
			<p>To trigger a call to <code>addItem(Int, ListItemUiModel)</code>, we can add a button to our main activity layout. This button can be as follows:</p>
			<pre class="source code">
&lt;Button
    android:id="@+id/main_add_item_button"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Add A Cat"
    app:layout_<a id="_idTextAnchor407"/>constraintBottom_toBottomOf="parent" /&gt;</pre>
			<p>The app will now look like this:</p>
			<div><div><img src="img/B19411_06_014.jpg" alt="Figure 6.14 – The main layout with a button to add a cat"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – The main layout with a button to add a cat</p>
			<p>Don’t forget to update your <code>RecyclerView</code> so that its bottom will be constrained to the top of this button. Otherwise, the button and <code>RecyclerView</code> will overlap.</p>
			<p>In a production app, you could add<a id="_idIndexMarker606"/> a rationale about what a new item would be. For example, you could have a form for a user to fill in different details. For the sake of simplicity, in our example, we will always add the same dummy item – an anonymous female secret cat agent.</p>
			<p>To add the item, we set <code>OnClickListener</code> on our button:</p>
			<pre class="source code">
addItemButton.setOnClickListener {
  listItemsAdapter.addItem(1, ListItemUiModel.Cat(
    CatUiModel(Gender.Female, CatBreed.BalineseJavanese,
      "Anonymous", "Unknown",
      "https://cdn2.thecatapi.com/images/zJkeHza2K.jpg"
    ))
  )
}</pre>
			<p>And that is it. We add the item at position <code>1</code> so that it is added right below our first title, which is the item at position <code>0</code>. In a production app, you could have logic to determine the correct place to insert an item. It could be below the relevant title or always be added at the top, bottom, or in the correct place to preserve some existing order.</p>
			<p>We can now run the app. We will now have<a id="_idIndexMarker607"/> a new <code>RecyclerView</code>. The newly added cats ca<a id="_idTextAnchor408"/><a id="_idTextAnchor409"/>n be swiped away to be removed, just like the hardcoded cats before them.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor410"/>Exercise 6.06 – implementing an Add A Cat button</h2>
			<p>Having implemented a mechanism<a id="_idIndexMarker608"/> to remove items, it is time we implemented<a id="_idIndexMarker609"/> a mechanism to add items:</p>
			<ol>
				<li>Add a function to <code>ListItemsAdapter</code> to support adding items. Add it below the <code>removeItem(Int)</code> function:<pre class="source code">
fun addItem(position: Int, item: ListItemUiModel) {
    listData.add(position, item)
    notifyItemInserted(position)
}</pre></li>
				<li>Add a button to <code>activity_main.xml</code>, right after the <code>RecyclerView</code> tag:<pre class="source code">
&lt;Button
    android:id="@+id/main_add_item_button"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Add A Cat"
    app:layout_constraintBottom_toBottomOf="parent" /&gt;</pre></li>
				<li>Note that <code>android:text="Add A Cat"</code> is highlighted. If you hover your mouse over it, you will see that this is because of the hardcoded string. Click on the <strong class="bold">Add</strong> word to place the editor cursor over it.</li>
				<li>Press <em class="italic">Option</em> + <em class="italic">Enter</em> (iOS) or <em class="italic">Alt</em> + <em class="italic">Enter</em> (Windows) to show the context menu, and then press <em class="italic">Enter</em> again to show the <strong class="bold">Extract </strong><strong class="bold">Resource</strong> dialog.</li>
				<li>Name the resource <code>add_button_label</code>. Press <strong class="bold">OK</strong>.</li>
				<li>To change the bottom constraint on <code>RecyclerView</code> so that the button and <code>RecyclerView</code> do not overlap, within your <code>RecyclerView</code> tag, locate the following:<pre class="source code">
    app:layout_constraintBottom_toBottomOf="parent"</pre></li>
			</ol>
			<p>Replace it with the following line of code:</p>
			<pre class="source code">
app:layout_constraintBottom_to<strong class="bold">Top</strong>Of="<strong class="bold">@+id/main_add_item_button</strong>"</pre>
			<ol>
				<li value="7">Add a lazy field, holding a reference to the button at the top of the class, right after the definition of <code>recyclerView</code>:<pre class="source code">
private val addItemButton: View by lazy {
    findViewById(R.id.main_add_item_button) }</pre></li>
			</ol>
			<p>Note that <code>addItemButton</code> is defined as a view. This is because, in our code, we don’t need to know<a id="_idIndexMarker610"/> the type of view to add a click<a id="_idIndexMarker611"/> listener to it. Choosing the more abstract type allows us to later change the type of view in the layout without having to modify this code.</p>
			<ol>
				<li value="8">Lastly, update <code>MainActivity</code> to handle the click. Find the line that says the following:<pre class="source code">
itemTouchHelper.attachToRecyclerView(recyclerView)</pre></li>
			</ol>
			<p>Right after it, add the following:</p>
			<pre class="source code">
addItemButton.setOnClickListener {
    listItemsAdapter.addItem(1,
        ListItemUiModel.Cat(CatUiModel(
            Gender.Female, CatBreed.BalineseJavanese,
            "Anonymous", "Unknown",
            "https://cdn2.thecatapi.com/images/zJkeHza2K.jpg"
        ))
    )
}</pre>
			<p>This will add a new item to <code>RecyclerView</code> every time the button is <a id="_idTextAnchor411"/>clicked.</p>
			<ol>
				<li value="9">Run the app. You should<a id="_idIndexMarker612"/> see a new button at the bottom<a id="_idIndexMarker613"/> of your app:</li>
			</ol>
			<div><div><img src="img/B19411_06_015.jpg" alt="Figure 6.15 – An anonymous cat is added with the click of a button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – An anonymous cat is added with the click of a button</p>
			<ol>
				<li value="10">Try clicking it a few times. Every time you click it, a new, anonymous secret cat agent is added to your <code>RecyclerView</code>. You can swipe away the newly added cats, just like you could with the hardcoded ones.</li>
			</ol>
			<p>In this exercise, you added new items to <code>RecyclerView</code> in response to user interaction. You now know how to change the contents of <code>RecyclerView</code> at runtime. It is useful to know how to update lists at runtime because, quite often, the data you are presenting to your users changes<a id="_idIndexMarker614"/> while the app<a id="_idTextAnchor412"/> is running, and <a id="_idTextAnchor413"/>you want<a id="_idIndexMarker615"/> to present your users with a fresh, up-to-date state.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor414"/>Activity 6.01 – managing a list of Items</h2>
			<p>Imagine you want to develop<a id="_idIndexMarker616"/> a recipe management app. Your app would support sweet and savory recipes. Users of your app could add new sweet or savory recipes, scroll through the list of added recipes – grouped by flavor (sweet or savory) – click a recipe to get information about it, and finally, delete recipes by swiping them aside.</p>
			<p>The aim of this activity is to create an app with <code>RecyclerView</code> that lists the title of recipes, grouped by flavor. <code>RecyclerView</code> will support user interaction. Each recipe will have a title, a description, and a flavor. Interactions will include clicks and swipes.</p>
			<p>A click will present a user with a dialog showing the description of the recipe. A swipe will remove the swiped recipe from the app. Finally, with two <code>EditText</code> fields (see <a href="B19411_03.xhtml#_idTextAnchor163"><em class="italic">Chapter 3</em></a>, <em class="italic">Developing the UI with Fragments</em>) and two buttons, a user can add a new sweet or savory recipe respectively, with the title and description set to the values set in the <code>EditText</code> fields.</p>
			<p>The steps to complete this are as follows:</p>
			<ol>
				<li>Create a new empty activity app.</li>
				<li>Add <code>RecyclerView</code> support to the app’s <code>build.gradle</code> file.</li>
				<li>Add <code>RecyclerView</code>, two <code>EditText<a id="_idTextAnchor415"/></code> fields, and two buttons to the main layout. It should look something like this:</li>
			</ol>
			<div><div><img src="img/B19411_06_016.jpg" alt="Figure 6.16 – The layout with RecyclerView, two EditText fields, and two buttons"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – The layout with RecyclerView, two EditText fields, and two buttons</p>
			<ol>
				<li value="4">Add models for the flavor<a id="_idIndexMarker617"/> titles and recipes, and an enum for flavor.</li>
				<li>Add a layout for the flavor titles.</li>
				<li>Add a layout for the recipe titles.</li>
				<li>Add view holders for the flavor titles and recipe titles, as well as an adapter.</li>
				<li>Add click listeners to show a dialog with recipe descriptions.</li>
				<li>Update <code>MainActivity</code> to construct the new adapter, and hook up the buttons to add new savory and sweet recipes. Make sure the form is cleared after a recipe is<a id="_idTextAnchor416"/> added.</li>
				<li>Add a swipe helper to remove items.</li>
			</ol>
			<p>The final<a id="_idIndexMarker618"/> output will be as follows:</p>
			<div><div><img src="img/B19411_06_017.jpg" alt="Figure 6.17 – The Recipe Book ﻿﻿app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – The Recipe Book <a id="_idTextAnchor417"/><a id="_idTextAnchor418"/>app</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="https://packt.link/By7eE">https://packt.link/By7eE</a>.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor419"/>Summary</h1>
			<p>In this chapter, we learned how to add <code>RecyclerView</code> support to our project. We also learned how to add <code>RecyclerView</code> to our layout and how to populate it with items. We went through adding different item types, which is particularly useful for titles. We covered interaction with <code>RecyclerView</code>, responding to clicks on individual items and responding to swipe gestures.</p>
			<p>Lastly, we learned how to dynamically add and remove items to and from <code>RecyclerView</code>. The world of <code>RecyclerView</code> is very rich, and we have only scratched the surface. Going further would be beyond the scope of this book. However, it is strongly recommended that you investigate it on your own so that you can have carousels, designed dividers, and fancier swipe effects in your apps.</p>
			<p>You can start your exploration here: <a href="https://packt.link/ClmMn">https://packt.link/ClmMn</a>.</p>
			<p>In the next chapter, we will look into requesting special permissions on behalf of our app to enable it to perform certain tasks, such as accessing a user’s contacts list or microphone. We wil<a id="_idTextAnchor420"/>l also look into using Google’s Maps API and accessing a user’s physical location.</p>
		</div>
	</body></html>