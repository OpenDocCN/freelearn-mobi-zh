<html><head></head><body>
		<div id="_idContainer142" class="IMG---Figure">
			<h1 id="_idParaDest-104" class="chapter number"><a id="_idTextAnchor353"/><a id="_idTextAnchor354"/><a id="_idTextAnchor355"/><a id="_idTextAnchor356"/><a id="_idTextAnchor357"/>6</h1>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor358"/>Adding and Interacting with RecyclerView</h1>
			<p><a id="_idTextAnchor359"/>In this chapter, you will learn how to add lists and grids of items to your apps and effectively leverage the recycling power of <strong class="source inline">RecyclerView</strong>. You’ll also learn how to handle user interaction with the item views on the screen and support different item view types – for example, for titles. Later in the chapter, you’ll add and remove <span class="No-Break">items dynamically.</span></p>
			<p>By the end of the chapter, you will have the skills required to present your users with interactive lists of <span class="No-Break">rich items.</span></p>
			<p><a id="_idTextAnchor360"/>In the previous chapter, we learned how to fetch data, including lists of items and image URLs, from APIs, and how to load images from URLs. Combining that knowledge with the ability to display lists of items is the goal of <span class="No-Break">this chapter.</span></p>
			<p>Quite often, you will want to present your users with a list of items. For example, you might want to show them a list of pictures on their device or let them select their country from a list of all countries. To do that, you would need to populate multiple views, all sharing the same layout but presenting <span class="No-Break">different content.</span></p>
			<p>Historically, this was achieved by using <strong class="source inline">ListView</strong> or <strong class="source inline">GridView</strong>. While both are still viable options, they do not offer the robustness and flexibility of <strong class="source inline">RecyclerView</strong>. For example, they do not support large datasets well, they do not support horizontal scrolling, and they do not offer rich <span class="No-Break">divider customization.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">Customizing the divider between items in <strong class="source inline">RecyclerView</strong> can be easily achieved <span class="No-Break">using </span><span class="No-Break"><strong class="source inline">RecyclerView.ItemDecorator</strong></span><span class="No-Break">.</span></p>
			<p>So, what does <strong class="source inline">RecyclerView</strong> do? <strong class="source inline">RecyclerView</strong> orchestrates the creation, population, and reuse (hence the name) of views representing lists of items. To use <strong class="source inline">RecyclerView</strong>, you need to familiarize yourself with two of its dependencies – the adapter (and through it, the view holder) and the layout manager. These dependencies provide our <strong class="source inline">RecyclerView</strong> with the content to show, as well as tell it how to present that content and lay it out on <span class="No-Break">the screen.</span></p>
			<p>The adapter provides <strong class="source inline">RecyclerView</strong> with child views (nested Android views within <strong class="source inline">RecyclerView</strong> used to represent individual data items) to draw on the screen, binds those views to data (via <strong class="source inline">ViewHolder</strong> instances), and reports user interaction with <span class="No-Break">those views.</span></p>
			<p>The layout manager tells <strong class="source inline">RecyclerView</strong> how to lay its children out. We are provided with three layout types by default – linear, grid, and staggered grid – managed by <strong class="source inline">LinearLayoutManager</strong>, <strong class="source inline">GridLayoutManager</strong>, and <span class="No-Break"><strong class="source inline">StaggeredGridLayoutManager</strong></span><span class="No-Break"> respectively.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">This chapter relies on the use of the Jetpack RecyclerView <span class="No-Break">library: </span><a href="https://packt.link/FBX4d"><span class="No-Break">https://packt.link/FBX4d</span></a><span class="No-Break">.</span></p>
			<p>In this chapter, we will develop an app that lists secret agents and whether they are currently active or sleeping (and, thus, unavailable). The app will then allow us to add new agents or delete existing ones by swiping them away. There is a twist, though – as you saw in <a href="B19411_05.xhtml#_idTextAnchor312"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Essential Libraries: Retrofit, Moshi, and Glide</em>, all our agents will <span class="No-Break">be cats.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Adding <strong class="source inline">RecyclerView</strong> to <span class="No-Break">our layout</span></li>
				<li><span class="No-Break">Populating </span><span class="No-Break"><strong class="source inline">RecyclerView</strong></span></li>
				<li>Responding to clicks <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">RecylerView</strong></span></li>
				<li>Supporting different <span class="No-Break">item types</span></li>
				<li>Swiping to <span class="No-Break">remove items</span></li>
				<li>Adding <span class="No-Break">items interactively</span></li>
			</ul>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor361"/><a id="_idTextAnchor362"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/IJbeG"><span class="No-Break">https://packt.link/IJbeG</span></a></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor363"/>Adding RecyclerView to our layout</h1>
			<p>In <a href="B19411_03.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing the UI with Fragments</em>, we saw how we can add views<a id="_idIndexMarker520"/> to our layouts<a id="_idIndexMarker521"/> to be inflated by activities, fragments, or custom views. <strong class="source inline">RecyclerView</strong> is just another such view. To add it to our layout, we need to add the following tag to <span class="No-Break">our layout:</span></p>
			<pre class="source code">
&lt;androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recycler_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:listitem="@layout/item_sample" /&gt;</pre>
			<p>You should already be able to recognize the <strong class="source inline">android:id</strong> attribute, as well as the <strong class="source inline">android:layout_width</strong> and <span class="No-Break"><strong class="source inline">android:layout_height</strong></span><span class="No-Break"> ones.</span></p>
			<p>We can use the optional <strong class="source inline">tools:listitem</strong> attribute to tell Android Studio which layout to inflate as a list item in our preview toolbar. This will give us an idea of how <strong class="source inline">RecyclerView</strong> might look in <span class="No-Break">our app.</span></p>
			<p>Adding a <strong class="source inline">RecyclerView</strong> tag to our layout means we now have an empty container to hold the child views representing our list items. Once populated, it will handle the presenting, scrolling, and recycling of child views <span class="No-Break">for us<a id="_idTextAnchor364"/><a id="_idTextAnchor365"/>.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor366"/>Exercise 6.01 – adding an empty RecyclerView to your main activity</h2>
			<p>To use <strong class="source inline">RecyclerView</strong> in your app, you first need<a id="_idIndexMarker522"/> to add it to one of your layouts. Let’s add<a id="_idIndexMarker523"/> it to the layout inflated by our <span class="No-Break">main activity:</span></p>
			<ol>
				<li>Start by creating a new empty activity project (<strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">New Project</strong> | <strong class="bold">Empty Activity</strong>). Name your application <strong class="source inline">My RecyclerView App</strong>. Make sure your package name <span class="No-Break">is </span><span class="No-Break"><strong class="source inline">com.example.myrecyclerviewapp</strong></span><span class="No-Break">.</span></li>
				<li>Set the save location to where you want to save your project. Leave everything else at their default values and click <strong class="bold">Finish</strong>. Make sure you are on the <strong class="bold">Android</strong> view in your <span class="No-Break"><strong class="bold">Project</strong></span><span class="No-Break"> pan<a id="_idTextAnchor367"/>e:</span></li>
			</ol>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B19411_06_01.jpg" alt="Figure 6.1 – The Android view in the Project pane"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The Android view in the Project pane</p>
			<ol>
				<li value="3">Open your <strong class="source inline">activity_main.xml</strong> file in <span class="No-Break"><strong class="bold">Text</strong></span><span class="No-Break"> mode.</span></li>
				<li>To turn your label<a id="_idIndexMarker524"/> into a title at the top of the screen<a id="_idIndexMarker525"/> under which you can add your <strong class="source inline">RecyclerView</strong>, add an ID to <strong class="source inline">TextView</strong> and align it to the top, <span class="No-Break">like so:</span><pre class="source code">
&lt;TextView
<strong class="bold">    android:id="@+id/hello_label"</strong>
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
<strong class="bold">    app:layout_constraintTop_toTopOf="parent" /&gt;</strong></pre></li>
				<li>Add the following after the <strong class="source inline">TextView</strong> tag to add an empty <strong class="source inline">RecyclerView</strong> element to your layout, constrained below your <strong class="source inline">hello_label</strong> <span class="No-Break"><strong class="source inline">TextView</strong></span><span class="No-Break"> title:</span><pre class="source code">
&lt;androidx.recyclerview.widget.RecyclerView
  android:id="@+id/recycler_view"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  app:layout_constraintTop_toBottomOf="@+id/hello_label" /&gt;</pre></li>
			</ol>
			<p>Your layout file should<a id="_idIndexMarker526"/> now look something<a id="_idIndexMarker527"/> <span class="No-Break">like this:</span></p>
			<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
  ...&gt;
  &lt;TextView
    android:id="@+id/hello_label"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toTopOf="parent" /&gt;
  &lt;androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recycler_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:layout_constraintTop_toBottomOf="@+id/hello_label" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre>
			<ol>
				<li value="6">Run your app by clicking the <strong class="bold">Run app</strong> button or pressing <em class="italic">Ctrl</em> + <em class="italic">R</em> (<em class="italic">Shift</em> + <em class="italic">F10</em> in Windows). On the emulator, it should look <span class="No-Break">like <a id="_idTextAnchor368"/>this:</span></li>
			</ol>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B19411_06_02.jpg" alt="Figure 6.2 – The app with an empty RecyclerView (image cropped for space)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The app with an empty RecyclerView (image cropped for space)</p>
			<p>As you can see, our app runs, and our layout is presented on the screen. However, we do not see our <strong class="source inline">RecyclerView</strong>. Why is that? At this stage, our <strong class="source inline">RecyclerView</strong> has no content. <strong class="source inline">RecyclerView</strong> with no content does not render by default – so, while our <strong class="source inline">RecyclerView</strong> is indeed<a id="_idIndexMarker528"/> on the screen, it is not visible. This brings<a id="_idIndexMarker529"/> us to the next step – populating <strong class="source inline">RecyclerView</strong> with content that we can <span class="No-Break">actual<a id="_idTextAnchor369"/><a id="_idTextAnchor370"/>ly see.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor371"/>Populating RecyclerView</h1>
			<p>So, we added <strong class="source inline">RecyclerView</strong> to our layout. For <a id="_idIndexMarker530"/>us to benefit from <strong class="source inline">RecyclerView</strong>, we need to add content to it. Let’s see how we go about <span class="No-Break">doing that.</span></p>
			<p>As we mentioned before, to add content to our <strong class="source inline">RecyclerView</strong>, we would need to implement an adapter. An adapter binds our data to child views. In simpler terms, this means it tells <strong class="source inline">RecyclerView</strong> how to plug data into views designed to present <span class="No-Break">that data.</span></p>
			<p>For example, let’s say we want to present a list <span class="No-Break">of employees.</span></p>
			<p>First, we need to design<a id="_idIndexMarker531"/> our UI model. This will be a data object holding all the information needed by our view to present a single employee. Because this is a UI model, one convention is to suffix its name <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">UiModel</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
data class EmployeeUiModel(
    val name: String,
    val biography: String,
    val role: EmployeeRole,
    val gender: Gender,
    val imageUrl: String
)</pre>
			<p>We will define <strong class="source inline">EmployeeRole</strong> and <strong class="source inline">Gender</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source code">
enum class EmployeeRole {
    HumanResources,
    Management,
    Technology
}
enum class Gender {
    Female,
    Male,
    Unknown
}</pre>
			<p>The values are provided as an example, of course. Feel free to add more of <span class="No-Break">y<a id="_idTextAnchor372"/>our own!</span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B19411_06_03.jpg" alt="Figure 6.3 – The model’s hierarchy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The model’s hierarchy</p>
			<p>Now, we know what data to expect<a id="_idIndexMarker532"/> when binding to a view, so we can design our view to present this data (this is a simplified version of the actual layout, which we’ll save as <strong class="source inline">item_employee.xml</strong>). We’ll start <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">ImageView</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout ...&gt;
    &lt;ImageView
        android:id="@+id/item_employee_photo"
        android:layout_width="60dp"
        android:layout_height="60dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:background="@color/colorPrimary" /&gt;</pre>
			<p>Then, we will add a <strong class="source inline">TextView</strong> for <span class="No-Break">each field:</span></p>
			<pre class="source code">
  &lt;TextView
    android:id="@+id/item_employee_name"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginStart="16dp"
    android:layout_marginLeft="16dp"
    android:textStyle="bold"
    app:layout_constraintStart_toEndOf="@+id/item_employee_photo"
    app:layout_constraintTop_toTopOf="parent"
    tools:text="Oliver" /&gt;
  &lt;TextView
    android:id="@+id/item_employee_role"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textColor="@color/colorAccent"
    app:layout_constraintStart_toStartOf="@+id/item_employee_name"
    app:layout_constraintTop_toBottomOf="@+id/
        item_employee_name"
    tools:text="Exotic Shorthair" /&gt;
  &lt;TextView
    android:id="@+id/item_employee_biography"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:layout_constraintStart_toStartOf="@+id/item_employee_role"
    app:layout_constraintTop_toBottomOf="@+id/item_employee_role"
    tools:text="Stealthy and witty. Better avoid in dark alleys." /&gt;
  &lt;TextView
    android:id="@+id/item_employee_gender"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textSize="30sp"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintTop_toTopOf="parent"
    tools:text="&amp;#9794;" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre>
			<p>So far, there is nothing new. You should<a id="_idIndexMarker533"/> be able to recognize all of the different view types from <a href="B19411_02.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Building User </em><span class="No-Break"><em class="italic">Scre<a id="_idTextAnchor373"/>en Flows</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B19411_06_04.jpg" alt="Figure 6.4 – A preview of the item_cat.xml layout file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – A preview of the item_cat.xml layout file</p>
			<p>With a data model and a layout, we now have everything we need to bind our data to the view. To do that, we will implement a view holder. Usually, a view holder has two responsibilities – it holds a reference to a view (as its name implies), but it also binds data to that view. We will implement<a id="_idIndexMarker534"/> our view holder <span class="No-Break">as follows:</span></p>
			<pre class="source code">
private const val FEMALE_SYMBOL = "\u2640"
private const val MALE_SYMBOL = "\u2642"
private const val UNKNOWN_SYMBOL = "?"
class EmployeeViewHolder(
  containerView: View,
  private val imageLoader: ImageLoader
) : ViewHolder(containerView) {
<strong class="bold">  </strong>private val employeeNameView: TextView<strong class="bold"> </strong>by lazy {
    containerView.findViewById(R.id.item_employee_name) }
<strong class="bold">  </strong>private val employeeRoleView: TextView<strong class="bold"> </strong>by lazy {
    containerView.findViewById(R.id.item_employee_role) }
<strong class="bold">  </strong>private val employeeBioView: TextView<strong class="bold"> </strong>by lazy {
    containerView.findViewById(R.id.item_employee_bio) }
<strong class="bold">  </strong>private val employeeGenderView: TextView<strong class="bold"> </strong>by lazy {
    containerView.findViewById(R.id.item_employee_gender) }
  fun bindData(employeeData: EmployeeUiModel) {
    imageLoader.loadImage(employeeData.imageUrl,
      employeePhotoView)
    employeeNameView.text = employeeData.name
    employeeRoleView.text = when (employeeData.role) {
      EmployeeRole.HumanResources -&gt; "Human Resources"
      EmployeeRole.Management -&gt; "Management"
      EmployeeRole.Technology -&gt; "Technology"
    }
    employeeBioView.text = employeeData.biography
    employeeGenderView.text = when (employeeData.gender) {
      Gender.Female -&gt; FEMALE_SYMBOL
      Gender.Male -&gt; MALE_SYMBOL
      else -&gt; UNKNOWN_SYMBOL
    }
  }
}</pre>
			<p>There are a few things<a id="_idIndexMarker535"/> worth noting in the preceding code. First, by convention, we suffixed the name of our view holder with <strong class="source inline">ViewHolder</strong>. Second, note that <strong class="source inline">EmployeeViewHolder</strong> needs to implement the abstract <span class="No-Break"><strong class="source inline">RecyclerView.ViewHolder</strong></span><span class="No-Break"> class.</span></p>
			<p>This is required so that the generic type of our adapter can be our view holder. Lastly, we lazily keep references to the views we are interested in. The first time <strong class="source inline">bindData(EmployeeUiModel)</strong> is called, we will find these views in the layout and keep references <span class="No-Break">to them.</span></p>
			<p>Next, we introduced a <strong class="source inline">bindData(EmployeeUiModel)</strong> function. This function will be called by our adapter to bind the data to the view held by the view holder. The last but most important thing to note is that we always make sure to set a state for all modified views for every <span class="No-Break">possible input.</span></p>
			<p>With our view holder set up, we can proceed to implement our adapter. We will start by implementing the minimum required functions, plus a function to set the data. Our adapter will look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
class EmployeesAdapter(
  private val layoutInflater: LayoutInflater,
  private val imageLoader: ImageLoader
) : RecyclerView.Adapter&lt;EmployeeViewHolder&gt;() {
  private val employees = mutableListOf&lt;EmployeeUiModel&gt;()
  fun setData(newEmployees: List&lt;EmployeeUiModel&gt;) {
    employees.clear()
    employees.addAll(newEmployees)
    notifyDataSetChanged()
  }
  override fun onCreateViewHolder(parent: ViewGroup,
    viewType: Int): EmployeeViewHolder {
    val view = layoutInflater.inflate(
      R.layout.item_employee, parent, false)
    return EmployeeViewHolder(view, imageLoader)
  }
  override fun getItemCount() = employees.size
  override fun onBindViewHolder(
    holder: EmployeeViewHolder, position: Int) {
    holder.bindData(employees [position])
  }
}</pre>
			<p>Let’s go over this implementation. First, we inject<a id="_idIndexMarker536"/> our dependencies into the adapter via its constructor. This will make testing our adapter much easier but will also allow us to change some of its behavior (for example, replace the image loading library) painlessly. In fact, we would not need to change the adapter at all in <span class="No-Break">that case.</span></p>
			<p>Then, we define a private mutable list of <strong class="source inline">EmployeeUiModel</strong> to store the data currently provided by the adapter to <strong class="source inline">RecyclerView</strong>. We also introduce a method (<strong class="source inline">setData</strong>) to populate that list. Note that we keep a local list and set its contents, rather than allowing <strong class="source inline">employees</strong> to be <span class="No-Break">set directly.</span></p>
			<p>This is mainly because Kotlin, just like Java, passes variables by reference. Passing variables by reference means changes to the content of the list passed into the adapter would change the list held by the adapter. So, for example, if an item was removed outside of the adapter, the adapter would have that item removed <span class="No-Break">as well.</span></p>
			<p>This becomes a problem because the adapter would not be aware of that change, and so would not be able to notify <strong class="source inline">RecyclerView</strong>. There are other risks around a list being modified outside of the adapter, but covering them is beyond the scope of <span class="No-Break">this book.</span></p>
			<p>Another benefit of encapsulating<a id="_idIndexMarker537"/> the modification of data in a function is that we avoid the risk of forgetting to notify <strong class="source inline">RecyclerView</strong> that a dataset has changed, which we do by <span class="No-Break">calling </span><span class="No-Break"><strong class="source inline">notifyDataSetChanged()</strong></span><span class="No-Break">.</span></p>
			<p>We proceed to implement the adapter’s <strong class="source inline">onCreateViewHolder(ViewGroup, Int)</strong> function. This function is called when <strong class="source inline">RecyclerView</strong> needs a new <strong class="source inline">ViewHolder</strong> to render data on a screen. It provides us with a <strong class="source inline">ViewGroup</strong> container and a view type (we’ll look into view types later in <span class="No-Break">this chapter).</span></p>
			<p>The function then expects us to return a view holder initialized with a view (in our case, an inflated one). So, we inflate the view we designed earlier, passing it to a new <strong class="source inline">EmployeeViewHolder</strong> instance. Note that the last argument to the inflated function <span class="No-Break">is </span><span class="No-Break"><strong class="source inline">false</strong></span><span class="No-Break">.</span></p>
			<p>This makes sure we do not attach the newly inflated view to the parent. Attaching and detaching views will be managed by the layout manager. Setting the view to <strong class="source inline">true</strong> or omitting it would result in <strong class="source inline">IllegalStateException</strong> being thrown. Finally, we return the newly <span class="No-Break">created </span><span class="No-Break"><strong class="source inline">EmployeeViewHolder</strong></span><span class="No-Break">.</span></p>
			<p>To implement <strong class="source inline">getItemCount()</strong>, we simply return the size of our <span class="No-Break"><strong class="source inline">employees</strong></span><span class="No-Break"> list.</span></p>
			<p>Lastly, we implement <strong class="source inline">onBindViewHolder(EmployeeViewHolder, Int)</strong>. This is done by passing <strong class="source inline">EmployeeUiModel</strong>, stored in <strong class="source inline">employees</strong>, at the given position to the <strong class="source inline">bindData(EmployeeUiModel)</strong> function of our view holder. Our adapter is <span class="No-Break">now ready.</span></p>
			<p>If we tried to plug our adapter into our <strong class="source inline">RecyclerView</strong> at this point and run our app, we would still see no content. This is because we are still missing two small steps – setting data on our adapter and assigning a layout manager to our <strong class="source inline">RecyclerView</strong>. The complete working code would look <span class="No-Break">like this:</span></p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {  
    private val employeesAdapter  
        by lazy { EmployeesAdapter(layoutInflater, 
        GlideImageLoader(this)) }  
    private val recyclerView: RecyclerView 
        by lazy { findViewById(R.id.main_recycler_view) }  
    override fun onCreate(savedInstanceState: Bundle?) {  
        super.onCreate(savedInstanceState)  
        setContentView(R.layout.activity_main)  
        recyclerView.adapter = employeesAdapter  
        recyclerView.layoutManager = LinearLayoutManager(  
            this, LinearLayoutManager.VERTICAL, false)  
        employeesAdapter.setData(  
            listOf(  
                EmployeeUiModel(  
                    "Robert",  
                    "Rose quickly through the organization",  
                    EmployeeRole.Management,  
                    Gender.Male,  
                    "https://images.pexels.com/photos/220453/
                    pexels-photo-220453.jpeg?  
                    auto=compress&amp;cs=tinysrgb&amp;h=650&amp;w=940"  
                 ),  
                 EmployeeUiModel(  
                    "Wilma",  
                    "A talented developer",  
                    EmployeeRole.Technology,  
                    Gender.Female,  
                    "https://images.pexels.com/photos/3189024/
                    pexels-photo-3189024.jpeg?  
                    auto=compress&amp;cs=tinysrgb&amp;h=650&amp;w=940"  
                 ),  
                 EmployeeUiModel( 
                    "Curious George",  
                    "Excellent at retention",  
                    EmployeeRole.HumanResources,  
                    Gender.Unknown,  
                    "https://images.pexels.com/photos/771742/
                    pexels-photo-771742.jpeg? 
                    auto=compress&amp;cs=tinysrgb&amp;h=750&amp;w=1260"  
                 )  
             )  
        )  
    }  
} </pre>
			<p>Running our app now, we would see a list of <span class="No-Break">our employees.</span></p>
			<p>Note that we hardcoded<a id="_idIndexMarker538"/> the list of employees. In a production app, following a <strong class="bold">Model-View-View-Model</strong> (<strong class="bold">MVVM</strong>) pattern (we will cover this pattern in <a href="B19411_15.xhtml#_idTextAnchor789"><span class="No-Break"><em class="italic">Chapter 15</em></span></a><em class="italic">, Architecture Patterns</em>), you would be provided with data to present to your <strong class="source inline">ViewModel</strong>. It is also important to note that we kept a reference <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">employeesAdapter</strong></span><span class="No-Break">.</span></p>
			<p>This is so that we could, later on, set the data to different values. Some implementations rely on reading the adapter from <strong class="source inline">RecyclerView</strong> itself – this can potentially result in unnecessary casting operations and unexpected states where the adapter is not yet assigned to <strong class="source inline">RecyclerView</strong>, so this is generally not a <span class="No-Break">recommended approach.</span></p>
			<p>Lastly, note that we chose to use <strong class="source inline">LinearLayoutManager</strong>, providing<a id="_idIndexMarker539"/> it with the activity for context, a <strong class="source inline">VERTICAL</strong> orientation flag, and <strong class="source inline">false</strong> to tell it that we do not want the order of the items in the<a id="_idTextAnchor374"/><a id="_idTextAnchor375"/> <span class="No-Break">list reversed.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor376"/>Exercise 6.02 – populating your RecyclerView</h2>
			<p><strong class="source inline">RecyclerView</strong> is not very interesting without<a id="_idIndexMarker540"/> any content. It is time to populate <strong class="source inline">RecyclerView</strong> by adding your secret cat agents <span class="No-Break">to it.</span></p>
			<p>A quick recap before you dive in – in the previous exercise, we introduced an empty list designed to hold a list of secret cat agents that users have at their disposal. In this exercise, you will be populating that list to present the users with the available secret cat agents in <span class="No-Break">the agency:</span></p>
			<ol>
				<li>To keep our file structure tidy, we will start by creating a model package. Right-click on the package name of our app, and then select<a id="_idTextAnchor377"/> <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">Package</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B19411_06_05.jpg" alt="Figure 6.5 – Creating a new package"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Creating a new package</p>
			<ol>
				<li value="2">Name the new package <strong class="source inline">model</strong>. Click <strong class="bold">OK</strong> to create <span class="No-Break">the package.</span></li>
				<li>To create our first model data class, right-click on the newly created model package, and then select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">Kotlin File/Class</strong></span><span class="No-Break">.</span></li>
				<li>Under <strong class="bold">Name</strong>, fill in <strong class="source inline">CatUiModel</strong>. Leave <strong class="bold">kind</strong> as <strong class="bold">File</strong> and click on <strong class="bold">OK</strong>. This will be the class holding the data we have about every individual <span class="No-Break">cat agent.</span></li>
				<li>Add the following to the newly created <strong class="source inline">CatUiModel.kt</strong> file to define the data class with all the relevant properties of a <span class="No-Break">cat agent:</span><pre class="source code">
data class CatUiModel(
    val gender: Gender,
    val breed: CatBreed,
    val name: String,
    val biography: String,
    val imageUrl: String
)</pre></li>
			</ol>
			<p>For each cat agent, other than<a id="_idIndexMarker541"/> their name and photo, we want to know their gender, breed, and biography. This will help us choose the right agent for <span class="No-Break">a mission.</span></p>
			<ol>
				<li value="6">Again, right-click on the model package, and then navigate to <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">Kotlin File/Class</strong></span><span class="No-Break">.</span></li>
				<li>This time, name the new file <strong class="source inline">CatBreed</strong> and set <strong class="source inline">kind</strong> to the <strong class="source inline">Enum</strong> class. This class will hold our different <span class="No-Break">cat breeds.</span></li>
				<li>Update your newly created <strong class="source inline">enum</strong> with some initial values, <span class="No-Break">as follows:</span><pre class="source code">
enum class CatBreed {
    AmericanCurl, BalineseJavanese, ExoticShorthair
}</pre></li>
				<li>Repeat <em class="italic">step 6</em> and <em class="italic">step 7</em>, only this time call your file <strong class="source inline">Gender</strong>. This will hold the accepted values for a cat <span class="No-Break">agent’s gender.</span></li>
				<li>Update the <strong class="source inline">Gender</strong> enum, <span class="No-Break">like so:</span><pre class="source code">
enum class Gender {
    Female, Male, Unknown
}</pre></li>
				<li>Now, to define the layout of the view holding the data about each cat agent, create a new layout resource file by right-clicking on <strong class="source inline">layout</strong> and then selecting <strong class="bold">New</strong> | <strong class="bold">Layout<a id="_idTextAnchor378"/> </strong><span class="No-Break"><strong class="bold">resource file</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B19411_06_06.jpg" alt="Figure 6.6 – Creating a new layout resource file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Creating a new layout resource file</p>
			<ol>
				<li value="12">Name your resource <strong class="source inline">item_cat</strong>. Leave all the other fields as they are and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
				<li>Update the contents<a id="_idIndexMarker542"/> of the newly created <strong class="source inline">item_cat.xml</strong> file (the following code block has been truncated for space, so use the following link to see the full code that you need <span class="No-Break">to add):</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">item_cat.xml</p>
			<pre class="source code">
    &lt;ImageView
        android:id="@+id/item_cat_photo"
        android:layout_width="60dp"
        android:layout_height="60dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:background="@color/colorPrimary" /&gt;
    &lt;TextView
        android:id="@+id/item_cat_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginStart="16dp"
        android:layout_marginLeft="16dp"
        android:textStyle="bold"
        app:layout_constraintStart_toEndOf="@+id/
            item_cat_photo"
        app:layout_constraintTop_toTopOf="parent"
        tools:text="Oliver" /&gt;</pre>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="http://packt.live/3sopUjo"><span class="No-Break">http://packt.live/3sopUjo</span></a><span class="No-Break">.</span></p>
			<p>This will create a layout<a id="_idIndexMarker543"/> with an image and text fields for a name, breed, and biography to be used in <span class="No-Break">our list.</span></p>
			<ol>
				<li value="14">You will need a copy of <strong class="source inline">ImageLoader.kt</strong>, introduced in <a href="B19411_05.xhtml#_idTextAnchor312"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Essential Libraries: Retrofit, Moshi, and Glide</em>, so right-click on the package name of your app, navigate to <strong class="bold">New</strong> | <strong class="bold">Kotlin File/Class</strong>, then set the name to <strong class="source inline">ImageLoader</strong> and <strong class="bold">kind</strong> to <strong class="bold">Interface</strong>, and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
				<li>Similar to <a href="B19411_05.xhtml#_idTextAnchor312"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Essential Libraries: Retrofit, Moshi, and Glide</em>, you only need to add one <span class="No-Break">function here:</span><pre class="source code">
interface ImageLoader {
  fun loadImage(imageUrl: String, imageView: ImageView)
}</pre></li>
			</ol>
			<p>Make sure to <span class="No-Break">import </span><span class="No-Break"><strong class="source inline">ImageView</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="16">Right-click on the package name of your app again, and then select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">Kotlin File/Class</strong></span><span class="No-Break">.</span></li>
				<li>Call the new file <strong class="source inline">CatViewHolder</strong>. <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
				<li>To implement <strong class="source inline">CatViewHolder</strong>, which will bind the cat agent data to your views, replace<a id="_idIndexMarker544"/> the contents of the <strong class="source inline">CatViewHolder.kt</strong> file with <span class="No-Break">the following:</span><pre class="source code">
private val FEMALE_SYMBOL = "\u2640"
private val MALE_SYMBOL = "\u2642"
private const val UNKNOWN_SYMBOL = "?"
class CatViewHolder(
  containerView: View,
  private val imageLoader: ImageLoader
) : ViewHolder(containerView) {
  private val catBiographyView: TextView by lazy {
    containerView
      .findViewById(R.id.item_cat_biography) }
  private val catBreedView: TextView by lazy {
    containerView.findViewById(R.id.item_cat_breed) }
  private val catGenderView: TextView by lazy {
    containerView.findViewById(R.id.item_cat_gender) }
  private val catNameView: TextView by lazy {
    containerView.findViewById(R.id.item_cat_name) }
  private val catPhotoView: ImageView by lazy {
    containerView.findViewById(R.id.item_cat_photo) }
  fun bindData(cat: CatUiModel) {
    imageLoader.loadImage(cat.imageUrl, catPhotoView)
    catNameView.text = cat.name
    catBreedView.text = when (cat.breed) {
      AmericanCurl -&gt; "American Curl"
      BalineseJavanese -&gt; "Balinese-Javanese"
      ExoticShorthair -&gt; "Exotic Shorthair"
    }
    catBiographyView.text = cat.biography
    catGenderView.text = when (cat.gender) {
      Female -&gt; FEMALE_SYMBOL
      Male -&gt; MALE_SYMBOL
      else -&gt; UNKNOWN_SYMBOL
    }
  }
}</pre></li>
				<li>Still under our app package name, create a new Kotlin file <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">CatsAdapter</strong></span><span class="No-Break">.</span></li>
				<li>To implement <strong class="source inline">CatsAdapter</strong>, which is responsible<a id="_idIndexMarker545"/> for storing the data for <strong class="source inline">RecyclerView</strong>, as well as creating instances of your view holder and using them to bind data to views, replace the contents of the <strong class="source inline">CatsAdapter.kt</strong> file <span class="No-Break">with this:</span><pre class="source code">
package com.example.myrecyclerviewapp
import { ... }
class CatsAdapter(
    private val layoutInflater: LayoutInflater,
    private val imageLoader: ImageLoader
) : RecyclerView.Adapter&lt;CatViewHolder&gt;() {
    private val cats = mutableListOf&lt;CatUiModel&gt;()
    fun setData(newCats: List&lt;CatUiModel&gt;) {
        cats.clear()
        cats.addAll(newCats)
        notifyDataSetChanged()
    }
    override fun onCreateViewHolder(parent: ViewGroup,
      viewType: Int): CatViewHolder {
        val view = layoutInflater
          .inflate(R.layout.item_cat, parent, false)
        return CatViewHolder(view, imageLoader)
    }
    override fun getItemCount() = cats.size
    override fun onBindViewHolder(
        holder: CatViewHolder, position: Int) {
        holder.bindData(cats[position])
    }
}</pre></li>
				<li>At this point, you need to include Glide<a id="_idIndexMarker546"/> in your project. Start by adding the following line of code to the <strong class="source inline">dependencies</strong> block inside your app’s <span class="No-Break"><strong class="source inline">gradle.build</strong></span><span class="No-Break"> file:</span><pre class="source code">
implementation 'com.github.bumptech.glide:glide:4.14.2'</pre></li>
				<li>Create a <strong class="source inline">GlideImageLoader</strong> class in your app package path, containing <span class="No-Break">the following:</span><pre class="source code">
package com.example.myrecyclerviewapp
[imports]
class GlideImageLoader(context: Context) : ImageLoader {
    private val glide by lazy { Glide(context) }
    override fun loadImage(imageUrl: String,
    imageView: ImageView) {
        glide.load(imageUrl)
            .centerCrop().into(imageView)
    }
}</pre></li>
			</ol>
			<p>This is a simple implementation assuming<a id="_idIndexMarker547"/> the loaded image should always <span class="No-Break">be center-cropped.</span></p>
			<ol>
				<li value="23">Update your <span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break"> file:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
  private val recyclerView: RecyclerView by lazy {
    findViewById(R.id.recycler_view) }
  private val catsAdapter by lazy { CatsAdapter(
    layoutInflater, GlideImageLoader(this)) }
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    recyclerView.adapter = catsAdapter
    recyclerView.layoutManager = LinearLayoutManager(
      this, LinearLayoutManager.VERTICAL, false)
    catsAdapter.setData(
      listOf(
        CatUiModel(Gender.Male,
          CatBreed.BalineseJavanese, "Fred",
          "Silent and deadly",
          "https://cdn2.thecatapi.com/image/DBmIBhhyv.
          jpg"
        ),
        CatUiModel(Gender.Female,
          CatBreed.ExoticShorthair, "Wilma",
          "Cuddly assassin",
          "https://cdn2.thecatapi.com/images/KJF8fB_20.
          jpg"
        ),
        CatUiModel(Gender.Unknown,
          CatBreed.AmericanCurl, "Curious George",
          "Award winning investigator",
          "https://cdn2.thecatapi.com/images/vJB8rwfdX.
          jpg"
        )
      )
    )
  }
}</pre></li>
			</ol>
			<p>This will define<a id="_idIndexMarker548"/> your adapter, attach it to <strong class="source inline">RecyclerView</strong>, and populate it with some <span class="No-Break">hardcoded data.</span></p>
			<ol>
				<li value="24">In your <strong class="source inline">AndroidManifest.xml</strong> file, add the following in the <strong class="source inline">manifest</strong> tag before the <span class="No-Break">application tag:</span><pre class="source code">
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</pre></li>
			</ol>
			<p>Having this tag will allow your app to download images from <span class="No-Break">the internet.</span></p>
			<ol>
				<li value="25">For some final touches, such as giving our title view a proper<a id="_idIndexMarker549"/> name and text, update your <strong class="source inline">activity_main.xml</strong> file, <span class="No-Break">like so:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
  ...&gt;
  &lt;TextView
    android:id="@+id/main_label"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/main_title"
    android:textSize="24sp"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toTopOf="parent" /&gt;
  &lt;androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recycler_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:layout_constraintTop_toBottomOf="@+id/main_label" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
				<li>Also, update your <strong class="source inline">strings.xml</strong> file to give your app a proper name <span class="No-Break">and title:</span><pre class="source code">
&lt;resources&gt;
  &lt;string name="app_name"&gt;SCA - Secret Cat Agents&lt;/string&gt;
  &lt;string name="main_title"&gt;Our Agents&lt;/string&gt;
&lt;/resources&gt;</pre></li>
				<li>Run your app. It <a id="_idTextAnchor379"/>should look <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B19411_06_07.jpg" alt="Figure 6.7 – RecyclerView with hardcoded secret cat agents"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – RecyclerView with hardcoded secret cat agents</p>
			<p>As you can see, <strong class="source inline">RecyclerView</strong> now has content, and your app is starting to take shape. Note how the same layout is used to present different items based on the data bound to each instance. As you would<a id="_idIndexMarker550"/> expect, if you add enough items for them to go off screen, scrolling works. Next, we’ll look into allowing a user to interact with the items i<a id="_idTextAnchor380"/><a id="_idTextAnchor381"/>nside <span class="No-Break">our </span><span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor382"/>Responding to clicks in RecyclerView</h1>
			<p>What if we want<a id="_idIndexMarker551"/> to let our users select<a id="_idIndexMarker552"/> an item from a presented list? To achieve that, we need to communicate clicks back to <span class="No-Break">our app.</span></p>
			<p>The first step in implementing click interaction is to capture clicks on items at the <strong class="source inline">ViewHolder</strong> level. To maintain separation between our view holder and the adapter, we define a nested <strong class="source inline">OnClickListener</strong> interface in our view holder. We choose to define the interface within the view holder because that and the listener are <span class="No-Break">tightly coupled.</span></p>
			<p>The interface will, in our case, have only one function. The purpose of this function is to inform the owner of the view holder about the clicks. The owner of a view holder is usually a <strong class="source inline">Fragment</strong> or an <strong class="source inline">Activity</strong>. Since we know that a view holder can be reused, we know that it can be challenging to define it at construction time in a way that would tell us which item was clicked (since that item will change over time <span class="No-Break">with reuse).</span></p>
			<p>We work around that by passing the currently presented item back to the owner of the view holder on clicking. This means our interface would look <span class="No-Break">like this:</span></p>
			<pre class="source code">
interface OnClickListener {
    fun onClick(cat: CatUiModel)
}</pre>
			<p>We will also add this listener as a parameter to our <span class="No-Break"><strong class="source inline">ViewHolder</strong></span><span class="No-Break"> constructor:</span></p>
			<pre class="source code">
class CatViewHolder(
    containerView: View,
    private val imageLoader: ImageLoader<strong class="bold">,</strong>
<strong class="bold">    private val onClickListener: OnClickListener</strong>
) : ViewHolder(containerView) {
    ...
}</pre>
			<p>It will be used <span class="No-Break">like this:</span></p>
			<pre class="source code">
containerView.setOnClickListener {
    onClickListener.onClick(cat) }</pre>
			<p>Now, we want our adapter to pass in a listener. In turn, that listener will be responsible for informing the owner of the adapter about the click. This means our adapter, too, would need a nested listener interface, quite similar to the one we implemented in our <span class="No-Break">view holder.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">While this seems like duplication that can be avoided by reusing the same listener, that is not a great idea, as it leads to tight coupling between the view holder and the adapter through the listener. What happens when you want your adapter to also report other events through the listener? You would have to handle those events coming from the view holder, even though they would not actually be implemented in the <span class="No-Break">view holder.</span></p>
			<p>Finally, to handle the click event and show a dialog, we define a listener in our activity and pass it to our adapter. We set that listener to show a dialog on clicking. In an MVVM implementation, you would be notifying the <strong class="source inline">ViewModel</strong> of the click<a id="_idIndexMarker553"/> at this point instead. <strong class="source inline">ViewModel</strong> would then update its state, telling<a id="_idIndexMarker554"/> the view (our activity) that it<a id="_idTextAnchor383"/><a id="_idTextAnchor384"/> should display <span class="No-Break">the dialog.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor385"/>Exercise 6.03 – responding to clicks</h2>
			<p>Your app already shows<a id="_idIndexMarker555"/> the user a list of secret cat agents. It is time to allow<a id="_idIndexMarker556"/> your user to choose a secret cat agent by clicking on its view. Click events are delegated from the view holder to the adapter to the activ<a id="_idTextAnchor386"/>ity, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B19411_06_08.jpg" alt="Figure 6.8 – The flow of click events"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The flow of click events</p>
			<p>The following are the steps<a id="_idIndexMarker557"/> that you need to follow to complete<a id="_idIndexMarker558"/> <span class="No-Break">this exercise:</span></p>
			<ol>
				<li>Open your <strong class="source inline">CatViewHolder.kt</strong> file. Add a nested interface to it right before the final closing <span class="No-Break">curly bracket:</span><pre class="source code">
interface OnClickListener {
    fun onClick(cat: CatUiModel)
}</pre></li>
			</ol>
			<p>This will be the interface that a listener will have to implement in order to register for click events on individual <span class="No-Break">cat items.</span></p>
			<ol>
				<li value="2">Update the <strong class="source inline">CatViewHolder</strong> constructor to accept <strong class="source inline">OnClickListener</strong> and make <span class="No-Break"><strong class="source inline">containerView</strong></span><span class="No-Break"> accessible:</span><pre class="source code">
class CatViewHolder(
    <strong class="bold">private val</strong> containerView: View,
    private val imageLoader: ImageLoader<strong class="bold">,</strong>
<strong class="bold">    private val onClickListener: OnClickListener</strong>
) : ViewHolder(containerView) {</pre></li>
			</ol>
			<p>Now, when constructing a <strong class="source inline">CatViewHolder</strong> constructor, you also register<a id="_idIndexMarker559"/> for clicks<a id="_idIndexMarker560"/> on <span class="No-Break">item views.</span></p>
			<ol>
				<li value="3">At the top of your <strong class="source inline">bindData(CatUiModel)</strong> function, add the following to intercept clicks and report them to the <span class="No-Break">provided listener:</span><pre class="source code">
containerView.setOnClickListener {
    onClickListener.onClick(cat) }</pre></li>
				<li>Now, open your <strong class="source inline">CatsAdapter.kt</strong> file. Add this nested interface right before the final closing <span class="No-Break">curly bracket:</span><pre class="source code">
interface OnClickListener {
    fun onItemClick(cat: CatUiModel)
}</pre></li>
			</ol>
			<p>This defines the interface that listeners will have to implement to receive item click events from <span class="No-Break">the adapter.</span></p>
			<ol>
				<li value="5">Update the <strong class="source inline">CatsAdapter</strong> constructor to accept a call implementing the <strong class="source inline">OnClickListener</strong> adapter you <span class="No-Break">just defined:</span><pre class="source code">
class CatsAdapter(
    private val layoutInflater: LayoutInflater,
    private val imageLoader: ImageLoader<strong class="bold">,</strong>
<strong class="bold">    private val onClickListener: OnClickListener</strong>
) : RecyclerView.Adapter&lt;CatViewHolder&gt;() {</pre></li>
				<li>In <strong class="source inline">onCreateViewHolder(ViewGroup, Int)</strong>, update the creation of the view holder, <span class="No-Break">as follows:</span><pre class="source code">
return CatViewHolder(view, imageLoader, <strong class="bold">object :</strong>
<strong class="bold">CatViewHolder.OnClickListener {</strong>
<strong class="bold">override fun onClick(cat: CatUiModel) =</strong>
<strong class="bold">onClickListener.onItemClick(cat)</strong>
<strong class="bold">}</strong>)</pre></li>
			</ol>
			<p>This will add an anonymous class<a id="_idIndexMarker561"/> that delegates the <strong class="source inline">ViewHolder</strong> click events<a id="_idIndexMarker562"/> to the <span class="No-Break">adapter listener.</span></p>
			<ol>
				<li value="7">Finally, open your <strong class="source inline">MainActivity.kt</strong> file. Update your <strong class="source inline">catsAdapter</strong> construction as follows to provide the required dependencies to the adapter, in the form of an anonymous listener handling click events by showing <span class="No-Break">a dialog:</span><pre class="source code">
private val catsAdapter by lazy {
  CatsAdapter(layoutInflater, GlideImageLoader(this)<strong class="bold">,</strong>
<strong class="bold">    object : CatsAdapter.OnClickListener {</strong>
<strong class="bold">      override fun onClick(cat: CatUiModel) =</strong>
<strong class="bold">        onClickListener.onItemClick(cat)</strong>
<strong class="bold">    }</strong>
  )
}</pre></li>
				<li>Add the following function right before the final closing <span class="No-Break">curly bracket:</span><pre class="source code">
private fun showSelectionDialog(cat: CatUiModel) {
  AlertDialog.Builder(this)
    .setTitle("Agent Selected")
    .setMessage("You have selected agent ${cat.name}")
    .setPositiveButton("OK") { _, _ -&gt; }.show()
}</pre></li>
			</ol>
			<p>This function will show a dialog with the name of the cat whose data was <span class="No-Break">passed in.</span></p>
			<ol>
				<li value="9">Make sure to import the right version of <strong class="source inline">AlertDialog</strong>, which is <strong class="source inline">androidx.appcompat.app.AlertDialog</strong>, <span class="No-Break">not </span><span class="No-Break"><strong class="source inline">android.app.AlertDialog</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The AppCompat version is usually a better choice because it offers <span class="No-Break">backward compatibility.</span></p>
			<ol>
				<li value="10">Run your app. Clicking on one of t<a id="_idTextAnchor387"/>he cats<a id="_idIndexMarker563"/> should now<a id="_idIndexMarker564"/> open <span class="No-Break">a dialog:</span></li>
			</ol>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B19411_06_09.jpg" alt="Figure 6.9 – A dialog showing an agent was selected"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – A dialog showing an agent was selected</p>
			<p>Try clicking the different items, and note the<a id="_idIndexMarker565"/> different messages presented. You now know how to respond<a id="_idIndexMarker566"/> to users clicking on items inside your <strong class="source inline">RecyclerView</strong>. Next, we will look at how we can suppo<a id="_idTextAnchor388"/><a id="_idTextAnchor389"/>rt different item types in <span class="No-Break">our lists.</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor390"/>Supporting different Item types</h1>
			<p>In the previous sections, we learned<a id="_idIndexMarker567"/> how to handle a list of items of a single type (in our case, all our items were <strong class="source inline">CatUiModel</strong>). What happens if you want to support more than one type of item? A good example of this would be having group titles on <span class="No-Break">our list.</span></p>
			<p>Let’s say that instead of getting a list of cats, we get a list containing happy cats and sad cats. Each of the two groups of cats is preceded by a title of the corresponding group. Instead of a list of <strong class="source inline">CatUiModel</strong> instances, our list would now contain <strong class="source inline">ListItem</strong> instances. <strong class="source inline">ListItem</strong> might look <span class="No-Break">like this:</span></p>
			<pre class="source code">
sealed class ListItem {
    data class Group(val name: String) : ListItem()
    data class Cat(val cat: CatUiModel) : ListItem()
}</pre>
			<p>Our list of items may look <span class="No-Break">like this:</span></p>
			<pre class="source code">
listOf(
  ListItem.Group("Happy Cats"),
  ListItem.Cat(
    CatUiModel(Gender.Female, CatBreed.AmericanCurl,
      "Kitty", "Kitty is warm and fuzzy.",
      "https://cdn2.thecatapi.com/images/..."
    )
  ),
  ListItem.Cat(
    CatUiModel(Gender.Male, CatBreed.ExoticShorthair,
      "Joey", "Loves to cuddle.",
      "https://cdn2.thecatapi.com/images/..."
    )
  ),
  ListItem.Group("Sad Cats"),
  ListItem.Cat(
    CatUiModel(Gender.Unknown, CatBreed.AmericanCurl,
      "Ginger", "Just not in the mood.",
      "https://cdn2.thecatapi.com/images/..."
    )
  ),
  ListItem.Cat(
      CatUiModel(Gender.Female, CatBreed.ExoticShorthair,
      "Butters", "Sleeps most of the time.",
      "https://cdn2.thecatapi.com/images/..."
    )
  )
)</pre>
			<p>In this case, having just one layout<a id="_idIndexMarker568"/> type will not do. Luckily, as you may have noticed in our earlier exercises, <strong class="source inline">RecyclerView.Adapter</strong> provides us with a mechanism to handle this (remember the <strong class="source inline">viewType</strong> parameter used in the <strong class="source inline">onCreateViewHolder(ViewGroup, </strong><span class="No-Break"><strong class="source inline">Int)</strong></span><span class="No-Break"> function?).</span></p>
			<p>To help the adapter determine which view type is needed for each item, we override its <strong class="source inline">getItemViewType(Int)</strong> function. An example of an implementation that would do the trick for us is <span class="No-Break">the following:</span></p>
			<pre class="source code">
override fun getItemViewType(position: Int) =
  when (listData[position]) {
    is ListItem.Group -&gt; VIEW_TYPE_GROUP
    is ListItem.Cat -&gt; VIEW_TYPE_CAT
  }</pre>
			<p>Here, <strong class="source inline">VIEW_TYPE_GROUP</strong> and <strong class="source inline">VIEW_TYPE_CAT</strong> are defined <span class="No-Break">as follows:</span></p>
			<pre class="source code">
private const val VIEW_TYPE_GROUP = 0
private const val VIEW_TYPE_CAT = 1</pre>
			<p>This implementation maps<a id="_idIndexMarker569"/> the data type at a given position to a constant value, representing one of our known layout types. In our case, we know about titles and cats, thus the two types. The values we use can be any integer values as they’re passed back to us, as is the case in the <strong class="source inline">onCreateViewHolder(ViewGroup, Int)</strong> function. All we need to do is make sure not to repeat the same value more <span class="No-Break">than once.</span></p>
			<p>Now that we have told the adapter which view types are supported, we also need to tell it which view holder to use for each view type. This is done by implementing the <strong class="source inline">onCreateViewHolder(ViewGroup, </strong><span class="No-Break"><strong class="source inline">Int)</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source code">
override fun onCreateViewHolder(parent: ViewGroup,
viewType: Int) = when (viewType) {
    VIEW_TYPE_GROUP -&gt; {
        val view = layoutInflater.inflate(
            R.layout.item_title, parent, false)
        GroupViewHolder(view)
    }
    VIEW_TYPE_CAT -&gt; {
        val view = layoutInflater.inflate(
            R.layout.item_cat, parent, false)
        CatViewHolder(view, imageLoader, object :
        CatViewHolder.OnClickListener {
        override fun onClick(cat: CatUiModel) =
            onClickListener.onItemClick(cat)
        })
    }
    else -&gt; throw IllegalArgumentException(
      "Unknown view type requested: $viewType")
}</pre>
			<p>Unlike the earlier implementations<a id="_idIndexMarker570"/> of this function, we now take the value of <strong class="source inline">viewType</strong> <span class="No-Break">into account.</span></p>
			<p>As we now know, <strong class="source inline">viewType</strong> is expected to be one of the values we returned <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">getItem</strong></span><strong class="source inline">
</strong><span class="No-Break"><strong class="source inline">ViewType(Int)</strong></span><span class="No-Break">.</span></p>
			<p>For each of these values (<strong class="source inline">VIEW_TYPE_GROUP</strong> and <strong class="source inline">VIEW_TYPE_CAT</strong>), we inflate the corresponding layout and construct a suitable view holder. Note that we never expect to receive any other value, so we throw an exception if such a value <span class="No-Break">is encountered.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">Depending on your needs, you could instead return a default view holder with a layout, showing an error or nothing at all. It may also be a good idea to log such values to allow you to investigate why you received them and decide how to <span class="No-Break">handle them.</span></p>
			<p>For our group title layout, a simple <strong class="source inline">TextView</strong> may be sufficient. For a cat, the <strong class="source inline">item_cat.xml</strong> layout can be used <span class="No-Break">as is.</span></p>
			<p>Now, let’s move on to the view holder. We need to create a view holder for the group title. This means we will now have two different view holders. However, our adapter only supports one adapter type. The easiest solution is to define a common view holder that both <strong class="source inline">GroupViewHolder</strong> and <strong class="source inline">CatViewHolder</strong> <span class="No-Break">will extend.</span></p>
			<p>Let’s call it <strong class="source inline">ListItemViewHolder</strong>. The <strong class="source inline">ListItemViewHolder</strong> class can be abstract, as we never intend to use it directly. To make it easy to bind data, we can also introduce a function in our abstract view holder – <strong class="source inline">abstract fun </strong><span class="No-Break"><strong class="source inline">bindData(listItem: ListItemUiModel)</strong></span><span class="No-Break">.</span></p>
			<p>Our concrete implementations can expect to receive a specific type, and so we can add the following lines to both <strong class="source inline">GroupViewHolder</strong> and <span class="No-Break"><strong class="source inline">CatViewHolder</strong></span><span class="No-Break"> respectively:</span></p>
			<pre class="source code">
require(listItem is ListItemUiModel.Group)
    { "Expected ListItemUiModel.Group" }
require(listItem is ListItemUiModel.Cat)
    { "Expected ListItemUiModel.Cat" }</pre>
			<p>Specifically, in <strong class="source inline">CatViewHolder</strong>, thanks to some Kotlin magic, we can then use <strong class="source inline">define val cat = listItem.cat</strong> and leave the rest of the <span class="No-Break">class unchanged.</span></p>
			<p>Having made those changes, we can now expect<a id="_idIndexMarker571"/> to see the <strong class="source inline">Happy Cats</strong> and <strong class="source inline">Sad Cats</strong> group t<a id="_idTextAnchor391"/><a id="_idTextAnchor392"/>itles, each followed by the <span class="No-Break">relevant cats.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor393"/>Exercise 6.04 – adding titles to RecyclerView</h2>
			<p>We now want to be able to present<a id="_idIndexMarker572"/> our secret cat agents in two groups – active agents<a id="_idIndexMarker573"/> that are available for us to deploy to the field and sleeper agents that cannot currently be deployed. We will do that by adding a title above the active agents and another above the <span class="No-Break">sleeper agents:</span></p>
			<ol>
				<li>Under <strong class="source inline">com.example.myrecyclerviewapp.model</strong>, create a new Kotlin file <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">ListItemUiModel</strong></span><span class="No-Break">.</span></li>
				<li>Add the following to the <strong class="source inline">ListItemUiModel.kt</strong> file, defining our two data types – titles <span class="No-Break">and cats:</span><pre class="source code">
sealed class ListItemUiModel {
    data class Title(val title: String) :
        ListItemUiModel()
    data class Cat(val cat: CatUiModel) :
        ListItemUiModel()
}</pre></li>
				<li>Create a new Kotlin file in <strong class="source inline">com.example.myrecyclerviewapp</strong> <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">ListItem</strong></span><strong class="source inline">
ViewHolder</strong>. This will<a id="_idIndexMarker574"/> be our base<a id="_idIndexMarker575"/> <span class="No-Break">view holder.</span></li>
				<li>Populate the <strong class="source inline">ListItemViewHolder.kt</strong> file with <span class="No-Break">the following:</span><pre class="source code">
abstract class ListItemViewHolder(containerView: View
) : RecyclerView.ViewHolder(containerView) {
    abstract fun bindData(listItem: ListItemUiModel)
}</pre></li>
				<li>Open the <span class="No-Break"><strong class="source inline">CatViewHolder.kt</strong></span><span class="No-Break"> file.</span></li>
				<li>Make <strong class="source inline">CatViewHolder</strong> <span class="No-Break">extend </span><span class="No-Break"><strong class="source inline">ListItemViewHolder</strong></span><span class="No-Break">:</span><pre class="source code">
class CatViewHolder(...) :
    ListItemViewHolder(containerView) {</pre></li>
				<li>Replace the <strong class="source inline">bindData(CatUiModel)</strong> parameter with <strong class="source inline">ListItemUiModel</strong> and make it override the <strong class="source inline">ListItemViewHolder</strong> <span class="No-Break">abstract function:</span><pre class="source code">
override fun bindData(listItem: ListItemUiModel)</pre></li>
				<li>Add the following two lines to the top of the <strong class="source inline">bindData(ListItemUiModel)</strong> function to enforce casting <strong class="source inline">ListItemUiModel</strong> to <strong class="source inline">ListItemUiModel.Cat</strong> and to fetch the cat data <span class="No-Break">from it:</span><pre class="source code">
require(listItem is ListItemUiModel.Cat)
    { "Expected ListItemUiModel.Cat" }
val cat = listItem.cat</pre></li>
			</ol>
			<p>Leave the rest of the <span class="No-Break">file untouched.</span></p>
			<ol>
				<li value="9">Create a new layout file. Name your <span class="No-Break">layout </span><span class="No-Break"><strong class="source inline">item_title</strong></span><span class="No-Break">.</span></li>
				<li>Replace the default content<a id="_idIndexMarker576"/> of the newly created <strong class="source inline">item_title.xml</strong> file with <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker577"/></span><span class="No-Break"> following:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;TextView
  xmlns:android=
    "http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:id="@+id/item_title_title"
  android:layout_width="match_parent"
  android:layout_height="wrap_content"
  android:padding="8dp"
  android:textSize="16sp"
  android:textStyle="bold"
  app:layout_constraintStart_toStartOf="parent"
  app:layout_constraintTop_toTopOf="parent"
  tools:text="Sleeper Agents" /&gt;</pre></li>
			</ol>
			<p>This new layout, containing only a <strong class="source inline">TextView</strong> with<a id="_idTextAnchor394"/> a 16 sp-sized bold font, will host <span class="No-Break">our titles:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B19411_06_010.jpg" alt="Figure 6.10 – A preview of the item_title.xml layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – A preview of the item_title.xml layout</p>
			<ol>
				<li value="11">Implement <strong class="source inline">TitleViewHolder</strong> in a new file<a id="_idIndexMarker578"/> with the same name<a id="_idIndexMarker579"/> <span class="No-Break">under </span><span class="No-Break"><strong class="source inline">com.example.myrecyclerviewapp</strong></span><span class="No-Break">:</span><pre class="source code">
class TitleViewHolder(
  containerView: View
) : ListItemViewHolder(containerView) {
  private val titleView: TextView by lazy {
    containerView.findViewById(R.id.item_title_title)
  }
  override fun bindData(listItem: ListItemUiModel) {
    require(listItem is ListItemUiModel.Title)
      { "Expected ListItemUiModel.Title" }
    titleView.text = listItem.title
  }
}</pre></li>
			</ol>
			<p>This is very similar to <strong class="source inline">CatViewHolder</strong>, but since we only set the text on <strong class="source inline">TextView</strong>, it is also <span class="No-Break">much simpler.</span></p>
			<ol>
				<li value="12">Now, to make things tidier, select <strong class="source inline">CatViewHolder</strong>, <strong class="source inline">ListItemViewHolder</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">TitleViewHolder</strong></span><span class="No-Break">.</span></li>
				<li>Move all the files to a new namespace; right-click on one<a id="_idIndexMarker580"/> of the files, and<a id="_idIndexMarker581"/> then select <strong class="bold">Refactor</strong> | <strong class="bold">Move</strong> (or <span class="No-Break">press </span><span class="No-Break"><em class="italic">F6</em></span><span class="No-Break">).</span></li>
				<li>Append <strong class="source inline">/viewholder</strong> to the prefilled <strong class="bold">To directory</strong> field. Leave <strong class="bold">Search references</strong> and <strong class="bold">Update package directive (Kotlin files)</strong> checked and <strong class="bold">Open moved files in editor</strong> unchecked. <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
				<li>Open the <span class="No-Break"><strong class="source inline">CatsAdapter.kt</strong></span><span class="No-Break"> file.</span></li>
				<li>Now, rename <strong class="source inline">CatsAdapter</strong> <strong class="source inline">ListItemsAdapter</strong>. Right-click on the <strong class="source inline">CatsAdapter</strong> class name in the code window, and then select <strong class="bold">Refactor</strong> | <strong class="bold">Rename</strong> (or <em class="italic">Shift</em> + <span class="No-Break"><em class="italic">F6</em></span><span class="No-Break">).</span></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">It is important to maintain the naming of variables, functions, and classes to reflect their actual usage to avoid <span class="No-Break">future confusion.</span></p>
			<ol>
				<li value="17">When <strong class="source inline">CatsAdapter</strong> is highlighted, type <strong class="source inline">ListItemsAdapter</strong> and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
				<li>Change the adapter generic type <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">ListItemViewHolder</strong></span><span class="No-Break">:</span><pre class="source code">
class ListItemsAdapter(...) :
    RecyclerView.Adapter&lt;<strong class="bold">ListItemViewHolder</strong>&gt;() {</pre></li>
				<li>Update <strong class="source inline">listData</strong> and <strong class="source inline">setData(List&lt;CatUiModel&gt;)</strong> to handle <strong class="source inline">ListItemUiModel</strong> <span class="No-Break">instead:</span><pre class="source code">
private val <strong class="bold">listData</strong> = mutableListOf&lt;<strong class="bold">ListItemUiModel</strong>&gt;()
fun setData(new<strong class="bold">ListData</strong>: List&lt;<strong class="bold">ListItemUiModel</strong>&gt;) {
    <strong class="bold">listData</strong>.clear()
    <strong class="bold">listData</strong>.addAll(new<strong class="bold">ListData</strong>)
    notifyDataSetChanged()
}</pre></li>
				<li>Update <strong class="source inline">onBindViewHolder(CatViewHolder)</strong> to comply with the adapter <span class="No-Break">contract change:</span><pre class="source code">
override fun onBindViewHolder(holder:
    <strong class="bold">ListItemViewHolder</strong>, position: Int) {
    holder.bindData(<strong class="bold">listData</strong>[position])
}</pre></li>
				<li>At the top of the file, after the imports<a id="_idIndexMarker582"/> and before the class<a id="_idIndexMarker583"/> definition, add the view <span class="No-Break">type constants:</span><pre class="source code">
private const val VIEW_TYPE_TITLE = 0
private const val VIEW_TYPE_CAT = 1</pre></li>
				<li>Implement <strong class="source inline">getItemViewType(Int)</strong>, <span class="No-Break">like so:</span><pre class="source code">
override fun getItemViewType(position: Int) =
    when (listData[position]) {
        is ListItemUiModel.Title -&gt; VIEW_TYPE_TITLE
        is ListItemUiModel.Cat -&gt; VIEW_TYPE_CAT
    }</pre></li>
				<li>Lastly, change your <strong class="source inline">onCreateViewHolder(ViewGroup, Int)</strong> implementation, <span class="No-Break">as follows:</span><pre class="source code">
override fun onCreateViewHolder(parent: ViewGroup,
  viewType: Int) = when (viewType) {
  VIEW_TYPE_TITLE -&gt; {
    val view = layoutInflater.inflate(
      R.layout.item_title, parent, false)
    TitleViewHolder(view)
  }
  VIEW_TYPE_CAT -&gt; {
    val view = layoutInflater.inflate(
      R.layout.item_cat, parent, false)
    CatViewHolder(
      view,
      imageLoader,
      object : CatViewHolder.OnClickListener {
        override fun onClick(cat: CatUiModel) =
          onClickListener.onItemClick(catData)
      })
  }
  else -&gt; throw IllegalArgumentException("Unknown view type requested: $viewType")
}</pre></li>
				<li>Update <strong class="source inline">MainActivity</strong> to populate the adapter<a id="_idIndexMarker584"/> with appropriate data, replacing<a id="_idIndexMarker585"/> the previous <strong class="source inline">catsAdapter.setData(List&lt;CatUiModel&gt;)</strong> call (note that the following code has been truncated for space; refer to the link after the code block to access the full code that you need <span class="No-Break">to add):</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">MainActivity.kt</p>
			<pre class="source code">
listItemsAdapter.setData(
  listOf(
      ListItemUiModel.Title("Sleeper Agents"),
      ListItemUiModel.Cat(
        CatUiModel(Gender.Male,
          CatBreed.ExoticShorthair, "Garvey",
          "Garvey is as a lazy, fat, and cynical orange 
          cat.",
          "https://cdn2.thecatapi.com/images/FZpeiLi4n.jpg"
        )
      ),
      ListItemUiModel.Cat(
        CatUiModel(Gender.Unknown,
          CatBreed.AmericanCurl, "Curious George",
          "Award winning investigator",
          "https://cdn2.thecatapi.com/images/vJB8rwfdX.
          jpg"
        )
      ),
      ListItemUiModel.Title("Active Agents"),</pre>
			<p>The complete code<a id="_idIndexMarker586"/> for this step<a id="_idIndexMarker587"/> can be found <span class="No-Break">at </span><a href="http://packt.live/3icCrSt"><span class="No-Break">http://packt.live/3icCrSt</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="25">Since <strong class="source inline">catsAdapter</strong> is no longer holding <strong class="source inline">CatsAdapter</strong> but <strong class="source inline">ListItemsAdapter</strong>, rename it accordingly. Name <span class="No-Break">it </span><span class="No-Break"><strong class="source inline">listItemsAdapter</strong></span><span class="No-Break">.</span></li>
				<li>Run the<a id="_idTextAnchor395"/> app. You should see something similar to <span class="No-Break">the following:</span></li>
			</ol>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B19411_06_011.jpg" alt="Figure 6.11 – RecyclerView with the Sleeper Agents and Active Agents header views"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – RecyclerView with the Sleeper Agents and Active Agents header views</p>
			<p>As you can see, we now have titles<a id="_idIndexMarker588"/> above our two agent groups. Unlike the <strong class="bold">Our Agents</strong> title, these titles<a id="_idIndexMarker589"/> will scroll with our content. Next, we will <a id="_idTextAnchor396"/><a id="_idTextAnchor397"/>learn how to swipe an item to remove it <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor398"/>Swiping to remove Items</h1>
			<p>In the previous sections, we learned<a id="_idIndexMarker590"/> how to present different<a id="_idIndexMarker591"/> view types. However, up until now, we have worked with a fixed list of items. What if you want to be able to remove items from the list? There are a few common mechanisms to achieve that – fixed <strong class="bold">delete</strong> buttons on each item, swiping to delete, and long-clicking to select and then a tapping a <strong class="bold">delete</strong> button, to name a few. In this section, we will focus on the <em class="italic">swiping to </em><span class="No-Break"><em class="italic">delete</em></span><span class="No-Break"> approach.</span></p>
			<p>Let’s start by adding the deletion functionality to our adapter. To tell the adapter to remove an item, we need to indicate which item we want to remove. The simplest way to achieve this is by providing the position of the item. In our implementation, this will directly correlate to the position of the item in our <strong class="source inline">listData</strong> list. So, our <strong class="source inline">removeItem(Int)</strong> function should look <span class="No-Break">like this:</span></p>
			<pre class="source code">
fun removeItem(position: Int) {
    listData.removeAt(position)
    notifyItemRemoved(position)
}</pre>
			<p class="callout heading">Note</p>
			<p class="callout">Just like when setting data, we need to notify <strong class="source inline">RecyclerView</strong> that the dataset has changed – in this case, an item <span class="No-Break">was removed.</span></p>
			<p>Next, we need to define swipe gesture<a id="_idIndexMarker592"/> detection. This is done<a id="_idIndexMarker593"/> by utilizing <strong class="source inline">ItemTouchHelper</strong>, which handles certain touch events, namely dragging and swiping, by reporting them to us via a callback. We handle these callbacks by implementing <strong class="source inline">ItemTouchHelper.Callback</strong>. Also, <strong class="source inline">RecyclerView</strong> provides <strong class="source inline">ItemTouchHelper.SimpleCallback</strong>, which takes away the writing of a lot of <span class="No-Break">boilerplate code.</span></p>
			<p>We want to respond to swipe gestures but ignore move gestures. More specifically, we want to respond to swipes to the right. Moving is used to reorder items, which is beyond the scope of this chapter. So, our implementation of <strong class="source inline">SwipToDeleteCallback</strong> will look <span class="No-Break">as follows:</span></p>
			<pre class="source code">
inner class SwipeToDeleteCallback :
  ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.RIGHT) {
  override fun onMove(
    recyclerView: RecyclerView,
    viewHolder: RecyclerView.ViewHolder,
    target: RecyclerView.ViewHolder
  ): Boolean = false
  override fun getMovementFlags(
    recyclerView: RecyclerView,
    viewHolder: RecyclerView.ViewHolder
  ) = if (viewHolder is CatViewHolder) {
    makeMovementFlags(
      ItemTouchHelper.ACTION_STATE_IDLE,
      ItemTouchHelper.RIGHT
    ) or makeMovementFlags(
      ItemTouchHelper.ACTION_STATE_SWIPE,
      ItemTouchHelper.RIGHT
    )
  } else { 0 }
  override fun onSwiped(viewHolder: RecyclerView.ViewHolder,
    direction: Int) {
    val position = viewHolder.adapterPosition
    removeItem(position)
  }
}</pre>
			<p>Because our implementation is tightly<a id="_idIndexMarker594"/> coupled to our adapter<a id="_idIndexMarker595"/> and its view types, we can comfortably define it as an inner class. The benefit we gain is the ability to directly call methods on <span class="No-Break">the adapter.</span></p>
			<p>As you can see, we return <strong class="source inline">false</strong> from the <strong class="source inline">onMove(RecyclerView, ViewHolder, ViewHolder)</strong> function. This means we ignore <span class="No-Break">move events.</span></p>
			<p>Next, we need to tell <strong class="source inline">ItemTouchHelper</strong> which items can be swiped. We achieve this by overriding <strong class="source inline">getMovementFlags(RecyclerView, ViewHolder)</strong>. This function is called when a user is about to start a drag or swipe gesture. <strong class="source inline">ItemTouchHelper</strong> expects us to return the valid gestures for the provided <span class="No-Break">view holder.</span></p>
			<p>We check the <strong class="source inline">ViewHolder</strong> class, and if it is <strong class="source inline">CatViewHolder</strong>, we want to allow swiping; otherwise, we do not. We use <strong class="source inline">makeMovementFlags(Int, Int)</strong>, which is a helper function used to construct flags in a way that <strong class="source inline">ItemTouchHelper</strong> can <span class="No-Break">decipher them.</span></p>
			<p>Note that we define rules for <strong class="source inline">ACTION_STATE_IDLE</strong>, which is the starting<a id="_idIndexMarker596"/> state of a gesture, thus allowing a gesture to start from the left<a id="_idIndexMarker597"/> or the right. We then combine it (using <strong class="source inline">or</strong>) with the <strong class="source inline">ACTION_STATE_SWIPE</strong> flags, allowing the ongoing gesture to swipe left or right. Returning <strong class="source inline">0</strong> means neither swiping nor moving will occur for the provided <span class="No-Break">view holder.</span></p>
			<p>Once a swipe action is completed, <strong class="source inline">onSwiped(ViewHolder, Int)</strong> is called. We then obtain the position from the passed-in view holder by calling <strong class="source inline">adapterPosition</strong>. Now, <strong class="source inline">adapterPosition</strong> is important because it is the only reliable way to obtain the real position of the item presented by the <span class="No-Break">view holder.</span></p>
			<p>With the correct position, we can remove the item by calling <strong class="source inline">removeItem(Int)</strong> in <span class="No-Break">the adapter.</span></p>
			<p>To expose our newly created <strong class="source inline">SwipeToDeleteCallback</strong> implementation, we define a read-only variable within our adapter named <strong class="source inline">swipeToDeleteCallback</strong>, and set it to a new instance <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">SwipeToDeleteCallback</strong></span><span class="No-Break">.</span></p>
			<p>Finally, to plug our <strong class="source inline">callback</strong> mechanism to <strong class="source inline">RecyclerView</strong>, we need to construct a new <strong class="source inline">ItemTouchHelper</strong> and attach it to our <strong class="source inline">RecyclerView</strong>. We should do this when setting up our <strong class="source inline">RecyclerView</strong>, which we do in the <strong class="source inline">onCreate(Bundle?)</strong> function of our main activity. This is how the creation and <span class="No-Break">attaching looks:</span></p>
			<pre class="source code">
val itemTouchHelper =
  ItemTouchHelper(listItemsAdapter.swipeToDeleteCallback)
itemTouchHelper.attachToRecyclerView(recyclerView)</pre>
			<p>We can now swipe items to remove them from the list. Note how our titles cannot be swiped, just as <span class="No-Break">we intended.</span></p>
			<p>You may have noticed a small glitch – the last item is cut off as it animates upward. This is happening because <strong class="source inline">RecyclerView</strong> shrinks to accommodate the new (smaller) number of items before the animation starts. A quick fix to this would be to fix the height of our<a id="_idTextAnchor399"/><a id="_idTextAnchor400"/> <strong class="source inline">RecyclerView</strong> by confining its bottom<a id="_idIndexMarker598"/> to the bottom<a id="_idIndexMarker599"/> of <span class="No-Break">its parent.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor401"/>Exercise 6.05 – adding swipe to delete functionality</h2>
			<p>We previously added <strong class="source inline">RecyclerView</strong> to our app and then added<a id="_idIndexMarker600"/> items of different types to it. We will now allow users to delete some items (we want to let the users remove secret cat agents but not titles) by swiping them left <span class="No-Break">or right:</span></p>
			<ol>
				<li>To add item removal functionality to our adapter, add the following function to <strong class="source inline">ListItemsAdapter</strong> right after the <span class="No-Break"><strong class="source inline">setData(List&lt;ListItemUiModel&gt;)</strong></span><span class="No-Break"> function:</span><pre class="source code">
fun removeItem(position: Int) {
    listData.removeAt(position)
    notifyItemRemoved(position)
}</pre></li>
				<li>Next, right before the closing curly bracket of your <strong class="source inline">ListItemsAdapter</strong> class, add the following <strong class="source inline">callback</strong> implementation to handle the user swiping a cat agent left <span class="No-Break">or right:</span><pre class="source code">
inner class SwipeToDeleteCallback :
  ItemTouchHelper.SimpleCallback(0,
  ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT) {
  override fun onMove(
    recyclerView: RecyclerView,
    viewHolder: RecyclerView.ViewHolder,
    target: RecyclerView.ViewHolder
  ): Boolean = false
    override fun getMovementFlags(
      recyclerView: RecyclerView,
    viewHolder: RecyclerView.ViewHolder
  ) = if (viewHolder is CatViewHolder) {
    makeMovementFlags(
      ItemTouchHelper.ACTION_STATE_IDLE,
      ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT
    ) or makeMovementFlags(
      ItemTouchHelper.ACTION_STATE_SWIPE,
      ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT
    )
  } else { 0 }
  override fun onSwiped(viewHolder:
    RecyclerView.ViewHolder, direction: Int) {
    val position = viewHolder.adapterPosition
    removeItem(position)
  }
}</pre></li>
			</ol>
			<p>We have implemented an <strong class="source inline">ItemTouchHelper.SimpleCallback</strong> instance, passing in the directions<a id="_idIndexMarker601"/> we were interested in – <strong class="source inline">LEFT</strong> and <strong class="source inline">RIGHT</strong>. Joining the values is achieved by using the <strong class="source inline">or</strong> <span class="No-Break">Boolean operator.</span></p>
			<p>We have overridden the <strong class="source inline">getMovementFlags</strong> function to make sure we have only handled swiping on a cat agent view and not on a title. Creating flags for both <strong class="source inline">ItemTouchHelper.ACTION_STATE_SWIPE</strong> and <strong class="source inline">ItemTouchHelper.ACTION_STATE_IDLE</strong> allows us to intercept both swipe and release <span class="No-Break">events respectively.</span></p>
			<p>Once a swipe is completed (the user has lifted their finger from the screen), <strong class="source inline">onSwiped</strong> will be called, and in response, we remove the item at the position provided by the dragged <span class="No-Break">view holder.</span></p>
			<ol>
				<li value="3">At the top of your adapter, expose<a id="_idIndexMarker602"/> an instance of the <strong class="source inline">SwipeToDeleteCallback</strong> class you <span class="No-Break">just created:</span><pre class="source code">
class ListItemsAdapter(...) :
  RecyclerView.Adapter&lt;ListItemViewHolder&gt;() {
<strong class="bold">  val swipeToDeleteCallback = SwipeToDeleteCallback()</strong></pre></li>
				<li>Lastly, tie it all together by implementing <strong class="source inline">ItemViewHelper</strong> and attaching it to our <strong class="source inline">RecyclerView</strong>. Add the following code to the <strong class="source inline">onCreate(Bundle?)</strong> function of your <strong class="source inline">MainActivity</strong> file right after assigning the layout manager to <span class="No-Break">your adapter:</span><pre class="source code">
recyclerView.layoutManager = ...
val itemTouchHelper = ItemTouchHelper(listItemsAdapter
  .swipeToDeleteCallback)
itemTouchHelper.attachToRecyclerView(recyclerView)</pre></li>
				<li>To address the small visual glitch you would get when items are removed, scale <strong class="source inline">RecyclerView</strong> to fit the screen by updating the code in <strong class="source inline">activity_main.xml</strong>, as follows. The changes are in the <strong class="source inline">RecyclerView</strong> tag, right before the <span class="No-Break"><strong class="source inline">app:layout_constraintTop_toBottomOf</strong></span><span class="No-Break"> attribute:</span><pre class="source code">
android:layout_height="<strong class="bold">0dp</strong>"
<strong class="bold">app:layout_constraintBottom_toBottomOf="parent"</strong>
app:layout_constraintTop_toBottomOf="@+id/main_label" /&gt;</pre></li>
			</ol>
			<p>Note that there are two changes – we added a constraint at the bottom of the view to the bottom of the parent, and we set the layout height to <strong class="source inline">0dp</strong>. The latter change tells our<a id="_idTextAnchor402"/> app<a id="_idIndexMarker603"/> to calculate the height of <strong class="source inline">RecyclerView</strong> based on <span class="No-Break">its constraints:</span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B19411_06_012.jpg" alt="Figure 6.12 – RecyclerView taking the full height of the layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – RecyclerView taking the full height of the layout</p>
			<ol>
				<li value="6">Run your app. You should now be able to swipe secret cat agents left or right to remove them from the<a id="_idTextAnchor403"/> list. Note that <strong class="source inline">RecyclerView</strong> handles the collapsing animation <span class="No-Break">for us:</span></li>
			</ol>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B19411_06_013.jpg" alt="Figure 6.13 – A cat being swiped to the right"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – A cat being swiped to the right</p>
			<p>Note how even though titles are item views, they cannot be swiped. You have implemented a callback for swiping gestures that distinguishes between different item types and responds to a swipe by deleting<a id="_idIndexMarker604"/> the swiped item. Now, you know how to remove <a id="_idTextAnchor404"/><a id="_idTextAnchor405"/>items interactively. Next, you will learn how to add new items <span class="No-Break">as well.</span></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor406"/>Adding items interactively</h1>
			<p>We have just learned how to remove items<a id="_idIndexMarker605"/> interactively. What about adding new items? Let’s look <span class="No-Break">into it.</span></p>
			<p>Similar to the way we implemented the removal of items, we start by adding a function to <span class="No-Break">our adapter:</span></p>
			<pre class="source code">
fun addItem(position: Int, item: ListItemUiModel) {
    listData.add(position, item)
    notifyItemInserted(position)
}</pre>
			<p>Note that the implementation is very similar to the <strong class="source inline">removeItem(Int)</strong> function we implemented earlier. This time, we also receive an item to add and a position to add it to. We then add it to our <strong class="source inline">listData</strong> list and notify <strong class="source inline">RecyclerView</strong> that we added an item in the <span class="No-Break">requested position.</span></p>
			<p>To trigger a call to <strong class="source inline">addItem(Int, ListItemUiModel)</strong>, we can add a button to our main activity layout. This button can be <span class="No-Break">as follows:</span></p>
			<pre class="source code">
&lt;Button
    android:id="@+id/main_add_item_button"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Add A Cat"
    app:layout_<a id="_idTextAnchor407"/>constraintBottom_toBottomOf="parent" /&gt;</pre>
			<p>The app will now look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B19411_06_014.jpg" alt="Figure 6.14 – The main layout with a button to add a cat"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – The main layout with a button to add a cat</p>
			<p>Don’t forget to update your <strong class="source inline">RecyclerView</strong> so that its bottom will be constrained to the top of this button. Otherwise, the button and <strong class="source inline">RecyclerView</strong> <span class="No-Break">will overlap.</span></p>
			<p>In a production app, you could add<a id="_idIndexMarker606"/> a rationale about what a new item would be. For example, you could have a form for a user to fill in different details. For the sake of simplicity, in our example, we will always add the same dummy item – an anonymous female secret <span class="No-Break">cat agent.</span></p>
			<p>To add the item, we set <strong class="source inline">OnClickListener</strong> on <span class="No-Break">our button:</span></p>
			<pre class="source code">
addItemButton.setOnClickListener {
  listItemsAdapter.addItem(1, ListItemUiModel.Cat(
    CatUiModel(Gender.Female, CatBreed.BalineseJavanese,
      "Anonymous", "Unknown",
      "https://cdn2.thecatapi.com/images/zJkeHza2K.jpg"
    ))
  )
}</pre>
			<p>And that is it. We add the item at position <strong class="source inline">1</strong> so that it is added right below our first title, which is the item at position <strong class="source inline">0</strong>. In a production app, you could have logic to determine the correct place to insert an item. It could be below the relevant title or always be added at the top, bottom, or in the correct place to preserve some <span class="No-Break">existing order.</span></p>
			<p>We can now run the app. We will now have<a id="_idIndexMarker607"/> a new <strong class="bold">Add a Cat</strong> button. Every time we click the button, an anonymous secret cat agent will be added to <strong class="source inline">RecyclerView</strong>. The newly added cats ca<a id="_idTextAnchor408"/><a id="_idTextAnchor409"/>n be swiped away to be removed, just like the hardcoded cats <span class="No-Break">before them.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor410"/>Exercise 6.06 – implementing an Add A Cat button</h2>
			<p>Having implemented a mechanism<a id="_idIndexMarker608"/> to remove items, it is time we implemented<a id="_idIndexMarker609"/> a mechanism to <span class="No-Break">add items:</span></p>
			<ol>
				<li>Add a function to <strong class="source inline">ListItemsAdapter</strong> to support adding items. Add it below the <span class="No-Break"><strong class="source inline">removeItem(Int)</strong></span><span class="No-Break"> function:</span><pre class="source code">
fun addItem(position: Int, item: ListItemUiModel) {
    listData.add(position, item)
    notifyItemInserted(position)
}</pre></li>
				<li>Add a button to <strong class="source inline">activity_main.xml</strong>, right after the <span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break"> tag:</span><pre class="source code">
&lt;Button
    android:id="@+id/main_add_item_button"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Add A Cat"
    app:layout_constraintBottom_toBottomOf="parent" /&gt;</pre></li>
				<li>Note that <strong class="source inline">android:text="Add A Cat"</strong> is highlighted. If you hover your mouse over it, you will see that this is because of the hardcoded string. Click on the <strong class="bold">Add</strong> word to place the editor cursor <span class="No-Break">over it.</span></li>
				<li>Press <em class="italic">Option</em> + <em class="italic">Enter</em> (iOS) or <em class="italic">Alt</em> + <em class="italic">Enter</em> (Windows) to show the context menu, and then press <em class="italic">Enter</em> again to show the <strong class="bold">Extract </strong><span class="No-Break"><strong class="bold">Resource</strong></span><span class="No-Break"> dialog.</span></li>
				<li>Name the resource <strong class="source inline">add_button_label</strong>. <span class="No-Break">Press </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
				<li>To change the bottom constraint on <strong class="source inline">RecyclerView</strong> so that the button and <strong class="source inline">RecyclerView</strong> do not overlap, within your <strong class="source inline">RecyclerView</strong> tag, locate <span class="No-Break">the following:</span><pre class="source code">
    app:layout_constraintBottom_toBottomOf="parent"</pre></li>
			</ol>
			<p>Replace it with the following line <span class="No-Break">of code:</span></p>
			<pre class="source code">
app:layout_constraintBottom_to<strong class="bold">Top</strong>Of="<strong class="bold">@+id/main_add_item_button</strong>"</pre>
			<ol>
				<li value="7">Add a lazy field, holding a reference to the button at the top of the class, right after the definition <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">recyclerView</strong></span><span class="No-Break">:</span><pre class="source code">
private val addItemButton: View by lazy {
    findViewById(R.id.main_add_item_button) }</pre></li>
			</ol>
			<p>Note that <strong class="source inline">addItemButton</strong> is defined as a view. This is because, in our code, we don’t need to know<a id="_idIndexMarker610"/> the type of view to add a click<a id="_idIndexMarker611"/> listener to it. Choosing the more abstract type allows us to later change the type of view in the layout without having to modify <span class="No-Break">this code.</span></p>
			<ol>
				<li value="8">Lastly, update <strong class="source inline">MainActivity</strong> to handle the click. Find the line that says <span class="No-Break">the following:</span><pre class="source code">
itemTouchHelper.attachToRecyclerView(recyclerView)</pre></li>
			</ol>
			<p>Right after it, add <span class="No-Break">the following:</span></p>
			<pre class="source code">
addItemButton.setOnClickListener {
    listItemsAdapter.addItem(1,
        ListItemUiModel.Cat(CatUiModel(
            Gender.Female, CatBreed.BalineseJavanese,
            "Anonymous", "Unknown",
            "https://cdn2.thecatapi.com/images/zJkeHza2K.jpg"
        ))
    )
}</pre>
			<p>This will add a new item to <strong class="source inline">RecyclerView</strong> every time the button <span class="No-Break">is <a id="_idTextAnchor411"/>clicked.</span></p>
			<ol>
				<li value="9">Run the app. You should<a id="_idIndexMarker612"/> see a new button at the bottom<a id="_idIndexMarker613"/> of <span class="No-Break">your app:</span></li>
			</ol>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B19411_06_015.jpg" alt="Figure 6.15 – An anonymous cat is added with the click of a button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – An anonymous cat is added with the click of a button</p>
			<ol>
				<li value="10">Try clicking it a few times. Every time you click it, a new, anonymous secret cat agent is added to your <strong class="source inline">RecyclerView</strong>. You can swipe away the newly added cats, just like you could with the <span class="No-Break">hardcoded ones.</span></li>
			</ol>
			<p>In this exercise, you added new items to <strong class="source inline">RecyclerView</strong> in response to user interaction. You now know how to change the contents of <strong class="source inline">RecyclerView</strong> at runtime. It is useful to know how to update lists at runtime because, quite often, the data you are presenting to your users changes<a id="_idIndexMarker614"/> while the app<a id="_idTextAnchor412"/> is running, and <a id="_idTextAnchor413"/>you want<a id="_idIndexMarker615"/> to present your users with a fresh, <span class="No-Break">up-to-date state.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor414"/>Activity 6.01 – managing a list of Items</h2>
			<p>Imagine you want to develop<a id="_idIndexMarker616"/> a recipe management app. Your app would support sweet and savory recipes. Users of your app could add new sweet or savory recipes, scroll through the list of added recipes – grouped by flavor (sweet or savory) – click a recipe to get information about it, and finally, delete recipes by swiping <span class="No-Break">them aside.</span></p>
			<p>The aim of this activity is to create an app with <strong class="source inline">RecyclerView</strong> that lists the title of recipes, grouped by flavor. <strong class="source inline">RecyclerView</strong> will support user interaction. Each recipe will have a title, a description, and a flavor. Interactions will include clicks <span class="No-Break">and swipes.</span></p>
			<p>A click will present a user with a dialog showing the description of the recipe. A swipe will remove the swiped recipe from the app. Finally, with two <strong class="source inline">EditText</strong> fields (see <a href="B19411_03.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Developing the UI with Fragments</em>) and two buttons, a user can add a new sweet or savory recipe respectively, with the title and description set to the values set in the <span class="No-Break"><strong class="source inline">EditText</strong></span><span class="No-Break"> fields.</span></p>
			<p>The steps to complete this are <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Create a new empty <span class="No-Break">activity app.</span></li>
				<li>Add <strong class="source inline">RecyclerView</strong> support to the app’s <span class="No-Break"><strong class="source inline">build.gradle</strong></span><span class="No-Break"> file.</span></li>
				<li>Add <strong class="source inline">RecyclerView</strong>, two <strong class="source inline">EditText<a id="_idTextAnchor415"/></strong> fields, and two buttons to the main layout. It should look something <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B19411_06_016.jpg" alt="Figure 6.16 – The layout with RecyclerView, two EditText fields, and two buttons"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – The layout with RecyclerView, two EditText fields, and two buttons</p>
			<ol>
				<li value="4">Add models for the flavor<a id="_idIndexMarker617"/> titles and recipes, and an enum <span class="No-Break">for flavor.</span></li>
				<li>Add a layout for the <span class="No-Break">flavor titles.</span></li>
				<li>Add a layout for the <span class="No-Break">recipe titles.</span></li>
				<li>Add view holders for the flavor titles and recipe titles, as well as <span class="No-Break">an adapter.</span></li>
				<li>Add click listeners to show a dialog with <span class="No-Break">recipe descriptions.</span></li>
				<li>Update <strong class="source inline">MainActivity</strong> to construct the new adapter, and hook up the buttons to add new savory and sweet recipes. Make sure the form is cleared after a recipe <span class="No-Break">is<a id="_idTextAnchor416"/> added.</span></li>
				<li>Add a swipe helper to <span class="No-Break">remove items.</span></li>
			</ol>
			<p>The final<a id="_idIndexMarker618"/> output will be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B19411_06_017.jpg" alt="Figure 6.17 – The Recipe Book ﻿﻿app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – The Recipe Book <a id="_idTextAnchor417"/><a id="_idTextAnchor418"/>app</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found <span class="No-Break">at </span><a href="https://packt.link/By7eE"><span class="No-Break">https://packt.link/By7eE</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor419"/>Summary</h1>
			<p>In this chapter, we learned how to add <strong class="source inline">RecyclerView</strong> support to our project. We also learned how to add <strong class="source inline">RecyclerView</strong> to our layout and how to populate it with items. We went through adding different item types, which is particularly useful for titles. We covered interaction with <strong class="source inline">RecyclerView</strong>, responding to clicks on individual items and responding to <span class="No-Break">swipe gestures.</span></p>
			<p>Lastly, we learned how to dynamically add and remove items to and from <strong class="source inline">RecyclerView</strong>. The world of <strong class="source inline">RecyclerView</strong> is very rich, and we have only scratched the surface. Going further would be beyond the scope of this book. However, it is strongly recommended that you investigate it on your own so that you can have carousels, designed dividers, and fancier swipe effects in <span class="No-Break">your apps.</span></p>
			<p>You can start your exploration <span class="No-Break">here: </span><a href="https://packt.link/ClmMn"><span class="No-Break">https://packt.link/ClmMn</span></a><span class="No-Break">.</span></p>
			<p>In the next chapter, we will look into requesting special permissions on behalf of our app to enable it to perform certain tasks, such as accessing a user’s contacts list or microphone. We wil<a id="_idTextAnchor420"/>l also look into using Google’s Maps API and accessing a user’s <span class="No-Break">physical location.</span></p>
		</div>
	</body></html>