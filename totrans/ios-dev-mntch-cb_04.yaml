- en: Chapter 4. Data Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting and updating data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an already existing SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data with serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data with XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing XML data with LINQ to XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every application needs to have permanent data storage on the filesystem.
    In this chapter, we will discuss different ways of storing data. We will see how
    to create an SQLite database and manage data with it from within an iPhone application.
    Also, we will learn how to use an already existing database in a project.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite ([http://www.sqlite.org](http://www.sqlite.org) ) is a self-contained
    transactional database system. Each database is saved in a standalone file, and
    there is no database server. In iOS, SQLite support is native.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to serialize and save objects to the filesystem and how
    to use XML files with LINQ to XML.
  prefs: []
  type: TYPE_NORMAL
- en: Creating files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create files on the filesystem of iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **iPhone Single View Application** project in MonoDevelop. Name
    it `FileCreationApp`. Open the `FileCreationAppViewController.xib` file, and add
    a `UILabel` and a `UIButton` on its view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the following code in the `FileCreationAppViewController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As one can see from this code, we can use standard classes from the `System.IO`
    namespace, just like in desktop applications. The first thing we do is to set
    a path for the file we will save. We do this in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In iOS, we do not have access to the whole filesystem, not even inside the application
    bundle. An exception will occur if we try to write inside a folder we do not have
    access to. So, we use the static `Environment.GetFolderPath(SpecialFolder)` method
    and retrieve the `Personal` special folder, which corresponds to our application's
    `Documents` folder. Note the use of `Path.Combine(string, string)`, which combines
    two strings and returns a path. After that, we create a new instance of the `StreamWriter`
    class and write some text in the file with its `WriteLine(string)` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the text from the file, we create a new instance of the `StreamReader`
    class and read the text with its `ReadLine` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to write or read binary data, we can use the `FileStream` class.
  prefs: []
  type: TYPE_NORMAL
- en: Documents Folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application's `Documents` folder is relevant to the application alone. If
    the application is uninstalled from the device, its contents are also removed.
    We have both read and write access in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Storing data with serialization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create an SQLite database file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **iPhone Single View Application** in MonoDevelop, and name it
    `CreateSQLiteApp`. Add a `UILabel` and a `UIButton` on its view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a reference to the project to the assembly `Mono.Data.Sqlite` and the corresponding
    `using` directive on the namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following method in the `CreateSQLiteAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: iOS provides native support for SQLite databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access SQLite databases with Mono''s `Mono.Data.Sqlite` namespace, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `CreateSQLiteDatabase` method, we first check if the file already
    exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can continue with the creation of the database. We first create the
    file with the `SqliteConnection.CreateFile(string)` static method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We connect to the newly created file by initializing an `SqliteConnection`
    object and calling its `Open()` method. The connection string for an SQLite database
    is `Data Source =`, followed by the filename of the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a table in the database, an `SqliteCommand` object is initialized.
    We pass a standard SQL string to its `CommandText` property, and call the `ExecuteNonQuery()`
    method to execute the SQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Note the usage of a try-catch block. It is provided to display a message to
    the user if something goes wrong with the creation of the database.
  prefs: []
  type: TYPE_NORMAL
- en: SQL table creation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this task, we have created a simple table for our database, with the name
    `Customers`. It contains three fields. `FirstName` and `LastName` are of type
    `VARCHAR(20)`, while `ID` is of type `INTEGER` and is also the `PRIMARY KEY` of
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from using SQL commands for creating tables, we can create an SQLite database
    with various commercial or free GUI tools. A simple search on the Internet will
    yield various results.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Querying an SQLite database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inserting and updating data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using an already existing database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting and updating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to write data to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this task, we will extend the project `CreateSQLiteApp` that we created
    in the previous task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add two more buttons on the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `CreateSQLiteAppViewController` class, create two methods that will
    connect to the database file using the code from the previous task. The difference
    here lies in the usage of the `SqliteCommand` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To insert and update data in an SQLite table, we use the common `INSERT` and
    `UPDATE` statements respectively. The highlighted parts of the code indicate the
    usage of SQLite parameters. Both statements are executed on the database at the
    `sqlCom.ExecuteNonQuery()`; line. The `ExecuteNonQuery` has a return value of
    type `int` that indicates the number of rows in the table that were affected.
    So, if we called the method like the following in our example, we would get the
    output `1`, indicating that one row was affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we have used the project from the previous task, where we provided code
    for creating the database file, we should add the following code on the beginning
    of each of our methods that perform the data operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is to make sure that we will not have an exception if the user taps on
    the **insert** or **update** button while there is no database file.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite performance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although SQLite offers great performance and portability, it relies to a great
    extent on its host filesystem, regardless of which platform it is stored on. If
    you want to perform multiple concurrent `INSERT` or `UPDATE` statements, consider
    using an `SqliteTransaction`. Apart from the benefit in performance, by batching
    multiple statements together, a transaction provides a way of rolling back the
    operation if a problem occurs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating files*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an SQLite database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Querying an SQLite database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to retrieve data from an SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we will use the `CreateSQLiteApp` project. Upon completion of this
    task, the project will be a full SQLite management application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add another button on the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `CreateSQLiteAppViewController` class, add a method that will handle
    the query. The part that performs the query is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To perform a query on an SQLite database, we create a simple `SELECT` statement
    and assign it to the `CommandText` property of the `SqliteCommand` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The asterisk (*) after the `SELECT` word indicates that we want to retrieve
    all the fields of the table. The simplest way to execute the SQL query is by using
    the `SqliteDataReader` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SqliteCommand.ExecuteReader()` method performs the query on the table
    and creates an `SqliteDataReader` object. Now that we have our object, we first
    check if the table contains any rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the above returns `true`, we begin advancing through each row by passing
    the `SqliteDataReader.Read()` method in a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now retrieve each field''s value by passing the name of each field as
    an index on the `SqliteDataReader` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since the indexed `dbReader` variable returns an object of the type `System.Object`,
    we use the `Convert.ToString(object)` static method to convert it to a string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite database is not thread-safe. If we want to perform queries on a database
    while another thread might be executing `INSERT` or `UPDATE` statements, it would
    be better to provide some sort of synchronization mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Query performance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although devices running the iOS platform are performing better than some older
    desktop computers, their resources are still limited in comparison. When querying
    data from large databases, consider narrowing the results to the data that is
    needed at that particular time with the SQL `WHERE` statement. Also, if no sorting
    is required, avoid using `ORDER BY` statements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an SQLite database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inserting and updating data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using an already existing SQLite database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an already existing SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to include an already existing SQLite database
    file in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is always easier to create databases with some kind of frontend. In this
    task, we will see how to integrate an existing SQLite database with an iPhone
    project. Create a new **iPhone Single View Application** project, and name it
    `SqliteIntegrationApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a `UIButton` and a `UILabel` on the view in Interface Builder. Connect them
    with the appropriate outlets. Make sure the label is tall enough for six lines,
    and set its **# Lines** field in the **Inspector** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In MonoDevelop, right-click on the project in the **Solution** pad, and click
    **Add Files...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the dialog box that will be shown, navigate to the path where the database
    file resides and select it. The file will be added in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select **Build Action | Content**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following methods in the `SqliteIntegrationAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The functionality of the `QueryData` method is the same as the method that performs
    the query in the previous task. The main difference is that in this project, it
    will act as the button's TouchUpInside event handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a field of type `string` that will hold the database path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And, finally, in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application. Tap on the button, and watch the contents of
    the database being displayed in the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we have done here is a combination of various practices discussed in previous
    tasks. When we want to add various files in a project, it is important that we
    set their **Build Action** to **Content**. Any file that is marked as **Content**
    is being copied as-is in the application bundle. In this case, the file is an
    SQLite database, hence we will need write access to it at runtime. We need to
    copy it in the application''s **Documents** folder. This is what the `CopyDatabase()`
    method does, at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is important to check if the file already exists so that it will not be overwritten
    the next time the application is executed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you get an `SqliteException`, the first thing to check is if for some reason
    the database file was not copied to the correct folder.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating files*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an SQLite database*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data with serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss using .NET serialization to store C# objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **iPhone Single View Application** project in MonoDevelop. Name
    it `SerializationApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add two buttons and a label on the view in Interface Builder. Add the following
    using directives in the `SerializationAppViewController.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following methods in the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code can be found in the `SerializationApp` project.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Serialization with MonoTouch works the same as in desktop C# applications. The
    `CustomerData` class indicated in the highlighted code is a simple object that
    contains one integer and two string properties.
  prefs: []
  type: TYPE_NORMAL
- en: To serialize the object, we first initialize a `MemoryStream:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then use the `BinaryFormatter` class to serialize the object and store it
    into the stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the serialization, we reset the stream''s position to its beginning,
    and read the data from it into a byte array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To deserialize the object from the buffer, the process is similar, but in the
    reverse order. After the `MemoryStream` initialization, we reset the stream''s
    position to its beginning and use the `Deserialize` method of the `BinaryFormatter`.
    It returns an object of type `System.Object`, so we need to cast it to the type
    of our object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One important thing to remember when serializing objects with MonoTouch is
    to decorate the objects that will be serialized with the `PreserveAttribute`.
    This attribute instructs the linker to avoid stripping the object of unused members,
    keeping it intact. The `CustomerData` class in this task is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Serializable objects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a simple example to display the use of binary serialization in an iOS
    application. Objects can be customized for serialization by inheriting the `ISerializable`
    C# interface.
  prefs: []
  type: TYPE_NORMAL
- en: When creating an object that will be used for serialization, do not forget to
    mark it with the `SerializableAttribute`. An exception will occur when trying
    to serialize objects that are not marked with this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Storing data with XML*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"),Development Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Compiling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data with XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to store data with XML serialization.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a new **iPhone Single View Application** project in MonoDevelop, and
    name it `XMLDataApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a `UIButton` and a `UILabel` on the view. Add the class `CustomerData`
    from the previous task to the project. Add the following `using` directives in
    the `XMLDataAppViewController.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method in the `XMLDataAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete solution can be found in the `XMLDataApp` project.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we are using the `XmlSerializer` class to serialize an object
    to XML. The `StringBuilder` object will hold the XML data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the `XmlSerializer`, we use its `XmlSerializer(System.Type)`
    constructor, passing as a parameter the type of the object we want to serialize:
    `(typeof(CustomerData))`. We than call its `Serialize(XmlWriter, object)` method,
    which will perform the actual serialization and store the output XML to the `StringBuilder`,
    through the `XmlWriter` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When you compile and run the application, you will see the output XML in the
    label.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two main advantages in using XML to store data:'
  prefs: []
  type: TYPE_NORMAL
- en: The output is pure text, as opposed to binary serialization, which makes it
    human readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data can be transmitted or received to and from different types of applications,
    websites, and so on that are not necessarily written in C#.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deserialization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To deserialize our object from XML, we would use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Storing data with serialization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Managing XML data with LINQ to XML*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing XML data with LINQ to XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to manage XML data using **Language INtegrated
    Query (LINQ)** .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this task, we are going to use the project `XMLDataApp` from the previous
    task. Open it in MonoDevelop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add another `UIButton` on the view. Add a reference to the `System.Xml.Linq`
    assembly and the following `using` directive in the `XMLDataAppViewController.cs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following method in the `XMLDataAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: LINQ is very versatile and straightforward in querying XML data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do is create an `XDocument` from our XML data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, we create a query on its `Descendants()` method, which returns an
    `IEnumerable<XElement>` object. Each `XElement` object corresponds to an XML element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the information of each `XElement` returned, we construct our `CustomerData`
    object in the `select` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To retrieve the created object, we call the extension method `FirstOrDefault()`
    on the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The XML in this example contains only one object of the type `CustomerData`.
    If there were more, we could narrow down the results, providing a `where` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous types in LINQ
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In MonoTouch, we can also use C#'s powerful feature of anonymous types in queries,
    for example, `select new { ID = … }`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Storing data with serialization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
