<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-172"><em class="italic"><a id="_idTextAnchor178"/>Chapter 7</em>: Controlling the Data Flow</h1>&#13;
			<p>The previous chapter covered an important <strong class="bold">Kotlin</strong> concurrency primitive: <strong class="bold">coroutines</strong>. In this chapter, we'll discuss two other vital concurrent primitives in Kotlin: <strong class="bold">channels</strong> and <strong class="bold">flows</strong>. We'll also touch on <strong class="bold">higher-order functions</strong> for <strong class="bold">collections</strong>, as their API is very similar to that of channels and flows. </p>&#13;
			<p>The idea of making extensive use of small, reusable, and composable functions comes directly from the <strong class="bold">functional programming</strong> paradigm, which we discussed in the previous chapter. These functions allow us to write code in a manner that describes <em class="italic">what</em> we want to do instead of <em class="italic">how</em> we want to do it. </p>&#13;
			<p>In this chapter, we'll cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Reactive principles</li>&#13;
				<li>Higher-order functions for collections</li>&#13;
				<li>Concurrent data structures</li>&#13;
				<li>Sequences</li>&#13;
				<li>Channels</li>&#13;
				<li>Flows</li>&#13;
			</ul>&#13;
			<p>After reading this chapter, you'll be able to efficiently communicate between different coroutines and process your data with ease. </p>&#13;
			<h1 id="_idParaDest-173"><a id="_idTextAnchor179"/>Technical requirements</h1>&#13;
			<p>In addition to the technical requirements from the previous chapters, you will also need a <strong class="bold">Gradle</strong>-enabled Kotlin project to be able to add the required dependencies.</p>&#13;
			<p>You can find the source code used in this chapter on <strong class="bold">GitHub</strong> at the following location:</p>&#13;
			<p><a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07</a></p>&#13;
			<h1 id="_idParaDest-174"><a id="_idTextAnchor180"/>Reactive principles</h1>&#13;
			<p>We'll start <a id="_idIndexMarker499"/>this chapter with a brief detour into <strong class="bold">Reactive programming</strong>, as it forms the foundation of the <strong class="bold">data streaming</strong> concept.</p>&#13;
			<p>Reactive programming is a paradigm based on functional programming in which we model our logic as a set of operations in a data stream. The fundamental concepts of reactive programming are summarized nicely in <em class="italic">The Reactive Manifesto</em> (<a href="https://www.reactivemanifesto.org">https://www.reactivemanifesto.org</a>). </p>&#13;
			<p>According to this manifesto, reactive programs should be all of the following:</p>&#13;
			<ul>&#13;
				<li>Responsive</li>&#13;
				<li>Resilient</li>&#13;
				<li>Elastic</li>&#13;
				<li>Message-driven</li>&#13;
			</ul>&#13;
			<p>To understand these four principles, we'll use an example.</p>&#13;
			<p>Let's imagine you are calling your Internet Service Provider, since your internet is slow, for example. <em class="italic">Do you have this picture in your mind?</em> Let's start then.</p>&#13;
			<h2 id="_idParaDest-175"><a id="_idTextAnchor181"/>Responsive principle</h2>&#13;
			<p><em class="italic">How much time are you willing to spend waiting on the line?</em> That<a id="_idIndexMarker500"/> depends on the urgency <a id="_idIndexMarker501"/>of the situation and how much time you have. If you're in a hurry, you'll probably drop the call sooner rather than later because you don't know how much time you'll need to wait while listening to that horrible music. </p>&#13;
			<p>That's the system being <em class="italic">unresponsive</em> to you. This also happens with web systems. A request to a web server may get stuck in a queue when waiting for other requests to be processed.</p>&#13;
			<p>On the other hand, a responsive call center may tell you in a pleasant voice once in a while how many people are in the queue before you – or even how much time you'll have to wait. </p>&#13;
			<p>In both cases, the result is the same. You've wasted your time waiting on the line. But the second<a id="_idIndexMarker502"/> system was responsive to <a id="_idIndexMarker503"/>your needs, and you could make decisions based on that.</p>&#13;
			<h2 id="_idParaDest-176"><a id="_idTextAnchor182"/>Resilient principle</h2>&#13;
			<p>Let's <a id="_idIndexMarker504"/>move<a id="_idIndexMarker505"/> on to the <strong class="bold">resilient</strong> principle. Imagine you're waiting on the line for 10 minutes and then the line drops. That's the system not being resilient to failures.</p>&#13;
			<p>The Reactive Manifesto recommends several ways to achieve resiliency: </p>&#13;
			<ul>&#13;
				<li><strong class="bold">Delegation</strong>: You'll <a id="_idIndexMarker506"/>probably hear, "<em class="italic">Our current representative is unable to resolve your slow internet; we are redirecting you to someone else.</em>"</li>&#13;
				<li><strong class="bold">Replication</strong>: Then, you may hear, "<em class="italic">We are aware that many people are on the line; we are adding more representatives as we speak.</em>" This also relates to <em class="italic">elasticity</em>, which we'll cover in the next section.</li>&#13;
				<li><strong class="bold">Containment</strong> and <strong class="bold">isolation</strong>: Finally, the automatic voice tells you, "<em class="italic">If you don't want to wait, please leave your number and we'll get back to you.</em>" <em class="italic">Containment</em> means that you are now decoupled from the scalability problems the system is having (that is, the system not having enough representatives). In contrast, <em class="italic">isolation</em> means that even if the system has issues with a phone line not being reliable, you don't care.</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-177"><a id="_idTextAnchor183"/>Elastic principle</h2>&#13;
			<p>In the<a id="_idIndexMarker507"/> previous<a id="_idIndexMarker508"/> section, we discussed replication. To prevent failures, our call center always has at least three representatives on shift. Maybe all of them are answering calls, or perhaps they're just patiently waiting. </p>&#13;
			<p><em class="italic">What happens, though, if some rabid mole chews through the internet cable?</em> </p>&#13;
			<p>Suddenly, there is a surge of calls from disgruntled customers. </p>&#13;
			<p>If our call center has only three phones, there is not much we can do about this. But if we had some extra resources, we could bring more representatives in to handle the incident and calm our customers. And after the cable was finally fixed, we could let them go back to their business. That's the system being <em class="italic">elastic</em> in response to the workload. </p>&#13;
			<p><em class="italic">Elasticity</em> builds on <em class="italic">scalability</em>. For example, we could manage all of the incoming calls if each representative could work independently by having their own phone. If we had more representatives than phones, the number of phones would become a <em class="italic">bottleneck</em>, with <a id="_idIndexMarker509"/>some representatives unable to<a id="_idIndexMarker510"/> answer any calls.</p>&#13;
			<h2 id="_idParaDest-178"><a id="_idTextAnchor184"/>Message-driven principle</h2>&#13;
			<p>The <strong class="bold">message-driven</strong> principle <a id="_idIndexMarker511"/>is also<a id="_idIndexMarker512"/> referred to as <strong class="bold">asynchronous message passing</strong>. So, in<a id="_idIndexMarker513"/> the previous section, we saw that if you could leave a message for any representative to call back, it could make the system more resilient. </p>&#13;
			<p><em class="italic">So, what if all customers only leave messages?</em></p>&#13;
			<p>Then, each representative could <em class="italic">prioritize</em> those messages or <em class="italic">batch</em> them. For example, printing all of the billing receipts together instead of working through the messages in a random order. </p>&#13;
			<p>Using messages also allows applying backpressure. If a representative receives too many messages, they may collapse from stress. To avoid that, they may text you to say that you'll have to wait a bit longer to receive your answer. Again, we're also talking about <em class="italic">delegation</em> here, as all of these principles overlap.</p>&#13;
			<p>Messages are also <em class="italic">non-blocking</em>. After you leave the message, you don't sit there waiting for the representative's response. Instead, you usually go back to your regular tasks. The ability to perform other tasks while you wait is one of the cornerstones of <em class="italic">concurrency</em>.</p>&#13;
			<p>In this section, we learned about the four reactive principles. Reactive applications are responsive, resilient, elastic, and message-driven. In the following sections, we'll see how these principles are applied in Kotlin. We'll start with <em class="italic">collections</em>, or as they'd be referred to in reactive programming terms, <em class="italic">static data streams</em>.</p>&#13;
			<h1 id="_idParaDest-179"><a id="_idTextAnchor185"/>Higher-order functions on collections</h1>&#13;
			<p>We briefly <a id="_idIndexMarker514"/>touched on this topic in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, but before we can discuss streams, let's make sure that those of us who come from languages that don't have higher-order functions on collections know what they are, what they do, and what the benefits of using them are. </p>&#13;
			<p>We won't be able to cover all of the functions available on collections, but we'll cover the most widely used ones.</p>&#13;
			<h2 id="_idParaDest-180"><a id="_idTextAnchor186"/>Mapping elements</h2>&#13;
			<p>The <code>map()</code> function <a id="_idIndexMarker515"/>takes each <a id="_idIndexMarker516"/>element of a collection and returns a new element of a possibly different type. To understand this idea better, let's say we have a list of letters and we would like to output their ASCII values.</p>&#13;
			<p>First, let's implement it in an imperative way:</p>&#13;
			<pre>val letters = 'a'..'z'</pre>&#13;
			<pre>val ascii = mutableListOf&lt;Int&gt;()</pre>&#13;
			<pre>for (l in letters) {</pre>&#13;
			<pre>    ascii.add(l.toInt())</pre>&#13;
			<pre>}</pre>&#13;
			<p>Notice that even for such a trivial task, we had to write quite a lot of code. We also had to define our output list as mutable.</p>&#13;
			<p>Now, the same code using the <code>map()</code> function would look like this:</p>&#13;
			<pre>val result: List&lt;Int&gt; = ('a'..'z').map { it.toInt() }</pre>&#13;
			<p>Notice how much shorter the implementation is. We don't need to define a mutable list, nor do we need to write a <code>for-each</code> loop ourselves.</p>&#13;
			<h2 id="_idParaDest-181"><a id="_idTextAnchor187"/>Filtering elements</h2>&#13;
			<p>Another<a id="_idIndexMarker517"/> common task is filtering a <a id="_idIndexMarker518"/>collection. You know the drill – you iterate over it and only put values that fit your criteria in a new collection. For example, if given a range of numbers between <code>1</code> and <code>100</code>, we would like to return only those that are divisible by <code>3</code> or divisible by <code>5</code>.</p>&#13;
			<p>In the imperative way, this function might look something like this:</p>&#13;
			<pre>val numbers = 1..100</pre>&#13;
			<pre>val notFizzbuzz = mutableListOf&lt;Int&gt;()</pre>&#13;
			<pre>for (n in numbers) {</pre>&#13;
			<pre>    if (n % 3 == 0 || n % 5 == 0) {</pre>&#13;
			<pre>        notFizzbuzz.add(n)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>In its functional variant, we would use the <code>filter()</code> function:</p>&#13;
			<pre>val filtered: List&lt;Int&gt; = (1..100).filter { it % 3 == 0 || </pre>&#13;
			<pre>  it % 5 == 0 }</pre>&#13;
			<p>Again, notice how much more concise our code becomes. We only specify <em class="italic">what</em> needs to be done, filtering elements that match the criteria, and not <em class="italic">how</em> this should be done (for example, using an <code>if</code> statement).</p>&#13;
			<h2 id="_idParaDest-182"><a id="_idTextAnchor188"/>Finding elements</h2>&#13;
			<p>Finding the<a id="_idIndexMarker519"/> first<a id="_idIndexMarker520"/> element in a collection is another common task. If we were to write a function for finding a number that is divisible by both <code>3</code> and <code>5</code>, we could implement it like this:</p>&#13;
			<pre>fun findFizzbuzz(numbers: List&lt;Int&gt;): Int? {</pre>&#13;
			<pre>    for (n in numbers) {</pre>&#13;
			<pre>        if (n % 3 == 0 &amp;&amp; n % 5 == 0) {</pre>&#13;
			<pre>            return n</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    return null</pre>&#13;
			<pre>}</pre>&#13;
			<p>The same functionality can be achieved using the <code>find</code> function:</p>&#13;
			<pre>val found: Int? = (1..100).find { it % 3 == 0 &amp;&amp; it % 5 ==   0 }</pre>&#13;
			<p>In a similar way to the preceding imperative function, the <code>find</code> function returns <code>null</code> if there is no element that meets our criteria.</p>&#13;
			<p>There's also <a id="_idIndexMarker521"/>an accompanying <code>findLast()</code> method, which<a id="_idIndexMarker522"/> does the same, but which starts with the last element of the collection.</p>&#13;
			<h2 id="_idParaDest-183"><a id="_idTextAnchor189"/>Executing code for each element</h2>&#13;
			<p>All previous <a id="_idIndexMarker523"/>families of functions had one common characteristic: they all resulted in a stream. But not all the higher-order functions return streams. Some will return a single value, such as <code>Unit</code> or, for example, a <a id="_idIndexMarker524"/>number. Those functions are called <strong class="bold">terminator functions</strong>.</p>&#13;
			<p>In this section, we'll deal with the first terminator function. Terminator functions return something else rather than a new collection, so you can't chain the result of this call to other calls. Therefore, they <em class="italic">terminate</em> the chain.</p>&#13;
			<p>In the case of <code>forEach()</code>, it returns the result of the <code>Unit</code> type. The <code>Unit</code> type is akin to <code>void</code> in <code>forEach()</code> function is like the plain old <code>for</code> loop:</p>&#13;
			<pre>val numbers = (0..5)</pre>&#13;
			<pre>numbers.map { it * it}          // Can continue</pre>&#13;
			<pre>       .filter { it &lt; 20 }      // Can continue</pre>&#13;
			<pre>       .forEach { println(it) } // Cannot continue</pre>&#13;
			<p>Note that <code>forEach()</code> has some minor performance impacts compared to the traditional <code>for</code> loop. </p>&#13;
			<p>There's also <code>forEachIndexed()</code>, which provides an index in the collection alongside the actual value:</p>&#13;
			<pre>numbers.map { it * it }</pre>&#13;
			<pre>        .forEachIndexed { index, value -&gt;</pre>&#13;
			<pre>    print("$index:$value, ")</pre>&#13;
			<pre>}</pre>&#13;
			<p>The output for the preceding code will be as follows:</p>&#13;
			<pre>&gt; 0:1, 1:4, 2:9, 3:16, 4:25, </pre>&#13;
			<p>Since Kotlin 1.1, there's also the <code>onEach()</code> function, which is a bit more useful because it returns the collection again:</p>&#13;
			<pre>numbers.map { it * it}         </pre>&#13;
			<pre>       .filter { it &lt; 20 }     </pre>&#13;
			<pre>       .sortedDescending()     </pre>&#13;
			<pre>       .onEach { println(it) } // Can continue now</pre>&#13;
			<pre>       .filter { it &gt; 5 }</pre>&#13;
			<p>As you can<a id="_idIndexMarker525"/> see, this function is not terminating. </p>&#13;
			<h2 id="_idParaDest-184"><a id="_idTextAnchor190"/>Summing up elements</h2>&#13;
			<p>Much<a id="_idIndexMarker526"/> like <code>forEach()</code>, <code>reduce()</code> is a terminating function. But instead of terminating with <code>Unit</code>, which is not very useful, it terminates with a single value of the same type as the collection it operates on. </p>&#13;
			<p>To see how <code>reduce()</code> works in practice, let's summarize all numbers between <code>1</code> and <code>100</code>:</p>&#13;
			<pre>val numbers = 1..100</pre>&#13;
			<pre>var sum = 0</pre>&#13;
			<pre>for (n in numbers) {</pre>&#13;
			<pre>    sum += n</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, let's write the same code using <code>reduce</code>:</p>&#13;
			<pre>val reduced: Int = (1..100).reduce { sum, n -&gt; sum + n }</pre>&#13;
			<p>Note that here it lets us avoid declaring a mutable variable for storing the sum of the elements. Unlike previous higher-order functions we've seen, <code>reduce()</code> receives not one but two arguments. The first argument is the accumulator. In the imperative example, it's the <code>sum</code> variable. The second argument is the next element. We used the same names for <a id="_idIndexMarker527"/>the arguments, so it should be relatively easy to compare both implementations. </p>&#13;
			<h2 id="_idParaDest-185"><a id="_idTextAnchor191"/>Getting rid of nesting</h2>&#13;
			<p>Sometimes <a id="_idIndexMarker528"/>when working with collections, we may end up with a <em class="italic">collection of collections</em>. For example, consider the following code:</p>&#13;
			<pre>val listOfLists: List&lt;List&lt;Int&gt;&gt; = listOf(listOf(1, 2), listOf(3, 4, 5), listOf(6, 7, 8))</pre>&#13;
			<p><em class="italic">But what if we wanted to turn this collection into a single list containing all of the nested elements?</em></p>&#13;
			<p>Then, the output would look like this:</p>&#13;
			<pre>&gt; [1, 2, 3, 4, 5, 6, 7, 8]</pre>&#13;
			<p>One option is to iterate our input and use the <code>addAll</code> method that the mutable collections have:</p>&#13;
			<pre>val flattened = mutableListOf&lt;Int&gt;()</pre>&#13;
			<pre>for (list in listOfLists) {</pre>&#13;
			<pre>    flattened.addAll(list)</pre>&#13;
			<pre>}</pre>&#13;
			<p>A better option is to use a <code>flatMap()</code> function, which will do the same:</p>&#13;
			<pre>val flattened: List&lt;Int&gt; = listOfLists.flatMap { it }</pre>&#13;
			<p>This concrete example could be simplified even further by using a <code>flatten()</code> function:</p>&#13;
			<pre>val flattened: List&lt;Int&gt; = listOfLists.flatten()</pre>&#13;
			<p>But the <code>flatMap()</code> function is usually more useful, as it allows you to apply other functions to each collection, in an <strong class="bold">Adapter</strong> like pattern.</p>&#13;
			<p>There are many other higher-order functions declared on collections, so we couldn't cover all of them in this short section. You must browse through the official documentation and learn about them. Nevertheless, the functions discussed previously should provide a solid ground for the next topic we'll cover. </p>&#13;
			<p>Now, when you're<a id="_idIndexMarker529"/> familiar with how to transform and iterate over the <em class="italic">static data streams</em>, let's see how we can apply the same operations to <em class="italic">dynamic data streams</em>. </p>&#13;
			<h1 id="_idParaDest-186"><a id="_idTextAnchor192"/>Exploring concurrent data structures</h1>&#13;
			<p>Now we're familiar <a id="_idIndexMarker530"/>with some of the most common higher-order functions on collections, let's combine this knowledge with what we learned in the previous chapter about concurrency primitives in Kotlin to discuss the <em class="italic">concurrent data structures</em> Kotlin provides.</p>&#13;
			<p>The two most essential concurrent data structures are <em class="italic">channels</em> and <em class="italic">flows</em>. However, before we can discuss them, we need to look at another data structure: <strong class="bold">sequences</strong>. While this data structure is not concurrent itself, it will provide us with a bridge into the concurrent world.</p>&#13;
			<h2 id="_idParaDest-187"><a id="_idTextAnchor193"/>Sequences</h2>&#13;
			<p>Higher-order <a id="_idIndexMarker531"/>functions on collections existed in many<a id="_idIndexMarker532"/> functional programming languages for a long time. But for Java developers, the higher-order functions for collections first appeared in Java 8 with the introduction of the <strong class="bold">Stream API</strong>.</p>&#13;
			<p>Despite providing developers with valuable functions such as <code>map()</code>, <code>filter()</code>, and some of the others we already discussed, there were two major drawbacks to the Stream API. First, in order to use these functions, you had to migrate to Java 8. And second, your collection had to be converted to something<a id="_idIndexMarker533"/> called a <strong class="bold">stream</strong>, which had all of the functions defined on it. If you want to return a collection again after mapping and filtering your stream, you can collect it back. </p>&#13;
			<p>There is also another significant difference between streams and collections. Unlike collections, streams can be infinite. Since Kotlin doesn't limit itself to only <strong class="bold">JVM</strong> and is also backward-compatible to Java 6, it needed to provide another solution for the possibility of infinite collections. This solution was named <strong class="bold">sequence</strong> to avoid clashing with Java streams when they're available.</p>&#13;
			<p>We can create a new sequence using the <code>generateSequence()</code> function. For example, the next function will create an infinite sequence of numbers:</p>&#13;
			<pre>val seq: Sequence&lt;Long&gt; = generateSequence(1L) { it + 1 }</pre>&#13;
			<p>As the first argument we specify the initial value, while the second argument is a lambda that generates the next value based on the previous one. The returned type, as you can see, is <code>Sequence</code>.</p>&#13;
			<p>A regular collection or a range can be converted to a sequence using the <code>asSequence()</code> function:</p>&#13;
			<pre>(1..100).asSequence()</pre>&#13;
			<p>If we need to build a sequence using more complex logic, you can use a <code>sequence()</code> builder:</p>&#13;
			<pre>val fibSeq = sequence {</pre>&#13;
			<pre>    var a = 0</pre>&#13;
			<pre>    var b = 1</pre>&#13;
			<pre>    yield(a)</pre>&#13;
			<pre>    yield(b)</pre>&#13;
			<pre>    while (true) {</pre>&#13;
			<pre>        yield(a + b)</pre>&#13;
			<pre>        val t = a</pre>&#13;
			<pre>        a = b</pre>&#13;
			<pre>        b += t</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>} </pre>&#13;
			<p>In this example, we create a sequence of Fibonacci numbers. Then, we use the <code>yield()</code> function to return the next value in the series. Every time the sequence is used, the code will resume from the last <code>yield()</code> function invoked. </p>&#13;
			<p>While the concept<a id="_idIndexMarker534"/> of sequences doesn't seem very useful <a id="_idIndexMarker535"/>in itself, there is a significant difference between sequences and collections. Sequences are <em class="italic">lazy</em>, while collections are <em class="italic">eager</em>.</p>&#13;
			<p>This means that using higher-order functions on collections has a hidden cost for collections beyond a certain size. Most of them will copy the collection for the sake of immutability. </p>&#13;
			<p>To understand this difference, let's look at the following code. First, we'll create a list containing a million numbers and measure how much time it takes to square each number in the list –  once while operating on a <em class="italic">collection</em> and another while working on a <em class="italic">sequence</em>:</p>&#13;
			<pre>val numbers = (1..1_000_000).toList()</pre>&#13;
			<pre>println(measureTimeMillis {</pre>&#13;
			<pre>    numbers.map {</pre>&#13;
			<pre>        it * it</pre>&#13;
			<pre>    }.take(1).forEach { it }</pre>&#13;
			<pre>}) // ~50ms</pre>&#13;
			<pre> </pre>&#13;
			<pre>println(measureTimeMillis {</pre>&#13;
			<pre>    numbers.asSequence().map {</pre>&#13;
			<pre>        it * it</pre>&#13;
			<pre>    }.take(1).forEach { it }</pre>&#13;
			<pre>}) // ~5ms</pre>&#13;
			<p>We use the <code>take()</code> function, which is another higher-order function on collections, to <em class="italic">take</em> just the first element of the calculation. </p>&#13;
			<p>You can see that the code that uses a sequence executes much faster. This is because sequences, being lazy, execute the chain for each element. This means that only a single number from the entire list is squared.</p>&#13;
			<p>On the other hand, functions on collections work on the entire collection. This means that first, all of the numbers are squared, then put in a new collection, and only a single number is taken from the results. </p>&#13;
			<p>Sequences, channels, and flows follow the <em class="italic">reactive principles</em>, so it's essential to understand them before moving on. Note that reactive principles are not tied to functional<a id="_idIndexMarker536"/> programming. You can also be reactive while <a id="_idIndexMarker537"/>writing object-oriented or procedural code. However, it's still easier to discuss these principles after learning about functional programming and its foundations.</p>&#13;
			<h2 id="_idParaDest-188"><a id="_idTextAnchor194"/>Channels</h2>&#13;
			<p>In the previous <a id="_idIndexMarker538"/>chapter, we learned how to spawn coroutines and control them.</p>&#13;
			<p><em class="italic">But, what if two coroutines need to communicate with each other?</em></p>&#13;
			<p>In Java, threads communicate either by using the <code>wait()</code>/<code>notify()</code>/<code>notifyAll()</code> pattern or by using one of the rich set of classes from the <code>java.util.concurrent</code> package – for example, <code>BlockingQueue</code>.</p>&#13;
			<p>In Kotlin, as you may have noticed, there are no <code>wait()</code>/<code>notify()</code> methods. Instead, to communicate between coroutines, Kotlin uses channels. <code>BlockingQueue</code>, but instead of blocking a thread, channels suspend a coroutine, which is a lot cheaper. We'll use the following steps to create a channel and a coroutine:</p>&#13;
			<ol>&#13;
				<li>First, let's create a channel:<pre>val chan = Channel&lt;Int&gt;()</pre><p>Channels are typed. This channel can only receive integers.</p></li>&#13;
				<li>Then, let's create a coroutine that reads from this channel:<pre>launch {
    for (c in chan) {
        println(c)
    }
}</pre><p>Reading <a id="_idIndexMarker539"/>from a channel is as simple as using a <code>for-each</code> loop.</p></li>&#13;
				<li>Now, let's send some values to this channel. This is as simple as using the <code>send()</code> function:<pre>(1..10).forEach {
    chan.send(it)
}
chan.close()</pre></li>&#13;
				<li>Finally, we close the channel. Once closed, the coroutine that listens to the channel will also break out of the <code>for-each</code> loop, and if there's nothing else to do, the coroutine will terminate. </li>&#13;
			</ol>&#13;
			<p>This style of <a id="_idIndexMarker540"/>communication is called <strong class="bold">Communicating Sequential Processes</strong>, or more simply, <strong class="bold">CSP</strong>.</p>&#13;
			<p>As you can see, channels are a convenient and type-safe way to communicate between different coroutines. But we had to define the channels manually. In the following two sections, we'll<a id="_idIndexMarker541"/> see how this can be further simplified.</p>&#13;
			<h3>Producers</h3>&#13;
			<p>If we need <a id="_idIndexMarker542"/>a coroutine that supplies a stream of values, we could use the <code>produce()</code> function. This function creates a coroutine that is backed up by <code>ReceiveChannel&lt;T&gt;</code>, where <code>T</code> is the type the coroutine produces.</p>&#13;
			<p>We could rewrite the example from the previous section, as follows, by using the <code>produce()</code> function:</p>&#13;
			<pre>val chan = produce {</pre>&#13;
			<pre>    (1..10).forEach {</pre>&#13;
			<pre>        <strong class="bold">send(it)</strong></pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>launch {</pre>&#13;
			<pre>    for (c in chan) {</pre>&#13;
			<pre>        println(c)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Note that inside the <code>produce()</code> block, the <code>send()</code> function is readily available for us to push new values to the channel. </p>&#13;
			<p>Instead of using a <code>for-each</code> loop in our consumer coroutine, we can use a <code>consumeEach()</code> function:</p>&#13;
			<pre>launch {</pre>&#13;
			<pre>    chan.consumeEach {</pre>&#13;
			<pre>        println(it)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, it's time <a id="_idIndexMarker543"/>to look at another example where a coroutine is bound to a channel.</p>&#13;
			<h3>Actors</h3>&#13;
			<p>Similar <a id="_idIndexMarker544"/>to <code>producer()</code>, <code>actor()</code> is a coroutine bound to a channel. But instead of a channel going <em class="italic">out</em> of the coroutine, there's a channel going <em class="italic">into</em> the coroutine. </p>&#13;
			<p>Let's look at the following example:</p>&#13;
			<pre>val actor = actor&lt;Int&gt; {</pre>&#13;
			<pre>    channel.consumeEach {</pre>&#13;
			<pre>        println(it)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>(1..10).forEach {</pre>&#13;
			<pre>    actor.send(it)</pre>&#13;
			<pre>}</pre>&#13;
			<p>In this example, our main function is again producing the values and the actors consume them through the channel. This is very similar to the first example we saw, but instead of explicitly creating a channel and a separate coroutine, we have them bundled together.</p>&#13;
			<p>If you've worked with <strong class="bold">Scala</strong> or any other programming language that has actors, you may be familiar with a slightly different actor model from what we've described. For example, in some implementations, actors have both inbound and outbound channels (often<a id="_idIndexMarker545"/> called <strong class="bold">mailboxes</strong>). But in Kotlin, an actor has only an inbound mailbox in the form of a channel.</p>&#13;
			<h3>Buffered channels</h3>&#13;
			<p>In all of the <a id="_idIndexMarker546"/>previous examples, whether creating channels explicitly or implicitly, we in fact used their <em class="italic">unbuffered</em> version.</p>&#13;
			<p>To demonstrate what this means, let's take a look at a slightly altered example from the previous section:</p>&#13;
			<pre>val actor = actor&lt;Long&gt; {</pre>&#13;
			<pre>    var prev = 0L</pre>&#13;
			<pre>    channel.consumeEach {</pre>&#13;
			<pre>        println(it - prev)</pre>&#13;
			<pre>        prev = it</pre>&#13;
			<pre>        delay(100)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we have almost the same <code>actor</code> object, which receives timestamps and prints the difference between every two timestamps it gets. We also introduce a small delay before it can read the next value.</p>&#13;
			<p>Instead of sending a sequence of numbers, we would send the current timestamp to this <code>actor</code> object:</p>&#13;
			<pre>repeat(10) {</pre>&#13;
			<pre>    actor.send(System.currentTimeMillis())</pre>&#13;
			<pre>}</pre>&#13;
			<pre>actor.close().also { println("Done sending") }</pre>&#13;
			<p>Now, let's take a look at the output of our code:</p>&#13;
			<pre>&gt; ...</pre>&#13;
			<pre>&gt; 101</pre>&#13;
			<pre>&gt; 103</pre>&#13;
			<pre>&gt; 101</pre>&#13;
			<pre>&gt; Done sending</pre>&#13;
			<p>Notice that our producer is suspended until the channel is ready to accept the next value. Therefore, the <code>actor</code> object is able to apply backpressure on the producer, telling it not to send the next value until the <code>actor</code> object is ready.</p>&#13;
			<p>Now, let's make a minor change to the way we define our <code>actor</code> object:</p>&#13;
			<pre>val actor = actor&lt;Long&gt;(<strong class="bold">capacity = 10</strong>) {</pre>&#13;
			<pre>...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Every channel has a <em class="italic">capacity</em>, which is zero by default. This means until a value is consumed from a channel, no other value can be sent over it.</p>&#13;
			<p>Now, if we<a id="_idIndexMarker547"/> run our code again, we'll see a completely different output:</p>&#13;
			<pre>&gt; Done sending</pre>&#13;
			<pre>&gt; ...</pre>&#13;
			<pre>&gt; 0</pre>&#13;
			<pre>&gt; 0</pre>&#13;
			<p>The producer doesn't have to wait for the consumer anymore because the channel now buffers the messages. So, the messages are sent as fast as possible and the actor is still able to consume them at its own pace.</p>&#13;
			<p>In a similar manner, <code>capacity</code> could be defined on the producer channel:</p>&#13;
			<pre>val chan = produce(capacity = 10) { </pre>&#13;
			<pre>    (1..10).forEach { </pre>&#13;
			<pre>        send(it) </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>And it could be defined on the raw channel as well:</p>&#13;
			<pre>val chan = Channel&lt;Int&gt;(10)</pre>&#13;
			<p>Buffered channels are a very powerful concept that allow us to <em class="italic">decouple</em> producers from consumers. You should use them carefully, though, as the larger the capacity of the channel is, the more memory it will require.</p>&#13;
			<p>Channels are a relatively low-level concurrency construct. So, let's take a look at another type of<a id="_idIndexMarker548"/> stream, which provides us with a higher level of abstraction. </p>&#13;
			<h2 id="_idParaDest-189"><a id="_idTextAnchor195"/>Flows</h2>&#13;
			<p>A <strong class="bold">flow</strong> is a <a id="_idIndexMarker549"/>cold, asynchronous <a id="_idIndexMarker550"/>stream and is an implementation <a id="_idIndexMarker551"/>of the <strong class="bold">Observable design pattern</strong> we covered in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>. </p>&#13;
			<p>As a quick reminder, the Observable design pattern has two methods: <code>subscribe()</code> (which allows consumers to, well, subscribe for messages) and <code>publish()</code> (which sends a new message to all of the subscribers).</p>&#13;
			<p>The publish method of the <code>Flow</code> object is called <code>emit()</code>, while the subscribe method is called <code>collect()</code>.</p>&#13;
			<p>We can create a new flow using the <code>flow()</code> function:</p>&#13;
			<pre>val numbersFlow: Flow&lt;Int&gt; = flow {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Inside the <code>flow</code> constructor, we can use the <code>emit()</code> function to publish a new value to all listeners.</p>&#13;
			<p>For example, here we create a flow that would publish ten numbers using the <code>flow</code> constructor:</p>&#13;
			<pre>flow {</pre>&#13;
			<pre>    (0..10).forEach {</pre>&#13;
			<pre>        println("Sending $it")</pre>&#13;
			<pre>        emit(it)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now that we've covered how to publish a message, let's discuss how to subscribe to a flow.</p>&#13;
			<p>For that, we can use the <code>collect()</code> function available on the <code>flow</code> object:</p>&#13;
			<pre>numbersFlow.collect { number -&gt;</pre>&#13;
			<pre>    println("Listener received $number")</pre>&#13;
			<pre>}</pre>&#13;
			<p>If you run this code now, you'll see that the listener prints all the numbers it receives from the flow.</p>&#13;
			<p>Unlike some other reactive frameworks and libraries, there is no special syntax to raise an exception to <a id="_idIndexMarker552"/>the listener. Instead, we can simply use the <a id="_idIndexMarker553"/>standard <code>throw</code> expression to do that:</p>&#13;
			<pre>flow {</pre>&#13;
			<pre>    (1..10).forEach {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre><strong class="bold">        if (it == 9) {</strong></pre>&#13;
			<pre><strong class="bold">            throw RuntimeException()</strong></pre>&#13;
			<pre><strong class="bold">        }</strong></pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>From the listener side, handling exceptions is as simple as wrapping the <code>collect()</code> function in a <code>try</code>/<code>catch</code> block:</p>&#13;
			<pre>try {</pre>&#13;
			<pre>    numbersFlow.collect { number -&gt;</pre>&#13;
			<pre>        println("Listenerreceived $number")</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>catch (e: Exception) {</pre>&#13;
			<pre>    println("Got an error")</pre>&#13;
			<pre>}</pre>&#13;
			<p>Like channels, the Kotlin flows are suspending, but they are not concurrent. Flows support backpressure, although this is completely transparent to the user. To see what this means, let's create multiple subscribers for the same flow:</p>&#13;
			<pre>(1..4).forEach { coroutineId -&gt;</pre>&#13;
			<pre>    delay(5000)</pre>&#13;
			<pre>    launch(Dispatchers.Default) {</pre>&#13;
			<pre>        numbersFlow.collect { number -&gt; </pre>&#13;
			<pre>            delay(1000)</pre>&#13;
			<pre>            println("Coroutine $coroutineId received </pre>&#13;
			<pre>              $number") </pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Each subscriber<a id="_idIndexMarker554"/> runs in its own coroutine, with a delay of five <a id="_idIndexMarker555"/>seconds between each new subscription. This allows us to see them run concurrently.</p>&#13;
			<p>Now, let's take a look at the output:</p>&#13;
			<pre>&gt; ...</pre>&#13;
			<pre>&gt; Sending 1</pre>&#13;
			<pre>&gt; Coroutine 1 received 5</pre>&#13;
			<pre>&gt; Sending 6</pre>&#13;
			<pre>&gt; Coroutine 2 received 1</pre>&#13;
			<pre>&gt; Sending 2</pre>&#13;
			<pre>&gt; Coroutine 1 received 6</pre>&#13;
			<pre>&gt; ...</pre>&#13;
			<p>From this output, we can learn two important lessons:</p>&#13;
			<ul>&#13;
				<li><code>1</code>.</li>&#13;
				<li><strong class="bold">Flows use backpressure</strong>: Note that the next number is not sent until the previous number is received. This is similar to the behavior of unbuffered channels and different from buffered channels, where the producer can send numbers<a id="_idIndexMarker556"/> faster than the consumer can consume <a id="_idIndexMarker557"/>them.</li>&#13;
			</ul>&#13;
			<p>Next, let's see how these two properties of flows can be altered, if necessary.</p>&#13;
			<h3>Buffering flows</h3>&#13;
			<p>In some<a id="_idIndexMarker558"/> cases, for example, when we have plenty of available memory, we aren't interested in applying backpressure on the producer right away. To do so, each consumer can specify that the flow should be <em class="italic">buffered</em> by using the <code>buffer()</code> function:</p>&#13;
			<pre>numbersFlow.<strong class="bold">buffer()</strong>.collect { number -&gt;</pre>&#13;
			<pre>    delay(1000)</pre>&#13;
			<pre>    println("Coroutine $coroutineId received $number")</pre>&#13;
			<pre>}</pre>&#13;
			<p>If we look at the output of the preceding code again, we'll see a dramatic change:</p>&#13;
			<pre>&gt; ...</pre>&#13;
			<pre>&gt; Sending 8</pre>&#13;
			<pre>&gt; Sending 9</pre>&#13;
			<pre>&gt; Sending 10</pre>&#13;
			<pre>&gt; Coroutine 1 received 1</pre>&#13;
			<pre>&gt; Coroutine 1 received 2</pre>&#13;
			<pre>&gt; ...</pre>&#13;
			<p>With a buffer, the flow produces values without any backpressure from the consumer until the buffer is filled. Then, the consumer is still able to collect the values at its own pace. This behavior is similar to buffered channels, and in fact, the implementation uses a channel under the hood. </p>&#13;
			<p>Buffering a flow is useful when it takes a considerable amount of time to process each message. Take uploading images from your phone as an example. Of course, the upload will take a different amount of time based on the size of the image. You don't want to block the user interface until the image is uploaded because that would be a bad user experience and against reactive principles. </p>&#13;
			<p>Instead, you could define a buffer that fits into the memory, upload the images at your own pace, and block the user interface only once the buffer is full of tasks. </p>&#13;
			<p>In the case of images, we are dealing with a series of elements we don't want to lose. So, let's consider<a id="_idIndexMarker559"/> a different example, where we could allow dropping some of the elements in our flow.</p>&#13;
			<h3>Conflating flows</h3>&#13;
			<p>Imagine we <a id="_idIndexMarker560"/>have a flow that produces changes in stock prices at a rate of ten times a second, and we have a UI that needs to display the latest stock values. To do this, we'll just use a number that goes up by 1 for every tick:</p>&#13;
			<pre>val stock: Flow&lt;Int&gt; = flow {</pre>&#13;
			<pre>    var i = 0</pre>&#13;
			<pre>    while (true) {</pre>&#13;
			<pre>        emit(++i)</pre>&#13;
			<pre>        delay(100)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>The UI itself, however, doesn't have to be refreshed ten times every second. Once every second is more than enough. If we simply try to use <code>collect()</code>, as in the previous example, we'll be constantly behind the producer:</p>&#13;
			<pre>var seconds = 0</pre>&#13;
			<pre>stock.collect { number -&gt;</pre>&#13;
			<pre>    delay(1000)</pre>&#13;
			<pre>    seconds++</pre>&#13;
			<pre>    println("$seconds seconds -&gt; received $number")</pre>&#13;
			<pre>}</pre>&#13;
			<p>The preceding code outputs the following:</p>&#13;
			<pre>&gt; 1 seconds -&gt; received 1</pre>&#13;
			<pre>&gt; 2 seconds -&gt; received 2</pre>&#13;
			<pre>&gt; 3 seconds -&gt; received 3</pre>&#13;
			<pre>&gt; ...</pre>&#13;
			<p>The preceding output is incorrect. The reason for this is that we apply backpressure to the flow, slowing it down. Another option would be to buffer 10 values, as we've seen in the previous example. But since we want to refresh the UI ten times slower than the flow refreshes itself, we'll have to discard nine values out of ten. We'll leave it to the readers to<a id="_idIndexMarker561"/> try and implement that logic.</p>&#13;
			<p>A better solution would be to <em class="italic">conflate</em> the flow. A conflated flow doesn't store all of the messages. Instead, it keeps only the most recent values. We implement this in the following code:</p>&#13;
			<pre>stock.<strong class="bold">conflate()</strong>.collect { number -&gt;</pre>&#13;
			<pre>    delay(1000)</pre>&#13;
			<pre>    seconds++</pre>&#13;
			<pre>    println("$seconds seconds -&gt; received $number")</pre>&#13;
			<pre>}</pre>&#13;
			<p>Let's first look at the output:</p>&#13;
			<pre>&gt; ...</pre>&#13;
			<pre>&gt; 4 seconds -&gt; received 30</pre>&#13;
			<pre>&gt; 5 seconds -&gt; received 40</pre>&#13;
			<pre>&gt; 6 seconds -&gt; received 49</pre>&#13;
			<pre>&gt; ...</pre>&#13;
			<p>You can see that now the values are correct. On average, our counter is incremented ten times every second. </p>&#13;
			<p>Now, our flow will never be suspended and the subscriber will receive only the most recent value<a id="_idIndexMarker562"/> that the flow has calculated.</p>&#13;
			<h1 id="_idParaDest-190"><a id="_idTextAnchor196"/>Summary</h1>&#13;
			<p>This chapter was dedicated to practicing functional programming with reactive principles and learning the building blocks of functional programming in Kotlin. We also learned about the main benefits of reactive systems. For example, such systems should be responsive, resilient, elastic, and driven by messaging. </p>&#13;
			<p>Now, you should know how to transform your data, filter your collections, and find elements within the collection that meet your criteria. </p>&#13;
			<p>You should also better understand the difference between <em class="italic">cold</em> and <em class="italic">hot</em> streams. A cold stream, such as a <em class="italic">flow</em>, starts working only when someone subscribes to it. A new subscriber will usually receive all of the events. On the other hand, a hot stream, such as a <em class="italic">channel</em>, continuously emits events, even if nobody is listening to them. A new subscriber will receive only the events that were sent after the subscription was made.</p>&#13;
			<p>We also discussed the concept of backpressure, which can be implemented in a flow. For example, if the consumer is not able to process all of the events, it may suspend the producer, buffer the events in the hope of catching up, or conflate the stream, handling only some of the events. </p>&#13;
			<p>The next chapter will cover concurrent design patterns, which allow us to architect concurrent systems in a scalable, maintainable, and extensible manner, using coroutines and reactive streams as building blocks. </p>&#13;
			<h1 id="_idParaDest-191"><a id="_idTextAnchor197"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What is the difference between higher-order functions on collections and on concurrent data structures?</li>&#13;
				<li>What is the difference between cold and hot streams of data?</li>&#13;
				<li>When should a conflated channel or flow be used?</li>&#13;
			</ol>&#13;
		</p>&#13;
	</div></body></html>