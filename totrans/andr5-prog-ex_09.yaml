- en: Chapter 9. Camera, Video, and Multimedia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。相机、视频和多媒体
- en: Recent years have brought about great advancements in mobile multimedia technologies,
    with many people not only listening to music and watching movies on their mobile
    devices but using them to produce high quality media of their own. The SDK provides
    APIs that allow us to include both media playback as well as media capture, and
    with the camera APIs being completely overhauled, there has never been a better
    time to be developing Android multimedia apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，移动多媒体技术取得了巨大进步，许多人不仅在他们的移动设备上听音乐和看电影，而且使用它们来制作自己高质量的多媒体内容。SDK提供了API，允许我们包含媒体播放以及媒体捕获，并且随着相机API的完全重写，现在是开发Android多媒体应用程序的最好时机。
- en: Many multimedia features can be very easily incorporated into our apps by simply
    harnessing the system's native applications such as the camera. Alternatively,
    we can work directly with the APIs and develop apps that handle all the photos
    and videos capturing process themselves, although this is no simple task. One
    thing that is simple to achieve, though, is including the recording and playing
    of multimedia, including audio, within our apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多多媒体功能可以通过简单地利用系统的原生应用程序（如相机）非常容易地集成到我们的应用程序中。或者，我们可以直接与API合作，开发处理所有照片和视频捕获过程的应用程序，尽管这不是一个简单的任务。然而，简单实现的一件事是在我们的应用程序中包含多媒体的录制和播放，包括音频。
- en: 'In this chapter, you will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Preview images using the native Camera app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生相机应用程序预览图像
- en: Automatically refactor code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动重构代码
- en: Save images from the native camera to our app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从原生相机保存图像到我们的应用程序
- en: Handle IO exceptions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理IO异常
- en: Create a unique filename
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个唯一的文件名
- en: Add images to the device gallery
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像添加到设备图库
- en: Make images private
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使图像私有
- en: Capture and play back video
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获和播放视频
- en: Add video controls
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加视频控件
- en: Handle video interruptions without losing position
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理视频中断而不会丢失位置
- en: Package videos with an app
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视频打包到应用程序中
- en: Play videos from memory
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内存中播放视频
- en: Stream video from the Web
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络流式传输视频
- en: Record audio files with a MediaRecorder
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MediaRecorder记录音频文件
- en: Play back audio files with a MediaPlayer
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MediaPlayer播放音频文件
- en: Capturing images
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获图像
- en: More often than not, when including image or video capture in our apps, all
    we need to do is take advantage of the fact that the system already has applications
    designed for these purposes and we can call upon them with an Intent, in just
    the same way that we call Activities inside our own apps. We do not even need
    to know which app is called, as the system will automatically seek out the most
    appropriate, even offering the user a choice when one is available.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，当在我们的应用程序中包含图像或视频捕获时，我们只需要利用系统已经为这些目的设计的应用程序，并且我们可以通过Intent调用它们，就像我们在自己的应用程序中调用Activity一样。我们甚至不需要知道调用的是哪个应用程序，因为系统会自动寻找最合适的，甚至在有选择的情况下为用户提供选择。
- en: 'Here, we will include a photo taking function in our Ancient Britain app that
    harnesses the native Camera application to capture an image, display it in a view
    and save it to a specific directory. We will then make our image available to
    the device gallery and other apps. This is not a short exercise, so we will split
    it into three parts: preparing and refactoring, previewing a camera shot, and
    saving a camera shot.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在Ancient Britain应用程序中包含一个拍照功能，该功能利用原生相机应用程序捕获图像，将其显示在视图中并保存到特定目录。然后我们将我们的图像提供给设备图库和其他应用程序。这不是一个简短的练习，所以我们将它分成三个部分：准备和重构、预览相机拍摄，以及保存相机拍摄。
- en: Refactoring code
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重构
- en: 'To save time, we will not set up another button for our camera function. Instead
    we will reuse the ImageView that currently takes the user to the relevant Wikipedia
    page. We will also need to set some permissions and feature uses and add a new
    graphic. Follow these steps to prepare the Ancient Britain app, which we began
    in [Chapter 4](ch04.html "Chapter 4. Managing RecyclerViews and Their Data"),
    *Managing RecyclerViews and Their Data* to incorporate calls to the native camera:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间，我们不会为我们的相机功能设置另一个按钮。相反，我们将重用当前用于将用户带到相关维基百科页面的ImageView。我们还需要设置一些权限和功能使用，并添加一个新图形。按照以下步骤准备Ancient
    Britain应用程序，我们在[第4章](ch04.html "第4章。管理RecyclerView及其数据")*管理RecyclerView及其数据*中开始，以包含对原生相机的调用：
- en: Open the `Ancient Britain` project in Android Studio and open the manifest file.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开`Ancient Britain`项目并打开清单文件。
- en: 'Include these tags:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下标签：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Find an icon-sized image, suitable for a camera function, such as the following:![Refactoring
    code](img/B04321_09_01.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个适合相机功能的图标大小的图片，例如以下所示：![重构代码](img/B04321_09_01.jpg)
- en: Save this in the `res/drawable` directory in file explorer view and replace
    the `web_icon.png` file with the one you just made.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件资源管理器视图中将其保存在`res/drawable`目录中，并用您刚刚制作的文件替换`web_icon.png`文件。
- en: Open the `DetailActivity.java` file.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DetailActivity.java`文件。
- en: 'Locate the following line and right-click on `detailWebLink`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位以下行，并在`detailWebLink`上右键单击：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Press *Shift* + *F6* and rename the instance `detailCameraButton`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Shift* + *F6*重命名实例`detailCameraButton`。
- en: Do the same for the XML reference, renaming it `detail_camera_button`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于XML引用，也进行相同的操作，将其重命名为`detail_camera_button`。
- en: Select `web_icon` in the `drawable` folder in the project explorer and rename
    it `camera_icon`.![Refactoring code](img/B04321_09_02.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中的`drawable`文件夹中选择`web_icon`并将其重命名为`camera_icon`。![重构代码](img/B04321_09_02.jpg)
- en: The first thing we did here, was apply permissions and feature to the manifest,
    the feature being included here so as to prevent devices without cameras being
    able to find it on the Play store.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第一件事是向清单中添加权限和功能，这里包含的功能是为了防止没有摄像头的设备在Play商店中找到它。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you are developing for API level 17 or below, you will need to add the permission:
    `android.permission.CAMERA`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为API级别17或以下开发，您需要添加权限：`android.permission.CAMERA`。
- en: The refactoring that we did next was not strictly necessary but made the code
    easier to follow and demonstrated just how easy it is to rename things with the
    *F6* key. The effects propagate throughout the project, for example when we renamed
    an XML reference in Java, the corresponding layout file was edited accordingly,
    and there are many handy refactoring tools available through the Refactor menu.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来所做的重构并非绝对必要，但它使代码更容易理解，并展示了使用*F6*键重命名事物是多么简单。这些效果会在整个项目中传播，例如当我们在一个Java中的XML引用中重命名时，相应的布局文件也会相应地编辑，并且通过重构菜单有许多方便的重构工具可用。
- en: Previewing the camera output
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预览相机输出
- en: 'To preview the camera, we need to fire an intent that calls the native camera
    as well as a way of responding when the camera returns to our app. These three
    steps achieve that:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预览相机，我们需要触发一个调用本地相机的intent，以及当相机返回到我们的应用程序时的响应方式。这三个步骤实现了这一点：
- en: 'Add these fields to the `detailActivity` class:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字段添加到`detailActivity`类中：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Replace the `onClick()` method of the now, `detailCameraButton` button''s `onClickListener`
    with this code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现在`detailCameraButton`按钮的`onClickListener`中的`onClick()`方法替换为以下代码：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Provide the class with the following `onActivityResult()` method:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该类提供以下`onActivityResult()`方法：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can now run the app. Clicking the camera icon will allow you to take a picture
    which will be displayed in the layout's other `ImageView`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以运行应用程序了。点击相机图标将允许您拍照，照片将在布局中的其他`ImageView`中显示。
- en: '![Previewing the camera output](img/B04321_09_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![预览相机输出](img/B04321_09_03.jpg)'
- en: The intent we create here is called on the `MediaStore` class, using a constant
    that opens the native camera. Note how the Camera Activity is protected by the
    intent's `resolveActivity()` method. If there is no app on the device that can
    fulfill the request and the intent is fired, then the app will crash. The `PacketManager()`
    will contain nothing if no suitable app is found.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的intent是在`MediaStore`类上调用的，使用一个打开本地相机的常量。注意相机活动是如何通过intent的`resolveActivity()`方法受到保护的。如果没有适合请求的应用程序在设备上，并且触发了intent，那么应用程序将会崩溃。如果没有找到合适的应用程序，`PacketManager()`将不包含任何内容。
- en: When control is handed back to our app, the `onActivityResult()` method is called.
    The `requestCode` is used to check where the camera Activity was called from and
    the `resultCode` to test that it worked. We used the data value pair `data` to
    extract the bitmap the camera returned in its Bundle. This particular image is
    only a thumbnail. The full image is available and next we will see how to store
    it on the SD card.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制权交回我们的应用程序时，会调用`onActivityResult()`方法。`requestCode`用于检查相机活动是从哪里被调用的，而`resultCode`用于测试它是否成功。我们使用数据值对`data`从相机返回的Bundle中提取位图。这个特定的图像只是一个缩略图。完整图像是可用的，接下来我们将看到如何将其存储在SD卡上。
- en: Saving the camera output
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存相机输出
- en: 'Again to save time and extra coding, we will use an existing widget as a button
    to trigger an Intent to save as well as take a photo. We will replace the main
    image view''s `onTouchListener` with an `onClickListener` and call the methods
    we need from there. Follow these steps to see how:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间和额外的编码，我们将使用现有的小部件作为按钮来触发保存图片以及拍照的 Intent。我们将替换主图像视图的 `onTouchListener`
    为 `onClickListener` 并从那里调用所需的函数。按照以下步骤查看如何操作：
- en: 'In the `detailActivity` class, replace the line `detailImage.setOnTouchListener(listener);`
    in the `onCreate()` method with this code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `detailActivity` 类中，将 `onCreate()` 方法中的 `detailImage.setOnTouchListener(listener);`
    行替换为以下代码：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the `takePhoto()` method to look like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `takePhoto()` 方法，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Include the `filename()` method like so:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 `filename()` 方法，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `onActivityResult()` method, replace the commented `// To complete line
    with this code`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onActivityResult()` 方法中，替换掉注释的 `// To complete line with this code`：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can now run and test the app. Tapping the camera icon replaces the main
    image with the one just taken and tapping on the image itself will let you save
    a picture to the device's SD card in the Pictures directory.![Saving the camera
    output](img/B04321_09_04.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行并测试应用。点击相机图标将替换主图像为刚刚拍摄的图像，点击图像本身将允许您将图片保存到设备的 SD 卡上的图片目录中。![保存相机输出](img/B04321_09_04.jpg)
- en: Clearly, the way this example processes user input, is a little on the clumsy
    side. Ideally, we would have added new buttons or even another Activity to handle
    previewing and saving images. We took this approach for the sake of brevity and
    to highlight the processes themselves. The two methods applied warrant a little
    examination themselves.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个示例处理用户输入的方式有点笨拙。理想情况下，我们会添加新的按钮或甚至另一个 Activity 来处理预览和保存图片。我们采取这种方法是为了简洁并突出显示这些过程本身。这两个方法本身也值得仔细检查。
- en: The `takePhoto()` method fires the same intent as the camera button's `onClick()`
    method. A different request code is used to show how we can call the same external
    Activity but respond differently depending on where it was called from. Android
    generally manages exceptions rather well, but we cannot guarantee the presence
    of a SD card and it makes sense to try to catch this exception. We could create
    a message. If the creation of the File `photoFile` is successful (and it rarely
    isn't), it can be included in our Intent with the line `takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT,
    Uri.fromFile(photoFile));`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`takePhoto()` 方法触发与相机按钮的 `onClick()` 方法相同的 intent。使用不同的请求代码来展示我们如何调用相同的外部 Activity，但根据调用位置的不同而做出不同的响应。Android
    通常管理异常相当好，但我们不能保证 SD 卡的存在，并且尝试捕获这个异常是有意义的。我们可以创建一个消息。如果 `photoFile` 文件的创建成功（这很少不成功），它可以通过以下行包含在我们的
    Intent 中 `takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(photoFile));`。'
- en: When creating a filename, we need to be careful that it does not collide with
    others. Without a lot of precautionary code, this can be done by setting up a
    unique filename, which is done here by appending a timestamp. This method is called
    during our attempt to catch system exceptions and therefore requires the throws
    `IOException` declaration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建文件名时，我们需要小心不要与其他文件冲突。在没有太多预防性代码的情况下，可以通过设置一个唯一的文件名来实现，这里是通过附加时间戳来完成的。这个方法在我们尝试捕获系统异常时被调用，因此需要抛出
    `IOException` 声明。
- en: Finally, we added some code in the `else` clause of our `onActivityResult()`
    method, which is called after the image is saved and control returned to our app.
    The `ACTION_MEDIA_SCANNER_SCAN_FILE` Intent is a request to the media scanner
    to add it to the media database the next time it is run. This means that our image
    will appear in the native gallery app and be available to any other app that uses
    the media database, such as wallpaper pickers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `onActivityResult()` 方法的 `else` 子句中添加了一些代码，该子句在图片保存并控制返回到我们的应用后被调用。`ACTION_MEDIA_SCANNER_SCAN_FILE`
    Intent 是请求媒体扫描器在下次运行时将其添加到媒体数据库。这意味着我们的图片将出现在原生图库应用中，并且可供任何使用媒体数据库的其他应用使用，例如壁纸选择器。
- en: If you want your images to be only available from within your app, it is not
    enough simply to omit these lines, as the images are still accessible from any
    file browsing software. To prevent this, use `Environment.getExternalFilesDir()`
    instead of `Environment.getExternalStoragePublicDirectory()`. This will also have
    the effect of deleting these files when your app is uninstalled.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想让你的图像在应用内部可用，仅仅省略这些行是不够的，因为图像仍然可以通过任何文件浏览软件访问。为了防止这种情况，使用`Environment.getExternalFilesDir()`而不是`Environment.getExternalStoragePublicDirectory()`。这也会在应用卸载时删除这些文件。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The media scanner does not necessarily run at predictable times and, when testing,
    you may have to restart your device or emulator to force it to include your file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体扫描器不一定在可预测的时间运行，在测试时，你可能需要重新启动你的设备或模拟器来强制它包含你的文件。
- en: Commandeering the platform's camera like this is a wonderfully convenient way
    to incorporate its functionality with a minimum of coding. Of course, it is quite
    possible to recreate a camera or a video app from scratch and we will take a quick
    look at how that can be done shortly. First, let us see how to record and play
    back video in the same way we did here with the camera.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式控制平台的摄像头是一个非常方便的方法，可以在最少的编码下整合其功能。当然，从头开始重新创建一个摄像头或视频应用是完全可能的，我们很快就会看看如何做到这一点。首先，让我们看看如何以与这里使用摄像头相同的方式录制和播放视频。
- en: Capturing and playing video
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获和播放视频
- en: 'Using native apps to capture video content from within our own apps is achieved
    in an almost identical way, to the one we just applied. The main difference is
    that when dealing with video content a lot of the functionality is provided by
    the purpose-built widget, the `VideoView`. We will also add video control buttons
    with the `MediaController` and see how to pause a video when our app is sent to
    the background. Follow these steps to build a simple video app:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生应用从我们自己的应用中捕获视频内容的方式几乎与我们刚刚应用的方式相同。主要区别在于，在处理视频内容时，许多功能都是由专门设计的控件`VideoView`提供的。我们还将添加带有`MediaController`的视频控制按钮，并看看如何在应用发送到后台时暂停视频。按照以下步骤构建一个简单的视频应用：
- en: Start a new Android Studio project.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的Android Studio项目。
- en: Add the feature uses and permissions we included in the last exercise to the
    manifest.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在上一个练习中包含的功能使用和权限添加到清单中。
- en: 'Open the `activity_main.xml` file and replace the `TextView` with this `VideoView`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件，并用以下`VideoView`替换`TextView`：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open the `MainActivity.java` and add these fields:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并添加以下字段：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Include this code in the `onCreate()` method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中包含以下代码：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then the `onActivityResult()` method:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是`onActivityResult()`方法：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you test the project now, you will be able to record and play back a video.
    However, if the Activity loses focus and restarts, the video will also start from
    the beginning.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在测试项目，你将能够录制和播放视频。然而，如果Activity失去焦点并重新启动，视频也将从头开始播放。
- en: 'To rectify this, add these two methods:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了纠正这个问题，添加这两个方法：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you now test the app and interrupt the playback with another app, and then
    return to the Activity, it will resume from where it left off.![Capturing and
    playing video](img/B04321_09_05.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在测试应用并使用另一个应用中断播放，然后返回到Activity，它将从上次停止的地方继续播放。![捕获和播放视频](img/B04321_09_05.jpg)
- en: 'Up until step 6, the way we dispatched our intent to capture video was almost
    identical to the method we used for still images, with the exception of the `MediaController`,
    which adds the familiar controls we all associate with video playback. When dealing
    with videos, particularly long ones, the user may wish to pause playback and engage
    with another app. To ensure that the video resumes from the last position when
    the user returns, we had to intercept the Activity lifecycle before the app is
    sent to the background with the `onSaveInstanceState()` method and again when
    it returns with `onRestoreInstanceState()`. We used `VideoView.pause()` and `VideoView.seekTo()`
    here. The following methods are available in `VideoView` for controlling video
    playback:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到第6步之前，我们派发意图以捕获视频的方法几乎与用于静态图像的方法相同，唯一的区别是`MediaController`，它添加了我们所有人都与视频播放相关联的熟悉控件。在处理视频时，尤其是处理较长的视频时，用户可能希望暂停播放并与其他应用交互。为了确保用户返回时视频从上次停止的位置继续播放，我们不得不在应用发送到后台之前使用`onSaveInstanceState()`方法拦截Activity生命周期，并在它返回时再次使用`onRestoreInstanceState()`。我们在这里使用了`VideoView.pause()`和`VideoView.seekTo()`。以下是在`VideoView`中可用于控制视频播放的方法：
- en: '`VideoView.start()`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VideoView.start()`'
- en: '`VideoView.pause()`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VideoView.pause()`'
- en: '`VideoView.resume()`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VideoView.resume()`'
- en: '`VideoView.seekTo(position)`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VideoView.seekTo(position)`'
- en: As useful as it is to be able to provide video recording capabilities in our
    apps, there are often times when we will want to play videos packaged within our
    app, or from an external source such as the device SD card or even streamed from
    the Internet. The example above only requires a few minor adjustments and the
    next section shows how to adapt it to play video from other sources than the camera
    itself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管能够在我们的应用中提供视频录制功能非常有用，但很多时候我们可能想要播放应用内打包的视频或从外部源（如设备SD卡或甚至从互联网流式传输）的视频。上面的示例只需要进行一些小的调整，下一节将展示如何将其调整为从除相机本身以外的其他来源播放视频。
- en: Playing video from memory and the Internet
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从内存和互联网播放视频
- en: 'There are countless reasons why we might want to include video content in our
    app or play videos produced by other apps, and in this section we will see how
    to package videos within our app and how to play videos from the device''s storage
    and the Web. The following exercise will take you through how to do each of these:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望在应用中包含视频内容或播放其他应用产生的视频的原因不计其数，在本节中，我们将看到如何打包视频到我们的应用中，以及如何从设备的存储和互联网上播放视频。以下练习将指导您如何完成这些操作：
- en: Open the project that we just worked on.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们刚刚工作的项目。
- en: Create a new folder in the `res` directory called `raw`.![Playing video from
    memory and the Internet](img/B04321_09_06.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res`目录下创建一个名为`raw`的新文件夹。![从内存和互联网播放视频](img/B04321_09_06.jpg)
- en: 'Find a short video file with one of the following formats, name it `movie`,
    and paste it into the `res/raw` folder: `.webm`, `.3gp`, `.mp4`, or `.mkv`.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个格式为以下之一、命名为`movie`的短视频文件，并将其粘贴到`res/raw`文件夹中：`.webm`、`.3gp`、`.mp4`或`.mkv`。
- en: Open the `MainActivity` file.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`文件。
- en: 'In the `onCreate()` method, comment out the call to `takePhoto()` and add these
    two lines:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中，注释掉对`takePhoto()`的调用，并添加以下两行：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If playing an in-app video is what you are after, you can stop here and run
    the app.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要在应用内播放视频，可以在这里停止并运行应用。
- en: 'To play a video stored on the device''s SD card, replace the lines you just
    entered with these:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要播放存储在设备SD卡上的视频，将您刚才输入的行替换为以下内容：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If run, the app will now play the indicated file from the SD card. To stream
    a video, use this code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果运行，应用现在将播放SD卡上的指定文件。要流式传输视频，请使用以下代码：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's all there is to it. We stored our in-app video in the `res/raw` directory.
    Although not included, when we create a project, `raw` is a recognized resource
    folder and can be used for storing any file that we do not want compiled when
    the project is built and/or packaged.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们将应用内的视频存储在`res/raw`目录下。虽然未包含在内，但当我们创建项目时，`raw`是一个已识别的资源文件夹，可以用于存储我们不希望在项目构建和/或打包时编译的任何文件。
- en: The other thing to note about this otherwise straightforward code is how we
    use `VideoView.setVideoPath()` when loading from internal storage or the Web,
    rather than `VideoView.setVideoURI()`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此代码的其他注意事项是，当从内部存储或互联网加载时，我们使用`VideoView.setVideoPath()`而不是`VideoView.setVideoURI()`。
- en: Calling other apps, such as the camera app, is a very convenient way to incorporate
    such features without a great deal of coding. There are, of course, times when
    we will want a deeper integration of the camera APIs. This requires building the
    camera from the ground up and is beyond the scope of this chapter. However, Android
    5 does introduce a whole new set of camera APIs, the `android.hardware.camera2`,
    which supersedes the `android.hardware.Camera` APIs. **Camera2** allows for some
    exciting new features, such as control over individual cameras and improved storage
    capabilities, and although there is no room to build a camera2 app from scratch
    here, there is a very informative sample, packaged with the SDK, which we will
    now take a look at.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用其他应用，例如相机应用，是一种非常方便的方式，可以在不进行大量编码的情况下集成这些功能。当然，有时我们可能希望更深入地集成相机API。这需要从头开始构建相机，但这超出了本章的范围。然而，Android
    5确实引入了一套全新的相机API，即`android.hardware.camera2`，它取代了`android.hardware.Camera` API。**Camera2**允许一些令人兴奋的新特性，例如控制单个相机和改进的存储能力，尽管这里没有足够的空间从头开始构建camera2应用，但SDK中包含了一个非常有信息量的示例，我们将现在查看它。
- en: Exploring the camera2 APIs
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索camera2 API
- en: The camera2 APIs are a lot more sophisticated than their predecessors, but they
    are also a lot more involved. Building a camera app from scratch is far from simple.
    Fortunately, Android packages numerous sample apps within the SDK and there is
    a suitable camera2 sample, that we can take a look at.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: camera2 API比它们的 predecessors复杂得多，但它们也复杂得多。从头开始构建相机app远非简单。幸运的是，Android SDK中包含了许多示例app，并且有一个合适的camera2样本，我们可以查看。
- en: Samples can be loaded directly into the Android Studio from the Quick Start
    pane of the startup window **File** | **Import Sample...** from within the IDE.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 样本可以直接从启动窗口的快速启动面板中加载到Android Studio，在IDE内部选择**文件** | **导入样本...**。
- en: '![Exploring the camera2 APIs](img/B04321_09_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![探索camera2 API](img/B04321_09_07.jpg)'
- en: Most camera2 processes begin with the `CameraManager`. This class allows us
    to identify and connect to any cameras attached to the device, as well as determining
    their properties. In the sample, the `Camera2BasicFragment` class is where most
    of the interesting work is done and you can see how a `CameraManager` is used
    in the `openCamera()` method to open a camera, and in `setUpCameraOutputs()` to
    acquire the camera ID and whether it is the front-facing camera using the `CameraCharateristics`
    class. This class can be seen in action in the `setUpCameraOutputs()` method too,
    where it is used to rule out the front-facing camera.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数camera2过程都是从`CameraManager`开始的。这个类允许我们识别和连接到设备上连接的任何相机，以及确定它们的属性。在示例中，`Camera2BasicFragment`类是大多数有趣工作的地方，你可以看到如何在`openCamera()`方法中使用`CameraManager`打开相机，以及在`setUpCameraOutputs()`中使用`CameraCharacteristics`类获取相机ID以及它是否是前置相机。这个类在`setUpCameraOutputs()`方法中也可以看到，它被用来排除前置相机。
- en: The `CameraDevice` is the class used to represent individual cameras within
    an app, and is used for setting up a `CaptureRequest` and a `CaptureRequestSession`
    for the actual process of taking photos. This also gives us control over functions
    such as auto focus and white balance. The `CameraCaptureSession` is where camera2
    features, such as being able to take multiple images in a burst, are made available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraDevice`类用于在应用中表示单个相机，并用于设置`CaptureRequest`和`CaptureRequestSession`，以便进行拍照的实际过程。这也使我们能够控制诸如自动对焦和白平衡等功能。《CameraCaptureSession》是提供camera2功能的地方，例如能够连续拍摄多张图片。'
- en: It is well worth exploring and experimenting with the `Camer2Basic` sample,
    and there is also a `Camera2Video` sample. If you are interested in building a
    camera app from scratch using Android 5 capabilities, then the official documentation
    at [http://developer.android.com/reference/android/hardware/camera2/package-summary.html](http://developer.android.com/reference/android/hardware/camera2/package-summary.html)
    is well worth checking out.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 探索和实验`Camer2Basic`样本是非常值得的，还有一个`Camera2Video`样本。如果你对使用Android 5功能从头开始构建相机app感兴趣，那么官方文档[http://developer.android.com/reference/android/hardware/camera2/package-summary.html](http://developer.android.com/reference/android/hardware/camera2/package-summary.html)是值得查看的。
- en: 'The Camera2 APIs, despite their sophistication, have one serious drawback:
    they are the one set of Android 5 APIs that cannot be made backward compatible
    easily. Any app that relies largely on camera and video functions would require
    an necessary amount of alternative code to make it available for older platforms.
    Jelly Bean and KitKat current occupy over three-quarters of the market and look
    likely to make up a significant proportion of your target audience for a good
    time to come. Unless you plan to utilize camera2-specific features, such as capturing
    images in RAW format or taking multiple shots in a burst, you should seriously
    consider using the original Camera APIs, which despite having depreciated are
    still perfectly usable.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管camera2 API非常复杂，但它们有一个严重的缺点：它们是Android 5 API中唯一一组难以实现向后兼容的API。任何主要依赖相机和视频功能的app都需要一定数量的替代代码来使其适用于旧平台。Jelly
    Bean和KitKat目前占据了超过四分之三的市场份额，并且看起来很可能会在未来一段时间内占据你目标受众的很大一部分。除非你计划利用camera2特定的功能，例如以RAW格式捕获图像或连续拍摄多张照片，否则你应该认真考虑使用原始的Camera
    API，尽管它们已经过时，但仍然完全可用。
- en: Recording and playing audio
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制和播放音频
- en: 'We saw earlier in the chapter how to capture and play multimedia content using
    native apps and the `VideoView`. There is also another very handy tool for recording
    and playing media files, especially audio: the `MediaRecorder` class. The `MediaRecorder`
    allows us to simply set such things as audio source, output location, and format,
    as well as giving us control over play and record functions. In this exercise,
    we will develop a small app that records and plays back audio captured with a
    device''s inbuilt microphone:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们之前看到了如何使用原生应用和 `VideoView` 捕获和播放多媒体内容。还有一个非常实用的工具用于录制和播放媒体文件，特别是音频：`MediaRecorder`
    类。`MediaRecorder` 允许我们简单地设置音频源、输出位置和格式，同时让我们控制播放和录制功能。在这个练习中，我们将开发一个小型应用，用于录制和播放设备内置麦克风捕获的音频：
- en: Start a new Android Studio project.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的 Android Studio 项目。
- en: Find three button-sized media images like those below and place them in your
    `drawable` folder.![Recording and playing audio](img/B04321_09_08.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到三个与按钮大小相似的媒体图像，如下所示，并将它们放置在您的 `drawable` 文件夹中。![录制和播放音频](img/B04321_09_08.jpg)
- en: Call them Play, Record, and Stop.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们命名为播放、录制和停止。
- en: 'Open the manifest files and include these permissions:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开清单文件并包含这些权限：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Create a layout similar to the one here:![Recording and playing audio](img/B04321_09_09.jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于下面的布局：![录制和播放音频](img/B04321_09_09.jpg)
- en: Use `ImageViews` as the buttons and give them the IDs `record_button`, `stop_button`
    and `play_button`. Call the `TextView`, `text_view`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ImageViews` 作为按钮，并给它们分配 IDs `record_button`、`stop_button` 和 `play_button`。将
    `TextView` 命名为 `text_view`。
- en: 'Open the `MainActivity` and include these two fields:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity` 并包含这两个字段：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `onCreate()` method, add this `TextView`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法中添加这个 `TextView`：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add this file path:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这个文件路径：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then these `MediaRecorder` configurations:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加这些 `MediaRecorder` 配置：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each `ImageView` we created in the layout requires an `OnClickListener` within
    the `onCreate()` method as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局中创建的每个 `ImageView` 都需要在 `onCreate()` 方法中添加一个 `OnClickListener`，如下所示：
- en: 'ImageView `recordButton`:'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ImageView `recordButton`:'
- en: '[PRE22]'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'ImageView `stopButton`:'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ImageView `stopButton`:'
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'ImageView `playButton`:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ImageView `playButton`:'
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, add the `play()` method, which looks like this:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加 `play()` 方法，其外观如下：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can now run the app on a handset (as the stock emulators do not yet have
    the microphone functionality) and record and play back audio. The file `recording.3gp`
    can be found in the root directory of the SD card.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以在手机上运行该应用（因为库存模拟器还没有麦克风功能），录制和播放音频。文件 `recording.3gp` 可以在 SD 卡的根目录中找到。
- en: The `MediaRecorder` class makes light work of recording audio and can also be
    used to record video. Like the `MediaPlayer` class we used to play the audio back,
    this is similarly intuitive to use. The use of `MediaRecorder.release()` is important,
    as without it the system would continue to use resources. We only prepared and
    played the file here, but the `MediaPlayer` can do a lot more and it is well worth
    taking a look at its documentation, which can be found at [http://developer.android.com/reference/android/media/MediaPlayer.html](http://developer.android.com/reference/android/media/MediaPlayer.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaRecorder` 类简化了音频录制工作，也可以用来录制视频。就像我们用来播放音频的 `MediaPlayer` 类一样，这个类同样易于使用。使用
    `MediaRecorder.release()` 很重要，因为没有它，系统会继续使用资源。我们在这里只准备和播放了文件，但 `MediaPlayer` 可以做更多的事情，因此查看其文档是值得的，文档可以在
    [http://developer.android.com/reference/android/media/MediaPlayer.html](http://developer.android.com/reference/android/media/MediaPlayer.html)
    找到。'
- en: Again, we used `Environment.getExternalStorageDirectory()` to automatically
    select the user's preferred external storage device and although we took a different
    approach to the way we managed multimedia earlier in the chapter, either method
    can be applied in many situations. The `MediaRecorder` and `MediaPlayer` together
    provide a simple but powerful way to incorporate audio in our apps.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用了 `Environment.getExternalStorageDirectory()` 来自动选择用户首选的外部存储设备，尽管我们与本章早期管理多媒体的方式有所不同，但任何一种方法都可以应用于许多情况。`MediaRecorder`
    和 `MediaPlayer` 一起提供了一个简单但强大的方法，将音频整合到我们的应用中。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Multimedia such as audio and video have become an integral part of the way we
    use our mobile devices. Whether it is to create it or consume it, including multimedia
    functionality in our apps gives them greater appeal and usefulness. In this chapter,
    we saw how to incorporate native apps such as the camera into our own apps, saving
    us a great deal of coding in the process. We saw how to capture, record, and play
    back camera images, video, and finally audio.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 多媒体，如音频和视频，已成为我们使用移动设备方式的一个不可或缺的部分。无论是创建还是消费多媒体内容，在我们的应用中加入多媒体功能都能使它们更具吸引力和实用性。在本章中，我们学习了如何将原生应用，如相机，集成到我们自己的应用中，从而在过程中节省了大量编码工作。我们看到了如何捕捉、录制和回放相机图像、视频，以及最终音频。
- en: This concludes not just our exploration of Android 5 multimedia, but also, more
    or less, the programming aspect of this book, as the final chapter looks at how
    we can take our finished product and make it available to the world, and how to
    hopefully turn our hard work into a financial gain. There are one or two exercises
    in the chapter, as we will look at how to make our apps backwards compatible to
    reach a larger number of potential users, and we will return one last time to
    the Ancient Britain app to add a mobile advertisement to it using the Google AdMob
    service.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅结束了我们对Android 5多媒体的探索，而且也差不多结束了本书的编程部分，因为最后一章探讨了如何将我们的成品推向世界，以及如何将我们的辛勤工作转化为经济收益。本章中有一两个练习，我们将探讨如何使我们的应用向后兼容，以吸引更多的潜在用户，并且我们将最后一次回到Ancient
    Britain应用，使用Google AdMob服务为其添加移动广告。
