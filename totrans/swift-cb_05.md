超越标准库

苹果开源 Swift 的意图是提供一个跨平台、通用编程语言，它已经准备好使用。Swift 标准库提供了核心语言特性和常见集合类型。然而，这并不提供启动所需的所有内容。

因此，苹果提供了一个名为 **Foundation** 的框架，以帮助您执行核心 Swift 语言和标准库未涵盖的常见编程任务。

当你在苹果平台上开发时，你将使用的 Foundation 框架是 *封闭源代码*，这意味着底层代码不可访问，只有 API 是可见的。然而，当苹果开源 Swift 并使其对 Linux 可用时，提供 Foundation 框架变得必要。为此，苹果发布了一个开源的、基于 Swift 的 Foundation 版本，作为一个核心库，可在以下位置找到：[https://github.com/apple/swift-corelibs-foundation](https://github.com/apple/swift-corelibs-foundation)。

在本章中，我们将介绍以下食谱：

+   使用 Foundation 比较日期

+   使用 `URLSession` 获取数据

+   处理 JSON

+   处理 XML

# 技术要求

本章的所有代码都可以在这本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter05)

查看以下视频，了解代码的实际应用：[https://bit.ly/3cIcNUK](https://bit.ly/3cIcNUK)

# 使用 Foundation 比较日期

本食谱将专注于 Foundation 中一个非常广泛使用的领域，即日期和时间的操作和格式化。

我们将创建一个函数，该函数确定离圣诞节还有多长时间，并将此信息作为字符串返回，以便向用户显示。

## 准备工作

在新的 iOS playground 中创建一个新的 playground，并在 playground 的顶部导入 Foundation 框架：

[PRE0]

## 如何操作...

让我们创建一个函数，它会返回一个字符串，告诉我们离圣诞节还有多长时间，然后我们可以打印出来：

1.  定义函数：

[PRE1]

1.  在函数内部，获取当前的日历和时间区域：

[PRE2]

1.  获取当前日期和时间，并使用日历获取当前年份：

[PRE3]

1.  定义与圣诞节午夜对应的日期组件：

[PRE4]

1.  从这些组件获取一个 `Date` 对象：

[PRE5]

1.  如果我们已经过了今年的圣诞节，我们需要调整组件以指向下一年的圣诞节：

[PRE6]

1.  创建 `DateComponentsFormatter` 来格式化显示到圣诞节的剩余时间：

[PRE7]

1.  使用 `DateComponentFormatter` 返回从现在到下一个圣诞节的字符串：

[PRE8]

1.  在 `howLongUntilChristmas` 函数下方，使用此函数创建一个字符串，并打印结果：

[PRE9]

## 工作原理...

在**步骤1**中，我们创建了`howLongUntilChristmas`函数，然后在**步骤2**中，我们获取当前设置的日历和时间区域，因为它们将用于后续的日期计算：

[PRE10]

获取当前时区是显而易见的，但`Calendar`类型代表什么以及为什么需要检索它并不立即明显。

日期的表示方式并不像你想象的那样具有普遍性。某些时间组件大多是通用的，例如年份和天数的长度，因为它们与天文事件有关，例如地球围绕太阳公转一周所需的时间，以及地球围绕自身轴旋转一周所需的时间。然而，其他时间组件，如月份、周以及年份的编号，根植于创建它们的文明。

欧洲以及世界上大多数地区使用的日历被称为**格里高利日历**，由教皇格列高利十三世于1582年引入，取代了儒略日历。目前全球大约有40种不同的日历在使用中，包括格里高利日历、中国日历、希伯来日历、伊斯兰日历、波斯日历、埃塞俄比亚日历和巴厘岛Pawukon日历。

我们展示距离圣诞节还有多长时间的方式将取决于与用户相关的日历。这就是为什么我们要求用户提供当前日历，如果他们想要不同的表示方式，他们可以更改它。

我们接下来的任务是获取当前的日期和时间：

[PRE11]

在**步骤3**中，`Date`值类型的默认初始化器使用当前日期和时间作为其值。请注意，这个日期值是在创建时设置的；它不会随着当前日期和时间的更新而持续更新。

在这一步，我们获取下一个圣诞节的日期和时间。我们知道圣诞节的时、日、月，因此要构建圣诞节的日期，我们只需要知道年份。`Calendar`类中有一个名为`component`的方法，允许我们从`Date`值中检索特定组件：

[PRE12]

现在我们有了用户当前日历中的当前年份；我们可以用它来创建圣诞节的日期。

在**步骤4**中，我们创建了一个`DateComponents`实例，传递了日历、时区和我们将定义当前年份午夜12点的12月25日：

[PRE13]

在**步骤5**中，我们从`DateComponents`创建一个`Date`对象。这是一个可选类型，因为我们可能没有向组件提供足够的信息来生成日期；然而，由于我们知道我们已经提供了，我们可以强制展开这个可选类型：

[PRE14]

接下来，我们需要处理一个边缘情况；如果我们今年已经过了圣诞节怎么办？例如，让我们想象当前日期是2020年12月27日；我们正在尝试找到下一个圣诞节的日期，但如果我们使用当前年份，我们将得到2020年12月25日，这是刚刚过去的圣诞节。因此，在**步骤6**中，我们将当前年份加1，得到下一个圣诞节，即2021年12月25日：

[PRE15]

为了解决这个问题，我们检查今年的圣诞节是否在 `now` 之前；如果是，我们将年份组件提升到下一年，并从 `DateComponent` 重新创建圣诞节日期。

我们现在有了当前的 `Date` 和下一个圣诞节的 `Date`，Foundation 提供了通过使用 `DateComponentsFormatter` 来计算两个日期之间时间差并将其格式化为用户显示的功能。

在 *步骤 7* 中，我们创建 `DateComponentsFormatter`，并将 `unitStyle` 设置为 `full`，这将使用完整的单位名称提供字符串，而不使用缩写。我们配置我们想要如何将日期和时间分割以供显示，使用 `allowedUnits`：

[PRE16]

在 *步骤 8* 中，我们可以从格式化器中检索一个字符串，描述两个给定日期之间的时间，并使用提供给格式化器的设置。由于 `DateComponentsFormatter` 返回一个可选字符串，我们解包并返回它：

[PRE17]

我们的 `howLongUntilChristmas` 方法将提供一个描述距离圣诞节还有多久的字符串，然后我们可以将其打印出来。

## 参见

在 Foundation 中还有更多内容可以探索，因此请查看文档以了解更多功能：

+   Swift 3 对 Foundation 的文档：[http://swiftbook.link/docs/foundation](http://swiftbook.link/docs/foundation)

+   Foundation 的开源仓库：[https://github.com/apple/swift-corelibs-foundation](https://github.com/apple/swift-corelibs-foundation)

# 使用 URLSession 获取数据

每个值得构建的应用在某个时候都需要从互联网发送或接收信息，因此，网络支持是任何开发平台的关键部分。在 Swift 中，这种网络支持由 Foundation 框架提供。

当我们需要从互联网检索信息时，我们会向互联网上的一个服务器发送请求，然后该服务器发送一个响应，希望其中包含我们请求的信息。

在这个菜谱中，我们将学习如何使用 Foundation 框架发送网络请求并接收响应。

## 准备工作

了解 Foundation 提供的与网络相关的不同组件以及它们的功能是有帮助的：

+   `URL`：远程服务器上资源的地址。它包含有关服务器和资源在服务器上位置的信息。

+   `URLRequest`：表示将要发送到远程服务器的请求。定义了资源的 URL、请求的发送方式、以头信息形式存在的元数据，以及应与之一起发送的数据。

+   `URLSession`：管理与远程服务器的通信，保存该通信的配置，并创建和优化底层连接。

+   `URLSessionDataTask`：一个管理请求状态并传递响应的对象。

+   `URLResponse`：保存远程服务器响应的元数据。

## 如何做到这一点...

让我们使用这些网络工具从远程服务器检索一个图像：

1.  导入 `PlaygroundSupport` 并为这个游乐场设置无限执行：

[PRE18]

1.  导入Foundation并创建一个`URLSession`实例：

[PRE19]

1.  接下来，我们将构造一个请求远程图像的请求：

[PRE20]

1.  现在我们有了`URLRequest`，我们可以创建一个数据任务来从远程服务器检索图像：

[PRE21]

1.  我们将图像数据放入一个`UIImage`对象中以显示它。因此，我们需要导入`UIKit`框架，它提供了`UIImage`。所以，让我们在playground的顶部导入`UIKit`：

[PRE22]

1.  在完成处理程序中检查图像数据并创建一个`UIImage`对象：

[PRE23]

1.  在任务上调用`resume`以启动它：

[PRE24]

## 它是如何工作的...

让我们回顾一下之前提到的步骤，以了解我们在做什么：

[PRE25]

**Playgrounds** 从顶部到底部执行它们包含的代码。当达到playground页面的末尾时，playground停止执行。在我们的例子中，任务被创建并启动，但然后playground在图像完全检索之前就到达了页面的末尾，因为这是异步发生的。如果playground在这里停止执行，完成处理程序将永远不会执行，我们就看不到图像。在正常应用程序中这不是问题，因为应用程序在使用时持续运行；这仅仅是Swift playgrounds的工作方式。

为了解决这个问题，我们需要告诉playground我们不想它在到达页面末尾时停止执行，而应该在我们等待响应接收时无限期地运行。这是通过在*步骤1*中导入`PlaygroundSupport`框架并将当前`PlaygroundPage`的`needsIndefiniteExecution`设置为`true`来实现的。

[PRE26]

在*步骤2*中，当创建`URLSession`时，我们传入一个`URLSessionConfiguration`对象，它允许配置请求超时时间和缓存响应等。对于我们的目的，我们将只使用默认配置。

[PRE27]

在*步骤3*中，我们将从优秀的网络漫画*XKCD*（[http://xkcd.com](https://xkcd.com/)）请求图像。我们可以从一个字符串创建URL，然后从URL创建一个`URLRequest`请求。

[PRE28]

在*步骤4*中，我们不是直接创建数据任务；相反，我们要求我们的`URLSession`实例创建数据任务，并传入`URLRequest`和一个完成处理程序。一旦从远程服务器收到响应或发生某些错误，完成处理程序将被触发。

完成处理程序有三个输入，都是可选的：

+   `data: 数据`: 响应体中返回的数据；如果我们的请求成功，这将包含我们的图像数据。

+   `response: URLResponse`: 响应元数据，包括响应头。如果请求是通过HTTP/HTTPS进行的，那么这将是一个`HTTPURLResponse`，它将包含HTTP状态码。

+   `error: 错误`: 如果请求由于网络问题等失败，此值将包含错误，数据和响应值将为`nil`。如果请求成功，此错误值将为`nil`。

[PRE29]

在**步骤6**中，我们检查响应数据并将其转换为图像。为此，我们需要从数据中构建一个`UIImage`对象。`UIImage`是一个表示iOS上图像的类，可以在`UIKit`框架中找到。因此，我们也在沙盒的顶部导入了`UIKit`，就像我们在**步骤5**中所做的那样。

由于我们在这个示例中不打算对图像做任何处理，我们只是将其在沙盒预览中查看；如果将其分配给一个永远不会使用的值，编译器将会报错。因此，我们用下划线`_`替换正常的值赋值，这样就可以生成`UIImage`对象，而无需将其分配给任何东西。

[PRE30]

在**步骤7**中，我们已经创建了数据任务来检索图像，但我们需要实际启动任务来发出请求。为此，我们在任务上调用`resume`方法。

当我们运行沙盒时，你最终会看到图像值已经在沙盒的右侧侧栏中填充，你可以点击预览图标来查看已下载的图像：

![图片](img/9a63cd3c-f4ae-46ec-a564-9bbcbcbc458f.png)

图5.1 – 在沙盒时间轴中显示检索到的图像

## 相关内容

+   更多关于网络的信息可以在Apple的网络概述中找到：[http://swiftbook.link/docs/networking](http://swiftbook.link/docs/networking)

+   更多信息也可以在Apple的URL Session编程指南中找到：[http://swiftbook.link/docs/urlsession-guide](http://swiftbook.link/docs/urlsession-guide)

# 处理JSON

如上一次教程中所述，几乎每个应用程序在某个时候都需要与互联网交换信息，在上一次教程中，我们从远程服务器检索了一个图像。通常，你的应用程序需要检索更多样化的数据，可能涉及搜索结果或服务器上存储的共享状态信息。

这种信息可以用多种方式表示，但最常见的方式之一是**JavaScript对象表示法**（**JSON**），它是一种基于文本的结构，用于表示信息。一个JSON对象包含键值对，其中键是字符串，值可以是字符串、数字、布尔值、null、其他对象或数组。

例如，关于一个人的信息可以用这个JSON对象来表示：

[PRE31]

下面的例子是一个JSON对象的数组：

[PRE32]

基础库提供了从JSON数据中读取信息和将信息写入JSON数据的工具。在本教程中，我们将与一个基于JSON的**应用程序编程接口**（**API**）进行交互，以发送和接收信息。

## 准备工作

我们的目标是与 GitHub API 交互，并为这本书的仓库创建一个 issue。Git 和 GitHub 的完整解释超出了本书的范围；简单来说，它是一个存储你源代码版本副本的服务。与本书相关的资源存储在 GitHub 上的仓库中，GitHub 用户可以创建 *issue*，这些 issue 可以作为错误报告或功能请求。

如果你还没有一个账户，那么你需要注册一个 GitHub 账户：

1.  访问 [https://github.com](https://github.com)。

1.  填写你的详细信息并点击“注册 GitHub”。

一旦你创建了 GitHub 账户，你需要创建一个个人访问令牌，我们将使用它来验证对 GitHub API 的一些请求。要创建个人访问令牌，请按照以下步骤操作：

1.  前往设置页面 ([https://github.com/settings/tokens](https://github.com/settings/tokens)) 并点击“生成新令牌”。

1.  给令牌起一个名字，并勾选旁边的 repo：

![图片](img/3e4a5de2-cf58-4ddb-9e9d-8a7b33dcdeb8.png)

图 5.2 – 创建个人访问令牌

1.  点击页面底部的“生成令牌”。现在你将看到你新创建的个人访问令牌。

1.  复制这个令牌并将其粘贴到某个地方，因为我们稍后会需要它：

![图片](img/cf6a82d4-b33c-4222-b7aa-e722f882dccf.png)

图 5.3 – 生成的个人访问令牌

## 如何做到这一点...

要创建我们的 issue，我们首先将检索 Packt Publishing 的所有公共仓库，然后找到这本书的相关仓库。然后我们将在该仓库中创建一个新的 issue。

正如前面的配方中所述，我们需要一个 `URLSession` 对象来执行我们的请求，并且我们需要告诉游乐场在执行到游乐场的末尾时不要结束执行：

[PRE33]

我们的第一步是获取给定用户的所有公共仓库：

1.  让我们创建一个函数来做这件事：

[PRE34]

你会注意到，在创建 `URLRequest` 之后，我们设置了一个 HTTP 头部；这个特定的头部确保我们总是能够获取到 GitHub API 的第 3 版。

我们从 GitHub API 文档 ([https://developer.github.com/v3/](https://developer.github.com/v3/)) 中知道，这个响应数据是 JSON 格式。我们需要解析 JSON 数据，将其转换成我们可以使用的东西；输入 `JSONSerialization`。`JSONSerialization` 是 Foundation 框架的一部分，它提供了将 Swift 字典和数组转换为 JSON 数据（称为 **序列化**）以及将其转换回（称为 **反序列化**）的方法。

1.  让我们使用 `JSONSerialization` 将我们的 JSON 响应数据转换成更有用的东西：

[PRE35]

1.  现在，让我们通过执行我们的函数并传递 `PacktPublishing` 作为 GitHub 用户名来获取公共 Packt 仓库：

[PRE36]

执行后，打印输出应该看起来像这样：

![图片](img/444dcf8e-5bf3-4543-86fb-3b16f86ca331.png)

图 5.4 – 公共 GitHub 仓库 API 响应

`JSONSerializer`已将我们的JSON数据转换为熟悉的数组和字典，我们可以用正常方式检索所需的信息。JSON数据以`Any`类型反序列化，因为JSON的根可以是JSON对象或数组。

由于从前面的输出中我们知道响应的根是一个JSON对象的数组，我们需要将值从`Any`类型转换为`[String: Any]`类型的字典数组。这被称为从一种类型到另一种类型的**类型转换**，我们可以通过使用`as`关键字并指定新类型来实现。此关键字可以用三种不同的方式使用：

+   `as`将执行平凡的类型转换。如果现有类型与预期类型同义，则这是可能的，例如，从子类到超类的类型转换。

+   `as?`将条件执行类型转换，返回一个可选值。如果无法将值表示为预期类型，则该值将为`nil`。

+   `as!`将执行强制类型转换。如果无法将值表示为预期类型，您将遇到崩溃。

因此，让我们将反序列化数据转换为具有字符串键的字典数组，类型为`[[String: Any]]`：

[PRE37]

现在，我们有了API响应中存储库的字典数组，我们需要将其作为输入提供给此函数。提供异步工作结果的一个常见模式是提供一个完成处理程序作为参数。完成处理程序是一个闭包，可以在异步工作完成后执行。

由于我们想要提供的输出是存储库字典的数组，因此如果请求成功，我们将将其定义为闭包的输入，如果不成功，则为错误：

[PRE38]

现在，每当生成错误时，我们执行`completionHandler`，传入错误和`nil`作为结果值。此外，当我们有存储库结果时，我们执行完成处理程序，传入解析后的JSON和`nil`作为错误。

在前面的代码中，我们传递了一些新的错误，因此让我们定义这些错误：

[PRE39]

这改变了我们调用此`fetchRepos`函数的方式：

[PRE40]

现在我们已经检索了公共存储库的详细信息，我们将为此章节的存储库提交一个问题。这个问题可以是您对本书的任何反馈；它可以是评论、对新内容的建议，或者您可以告诉我您目前正在进行的Swift项目。

此对GitHub API的请求将针对您的用户账户进行身份验证，因此我们需要包括我们在本食谱开头创建的个人访问令牌的详细信息。有几种方式可以验证对GitHub API的请求，但最简单的是基本身份验证，这涉及到在请求头中添加一个授权字符串。

让我们创建一个方法来正确格式化个人访问令牌以进行身份验证：

[PRE41]

接下来，让我们创建一个提交问题的函数。从[https://developer.github.com/v3/issues/#create-an-issue](https://developer.github.com/v3/issues/#create-an-issue)的API文档中，我们可以看到，除非你有推送权限，否则你只能使用以下组件创建一个问题：

+   `title`（必需）

+   `body`（可选）

因此，我们的函数将接受这些信息作为输入，包括仓库名和用户名：

[PRE42]

创建问题是通过发送一个`POST`请求来实现的，问题信息作为JSON数据在请求体中提供。为了创建我们的请求，我们可以使用`JSONSerialization`，但这次我们将我们的预期JSON结构序列化为`Data`：

[PRE43]

与之前的API请求一样，我们需要一种方式来提供创建问题的结果，所以让我们提供一个完成处理程序，尝试反序列化响应，并将其提供给完成处理程序：

[PRE44]

成功创建问题的API响应提供了一个该问题的JSON表示。如果成功，我们的函数将返回这个表示，如果不成功，则返回一个错误。

现在我们已经有一个在仓库中创建问题的函数，是时候使用它来创建一个问题了：

[PRE45]

我将检查这些创建的问题，所以请就这本书提供真实的反馈。你发现内容如何？太详细了吗？不够详细？我遗漏了什么或没有完全解释清楚的地方？你有什么问题吗？这是你让我知道的机会。

## 还有更多...

当我们创建我们的完成处理程序时，我们给了它们两个输入：成功的结果（要么是仓库信息，要么是创建的问题）或者如果有失败，则是一个错误。这两个值都是可选的；一个将是`nil`，另一个有值。然而，这种约定并不是由语言强制执行的，使用这个函数的用户必须考虑它可能不是这种情况的可能性。如果`fetchRepos`函数在仓库和错误都带有非`nil`值时触发完成处理程序，函数的使用者应该怎么做？如果两者都是`nil`呢？

使用这个函数的用户，即使没有查看函数的内部代码，也不能确定这种情况不会发生，这意味着他们可能需要编写功能性和测试来处理这种可能性，即使这种情况可能永远不会发生。

如果我们能更准确地表示我们函数的预期行为，为用户提供清晰的可能的输出指示，不留任何歧义，那就更好了。我们知道从调用函数中会有两种可能的输出：它要么成功并返回相关值，要么失败并返回一个错误来指示失败的原因。

而不是使用可选值，我们可以使用枚举来表示这些可能性，Foundation框架提供了一个通用的枚举用于此目的，称为`Result`。

`Result`枚举有一个`success`情况，它有一个关联类型用于成功的结果，以及一个`failure`情况，它有一个关联类型用于相关的错误。这两个关联类型都被定义为泛型约束，其中失败类型需要遵守`Error`协议。

我们现在可以定义成功和失败状态，并使用关联值来保存每个状态相关的值，对于成功状态是仓库信息，对于失败状态是错误。

现在，让我们修改`fetchRepos`函数，使其在`completionHandler`中提供`Result`枚举：

[PRE46]

我们需要更新调用`fetchRepos`函数的方式：

[PRE47]

我们现在使用`switch`语句而不是`if/else`，并且我们得到一个额外的好处，编译器将确保我们已经覆盖了所有可能的结果。

在对`fetchRepos`函数进行了这次改进之后，我们可以类似地改进`createIssue`函数：

[PRE48]

最后，我们需要更新提供给`createIssue`函数的完成处理器的内容：

[PRE49]

处理JSON数据和从中提取相关信息可能会令人沮丧。考虑我们`fetchRepos`函数的JSON响应：

[PRE50]

如果我们想要获取第一个仓库所有者的用户名，我们需要反序列化JSON，然后有条件地解包多层嵌套以获取用户名字符串：

[PRE51]

只为了获取一个值，就需要进行大量的可选解包和类型转换！Swift的强类型特性与JSON的松散定义模式不太兼容，这就是为什么你需要做很多工作才能将松散类型的信息转换为强类型值。

为了帮助解决这些问题，有一些开源框架可供使用，这些框架使得在Swift中使用JSON变得更加容易。`SwiftyJSON`是一个流行的框架，可以在GitHub上找到，网址为[https://github.com/SwiftyJSON/SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON)。

我还构建了一个轻量级的JSON辅助工具，名为`JSONNode`，也可以在GitHub上找到，网址为[https://github.com/keefmoon/JSONnode](https://github.com/keefmoon/JSONnode)。

使用`JSONNode`，你可以用以下代码执行相同的任务，即检索第一个仓库的所有者的用户名：

[PRE52]

JSON中的信息，无论深度如何，都可以使用子脚本来在一行中检索。

# 处理XML

**XML**代表**可扩展标记语言**，是一种在网络上存储和传输数据时表示数据的方式。XML是一个非常灵活的格式，用于表示许多类型的数据。当前HTML的规范，它驱动着大部分的网页，是XML的一个实现。

在本食谱中，我们将关注的XML版本是**RSS**，代表**Really Simple Syndication**。RSS用于定义一组按时间顺序排列的可消化的内容；然后可以使用这些RSS源从多个不同的来源聚合内容。RSS通常用作新闻文章和播客的发布机制。

在本食谱中，我们将学习如何通过获取和解析BBC新闻RSS源来读取和写入XML数据。

## 准备工作

处理XML数据的功能由Foundation框架提供。然而，尽管帮助读取XML数据的类在苹果的所有平台上都可用，但帮助写入XML数据的类仅在macOS平台上可用。

这是一个不幸的疏忽，这意味着如果你需要在iOS应用中写入XML数据，你可能会需要寻找第三方助手或自己构建。我们将在本食谱的末尾调查第三方助手。

为了使用Foundation框架调查读取和写入XML，我们需要创建一个新的基于macOS的游乐场，而不是像本书中迄今为止所使用的那样基于iOS的游乐场。

按照常规创建一个新的Swift游乐场，但请从macOS选项卡中选择空白模板：

![](img/a958f28d-123d-464f-9a57-0a9754f2b163.png)

图5.5 – 选择模板

我们将要检索和解析的RSS源来自BBC新闻网站首页，其网址为[http://feeds.bbci.co.uk/news/rss.xml](http://feeds.bbci.co.uk/news/rss.xml)。

我们的第一步是从这个URL检索数据，这样我们就可以开始理解它了。由于我们之前已经介绍了通过网络检索信息，我将添加代码而不做进一步说明；查看本章中的*使用URLSession获取数据*食谱以获取更多信息：

[PRE53]

当你运行游乐场时，你会得到一个如下所示的输出：

[PRE54]

## 如何做到这一点...

整体结构对于看过HTML的人来说应该是熟悉的。除了定义XML版本和格式的第一行和第二行之外，信息都是通过开标签和关闭标签来结构的。考虑以下示例：

[PRE55]

开标签的名称定义了该XML元素的内容；在这种情况下，它是一个链接。然后是元素的内容，内容结束由一个带有其名称之前`/`字符的关闭标签定义。

除了这个简单的例子之外，XML元素还可以有属性，这些属性描述了关于元素内容的额外信息：

[PRE56]

这些在开标签内定义为键值对。

XML元素的内容可能是一个字符串，就像前面的例子一样，或者它可以是嵌套的子XML元素：

[PRE57]

最后，XML元素的内容可以是数据。这些数据可能以字符串的形式表示，尤其是如果字符串可能很长，并且可能包括换行符、特殊字符和其他可能被误认为是XML格式化部分组成部分的组件：

[PRE58]

现在我们已经检索到了XML，我们希望将其解析成有用的东西。我们将使用的解析器是由Foundation框架提供的，在iOS和macOS上可用。它被称为`XMLParser`。`XMLParser`是一个**SAX**解析器，代表**简单XML API**。SAX解析器的特点如下：

+   事件驱动

+   低内存开销

+   只保留相关信息

+   一次遍历

解析器接受一个代理对象，在解析文档时将事件信息传递给它。代理对象的责任是在XML数据解析时从这些代理回调中获取并保留相关信息，因为解析器不会保留解析后的数据。

我们将通过一个简单的示例来逐步了解解析器如何向代理报告事件。以下是我们要解析的简单XML：

[PRE59]

解析器将逐字符解析XML，每当触发一个事件时，代理都会被告知：

1.  第一个事件将是文档的开始，此时解析器将调用以下内容：

[PRE60]

在这里，我们可以进行任何所需的设置或状态重置。

1.  然后，解析器将遍历文档，直到它到达这个点：

[PRE61]

1.  解析器已经完成了第一个元素的开标签的解析，因此它触发了代理回调：

[PRE62]

1.  解析器继续进行，直到它到达这个点：

[PRE63]

1.  由于解析器已经看到了另一个起始标签，它将触发相同的代理回调，并提供有关这个新元素的信息：

[PRE64]

这次，由于元素具有属性信息，这些信息由代理回调在`attributeDict`字典中提供。

1.  解析器现在开始解析第一个`quote`元素的内容。在某个时刻，它将使用收集到的内容触发代理回调：

[PRE65]

然后，它将收集到的内容提供给了代理：

[PRE66]

解析器在内容中间停止并触发代理回调的原因是为了最大限度地利用内存。解析器必须将处理的所有数据保留在内存中，直到它可以传递给代理。因此，如果解析器确定内存使用量很高，它将收集到目前为止的内容并将其传递给代理。一旦完成，它就可以释放内存并重新收集进一步的内容。

在这个简单的示例中，解析器不会在单个代理回调中提供元素的所有内容是非常不可能的。然而，看到这样的例子是有用的，因为我们必须考虑到这种可能性，并且它将影响我们稍后实现代理的方式。

1.  解析器将触发相同的`foundCharacters`代理回调，直到将一个元素的所有内容都传递给代理：

[PRE67]

1.  然后，它提供自上次调用代理以来的新内容：

[PRE68]

1.  解析器现在处理第一个`quote`元素的关闭标签：

[PRE69]

1.  然后，它触发代理回调，表示元素的结束：

[PRE70]

解析器将继续以相同的方式处理下一个`quote`元素，触发相同的`didStartElement`序列，然后是一系列`foundCharacters`回调，最后以对`didEndElement`的调用结束。

1.  完成处理最后一个`quote`元素后，解析器将处理`quotes`元素的关闭标签：

[PRE71]

它将为`quotes`元素触发另一个`didEndElement`回调：

[PRE72]

1.  最后，解析器将触发一个代理回调，以指示文档解析完成：

[PRE73]

现在你已经了解了解析器如何向代理传递信息，我们可以回到我们的RSS示例。

## 它是如何工作的...

你会记得我们检索到的XML数据如下所示：

[PRE74]

从这个中，我们想要提取可用的新闻文章，因此让我们定义一个包含一些有用信息的`NewsArticle`模型，并将其放置在游乐场的顶部：

[PRE75]

由于所需的信息将分布在多个代理回调中，我们的代理需要跟踪它已接收到的信息，以便可以在适当的时间将其拼接在一起。

让我们创建一个类对象作为解析器的代理，并使其符合`XMLParserDelegate`：

[PRE76]

在前面的XML中，每篇新闻文章都包含在一个`item`元素中，因此我们的代理需要跟踪解析器何时为`item`元素提供内容，以便它可以忽略来自其他元素的内容：

[PRE77]

我们想要从`item`元素中提取的两个部分是标题和URL。正如我们从XML中可以看到的，标题包含在`title`元素内的`CDATA`包装器中，而URL包含在`link`元素中：

[PRE78]

因此，我们还需要跟踪解析器何时处于`link`元素中，并且当它处于链接元素内时，将接收到的内容附加到一个`String`属性中。同样，我们需要跟踪解析器何时处于`title`元素中，并且当它处于该元素时，将接收到的内容附加到一个`Data`属性中。

让我们在`RSSNewsArticleBuilder`对象中添加所需的额外属性：

[PRE79]

在`didStartElement`方法中，我们可以检查需要跟踪的新元素名称。我们还必须记得在开始相关元素时重置链接和标题属性。这样，我们就不会继续将针对下一个项目元素的文本内容附加到上一个元素的文本内容上：

[PRE80]

现在我们知道我们处于正确的元素中，我们可以实现两个`XMLParserDelegate`方法来接收相关内容并将其存储：

[PRE81]

在`didEndElement`方法中，我们需要更新我们的新属性，并且我们可以打印出我们从XML中检索到的值：

[PRE82]

现在我们已经提取了新闻文章的标题和URL，我们可以使用这些信息来创建一个`NewsArticle`模型对象。首先，让我们创建一个数组来保存我们将创建的`NewsArticle`对象：

[PRE83]

我们可以在`item`元素的末尾创建`NewsArticle`对象，因为那时我们将拥有所有相关内容：

[PRE84]

最后，当文档开始时，我们应该确保所有属性都已重置：

[PRE85]

现在我们已经完成了解析器代理，让我们回到我们的`fetchBBCNewsRSSFeed`函数：

[PRE86]

一旦检索到XML数据，我们将将其传递给`XMLParser`，设置代理，并告诉解析器解析数据：

[PRE87]

我们希望从这个函数提供文章作为输出，因此我们可以添加一个完成处理程序来提供新闻文章数组或错误：

[PRE88]

最后，我们可以调用此函数，它将检索RSS源，解析它，并返回一个新闻文章数组：

[PRE89]

## 还有更多...

Foundation还提供了写入XML数据的能力，尽管目前此功能仅在macOS上可用。

在检索到RSS源并创建我们的新闻文章后，让我们将此信息写入XML数据结构，并将其保存到磁盘。此XML将采用以下形式：

[PRE90]

在XML结构的根处是一个`articles`元素，它包含多个`article`元素，这些元素又包含一个`title`元素和一个`url`元素。

要写入XML数据，我们将使用`XMLDocument`和`XMLElement`对象重新创建前面的结构。一旦构建完成，`XMLDocument`对象的`xmlData`属性提供了文档作为数据。

让我们创建一个函数，从`NewsArticle`数组生成XML数据：

[PRE91]

我们创建每个`XMLElement`并将其作为子元素添加到我们想要嵌套的元素中。

如果你在这个故事板中构建它，请确保将此函数放在`RSSNewsArticleBuilder`之后，并在调用`fetchBBCNewsRSSFeed`的代码之前，因为这个函数很快就需要可用。

我们对`fetchBBCNewsRSSFeed`的调用将提供一个`NewsArticle`数组，因此我们可以将此传递给我们的新函数，以将此信息写入XML数据：

[PRE92]

现在我们有了数据，我们可以获取`documents`目录的URL，附加我们将创建的文件名，并将其写入磁盘：

[PRE93]

我们现在已检索到RSS源，从中提取了有用的信息，将这些信息写入自定义XML格式，并将其保存到磁盘。给自己鼓掌吧！

## 参见

更多关于`XMLParser`的信息可以在Apple的Foundation参考文档中找到，网址为[http://swiftbook.link/docs/xmlparser](http://swiftbook.link/docs/xmlparser)。

其他XML解析器也可用，它们可能比Apple的解析器有优势，包括能够在iOS上写入XML。它们如下所示：

+   RaptureXML: [https://github.com/ZaBlanc/RaptureXML](https://github.com/ZaBlanc/RaptureXML)

+   TBXML: [https://github.com/71squared/TBXML](https://github.com/71squared/TBXML)
