<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0; Watch Faces"><div class="titlepage" id="aid-26I9K2"><div><div><h1 class="title"><a id="ch10"/>Chapter 10.  Watch Faces </h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>"If you spend too much time thinking about a thing, you'll never get it done."
                                                                                                          - Bruce Lee</em></span>
</p></blockquote></div><p>We will begin this chapter with an introduction to the concept of watch faces and survey the Android Wear APIs available to help us develop them. We will then develop a simple interactive watch face that, in addition to showing time, responds to a tap action by showing the number of days elapsed in the year and the number remaining.</p><div class="note" title="Note"><h3 class="title"><a id="note18"/>Note</h3><p>The code accompanying this chapter is available for reference on GitHub (<a class="ulink" href="https://github.com/siddii/mastering-android-wear/tree/master/Chapter_10">https://github.com/siddii/mastering-android-wear/tree/master/Chapter_10</a>).</p><p>For the sake of brevity, code snippets are only included as needed. The reader is encouraged to download the referenced code from GitHub and follow along as they progress through the chapter.</p></div><div class="section" title="Telling the time"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec59"/>Telling the time</h1></div></div></div><p>When we speak of wearable devices, we are overwhelmingly referring to smartwatches, and a watch that does not tell the time isn't really much of a watch. It's like having a luxury yacht that features state of the art GPS technology but has trouble staying afloat. To strike a metaphor closer to home, consider a smartphone that has trouble functioning as a phone. (Wait! That's actually happened!)</p><div class="section" title="What is a watch face?"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec50"/>What is a watch face?</h2></div></div></div><p>The term <span class="emphasis"><em>watch face</em></span> is used to refer to the digital display of the current time on the wearable device so that the user can tell at a glance what the time is, in much the same way one does when wearing a watch.</p><p>Unlike a traditional watch, however, our wearable has a multitude of additional functionalities restricted only by its own internal memory and its communication with one or more paired handheld companion devices. So, showing the time on a wearable speaks to a far more sophisticated piece of software than, say, software that is written for a digital watch that may have a specific list of functionalities—time, date, dual time, and alarm mode to name a few.</p><p>Needless to say, the watch face is itself a replaceable component in a wearable. You can change it to one you like, as often as you like. Watch faces sporting an array of styles and shapes, some offering relevant contextual data, are available through the Android Wear companion app. A user simply selects an available watch face, either on the wearable or on the companion app, and the wearable device displays a preview of the watch face and allows the user to configure it. And if you can't find what you like, you can go ahead and write your own. Hence, this chapter. Our journey through implementing a watch face will feel more real when we get to build one in the next section. Let's first touch upon what a watch face design entails, and which Wear API classes come into play in the development of a watch face.</p></div><div class="section" title="Design considerations"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec51"/>Design considerations</h2></div></div></div><p>While Android Wear can be a huge help in your design efforts through the provision of various capabilities such as attractive colors, dynamic backgrounds, animations, and data integrations, there are non-API aspects to your design that must be considered. We list a few here that are widely embraced by the Android development community:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Think about what you want to show the user and how that fits into the context of a watch face. Too much information can distract.</li><li class="listitem">Your watch face should run reliably on square and circular devices.</li><li class="listitem">Provide a suitable implementation for the ambient mode. Users will thank you for not draining their wearable's battery life when it is idle.</li><li class="listitem">UI indicators (such as notification cards) should still show up without making it impossible to read the time.</li><li class="listitem">Enrich your watch face with intelligence to query and display context-sensitive information available through the companion handheld device. Remember, the companion app does all the heavy lifting, so your wearable app (in this case, your watch face) should delegate to the companion app any computation-intensive work or third-party data lookup, such as weather information.</li></ul></div><p>Let the user configure the watch face.</p><p>We highly recommend that you read through the <span class="emphasis"><em>Watch Faces for Android Wear</em></span> section, which will help as a design guide, available on the Android developers site (<a class="ulink" href="https://developer.android.com/design/wear/watchfaces.html">https://developer.android.com/design/wear/watchfaces.html</a>).</p></div><div class="section" title="Implementation considerations"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec52"/>Implementation considerations</h2></div></div></div><p>Considering the background images. The background image in interactive mode may be different than the one used in ambient mode. Furthermore, background images should be scaled down (as a one-time operation) if the device has a lower resolution than the image.</p><p>Application code that retrieves context-sensitive data should only run on as-needed basis, with results being stored for reuse when the watch face needs to be redrawn.</p><p>Updates to the watch face in ambient mode should be as simple as possible through the use of a limited set of colors, a fixed black background, and with only outlines being drawn to minimize work and conserve battery life.</p></div><div class="section" title="The watch face service"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec53"/>The watch face service</h2></div></div></div><p>A watch face is implemented as a service and packaged inside a wearable app. You already know that wearable apps are, in turn, packaged inside handheld apps. When users install such a handheld app that contains a wearable app with one or more watch faces, these watch faces then become selectable in the watch face picker on the wearable. They are also available on the handheld device in the Android Wear companion app. When one of the watch faces is selected (either on the handheld or the wearable's picker), the watch face is shown on the wearable device, which invokes the service callback methods as required through the life cycle of the watch face.</p><p>To create watch face implementations, we extend the classes provided in the Wearable support library (the <code class="literal">android.support.wearable.watchface</code> package). When a watch face becomes active, the system invokes the methods in its service class when various events occur, such as a change in time, a switch to ambient mode, and a notification alert. The implementations of the corresponding handlers then respond by drawing the watch face using the updated time or the notification data or whatever other data the event may consume. Key methods that may need to be implemented in a watch face service include following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">onCreate</code> method</li><li class="listitem">The <code class="literal">onPropertiesChanged </code>method</li><li class="listitem">The <code class="literal">onTimeTick</code> method</li><li class="listitem">The <code class="literal">onAmbientModeChanged</code> method</li><li class="listitem">The <code class="literal">onDraw</code> method</li><li class="listitem">The <code class="literal">onVisibilityChanged</code> method</li></ul></div><p>Check out the Wearable support library at <a class="ulink" href="https://developer.android.com/reference/android/support/wearable/watchface/package-summary.html">https://developer.android.com/reference/android/support/wearable/watchface/package-summary.html</a> for a close look at the object model of the available watch face service classes.</p><p>Once implemented, the watch face service must be registered in the manifest (<code class="literal">AndroidManifest.xml</code>) file of the wearable app. This is how the system makes the watch face available in both the Android Wear companion app and the watch face picker on the wearable device when a user installs the app.</p></div><div class="section" title="Interactive watch faces"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec54"/>Interactive watch faces</h2></div></div></div><p>Watch faces do support limited user interaction. A single tap gesture at a given location on the watch face is accepted as long as it does not conflict with another UI element also listening for that gesture. In our sample code in the next section, we support a tap gesture that shows the number of days elapsed in the current year, as well as the number of days remaining.</p><p>Handling tap events involve implementing the <code class="literal">setWatchFaceStyle</code> method available in all extensions of the <code class="literal">WatchFaceService.Engine</code> class. The app informs the system that the watch face receives tap events, as shown in the following snippet:</p><pre class="programlisting">setWatchFaceStyle(new WatchFaceStyle.Builder(mService) 
  .setAcceptsTapEvents(true) 
 
  // other style customizations 
  .build()); 
</pre></div><div class="section" title="Performance considerations"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec55"/>Performance considerations</h2></div></div></div><p>Conserving power is quite critical in the context of watch faces because a watch face is always active. Here are a few best practices put forward by the Wear development community with respect to watch face development:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Ensure that the watch face only performs actions when it is active. Use the <code class="literal">onVisibilityChanged</code> and <code class="literal">isVisible</code> methods of the <code class="literal">WatchFaceService.Engine</code> class to determine that.</li><li class="listitem">Avoid using the <code class="literal">WearableListenerService</code> element to listen for events, as it is called whether or not a watch face is active. Rather, use listeners registered with the <code class="literal">DataApi.addListener</code> element.</li><li class="listitem">Keep an eye on the actual power consumed by our wearable app. The Android Wear companion app lets us see how much battery different processes on the wearable device consume.</li><li class="listitem">When using animations, take care to lower the frame rate. 30 frames per second are sufficient for a smooth animation experience. We should use animations as little as possible, and when we do use them, we should use every opportunity to let the CPU sleep between runs of our animation. Every idle cycle contributes to a larger effort at conserving battery life.</li><li class="listitem">Keep the bitmaps small. Where it makes sense, combine multiple bitmaps into one. Reducing the number of graphic assets we draw contributes to power savings.</li><li class="listitem">Use the <code class="literal">Engine.onDraw</code> method exclusive to perform drawing operations. Move any work that loads resources, resizes images, or performs computations external to drawing, out of the <code class="literal">onDraw</code> method. Consider locating such code in the <code class="literal">onCreate</code> method instead.</li></ul></div></div></div></div>
<div class="section" title="Let's build a watch face" id="aid-27GQ61"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec60"/>Let's build a watch face</h1></div></div></div><p>It's time to see the concepts, introduced previously, in action. We will build a simple watch face that shows the time using a fairly standard hour, minutes, and seconds display. Tapping the watch face will show the number of days that have elapsed in the current year. A second tap will show the number of days remaining in the current year.</p><p>In the subsections that follow, we will define a <code class="literal">WatchFaceService</code> class that extends the API <code class="literal">CanvasWatchFaceService</code> class and overrides the relevant event handlers that pertain to our sample application.</p><div class="section" title="The Android manifest file"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec56"/>The Android manifest file</h2></div></div></div><p>We begin by declaring the <code class="literal">TodayWatchFaceService</code> service and the <code class="literal">WatchFaceConfigActivity</code> activity, which helps with selecting a background color for the watch:</p><pre class="programlisting">&lt;!— Required to act as a custom watch face. —&gt; 
&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt; 
 
&lt;service 
  android:name=".TodayWatchFaceService" 
  android:label="@string/digital_name" 
  android:permission="android.permission.BIND_WALLPAPER" &gt; 
  &lt;meta-data 
    android:name="android.service.wallpaper" 
    android:resource="@xml/watch_face" /&gt; 
 
  &lt;meta-data 
    android:name="com.google.android.wearable.watchface.preview" 
    android:resource="@drawable/preview_digital" /&gt; 
 
  &lt;meta-data 
    android:name="com.google.android.wearable.watchface.preview_circular" 
    android:resource="@drawable/preview_digital_circular" /&gt; 
 
  &lt;meta-data 
    android:name="com.google.android.wearable.watchface.companionConfigurationAction" 
    android:value="com.siddique.androidwear.today.CONFIG_DIGITAL"/&gt; 
 
  &lt;meta-data 
    android:name="com.google.android.wearable.watchface.wearableConfigurationAction" 
    android:value="com.siddique.androidwear.today.CONFIG_DIGITAL"/&gt;  
  &lt;intent-filter&gt; 
    &lt;action android:name="android.service.wallpaper.WallpaperService" /&gt; 
 
    &lt;category android:name="com.google.android.wearable.watchface.category.WATCH_FACE" /&gt; 
  &lt;/intent-filter&gt; 
&lt;/service&gt; 
 
&lt;activity 
  android:name=".WatchFaceConfigActivity" 
  android:label="@string/digital_config_name" &gt; 
  &lt;intent-filter&gt; 
    &lt;action android:name="com.siddique.androidwear.today.CONFIG_DIGITAL" /&gt; 
 
      &lt;category android:name="com.google.android.wearable.watchface.category.WEARABLE_CONFIGURATION" /&gt; 
      &lt;category android:name="android.intent.category.DEFAULT" /&gt; 
    &lt;/intent-filter&gt; 
&lt;/activity&gt; 
</pre></div></div>
<div class="section" title="The TodayWatchFace service" id="aid-28FAO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec61"/>The TodayWatchFace service</h1></div></div></div><p>Before we take a closer look at the implementation of the <code class="literal">TodayWatchFaceService</code> class, let's run our sample code to see how it behaves so that we can observe the app from a user standpoint.</p><p>Note that long pressing on the device screen causes the installed watch faces to get displayed:</p><p>
</p><div class="mediaobject"><img src="../Images/image00216.jpeg" alt="The TodayWatchFace service"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Note that a <span class="emphasis"><em>gear</em></span> icon shows up underneath the label, the <code class="literal">TodayWatchFace</code> activity, of our custom watch face because we have a configuration activity defined for the <code class="literal">WatchFace</code> element. Let's select our custom watch face. Here's how it renders. By default, it shows the day of the week and the full date with the <span class="emphasis"><em>seconds</em></span> colon blinking:</p><p>
</p><div class="mediaobject"><img src="../Images/image00217.jpeg" alt="The TodayWatchFace service"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Tapping once on the watch face shows the day of the year, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="../Images/image00218.jpeg" alt="The TodayWatchFace service"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Tapping a second time on the watch face shows the number of days left in the year.</p><p>
</p><div class="mediaobject"><img src="../Images/image00219.jpeg" alt="The TodayWatchFace service"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Tapping again takes us back to the default display.</p></div>
<div class="section" title="The TodayWatchFaceService class" id="aid-29DRA1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec62"/>The TodayWatchFaceService class</h1></div></div></div><p>The <code class="literal">TodayWatchFaceService</code> class does all of the work, including setting the layout, reading the configuration values, and painting the UI for every tick of the second. It isn't realistic to discuss over 700 lines of code in this chapter. So, we'll look at important snippets taken from this class definition:</p><pre class="programlisting">public class TodayWatchFaceService extends CanvasWatchFaceService { 
  @Override 
  public Engine onCreateEngine()  
  { 
    return new Engine(); 
  } 
  private class Engine extends CanvasWatchFaceService.Engine  implements DataApi.DataListener,  GoogleApiClient.ConnectionCallbacks,  GoogleApiClient.OnConnectionFailedListener  
  { 
    ... 
  } 
} 
</pre><div class="note" title="Note"><h3 class="title"><a id="tip19"/>Tip</h3><p>As always, the sample source code for this chapter, and all others, is available at the GitHub link provided at the beginning of each chapter. The source code hosted at GitHub is our primary reference for a thorough understanding of how this service works.</p></div></div>
<div class="section" title="The onTimeTick method" id="aid-2ACBS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec63"/>The onTimeTick method</h1></div></div></div><p>This method is called for every time tick. We invalidate the UI (see the call to the <code class="literal">invalidate()</code> method) to force a call to the <code class="literal">onDraw</code> method. In effect, we re-render the UI every 500 milliseconds in normal mode and every minute in ambient or mute mode:</p><pre class="programlisting">@Override 
public void onTimeTick()  
  { 
    super.onTimeTick(); 
    if (Log.isLoggable(TAG, Log.DEBUG))  
    { 
      Log.d(TAG, "onTimeTick: ambient = " + isInAmbientMode()); 
    } 
  invalidate(); 
} 
</pre></div>
<div class="section" title="Drawing the watch face" id="aid-2BASE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec64"/>Drawing the watch face</h1></div></div></div><p>The <code class="literal">onDraw()</code> method paints the watch face with all necessary information. Follow the comments in the code to make complete sense of the following code snippet:</p><pre class="programlisting">@Override 
public void onDraw(Canvas canvas, Rect bounds)  
{ 
  long now = System.currentTimeMillis(); 
  mCalendar.setTimeInMillis(now); 
  mDate.setTime(now); 
  boolean is24Hour =  DateFormat.is24HourFormat(TodayWatchFaceService.this); 
 
  // Show colons for the first half of each second so the colons blink on when the time 
  // updates. 
  mShouldDrawColons = (System.currentTimeMillis() % 1000) &lt; 500; 
 
  // Draw the background. 
  canvas.drawRect(0, 0, bounds.width(), bounds.height(), mBackgroundPaint); 
 
  // Draw the hours. 
  float x = mXOffset; 
  String hourString; 
  if (is24Hour)  
  { 
    hourString =  formatTwoDigitNumber(mCalendar.get(Calendar.HOUR_OF_DAY));   }  
  else  
  { 
    int hour = mCalendar.get(Calendar.HOUR); 
    if (hour == 0)  
    { 
      hour = 12; 
    } 
    hourString = String.valueOf(hour); 
  } 
  canvas.drawText(hourString, x, mYOffset, mHourPaint); 
  x += mHourPaint.measureText(hourString); 
 
  // In ambient and mute modes, always draw the first colon.  Otherwise, draw the 
  // first colon for the first half of each second. 
  if (isInAmbientMode() || mMute || mShouldDrawColons)  
  { 
    canvas.drawText(COLON_STRING, x, mYOffset, mColonPaint); 
  } 
  x += mColonWidth; 
 
  // Draw the minutes. 
  String minuteString =  formatTwoDigitNumber(mCalendar.get(Calendar.MINUTE)); 
  canvas.drawText(minuteString, x, mYOffset, mMinutePaint); 
  x += mMinutePaint.measureText(minuteString); 
 
  // In unmuted interactive mode, draw a second blinking colon  followed by the seconds. 
  // Otherwise, if we're in 12-hour mode, draw AM/PM 
  if (!isInAmbientMode() &amp;&amp; !mMute)  
  { 
    if (mShouldDrawColons)  
    { 
      canvas.drawText(COLON_STRING, x, mYOffset, mColonPaint); 
    } 
  x += mColonWidth; 
  canvas.drawText(formatTwoDigitNumber(mCalendar.get(Calendar.SECOND)), x, mYOffset, mSecondPaint); 
  }  
  else if (!is24Hour)  
  { 
    x += mColonWidth; 
    canvas.drawText(getAmPmString(  mCalendar.get(Calendar.AM_PM)), x, mYOffset, mAmPmPaint); 
  } 
 
  // Only render the day of week and date if there is no peek card, so they do not bleed 
  // into each other in ambient mode. 
  if (getPeekCardPosition().isEmpty())  
  { 
    if (tapCount == 0)  
    { 
      // Day of week 
      canvas.drawText(mDayOfWeekFormat.format(mDate), mXOffset, mYOffset + mLineHeight, mDatePaint); 
      canvas.drawText(mDateFormat.format(mDate), mXOffset, mYOffset + mLineHeight * 2, mDatePaint); 
    }  
    else if (tapCount == 1)  
    { 
      // Day of Year 
      canvas.drawText("Day of year", mXOffset, mYOffset + mLineHeight, mDatePaint); 
      canvas.drawText(Integer.toString(TodayUtil.getDayOfYear()), mXOffset, mYOffset + mLineHeight * 2, mDatePaint); 
    } 
    else if (tapCount == 2)  
    { 
      // Days left in Year 
       canvas.drawText("Days left in year", mXOffset, mYOffset + mLineHeight, mDatePaint); 
     canvas.drawText(Integer.toString(TodayUtil.getDaysLeftInYear()), mXOffset, mYOffset + mLineHeight * 2, mDatePaint); 
    } 
  } 
} 
</pre></div>
<div class="section" title="Ambient mode" id="aid-2C9D01"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec65"/>Ambient mode</h1></div></div></div><p>Ambient mode, in contrast with interactive mode, is the energy saver mode. Depending on the watch and its configuration, an operation such as a click on a dial renders the watch faces in ambient mode:</p><p>
</p><div class="mediaobject"><img src="../Images/image00220.jpeg" alt="Ambient mode"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>It may not be obvious at a glance because our app is so simple, but if we compare the preceding screenshot with the screenshot of the watch face in interactive mode, we will see that the seconds don't show up and the colon symbol doesn't blink.</p><p>Here's the listener that gets called when the watch face switches from interactive mode to ambient mode:</p><pre class="programlisting">@Override 
public void onAmbientModeChanged(boolean inAmbientMode)  
{ 
  super.onAmbientModeChanged(inAmbientMode); 
  if (Log.isLoggable(TAG, Log.DEBUG))  
  { 
    Log.d(TAG, "onAmbientModeChanged: " + inAmbientMode); 
  } 
  adjustPaintColorToCurrentMode(mBackgroundPaint, mInteractiveBackgroundColor,WatchFaceUtil.COLOR_VALUE_DEFAULT_AND_AMBIENT_BACKGROUND); 
  adjustPaintColorToCurrentMode(mHourPaint, mInteractiveHourDigitsColor,WatchFaceUtil.COLOR_VALUE_DEFAULT_AND_AMBIENT_HOUR_DIGITS); 
  adjustPaintColorToCurrentMode(mMinutePaint, mInteractiveMinuteDigitsColor, WatchFaceUtil.COLOR_VALUE_DEFAULT_AND_AMBIENT_MINUTE_DIGITS); 
 
  // Actually, the seconds are not rendered in the ambient mode, so we could pass just any 
  // value as ambientColor here. 
  adjustPaintColorToCurrentMode(mSecondPaint,  mInteractiveSecondDigitsColor, WatchFaceUtil.COLOR_VALUE_DEFAULT_AND_AMBIENT_SECOND_DIGITS); 
 
  if (mLowBitAmbient)  
  { 
    boolean antiAlias = !inAmbientMode; 
    mDatePaint.setAntiAlias(antiAlias); 
    mHourPaint.setAntiAlias(antiAlias); 
    mMinutePaint.setAntiAlias(antiAlias); 
    mSecondPaint.setAntiAlias(antiAlias); 
    mAmPmPaint.setAntiAlias(antiAlias); 
    mColonPaint.setAntiAlias(antiAlias); 
  } 
  invalidate(); 
  // Whether the timer should be running depends on whether we're in ambient mode (as well 
  // as whether we're visible), so we may need to start or stop the timer. 
  updateTimer(); 
} 
</pre></div>
<div class="section" title="Customizing the watch face" id="aid-2D7TI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec66"/>Customizing the watch face</h1></div></div></div><p>We did not want to take this example too far, so in the interest of simplicity, we decided to provide a configurable watch face background color. Clicking on the gear icon from the watch face settings lets us pick the background color, as shown here:</p><p>
</p><div class="mediaobject"><img src="../Images/image00221.jpeg" alt="Customizing the watch face"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><div class="section" title="The WatchFaceConfigActivity class"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec57"/>The WatchFaceConfigActivity class</h2></div></div></div><p>The <code class="literal">WatchFaceConfigActivity</code> class renders a simple color picker to determine the background color:</p><pre class="programlisting">public class WatchFaceConfigActivity extends Activity implements WearableListView.ClickListener, WearableListView.OnScrollListener  
{ 
  @Override 
  protected void onCreate(Bundle savedInstanceState)  
  { 
    super.onCreate(savedInstanceState); 
    setContentView(R.layout.activity_digital_config); 
    mHeader = (TextView) findViewById(R.id.header); 
    WearableListView listView = (WearableListView) findViewById(R.id.color_picker); 
    BoxInsetLayout content = (BoxInsetLayout) findViewById(R.id.content); 
  } 
} 
</pre><p>Here's a screenshot of the watch face when we select a background color of navy blue:</p><p>
</p><div class="mediaobject"><img src="../Images/image00222.jpeg" alt="The WatchFaceConfigActivity class"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>We've just scratched the surface of watch face design and development, but hopefully, the basic treatment here has given us a taste of the work involved and piqued our interest. We could get a lot more creative in displaying relevant contextual information for a given day, such as the number of to-do items, weather-related information, and so on. As with all knowledge acquisition, we see that as we get done, we're really just getting started.</p></div></div>
<div class="section" title="Summary" id="aid-2E6E41"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Summary</h1></div></div></div><p>In this chapter, we introduced the concept of watch faces and looked at their design, implementation, and performance considerations. We then surveyed the <code class="literal">WatchFaceService.Engine</code> class before implementing a simple interactive watch face and seeing these concepts and API classes in action.</p></div></body></html>