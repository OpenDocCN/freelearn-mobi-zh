["```swift\n-(void) setupWorld {\n    // Define the gravity vector.\n    b2Vec2 gravity;\n    gravity.Set(0.0f, 0.0f);\n\n    // Construct a world object\n    world = new b2World(gravity);\n\n    world->SetAllowSleeping(true);\n    world->SetContinuousPhysics(true);\n\n    // Create contact listener\n    contactListener = new BRContactListener();\n    world->SetContactListener(contactListener);\n}\n```", "```swift\n-(void) buildEdges {\n    // Define the wall body\n    b2BodyDef wallBodyDef;\n    wallBodyDef.position.Set(0, 0);\n\n    // Create a body for the walls\n    wallBody = world->CreateBody(&wallBodyDef);\n\n    // This defines where the bottom edge of the HUD is\n    float maxY = 424;\n\n    // Define the 4 corners of the playfield\n    b2Vec2 bl(0.0f, 0.0f); // bottom left corner\n    b2Vec2 br(size.width/PTM_RATIO,0); // bottom right\n    b2Vec2 tl(0,maxY/PTM_RATIO); // top left corner\n    b2Vec2 tr(size.width/PTM_RATIO,maxY/PTM_RATIO); // top right\n\n    b2EdgeShape bottomEdge;\n    b2EdgeShape leftEdge;\n    b2EdgeShape rightEdge;\n    b2EdgeShape topEdge;\n\n    // Set the edges\n    bottomEdge.Set(bl, br);\n    leftEdge.Set(bl, tl);\n    rightEdge.Set(br, tr);\n    topEdge.Set(tl, tr);\n\n    // Define the fixtures for the walls\n    wallBody->CreateFixture(&topEdge,0);\n    wallBody->CreateFixture(&leftEdge,0);\n    wallBody->CreateFixture(&rightEdge,0);\n\n    // Keep a reference to the bottom wall\n    bottomGutter = wallBody->CreateFixture(&bottomEdge,0);\n}\n```", "```swift\n-(void) buildBallAtStartingPosition:(CGPoint)startPos\n                 withInitialImpulse:(b2Vec2)impulse {\n    // Create sprite and add it to layer\n    PhysicsSprite *ball = [PhysicsSprite\n                spriteWithSpriteFrameName:@\"ball.png\"];\n    ball.position = startPos;\n    ball.tag = kBall;\n    [bricksheet addChild:ball z:50];\n\n    // Create ball body\n    b2BodyDef ballBodyDef;\n    ballBodyDef.type = b2_dynamicBody;\n    ballBodyDef.position.Set(startPos.x/PTM_RATIO, \n                             startPos.y/PTM_RATIO);\n    ballBodyDef.userData = ball;\n    b2Body *ballBody = world->CreateBody(&ballBodyDef);\n\n    // Link the body to the sprite\n    [ball setPhysicsBody:ballBody];\n\n    //Create a circle shape\n    b2CircleShape circle;\n    circle.m_radius = 7.0/PTM_RATIO;\n\n    //Create fixture definition and add to body\n    b2FixtureDef ballFixtureDef;\n    ballFixtureDef.shape = &circle;\n    ballFixtureDef.density = 1.0f;\n    ballFixtureDef.friction = 0.0f;\n    ballFixtureDef.restitution = 1.0f;\n    ballBody->CreateFixture(&ballFixtureDef);\n    ballBody->ApplyLinearImpulse(impulse,\n                                 ballBody->GetPosition());\n    isBallInPlay = YES;\n}\n```", "```swift\n-(void) newBall {\n    [self buildBallAtStartingPosition:ccp(150,200)\n                   withInitialImpulse:b2Vec2(0.2,-1.5)];\n}\n```", "```swift\n-(void)update:(ccTime)dt {\n    // Step the world forward\n  world->Step(dt, 10, 10);\n\n    // Iterate through all bodies in the world\n    for(b2Body *b = world->GetBodyList(); b;b=b->GetNext()) {\n    if (b->GetUserData() != NULL) {\n            // Get the sprite for this body\n      PhysicsSprite *sprite = \n(PhysicsSprite*)b->GetUserData();\n\n            // Speed clamp for balls\n            if (sprite.tag == kBall) {\n        static int maxSpeed = 15;\n\n        b2Vec2 velocity = b->GetLinearVelocity();\n        float32 speed = velocity.Length();\n\n        if (speed > maxSpeed) {\n          b->SetLinearDamping(0.5);\n        } else if (speed < maxSpeed) {\n          b->SetLinearDamping(0.0);\n        }\n      }\n    }\n  }\n}\n```", "```swift\n#import \"Box2D.h\"\n#import <vector>\n#import <algorithm>\n\nstruct BRContact {\n  b2Fixture *fixtureA;\n  b2Fixture *fixtureB;\n  bool operator ==(const BRContact& other) const\n  {\n    return (fixtureA == other.fixtureA) &&\n               (fixtureB == other.fixtureB);\n  }\n};\n\nclass BRContactListener : public b2ContactListener {\n\npublic:\n  std::vector<BRContact>_contacts;\n\n  BRContactListener();\n  ~BRContactListener();\n\n  virtual void BeginContact(b2Contact* contact);\n  virtual void EndContact(b2Contact* contact);\n  virtual void PreSolve(b2Contact* contact,\n                        const b2Manifold* oldManifold);\n  virtual void PostSolve(b2Contact* contact,\n                        const b2ContactImpulse* impulse);\n};\n```", "```swift\n#import \"BRContactListener.h\"\n\nBRContactListener::BRContactListener() : _contacts() {\n}\n\nBRContactListener::~BRContactListener() {\n}\n\nvoid BRContactListener::BeginContact(b2Contact* contact) {\n  // We need to copy the data because b2Contact is reused.\n  BRContact brContact = { contact->GetFixtureA(),\n                            contact->GetFixtureB() };\n  _contacts.push_back(brContact);\n}\n\nvoid BRContactListener::EndContact(b2Contact* contact) {\n  BRContact brContact = { contact->GetFixtureA(),\n                            contact->GetFixtureB() };\n  std::vector<BRContact>::iterator pos;\n  pos = std::find(_contacts.begin(), _contacts.end(),\n                    brContact);\n  if (pos != _contacts.end()) {\n    _contacts.erase(pos);\n  }\n}\n\nvoid BRContactListener::PreSolve(b2Contact* contact,\n                    const b2Manifold* oldManifold) {\n}\n\nvoid BRContactListener::PostSolve(b2Contact* contact,\n                    const b2ContactImpulse* impulse) {\n}\n```", "```swift\n  std::vector<b2Body *>toDestroy;\n  std::vector<BRContact>::iterator pos;\n  for (pos = contactListener->_contacts.begin();\n      pos != contactListener->_contacts.end(); pos++) {\n        BRContact contact = *pos;\n\n        // Get the bodies involved in this contact\n        b2Body *bodyA = contact.fixtureA->GetBody();\n        b2Body *bodyB = contact.fixtureB->GetBody();\n\n        // Get the sprites attached to these bodies\n        PhysicsSprite *spriteA =\n                    (PhysicsSprite*)bodyA->GetUserData();\n        PhysicsSprite *spriteB =\n                    (PhysicsSprite*)bodyB->GetUserData();\n\n        // Look for lost ball (off the bottom)\n        if (spriteA.tag == kBall &&\n            contact.fixtureB ==bottomGutter) {\n            if (std::find(toDestroy.begin(),\n                          toDestroy.end(), bodyA) ==\n                          toDestroy.end()) {\n                toDestroy.push_back(bodyA);\n            }\n        }\n        // Look for lost ball (off the bottom)\n        else if (contact.fixtureA == bottomGutter &&\n                 spriteB.tag == kBall) {\n            if (std::find(toDestroy.begin(),\n                          toDestroy.end(), bodyB) ==\n                          toDestroy.end()) {\n                toDestroy.push_back(bodyB);\n            }\n        }\n```", "```swift\n    // Destroy any bodies & sprites we need to get rid of\n    std::vector<b2Body *>::iterator pos2;\n    for(pos2 = toDestroy.begin(); pos2 != toDestroy.end();\n                                            ++pos2) {\n        b2Body *body = *pos2;\n        if (body->GetUserData() != NULL) {\n            PhysicsSprite *sprite =\n                    (PhysicsSprite*)body->GetUserData();\n            [self spriteDestroy:sprite];\n        }\n        world->DestroyBody(body);\n    }\n```", "```swift\n-(void) spriteDestroy:(PhysicsSprite*)sprite {\n    switch (sprite.tag) {\n        case kBall:\n            [[SimpleAudioEngine sharedEngine]\n                                playEffect:SND_LOSEBALL];\n            [sprite removeFromParentAndCleanup:YES];\n            [self loseLife];\n            break;\n  }\n}\n```", "```swift\n-(void) buildPaddleAtStartingPosition:(CGPoint)startPos {\n    // Create the paddle\n    paddle = [PhysicsSprite spriteWithSpriteFrameName:\n                                        @\"paddle.png\"];\n    paddle.position = startPos;\n    paddle.tag = kPaddle;\n    [bricksheet addChild: paddle];\n\n    // Create paddle body\n    b2BodyDef paddleBodyDef;\n    paddleBodyDef.type = b2_dynamicBody;\n    paddleBodyDef.position.Set(startPos.x/PTM_RATIO, \n                               startPos.y/PTM_RATIO);\n    paddleBodyDef.userData = paddle;\n    paddleBody = world->CreateBody(&paddleBodyDef);\n\n    // Connect the body to the sprite\n    [paddle setPhysicsBody:paddleBody];\n\n    // Build normal size fixure\n    [self buildPaddleFixtureNormal];\n\n    // Restrict paddle along the x axis\n    b2PrismaticJointDef jointDef;\n    b2Vec2 worldAxis(1.0f, 0.0f);\n    jointDef.collideConnected = true;\n    jointDef.Initialize(paddleBody, wallBody,\n            paddleBody->GetWorldCenter(), worldAxis);\n    world->CreateJoint(&jointDef);\n}\n```", "```swift\n-(void) buildPaddleFixtureNormal {\n    // Define the paddle shape\n    b2PolygonShape paddleShape;\n    int num = 8;\n    b2Vec2 verts[] = {\n        b2Vec2(31.5f / PTM_RATIO, -7.5f / PTM_RATIO),\n        b2Vec2(31.5f / PTM_RATIO, -0.5f / PTM_RATIO),\n        b2Vec2(30.5f / PTM_RATIO, 0.5f / PTM_RATIO),\n        b2Vec2(22.5f / PTM_RATIO, 6.5f / PTM_RATIO),\n        b2Vec2(-24.5f / PTM_RATIO, 6.5f / PTM_RATIO),\n        b2Vec2(-31.5f / PTM_RATIO, 1.5f / PTM_RATIO),\n        b2Vec2(-32.5f / PTM_RATIO, 0.5f / PTM_RATIO),\n        b2Vec2(-32.5f / PTM_RATIO, -7.5f / PTM_RATIO),\n    };\n    paddleShape.Set(verts, num);\n\n    // Build the fixture\n    [self buildPaddleFixtureWithShape:paddleShape\n                   andSpriteFrameName:@\"paddle.png\"];\n}\n```", "```swift\n-(void) buildPaddleFixtureWithShape:(b2PolygonShape)shape\n                 andSpriteFrameName:(NSString*)frameName {\n    if (paddleFixture != nil) {\n        paddleBody->DestroyFixture(paddleFixture);\n    }\n\n    // Create the paddle shape definition and add it to the body\n    b2FixtureDef paddleShapeDef;\n    paddleShapeDef.shape = &shape;\n    paddleShapeDef.density = 50.0f;\n    paddleShapeDef.friction = 0.0f;\n    paddleShapeDef.restitution = 0.0f;\n    paddleFixture = paddleBody->CreateFixture(&paddleShapeDef);\n\n    // Swap the sprite image to the normal paddle\n    [paddle setDisplayFrame:[[CCSpriteFrameCache\n                              sharedSpriteFrameCache]\n                             spriteFrameByName:frameName]];\n}\n```", "```swift\n-(void)ccTouchesBegan:(NSSet *)touches\n                    withEvent:(UIEvent *)event {\n  if (mouseJoint != NULL) return;\n\n  UITouch *myTouch = [touches anyObject];\n  CGPoint location = [myTouch locationInView:[myTouch view]];\n  location = [[CCDirector sharedDirector]\n                                convertToGL:location];\n  b2Vec2 locationWorld = b2Vec2(location.x/PTM_RATIO,\n                                  location.y/PTM_RATIO);\n\n  // We want any touches in the bottom part of the\n  // screen to control the paddle\n  if (location.y < 150) {\n    b2MouseJointDef md;\n    md.bodyA = wallBody;\n    md.bodyB = paddleBody;\n    md.target = locationWorld;\n    md.collideConnected = true;\n    md.maxForce = 1000.0f * paddleBody->GetMass();\n\n    mouseJoint = (b2MouseJoint *)world->CreateJoint(&md);\n    paddleBody->SetAwake(true);\n  }\n}\n```", "```swift\n-(void)ccTouchesMoved:(NSSet *)touches\n                        withEvent:(UIEvent *)event {\n\n  if (mouseJoint == NULL) return;\n\n  if (isGameOver) return;\n\n  UITouch *myTouch = [touches anyObject];\n  CGPoint location = [myTouch locationInView:[myTouch view]];\n  location = [[CCDirector sharedDirector]\n                convertToGL:location];\n  b2Vec2 locationWorld = b2Vec2(location.x/PTM_RATIO,\n                                  location.y/PTM_RATIO);\n\n  mouseJoint->SetTarget(locationWorld);\n}\n```", "```swift\n-(void)ccTouchesCancelled:(NSSet *)touches\n                withEvent:(UIEvent *)event {\n  if(mouseJoint) {\n    world->DestroyJoint(mouseJoint);\n    mouseJoint = NULL;\n  }\n}\n\n-(void)ccTouchesEnded:(NSSet *)touches\n            withEvent:(UIEvent *)event {\n    if (mouseJoint) {\n        world->DestroyJoint(mouseJoint);\n        mouseJoint = NULL;\n    }\n}\n```", "```swift\nstatic BRGameHandler *gameHandler = nil;\n\n@implementation BRGameHandler\n\n@synthesize currentLevel;\n@synthesize currentScore;\n@synthesize currentLives;\n@synthesize playfieldLayer;\n\n+ (id)sharedManager\n{\n    // Use Grand Central Dispatch to create it\n    static dispatch_once_t pred;\n    dispatch_once(&pred, ^{\n        gameHandler = [[super allocWithZone:NULL] init];\n    });\n    return gameHandler;\n}\n\n- (id)retain {\n  return self;\n}\n\n- (unsigned)retainCount {\t\n  return NSUIntegerMax;\n}\n\n-(oneway void)release {\n  //do nothing - the singleton is not allowed to release\n}\n\n- (id)autorelease {\n  return self;\n}\n```", "```swift\n-(id) init {\n    if (self == [super init]) {\n        [self resetGame];\n  }\n  return self;\n}\n\n-(void) resetGame {\n    // Start with the defaults\n    currentLevel = 1;\n    currentLives = 3;\n    currentScore = 0;\n}\n\n-(void) addToScore:(NSInteger)newPoints {\n    currentScore = currentScore + newPoints;\n}\n\n-(void) loseLife {\n    currentLives--;\n}\n```", "```swift\nBRGameHandler *gh;\n```", "```swift\ngh = [BRGameHandler sharedManager];\n```", "```swift\n-(void) addToScore:(NSInteger)newPoints {\n    [gh addToScore:newPoints];\n\n    NSString *currScore = [NSString\n            stringWithFormat:@\"%i\", [gh currentScore]];\n\n    [scoreDisplay setString:currScore];\n}\n```", "```swift\n-(void) createLifeImages {\n    for (int i = 1; i <= gh.currentLives; i++) {\n        CCSprite *lifeToken = [CCSprite\n                spriteWithSpriteFrameName:@\"ball.png\"];\n        [lifeToken setPosition:ccp(20 + (20 * i), 446)];\n        [self addChild:lifeToken z:10];\n        [livesArray addObject:lifeToken];\n    }\n}\n```", "```swift\n-(void) loseLife {\n    // Remove a life from the GameHandler variable\n    [gh loseLife];\n\n    CCSprite *lifeToRemove = [livesArray lastObject];\n\n    CCScaleBy *scaleLife = [CCScaleBy actionWithDuration:0.5\n                                    scale:2.0];\n    CCFadeOut *fadeLife = [CCFadeOut actionWithDuration:0.5];\n    CCSpawn *scaleAndFade = [CCSpawn actionOne:scaleLife\n                                    two:fadeLife];\n    CCCallFuncND *destroyLife = [CCCallFuncND\n                        actionWithTarget:self\n                        selector:@selector(destroyLife:)\n                        data:lifeToRemove];\n    CCSequence *seq = [CCSequence actions:scaleAndFade,\n                       destroyLife, nil];\n    [lifeToRemove runAction:seq];\n\n    [livesArray removeLastObject];\n}\n\n-(void) destroyLife:(CCSprite*)lifeToRemove {\n    [lifeToRemove removeFromParentAndCleanup:YES];\n}\n```", "```swift\n-(id) readPlist:(NSString*) fileName {\n  NSData *plistData;\n  NSString *error;\n  NSPropertyListFormat format;\n  id plist;\n\n    // Assumes filename is part of the main bundle\n  NSString *localizedPath = [[NSBundle mainBundle]\n            pathForResource:fileName ofType:@\"plist\"];\n  plistData = [NSData dataWithContentsOfFile:localizedPath];\n\n  plist = [NSPropertyListSerialization\n            propertyListFromData:plistData\n            mutabilityOption:NSPropertyListImmutable\n            format:&format errorDescription:&error];\n\n  if (!plist) {\n    NSLog(@\"Error reading plist '%s', error '%s'\",\n        [localizedPath UTF8String], [error UTF8String]);\n  }\n  return plist;\n}\n```", "```swift\n-(NSDictionary*)getDictionaryFromPlist:(NSString*)fileName {\n    return (NSDictionary*)[self readPlist:fileName];\n}\n```", "```swift\n// Load the level patterns\npatternDefs = [NSDictionary dictionaryWithDictionary:\n[gh getDictionaryFromPlist:@\"patterns\"]];\n\n// Load the brick pattern\nNSInteger uniquePatterns = 4;\nNSInteger newPattern =( [gh currentLevel] -1)\n                                    % uniquePatterns;\n[self buildBricksWithPattern:newPattern];\n```", "```swift\n-(void) buildBricksWithPattern:(NSInteger)patternNum {\n    // Load in the desired pattern\n    NSString *pattID = [NSString stringWithFormat:\n                        @\"P%i\",patternNum];\n    NSArray *tmpPattern = [patternDefs objectForKey:pattID];\n\n    // We start at row 1\n    NSInteger rowNum = 1;\n\n    // Build each row of bricks\n    for (NSString *aRow in tmpPattern) {\n        [self buildBricksForRow:rowNum withString:aRow];\n        rowNum++;\n    }\n}\n```", "```swift\n-(void) buildBricksForRow:(NSInteger)rowNum\n                    withString:(NSString*)brickString {\n    for(int i = 0; i < [brickString length]; i++) {\n        // Create brick and add it to the layer\n        NSRange rng = NSMakeRange(i, 1);\n        NSInteger newID = [[brickString\n                substringWithRange:rng] integerValue];\n\n        if (newID > 0) {\n            NSString *newBrickName = [NSString\n                stringWithFormat:@\"brick%i.png\", newID];\n\n            PhysicsSprite *brick = [PhysicsSprite\n                spriteWithSpriteFrameName:newBrickName];\n            CGPoint startPos = [self positionForBrick:brick\n                forRow:rowNum andColumn:i];\n\n            brick.position = startPos;\n            brick.tag = kBrick;\n            [bricksheet addChild:brick z:10];\n\n            // Create brick body\n            b2BodyDef brickBodyDef;\n            brickBodyDef.type = b2_dynamicBody;\n            brickBodyDef.position.Set(startPos.x/PTM_RATIO,\n                                      startPos.y/PTM_RATIO);\n            brickBodyDef.userData = brick;\n            b2Body *brickBody =\n                        world->CreateBody(&brickBodyDef);\n\n            [brick setPhysicsBody:brickBody];\n\n            // Create brick shape\n            b2PolygonShape brickShape;\n            brickShape.SetAsBox(\n                brick.contentSize.width/PTM_RATIO/2,\n                brick.contentSize.height/PTM_RATIO/2);\n\n            //Create shape definition, add to body\n            b2FixtureDef brickShapeDef;\n            brickShapeDef.shape = &brickShape;\n            brickShapeDef.density = 200.0;\n            brickShapeDef.friction = 0.0;\n            brickShapeDef.restitution = 1.0f;\n            brickBody->CreateFixture(&brickShapeDef);\n        }\n    }\n}\n```", "```swift\nelse if (spriteA != NULL && spriteB != NULL) {\n  // Sprite A = ball, Sprite B = Block\n  if (spriteA.tag == kBall && spriteB.tag == kBrick) {\n   if (std::find(toDestroy.begin(), toDestroy.end(),\n       bodyB) == toDestroy.end()) {\n        toDestroy.push_back(bodyB);\n   }\n  }\n  // Sprite B = block, Sprite A = ball\n  else if (spriteA.tag == kBrick && spriteB.tag == kBall) {\n    if (std::find(toDestroy.begin(), toDestroy.end(),\n      bodyA) == toDestroy.end()) {\n        toDestroy.push_back(bodyA);\n   }\n  }\n}\n```", "```swift\n-(void) spriteDestroy:(PhysicsSprite*)sprite {\n    switch (sprite.tag) {\n        case kBrick:\n            [[SimpleAudioEngine sharedEngine]\n                            playEffect:SND_BRICK];\n            [self checkForRandomPowerupFromPosition:\n                            sprite.position];\n            [sprite removeFromParentAndCleanup:YES];\n            [self addToScore:1];\n            break;\n        case kBall:\n            [[SimpleAudioEngine sharedEngine]\n                                playEffect:SND_LOSEBALL];\n            [sprite removeFromParentAndCleanup:YES];\n            [self loseLife];\n            break;\n}\n}\n```", "```swift\n-(void) checkForRandomPowerupFromPosition:(CGPoint)brickPos {\n    NSInteger rnd = arc4random() % 100;\n\n    if (rnd < 25) {  // 25 % CHANCE\n        [self buildPowerupAtPosition:brickPos];\n    }\n}\n```", "```swift\n-(void) buildPowerupAtPosition:(CGPoint)startPos {\n    NSInteger powerupType = arc4random() % 3;\n    NSString *powerupImageName;\n    NSInteger newTag;\n\n    switch (powerupType) {\n        case 1:\n            powerupImageName = @\"powerup_contract.png\";\n            newTag = kPowerupContract;\n            break;\n        case 2:\n            powerupImageName = @\"powerup_multi.png\";\n            newTag = kPowerupMultiball;\n            break;\n        default:\n            powerupImageName = @\"powerup_expand.png\";\n            newTag = kPowerupExpand;\n            break;\n    }\n\n    // Create sprite and add it to layer\n    PhysicsSprite *powerup = [PhysicsSprite\n            spriteWithSpriteFrameName:powerupImageName];\n    powerup.position = startPos;\n    powerup.tag = newTag;\n    [bricksheet addChild:powerup z:50];\n\n    // Create body\n    b2BodyDef powerupBodyDef;\n    powerupBodyDef.type = b2_dynamicBody;\n    powerupBodyDef.position.Set(startPos.x/PTM_RATIO, \n                             startPos.y/PTM_RATIO);\n    powerupBodyDef.userData = powerup;\n    b2Body *powerupBody = world->CreateBody(&powerupBodyDef);\n\n    // Connect the body to the sprite\n    [powerup setPhysicsBody:powerupBody];\n\n    // Define the fixture shape\n    b2PolygonShape powerupShape;\n    int num = 8;\n    b2Vec2 verts[] = {\n        b2Vec2(-5.6f / PTM_RATIO, 4.3f / PTM_RATIO),\n        b2Vec2(-5.6f / PTM_RATIO, -4.6f / PTM_RATIO),\n        b2Vec2(-4.3f / PTM_RATIO, -5.8f / PTM_RATIO),\n        b2Vec2(4.5f / PTM_RATIO, -5.8f / PTM_RATIO),\n        b2Vec2(5.5f / PTM_RATIO, -4.8f / PTM_RATIO),\n        b2Vec2(5.5f / PTM_RATIO, 4.4f / PTM_RATIO),\n        b2Vec2(4.5f / PTM_RATIO, 5.6f / PTM_RATIO),\n        b2Vec2(-4.7f / PTM_RATIO, 5.6f / PTM_RATIO)\n    };\n    powerupShape.Set(verts, num);\n\n    //Create shape definition and add to body\n    b2FixtureDef powerupShapeDef;\n    powerupShapeDef.shape = &powerupShape;\n    powerupShapeDef.isSensor = YES;\n    powerupBody->CreateFixture(&powerupShapeDef);\n\n    b2Vec2 force = b2Vec2(0,-3);\n    powerupBody->ApplyLinearImpulse(force,\n                     powerupBodyDef.position);\n}\n```", "```swift\n  else if (spriteA.tag == kPowerupContract &&\n           spriteB.tag == kPaddle) {\n    if (std::find(toDestroy.begin(),toDestroy.end(),\n               bodyA) == toDestroy.end()) {\n          toDestroy.push_back(bodyA);\n    }\n  }          \n  else if (spriteA.tag == kPaddle &&\n          spriteB.tag == kPowerupContract) {\n    if (std::find(toDestroy.begin(), toDestroy.end(),\n               bodyB) == toDestroy.end()) {\n          toDestroy.push_back(bodyB);\n    }\n  }\n```", "```swift\ncase kPowerupContract:\n  [sprite removeFromParentAndCleanup:YES];\n  [self buildPaddleFixtureShort];\n  paddleTimer = 10; // Set the timer to 10 seconds\n  isPaddleDeformed = YES;\n  break;\ncase kPowerupExpand:\n  [sprite removeFromParentAndCleanup:YES];\n  [self buildPaddleFixtureLong];\n  paddleTimer = 10; // Set the timer to 10 seconds\n  isPaddleDeformed = YES;\n  break;\ncase kPowerupMultiball:\n  [sprite removeFromParentAndCleanup:YES];\n  shouldStartMultiball = YES;\n  break;  \n```", "```swift\n-(void) buildPaddleFixtureLong {\n    // Define the paddle shape\n    b2PolygonShape paddleShape;\n    int num = 6;\n    b2Vec2 verts[] = {\n        b2Vec2(64.0f / PTM_RATIO, -7.5f / PTM_RATIO),\n        b2Vec2(64.0f / PTM_RATIO, -0.5f / PTM_RATIO),\n        b2Vec2(45.0f / PTM_RATIO, 6.5f / PTM_RATIO),\n        b2Vec2(-48.0f / PTM_RATIO, 6.5f / PTM_RATIO),\n        b2Vec2(-65.0f / PTM_RATIO, 0.5f / PTM_RATIO),\n        b2Vec2(-65.0f / PTM_RATIO, -7.5f / PTM_RATIO)\n    };\n    paddleShape.Set(verts, num);\n\n    // Build the fixture\n    [self buildPaddleFixtureWithShape:paddleShape\n                   andSpriteFrameName:@\"paddle_wide.png\"];\n}\n```", "```swift\n    if (isPaddleDeformed) {\n        paddleTimer = paddleTimer - dt;\n        if (paddleTimer <= 0) {\n            paddleTimer = 0;\n            isPaddleDeformed = NO;\n            [self buildPaddleFixtureNormal];\n        }\n    }\n```", "```swift\n    if (shouldStartMultiball) {\n        [self startMultiball];\n        shouldStartMultiball = NO;\n    }\n```", "```swift\n-(void) startMultiball {\n    // Prevent triggering a multiball when the ball is lost\n    if (!isBallInPlay) {\n        return;\n    }\n    CGPoint startPos;\n    for(b2Body *b = world->GetBodyList(); b;b=b->GetNext()) {\n    if (b->GetUserData() != NULL) {\n            // Get the sprite for this body\n      CCSprite *sprite = (CCSprite *)b->GetUserData();\n\n            if (sprite.tag == kBall) {\n                startPos = sprite.position;\n\n                // Build 2 new balls at the same position\n                [self buildBallAtStartingPosition:startPos\n                    withInitialImpulse:b2Vec2(0.2,1.5)];\n                [self buildBallAtStartingPosition:startPos\n                    withInitialImpulse:b2Vec2(-0.2,1.5)];\n\n                multiballCounter = multiballCounter + 2;\n\n                // We break out to avoid chain reactions\n                break;\n            }\n        }\n    }\n}\n```", "```swift\n-(void) loseLife {\n    if (multiballCounter > 0) {\n        multiballCounter--;\n    } else {\n        isBallInPlay = NO;\n\n        [hudLayer loseLife];\n        // Do we need another ball?\n        if ([gh currentLives] > 0) {\n            [self scheduleOnce:@selector(newBall) delay:1.0];\n        } else {\n            // Game over\n            [self prepareForGameOver];\n        }\n    }\n}\n```"]