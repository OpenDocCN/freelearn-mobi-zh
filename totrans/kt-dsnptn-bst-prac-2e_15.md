# 评估

# 第一章，Kotlin 入门

# 问题 1

Kotlin 中 `var` 和 `val` 之间的区别是什么？

# 回答

`val`关键字声明了一个不可变值，一旦分配后就不能修改。`var`关键字声明了一个可变变量，可以被多次赋值。

# 问题 2

你如何在 Kotlin 中扩展一个类？

# 回答

要扩展一个类，你可以在分号后指定其名称和构造函数。如果它是一个普通类，它必须被声明为`open`，以便你的代码能够扩展它。

# 问题 3

你如何向一个`final`类添加功能？

# 回答

要向一个无法继承的类添加功能，我们可以使用扩展函数。扩展函数将只能访问类本身及其公共字段和函数。

# 第二章，使用创建型模式

# 问题 1

列出本章中我们学到的`object`关键字的两个用途。

# 回答

当在全局作用域中使用或在与类内部的`companion`关键字一起使用时，`object`关键字用于声明单例，如果它与`companion`关键字一起使用，则作为静态方法的集合。

# 问题 2

`apply()`函数用于什么？

# 回答

当我们想要改变一个对象的状态并立即返回它时，使用`apply()`函数。

# 问题 3

提供本章中讨论的静态工厂方法的一个示例。

# 回答

`Long`对象的 JVM `valueOf()`方法是静态工厂方法。

# 第三章，理解结构型模式

# 问题 1

装饰器模式和代理设计模式的实现之间有什么区别？

# 回答

装饰器模式和代理设计模式可以以相同的方式实现。唯一的区别在于它们的意图——装饰器设计模式向对象添加功能，而代理设计模式可能会改变对象的功能。

# 问题 2

飞舞设计模式的主要目标是什么？

# 回答

飞舞设计模式的目标是通过在多个轻量级对象之间重用相同的不可变状态来节省内存。

# 问题 3

外观模式和适配器设计模式之间的区别是什么？

# 回答

外观设计模式创建了一个新的接口，以简化与复杂代码的交互，而适配器设计模式允许一个接口替代另一个接口。

# 第四章，熟悉行为型模式

# 问题 1

中介和观察者设计模式之间的区别是什么？

# 回答

它们都服务于类似的目的。中介引入了可能服务于不同目的的组件之间的紧密耦合，而观察者操作的是松散耦合的类似组件。

# 问题 2

什么是**领域特定语言**（**DSL**）？

# 回答

DSL 是一种专注于解决特定领域问题的语言。这与像 Kotlin 这样的通用语言不同，Kotlin 可以应用于不同的领域。Kotlin 鼓励开发者根据需要创建 DSL。

# 问题 3

使用密封类或接口的好处是什么？

# 答案

由于密封类的所有类型在编译时都是已知的，Kotlin 编译器可以验证 `when` 语句涵盖了所有情况，换句话说，是详尽的。

# 第五章，介绍函数式编程

# 问题 1

什么是高阶函数？

# 答案

任何接收另一个函数作为输入或返回函数作为输出的函数都是高阶函数。

# 问题 2

Kotlin 中的 `tailrec` 关键字是什么意思？

# 答案

`tailrec` 关键字的目的在于允许 Kotlin 编译器优化尾递归并避免栈溢出。

# 问题 3

什么是纯函数？

# 答案

纯函数是没有任何副作用（如 I/O）的函数。

# 第六章，线程和协程

# 问题 1

在 Kotlin 中，有哪几种方式可以启动协程？

# 答案

Kotlin 中的协程可以用 `launch()` 或 `async()` 函数启动。区别在于 `async()` 也会返回一个值，而 `launch()` 则不会。

# 问题 2

在结构化并发中，如果一个协程失败，所有兄弟协程也会被取消。我们如何防止这种行为？

# 答案

我们可以通过使用 `supervisorScope` 而不是 `coroutineScope` 来防止取消兄弟协程。

# 问题 3

`yield()` 函数的目的是什么？

# 答案

`yield()` 函数返回一个值并挂起协程，直到它被恢复。

# 第七章，控制数据流

# 问题 1

集合上的高阶函数与并发数据结构上的高阶函数之间有什么区别？

# 答案

集合上的高阶函数会在进行下一步之前处理整个集合，创建其副本。并发数据结构上的高阶函数是反应式的，逐个处理元素。

# 问题 2

数据的冷流和热流之间有什么区别？

# 答案

冷流会为每个新的消费者重复自身，而热流将只从订阅时开始将可用的数据发送给新的消费者。

# 问题 3

应该在什么情况下使用合并通道/流？

# 答案

当消费者比生产者慢，并且一些消息可能会丢失，只留下最新消息供消费时，可以使用合并流。

# 第八章，设计并发

# 问题 1

当我们说 Kotlin 中的 `select` 表达式是偏斜的，这意味着什么？

# 答案

偏斜的 `select` 表达式意味着在两个通道之间发生 *平局* 的情况下，`select` 表达式中列出的第一个通道将始终被选中。

# 问题 2

应该在什么情况下使用互斥锁而不是通道？

# 答案

互斥锁用于保护多个协程之间共享的资源。通道用于在协程之间传递数据。

# 问题 3

哪种并发设计模式可以帮助你有效地实现 **MapReduce** 或 **分而治之** 算法？

# 答案

对于分而治之算法，可以使用扇出设计模式来分割数据，而可以使用扇入设计模式来合并结果。

# 第九章，惯用和反模式

# 问题 1

Kotlin 中 Java 的 `try`-with-resources 的替代方案是什么？

# 答案

在 Kotlin 中，`use()` 函数在 `Closeable` 接口上工作，以确保在使用后释放资源。

# 问题 2

在 Kotlin 中处理空值的不同选项有哪些？

# 答案

处理空值有多种选择：Elvis 操作符、智能转换以及 `let` 和 `run` 范围函数都可以帮助处理这个问题。

# 问题 3

通过具体化泛型可以解决哪些问题？

# 答案

在 JVM 上，类型在运行时被擦除。通过将泛型函数体内联到调用点，它允许保留编译器使用的实际类型。

# 第十章，使用 Ktor 的并发微服务

# 问题 1

Ktor 应用是如何构建的，它们有什么好处？

# 答案

Ktor 应用被划分为模块，每个模块都是 `Application` 对象上的扩展函数。模块化我们的应用程序允许我们单独测试其不同方面。

# 问题 2

Ktor 中的插件是什么，它们用于什么？

# 答案

插件是 Ktor 解决横切关注点的一种方式。它们用于序列化和反序列化请求和响应，设置头部，甚至路由本身也是一个插件。

# 问题 3

`Exposed` 库主要解决了什么问题？

# 答案

`Exposed` 库提供了一个高级 API，用于处理数据库。

# 第十一章，使用 Vert.x 的响应式微服务

# 问题 1

Vert.x 中的 verticle 是什么？

# 答案

Verticle 是一种轻量级演员，允许我们将业务逻辑分离成小的反应单元。

# 问题 2

Vert.x 中的事件总线有什么目标？

# 答案

事件总线允许 verticles 通过发送和消费消息间接地相互通信。

# 问题 3

为什么我们不应该阻塞事件循环？

# 答案

事件循环使用有限数量的线程来并发处理多个请求。如果任何一个线程被阻塞，它都会降低 Vert.x 应用的性能。
