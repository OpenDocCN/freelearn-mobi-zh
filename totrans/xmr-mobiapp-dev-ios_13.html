<html><head></head><body>
  <div><div><div><div><h1 class="title"><a class="calibre1" id="ch13"/>Chapter 13. User Preferences</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">From time to time, it is useful for a user to be able to store preferences (such as ringtones for a contact). Thankfully, iOS provides a built-in preference system. This is fine if you only ever wish to write an app for iOS, but if the intention is to have an app that can be built for any platform that can use .NET, then a different approach is required.</p>

    <p class="calibre9">The topics covered in this chapter will be:</p>

    <div><ul class="itemizedlist">
        <li class="listitem">Using the built-in preference system</li>

        <li class="listitem">Rolling your own preference system</li>
      </ul>
    </div>

    <div><div><div><div><h1 class="title"><a class="calibre1" id="ch13lvl1sec56"/>The built-in system</h1>
          </div>
        </div>
      </div>

      <p class="calibre9">To start with, a special folder <a class="calibre1" id="id993"/>has to be added to your application called <a class="calibre1" id="id994"/> <code class="email">Settings.bundle</code> that contains a file called <code class="email">Root.plist</code>.</p>

      <p class="calibre9">This is not a normal file and the <code class="email">.plist</code> file needs <strong class="calibre2">Build Action</strong> to be set as <strong class="calibre2">Content</strong>.</p>

      <div><img alt="The built-in system" class="calibre11" src="img/00046.jpeg"/></div>

      <p class="calibre12"/>

      <p class="calibre9">The <code class="email">.plist</code> file is an <a class="calibre1" id="id995"/>XML file with entries stored in a regular dictionary objecting the <code class="email">&lt;key&gt;&lt;type&gt;</code> form, where type can be anything (such as <code class="email">string</code>, <code class="email">int</code>, and <code class="email">double</code>).</p>

      <p class="calibre9">For example, for creating a preference <a class="calibre1" id="id996"/>displayed as a <code class="email">UISlider</code> class it would be stored as shown in the following code:</p>

      <div><pre class="programlisting">&lt;dict&gt;
    &lt;key&gt;Type&lt;/key&gt;
    &lt;string&gt;UISlider&lt;/string&gt;
    &lt;key&gt;Key&lt;/key&gt;
    &lt;string&gt;My slider&lt;/string&gt;
    &lt;key&gt;DefaultValue&lt;/key&gt;
    &lt;int&gt;40&lt;/int&gt;
    &lt;key&gt;MinimumValue&lt;/key&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;key&gt;MaximumValue&lt;/key&gt;
    &lt;int&gt;75&lt;/int&gt;
&lt;/dict&gt;</pre>
      </div>

      <p class="calibre9">It is simple to understand, but the <a class="calibre1" id="id997"/>file can grow quickly, depending on how much information is being stored.</p>

      <div><div><div><div><h2 class="title1"><a class="calibre1" id="ch13lvl2sec68"/>Reading and writing to the .plist file</h2>
            </div>
          </div>
        </div>

        <p class="calibre9">Thankfully, it is simple to <a class="calibre1" id="id998"/>read from the <code class="email">.plist</code> file. All that is required is the key to identify the value and the knowledge of the value type to properly call the related method.</p>

        <div><pre class="programlisting">int read = NSUserDefaults.StandardDefaults.IntForKey("DefaultValue");
string name = NSUserDefaults.StandardDefaults.StringForKey("Key");</pre>
        </div>

        <p class="calibre9">Writing to the file can be <a class="calibre1" id="id999"/>performed in two ways. The simplest is to just write to the file, as shown in the following code:</p>

        <div><pre class="programlisting">NSUserDefaults.StandardDefaults["DefaultValue"] = 34;
NSUserDefaults.StandardDefaults["Key"] = "Hello mum!";</pre>
        </div>

        <p class="calibre9">The other way is to call the <a class="calibre1" id="id1000"/> <code class="email">NSNotificationCenter</code> class, which broadcasts notifications to the application. The <code class="email">NSUserDefaults</code> class <a class="calibre1" id="id1001"/>uses this system to emit the <code class="email">NSUserDefaultsDidChangeNotifcation</code> notification when the <code class="email">Settings</code> values change. The good part here is that any <a class="calibre1" id="id1002"/> <code class="email">NSObject</code> class can be set to act as an observer for the notification. The observer provides a call back method as shown in the following code:</p>

        <div><pre class="programlisting">public mySettingsClass()
{
    NSNotificationCenter.DefaultCenter.AddObserver
    (
        this, new Selector("updateSettings"),
        new NSString ("NSUserDefaultDidChangeNotification"),
        null
    );

    [Export ("updateSettings:")]private void UpdateSettings()
    {
        doSomething();
    }

    private void doSomething()
    {
        // do something here
    }
}</pre>
        </div>
      </div>
    </div>
  </div>


  <div><div><div><div><h1 class="title"><a class="calibre1" id="ch13lvl1sec57"/>Rolling your own settings system</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">While using the <a class="calibre1" id="id1003"/>built-in settings system may seem useful, the point of using the Xamarin range of products is to be able to use a large amount of the same code on any <a class="calibre1" id="id1004"/>platform that now supports <code class="email">.NET</code>. While, at the time of writing, Windows Mobile is languishing at around three percent of the market share of all smart phones, Microsoft is unlikely to allow this to continue and will push their massive reserves into getting people to adopt their smart phones. If you want the pure mathematics, 97 percent of all smart phones can be coded using the .NET platform. (Blackberry has a port of mono for it, but it is not well supported and so can be discounted.)</p>

    <p class="calibre9">This, therefore, requires a different strategy for storing user settings. We could use an SQLite database to store the details, but, as has been pointed out, each access to the sub system will cause a performance hit.</p>

    <p class="calibre9">The simplest way is to create a <code class="email">settings</code> class and <strong class="calibre2">serialize</strong> or <strong class="calibre2">deserialize</strong> the values as and when required. It is an extremely flexible approach and works wonderfully.</p>

    <div><div><div><div><h2 class="title1"><a class="calibre1" id="ch13lvl2sec69"/>Serializing and deserializing data</h2>
          </div>
        </div>
      </div>

      <p class="calibre9">The <a class="calibre1" id="id1005"/>following <a class="calibre1" id="id1006"/>code is a <a class="calibre1" id="id1007"/>very simple <a class="calibre1" id="id1008"/>serializer and deserializer:</p>

      <div><pre class="programlisting">public class Serializer
{
    public static void XmlSerializeObject&lt;T&gt;(T obj, string filePath)
    {
        using (StreamWriter sw = new StreamWriter(filePath))
        {
            XmlSerializer xmlSer = new XmlSerializer(typeof(T));
            xmlSer.Serialize(sw, obj);
        }
    }

    public static T XmlDeserializeObject&lt;T&gt;(string filePath)
    {
        using (StreamReader sr = new StreamReader(filePath))
        {
            XmlSerializer xmlSer = new XmlSerializer(typeof(T));
            return (T)xmlSer.Deserialize(sr);
        }
    }
}</pre>
      </div>

      <p class="calibre9">The preceding code will <a class="calibre1" id="id1009"/>serialize and <a class="calibre1" id="id1010"/>deserialize any object type that is put through it. This includes generic types such as <code class="email">List&lt;&gt;</code> and <code class="email">Dictionary&lt;,&gt;</code> objects. Do not pass in interface members or circular <a class="calibre1" id="id1011"/>references <a class="calibre1" id="id1012"/> (like an object that refers to an object that refers to the original object)—this will cause the serializer to crash.</p>
    </div>

    <div><div><div><div><h2 class="title1"><a class="calibre1" id="ch13lvl2sec70"/>Setting up the Settings file</h2>
          </div>
        </div>
      </div>

      <p class="calibre9">Unlike using the <code class="email">NSUserDefaults.plist</code> file, the settings file used here is still an XML file, but it doesn't need to be set as <a class="calibre1" id="id1013"/>any particular type. As it is also a simple XML file, it can be copied and transferred to <a class="calibre1" id="id1014"/>the same application on a different platform.</p><img alt="Note" class="calibre10" src="img/00001.gif"/>

      <div><h3 class="title2"><a class="calibre1" id="note06"/>Note</h3>

        <p class="calibre9">So say you're configuring a file for the app on the iPhone and you want to run it on your Android phone as well. You will copy the <code class="email">Settings</code> file and run the app on the Android phone and you instantly have the settings you had on the iPhone.</p>
      </div><img alt="Note" class="calibre10" src="img/00001.gif"/><br class="book"/>

      <p class="calibre9">The <code class="email">Settings</code> file consists of two classes—the <code class="email">handler</code> class and the <code class="email">data</code> class.</p>

      <div><div><div><div><h3 class="title2"><a class="calibre1" id="ch13lvl3sec121"/>The handler class</h3>
            </div>
          </div>
        </div>

        <p class="calibre9">The handler class handles <a class="calibre1" id="id1015"/>setting <a class="calibre1" id="id1016"/>up the <code class="email">Settings</code> file as well as the accessors for the data class. I've reproduced the important parts in the following code:</p>

        <div><pre class="programlisting">public static class myAppData
{
    private static AppSettings appSetting;

    public static AppSettings appSettings
    {
        get
        {
            if (appSetting == null)
            {
                if (File.Exists(AppSettingsFile))
                    appSetting = Serializer.XmlDeserializeObject&lt;AppSettings&gt;(AppSettingsFile);
                else
                {
                    appSetting = new myAppData.AppSettings();
                    Serializer.XmlSerializeObject &lt;AppSettings&gt;(appSetting, AppSettingsFile);
                }
            }
            return appSetting;
        }
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException("value is null!");
            }
            appSetting = value;
            if (File.Exists(AppSettingsFile))
                File.Delete(AppSettingsFile);
            Serializer.XmlSerializeObject &lt;AppSettings&gt;(appSetting, AppSettingsFile);
        }
    }

    private static string pathAppSettingsFile;
    public static string AppSettingsFile
    {
        get
        {
            if (string.IsNullOrEmpty(pathAppSettingsFile))
                pathAppSettingsFile =Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments"),"AppSettings.xml");
                return pathAppSettingsFile;
          }
    }
}</pre>
        </div>

        <div><div><div><div><h4 class="title3"><a class="calibre1" id="ch13lvl4sec15"/>Adding an accessor</h4>
              </div>
            </div>
          </div>

          <p class="calibre9">The following code is used for <a class="calibre1" id="id1017"/>any type of object being passed into the configuration file:</p>

          <div><pre class="programlisting">public static List&lt;string&gt; theAlias
{
    get { return appSettings.TheAlias;}
    set
    {
        AppSettings settings = appSettings;
        settings.TheAlias = value;
        appSettings = settings;
    }
}</pre>
          </div>

          <p class="calibre9">The preceding simple accessor can be cut and pasted as many times as required. The best thing is that the <code class="email">List&lt;&gt;</code> object can be of <a class="calibre1" id="id1018"/>any type—you can even have an entire list of classes in there!</p>
        </div>
      </div>

      <div><div><div><div><h3 class="title2"><a class="calibre1" id="ch13lvl3sec122"/>The data class</h3>
            </div>
          </div>
        </div>

        <p class="calibre9">The data class contains nothing <a class="calibre1" id="id1019"/>except a list of accessors that marry up to the ones in the <a class="calibre1" id="id1020"/>data handler class, and its also contains a default constructor as shown in the following code:</p>

        <div><pre class="programlisting">public class AppSettings
{
    public AppSettings()
    {
    }

    public List&lt;string&gt; TheAlias
    {get;set;}
}</pre>
        </div>

        <p class="calibre9">With the preceding code, you have possibly the most flexible configuration and settings system available.</p>
      </div>
    </div>
  </div>


  <div><div><div><div><h1 class="title"><a class="calibre1" id="ch13lvl1sec58"/>Summary</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">User settings are important—who in their right mind wants to have to set up everything time and again, or worse, for every update of the application? When updating an application, a file within the application folder will be kept and will always be available (except if the app is uninstalled). Stored user settings are not always guaranteed to persist between versions. We have seen in this chapter two completely different methods of storing configuration settings: the one supplied and the one created. There are other ways to do the same as I have demonstrated in this chapter.</p>
  </div>
</body></html>