<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Apps for TVs, Cars, and Wearables</h1></div></div></div><p>One of the most exciting new directions that Android has gone in recently, is the extension of the platform from phones and tablets to televisions, car dashboards and wearables such as watches. These new devices allow us to provide added functionality to our existing apps, as well as creating wholly original apps designed specifically for these new environments.</p><p>We have already acquired the skills needed to develop such apps and this chapter is really more concerned with explaining the idiosyncrasies of each platform and the guidelines Google is keen for us to follow. This is particularly vital when it comes to developing apps that people will use when driving, as safety has to be of prime importance. There are also certain technical issues that need to be addressed when developing wearable apps, such as the pairing of the device with a handset and the entirely different UI and methods of use.</p><p>In this chapter, you will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create wearable AVDs</li><li class="listitem" style="list-style-type: disc">Connect a wearable emulator to a handset with adb commands</li><li class="listitem" style="list-style-type: disc">Connect a wearable emulator to a handset emulator</li><li class="listitem" style="list-style-type: disc">Create a project with both mobile and wearable modules</li><li class="listitem" style="list-style-type: disc">Use the Wearable UI Library</li><li class="listitem" style="list-style-type: disc">Create shape-aware layouts</li><li class="listitem" style="list-style-type: disc">Create and customize cards for wearables</li><li class="listitem" style="list-style-type: disc">Understand wearable design principles</li><li class="listitem" style="list-style-type: disc">Access wearable sensors</li><li class="listitem" style="list-style-type: disc">Make an app available for Google TV</li><li class="listitem" style="list-style-type: disc">Include Leanback support</li><li class="listitem" style="list-style-type: disc">Understand Android Auto safety guidelines</li><li class="listitem" style="list-style-type: disc">Configure an Auto project</li><li class="listitem" style="list-style-type: disc">Install Google simulators</li><li class="listitem" style="list-style-type: disc">Send SMS messages using the Android Device Monitor</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec36"/>Android Wear</h1></div></div></div><p>Creating <a id="id312" class="indexterm"/>or adapting apps for wearables is probably the most complicated of the three form factors dealt with in this chapter and requires a little more setting up than the other projects. However, wearables often give us access to one of the more fun new sensors, the heart rate monitor. In seeing how this works, we also get to see, how to manage sensors in general.</p><p>Do not worry if you do not have access to an Android wearable device, as we will be constructing AVDs. You will ideally have an actual Android 5 handset, if you wish to pair it with the AVD. If you do not, it is still possible to work with two emulators but it is a little more complex to set up. Bearing this in mind, we can now prepare our first wearable app.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec39"/>Constructing and connecting to a wearable AVD</h2></div></div></div><p>It is perfectly possible to develop and test wearable apps on the emulator alone, but if we want to test<a id="id313" class="indexterm"/> all wearable features, we will need to <a id="id314" class="indexterm"/>pair it with a phone or a tablet. The next exercise assumes that you have an actual device. If you do not, still complete tasks 1 through 4 and we will cover how the rest can be achieved with an emulator <a id="id315" class="indexterm"/>a little later on.</p><div><ol class="orderedlist arabic"><li class="listitem">Open<a id="id316" class="indexterm"/> Android Studio. You do not need to start a project at this point.<div><img src="img/B04321_08_01.jpg" alt="Constructing and connecting to a wearable AVD"/><div><p>Start the SDK Manager and ensure you have the relevant packages installed.</p></div></div></li><li class="listitem">Open the AVD Manager.</li><li class="listitem">Create two new Android Wear AVDs, one round and one square, like so:<div><img src="img/B04321_08_02.jpg" alt="Constructing and connecting to a wearable AVD"/></div></li><li class="listitem">Ensure USB Debugging is selected on your handset.</li><li class="listitem">Install the <a id="id317" class="indexterm"/>Android Wear app from the Play Store at this URL: <a class="ulink" href="https://play.google.com/store/apps/details?id=com.google.android.wearable.app">https://play.google.com/store/apps/details?id=com.google.android.wearable.app</a>. Connect it to your computer and start one of the AVDs we just created.</li><li class="listitem">Locate <a id="id318" class="indexterm"/>and open the folder containing the <code class="literal">adb.exe</code> file. It <a id="id319" class="indexterm"/>will probably be something like <code class="literal">user\AppData\Local\Android\sdk\platform-tools\</code>.</li><li class="listitem">Using <em>Shift</em> + right-click, select <strong>Open command window here</strong>.</li><li class="listitem">In the command window, issue the following command: <div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">adb -d forward tcp:5601 tcp:5601</code></li></ul></div></li><li class="listitem">Launch the companion app and follow the instructions to pair the two devices.</li></ol></div><p>Being able <a id="id320" class="indexterm"/>to connect a real-world device to an<a id="id321" class="indexterm"/> AVD is a great way to develop form factors without having to own the devices. The wearable companion app simplifies the process of connecting the two. If you have had the emulator running for any length of time, you will have noticed that many actions, such as notifications, are sent to the wearable automatically. This means that very often our apps will link seamlessly with a wearable device, without us having to include code to pre-empt this.</p><p>The <code class="literal">adb.exe</code> (<strong>Android Debug Bridge</strong>) is a vital part of our development toolkit. Most of the time, the <a id="id322" class="indexterm"/>Android Studio manages it for us. However, it is useful to know that it is there and a little about how to interact with it. We used it here to manually open a port between our wearable AVD and our handset.</p><p>There are many <code class="literal">adb</code> commands that can be issued from the command prompt and perhaps the most useful is <code class="literal">adb devices</code>, which lists all currently debuggable devices and emulators, and is very handy when things are not working, to see if an emulator needs<a id="id323" class="indexterm"/> restarting. Switching the ADB off and <a id="id324" class="indexterm"/>on can be achieved using <code class="literal">adb kill-server</code> and <code class="literal">adb start-server</code> respectively. Using <code class="literal">adb help</code> will list all available commands.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>The port forwarding command we used in step 10, needs to be issued every time the phone is disconnected from the computer.</p></div></div><p>Without <a id="id325" class="indexterm"/>writing any code as such, we have already seen some<a id="id326" class="indexterm"/> of the features that are built into an Android Wear device and the way that the Wear UI differs from most other Android devices.</p><p>Even if you usually develop with the latest Android hardware, it is often still a good idea to use an emulator, especially for testing the latest SDK updates and pre-releases. If you do not have a real device, then the next, small section will show you how to connect your wearable AVD to a handset AVD.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec06"/>Connecting a wearable AVD with another emulator</h3></div></div></div><p>Pairing<a id="id327" class="indexterm"/> two emulators is very similar to pairing with a real device. The main difference is the way we install the companion app without access to the Play Store. Follow these steps to see how it is done:</p><div><ol class="orderedlist arabic"><li class="listitem">Start up, an AVD. This will need to be targeting Google APIs as seen here:<div><img src="img/B04321_08_03.jpg" alt="Connecting a wearable AVD with another emulator"/></div></li><li class="listitem">Download the <code class="literal">com.google.android.wearable.app-2.apk</code>. There are many places online where it can be found with a simple search, I used <a class="ulink" href="http://www.file-upload.net/download">www.file-upload.net/download</a>.</li><li class="listitem">Place the file in your <code class="literal">sdk/platform-tools</code> directory.</li><li class="listitem"><em>Shift</em> + right-click in this folder and select <strong>Open command window here</strong>.</li><li class="listitem">Enter the following command:<div><pre class="programlisting">
<strong>adb install com.google.android.wearable.app-2.apk.</strong>
</pre></div></li><li class="listitem">Start your wearable AVD.</li><li class="listitem">Enter <code class="literal">adb devices</code> into the command prompt, making sure that both emulators are visible with an output similar to this:<div><pre class="programlisting">
<strong>List of devices attached</strong>
<strong>emulator-5554   device</strong>
<strong>emulator-5555   device</strong>
</pre></div></li><li class="listitem">Enter <code class="literal">adb telnet localhost 5554</code> at the command prompt, where <code class="literal">5554</code> is the phone emulator.</li><li class="listitem">Next, enter <code class="literal">adb redir add tcp:5601:5601</code>.</li><li class="listitem">You can now use the Wear app on the handheld AVD to connect to the watch.</li></ol></div><p>As we've <a id="id328" class="indexterm"/>just seen, setting up a Wear project takes a little longer than some of the other exercises we have performed. Once set up though, the process is very similar to that of developing for other form factors, and something we can now get on with.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec40"/>Creating a wearable project</h2></div></div></div><p>All of the apps that we have developed so far, have required just a single module, and this makes sense as we have only been building for single devices. In this next step, we will be developing across two devices and so will need two modules. This is very simple to do, as you <a id="id329" class="indexterm"/>will see in these next steps.</p><div><ol class="orderedlist arabic"><li class="listitem">Start a new project in the Android Studio and call it something like <code class="literal">Wearable App</code>.</li><li class="listitem">On the <strong>Target Android Devices</strong> screen, select both <strong>Phone and Tablet</strong> and <strong>Wear</strong>, like so:<div><img src="img/B04321_08_04.jpg" alt="Creating a wearable project"/></div></li><li class="listitem">You will be asked to add two Activities. Select <strong>Blank Activity</strong> for the Mobile Activity and <strong>Blank Wear Activity</strong> for Wear.</li><li class="listitem">Everything else can be left as it is.</li><li class="listitem">Run the app on both round and square virtual devices.</li></ol></div><p>The first thing you will have noticed is the two modules, mobile and wear. The first is the same as we have seen many times, but there are a few subtle differences with the wear module and it is worth taking a little look at. The most important difference is the <code class="literal">WatchViewStub</code> class. The way it is used can be seen in the <code class="literal">activity_main.xml</code> and <code class="literal">MainActivity.java</code> files of the wear module.</p><p>This<a id="id330" class="indexterm"/> frame layout extension is designed specifically for wearables and detects the shape of the device, so that the appropriate layout is inflated. Utilizing the <code class="literal">WatchViewStub</code> is not quite as straightforward, as one might imagine, as the appropriate layout is only inflated after the <code class="literal">WatchViewStub</code> has done its thing. This means that, to access any views within the layout, we need to employ a special listener that is called once the layout has been inflated. How this <code class="literal">OnLayoutInflatedListener()</code> works can be seen by opening the <code class="literal">MainActivity.java</code> file in the wear module and examining the <code class="literal">onCreate()</code> method, which will look like this:</p><div><pre class="programlisting">@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  final WatchViewStub stub = (WatchViewStub) findViewById(R.id.watch_view_stub);
  stub.setOnLayoutInflatedListener(new WatchViewStub.OnLayoutInflatedListener() {
    @Override
    public void onLayoutInflated(WatchViewStub stub) {
      mTextView = (TextView) stub.findViewById(R.id.text);
    }
  });
}</pre></div><p>Other than<a id="id331" class="indexterm"/> the way that wearable apps and devices are set up for developing, the other significant difference is the UI. The widgets and layouts that we use for phones and tablets are not suitable, in most cases, for the diminished size of a watch screen. Android provides a whole new set of UI components, that we can use and this is what we will look at next.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec41"/>Designing a UI for wearables</h2></div></div></div><p>As well <a id="id332" class="indexterm"/>as having to consider the small size of wearable when designing layouts, we also have the issue of shape. Designing<a id="id333" class="indexterm"/> for a round screen brings its own challenges, but<a id="id334" class="indexterm"/> fortunately the <strong>Wearable UI Library</strong> makes this very simple. As well as the <code class="literal">WatchViewStub</code>, that we encountered in the previous section that inflates the correct layout, there is also a way to design a single layout that inflates in such a way, that it is suitable for both square and round screens.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec07"/>Designing the layout</h3></div></div></div><p>The project <a id="id335" class="indexterm"/>setup wizard included this library for us automatically in the <code class="literal">build.gradle (Module: wear)</code> file as a dependency:</p><div><pre class="programlisting">
<strong>compile 'com.google.android.support:wearable:1.1.0'</strong>
</pre></div><p>The following steps demonstrate how to create a shape-aware layout with a <code class="literal">BoxInsetLayout</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the project we created in the last section.</li><li class="listitem">You will need three images that must be placed in the <code class="literal">drawable</code> folder of the wear module: one called <code class="literal">background_image</code> of around 320 x 320 px and two of around 50 x 50 px, called <code class="literal">right_icon</code> and <code class="literal">left_icon</code>.</li><li class="listitem">Open the <code class="literal">activity_main.xml</code> file in the wear module.</li><li class="listitem">Replace its content with the following code:<div><pre class="programlisting">&lt;android.support.wearable.view.BoxInsetLayout
  
  
  android:background="@drawable/background_image"
  android:layout_height="match_parent"
  android:layout_width="match_parent"
  android:padding="15dp"&gt;

&lt;/android.support.wearable.view.BoxInsetLayout&gt;</pre></div></li><li class="listitem">Inside the <code class="literal">BoxInsetLayout</code>, add the following <code class="literal">FrameLayout</code>:<div><pre class="programlisting">&lt;FrameLayout
  android:id="@+id/wearable_layout"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:padding="5dp"
  app:layout_box="all"&gt;

&lt;/FrameLayout&gt;</pre></div></li><li class="listitem">Inside<a id="id336" class="indexterm"/> this, add these three views:<div><pre class="programlisting">&lt;TextView
  android:gravity="center"
  android:layout_height="wrap_content"
  android:layout_width="match_parent"
  android:text="Weather warning"
  android:textColor="@color/black" /&gt;

&lt;ImageView
  android:layout_gravity="bottom|left"
  android:layout_height="60dp"
  android:layout_width="60dp"
  android:src="img/left_icon" /&gt;

&lt;ImageView
  android:layout_gravity="bottom|right"
  android:layout_height="60dp"
  android:layout_width="60dp"
  android:src="img/right_icon" /&gt;</pre></div></li><li class="listitem">Open the <code class="literal">MainActivity.java</code> file in the wear module.</li><li class="listitem">In the <code class="literal">onCreate()</code> method, delete all lines after the line <code class="literal">setContentView(R.layout.activity_main);</code>.</li><li class="listitem">Now, run the app on both square and round emulators.<div><img src="img/B04321_08_05.jpg" alt="Designing the layout"/></div></li></ol></div><p>As we<a id="id337" class="indexterm"/> can see, the <code class="literal">BoxInsetLayout</code> does a fine job of inflating our layout regardless of screen shape. How it works is very simple. The <code class="literal">BoxInsetLayout</code> creates a square region, that is as large as can fit inside the circle of a round screen. This is set with the <code class="literal">app:layout_box="all"</code> instruction, which can also be used for positioning components, as we will see in a minute.</p><p>We have also set the padding of the <code class="literal">BoxInsetLayout</code> to 15 dp and that of the <code class="literal">FrameLayout</code> to 5 dp. This has the effect of a margin of 5 dp on round screens and 15 dp on square ones.</p><p>Whether you use the <code class="literal">WatchViewStub</code> and create separate layouts for each screen shape or <code class="literal">BoxInsetLayout</code> and just one layout file depends entirely on your preference and the purpose and design of your app. Whichever method you choose, you will no doubt want to add Material Design elements to your wearable app, the most common and versatile of these being the card. In the following section, we will explore the two ways that we can do this, the <code class="literal">CardScrollView</code> and the <code class="literal">CardFragment</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec08"/>Adding cards</h3></div></div></div><p>The <code class="literal">CardFragment</code> class provides a default card view, providing two text views and an image. It is<a id="id338" class="indexterm"/> beautifully simple to set up, has all the Material Design features such as rounded corners and a shadow, and is suitable for nearly all purposes. It can be customized, as we will see, although the <code class="literal">CardScrollView</code> is often a better option. First, let us see, how to implement a default card for wearables:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">activity_main.xml</code> file in the wear module of the current project.</li><li class="listitem">Delete or comment out the the text view and two image views.</li><li class="listitem">Open the <code class="literal">MainActivity.java</code> file in the wear module.</li><li class="listitem">In the <code class="literal">onCreate()</code> method, add the following code:<div><pre class="programlisting">FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
CardFragment cardFragment = CardFragment.create("Short title", "with a longer description");
fragmentTransaction.add(R.id.wearable_layout, cardFragment);
fragmentTransaction.commit();</pre></div></li><li class="listitem">Run<a id="id339" class="indexterm"/> the app on one or other of the wearable emulators to see how the default card looks.<div><img src="img/B04321_08_06.jpg" alt="Adding cards"/></div></li></ol></div><p>We met the <code class="literal">FragmentManager</code> in <a class="link" href="ch06.html" title="Chapter 6. Notifications and the Action Bar">Chapter 6</a>, <em>Notifications and the Action Bar</em> and here it operates in a very similar fashion and requires little explanation. The way we created the <code class="literal">CardFragment</code> itself, is also very straightforward. We used two string parameters here, but there is a third, drawable parameter and if the line is changed to <code class="literal">CardFragment cardFragment = CardFragment.create("TITLE", "with description and drawable", R.drawable.left_icon);</code> then we will get the following output:</p><div><img src="img/B04321_08_07.jpg" alt="Adding cards"/></div><p>This <a id="id340" class="indexterm"/>default implementation for cards on wearable is fine for most purposes and it can be customized by overriding its <code class="literal">onCreateContentView()</code> method. However, the <code class="literal">CardScrollView</code> is a very handy alternative, and this is what we will look at next.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec09"/>Customizing cards</h3></div></div></div><p>The <code class="literal">CardScrollView</code> is defined from within our layout and furthermore it detects screen shape and <a id="id341" class="indexterm"/>adjusts the margins to suit each shape. To see how this is done, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">activity_main.xml</code> file in the wear module.</li><li class="listitem">Delete or comment out every element, except the root <code class="literal">BoxInsetLayout</code>.</li><li class="listitem">Place the following <code class="literal">CardScrollView</code> inside the <code class="literal">BoxInsetLayout</code>:<div><pre class="programlisting">&lt;android.support.wearable.view.CardScrollView
  android:id="@+id/card_scroll_view"
  android:layout_height="match_parent"
  android:layout_width="match_parent"
  app:layout_box="bottom"&gt;

&lt;/android.support.wearable.view.CardScrollView&gt;</pre></div></li><li class="listitem">Inside this, add this <code class="literal">CardFrame</code>:<div><pre class="programlisting">&lt;android.support.wearable.view.CardFrame
  android:layout_width="match_parent"
  android:layout_height="wrap_content"&gt;

&lt;/android.support.wearable.view.CardFrame&gt;</pre></div></li><li class="listitem">Inside the <code class="literal">CardFrame</code>, add a <code class="literal">LinearLayout</code>.</li><li class="listitem">Add some <a id="id342" class="indexterm"/>views to this, so that the preview resembles the layout here:<div><img src="img/B04321_08_08.jpg" alt="Customizing cards"/></div></li><li class="listitem">Open the <code class="literal">MainActivity.java</code> file.</li><li class="listitem">Replace the code we added to the <code class="literal">onCreate()</code> method with this:<div><pre class="programlisting">CardScrollView cardScrollView = (CardScrollView) findViewById(R.id.card_scroll_view);
cardScrollView.setCardGravity(Gravity.BOTTOM);</pre></div></li><li class="listitem">You can now test the app on an emulator, which will produce the following result:<div><img src="img/B04321_08_09.jpg" alt="Customizing cards"/></div></li></ol></div><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>As can be seen in the previous image, the Android Studio has preview screens for both wearable shapes. Like some other previews, these are not always what you will see on a device, but they allow us to put layouts together very quickly, by dragging and dropping widgets.</p></div></div><p>As we <a id="id343" class="indexterm"/>can see, the <code class="literal">CardScrollView</code> and <code class="literal">CardFrame</code> are even easier to implement than the <code class="literal">CardFragment</code> and also far more flexible, as we can design almost any layout we can imagine. We assigned <code class="literal">app:layout_box</code> here again, only this time using <code class="literal">bottom</code>, causing the card to be placed as low on the screen as possible.</p><p>It is very important, when designing for such small screens, to keep our layouts as clean and simple as possible. Google's design principles state that wearable apps should be glanceable. This means that, as with a traditional wrist watch, the user should be able to glance at our app and immediately take in the information and return to what they were doing.</p><p>Another of Google's design principle—<em>Zero to low interaction</em>—is only a single tap or swipe a user needs to do to interact with our app. With these principles in mind, let us create a small app, with some actual functionality. In the next section, we will take advantage of the new heart rate sensor found in <a id="id344" class="indexterm"/>many wearable devices and display current beats-per-minute on the display.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec42"/>Accessing sensor data</h2></div></div></div><p>The location<a id="id345" class="indexterm"/> of an Android Wear device on the user's wrist, makes it the perfect piece of hardware for fitness apps, and not surprisingly, these apps are immensely popular. As with most features of the SDK, accessing sensors is pleasantly simple, using classes such as managers and listeners and requiring only a few lines of code, as you will see by following these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the project we have been working on in this chapter.</li><li class="listitem">Replace the background image with one that might be suitable for a fitness app. I have used a simple image of a heart.</li><li class="listitem">Open the <code class="literal">activity_main.xml</code> file.</li><li class="listitem">Delete everything, except the root <code class="literal">BoxInsetLayout</code>.</li><li class="listitem">Place this <code class="literal">TextView</code> inside it:<div><pre class="programlisting">  &lt;TextView
    android:id="@+id/text_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_gravity="center_vertical"
    android:gravity="center"
    android:text="BPM"
    android:textColor="@color/black"
    android:textSize="42sp" /&gt;</pre></div></li><li class="listitem">Open the Manifest file in the wear module.</li><li class="listitem">Add the following permission inside the root manifest node:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.BODY_SENSORS" /&gt;</pre></div></li><li class="listitem">Open the <code class="literal">MainActivity.java</code> file in the wear module.</li><li class="listitem">Add the following fields:<div><pre class="programlisting">private TextView textView;
private SensorManager sensorManager;
private Sensor sensor;</pre></div></li><li class="listitem">Implement a <code class="literal">SensorEventListener</code> on the Activity:<div><pre class="programlisting">public class MainActivity extends Activity implements SensorEventListener {</pre></div></li><li class="listitem">Implement the two methods required by the listener.</li><li class="listitem">Edit the <code class="literal">onCreate()</code> method, like this:<div><pre class="programlisting">@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);

  textView = (TextView) findViewById(R.id.text_view);

  sensorManager = ((SensorManager) getSystemService(SENSOR_SERVICE));
  sensor = sensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE);
}</pre></div></li><li class="listitem">Add <a id="id346" class="indexterm"/>this <code class="literal">onResume()</code> method:<div><pre class="programlisting">protected void onResume() {
  super.onResume();

  sensorManager.registerListener(this, this.sensor, 3);
}</pre></div></li><li class="listitem">And this <code class="literal">onPause()</code> method:<div><pre class="programlisting">@Override
protected void onPause() {
  super.onPause();

  sensorManager.unregisterListener(this);
}</pre></div></li><li class="listitem">Edit the <code class="literal">onSensorChanged()</code> callback, like so:<div><pre class="programlisting">@Override
public void onSensorChanged(SensorEvent event) {
  textView.setText("" + (int) event.values[0]);
}</pre></div></li><li class="listitem">If you do not have access to a real device, you can download a sensor simulator<a id="id347" class="indexterm"/> from here:<p>
<a class="ulink" href="https://code.google.com/p/openintents/wiki/SensorSimulator">https://code.google.com/p/openintents/wiki/SensorSimulator</a>
</p></li><li class="listitem">The app is now ready to test.<div><img src="img/B04321_08_10.jpg" alt="Accessing sensor data"/></div></li></ol></div><p>We <a id="id348" class="indexterm"/>began by adding a permission in the <code class="literal">AndroidManifest.xml</code> file in the appropriate module; this is something we have done before and need to do any time we are using features, that require the user's permission before installing.</p><p>The inclusion of a background image may seem necessary, but an appropriate background is a real aid to glancability as the user can tell instantly which app they are looking at.</p><p>It should be clear, from the way the <code class="literal">SensorManager</code> and the <code class="literal">Sensor</code> are set up in the <code class="literal">onCreate()</code> method, that all sensors are accessed in the same way and different sensors can be accessed with different constants. We used <code class="literal">TYPE_HEART_RATE</code> here, but any other sensor can be started with the appropriate constant, and all sensors can be managed with the same basic structures as we found here, the only real difference being the way each sensor returns <code class="literal">SensorEvent.values[]</code>. A comprehensive list of all sensors, and descriptions of the values they produce can be found at <a class="ulink" href="http://developer.android.com/reference/android/hardware/Sensor.html">http://developer.android.com/reference/android/hardware/Sensor.html</a>.</p><p>As with <a id="id349" class="indexterm"/>any time our apps utilize functions that run in the background, it is vital that we unregister our listeners, whenever they are no longer needed, in our Activity's <code class="literal">onPause()</code> method. We didn't use the <code class="literal">onAccuracyChanged()</code> callback here, but its purpose should be clear and there are many possible apps where its use is essential.</p><p>This concludes our exploration of wearable apps and how they are put together. Such devices continue to become more prevalent and the possibility of ever more imaginative uses is endless. Providing we consider why and how people use smart watches, and the like, and develop to take advantage of the location of these devices by programming glanceable interfaces that require the minimum of interactivity, Android Wear seems certain to grow in popularity and use, and the developers will continue to produce ever more innovative apps.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec37"/>Android TV</h1></div></div></div><p>At the opposite end of the size spectrum to Android Wear, is Android TV. Like Wear, the size <a id="id350" class="indexterm"/>of this form factor is all important, when it comes to how we design apps for it. The main consideration is the distance the user is from the screen, which is usually around 10 feet. This means designing simple and clean layouts and avoiding small and/or lengthy text.</p><p>Unlike Wear, many of the apps we design for phones and tablets can be made available for TVs as well. As one would imagine, this requires some fiddling around with the manifest, so as to make our apps visible to users searching for TV-specific apps in the Google Play store. Also, TVs do not have many of the functions that our phones do, such as GPS and touchscreens, and we need to take this into consideration as well.</p><p>The TV app template generated by the project wizard in Android Studio has bugs, and unless Google have fixed it by the time you read this, it is far from straightforward to use it to generate a working app. It is still worth taking a look though, as the Java directory contains over a dozen purpose-built classes that are very handy for apps designed for streaming and broadcasting television shows and the like.</p><p>The fact<a id="id351" class="indexterm"/> that the template does not work, is actually a good thing in our case, as we can use this section to see how to build a TV-compatible app from scratch or, if you prefer, how to convert an already developed app so that it is available to install on an Android TV.</p><p>The following exercise can be carried out using a blank activity template for a phone and a tablet or any app you have developed.</p><div><ol class="orderedlist arabic"><li class="listitem">Open your project's manifest file.</li><li class="listitem">Inside the root manifest node, add these permissions:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;

&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;</pre></div></li><li class="listitem">In the same node, add these feature uses:<div><pre class="programlisting">&lt;uses-feature
  android:name="android.hardware.touchscreen"
  android:required="false" /&gt;

&lt;uses-feature
  android:name="android.software.leanback"
  android:required="false" /&gt;

&lt;uses-feature
  android:name="android.hardware.microphone"
  android:required="false" /&gt;

&lt;uses-feature
  android:name="android.hardware.screen.portrait"
  android:required="false" /&gt;</pre></div></li><li class="listitem">Find or<a id="id352" class="indexterm"/> create a 320 x 180 px <code class="literal">xhdpi</code> banner image to represent your app. Ideally, it should contain text as well as an identifiable image, such as the following:<div><img src="img/B04321_08_11.jpg" alt="Android TV"/></div></li><li class="listitem">Place the image in your <code class="literal">drawable</code> folder, and call it <code class="literal">banner</code>.</li><li class="listitem">Add the following line inside the application node:<div><pre class="programlisting">android:banner="@drawable/banner"</pre></div></li><li class="listitem">Open your <code class="literal">build.gradle</code> file and add this dependency:<div><pre class="programlisting">compile 'com.android.support:leanback-v17:22.0.0'</pre></div></li><li class="listitem">Back in the manifest, change the theme declaration line to the following:<div><pre class="programlisting">android:theme="@style/Theme.Leanback"</pre></div></li><li class="listitem">Create a TV AVD and test the app.</li></ol></div><p>Although, we<a id="id353" class="indexterm"/> have not had to do very much here, there is still quite a lot to explain. Most of what we have done, is to make sure that our app is visible when browsing the Play store for TV apps. TVs do not support portrait screen layouts, so if this feature is required, it will simply not appear in the Play store as available for TV. We want to include the feature for devices that do support this orientation, and this is how we do that and still make our app available to TV users. We have to include the permission to record audio with all TV apps, but TVs do not generally support microphones.</p><p>The <strong>Leanback Support Library</strong> that we added in step 7 is a very useful tool for developing<a id="id354" class="indexterm"/> for TV. It provides a very suitable theme, <code class="literal">Theme.Leanback</code>, several useful widgets designed for TV, and it manages margins in such a way that our layout is not clipped. Without it, we would have to set wide margins of about 10 percent to avoid this kind of TV over-scanning.  If we wanted to write specifically for TV, we would also have changed the category inside our main activity's intent filter to <code class="literal">&lt;category android:name="android.intent.category.LEANBACK_LAUNCHER" /&gt;</code>.</p><p>There is quite a lot more to programming for Android TV, especially when it comes to broadcasting and streaming, that we cannot cover here. Generally speaking though, developing TV apps requires the same skills as programming for handheld devices and many apps run perfectly well on both formats. Providing we take into account the distance the user is from the screen and the limited input methods, we can write programs that provide a satisfying experience across all platforms.</p><p>The Android OS is a very flexible system and well suited to a wide variety of form factors. We've seen how it can run on screens as small as an inch and a half or as large as a home cinema. Android Lollipop heralded yet another new and exciting platform, allowing users to run Android apps when they are out in their cars.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec38"/>Android Auto</h1></div></div></div><p>Android Auto <a id="id355" class="indexterm"/>apps are apps that, when connected to a compatible car dashboard, run certain restricted content on the driver's dashboard. When developing for cars, the primary concern has to be safety and no Auto app that does not meet these strict standard will not be published on the Play store. Many Android apps are far too distracting to be suitable for use when driving. In fact, Android Auto really only supports two functions: audio playback and text-to-speech messaging. It is beyond the scope of this book to explore this comprehensively, but this is certainly a good time to see how such apps are set up and how to use the media and messaging simulators provided in the SDK. First though, we need to take a look at the safety rules insisted on by Google for<a id="id356" class="indexterm"/> Auto apps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There must be no animated elements on the Auto screen</li><li class="listitem" style="list-style-type: disc">Only audio ads are allowed</li><li class="listitem" style="list-style-type: disc">Apps must support voice control</li><li class="listitem" style="list-style-type: disc">All buttons and clickable controls must respond within two seconds</li><li class="listitem" style="list-style-type: disc">Text must be longer than 120 characters and must always be in the default Roboto font</li><li class="listitem" style="list-style-type: disc">Icons must be white, so that the system can control contrast</li><li class="listitem" style="list-style-type: disc">Apps must support day and night mode</li><li class="listitem" style="list-style-type: disc">App must support voice commands</li><li class="listitem" style="list-style-type: disc">App-specific buttons must respond to user actions with no more than a two-second delay</li></ul></div><p>IMPORTANT: These, and several other stipulations, will be tested by Google before publication, so it is essential that you run all of these tests yourself. The full list can be found at <a class="ulink" href="http://developer.android.com/distribute/essentials/quality/auto.html">http://developer.android.com/distribute/essentials/quality/auto.html</a>.</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>Designing <a id="id357" class="indexterm"/>apps that are suitable for day and night modes and that can have contrast controlled by the system to automatically remain readable in different light conditions, is quite a detailed subject and Google has produced a very useful guide to this, which can be found at <a class="ulink" href="http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf">http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf</a>.</p></div></div><p>Despite the restrictions we have covered Auto apps are developed in the same way as any other. There is<a id="id358" class="indexterm"/> one minor difference though, when developing for Auto, we need to define which in-car capabilities our app is using. This is done using an XML file. Follow these short steps, to see how:</p><div><ol class="orderedlist arabic"><li class="listitem">Start a new Android Studio project for phone and tablet, or open an existing one.</li><li class="listitem">Create a new <strong>Android resource directory</strong> inside the <code class="literal">res</code> directory and call it <code class="literal">xml</code>.<div><img src="img/B04321_08_12.jpg" alt="Android Auto"/></div></li><li class="listitem">Inside this <code class="literal">xml</code> folder, create a new Android resource file and call it something <a id="id359" class="indexterm"/>like <code class="literal">auto_config.xml</code>.</li><li class="listitem">Complete it as follows:<div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;

  &lt;automotiveApp&gt;
    &lt;uses name="media" /&gt;
    &lt;uses name="notification" /&gt;
  &lt;/automotiveApp&gt;</pre></div></li><li class="listitem">Open the manifest file.</li><li class="listitem">Add these lines inside the <code class="literal">application</code> node:<div><pre class="programlisting">&lt;meta-data android:name="com.google.android.gms.car.application"
  android:resource="@xml/auto_config"/&gt;</pre></div></li><li class="listitem">That's it, our app will now detect whether its host device is connected to a car dashboard.</li></ol></div><p>There are just two things here that need to be pointed out here. The two named uses are for running audio playback apps and receiving messages respectively. We would only need both, if our app was designed for both functions.</p><p>Google provide simulators for testing both media browsing and messaging apps, letting us test projects from the safety of a desk. The following steps demonstrate how to install them and use <a id="id360" class="indexterm"/>a telnet connection to send dummy SMS messages:</p><div><ol class="orderedlist arabic"><li class="listitem">From Android studio, open the SDK Manager.</li><li class="listitem">Make sure you have the latest versions of the Android Auto API Simulators, which are in the <code class="literal">Extras</code> folder.</li><li class="listitem">Connect a device or an emulator.</li><li class="listitem">Go to your <code class="literal">sdk/extras/google/simulators</code> folder and open the command window there, with <em>Shift</em> + right-click.</li><li class="listitem">Check that your device is connected with <code class="literal">adb devices</code>.</li><li class="listitem">Enter these two commands to install both simulators:<div><pre class="programlisting">
<strong>adb install media-browser-simulator.apk</strong>
<strong>adb install messaging-simulator.apk</strong>
</pre></div><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>If you are using a third party virtual device, such as Genymotion, you will be able to install these apps by dragging and dropping them onto the emulator's screen.</p></div></div></li></ol></div><p>Installing the <a id="id361" class="indexterm"/>simulators with an <code class="literal">adb</code> command is very simple, and of course any .<code class="literal">apk</code> file can be installed this way to a connected device. The media browser simulator can be tested with most media services such as Play Music.</p><div><img src="img/B04321_08_13.jpg" alt="Android Auto"/></div><p>Text can be sent to the messaging simulator by launching the <strong>Android Device Monitor</strong> from<a id="id362" class="indexterm"/> the <strong>Emulator Control</strong> tab.</p><p>That's about as much as we can cover of Android Auto here. The platform provides some of the most <a id="id363" class="indexterm"/>exciting new possibilities offered by Lollipop, and no doubt Android will be found in more and more vehicles in the future.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec39"/>Summary</h1></div></div></div><p>Android Wear, TV, and Auto represent radical departures from traditional form factors and are equally different from each other. This means that we have had to cover a lot of varied ground here.</p><p>Despite their diminutive size and functionality, wearables offer us an enormous range of possibilities. We know now how to create and connect wearable AVDs and how to develop easily for both square and round devices. We then went on to see what is required to set up a TV app, how to convert existing apps to be available on TV and about the useful library and features provided by Leanback support. We concluded by exploring the stringent safety rules that must be applied when developing and the tools available for testing Auto on.</p><p>One of the biggest overhauls, although perhaps less visible to the user, involves the camera APIs. These are entirely new to Lollipop and these along with adding multimedia to our apps is what we will move on to in the next chapter.</p></div></body></html>