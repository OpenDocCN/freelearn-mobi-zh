- en: Appendix A. Scripting Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting languages were originally intended to be lightweight languages for
    scripting common tasks, hence the name. They were thought of as languages for
    command-line utilities or as embedded languages to allow for easy customization
    of the control flow of a larger program. This appendix introduces how they can
    work with LevelDB, keeping things simple to help you draw analogies with the code
    you've learned. It doesn't debate the suitability of LevelDB as a database solution
    for scripting—the assumption is you're already interested in, or are already using
    LevelDB and just want to use it with other tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In the scientific world, the usability of Python made it increasingly popular
    for more complex programs and it has an enjoyed growth in web apps with frameworks
    such as Django. Ruby on Rails contributed substantially to the popularity of Ruby,
    to the extent where some people don't consider Ruby as a separate language. JavaScript,
    more officially ECMAScript, started as a browser language which has also grown
    into server-side programming. The popular Node.js environment packages it using
    Google's V8 engine to provide a standalone programming environment easily invoked
    from native code. In all these cases, the languages offer a relatively low overhead
    way to call C functions and thus to use external libraries that provide a C or
    C++ interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Whether writing web applications or local data crunching, database access is
    often useful. A typical web application uses a database server, and while that
    may be backed in turn by LevelDB, can't be said to be using LevelDB directly.
    However, if you need a single-access database, it's convenient to call it from
    a scripting language and so there have been multiple access layers written for
    LevelDB from these languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that the primary interface for LevelDB is C++ and
    that doesn't change just because you're programming in a scripting language. As
    you've learned through the Objective-C samples in this book, the C++ interface
    of LevelDB is a very lightweight one. You can regard the scripting language interfaces
    we look at here as being peers of the Objective-C frameworks we have been using.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We've seen in several chapters how using a custom comparator can add value to
    your database especially if you're using composite keys, or for case-insensitive
    searching. While many of the wrapper projects promise comparators as a future
    feature, it seems to be a weak point that they lack. Remember a comparator is
    a C++ object invoked by the core LevelDB code. To be able to implement them in
    a scripting language would require writing a coding bridge that can call back
    to the script from C++. Such `callback` functions are a lot more complex than
    the normal calling direction from script to database library. However, if you
    were hosting your script interpreter inside a larger native program, you could
    still write a custom comparator in C++ and have it work with the database.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在多个章节中看到，使用自定义比较器可以为你的数据库增加价值，尤其是如果你使用复合键，或者进行不区分大小写的搜索时。虽然许多包装项目承诺比较器作为未来的功能，但它们似乎缺少这一点。记住，比较器是一个由核心LevelDB代码调用的C++对象。要在脚本语言中实现它们，需要编写一个能够从C++回调到脚本的代码桥接器。这样的`回调`函数比从脚本到数据库库的正常调用方向要复杂得多。然而，如果你在更大的本地程序中托管你的脚本解释器，你仍然可以用C++编写自定义比较器，并使其与数据库一起工作。
- en: Using LevelDB from Node.js
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Node.js中使用LevelDB
- en: We went through the installation of Node.js and the LevelUP and LevelDOWN wrappers
    in [Chapter 7](ch07.html "Chapter 7. Debugging with REPLs and Command Lines"),
    *Debugging with REPLs and Command Lines*, as part of the installation of the **lev**
    utility. LevelDOWN is basically a republishing of the C++ interface into Node.js
    JavaScript syntax. Both are available, as you saw in the installer, by installing
    using **npm**, the **Node Package Manager**, and are now bundled into the level
    package. The homepage, with more installation options is [https://github.com/rvagg/node-levelup](https://github.com/rvagg/node-levelup)
    from which you can also clone the GIT repository if you want to contribute to
    the project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html "第7章。使用REPL和命令行进行调试")中介绍了Node.js和LevelUP以及LevelDOWN包装器的安装，*使用REPL和命令行进行调试*，作为安装**lev**实用程序的一部分。LevelDOWN基本上是将C++接口重新发布为Node.js
    JavaScript语法。两者都可通过**npm**（Node包管理器）安装，现在已包含在level包中。主页提供了更多安装选项，网址为[https://github.com/rvagg/node-levelup](https://github.com/rvagg/node-levelup)，如果你想为项目做出贡献，也可以从该地址克隆GIT仓库。
- en: The interesting evolution of LevelUP has been as an abstraction layer hiding
    the use of LevelDB underneath to the point where it no longer requires an installation
    of LevelDOWN, but can also work against other implementations including an in-memory
    store MemDown (see the previously mentioned home page for more details).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: LevelUP的有趣演变过程是一个抽象层，隐藏了底层使用LevelDB的过程，以至于它不再需要安装LevelDOWN，也可以与其他实现一起工作，包括内存存储MemDown（更多详情请参阅之前提到的主页）。
- en: 'Node.js programs are written as a series of callbacks invoked asynchronously,
    which makes sense considering its origin as a server-side language for web apps.
    A simple program that writes some data and reads it back is therefore structured
    as nested calls:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js程序以一系列异步调用的回调函数的形式编写，考虑到它原本是作为Web应用的服务器端语言，这样做是有意义的。因此，一个简单的写入一些数据并读取回的数据程序结构如下：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's a huge eco-system of node packages using LevelDB as a modular database.
    One particularly interesting one is **levelgraph**. You can download it from the
    home page [https://github.com/mcollina/levelgraph](https://github.com/mcollina/levelgraph)
    and use with LevelUP to provide the database layer. It provides a full-blown graph
    database abstraction using paired keys in a similar manner as our schema support
    described in [Chapter 8](ch08.html "Chapter 8. Richer Keys and Data Structures"),
    *Richer Keys and Data Structures*. However, levelgraph goes further to support
    classic triplet operations from graph database theory. It can be extended to support
    full RDF triplets with the levelgraph-n3 plugin from [https://github.com/mcollina/levelgraph-n3](https://github.com/mcollina/levelgraph-n3)
    which enables the compact N3 notation. See [http://www.w3.org/TeamSubmission/n3/](http://www.w3.org/TeamSubmission/n3/)
    if you're interested in graph databases and triplet-based knowledge representation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Using LevelDB from Python
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of Python wrappers for LevelDB that use the `Cython` tool
    set to generate an interface layer to talk to the C++ classes. The most recent
    and often recommended is plyvel: [https://plyvel.readthedocs.org/en/latest/installation.html](https://plyvel.readthedocs.org/en/latest/installation.html).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: However, there's also an even lower-level pure C API for LevelDB that allows
    you to call directly into functions in the shared library. One simple Python wrapper
    [https://code.google.com/p/leveldb-py/](https://code.google.com/p/leveldb-py/)
    is so simple that it is implemented with a single file. That file, `leveldb.py`,
    and the unit tests `test_leveldb.py` are included in the sample code for this
    chapter. You don't need to use a `pip` install or other command but just include
    the file alongside your call.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple wrapper, like many other scripting language wrappers, expects to
    have a dynamic library in a standard system location. This reflects their Unix
    heritage. Many installers actually rebuild LevelDB and push it into this location
    but this one requires you to do that work. To provide this library, go back to
    the build instructions in [Chapter 1](ch01.html "Chapter 1. Downloading LevelDB
    and Building with OS X"), *Downloading LevelDB and Building with OS X*, but this
    time, after you have built LevelDB, instead of renaming the static library, copy
    four files to `/usr/local/lib`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This ensures there is a dynamic library in the standard location so that an
    attempt to open a dynamic library named `leveldb` will work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to write a database similar to the previous Node.js code seen, looks
    a lot more like the C++ samples we''ve seen already:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To read that back we can just iterate through all of the keys and get their
    associated value:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Apart from supporting all of the basic LevelDB features we''ve seen so far,
    `leveldb.py` includes prefixing logic similar to that we added in Objective-C
    so you can get a subset of keys. The unit tests in `test_leveldb.py` include code
    such as:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持我们迄今为止看到的所有基本LevelDB功能外，`leveldb.py`还包括与我们在Objective-C中添加的前缀逻辑类似的逻辑，这样你可以获取键的子集。`test_leveldb.py`中的单元测试包括如下代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see from the last line that a prefixed retrieval of keys automatically
    strips the prefix, similar to what our code was doing to get keys for the `TableView`
    in Objective-C.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后一行可以看出，前缀检索键会自动去除前缀，这与我们在Objective-C中获取`TableView`键时所做的代码类似。
- en: Using LevelDB from Ruby
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ruby从LevelDB中获取
- en: 'The most commonly recommended Ruby wrapper for LevelDB is from [https://github.com/wmorgan/leveldb-ruby](https://github.com/wmorgan/leveldb-ruby)
    and can be installed, as seen in the log file included in the code samples for
    this chapter, with a gem command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最常推荐的LevelDB Ruby包装器来自[https://github.com/wmorgan/leveldb-ruby](https://github.com/wmorgan/leveldb-ruby)，如本章代码示例中包含的日志文件所示，可以使用gem命令进行安装：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that it has been stalled since 2011 and is minimal, not even including
    batch support. However, it supports the basics with code similar to the previous
    Python code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它自2011年以来一直处于停滞状态，且非常基础，甚至不包括批处理支持。然而，它使用与之前Python代码类似的代码支持了基本功能：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Unlike the Python code, reading back is idiomatically Ruby code where you can
    just treat the database as a dictionary and apply a block to it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python代码不同，Ruby代码在读取时是惯用的，你可以直接将数据库当作字典来处理，并对其应用一个块：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A much more useful and complete wrapper is [https://github.com/DAddYE/leveldb](https://github.com/DAddYE/leveldb)
    which includes nicer iterators and batches but has a more complex install and
    needs Ruby 2.0\. It adds batch support:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更实用且更完整的包装器是[https://github.com/DAddYE/leveldb](https://github.com/DAddYE/leveldb)，它包括更友好的迭代器和批处理，但安装过程更复杂，需要Ruby
    2.0。它增加了批处理支持：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sample as a Ruby style of code blocks uses the idiom that the block contains
    all the logic to apply to the batch so implies a write at the end of the block.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例作为Ruby风格的代码块使用了一个惯用表达式，即块包含所有要应用到批处理中的逻辑，因此暗示在块末尾进行写入。
- en: Summary
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We saw a little of the different styles of coding in the three dominant scripting
    languages. Take the opportunity to explore those links further and consider using
    a scripting language as a REPL to explore ideas with LevelDB. You might want to
    use one to quickly generate massive databases or play with different key structures.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在三种主流脚本语言中看到了不同的编码风格。抓住机会进一步探索那些链接，并考虑使用脚本语言作为REPL来探索LevelDB中的想法。你可能想用它快速生成大量数据库或玩转不同的键结构。
