- en: Appendix A. Scripting Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting languages were originally intended to be lightweight languages for
    scripting common tasks, hence the name. They were thought of as languages for
    command-line utilities or as embedded languages to allow for easy customization
    of the control flow of a larger program. This appendix introduces how they can
    work with LevelDB, keeping things simple to help you draw analogies with the code
    you've learned. It doesn't debate the suitability of LevelDB as a database solution
    for scripting—the assumption is you're already interested in, or are already using
    LevelDB and just want to use it with other tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the scientific world, the usability of Python made it increasingly popular
    for more complex programs and it has an enjoyed growth in web apps with frameworks
    such as Django. Ruby on Rails contributed substantially to the popularity of Ruby,
    to the extent where some people don't consider Ruby as a separate language. JavaScript,
    more officially ECMAScript, started as a browser language which has also grown
    into server-side programming. The popular Node.js environment packages it using
    Google's V8 engine to provide a standalone programming environment easily invoked
    from native code. In all these cases, the languages offer a relatively low overhead
    way to call C functions and thus to use external libraries that provide a C or
    C++ interface.
  prefs: []
  type: TYPE_NORMAL
- en: Whether writing web applications or local data crunching, database access is
    often useful. A typical web application uses a database server, and while that
    may be backed in turn by LevelDB, can't be said to be using LevelDB directly.
    However, if you need a single-access database, it's convenient to call it from
    a scripting language and so there have been multiple access layers written for
    LevelDB from these languages.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that the primary interface for LevelDB is C++ and
    that doesn't change just because you're programming in a scripting language. As
    you've learned through the Objective-C samples in this book, the C++ interface
    of LevelDB is a very lightweight one. You can regard the scripting language interfaces
    we look at here as being peers of the Objective-C frameworks we have been using.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen in several chapters how using a custom comparator can add value to
    your database especially if you're using composite keys, or for case-insensitive
    searching. While many of the wrapper projects promise comparators as a future
    feature, it seems to be a weak point that they lack. Remember a comparator is
    a C++ object invoked by the core LevelDB code. To be able to implement them in
    a scripting language would require writing a coding bridge that can call back
    to the script from C++. Such `callback` functions are a lot more complex than
    the normal calling direction from script to database library. However, if you
    were hosting your script interpreter inside a larger native program, you could
    still write a custom comparator in C++ and have it work with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Using LevelDB from Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We went through the installation of Node.js and the LevelUP and LevelDOWN wrappers
    in [Chapter 7](ch07.html "Chapter 7. Debugging with REPLs and Command Lines"),
    *Debugging with REPLs and Command Lines*, as part of the installation of the **lev**
    utility. LevelDOWN is basically a republishing of the C++ interface into Node.js
    JavaScript syntax. Both are available, as you saw in the installer, by installing
    using **npm**, the **Node Package Manager**, and are now bundled into the level
    package. The homepage, with more installation options is [https://github.com/rvagg/node-levelup](https://github.com/rvagg/node-levelup)
    from which you can also clone the GIT repository if you want to contribute to
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting evolution of LevelUP has been as an abstraction layer hiding
    the use of LevelDB underneath to the point where it no longer requires an installation
    of LevelDOWN, but can also work against other implementations including an in-memory
    store MemDown (see the previously mentioned home page for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js programs are written as a series of callbacks invoked asynchronously,
    which makes sense considering its origin as a server-side language for web apps.
    A simple program that writes some data and reads it back is therefore structured
    as nested calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There's a huge eco-system of node packages using LevelDB as a modular database.
    One particularly interesting one is **levelgraph**. You can download it from the
    home page [https://github.com/mcollina/levelgraph](https://github.com/mcollina/levelgraph)
    and use with LevelUP to provide the database layer. It provides a full-blown graph
    database abstraction using paired keys in a similar manner as our schema support
    described in [Chapter 8](ch08.html "Chapter 8. Richer Keys and Data Structures"),
    *Richer Keys and Data Structures*. However, levelgraph goes further to support
    classic triplet operations from graph database theory. It can be extended to support
    full RDF triplets with the levelgraph-n3 plugin from [https://github.com/mcollina/levelgraph-n3](https://github.com/mcollina/levelgraph-n3)
    which enables the compact N3 notation. See [http://www.w3.org/TeamSubmission/n3/](http://www.w3.org/TeamSubmission/n3/)
    if you're interested in graph databases and triplet-based knowledge representation.
  prefs: []
  type: TYPE_NORMAL
- en: Using LevelDB from Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of Python wrappers for LevelDB that use the `Cython` tool
    set to generate an interface layer to talk to the C++ classes. The most recent
    and often recommended is plyvel: [https://plyvel.readthedocs.org/en/latest/installation.html](https://plyvel.readthedocs.org/en/latest/installation.html).'
  prefs: []
  type: TYPE_NORMAL
- en: However, there's also an even lower-level pure C API for LevelDB that allows
    you to call directly into functions in the shared library. One simple Python wrapper
    [https://code.google.com/p/leveldb-py/](https://code.google.com/p/leveldb-py/)
    is so simple that it is implemented with a single file. That file, `leveldb.py`,
    and the unit tests `test_leveldb.py` are included in the sample code for this
    chapter. You don't need to use a `pip` install or other command but just include
    the file alongside your call.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple wrapper, like many other scripting language wrappers, expects to
    have a dynamic library in a standard system location. This reflects their Unix
    heritage. Many installers actually rebuild LevelDB and push it into this location
    but this one requires you to do that work. To provide this library, go back to
    the build instructions in [Chapter 1](ch01.html "Chapter 1. Downloading LevelDB
    and Building with OS X"), *Downloading LevelDB and Building with OS X*, but this
    time, after you have built LevelDB, instead of renaming the static library, copy
    four files to `/usr/local/lib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This ensures there is a dynamic library in the standard location so that an
    attempt to open a dynamic library named `leveldb` will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to write a database similar to the previous Node.js code seen, looks
    a lot more like the C++ samples we''ve seen already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To read that back we can just iterate through all of the keys and get their
    associated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from supporting all of the basic LevelDB features we''ve seen so far,
    `leveldb.py` includes prefixing logic similar to that we added in Objective-C
    so you can get a subset of keys. The unit tests in `test_leveldb.py` include code
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the last line that a prefixed retrieval of keys automatically
    strips the prefix, similar to what our code was doing to get keys for the `TableView`
    in Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Using LevelDB from Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most commonly recommended Ruby wrapper for LevelDB is from [https://github.com/wmorgan/leveldb-ruby](https://github.com/wmorgan/leveldb-ruby)
    and can be installed, as seen in the log file included in the code samples for
    this chapter, with a gem command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it has been stalled since 2011 and is minimal, not even including
    batch support. However, it supports the basics with code similar to the previous
    Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the Python code, reading back is idiomatically Ruby code where you can
    just treat the database as a dictionary and apply a block to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A much more useful and complete wrapper is [https://github.com/DAddYE/leveldb](https://github.com/DAddYE/leveldb)
    which includes nicer iterators and batches but has a more complex install and
    needs Ruby 2.0\. It adds batch support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This sample as a Ruby style of code blocks uses the idiom that the block contains
    all the logic to apply to the batch so implies a write at the end of the block.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw a little of the different styles of coding in the three dominant scripting
    languages. Take the opportunity to explore those links further and consider using
    a scripting language as a REPL to explore ideas with LevelDB. You might want to
    use one to quickly generate massive databases or play with different key structures.
  prefs: []
  type: TYPE_NORMAL
