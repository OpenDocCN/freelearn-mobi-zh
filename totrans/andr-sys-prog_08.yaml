- en: Creating Your Own Device on VirtualBox
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VirtualBox上创建您的设备
- en: 'We have learned how to customize and enhance an existing device to support
    new features using x86emu. The x86emu device is a device created on top of the
    following Android emulators: goldfish and ranchu. From this chapter to [Chapter
    11](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml), *Enabling VirtualBox-Specific
    Hardware Interfaces*, we will move to an advanced topic: porting Android systems.
    What can we do with a hardware platform that is not supported by AOSP?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用x86emu定制和增强现有设备以支持新功能。x86emu设备是在以下Android模拟器之上创建的设备：goldfish和ranchu。从本章到第11章[启用VirtualBox特定硬件接口]，我们将转向一个高级主题：移植Android系统。对于AOSP不支持的平台，我们能做什么？
- en: 'In this chapter, we will move to a new device, x86vbox. We will create this
    new x86vbox device to run it on VirtualBox. Since VirtualBox is virtual hardware
    that is not supported by AOSP directly, we have to create the HAL layer by ourselves.
    Creating the HAL layer by ourselves doesn''t mean we have to create everything
    from scratch. As I mentioned earlier, porting and customization are the art of
    integration. We can integrate device drivers for the devices that we need from
    other open source projects. In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将转向一个新的设备，x86vbox。我们将创建这个新的x86vbox设备，以便在VirtualBox上运行它。由于VirtualBox是AOSP直接不支持的虚拟硬件，我们必须自己创建HAL层。自己创建HAL层并不意味着我们必须从头开始创建一切。正如我之前提到的，移植和定制是集成的艺术。我们可以从其他开源项目中集成我们需要的设备驱动程序。在本章中，我们将涵盖以下主题：
- en: Analyzing the HAL of the Android-x86 project and using the Android-x86 HAL for
    the x86vbox device
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析Android-x86项目的HAL并使用Android-x86 HAL为x86vbox设备
- en: Creating the x86vbox device based on the analysis of Android-x86 HAL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Android-x86 HAL分析创建x86vbox设备
- en: Analyzing the start-up process for x86vbox
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析x86vbox的启动过程
- en: HAL of x86vbox
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86vbox的HAL
- en: 'Before we create the new x86vbox device, we need to resolve a key issue: creating
    the HAL for x86vbox. What this means is that we need to support the hardware devices
    that appear on VirtualBox. As we said previously, the Android-x86 project is a
    project that aims to provide **Board Support Package** (**BSP**) for any x86-based
    computing devices. Even though VirtualBox is a virtualized x86 hardware environment,
    we can still use part of Android-x86 projects to support it. In the following
    table, we can see a list of projects that we reused from Android-x86\. There are
    three project categories that we need to include in our build from Android-x86:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建新的x86vbox设备之前，我们需要解决一个关键问题：创建x86vbox的HAL。这意味着我们需要支持在VirtualBox上出现的硬件设备。正如我们之前所说的，Android-x86项目是一个旨在为任何基于x86的计算设备提供**板级支持包**（**BSP**）的项目。尽管VirtualBox是一个虚拟化的x86硬件环境，我们仍然可以使用Android-x86项目的一部分来支持它。在下面的表中，我们可以看到我们从Android-x86中重用的项目列表。我们需要在构建中包含以下三个项目类别：
- en: '**Linux kernel**: Android-x86 provides a kernel that can work with Android
    for Intel x86 architecture.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux内核**：Android-x86提供了一个可以与Android配合使用的内核，用于Intel x86架构。'
- en: '**HAL for Intel x86 architecture**: Android-x86 includes HAL support on most
    devices that you can find on your PC.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**针对Intel x86架构的HAL**：Android-x86在大多数你可以在PC上找到的设备上包含了HAL支持。'
- en: '**Android system projects and framework projects**: Android-x86 changed some
    projects under the `system/` and `frameworks/` directories to meet x86 architecture-specific
    requirements. For example, `init` and `init.rc` under `system/core` have been
    changed to work with the two-stage start up of Android-x86.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android系统项目和框架项目**：Android-x86将`system/`和`frameworks/`目录下的某些项目进行了更改，以满足x86架构特定的要求。例如，`system/core`下的`init`和`init.rc`已经被更改以与Android-x86的双阶段启动相兼容。'
- en: 'In the following table, we can also look at the projects in another dimension:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表中，我们还可以从另一个维度查看项目：
- en: AOSP projects changed by Android-x86.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android-x86更改的AOSP项目。
- en: Android-x86 only projects.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持Android-x86的项目。
- en: x86vbox--only projects.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持x86vbox的项目。
- en: In this chapter and the following chapters, we will create the x86vbox device
    and make changes to some of the following projects to run x86vbox on VirtualBox.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和随后的章节中，我们将创建x86vbox设备，并对以下一些项目进行更改，以便在VirtualBox上运行x86vbox。
- en: 'In the following table, all kernel- and HAL-related projects from AOSP, Android-x86,
    and x86vbox are listed. The projects that are created or changed by them are marked
    with **X**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表中，我们还列出了来自AOSP、Android-x86和x86vbox的所有内核和HAL相关项目。由它们创建或更改的项目用**X**标记：
- en: '| **Project** | **AOSP** | **Android-x86** | **x86vbox** | **HAL module** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **项目** | **AOSP** | **Android-x86** | **x86vbox** | **HAL 模块** |'
- en: '| `kernel` | X | X | X |  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `kernel` | X | X | X |  |'
- en: '| `device/generic/x86vbox` |  |  | X |  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `device/generic/x86vbox` |  |  | X |  |'
- en: '| `bionic` | X | X |  |  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `bionic` | X | X |  |  |'
- en: '| `bootable/newinstaller` |  | X | X |  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `bootable/newinstaller` |  | X | X |  |'
- en: '| `device/generic/common` | X | X | X |  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `device/generic/common` | X | X | X |  |'
- en: '| `device/generic/firmware` |  | X |  |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `device/generic/firmware` |  | X |  |  |'
- en: '| `external/alsa-lib` |  | X |  |  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `external/alsa-lib` |  | X |  |  |'
- en: '| `external/alsa-utils` |  | X |  |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `external/alsa-utils` |  | X |  |  |'
- en: '| `external/bluetooth/bluez` |  | X |  | `bluetooth.default` `audio.a2dp.default`
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `external/bluetooth/bluez` |  | X |  | `bluetooth.default` `audio.a2dp.default`
    |'
- en: '| `external/bluetooth/glib` |  | X |  |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `external/bluetooth/glib` |  | X |  |  |'
- en: '| `external/bluetooth/sbc` |  | X |  |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `external/bluetooth/sbc` |  | X |  |  |'
- en: '| `external/busybox` |  | X |  |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `external/busybox` |  | X |  |  |'
- en: '| `external/drm_gralloc` | X | X |  | `gralloc.drm` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `external/drm_gralloc` | X | X |  | `gralloc.drm` |'
- en: '| `external/drm_hwcomposer` | X | X |  | `hwcomposer.drm` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `external/drm_hwcomposer` | X | X |  | `hwcomposer.drm` |'
- en: '| `external/e2fsprogs` | X | X |  |  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `external/e2fsprogs` | X | X |  |  |'
- en: '| `external/ffmpeg` |  | X |  |  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `external/ffmpeg` |  | X |  |  |'
- en: '| `external/libdrm` | X | X |  |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `external/libdrm` | X | X |  |  |'
- en: '| `external/libpciaccess` |  | X |  |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `external/libpciaccess` |  | X |  |  |'
- en: '| `external/libtruezip` |  | X |  |  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `external/libtruezip` |  | X |  |  |'
- en: '| `external/llvm` | X | X |  |  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `external/llvm` | X | X |  |  |'
- en: '| `external/mesa` |  | X |  |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `external/mesa` |  | X |  |  |'
- en: '| `external/s2tc` |  | X |  |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `external/s2tc` |  | X |  |  |'
- en: '| `external/stagefright-plugins` |  | X |  |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `external/stagefright-plugins` |  | X |  |  |'
- en: '| `external/v86d` |  | X |  |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `external/v86d` |  | X |  |  |'
- en: '| `frameworks/av` | X | X |  |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `frameworks/av` | X | X |  |  |'
- en: '| `frameworks/base` | X | X | X |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `frameworks/base` | X | X | X |  |'
- en: '| `frameworks/native` | X | X |  |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `frameworks/native` | X | X |  |  |'
- en: '| `hardware/broadcom/wlan` | X | X |  |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/broadcom/wlan` | X | X |  |  |'
- en: '| `hardware/gps` |  | X |  | `gps.default` `gps.huawei` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/gps` |  | X |  | `gps.default` `gps.huawei` |'
- en: '| `hardware/intel/audio_media` | X | X |  | `audio.primary.hdmi` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/intel/audio_media` | X | X |  | `audio.primary.hdmi` |'
- en: '| `hardware/intel/libsensors` |  | X |  | `sensors.hsb` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/intel/libsensors` |  | X |  | `sensors.hsb` |'
- en: '| `hardware/libaudio` |  | X |  | `audio.primary.x86` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/libaudio` |  | X |  | `audio.primary.x86` |'
- en: '| `hardware/libcamera` |  | X |  | `camera.x86` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/libcamera` |  | X |  | `camera.x86` |'
- en: '| `hardware/libhardware` | X | X |  | `libhardware` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/libhardware` | X | X |  | `libhardware` |'
- en: '| `hardware/libhardware_legacy` | X | X |  | `audio_policy.default` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/libhardware_legacy` | X | X |  | `audio_policy.default` |'
- en: '| `hardware/liblights` |  | X |  | `lights.default` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/liblights` |  | X |  | `lights.default` |'
- en: '| `hardware/libsensors` |  | X |  | `sensors.hdaps` `sensors.iio`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '| `hardware/libsensors` |  | X |  | `sensors.hdaps` `sensors.iio`'
- en: '`sensors.kbd`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`sensors.kbd`'
- en: '`sensors.s103t`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`sensors.s103t`'
- en: '`sensors.w500` |'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`sensors.w500` |'
- en: '| `hardware/ril` | X | X |  |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/ril` | X | X |  |  |'
- en: '| `hardware/x86power` |  | X |  | `power.x86` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `hardware/x86power` |  | X |  | `power.x86` |'
- en: '| `system/core` | X | X |  |  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `system/core` | X | X |  |  |'
- en: The manifest for x86vbox
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86vbox 的清单
- en: 'Based on an analysis of the preceding table, we can create the manifest file
    for x86vbox. From the preceding table, we can see that we reuse 39 projects from
    Android-x86 to form the HAL of VirtualBox. Out of these 39 projects, 16 of them
    are from AOSP and changed by Android-x86\. To run our x86vbox device on VirtualBox,
    we need to create the device x86vbox at `device/generic/x86vbox`. We also need
    to change four projects: `kernel`, `bootable/newinstaller`, `device/generic/common`,
    and `frameworks/base`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 preceding 表格的分析，我们可以为 x86vbox 创建清单文件。从前面的表格中，我们可以看到我们重用了来自 Android-x86 的
    39 个项目来形成 VirtualBox 的 HAL。在这 39 个项目中，有 16 个来自 AOSP，并由 Android-x86 进行了修改。为了在 VirtualBox
    上运行我们的 x86vbox 设备，我们需要在 `device/generic/x86vbox` 创建设备 x86vbox。我们还需要更改四个项目：`kernel`、`bootable/newinstaller`、`device/generic/common`
    和 `frameworks/base`。
- en: 'In the manifest of the x86vbox, we will include the preceding projects for
    the x86 kernel, HAL, and have modified `system/` as well as `frameworks/`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x86vbox 的清单中，我们将包括前面提到的项目，用于 x86 内核、HAL，并且修改了 `system/` 以及 `frameworks/`：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that the manifest of x86vbox includes two parts. The first part includes
    the x86 kernel, x86vbox HAL, and modified AOSP projects that are all in GitHub.
    The second part includes the original AOSP projects. All the projects in the second
    part are not touched by either Android-x86 or x86vbox. The majority of projects
    in the first part are changed by Android-x86 only so we don't have to do anything
    for these projects as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，x86vbox的清单包含两部分。第一部分包括x86内核、x86vbox HAL以及所有位于GitHub上的修改过的AOSP项目。第二部分包括原始的AOSP项目。第二部分的所有项目都没有被Android-x86或x86vbox修改过。第一部分的大多数项目只被Android-x86修改过，所以我们也不必对这些项目做任何事情。
- en: In the first part of manifest, all the projects in the `external/` or `hardware/`
    directory are x86 HAL-related projects. The only AOSP project that you may have
    questions is **bionic**. You may be wondering why it is changed by Android-x86,
    since it is the C library of Android. You may know that system calls are implemented
    in the C library in the Linux system. There are two system calls `ioperm` and
    `iopl` missing from the original bionic and they are needed by the `external/v86d`
    project, which is the user space daemon for the `vesafb` frame buffer driver.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单的第一部分中，`external/`或`hardware/`目录下的所有项目都与x86 HAL相关。你可能对唯一的AOSP项目**bionic**有疑问。你可能想知道为什么Android-x86会修改它，因为它是Android的C库。你可能知道系统调用是在Linux系统的C库中实现的。原始的bionic缺少两个系统调用`ioperm`和`iopl`，而它们是`external/v86d`项目所需要的，该项目是`vesafb`帧缓冲驱动器的用户空间守护进程。
- en: All the preceding analysis helps us to clarify the scope of work. As we can
    see, the scope of work is not as big as we thought at the beginning. There are
    many open source projects available nowadays. If we can reuse them as much as
    possible, the amount of work usually can be reduced dramatically.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述分析帮助我们明确了工作范围。正如我们所见，工作范围并不像我们最初想象的那么大。现在有很多开源项目可供使用。如果我们尽可能多地重用它们，通常可以大幅减少工作量。
- en: All Android-x86 projects in GitHub are forked from the Android-x86 mirror so
    that we can change them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub上的所有Android-x86项目都是从Android-x86镜像分叉的，这样我们就可以修改它们。
- en: Creating a new x86vbox device
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的x86vbox设备
- en: Once we have the HAL for VirtualBox, we can create a new device named x86vbox
    now. If we review how we created the x86emu device in [Chapter 4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml),
    *Customizing the Android Emulator*, we know that we need to have a board/device
    configuration Makefile and a product definition Makefile for a new device. We
    can also create a new device by inheriting it from an existing device. If we look
    at the preceding table of x86 HAL, we can see that there is a common x86 device
    project, `device/common`, which can be found in Android-x86\. We will create our
    new device x86vbox by inheriting from this common device for x86\. The x86vbox
    that we create in this chapter is a 32-bit x86 device. You can follow the same
    instructions to create an x86_64 device by yourself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了VirtualBox的HAL，我们现在可以创建一个名为x86vbox的新设备。如果我们回顾一下在[第4章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml)中创建x86emu设备的过程，*自定义Android模拟器*，我们知道我们需要为新设备准备一个板/设备配置Makefile和一个产品定义Makefile。我们也可以通过继承现有设备来创建一个新设备。如果我们查看前面的x86
    HAL表格，我们可以看到一个共同的x86设备项目，`device/common`，可以在Android-x86中找到。我们将通过继承这个共同的x86设备来创建我们的新设备x86vbox。本章中创建的x86vbox是一个32位x86设备。你可以按照相同的说明自己创建一个x86_64设备。
- en: 'As we did in [Chapter 4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml), *Customizing
    the Android Emulator*, we create an `AndroidProducts.mk` Makefile to include the
    product definition Makefile for x86vbox as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml)中所述，*自定义Android模拟器*，我们创建了一个`AndroidProducts.mk`
    Makefile来包含x86vbox的产品定义Makefile，如下所示：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Product definition Makefile of x86vbox
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86vbox的产品定义Makefile
- en: 'As we know, the AOSP build system will look for `AndroidProducts.mk` to find
    the product definition Makefile for a particular device. Let''s review the product
    definition Makefile `x86vbox.mk` as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，AOSP构建系统会查找`AndroidProducts.mk`以找到特定设备的产品定义Makefile。让我们回顾一下产品定义Makefile
    `x86vbox.mk`，如下所示：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we can see, the product definition Makefile is very simple. It does the
    following things:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，产品定义Makefile非常简单。它执行以下操作：
- en: It includes the general x86 product definition Makefile, `device/generic/common/x86.mk`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含了通用的x86产品定义Makefile，`device/generic/common/x86.mk`
- en: It defines product definition variables such as `PRODUCT_NAME`, `PRODUCT_BRAND`,
    `PRODUCT_DEVICE`, `PRODUCT_MODEL`, and so on
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了产品定义变量，例如`PRODUCT_NAME`、`PRODUCT_BRAND`、`PRODUCT_DEVICE`、`PRODUCT_MODEL`等
- en: It specifies how to build the kernel for x86vbox
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它指定了如何为x86vbox构建内核。
- en: It looks even simpler than the one we created in [Chapter 4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml),
    *Customizing the Android Emulator* for x86emu. The inherited `x86.mk` Makefile
    did most actual work and we will analyze it in greater depth later.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来甚至比我们在[第4章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml)中创建的*x86emu的Android模拟器*的定制版本还要简单。继承的`x86.mk`
    Makefile做了大部分实际工作，我们将在稍后进行更深入的分析。
- en: Board configuration of x86vbox
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86vbox的板级配置
- en: 'Another Makefile that we will create for x86vbox is the board configuration
    Makefile `BoardConfig.mk` as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为x86vbox创建的另一个Makefile是板级配置Makefile `BoardConfig.mk`，如下所示：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This looks very simple as well. It defines the target architecture--specific
    variables `TARGET_ARCH`, `TARGET_CPU_ABI`, `TARGET_CPU_ABI_LIST_32_BIT`, and `TARGET_CPU_ABI_LIST`.
    Then it defines the parameters for the system image file. Finally, it includes
    the common board configuration the Makefile `device/generic/common/BoardConfig.mk`
    and we will look at this in a moment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来也很简单。它定义了目标架构的特定变量`TARGET_ARCH`、`TARGET_CPU_ABI`、`TARGET_CPU_ABI_LIST_32_BIT`和`TARGET_CPU_ABI_LIST`。然后它定义了系统映像文件的参数。最后，它包含了通用的板级配置Makefile
    `device/generic/common/BoardConfig.mk`，我们稍后会查看这个文件。
- en: Common x86 devices
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的x86设备
- en: In the Android-x86 project, it defines a common x86 device so that everybody
    can create a specific x86 device based on it. The inherited device can be either
    a 32-bit or a 64-bit x86 device.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android-x86项目中，它定义了一个通用的x86设备，以便每个人都可以基于它创建特定的x86设备。继承的设备可以是32位或64位的x86设备。
- en: 'We can have a look at the content of `device/generic/common` first as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先查看`device/generic/common`的内容，如下所示：
- en: '![](img/image_08_001.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_001.png)'
- en: We can see that there are a lot of files and directories. We will start the
    analysis from the `BoardConfig.mk` and `x86.mk` Makefiles first.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有很多文件和目录。我们将首先从`BoardConfig.mk`和`x86.mk` Makefile开始分析。
- en: 'In `BoardConfig.mk`, the variables needed by the build system are defined as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BoardConfig.mk`中，构建系统所需的变量定义如下：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is a long list. It defines audio, Wi-Fi, GPU, and Bluetooth-related features.
    It is also a disabled emulator-related build.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个长长的列表。它定义了音频、Wi-Fi、GPU和蓝牙相关特性。它也是一个禁用的模拟器相关构建。
- en: 'Now, let''s have a look at `x86.mk`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`x86.mk`：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `x86.mk`, it includes two generic Makefiles, `full.mk` and `locales_full.mk`,
    from the AOSP build system. If we recall the device definition Makefile for x86emu,
    it also includes these two Makefiles from the build system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`x86.mk`中，它从AOSP构建系统中包含了两个通用Makefile，`full.mk`和`locales_full.mk`。如果我们回想一下x86emu的设备定义Makefile，它也从构建系统中包含了这两个Makefile。
- en: 'There are another two local Makefiles, `device.mk` and `packages.mk`, imported
    by `x86.mk`. In `packages.mk`, the HAL module packages are defined as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`x86.mk`还导入了另外两个本地Makefile，`device.mk`和`packages.mk`。在`packages.mk`中，HAL模块包定义如下：'
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is not an exhaustive list of packages. There are more components added
    to `PRODUCT_PACKAGES` in `device.mk` as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是包的完整列表。在`device.mk`中，还有更多组件被添加到`PRODUCT_PACKAGES`中，如下所示：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In `device.mk`, it defines the properties for x86 devices and it is followed
    by a long list of files to be copied. At the end, it includes individual Makefiles
    for various components, such as firmware, touchscreen a calibration tool, audio,
    GPS, a sensor and native bridge, and so on. You can find and investigate each
    of them in the respective folders by yourself. In this chapter, we just give an
    overview about how we can create the x86vbox device. We will delve into the details
    of some hardware interfaces in later chapters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`device.mk`中，它定义了x86设备的属性，并随后列出了要复制的文件列表。最后，它包括各种组件的单独Makefile，例如固件、触摸屏校准工具、音频、GPS、传感器和本地桥接器等。你可以自己分别在每个相应的文件夹中找到并调查它们。在本章中，我们只概述了如何创建x86vbox设备。我们将在后面的章节中深入探讨一些硬件接口的细节。
- en: Getting the source code and building the x86vbox device
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取源代码和构建x86vbox设备
- en: 'To build the x86vbox device, we can get the source code from GitHub and AOSP
    using the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建x86vbox设备，我们可以使用以下命令从GitHub和AOSP获取源代码：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `android-7.1.1_r4_ch08_aosp` tag is used to baseline the changes in this
    chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`android-7.1.1_r4_ch08_aosp`标签作为本章更改的基线。
- en: 'After we get the source code for this chapter, we can set the environment and
    build the system as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取本章的源代码后，我们可以设置环境和构建系统，如下所示：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Boot up process and device initialization
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动过程和设备初始化
- en: Since we use the Android-x86 kernel and HAL for x86vbox, we will further analyze
    about the start-up process of x86vbox in this section. From the analysis, we can
    understand how Android-x86 supports multiple devices using one codebase. You can
    review the two-stage start-up process that we discussed in [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml),
    *Debugging the Boot Up Process using a Customized ramdisk*. We will work on a
    more detailed analysis on top of that introduction now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Android-x86内核和HAL为x86vbox，我们将进一步分析本节中x86vbox的启动过程。通过分析，我们可以了解Android-x86是如何使用一个代码库支持多个设备的。你可以回顾我们在[第6章](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)，*使用自定义ramdisk调试启动过程*中讨论的两个阶段启动过程。现在，我们将在此基础上进行更详细的分析。
- en: The kernel of Android-x86 is different from the kernel that we used in [Chapter
    6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml), *Debugging the Boot Up Process
    using a Customized ramdisk* for emulators. The Android-x86 kernel does not have
    any idea about what hardware interfaces it needs to support, so it builds as many
    device drivers as possible with it. On the other hand, the goldfish kernel does
    know what hardware it needs to support. This difference means they are built in
    two different ways. The goldfish kernel includes all devices supported inside
    the kernel, so it does not use kernel modules at all. However, it is impossible
    for Android-x86 kernel to do this, since it would make the size of the kernel
    too big. The kernel of Android-x86 uses kernel modules extensively.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Android-x86的内核与我们[第6章](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)，*使用自定义ramdisk调试启动过程*中用于模拟器的内核不同。Android-x86内核并不知道它需要支持哪些硬件接口，因此它尽可能多地构建与它相关的设备驱动程序。另一方面，goldfish内核知道它需要支持哪些硬件。这种差异意味着它们是以两种不同的方式构建的。goldfish内核包含了内核内部支持的所有设备，因此它根本不使用内核模块。然而，对于Android-x86内核来说，这样做是不可能的，因为这会使内核的大小变得过大。Android-x86的内核广泛使用内核模块。
- en: We will focus on an analysis about how device nodes are created and how the
    kernel modules are loaded during the start-up process in this chapter. Since Android-x86
    boots up in two stages, the device initialization is also split into two stages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将重点分析设备节点是如何在启动过程中创建的，以及内核模块是如何加载的。由于Android-x86的启动分为两个阶段，设备初始化也被分为两个阶段。
- en: Device initialization before Android start-up
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android启动前的设备初始化
- en: The boot-up process will start with an embedded Linux environment as the first
    stage. Most devices will be initialized during this stage. The good thing is that
    Android-x86 can enter a shell environment with a debug console using a defined
    environment variable. In this console, we can check the system status to find
    out whether we have the right configuration that we want to create. The default
    init script comes with two debug checkpoints. The first checkpoint is after the
    root device is mounted. The second checkpoint is entered after all the drivers
    are loaded. Of course, you can set up as many checkpoints as you want by changing
    the init script.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程将从嵌入式Linux环境作为第一阶段开始。大多数设备将在这一阶段进行初始化。好事是，Android-x86可以通过定义的环境变量进入一个带有调试控制台的控制台环境。在这个控制台中，我们可以检查系统状态，以确定我们是否拥有我们想要创建的正确配置。默认的init脚本包含两个调试检查点。第一个检查点是在根设备挂载之后。第二个检查点是在所有驱动程序加载之后。当然，你可以通过更改init脚本来设置尽可能多的检查点。
- en: 'The following is the part of the init script that we want to look at before
    we enter the first checkpoint:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们进入第一个检查点之前想要查看的init脚本的一部分：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the early boot stage, the init script mounts the `/proc` and `/sys` filesystems
    using by kernels. After that, it sets up the symbolic links of `busybox` so that
    we can use all the commands of `busybox`. Then, it will set `/sbin/mdev` as the
    handler for hotplug. The `mdev` command is a minimal implementation of `udev`.
    `mdev` can dynamically manage the device nodes under `/dev`, when a new device
    is detected by the kernel. `mdev` is part of `busybox` so we need to create all
    `busybox` symbolic links first. It also requires the `/proc` and `/sys` filesystem.
    After the hotplug is set, the script runs the command `mdev -s` to find all existing
    devices currently found by the kernel. At this point, all device nodes under `/dev`
    are created.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期启动阶段，init脚本使用内核挂载`/proc`和`/sys`文件系统。之后，它设置`busybox`的符号链接，以便我们可以使用所有`busybox`命令。然后，它将`/sbin/mdev`设置为热插拔的处理程序。`mdev`命令是`udev`的最小实现。`mdev`可以在内核检测到新设备时动态管理`/dev`下的设备节点。`mdev`是`busybox`的一部分，因此我们需要首先创建所有`busybox`符号链接。它还需要`/proc`和`/sys`文件系统。设置热插拔后，脚本运行`mdev
    -s`命令以找到内核当前检测到的所有设备。此时，`/dev`下的所有设备节点都已创建。
- en: udev and **mdev** **udev** is a device manager for the Linux kernel. As the
    successor to devfsd and hotplug, udev primarily manages device nodes in the `/dev`
    directory. At the same time, udev also handles all user space events raised while
    hardware devices are added into the system or removed from it, including firmware
    loading as required by certain **devices.**
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: udev和**mdev** **udev**是Linux内核的设备管理器。作为devfsd和hotplug的后继者，udev主要管理`/dev`目录下的设备节点。同时，udev还处理在硬件设备添加到系统或从系统中移除时产生的所有用户空间事件，包括某些**设备**所需的固件加载。
- en: '**mdev** is a minimum implementation of udev in `busybox`. It is used in embedded
    systems to replace udev. mdev lacks some features in udev, such as completed implementation
    of device driver loading, and so on. We can see that Android-x86 uses mdev in
    the first start up stage.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**mdev**是`busybox`中udev的最小实现。它用于嵌入式系统以替换udev。mdev在udev中缺少一些功能，例如设备驱动程序加载的完整实现等。我们可以看到，Android-x86在第一次启动阶段使用mdev。'
- en: 'Let''s look at the kernel modules and device nodes at this stage:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个阶段的内核模块和设备节点：
- en: '![](img/image_08_002.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_002.png)'
- en: Kernel modules and device nodes
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块和设备节点
- en: As we can see from the preceding screenshot, all device nodes are created under
    `/dev`. However, there is only one kernel module loaded at this time. We are in
    the first checkpoint now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，所有设备节点都创建在`/dev`下。然而，此时只加载了一个内核模块。我们现在处于第一个检查点。
- en: Let's move on and see what happens in the script before we hit another checkpoint
    in the following code snippet. To exit from the first checkpoint, we need to run
    the `exit` command to continue executing the script.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看在达到下一个检查点之前的脚本中会发生什么。要退出第一个检查点，我们需要运行`exit`命令以继续执行脚本。
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After exit from the first checkpoint, it will continue to execute the following
    script:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出第一个检查点后，它将继续执行以下脚本：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see that the init script performs the following tasks before it enters
    the next checkpoint:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在进入下一个检查点之前，init脚本执行以下任务：
- en: Loads kernel modules.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载内核模块。
- en: Mounts the data partition.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载数据分区。
- en: Mounts the SD card.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载SD卡。
- en: Sets up the touch screen calibration tool.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置触摸屏校准工具。
- en: Sets up the screen DPI.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置屏幕DPI。
- en: Performs any other post-boot detection.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行任何其他启动后的检测。
- en: 'You can study the script for tasks 2 to 6 by yourself, since they are very
    straightforward and easy to understand. We want to look at the first task in more
    detail here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自行学习任务2到6的脚本，因为它们非常直接且易于理解。我们在这里想更详细地看看第一个任务：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `load_modules` script function is implemented in the script file `0-auto-detect`,
    as shown in the preceding snippet. It calls another function, `auto-detect`, to
    do the actual work. This function is not that easy to understand. Let's explain
    what it does now. The purpose of this function is to create a shell command called
    `dev2mod` on-the-fly. What this `dev2mod` function does is take the module alias
    as a parameter and load the respective driver module according to the module alias.
    After the `dev2mod` command is created, `auto_detect` will call this function
    using the devices found by the kernel under the `/sys/bus` folder.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_modules`脚本函数在前面代码片段所示的脚本文件`0-auto-detect`中实现。它调用另一个函数`auto-detect`来完成实际工作。这个函数并不容易理解。现在让我们解释一下它做了什么。这个函数的目的是动态创建一个名为`dev2mod`的shell命令。这个`dev2mod`函数的作用是接受模块别名作为参数，并根据模块别名加载相应的驱动模块。在创建`dev2mod`命令后，`auto_detect`将使用在`/sys/bus`文件夹下由内核找到的设备调用此函数。'
- en: 'All the kernel modules of the Android-x86 kernel can be found in the `/lib/modules/4.x.x-android-x86/modules.alias`
    file. This file is processed to add the `modprobe` command at the end of each
    line so that the kernel module can be loaded with the module alias as a parameter.
    The temporary script file can be found at `/tmp/dev2mod` and it looks like the
    following code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Android-x86内核的所有内核模块都可以在`/lib/modules/4.x.x-android-x86/modules.alias`文件中找到。此文件被处理，以便在每行的末尾添加`modprobe`命令，以便可以使用模块别名作为参数加载内核模块。临时脚本文件位于`/tmp/dev2mod`，如下所示代码片段：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before the devices in the `/sys` filesystem are passed to the `dev2mod` function,
    we can take a look at how the output looks like on my system as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`/sys`文件系统中的设备传递给`dev2mod`函数之前，我们可以查看在我的系统上输出看起来如下：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see from the preceding output, it includes all module aliases found
    by the kernel. The preceding output of module aliases will be passed to the shell
    script function `dev2mod` through a pipe. The `dev2mod` function will load all
    respective kernel modules found by the kernel.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述输出所示，它包括了内核找到的所有模块别名。模块别名的先前输出将通过管道传递给shell脚本函数`dev2mod`。`dev2mod`函数将加载内核找到的所有相应模块。
- en: 'After the `load_modules` are executed, we enter the second checkpoint and we
    can take a look at the system status now:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`load_modules`之后，我们进入第二个检查点，现在我们可以查看系统状态：
- en: '![](img/image_08_003.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_08_003.png)'
- en: Kernel modules are loaded
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块加载
- en: 'We can see from the preceding screenshot that there are many kernel modules
    loaded in the system now. From the kernel module name, we can see that the audio,
    mouse, and keyboard drivers are loaded. This is how the device drivers are loaded
    automatically by the Android-x86 init script in `initrd.img`. At the end of the
    init script, it will invoke `chroot` or `switch_root` according to the setting
    of the environment variable `DEBUG`. In either case, the root filesystem will
    be changed to the Android `ramdisk.img` and will start the Android init process
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述截图我们可以看到，现在系统中加载了许多内核模块。从内核模块名称中，我们可以看到音频、鼠标和键盘驱动程序已被加载。这就是Android-x86 init脚本在`initrd.img`中自动加载设备驱动程序的方式。在init脚本末尾，它将根据环境变量`DEBUG`的设置调用`chroot`或`switch_root`。在任一情况下，根文件系统将更改为Android的`ramdisk.img`，并启动Android
    init进程，如下所示：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Android init process will perform the hardware initialization for these
    devices that cannot be detected by the kernel automatically. The init process
    will also initialize the HAL of Android-x86.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Android init进程将为这些内核无法自动检测到的设备执行硬件初始化。init进程还将初始化Android-x86的HAL。
- en: HAL initialization during the Android start-up
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android启动时的HAL初始化
- en: Let's look in greater detail into the hardware initialization of devices that
    cannot be detected by the kernel automatically, and the initialization of Android-x86
    HAL, in this section. One of the peripherals that haven't been initialized is
    the frame buffer for the graphic user interface in Android. We will use it as
    an example to explain how hardware is initialized by the init process in Android's
    `ramdisk.img`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨一下内核无法自动检测到的设备的硬件初始化，以及Android-x86 HAL的初始化，本节将进行介绍。尚未初始化的一个外围设备是Android图形用户界面的帧缓冲区。我们将以此为例，解释Android的`ramdisk.img`中init进程是如何初始化硬件的。
- en: 'If we recall the analysis of the init process in [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml),
    *Debugging the Boot Up Process Using a Customized ramdisk*, the init process will
    execute the `init.rc` script, which is general for all Android devices. In the
    `init.rc` script, it will import a device-specific script `init.${ro.hardware}.rc`.
    In our case, this script is `init.x86vbox.rc` on the target device. The `ro.hardware`
    property is set according to the kernel command-line parameter, `androidboot.hardware`,
    which we set it to `x86vbox`. The source code of `init.x86vbox.rc` can be found
    at `device/generic/common/init.x86.rc`. It is copied to the target output using
    the following line in `device.mk`. Be aware that the script name is changed after
    the copy:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾第 6 章 [调试启动过程使用自定义的 ramdisk](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)
    中对 init 进程的分析，init 进程将执行 `init.rc` 脚本，这是适用于所有 Android 设备的通用脚本。在 `init.rc` 脚本中，它将导入特定设备的脚本
    `init.${ro.hardware}.rc`。在我们的案例中，这个脚本是在目标设备上的 `init.x86vbox.rc`。`ro.hardware`
    属性根据内核命令行参数 `androidboot.hardware` 设置，我们将其设置为 `x86vbox`。`init.x86vbox.rc` 的源代码可以在
    `device/generic/common/init.x86.rc` 中找到。它通过 `device.mk` 中的以下行复制到目标输出。请注意，脚本名称在复制后已更改：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Another thing that we can see from the preceding code snippet is that a shell
    script, `init.sh`, is also copied to the system image at `/system/etc/init.sh`.
    This is the script used to load device drivers and initialize HAL in `init.x86vbox.rc`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述代码片段中我们还可以看到，shell 脚本 `init.sh` 也被复制到了系统镜像的 `/system/etc/init.sh` 路径下。这是在
    `init.x86vbox.rc` 中用于加载设备驱动程序和初始化 HAL 的脚本。
- en: 'In `init.x86vbox.rc`, an action trigger is defined as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init.x86vbox.rc` 文件中，一个动作触发器被定义为如下：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the predefined trigger, `post-fs`, the `init.sh` script will be executed
    as part of the initialization process. The following is the code snippet of `init.sh`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在预定义的触发器 `post-fs` 中，`init.sh` 脚本将作为初始化过程的一部分执行。以下为 `init.sh` 的代码片段：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see from the preceding code snippet, the `init.sh` script processes
    the kernel command line first. After that, it runs into a multi-selection statement.
    It executes a function according to the first parameter passed to it. This parameter
    is used to let the `do_init` function initialize a particular HAL module. In the
    case of the first parameter, it''s `init` or without parameter, it will execute
    the `do_init` function. In this case, all HAL modules will be initialized and
    this is the case that we want to investigate now. We can see what the `do_init`
    function does as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`init.sh` 脚本首先处理内核命令行。之后，它遇到一个多选择语句。根据传递给它的第一个参数执行一个函数。这个参数用于让 `do_init`
    函数初始化特定的 HAL 模块。在第一个参数的情况下，它是 `init` 或没有参数，将执行 `do_init` 函数。在这种情况下，所有 HAL 模块都将被初始化，这是我们目前想要调查的情况。我们可以如下查看
    `do_init` 函数做了什么：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `do_init` function will call individual HAL module initialization functions
    one by one. We won''t look at all of them here. We will take a look at how the
    frame buffer device is initialized in the `init_hal_gralloc` function. This is
    the one that we will investigate more in Chapter 10, *Enabling Graphics*, since
    graphic support is one of the most important tasks when it comes to porting:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_init` 函数将逐个调用各个 HAL 模块初始化函数。我们在这里不会查看所有这些函数。我们将看看在 `init_hal_gralloc` 函数中如何初始化帧缓冲区设备。这是我们将在第
    10 章 *启用图形* 中更深入调查的内容，因为图形支持在移植过程中是最重要的任务之一：'
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `init_hal_gralloc` function, it will perform the respective tasks according
    to the content of `/proc/fb`. From `/proc/fb`, it can detect the type of graphic
    hardware on the device. If the type of graphic hardware cannot be detected, it
    will use a general VESA frame buffer (uvesafb), which is used in our case for
    VirtualBox. It will call another shell function, `init_uvesafb`, to load the VESA
    frame buffer driver. The uvesafb driver will start a user space daemon `v86d`
    to execute the x86 BIOS code. The code is executed in a controlled environment
    and the results are passed back to the kernel via the netlink interface. This
    is how the graphic driver is initialized in our environment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init_hal_gralloc` 函数中，它将根据 `/proc/fb` 的内容执行相应的任务。从 `/proc/fb`，它可以检测设备上图形硬件的类型。如果无法检测到图形硬件的类型，它将使用通用的
    VESA 帧缓冲区（uvesafb），在我们的案例中用于 VirtualBox。它将调用另一个 shell 函数 `init_uvesafb` 来加载 VESA
    帧缓冲区驱动程序。uvesafb 驱动程序将启动一个用户空间守护进程 `v86d` 来执行 x86 BIOS 代码。代码在受控环境中执行，并通过 netlink
    接口将结果传回内核。这就是在我们的环境中初始化图形驱动程序的方式。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the Android-x86 HAL and integrated it to x86vbox
    so that we are able to boot x86vbox over the next few chapters. We also analyzed
    the start-up process of Android-x86\. We used the debug console in the first stage
    of the start-up process to analyze the kernel module loading process. Before we
    can actually boot the x86vbox on VirtualBox, one issue that we haven't resolved
    is which bootloader we should use. Unlike the emulator, it does not need a bootloader,
    since the emulator uses a built-in mini bootloader to load the kernel and ramdisk.
    VirtualBox is very similar to real hardware. We won't be able to boot up an operating
    system without a proper bootloader.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了Android-x86 HAL并将其集成到x86vbox中，以便我们能够在接下来的几章中启动x86vbox。我们还分析了Android-x86的启动过程。在启动过程的第一个阶段，我们使用了调试控制台来分析内核模块加载过程。在我们实际上在VirtualBox上启动x86vbox之前，一个尚未解决的问题是我们应该使用哪个引导加载程序。与模拟器不同，它不需要引导加载程序，因为模拟器使用内置的迷你引导加载程序来加载内核和ramdisk。VirtualBox非常类似于真实硬件。如果没有合适的引导加载程序，我们将无法启动操作系统。
- en: In the next chapter, we will discuss this issue and we will explain how we can
    resolve it using PXE boot supported by VirtualBox.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论这个问题，并解释我们如何使用VirtualBox支持的PXE引导来解决它。
