- en: Chapter 4. iOS Guided Rover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to build software that can be used to control
    a rover robot. What's new in this? Children have been playing with radio-controlled
    toys for years now, and sometimes, we still play with such toys!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we are going to build a robot that can be controlled by iOS devices
    in the following three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Through manual commands: The two sliders on the iOS control: the rover''s steering
    and the throttle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By means of the iOS device movements in space: By moving an iOS device left
    and right, you can control the steering, and by moving the iOS device back and
    forth, you can control the throttle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using voice commands: By saying a few voice commands, an iOS device can
    control the steering and throttle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cool, isn't it? Let's quickly get started with this fascinating journey into
    robotics without forgetting that the techniques that you are going to learn here
    can be used in many other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is organized into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS guided rover requirements: We will briefly set the project requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hardware: We will describe the hardware and the electronic circuit that is
    needed for the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Arduino code: We will write the code for Arduino to control the external
    appliance and communicate with iOS devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The iOS code: We will write code for an iOS device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to go further: More ideas will be provided to improve the project and learn
    more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS guided rover requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to develop the Arduino and iOS software to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Control the direction and speed of a rover, powered by two motors from the
    iOS device by:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using manual commands
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the iOS device in space
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using voice commands
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure the slope and tilt angles so that the robot doesn't flip over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer commands and information back and forth between the rover and the iOS
    application by using the Bluetooth BLE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will assume that you have already built a rover robot like the ones shown
    on the following sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/1MzmIYs](http://bit.ly/1MzmIYs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://bit.ly/1Jo9qJS](http://bit.ly/1Jo9qJS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://bit.ly/1i7oTag](http://bit.ly/1i7oTag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also buy two motors and two wheels (for more information, visit [http://bit.ly/1i7oWTG](http://bit.ly/1i7oWTG)
    and [http://bit.ly/1KeHtdf](http://bit.ly/1KeHtdf)) and make the chassis yourself
    with metal or wood.
  prefs: []
  type: TYPE_NORMAL
- en: You will find everything that you may need on eBay ([http://www.ebay.com](http://www.ebay.com))
    at an affordable price.
  prefs: []
  type: TYPE_NORMAL
- en: Additional electronic components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we will need some additional components:'
  prefs: []
  type: TYPE_NORMAL
- en: Sparkfun DC Motor Driver TB6612FBG ([https://www.sparkfun.com/products/9457](https://www.sparkfun.com/products/9457)
    or [http://www.adafruit.com/product/2448](http://www.adafruit.com/product/2448))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharp GP2Y0A21YK Distance Measuring Sensor Unit ([https://www.sparkfun.com/products/242](https://www.sparkfun.com/products/242)),
    which can be replaced by similar units with minimum changes in the Arduino code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adafruit ADXL345 Triple-Axis Accelerometer ([http://www.adafruit.com/products/1231](http://www.adafruit.com/products/1231))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 330 Ω resistor 0.25w
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's an accelerometer?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will briefly discuss what an accelerometer is and how to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: An accelerometer is a device that measures acceleration along its 3 axes, and
    returns three voltage signals that are proportional to the acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: The acceleration measured by the accelerometer gives us information about the
    inclination of the accelerometer with respect to the terrestrial gravitational
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how acceleration is related to the inclination of the accelerometer,
    let''s examine the situation depicted in the following figures, where we consider
    only two axes (*z* and *x*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![What''s an accelerometer?](img/image00196.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In figure **1**, the accelerometer has the *z* axis is parallel to the gravity
    (**g**), and the *x* axis is orthogonal to the gravity. Hence, the acceleration
    along the *x* axis is zero. In figure **2**, the accelerometer rotates at an angle
    **α**. The acceleration along the accelerometer *x* axis is gx, and gx is what
    the accelerometer returns as the acceleration along the x axis. In conclusion,
    by rotating the accelerometer, we have an acceleration along the accelerometer
    *x* axis that is proportional to the rotation itself. The same is true for the
    *y* axis that is pointing into the page.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we use this behavior for mounting an accelerometer on the rover
    to measure its inclination along the transversal and the longitudinal axis. At
    the same time, we use the iOS device accelerometer to measure device inclination
    for controlling the direction and speed of the rover.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DC motor rotates in one direction when powered up and rotates in the opposite
    direction when the voltage polarity is inverted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following circuit diagrams depict ways to use switches to power the DC
    motor to invert the voltage polarity and rotation direction. In the following
    circuit diagram, the motor rotates in the clockwise direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00197.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'While in the second case, it rotates in the anticlockwise direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00198.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Transistors can replace switches in order to control the direction through electronic
    signals. A transistor-based circuit that replaces the four switches is called
    an H-bridge ([http://bit.ly/1JBmdrE](http://bit.ly/1JBmdrE)).
  prefs: []
  type: TYPE_NORMAL
- en: Basically, an H-bridge is a circuit that allows you to control the DC motor
    direction through two input signals. When the first signal is high and the second
    one is low, the motor runs in one direction; when the first signal is low and
    the second one is high, the motor runs in the opposite direction. To control the
    speed of the motor, we also need a PWM signal ([https://www.arduino.cc/en/Tutorial/PWM](https://www.arduino.cc/en/Tutorial/PWM)).
    The TB6612FBG motor driver includes two H-bridge circuits to power the two motors
    up to 1A.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table, derived from the TB6612FBG datasheet describes how to
    use the available input signals to control the motor:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Input | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **IN1** | **IN2** | **PWM** | **STBY** | **OUT1** | **OUT2** | **Mode** |'
  prefs: []
  type: TYPE_TB
- en: '| H | H | H/L | H | L | L | Short brake |'
  prefs: []
  type: TYPE_TB
- en: '| L | H | H | H | L | H | Motor runs |'
  prefs: []
  type: TYPE_TB
- en: '| L | H | L | L | Short brake |'
  prefs: []
  type: TYPE_TB
- en: '| H | L | H | H | H | L | Motor runs in the opposite direction |'
  prefs: []
  type: TYPE_TB
- en: '| L | H | L | L | Short brake |'
  prefs: []
  type: TYPE_TB
- en: '| L | L | H | H | OFF (high impedance) | Stop |'
  prefs: []
  type: TYPE_TB
- en: '| H/L | H/L | H/L | L | OFF (high impedance) | Standby |'
  prefs: []
  type: TYPE_TB
- en: To make the motor run in a direction, we have to make IN1 low and IN2 high.
    The PWM signals control the motor speed. To make the motor run in the opposition
    direction, we have to make IN1 high and IN2 low, and the PWM signals still control
    the motor's speed.
  prefs: []
  type: TYPE_NORMAL
- en: The PWM signals can be generated from Arduino by using the `analogWrite` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following electric diagram of the electronic circuit is what we need for
    the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As required, we need a distance sensor that has an analog output; the output
    voltage decreases as the distance to the front object decreases. The relation
    between the output voltage and distance is not linear (see the datasheet by visiting
    [https://www.sparkfun.com/datasheets/Components/GP2Y0A21YK.pdf](https://www.sparkfun.com/datasheets/Components/GP2Y0A21YK.pdf)),
    but it can be linearized in the range of the distance of interest. In our application,
    we just need to stop the rover when it is very close to an obstacle. So, we don't
    care much about the actual distance. The red LED shows when an obstacle is very
    close to the rover.
  prefs: []
  type: TYPE_NORMAL
- en: ADXL345 is a 3-axis accelerometer. It measures the acceleration along its three
    axes (in [m/s²]). When the rover is completely at rest and leveled, the acceleration
    is 0 m/s² on the x axis, 0 m/s² on the y axis, and 9.8 m/s² on the z axis because
    of the gravitational force. When the rover is not leveled, the values read along
    the axis are different. When the measured values exceed a threshold, we know that
    the rover is going to flip over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how to mount the circuit on a breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Electronic circuit](img/image00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that we used two different power sources, one for Arduino and the
    electronic components, and the other for the motors. This was done for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The motors can require a different voltage compared to the electronic components.
    The motor power source can have a different voltage up to 15V, as required by
    the TB6612FBG chip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Motors generate a lot of electric noise that can disturb the electronics. With
    this configuration, electronics and motors are electrically isolated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rover can operate for a longer time, especially by using rechargeable batteries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Motor wiring**'
  prefs: []
  type: TYPE_NORMAL
- en: In case a motor spins in the wrong direction, you have to invert its wires.
  prefs: []
  type: TYPE_NORMAL
- en: How to make the rover turn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When both the motors spin at the same speed, the rover goes straight. To make
    it turn right, reduce the speed of the right motor. The more we reduce the speed,
    the more the rover turns. This is exactly the same as the method that is used
    to make the rover turn left.
  prefs: []
  type: TYPE_NORMAL
- en: That said, the Arduino code has to manage the rotation speed of the two motors
    in order to control the direction of the motor.
  prefs: []
  type: TYPE_NORMAL
- en: How to mount the accelerometer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's very important that the accelerometer board be mounted in the right position
    in order to properly read acceleration and work with the Arduino code that is
    shown in the next chapter. The accelerometer board has to be tightly screwed to
    the rover chassis with a nut and a bolt (it is better to use two nuts and bolts,
    one for each side).
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to mount the accelerometer](img/image00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Arduino code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: To have a better understanding of the explanations in the next few paragraphs,
    open the downloaded code while reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further, we need to install the following additional libraries
    from Adafruit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adafruit ADXL345**: This is used to get measurements from the ADXL345 accelerometer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adafruit Unified Sensor**: This is a general library that is required from
    the previous one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To install the libraries into the Arduino IDE, open the menu **Sketch** | **Include
    Library** | **Manage Libraries …**. For more information, see [Chapter 2](part0019.xhtml#aid-I3QM1
    "Chapter 2. Bluetooth Pet Door Locker"), *Bluetooth Pet Door Locker*.
  prefs: []
  type: TYPE_NORMAL
- en: Setup code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the downloaded code, since the setup code is quite simple and
    doesn't require a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just note that `currentSpeed`, `leftSpeed`, and `rightSpeed` are: the current
    speed of the rover, the speed reduction of the left wheel used to make the rover
    turn left, and the speed reduction of the right wheel used to make the rover turn
    right respectively. They are obviously all set to zero in the setup function.'
  prefs: []
  type: TYPE_NORMAL
- en: The `goingForward` variable indicates whether the rover is going forward or
    backward, and it is initially set to yes (forward).
  prefs: []
  type: TYPE_NORMAL
- en: The final lines initialize the accelerometer, as required by the library. The
    `xOffset` and `yOffset` variables are about tuning the accelerometer readings
    when the rover is at rest and in a plane. We will talk about them in the *Testing
    and tuning* section.
  prefs: []
  type: TYPE_NORMAL
- en: Motor control functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before getting into the explanation of the main code, we will take a look at
    the motor control functions, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forward`: This configures the motor control to make the rover move forward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backward`: This configures the motor control to make the rover move backward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brake`: This stops the rover'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throttle`: This controls the speed of the rover and its direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the previous table for TB6612FBG (row 2), to make the motors go forward,
    we need to set IN1 to low and IN2 to high. This is exactly what the `forward`
    function does for both the motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `backward` function is similar. From row 3 of the previous table, we need
    to set IN1 to high and IN2 to low to change the direction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In both the functions, we set `STBY` to `HIGH` in case we previously stopped
    the rover by setting `STBY` to `LOW`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, by using the table (row 5), use the following function to stop the rover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `throttle` function is very important as it controls the speed and direction
    of the rover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To set the speed of each motor, we have to set an appropriate PWM signal to
    the PWM pin.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to move the rover in a straight line, set the speed in such a way
    that it is equal for both motors. Otherwise, reduce the speed of the wheel that
    is on the rover's side, which we want to turn to.
  prefs: []
  type: TYPE_NORMAL
- en: Main program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `loop` function of the rover control software is not very complex, and
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When an iOS device is connected, after every `ACCELEROMETER_CHECK_INTERVAL`
    milliseconds, the acceleration values along the *x* and *y* axes are sent to the
    iOS device. Then, the distance sensor is read. If the distance from an obstacle
    is greater than `DISTANCETHRESHOLD`, the rover stops and the LED on the rover
    is turned on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the distance sensor readings are quite variable (like with most of the
    analog sensors), the mean value of 16 readings is used through the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To control the rover, the iOS function has to send the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'F: This is used to move the rover forward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'B: This is used to move the rover backward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T=<speed>: This is used to move the rover at a speed of <speed>. The <speed>
    lies in the 0-100 range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R=<speed>: This is used to move the rover right by reducing the current speed
    of the right motor to <speed>. The <speed> lies in the 0-100 range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'L=<speed>: This is used to move the rover left by reducing the current speed
    of the left motor to <speed>. The <speed> lies in the 0-100 range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we already know from the *Bluetooth Pet Locker* project in [Chapter 2](part0019.xhtml#aid-I3QM1
    "Chapter 2. Bluetooth Pet Door Locker"), *Bluetooth Pet Door Locker*, commands
    from the iOS controller are received in the `rxCallback` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The F(orward) and B(ackward) commands are very easy to handle, since we have
    the respective function to call.
  prefs: []
  type: TYPE_NORMAL
- en: For the T(hrottle) command, we get the required reduction speed in the `value`
    variable, and we proportionally scale it from the range of 0-100 to the range
    0-255 (`currentSpeed = map(atoi(value), 0, 100, 0, 255)`). This is the expected
    range for the PWM signal.
  prefs: []
  type: TYPE_NORMAL
- en: The function ends by calling the `throttle` function, which sets the speed for
    both the motors, thus setting the PWM signal.
  prefs: []
  type: TYPE_NORMAL
- en: For the R(ight) command, we get the required reduction speed in the `value`
    variable. Then, we proportionally scale the 0-100 to the range 0-`currentSpeed`.
    In fact, the speed reduction of the right motor cannot be larger than the actual
    motor speed. In other words, when the command value is 255 (the maximum rotation
    speed), the speed of the right motor is reduced to 0, and the rover turns right.
    The same thing happens for the L(eft) command.
  prefs: []
  type: TYPE_NORMAL
- en: iOS code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at the iOS application that remotely controls
    the rover. This application allows us to manually control the rover by the means
    of two sliders, that emulate the steering wheel and the throttle.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are going to push the application a lot further by using the iOS
    device accelerometer and even voice commands. These techniques can be successfully
    applied to many other projects too.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a step at a time so that you can understand every important detail.
    We will start from the manual control. As always, the full code of this project
    can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: To have a better understanding of the explanations in the next paragraphs, open
    the downloaded code while reading.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Xcode project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a new project as we already did in the previous chapters. The
    following are the parameters for the new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project Type**: Tabbed application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product Name**: Rover'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language**: Objective-C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: Universal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the project''s options, we need to deselect the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Landscape Right**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Landscape Left**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We do this because we are going to use the iOS accelerometer, and we don''t
    want the screen to rotate when we rotate the device (see the following screenshot).
    To access the project''s options, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the project in the left pane of Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **General** tab in the right pane.![Creating the Xcode project](img/image00202.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need additional code with the graphics components to show the rover inclination
    by the means of two gauges. The library can be downloaded from [https://github.com/sabymike/MSSimpleGauge](https://github.com/sabymike/MSSimpleGauge).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the additional code, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the preceding link and click on the **Download ZIP** button on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the downloaded ZIP file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Gauges` folder and copy the files to the `Rover` folder of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Rover** group in Xcode and right-click on it. Select **Add Files
    to "Rover"…**. Then, select the files that you just copied and click on **Add**.
    Make sure that **Copy items if needed** is selected (see the following screenshot):![Creating
    the Xcode project](img/image00203.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Xcode, select the files that you just added, right-click on them, select
    **New Group from Selection**, and then enter `Gauges`. This helps us keep the
    code organized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid a compilation error, open the file `MSArcLayer.h` and add `#import
    <UIKit/UIKit.h>` just before `#import <QuartzCore/QuartzCore.h>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need the library to accept voice commands (OpenEars), which can be downloaded
    from [http://www.politepix.com/openears/](http://www.politepix.com/openears/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Download OpenEars** button. To install the library, you have
    to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Uncompress the downloaded file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside your downloaded distribution, there is a folder called `Framework`. Drag
    the `Framework` folder into your app project in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have configured the required additional libraries, we can start
    creating the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of this project is very close to the Pet Door Locker. So, we
    can reuse at least a part of the user interface and the code, by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **FirstViewController.h** and **FirstViewController.m**, right-click
    on them, and click on **Delete** (see the following screenshot). Then, click on
    **Move to Trash**:![Creating the Xcode project](img/image00204.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the same procedure, delete **SecondViewController** and **Main.storyboard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **PetDoorLocker** project in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the following files and drag and drop them to the **Rover** project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PetDoorLockerViewController.h**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PetDoorLockerViewController.m**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BLEConnectionViewController.h**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BLEConnectionViewController.m**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main.storyboard**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Be sure that **Copy items if needed** is selected, and then click on **Finish**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have added icons to the Tab Bar, don't forget to drag and drop them too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rename `PetDoorLockerViewController` to `RoverViewController` by using the same
    procedure that we used in the previous chapters.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Main.storyboard** and locate the main **View** controller.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the following GUI components:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Door Status**, **Temperature**, **Label**, and **Lock** labels
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **switch** component
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Move the status view close to the **connect** button and update its Layout Constraints.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the GUI components and the related Layout Constraints, as shown in the following
    screenshot:![Creating the Xcode project](img/image00205.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top, there are two UIViews for which, the size is 64 x 128 and the class
    is MSRangeGauge (change it in the Property Inspector)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the **Throttle** slider, go to the Property Inspector and set the following
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Minimum Value**: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum Value**: 100'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current Value**: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thumb Tin**: Red or whatever you like'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the **Steering** slider, go to the Property Inspector and set the following
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Minimum Value**: 0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum Value**: 200'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current Value**: 100'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the Segment Control, go to the Property Inspector and set **Segments** to
    3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the titles by double-clicking on each segment and entering the following
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerometer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Voice
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the View Controller container and in the Identity Inspector, change **Class**
    to **RoverViewController**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `RoverViewController.h` file, add `#import "MSRangeGauge.h"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Link the GUI components to the RoverViewController code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In your `RoverViewController.m`, there still are some references to the older
    project. Don't bother about these references. We will remove them in the following
    sections.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Link the Throttle slider to the method, as follows: `(IBAction)throttleChanged:(UISlider
    *)sender`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Link the Steering slider to the method, as follows: `(IBAction)steeringWheelChanged:(UISlider
    *)sender`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Link the forward/backward switch to the method, as follows: `(IBAction)directionChanged:(UISwitch
    *)sender`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Link the mode segment controller with the method, as follows: `(IBAction)modeChange:(UISegmentedControl
    *)sender`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing code for BLEConnectionViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have copied this View Controller from the PetDoorLocker project, we
    don't need to change it.
  prefs: []
  type: TYPE_NORMAL
- en: We saved some work!
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for RoverViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we have to remove the unnecessary code from the previous PetDoorLocker
    project that we don''t need anymore, by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `RoverViewController.m`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the lines that refer to `_temperature` and `_doorStatus` in the code.
    Please refer to the downloaded code in case you have any doubt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Empty the `dataReceived` function; we will rewrite it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Completely remove the `switchChanged` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now start writing new code to control our rover.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start from the easy part—receiving acceleration data from the rover. This
    data gives us information about the rover's inclination along its longitudinal
    and transverse axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'This information will be shown by the two gauges (RMRangeGauges) that we added
    in the main screen. The gauges have to be initialized in the viewDidLoad method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code is very easy to understand, thanks to the self-documenting names of
    the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the gauges are horizontal and don''t have any features to show the needle
    vertically, we use the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code, we rotate the first gauge by 90 degrees in order to
    have a better indication of the vertical inclination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inclination data is received by the dataReceived method as a string: <vertical
    inclination>:<horizontal inclination>, and the values are set to the two gauges,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `didDisconnectPeripheral` method, which is called when the Bluetooth
    device disconnects, we have to reset the position of the two gauges by adding
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since we have three modes to operate the Rover—manually, by using the iOS accelerometer,
    and through voice commands—we are going to divide the code writing into three
    different sections to have a better understanding of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Code to control the rover manually
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this scenario, we have to write the code that manages the Throttle slider
    to control the speed of the rover, the Steering slider to control its direction,
    and the switch to control its forward or backward movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the Throttle slider is quite simple, since we only have to send
    a message to the rover in the form of T=<speed>, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The method that is used to control the direction is not that complex. It sends
    two messages depending on the position of the slider with respect to its middle—R=<speed>
    to turn the rover towards the right and L=<speed> to turn the rover towards the
    left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete the management of the two sliders, we need to change the `didConnectPeripheral`
    method so that when the iOS device connects to the Rover, the two sliders are
    reset to their initial position, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method that we need to write is to control the forward/backward direction.
    We need to send two simple messages to the rover—`F` is for forward and `B` is
    for backward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To avoid undesirable behavior, each time we switch the direction, the rover
    is stopped, by setting the speed to 0 via the `[self throttleChanged:_throttleSlider]`
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready for the rover's first test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Rover with manual driving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To perform the first rover test, you can use the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Upload the Arduino code and check the console for any error message. If everything
    goes fine, Arduino is ready to take control over your rover.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power up both the motors and Arduino itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the iOS application to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the second tab to scan for the Bluetooth BLE breakout board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the first tab and progressively increase the Throttle slider. You should
    see the rover moving forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can make it move right and left by moving the Steering slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn the direction switch, the rover stops. On increasing the speed again, the
    rover moves in the opposite direction it was moving before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When going on a slope, you will see the needle of the vertical and/or the horizontal
    gauge move up or down and/or left or right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When moving against an obstacle, the rover should stop before colliding against
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Weird rover movements**'
  prefs: []
  type: TYPE_NORMAL
- en: If the rover moves in a wrong direction, you probably have not wired either
    or both of the motors properly. Swap the wires of the motor that is spinning in
    the wrong direction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Weird gauge indications**'
  prefs: []
  type: TYPE_NORMAL
- en: If the gauges don't seem to be moving accordingly with the slope, don't worry
    too much about this for now. We are going to calibrate them later. For now, we
    only have to check whether the data is being properly transferred from the rover
    to the iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Missing gauge indications**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot see any indication from the gauges, there may be an error in
    cabling the ADXL345 device. First double-check whether the Arduino console has
    any error message. If this doesn''t help, remove the comments from the following
    two lines in the Arduino code (the `main loop`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Connect the iOS device again and check the Arduino console. If you can see the
    printed numbers, then the accelerometer is working and you have to double-check
    the iOS code.
  prefs: []
  type: TYPE_NORMAL
- en: '**The rover hits obstacles**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance sensor is sensitive to the shape, reflectance, and position of
    the obstacles and sometimes, it''s not able to avoid them. This is the reason
    why different types of sensors are used at the same time, and in different positions
    in real-world robots. To check whether the sensor is properly connected and it''s
    working as expected, you can remove the comment in the following line (in the
    `main loop`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You should now be able to see the distance in the Arduino console.
  prefs: []
  type: TYPE_NORMAL
- en: Code for controlling the rover by the means of the iOS accelerometer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now going to improve our app by using the iOS accelerometer to control
    the steering and the throttle.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned earlier, any deviation in the iOS device position can be measured
    and used to send appropriate commands to the rover with the help of the accelerometer
    that we mounted on the rover.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the accelerometer information, we need to use the `CMMotionManager`
    class. First, we add `#import <CoreMotion/CoreMotion.h>` to `RoverViewController.h`.
    Then, we create a property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we initialize it in the `viewDidLoad` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The accelerometer is activated when the second button is selected on the segment
    controller, and the related method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `useAccelerometer` method actually activates the accelerometer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `[_motionManager setDeviceMotionUpdateInterval:0.2]` method instructs the
    motion manager to update our code with acceleration values every 0.2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The next method actually starts updating our code of accelerometer values, which
    are received in the handler block.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, iOS provide us with not only the actual value of acceleration along
    the three axes of the device, but also the quaternions. Don't be afraid of the
    name! They simply represent orientations and rotations of the iOS device in three
    dimensions (if you like mathematics, visit [https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)).
    From them, you can easily calculate the two angles of the pitch and roll of the
    iOS device (see the following image).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a liking for mathematics, visit [https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles](https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code for controlling the rover by the means of the iOS accelerometer](img/image00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The roll is used to change the rover's direction of movement, and the pitch
    is used to control the throttle. The `-(void)sendAccelerometersCommands:(CMQuaternion)quad`
    method calculatesthe two angles and generates the messages that need to be sent
    to the rover, as we did in `throttleChanged` and `steeringWheelChanged`.
  prefs: []
  type: TYPE_NORMAL
- en: Driving the rover by the means of the iOS device movement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test the rover, tap on the accelerometer, switch to forward, and hold the
    iOS device vertically. By moving the device forward around the pitch axis (see
    the previous image), the rover should start moving forward. The more the device
    moves forward, the more the rover's speed increases. By moving the device backward,
    the rover's speed reduces, and you can stop the rover by using this movement.
  prefs: []
  type: TYPE_NORMAL
- en: To turn the rover left or right, the device has to be turned left or right around
    the roll axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the commands more or less responsive, you can try to change the frequency
    at which the code is updated with new acceleration values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget that increasing the update interval increases the battery consumption.
    The tradeoff is strictly related to your rover and your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Code for controlling the rover by voice commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Voice recognition has been a challenge for years, but nowadays, you can add
    this feature to your application in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already added the required library. So, we can start adding the required
    code by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `RoverViewController.h` and add `#import <OpenEars/OEEventsObserver.h>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the interface from `@interface RoverViewController : UIViewController
    <CBCentralManagerDelegate, CBPeripheralDelegate>` to `@interface RoverViewController
    : UIViewController <CBCentralManagerDelegate, CBPeripheralDelegate, OEEventsObserverDelegate>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `RoverViewController.m` and add the following imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the properties by adding the following code to the `viewDidLoad`
    method. The `words` array contains the voice commands that will be recognized.
    The rest of the code is from the documentation of the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `modeChange` method in the following way (turn off the voice commands
    recognition and/or accelerometer when they are not being used):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `useVoice` method. It activates the listening of voice commands
    and configures the library in order to call the `pocketsphinxDidReceiveHypothesis`
    delegate method when a voice command is recognized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `pocketsphinxDidReceiveHypothesis` method, which can be copied from
    the downloaded code. It doesn''t do much other than formatting and sending commands
    to the rover much as we already did for the other modes. We just need to point
    out the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `hypothesis` parameter is a string with the recognized command
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[_fliteController say:hypothesis withVoice:self.slt]` call allows you to
    hear the recognized command that is pronounced by your iOS device
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the app, we have to add few lines in the `applicationDidEnterBackground`
    method in the `AppDelegate.m` file to disconnect from the rover when the app is
    sent to the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Driving the rover by voice commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To try this feature, you have to tap on Voice and then speak any of the available
    commands. When the application identifies a voice command, it pronounces the recognized
    command and the rover will start moving accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the voice recognition takes some time. Hence, the rover is
    not very responsive. The voice mode is more appropriate in wide space and for
    long navigation (whatever this could mean for a rover!)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you experience low background noises that trigger speech recognition, you
    can raise the value in this call in the range of 1.5-3.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the rover a little bit more responsive, you can try to reduce the time
    that the app should wait for after the speech ends to attempt recognizing the
    speech (the default value is 0.7 seconds), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Testing and tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already tested each mode of driving the rover, but we may still have
    unreliable readings from the accelerometer that is mounted on the rover itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calibrate the accelerometer''s readings, use the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the ADXL345 is firmly mounted on the rover, and its axes are
    parallel to the longitudinal and transverse axes of the rover.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the rover on a firm, flat surface and ensure that the rover is in plane
    with the help of a spirit level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Comment out the following lines in the `loop` function of the Arduino code
    and upload it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Power Arduino via the USB cable and open the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the iOS device. The acceleration reading appears on the console for
    both the axes. They should be 0 or very close to 0\. If this is not the case,
    take 10 to 20 readings, calculate the average, and put these values in the `setup`
    function for the `xOffset` and `yOffset` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the readings from the accelerometer should be more consistent, and the
    two needles on the iOS devices should help you drive the rover on rough terrain,
    avoiding overturns.
  prefs: []
  type: TYPE_NORMAL
- en: How to go further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some suggestions to improve the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Show the distance to the front obstacles in the iOS application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the rover when its inclination goes beyond a certain threshold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add more distance sensors or mount the distance sensor on a servo motor so that
    the rover can detect obstacles all around it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount different types of sensors for better obstacle avoidance (for instance,
    ultrasound distance sensors or laser distance sensors).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow iOS device landscape orientation. Here's a hint—you need to get the actual
    iOS device orientation by using one of the orientation delegate methods (`willTransitionToTraitCollection,viewWillTransitionToSize`),
    which is provided by the `ViewController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Voice recognition can be used on many projects because it's very simple to set
    up and works pretty well. You can start adding voice recognition to the Wi-Fi
    Power Plug project.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a challenge, try to improve your rover by making it move autonomously,
    which can be done by making the rover become aware of its position. (A hint—you
    can use particle filters to accomplish this, but this is a very tough subject.
    The Google car is based on this and a lot of other things as well).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You were introduced to the fascinating world of robotics and controlled vehicles.
    You learned how to write Arduino code to control both the speed and the direction
    of rotation of DC motors, measure the distance with an analog infrared sensor,
    and measure acceleration along the three axes by using an accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to use new graphical components such as the `UISlider` and the
    `UISegmentedControl` on an iOS device, and take advantage of the accelerometer
    that is sported by iOS devices. Moreover, you learned how to improve your projects
    with a very powerful and easy-to-use library for voice recognition and text to
    speech.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that you now have a rover that you can drive without other people
    thinking that you are odd; you are not playing like you were a child, you are
    learning robotics! Have fun with your rover!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is quite long and the project was complex, but we can now catch
    our breath. In the next chapter, we will build a very simple but extremely powerful
    project. It controls the volume of your TV set by keeping it at almost the same
    level even if commercials are on air. Even if the project is pretty easy, you
    will learn a lot about IR transmitters and receivers, and digital signal processing.
  prefs: []
  type: TYPE_NORMAL
