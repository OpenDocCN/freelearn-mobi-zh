<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Everything Is Connected &#x2013; Memory Management"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Everything Is Connected – Memory Management</h1></div></div></div><p>When using an app, there is nothing worse than it being slow and unresponsive. Computer users have come to expect every piece of software to respond immediately to every interaction. Even<a class="indexterm" id="id301"/> the most feature-rich app will be ruined if it is unpleasant to use because it doesn't manage the device resources effectively. Also, with the growing popularity of mobile computers and devices, it is more important than ever to write software that uses battery power efficiently. One of the aspects of writing software that has the largest impact on both responsiveness and battery power is memory management.</p><p>In this chapter, we will discuss techniques specific to Swift that allow us to manage memory in order to ensure that our code remains responsive and minimizes its effect on battery life and other apps. We will do so by covering the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Computer data storage</li><li class="listitem" style="list-style-type: disc">Value types versus reference types</li><li class="listitem" style="list-style-type: disc">Automatic reference counting</li><li class="listitem" style="list-style-type: disc">Strong reference cycles</li><li class="listitem" style="list-style-type: disc">Lost objects</li><li class="listitem" style="list-style-type: disc">Structures versus classes</li></ul></div><div class="section" title="Computer data storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Computer data storage</h1></div></div></div><p>Before <a class="indexterm" id="id302"/>we start looking at the code, we need to understand in some detail how data is represented in a computer. The common cliché is that all data in a computer is in 1s and 0s. This is true, but not so important when talking about memory management. Instead, we are concerned about <span class="emphasis"><em>where</em></span> the data is stored. All computers, whether a desktop, laptop, tablet, or phone, store data in two places.</p><p>The first place we normally think of is the file system. It is stored on a dedicated piece of hardware; this is called a hard disk drive in many computers, but more recently, some computers have started to use solid-state drives. The other thing we hear about when buying <a class="indexterm" id="id303"/>computers is the amount of "memory" it has. Computer memory comes in "sticks" which hold less information than normal drives. All data, even if primarily stored on the Internet somewhere, must be loaded into the computer's memory so that we can interact with it.</p><p>Let's take a look at what that means for us as programmers.</p><div class="section" title="File system"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec64"/>File system</h2></div></div></div><p>The<a class="indexterm" id="id304"/> file system is designed for long-term storage of data. It is far slower to access than memory, but it is much more cost effective for storing a lot of data. As the name implies, the file system is simply a hierarchical tree of files, which we as users can interact with directly using the <span class="emphasis"><em>Finder</em></span> on a Mac. This file system still exists on iPhones and iPads but it is hidden from us. However, software can still read and write the file system, thus allowing us to store data permanently, even after turning the device off.</p></div><div class="section" title="Memory"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec65"/>Memory</h2></div></div></div><p>Memory is <a class="indexterm" id="id305"/>a little more complex than the file system. It is designed to store the necessary data, temporarily for the software running currently. Unlike with a file system, all memory is lost as soon as you turn off your device. The analogy is similar to how we humans have short-term and long-term memory. While we are having a conversation or thinking about something, we have a certain subset of the information we are actively thinking about and the rest is in our long-term memory. In order to actively think about something, we have to recall it from our long-term memory into our short-term memory.</p><p>Memory is quick to access, but it is much more expensive. When computers start to act abnormally slow, it is commonly because it is very close to using up all of its memory. This is because the operating system will automatically start using the file system as a backup when memory is low. Information that is meant for short-term storage is automatically written to the file system instead, making it much slower to access again.</p><p>This is similar to how we humans have a problem processing too much information at once. If we try to add two 20-digit numbers in our head, it is going to take us a long time or simply be impossible. Instead, we often write out the partial solution on paper, as we go along. In this case, the paper is acting as our file system. It would be faster if we could just remember everything instead of taking the time to write it down and read it back, but we simply can't process that much information at one time.</p><p>This is important to consider when programming because we want to reduce the amount of memory that we use at any given time. Using a lot of memory doesn't only negatively affect our own <a class="indexterm" id="id306"/>software; it can negatively affect the entire computer's performance. Also, when the operating system has to resort to using the file system, the extra processing and extra access to a second piece of hardware causes more power usage.</p><p>Now that we understand our goal, we can start discussing how we manage memory better in Swift.</p></div></div></div>
<div class="section" title="Value types versus reference types"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Value types versus reference types</h1></div></div></div><p>All <a class="indexterm" id="id307"/>variables and constants in Swift are stored in memory. In fact, unless you explicitly write data to the file system, everything you create is going to be in memory. In Swift, there are two different categories of types. These two categories are <span class="strong"><strong>value types</strong></span> and <span class="strong"><strong>reference types</strong></span>. The only way in which they differ is in the way they behave when they get assigned to new variables, passed into methods, or captured in closures. Essentially, they only differ when you try to assign a new variable or constant to the value of an existing variable or constant.</p><p>A value type is always copied when being assigned somewhere new while a reference type is not. Before we look at exactly what that means in more detail, let's go over how we determine if a type is a value type or a reference type.</p><div class="section" title="Determining value type or reference type"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec66"/>Determining value type or reference type</h2></div></div></div><p>A value type<a class="indexterm" id="id308"/> is any type that is defined as either a structure or an enumeration, while all classes are reference types. This is easy to determine for your own custom types based on how you declared them. Beyond that, all of the built-in types for Swift, such as strings, arrays, and dictionaries <a class="indexterm" id="id309"/>are value types. If you are ever uncertain, you can test any of the two types you want in a playground, to see if its behavior is consistent with a value type or a reference type. The simplest behavior to check is what happens on assignment.</p></div><div class="section" title="Behavior on assignment"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec67"/>Behavior on assignment</h2></div></div></div><p>When <a class="indexterm" id="id310"/>a value type is reassigned, it is copied so that afterwards each variable or constant holds a distinct value that can be changed independently. Let's take a look at a simple example using a string:</p><div class="informalexample"><pre class="programlisting">var value1 = "Hello"
var value2 = value1
value1 += " World!"
print(value1) // "Hello World!"
print(value2) // "Hello"</pre></div><p>As you can see, when <code class="literal">value2</code> is set to <code class="literal">value1</code> a copy gets created. This is so that when we append <code class="literal">" World!"</code> to <code class="literal">value1</code>, <code class="literal">value2</code> remains unchanged, as <code class="literal">"Hello"</code>. We can visualize them as two completely separate entities:</p><div class="mediaobject"><img alt="Behavior on assignment" src="graphics/B05103_07_01.jpg"/></div><p>On the <a class="indexterm" id="id311"/>other hand, let's take a look at what happens with a reference type:</p><div class="informalexample"><pre class="programlisting">class Person {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}
var reference1 = Person(name: "Kai")
var reference2 = reference1
reference1.name = "Naya"
print(reference1.name) // "Naya"
print(reference2.name) // "Naya"</pre></div><p>As you can see, when we changed the name of <code class="literal">reference1</code>, <code class="literal">reference2</code> was also changed. So why is this? As the name implies, reference types are simply references to an instance. When you assign a reference to another variable or constant, both are actually referring to the exact same instance. We can visualize it as two separate objects referencing the same instance:</p><div class="mediaobject"><img alt="Behavior on assignment" src="graphics/B05103_07_02.jpg"/></div><p>In the <a class="indexterm" id="id312"/>real world, this would be like two kids sharing a toy. Both can play with the toy but if one breaks the toy, it is broken for both kids.</p><p>However, it is important to realize that if you assign a reference type to a new value, it does not change the value it was originally referencing:</p><div class="informalexample"><pre class="programlisting">reference2 = Person(name: "Kai")
print(reference1.name) // "Naya"
print(reference2.name) // "Kai"</pre></div><p>As you can see, we assigned <code class="literal">reference2</code> to an entirely different <code class="literal">Person</code> instance, so they can now be manipulated independently. We can then visualize this as two separate references on two separate instances, as shown in the following image:</p><div class="mediaobject"><img alt="Behavior on assignment" src="graphics/B05103_07_03.jpg"/></div><p>This will be like buying a new toy for one of the kids.</p><p>This <a class="indexterm" id="id313"/>shows you that a reference type is actually a special version of a value type. The difference is that a reference type is not itself an instance of any type. It is simply a way to refer to another instance, sort of like a placeholder. You can copy the reference so that you have two variables referencing the same instance, or you can give a variable a completely new reference to a new instance. With reference types, there is an extra layer of indirection based on sharing instances between multiple variables.</p><p>Now that we know this, the simplest way to verify if a type is a value type or a reference type is to check its behavior when being assigned. If the second value is changed when you modify the first value, it means that the type you are testing is a reference type.</p></div><div class="section" title="Behavior on input"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec68"/>Behavior on input</h2></div></div></div><p>Another <a class="indexterm" id="id314"/>place where the behavior of a value type differs from a reference type is when passing them into functions and methods. However, the behavior is very simple to remember if you look at passing a variable or constant into a function as just another assignment. This means that when you pass a value type into a function, it is copied while a reference type still shares the same instance:</p><div class="informalexample"><pre class="programlisting">func setNameOfPerson(person: Person, var to name: String) {
    person.name = name
    name = "Other Name"
}</pre></div><p>Here we have defined a function that takes both a reference type: <code class="literal">Person</code> and a value type: <code class="literal">String</code>. When we update the <code class="literal">Person</code> type within the function, the person we passed in is also changed:</p><div class="informalexample"><pre class="programlisting">var person = Person(name: "Sarah")
var newName = "Jamison"
setNameOfPerson(person, to: newName)

print(person.name) // "Jamison"
print(newName) // "Jamison"</pre></div><p>However, when<a class="indexterm" id="id315"/> we change the string within the function, the <code class="literal">String</code> passed into it remains unchanged.</p><p>The place where things get a little more complicated is with <code class="literal">inout</code> parameters. An <code class="literal">inout</code> parameter is actually a reference to the passed-in instance. This means that, it will treat a value type as if it were a reference type:</p><div class="informalexample"><pre class="programlisting">func updateString(inout string: String) {
    string = "Other String"
}

var someString = "Some String"
updateString(&amp;someString)
print(someString) // "Other String"</pre></div><p>As you can see, when we changed the <code class="literal">inout</code> version of <code class="literal">string</code> within the function, it also changed the <code class="literal">someString</code> variable outside of the function just as if it were a reference type.</p><p>If we remember that a reference type is just a special version of a value type where the value is a reference, we can infer what will be possible with an <code class="literal">inout</code> version of a reference type. When we define an <code class="literal">inout</code> reference type, we actually have a reference <span class="emphasis"><em>to a reference</em></span>; this reference is then the one that is pointing to a reference. We can visualize the difference between an <code class="literal">inout</code> value type and an <code class="literal">inout</code> reference type as shown:</p><div class="mediaobject"><img alt="Behavior on input" src="graphics/B05103_07_04.jpg"/></div><p>If we simply change the value of this variable, we will get the same behavior as if it were not an <code class="literal">inout</code> parameter. However, we can also change where the inner reference is referring to<a class="indexterm" id="id316"/> by declaring it as an <code class="literal">inout</code> parameter:</p><div class="informalexample"><pre class="programlisting">func updatePerson(inout insidePerson: Person) {
    insidePerson.name = "New Name"
    insidePerson = Person(name: "New Person")
}

var person2 = person
updatePerson(&amp;person)
print(person.name) // "New Person"
print(person2.name) // "New Name"</pre></div><p>We start by creating a second reference: <code class="literal">person2</code> to the same instance as the <code class="literal">person</code> variable that currently has the name <code class="literal">"Jamison"</code> from before. After this, we pass the original <code class="literal">person</code> variable into our <code class="literal">updatePerson:</code> method and have this:</p><div class="mediaobject"><img alt="Behavior on input" src="graphics/B05103_07_05.jpg"/></div><p>In this method, we first change the name of the existing person to a new name. We can see in the output that the name of <code class="literal">person2</code> has also changed, because both <code class="literal">insidePerson</code> inside the function and <code class="literal">person2</code> are still referencing the same instance:</p><div class="mediaobject"><img alt="Behavior on input" src="graphics/B05103_07_06.jpg"/></div><p>However, we<a class="indexterm" id="id317"/> then also assign <code class="literal">insidePerson</code> to a completely new instance of the <code class="literal">Person</code> reference type. This results in <code class="literal">person</code> and <code class="literal">person2</code> outside of the function pointing at two completely different instances of <code class="literal">Person</code> leaving the name of <code class="literal">person2</code> to be <code class="literal">"New Name"</code> and updating the name of <code class="literal">person</code> to <code class="literal">"New Person"</code>:</p><div class="mediaobject"><img alt="Behavior on input" src="graphics/B05103_07_07.jpg"/></div><p>Here, by defining <code class="literal">insidePerson</code> as an <code class="literal">inout</code> parameter, we were able to change where the passed-in variable was referencing. It can help us to visualize all the different types as one type pointing to another.</p><p>At any point, any of these arrows can be pointed at something new using an assignment and the instance can always be accessed through the references.</p></div><div class="section" title="Closure capture behavior"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Closure capture behavior</h2></div></div></div><p>The <a class="indexterm" id="id318"/>last behavior we have to worry about is when variables are captured within closures. This is what we did not cover about closures in <a class="link" href="ch05.html" title="Chapter 5. A Modern Paradigm – Closures and Functional Programming">Chapter 5</a>, <span class="emphasis"><em>A Modern Paradigm – Closures and Functional Programming</em></span>. Closures can actually use the variables that were defined in the same scope as the closure itself:</p><div class="informalexample"><pre class="programlisting">var nameToPrint = "Kai"
var printName = {
    print(nameToPrint)
}
printName() // "Kai"</pre></div><p>This is very different from normal parameters that we have seen before. We actually do not specify <code class="literal">nameToPrint</code> as a parameter, nor do we pass it in when calling the method. Instead, the closure captures the <code class="literal">nameToPrint</code> variable that is defined before it. These types of captures act similarly to <code class="literal">inout</code> parameters in functions.</p><p>When a value type is captured, it can be changed and it will change the original value as well:</p><div class="informalexample"><pre class="programlisting">var outsideName = "Kai"
var setName = {
    outsideName = "New Name"
}
print(outsideName) // "Kai"
setName()
print(outsideName) // "New Name"</pre></div><p>As you can see, <code class="literal">outsideName</code> was changed after the closure was called. This is exactly like an <code class="literal">inout</code> parameter.</p><p>When a reference type is captured, any changes will also be applied to the outside version of the variable:</p><div class="informalexample"><pre class="programlisting">var outsidePerson = Person(name: "Kai")
var setPersonName = {
    outsidePerson.name = "New Name"
}
print(outsidePerson.name) // "Kai"
setPersonName()
print(outsidePerson.name) // "New Name"</pre></div><p>This is also exactly like an <code class="literal">inout</code> parameter.</p><p>The other part of closure capture that we need to keep in mind is that changing the captured value after the closure is defined will still affect the value within the closure. We can take advantage of this to use the <code class="literal">printName</code> closure we defined in the preceding section to print any name:</p><div class="informalexample"><pre class="programlisting">nameToPrint = "Kai"
printName() // Kai
nameToPrint = "New Name"
printName() // "New Name"</pre></div><p>As you can<a class="indexterm" id="id319"/> see, we can change what <code class="literal">printName</code> prints out by changing the value of <code class="literal">nameToPrint</code>. This behavior is actually very hard to track down when it happens accidently, so it is usually a good idea to avoid capturing variables in closures whenever possible. In this case, we are taking advantage of the behavior, but more often than not, it will cause bugs. Here, it would be better to pass what we want to print as an argument.</p><p>Another way to avoid this behavior is to use a feature called <a class="indexterm" id="id320"/>
<span class="strong"><strong>capture lists</strong></span>. With this, you can specify the variables that you want to capture by copying them:</p><div class="informalexample"><pre class="programlisting">nameToPrint = "Original Name"
var printNameWithCapture = { [nameToPrint] in
    print(nameToPrint)
}
printNameWithCapture() // "Original Name"
nameToPrint = "New Name"
printNameWithCapture() // "Original Name"</pre></div><p>A capture list is defined at the beginning of a closure before any parameter. It is a comma-separated list of all the variables being captured, which we want to copy within square brackets. In this case, we requested <code class="literal">nameToPrint</code> to be copied, so when we change it later, it does not affect the value that is printed out. We will see more advanced uses of capture lists later in this chapter.</p></div></div>
<div class="section" title="Automatic reference counting"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Automatic reference counting</h1></div></div></div><p>Now<a class="indexterm" id="id321"/> that we understand the different ways in which data is represented in Swift, we can look into how we can manage the memory better. Every instance that we create takes up memory. Naturally, it wouldn't make sense to keep all data around forever. Swift needs to be able to free up memory so that it can be used for other purposes, once our program doesn't need it anymore. This is the key to managing memory in our apps. We need to make sure that Swift can free up all the memory that we no longer need, as soon as possible.</p><p>The way that Swift knows it can free up memory is when the code can no longer access an instance. If there is no longer any variable or constant referencing an instance, it can be repurposed for another instance. This is called "freeing the memory" or "deleting the object".</p><p>In <a class="link" href="ch03.html" title="Chapter 3. One Piece at a Time – Types, Scopes, and Projects">Chapter 3</a>, <span class="emphasis"><em>One Piece at a Time – Types, Scopes, and Projects</em></span> we already discussed when a variable is accessible or not in the section about scopes. This makes memory management very simple for value types. Since value types are always copied when they are reassigned or passed into functions, they can be immediately deleted once they go out of scope. We can look at a simple example to get the full picture:</p><div class="informalexample"><pre class="programlisting">func printSomething() {
    let something = "Hello World!"
    print(something)
}</pre></div><p>Here we have <a class="indexterm" id="id322"/>a very simple function that prints out "Hello World!". When <code class="literal">printSomething</code> is called, <code class="literal">something</code> is assigned to a new instance of <code class="literal">String</code> with the value <code class="literal">"Hello World!"</code>. After <code class="literal">print</code> is called, the function exits and therefore <code class="literal">something</code> is no longer in scope. At that point, the memory being taken up by <code class="literal">something</code> can be freed.</p><p>While this is very simple, reference types are much more complex. At a high level, an instance of a reference type is deleted at the point that there is no longer any reference to the instance in scope anymore. This is relatively straightforward to understand but it gets more complex in the details. The Swift feature that manages this is called <span class="strong"><strong>Automatic Reference Counting</strong></span> or <span class="strong"><strong>ARC</strong></span> for short.</p><div class="section" title="Object relationships"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec70"/>Object relationships</h2></div></div></div><p>The key <a class="indexterm" id="id323"/>to ARC is that every object has<a class="indexterm" id="id324"/> relationships with one or more variables. This can be extended to include the idea that all objects have a relationship with other objects. For example, a car object would contain objects for its four tires, engine, and so on. It will also have a relationship with its manufacturer, dealership, and owner. ARC uses these relationships to determine when an object can be deleted. In Swift, there are three different types of relationships: <span class="strong"><strong>strong</strong></span>, <span class="strong"><strong>weak</strong></span>, and <span class="strong"><strong>unowned</strong></span>.</p><div class="section" title="Strong"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec14"/>Strong</h3></div></div></div><p>The first, and <a class="indexterm" id="id325"/>default type of relationship is a strong relationship. It says that a variable requires the instance it is referring to always exist, as long as the variable is still in scope. This is the only behavior available for value types. When an instance no longer has any strong relationships to it, it will be deleted.</p><p>A great example of this type of relationship is with a car that must have a steering wheel:</p><div class="informalexample"><pre class="programlisting">class SteeringWheel {}

class Car {
    var steeringWheel: SteeringWheel
    
    init(steeringWheel: SteeringWheel) {
        self.steeringWheel = steeringWheel
    }
}</pre></div><p>By default, the <code class="literal">steeringWheel</code> property has a strong relationship to the <code class="literal">SteeringWheel</code> instance it is initialized with. Conceptually, this means that the car itself has a strong relationship to the steering wheel. As long as a car exists, it must have a relationship to a steering wheel that exists. Since <code class="literal">steeringWheel</code> is declared as a variable, we could change the steering wheel of the car, which would remove the old strong relationship and add a new one, but a strong relationship will always exist.</p><p>If we were<a class="indexterm" id="id326"/> to create a new instance of <code class="literal">Car</code> and store it in a variable, that variable would have a strong relationship to the car:</p><div class="informalexample"><pre class="programlisting">let wheel = SteeringWheel()
let car = Car(steeringWheel: wheel)</pre></div><p>Lets break down all the relationships in this code. First we create the <code class="literal">wheel</code> constant and assign it to a new instance of <code class="literal">SteeringWheel</code>. This sets up a strong relationship from <code class="literal">wheel</code> to the new instance. We do the same thing with the <code class="literal">car</code> constant, but this time we also pass in the <code class="literal">wheel</code> constant to the initializer. Now, not only does <code class="literal">car</code> have a strong relationship to the new <code class="literal">Car</code> instance, but the <code class="literal">Car</code> initializer also creates a strong relationship from the <code class="literal">steeringWheel</code> property to the same instance as the <code class="literal">wheel</code> constant:</p><div class="mediaobject"><img alt="Strong" src="graphics/B05103_07_08.jpg"/></div><p>So what does this relationship graph mean for memory management? At this time, the <code class="literal">Car</code> instance has one strong relationship: the <code class="literal">car</code> constant, and the <code class="literal">SteeringWheel</code> instance has two strong relationships: the <code class="literal">wheel</code> constant and the <code class="literal">steeringWheel</code> property of the <code class="literal">Car</code> instance.</p><p>This means<a class="indexterm" id="id327"/> that the <code class="literal">Car</code> instance will be deleted as soon as the <code class="literal">car</code> constant goes out of scope. On the other hand, the <code class="literal">SteeringWheel</code> instance will only be deleted after both the <code class="literal">wheel</code> constant goes out of scope and the <code class="literal">Car</code> instance is deleted.</p><p>You can envision a strong reference counter on every instance in your program. Every time a strong relationship is setup to an instance the counter goes up. Every time an object strongly referencing it gets deleted, the counter goes down. If that counter ever goes back to zero, the instance is deleted.</p><p>The other important thing to realize is that all relationships are only in one direction. Just because the <code class="literal">Car</code> instance has a strong relationship to the <code class="literal">SteeringWheel</code> instance does not mean that the <code class="literal">SteeringWheel</code> instance has any relationship back. You could add your own relationship back by adding a car property to the <code class="literal">SteeringWheel</code> class, but you have to be careful when doing this, as we will see in the strong reference cycle section coming up.</p></div><div class="section" title="Weak"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec15"/>Weak</h3></div></div></div><p>The <a class="indexterm" id="id328"/>next type of relationship in Swift is a weak relationship. It allows one object to reference another without enforcing that it always exists. A weak relationship does not contribute to the reference counter of an instance, which means that the addition of a weak relationship does not increase the counter nor does it decrease the counter when removed.</p><p>Since a weak relationship cannot guarantee that it will always exist, it must always be defined as an optional. A weak relationship is defined using the <code class="literal">weak</code> keyword before the variable declaration:</p><div class="informalexample"><pre class="programlisting">class SteeringWheel {
    weak var car: Car?
}</pre></div><p>This allows a <code class="literal">SteeringWheel</code> to have a car assigned to it, without enforcing that the car never be deleted. The car initializer can then assign this backwards reference to itself:</p><div class="informalexample"><pre class="programlisting">class Car {
    var steeringWheel: SteeringWheel
    
    init(steeringWheel: SteeringWheel) {
        self.steeringWheel = steeringWheel
        self.steeringWheel.car = self
    }
}</pre></div><p>If the car is <a class="indexterm" id="id329"/>ever deleted, the car property of <code class="literal">SteeringWheel</code> will automatically be set to nil. This allows us to gracefully handle the scenario that a weak relationship refers to an instance that has been deleted.</p></div><div class="section" title="Unowned"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec16"/>Unowned</h3></div></div></div><p>The final<a class="indexterm" id="id330"/> type of relationship is an unowned relationship. This relationship is almost identical to a weak relationship. It also allows one object to reference another without contributing to the strong reference count. The only difference is that an unowned relationship does not need to be declared as optional and it uses the <code class="literal">unowned</code> keyword instead of <code class="literal">weak</code>. It acts similar to an implicitly unwrapped optional. You can interact with an unowned relationship as if it were a strong relationship, but if the unowned instance has been deleted and you try to access it, your entire program will crash. This means that you should only use unowned relationships in scenarios where the unowned object will never actually be deleted while the primary object still exists.</p><p>You may ask then, "Why would we not always use a strong relationship instead?" The answer is that sometimes unowned or weak references are needed to break something called a <span class="strong"><strong>strong reference cycle</strong></span>.</p></div></div></div>
<div class="section" title="Strong reference cycles"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Strong reference cycles</h1></div></div></div><p>A <a class="indexterm" id="id331"/>strong reference cycle is when two instances directly or indirectly hold strong references to each other. This means that neither object can ever be deleted, because both are ensuring that the other will always exist.</p><p>This scenario is our first really bad memory management scenario. It is one thing to keep memory around longer than it is needed; it is a whole different level to create memory that can never be freed up to be reused again. This type of memory problem is called a memory leak, because the computer will slowly leak memory until there is no longer any new memory available. This is why you will sometimes see a speed improvement after restarting your device. Upon restart, all of the memory is freed up again. Modern operating systems will sometimes find ways to forcefully free up memory, especially when completely quitting an app, but we cannot rely on this as programmers.</p><p>So how can we prevent these strong reference cycles? First, let's take a look at what they look like. There are two main scenarios where these cycles can exist: between objects and with closures.</p><div class="section" title="Between objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec71"/>Between objects</h2></div></div></div><p>A <a class="indexterm" id="id332"/>strong reference <a class="indexterm" id="id333"/>cycle between objects is when two types directly or indirectly contain strong references to each other.</p><div class="section" title="Spotting"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec17"/>Spotting</h3></div></div></div><p>A great <a class="indexterm" id="id334"/>example of a strong reference cycle between objects is if we rewrite our preceding car example without using a weak reference from <code class="literal">SteeringWheel</code> to <code class="literal">Car</code>:</p><div class="informalexample"><pre class="programlisting">class SteeringWheel {
    var car: Car?
}

class Car {
    var steeringWheel: SteeringWheel
    
    init(steeringWheel: SteeringWheel) {
        self.steeringWheel = steeringWheel
        self.steeringWheel.car = self
    }
}</pre></div><p>The only difference between this code and the preceding code is that the <code class="literal">car</code> property on <code class="literal">SteeringWheel</code> is no longer declared as weak. This means that when a car is created, it will set up a strong relationship to the <code class="literal">SteeringWheel</code> instance and then create a strong reference from the <code class="literal">SteeringWheel</code> instance back to the car:</p><div class="mediaobject"><img alt="Spotting" src="graphics/B05103_07_09.jpg"/></div><p>This scenario means that the reference count of both instances can never go down to zero and therefore they will never be deleted and the memory will be leaked.</p><p>Two objects <a class="indexterm" id="id335"/>can also indirectly hold strong references to each other through one or more third parties:</p><div class="informalexample"><pre class="programlisting">class Manufacturer {
    var cars: [Car] = []
}

class SteeringWheel {
    var manufacturer: Manufacturer?
}

class Car {
    var steeringWheel: SteeringWheel?
}</pre></div><p>Here, we have the scenario where a <code class="literal">Car</code> can have a strong reference to a <code class="literal">SteeringWheel</code> that can have a strong reference to a <code class="literal">Manufacturer</code> that in turn has a strong reference to the original <code class="literal">Car</code>:</p><div class="mediaobject"><img alt="Spotting" src="graphics/B05103_07_10.jpg"/></div><p>This is another strong reference cycle and it illustrates two more important points. First, optionals, by default, still create strong relationships when not nil. Also, the built in container types, such as arrays and dictionaries, also create strong relationships.</p><p>Clearly strong reference cycles can be difficult to spot, especially because they are hard to detect in the first place. An individual memory leak is rarely going to be noticeable to a user of your program, but if you continuously leak memory over and over again, it can cause their device to feel sluggish or even crash.</p><p>The best way as<a class="indexterm" id="id336"/> a developer to detect them is to use a tool built into Xcode called <a class="indexterm" id="id337"/>
<span class="strong"><strong>Instruments</strong></span>. Instruments can do many things, but one of those things is called <a class="indexterm" id="id338"/>
<span class="strong"><strong>Leaks</strong></span>. To run this tool you must have an Xcode Project; you cannot run it on a Playground. It is run by selecting <span class="strong"><strong>Product</strong></span> | <span class="strong"><strong>Profile</strong></span> from the menu bar.</p><p>This will build your project and display a series of profiling tools:</p><div class="mediaobject"><img alt="Spotting" src="graphics/B05103_07_11.jpg"/></div><p>If you select the <span class="strong"><strong>Leaks</strong></span> tool and press the record button in the upper-left corner, it will run your program and warn you of memory leaks which it can detect. A memory leak will look like a red X icon and will be listed as a leaked object:</p><div class="mediaobject"><img alt="Spotting" src="graphics/B05103_07_12.jpg"/></div><p>You can <a class="indexterm" id="id339"/>even select the <span class="strong"><strong>Cycles &amp; Roots</strong></span> view for the leaked objects and Instruments will show you a visual representation of your strong reference cycle. In the following screenshot, you can see that there is a cycle between <code class="literal">SteeringWheel</code> and <code class="literal">Car</code>:</p><div class="mediaobject"><img alt="Spotting" src="graphics/B05103_07_13.jpg"/></div><p>Clearly, Leaks<a class="indexterm" id="id340"/> is a powerful tool and you should run it periodically on your code, but it will not catch all strong reference cycles. The last line of defense is going to be you staying vigilant with your code, always thinking about the ownership graph.</p><p>Of course, spotting cycles is only part of the battle. The other part of the battle is fixing them.</p></div><div class="section" title="Fixing"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec18"/>Fixing</h3></div></div></div><p>The<a class="indexterm" id="id341"/> easiest way to break a strong reference cycle is to simply remove one of the relationships completely. However, this is very often not going to be an option. A lot of the time, it is important to have a two-way relationship.</p><p>The way we fix cycles without completely removing a relationship is to make one or more of the relationships weak or unowned. In fact, this is the main reason that these other two types of relationships exist.</p><p>We fix the strong reference cycle in our original example by changing the car relationship back to weak:</p><div class="informalexample"><pre class="programlisting">class SteeringWheel {
    weak var car: Car?
}

class Car {
    var steeringWheel: SteeringWheel
    
    init(steeringWheel: SteeringWheel) {
        self.steeringWheel = steeringWheel
        self.steeringWheel.car = self
    }
}</pre></div><p>Now <code class="literal">Car</code> has a strong reference to <code class="literal">SteeringWheel</code> but there is only a weak reference back:</p><div class="mediaobject"><img alt="Fixing" src="graphics/B05103_07_14.jpg"/></div><p>How you break any given cycle is going to depend on your implementation. The only important part is that somewhere in the cycle of references there is a weak or unowned relationship.</p><p>Unowned<a class="indexterm" id="id342"/> relationships are good for scenarios where the connection will never be missing. In our example, there are times that a <code class="literal">SteeringWheel</code> exists without a car reference. If we change it so that the <code class="literal">SteeringWheel</code> is created in the <code class="literal">Car</code> initializer, we could make the reference unowned:</p><div class="informalexample"><pre class="programlisting">class SteeringWheel2 {
    unowned var car: Car
    
    init(car: Car) {
        self.car = car
    }
}

class Car {
    var steeringWheel: SteeringWheel2!
    
    init() {
        self.steeringWheel = SteeringWheel2(car: self)
    }
}</pre></div><p>Also, note that we had to define the <code class="literal">steeringWheel</code> property as an implicitly unwrapped optional. This is because we had to use <code class="literal">self</code> when initializing it but at the same time we cannot use <code class="literal">self</code> until all the properties have a value. Making it optional allows it to be nil while we are using <code class="literal">self</code> to create the steering wheel. This is safe as long as the <code class="literal">SteeringWheel2</code> initializer doesn't try to access the <code class="literal">steeringWheel</code> property of the passed in car.</p></div></div><div class="section" title="With closures"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec72"/>With closures</h2></div></div></div><p>As we <a class="indexterm" id="id343"/>found out in <a class="link" href="ch05.html" title="Chapter 5. A Modern Paradigm – Closures and Functional Programming">Chapter 5</a>, <span class="emphasis"><em>A Modern Paradigm – Closures and Functional Programming</em></span>, closures <a class="indexterm" id="id344"/>are just another type of object, so they follow the same ARC rules. However, they are subtler than classes because of their ability to capture variables from their surrounding scope. These captures create strong references from the closures to the captured variable that are often overlooked because capturing variables looks so natural compared to conditionals, for loops and other similar syntax.</p><p>Just as classes can create circular references, so can closures. Something can have a strong reference to a closure that directly or indirectly has a strong reference back to the original object. Let's take a look at how we can spot that.</p><div class="section" title="Spotting"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec19"/>Spotting</h3></div></div></div><p>It is <a class="indexterm" id="id345"/>very common to provide closure properties that will be called whenever something occurs. These are generally called callbacks. Let's look at a ball class that has a callback for when the ball bounces:</p><div class="informalexample"><pre class="programlisting">class Ball {
    var location: (x: Double, y: Double) = (0,0)
    
    var onBounce: (() -&gt; ())?
}</pre></div><p>This type of setup makes it easy to inadvertently create a strong reference cycle:</p><div class="informalexample"><pre class="programlisting">let ball = Ball()
ball.onBounce = {
    print("\(ball.location.x), \(ball.location.y)")
}</pre></div><p>Here, we are printing out the location of the ball every time it bounces. However, if you consider this carefully, you will see that there is a strong reference cycle between the closure and the ball instance. This is because we are capturing the ball within the closure. As we have learned already, this creates a strong reference from the closure to the ball. The ball also has a strong reference to the closure through the <code class="literal">onBounce</code> property. That is our circle.</p><p>You should always be conscious of what variables are being captured in your closures and if that variable directly or indirectly has a strong reference to the closure itself.</p></div><div class="section" title="Fixing"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec20"/>Fixing</h3></div></div></div><p>To fix these <a class="indexterm" id="id346"/>types of strong reference cycles with closures we will again need to make one part of the circle weak or unowned.</p><p>Swift does not allow us to make closure references weak, so we have to find a way to capture the ball variable weakly instead of strongly.</p><p>To capture a variable weakly, we must use a capture list. Using a capture list, we can capture a weak or unowned copy of the original variable. We do so by specifying the <code class="literal">weak</code> or <code class="literal">unowned</code> variables before the capture list variable name:</p><div class="informalexample"><pre class="programlisting">ball.onBounce = { [weak ball] in
    print("\(ball?.location.x), \(ball?.location.y)")
}</pre></div><p>By declaring the ball copy as weak, it automatically makes it optional. This means that we had to use optional chaining to print out its location. Just like with other weak variables, <code class="literal">ball</code> will be set to nil if the ball is deleted. However, based on the nature of the code, we know that this closure will never be called if <code class="literal">ball</code> is deleted, since the closure is stored right on the ball instance. In that case, it is probably better to use the <code class="literal">unowned</code> keyword:</p><div class="informalexample"><pre class="programlisting">ball.onBounce = { [unowned ball] in
    print("\(ball.location.x), \(ball.location.y)")
}</pre></div><p>It is always nice to clean up your code by removing unnecessary optionals.</p></div></div></div>
<div class="section" title="Lost objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Lost objects</h1></div></div></div><p>It is a <a class="indexterm" id="id347"/>great idea to always keep strong reference cycles in mind, but if we are too aggressive with the use of weak and unowned references, we can run into the opposite problem, where an object is deleted before we intended it to be.</p><div class="section" title="Between objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec73"/>Between objects</h2></div></div></div><p>With an <a class="indexterm" id="id348"/>object this will happen if all of the references to the object are weak or unowned. This won't be a fatal mistake if we use weak references, but if this happens with an unowned reference it will crash your program.</p><p>For example, let's look at the preceding example with an extra weak reference:</p><div class="informalexample"><pre class="programlisting">class SteeringWheel {
    weak var car: Car?
}
class Car {
    weak var steeringWheel: SteeringWheel!

    init(steeringWheel: SteeringWheel) {
        self.steeringWheel = steeringWheel
        steeringWheel.car = self
    }
}

let wheel = SteeringWheel()
let car = Car(steeringWheel: wheel)</pre></div><p>This code is the same as the preceding one except that both the <code class="literal">car</code> property of <code class="literal">SteeringWheel</code> and the <code class="literal">steeringWheel</code> property of <code class="literal">Car</code> are weak. This means that as soon as <code class="literal">wheel</code> goes out of scope, it will be deleted, resetting the <code class="literal">steeringWheel</code> property of the car to nil. There may be scenarios where you want this behavior, but often this will be unintentional and create confusing bugs.</p><p>The important thing is that you keep in mind all of the relationships an object has. There should always be at least one strong reference as long as you still want the object around and of course, there should never be a strong reference cycle.</p></div><div class="section" title="With closures"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec74"/>With closures</h2></div></div></div><p>This <a class="indexterm" id="id349"/>actually can't happen with closures because, as we discussed before, you cannot refer to a closure weakly. If you try, the compiler will give you an error:</p><div class="informalexample"><pre class="programlisting">class Ball2 {
    weak var onBounce: (() -&gt; ())? // Error: 'weak' cannot be
    // applied to non-class type '() -&gt; ()'
}</pre></div><p>Swift saves us from yet another type of bug.</p></div></div>
<div class="section" title="Structures versus classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Structures versus classes</h1></div></div></div><p>Now <a class="indexterm" id="id350"/>that we have a good understanding of memory management, we are ready to discuss the full trade-offs we make when we choose to design a type as a structure or a class. With our ability to extend protocols like we saw in the previous chapter, we can achieve very similar functionality to the inheritance we saw with classes in <a class="link" href="ch03.html" title="Chapter 3. One Piece at a Time – Types, Scopes, and Projects">Chapter 3</a>, <span class="emphasis"><em>One Piece at a Time – Types, Scopes, and Projects</em></span>. This means that we are often choosing between using a structure or a class based on the memory implications, or in other words, whether we want our type to be a value type or a reference type.</p><p>Value types have an advantage because they are very simple to reason about. You don't have to worry about multiple variables referencing the same instance. Even better, you don't have to worry about all of the potential problems we have discussed with strong reference cycles. However, there is still an advantage to reference types.</p><p>Reference types are advantageous when it really makes sense to share an instance between multiple variables. This is especially true when you are representing some sort of physical resource that makes no sense to copy like a port on the computer or the main window of an application. Also, some will argue that reference types use memory more efficiently, because it doesn't take up more memory with lots of copies floating around. However, the Swift compiler will actually do a lot of optimizing of our code and reduce or eliminate most of the copying that actually occurs when possible. For example, if we pass a value type into a function that never modifies the value, there is no reason to actually create that copy. Ultimately, I don't recommend optimizing for something like that before it becomes necessary. Sometimes you will run into memory problems with your application and then it can be appropriate to convert large types to classes if they are being copied a lot.</p><p>Ultimately, I recommend using structures and protocols as a default, because they greatly reduce complexity and fall back to classes only when it is required. I even recommend using protocols instead of super classes when possible, because they are easier to shift around and make<a class="indexterm" id="id351"/> it an easier transition between value types and reference types.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Summary</h1></div></div></div><p>Memory management is often considered difficult to understand, but when you break it down, you can see that it is relatively straightforward. In this chapter, we have seen that all data in a computer is either stored in the file system that is a slow permanent storage, or in memory, which is a fast but temporary location. The file system is used as a backup to memory, slowing down the computer greatly, so we as programmers want to minimize the amount of memory we are ever using at one time.</p><p>We saw that in Swift there are value types and reference types. These concepts are critical to understanding how you can reduce memory usage and eliminate memory leaks. Memory leaks are created when an object has a strong reference to itself, maybe through a third party, which is called a strong reference cycle. We must also be careful that we keep at least one strong reference to every object we want to stay around or we may lose it prematurely.</p><p>With practice programming, you will get better with both preventing and fixing memory problems. You will write streamlined apps that keep your users' computers running smoothly.</p><p>We are now ready to move on to the last feature of Swift that we will discuss before we get into the more artful side of computer programming called error handling.</p></div></body></html>