<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. A Whole New World – Developing an App</h1></div></div></div><p>Until this point, we have been concentrating almost exclusively on learning Swift without learning much about the platforms that it was designed for. This is because learning a new platform is a completely different world from learning a language. Learning a programming language is like learning the basic grammar of a spoken language. The grammar between the spoken languages generally expresses similar concepts but the specific words of the languages are often more varied, even if they are sometimes recognizable. Learning a programming language is learning how to connect the specific vocabulary of your desired platform. This chapter will be about learning some of the vocabulary of the iOS framework.</p><p>We will do this by going through the process of starting to develop a simple camera app. Along the way, we will learn some of the most critical vocabularies to get started with any other kind of iOS app and many of the concepts will be transferable to OS X development. More specifically, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Conceptualizing the app</li><li class="listitem" style="list-style-type: disc">Setting up the app project</li><li class="listitem" style="list-style-type: disc">Configuring the user interface</li><li class="listitem" style="list-style-type: disc">Running the app</li><li class="listitem" style="list-style-type: disc">Temporarily saving a photo</li><li class="listitem" style="list-style-type: disc">Populating our photo grid</li><li class="listitem" style="list-style-type: disc">Refactoring to respect model-view-controller</li><li class="listitem" style="list-style-type: disc">Permanently saving a photo</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Conceptualizing the app</h1></div></div></div><p>Before <a class="indexterm" id="id508"/>we even open up Xcode, we should have a good sense of what we plan to develop. We want to know the basics of what kind of data we are going to need to represent and what the user interface is going to be like. We don't yet need pixel perfect designs for every screen, but we should have a good idea of the flow of the app and what features we want to include in our first version.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec116"/>Features</h2></div></div></div><p>As we<a class="indexterm" id="id509"/> already discussed, we are going to develop a basic camera app. This leaves us with a very clear list of features, which we would want in a first version:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Take a photo</li><li class="listitem" style="list-style-type: disc">View gallery of previously taken photos</li><li class="listitem" style="list-style-type: disc">Label photos</li><li class="listitem" style="list-style-type: disc">Delete photos</li></ul></div><p>These are the highly critical features of a camera app. Clearly, we don't have any differentiating features that will make this app valuable above other existing apps, but this will be enough to learn the most critical parts of making an iOS app.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec117"/>Interface</h2></div></div></div><p>Now <a class="indexterm" id="id510"/>that we have a list of features, we can come up with the basic flow of the app, otherwise referred to as a wireframe. The first screen of our app will be a gallery of any picture the user has already taken. There will be a button on the screen, which will allow them to take a new picture. It will also have the ability to activate the editing mode where they can delete photos or change their label:</p><div><img alt="Interface" src="img/B05103_11_01.jpg"/></div><p>This interface <a class="indexterm" id="id511"/>will allow us to take advantage of the built-in picture-taking interface that we will look at in more detail later. This interface will also allow us to make it flexible to work on all the different phone and tablet screens. It may seem simple, but there are many components that have to fit together to make this application work. On the other hand, once you have a good understanding of the different components, it will start to seem simple again.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec118"/>Data</h2></div></div></div><p>Now<a class="indexterm" id="id512"/> that we know roughly how the app needs to work for the user, we can come up with at least a high-level concept of how the data should be stored. In this case, we simply have a flat list of images with different labels. The easiest way for us to store these files is in the local file system, with each image named after the user chosen label. The only thing to keep in mind with this system is that we will have to find a way to allow two different images with the same exact label. We will solve that problem in more detail when we get around to implementing it.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Setting up the app project</h1></div></div></div><p>Now that we <a class="indexterm" id="id513"/>have finished conceptualizing our app, we are ready to start coding. In <a class="link" href="ch03.html" title="Chapter 3. One Piece at a Time – Types, Scopes, and Projects">Chapter 3</a>, <em>One Piece at a Time – Types, Scopes, and Projects</em>, we created a command-line project. This time, we are going to create an iOS Application. Once again, in Xcode, navigate to <strong>File</strong> | <strong>New</strong> | <strong>Project…</strong>. When a window appears, select the <strong>Single View Application</strong> from the <strong>iOS</strong> | <strong>Application</strong> menu:</p><div><img alt="Setting up the app project" src="img/B05103_11_02.jpg"/></div><p>From there, click <a class="indexterm" id="id514"/>on <strong>Next</strong> and then give the project the name <code class="literal">LearningCamera</code>. Any <strong>Organization Name</strong> and <strong>Identifier</strong> are fine. Finally, make sure that <strong>Swift</strong> is selected from the Language drop down menu and <strong>Universal</strong> is selected from the <strong>Devices</strong> drop down. Now select <strong>Next</strong> again and create the project.</p><p>Xcode will then present you with a project development window that looks somewhat different from a command-line project:</p><div><img alt="Setting up the app project" src="img/B05103_11_03.jpg"/></div><p>This default <a class="indexterm" id="id515"/>screen allows us to configure various attributes of the app including the version number, target devices, and much more. For our purposes, all of the defaults are fine. When you decide to submit an app to the app store, this screen will become much more important.</p><p>Xcode has also created a few different files and folders for us. We will be working exclusively in the <code class="literal">LearningCamera</code> folder. The <code class="literal">LearningCameraTests</code> folder is for automated tests; they are a fantastic idea but beyond the scope of this book. The final folder is the <code class="literal">Products</code> folder, which you won't have to change.</p><p>In the <code class="literal">LearningCamera</code> folder, we have several important files. The first file is <code class="literal">AppDelegate.swift</code>, which is the entry point of the application. It has a class that was created for you, called <code class="literal">AppDelegate</code> that has a number of methods that are called at different points during the application life cycle. We won't have to modify this file for our purposes but it is an important file in many applications.</p><p>The second file is <code class="literal">ViewController.swift</code>. This holds a <code class="literal">UIViewController</code> subclass that is used to manage the interaction between the app's default view and the business logic. We will be doing a lot of work in there.</p><p>The third file is <code class="literal">Main.storyboard</code>. This file contains the interface design for our views. Currently, it has only a single view that is managed by <code class="literal">ViewController</code>. We will be working with this file later to add and configure our visual components.</p><p>The fourth <a class="indexterm" id="id516"/>file is <code class="literal">Assets.xcassets</code>. This is a container for all of the images that we would want to display in our app. Almost every app you make will have at least one image so this is a very important file too.</p><p>Finally, the last file is <code class="literal">LaunchScreen.storyboard</code>. This file lets us manage the display while our app is launching. This is an extremely important part of a production application because this is the first thing a user sees every time they launch it; a well-designed launch process can make a huge difference. However, we do not have to do anything to this file for our learning purpose.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec79"/>Configuring the user interface</h1></div></div></div><p>Now that <a class="indexterm" id="id517"/>we have our bearings within the project, let's jump into configuring the user interface of our app. As we discussed earlier, this is done within the <code class="literal">Main.storyboard</code> file. When we select that file, we are presented with a graphical editing tool, generally referred to as <a class="indexterm" id="id518"/>
<strong>Interface Builder</strong>:</p><div><img alt="Configuring the user interface" src="img/B05103_11_04.jpg"/></div><p>In the center, there is a main view that is controlled by a <code class="literal">ViewController</code> instance. This is a blank canvas where we can add all of the interface elements we want.</p><p>The first thing <a class="indexterm" id="id519"/>we want to do is add the bar along the top that is in our wireframes. This bar is called a <strong>navigation bar</strong><a class="indexterm" id="id520"/> and we can add it directly, as it is one of the elements in our library. However, the frameworks will handle many complications for us if we use a <strong>Navigation Controller</strong> instead. A Navigation Controller is a view controller that contains other view controllers. Specifically, it adds a navigation bar to the top and allows us to push child view controllers onto it in the future. This controller creates the animation of a view being pushed on from the right in many applications. For example, when you select an e-mail in the Mail app, it animates in the contents of the e-mail; this uses a navigation controller. We will not have to push any view controllers on in this app, but it is good to be set up for the future and this is a superior way of getting a navigation bar at the top.</p><p>Along the right, we have a library of elements we can drag onto the canvas, let's start by finding the <strong>Navigation Controller</strong>. Drag it from the library to the pane on the left where the <strong>View Controller Scene</strong> is listed. This is going to add two new view controllers to the list:</p><div><img alt="Configuring the user interface" src="img/B05103_11_05.jpg"/></div><p>We don't want the new <strong>Root View Controller</strong>, only the <strong>View Controller Scene</strong> so let's delete it. To do this, click on the <strong>Root View Controller</strong> with the yellow icon and press the <em>Delete</em> key. Next, we want to make the <strong>View Controller Scene</strong> the root view controller. The root view <a class="indexterm" id="id521"/>controller is the first controller to be shown within the <strong>Navigation Controller</strong>. To do this, right-click on the <strong>Navigation Controller</strong> with the yellow icon and drag it to the <strong>View Controller</strong> with the yellow icon below. The <strong>View Controller</strong> will be highlighted blue:</p><div><img alt="Configuring the user interface" src="img/B05103_11_06.jpg"/></div><p>Once you let go of the right mouse button, a menu will come up and you should click on <strong>Root View Controller</strong>. Finally, we want to make the navigation controller the first view controller to appear in the app. Select the <strong>Navigation Controller</strong> with the yellow icon and navigate to <strong>View</strong> | <strong>Utilities</strong> | <strong>Show Attributes Inspector</strong> from the main menu, and then scroll-down and check the <strong>Is Initial View Controller</strong> checkbox. Note that you can drag around the view controllers on the screen however, you want to make the file easier to navigate.</p><p>Now we are ready to customize our main view. To focus the view, select <strong>View Controller</strong> from the pane on the left. Now double-click on the title and change it to <code class="literal">Gallery</code>:</p><div><img alt="Configuring the user interface" src="img/B05103_11_07.jpg"/></div><p>Next, we <a class="indexterm" id="id522"/>want to add the "Take a Picture" button to our navigation bar. All buttons in toolbars are called <a class="indexterm" id="id523"/>
<strong>bar button items</strong>. Find them in the library and then drag it to the right side of the toolbar (the place where you can drop it will turn blue when you get close to it). By default, the button will say <strong>Item</strong>, but we want it to be an add button instead. One option would be to change the text to an addition symbol, but there is a better option. After adding the button, you should be able to see it appear in the hierarchy that is to the left of the main view. In there, you will see the navigation bar with the new button item nested inside the <strong>Gallery</strong> title. If you select that item in the hierarchy, you will see some options we can configure about the item along the right-hand side of the screen. We want to change the System Item to <strong>Add</strong>:</p><div><img alt="Configuring the user interface" src="img/B05103_11_08.jpg"/></div><p>Now, you <a class="indexterm" id="id524"/>can do the same thing for the left-hand side of the navigation bar with the <strong>Edit</strong> identifier.</p><p>Finally, we need to add the gallery of photos. For this, we are going to use the <strong>Collection View</strong> from the library. Drag one onto the center of the view. A collection view is made of a variable amount of cells laid out in a grid. Each cell is a copy of a template cell and it can be configured in code to display specific data. When you dragged the collection view on, it also created a template cell for you. We will configure that soon.</p><p>First, we need to define the rules for the sizing of the collection view. This will allow the interface to adapt well to each different screen size. The tool we use to do this is called <a class="indexterm" id="id525"/>
<strong>Auto Layout</strong>. Click on the collection view and then select the <strong>Pin</strong> icon in the lower right of the screen:</p><div><img alt="Configuring the user interface" src="img/B05103_11_09.jpg"/></div><p>Configure this <a class="indexterm" id="id526"/>window to match the preceding screenshot. Click on each of the four struts so that they are highlighted red, uncheck <strong>Constrain to margins</strong>, and change each of the measurements to zero. After everything is configured, click on <strong>Add 4 Constraints</strong>. This will cause some yellow lines to appear that indicate that the view's placement is not consistent with the rules we just created. We can resize the views ourselves to make it match or we can let Xcode do it for us: there will be a yellow icon next to the <strong>Gallery Scene</strong> on the left-hand side of the screen. Click on that and you will get a list of misplaced views. In there, you can click on the yellow triangle and click on <strong>Fix Misplacement</strong>. We also want to make the background white instead of black. Select the collection view and then change its <strong>Background</strong> to white in the Attributes Inspector.</p><p>The last thing we need to configure on this screen is the <a class="indexterm" id="id527"/>
<strong>collection view cell</strong>. This is the box in the upper-left corner of the collection view. We need to change the size and add both an image and a label; let's start by changing the size. Click on the <strong>Collection View</strong> if it isn't already selected and navigate to <strong>View</strong> | <strong>Utilities</strong> | <strong>Show Size Inspector </strong>from the main menu. Change the <strong>Cell Size</strong> to be <code class="literal">110</code> points wide and <code class="literal">150</code> points tall.</p><p>Now, we can drag in our image. In the library, this is called an <strong>Image View</strong>. Drag it into the cell and then change the height and width in the <a class="indexterm" id="id528"/>
<strong>Size Inspector</strong> to <code class="literal">110</code> and <strong>x</strong> and <strong>y</strong> to <code class="literal">0</code>. Next, we want to drag a <strong>Label</strong> below the image view. Once it is placed, we want to configure the placement rules within the cell.</p><p>First, select the <strong>Image View</strong>. We have to make it the full width and attach it to the top of the cell, so select the pin icon again and configure it as follows:</p><div><img alt="Configuring the user interface" src="img/B05103_11_10.jpg"/></div><p>It is pinned<a class="indexterm" id="id529"/> to the left, top, and right without constraining to margins and values of zero for all three measurements. Click on <strong>Add 3 Constraints</strong> and we are ready to define the rules for the label. We want the label to be full width and vertically centered. A label is going to automatically center the text, so we want the label to be tall enough to have a reasonable margin above and below the text. Click on the label and configure it as follows:</p><div><img alt="Configuring the user interface" src="img/B05103_11_11.jpg"/></div><p>It is pinned <a class="indexterm" id="id530"/>in every direction without constraining to the margins and has zero for all measurements. It is also constrained to be 30 points tall by checking the <strong>Height</strong> checkbox. Click <strong>Add 5 Constraints</strong> and then have Xcode resize it for you again from the menu on the left. Also, make sure to select the center alignment in the Attributes Inspector and reduce the font size to <code class="literal">12</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec80"/>Running the app</h1></div></div></div><p>Now we <a class="indexterm" id="id531"/>have most of our interface configured without writing a single piece of code. We can run the app to see what it looks like. To do this, first select the simulator you want to run it on from the menu in the top bar. Then you can click on the run button, which is the one with the black triangle. This will open up a new simulator window running your app:</p><div><img alt="Running the app" src="img/B05103_11_12.jpg"/></div><p>You can<a class="indexterm" id="id532"/> rotate the virtual device from the <strong>Hardware</strong> menu to see what happens when you rotate it and you can try running it on various different simulators. We have configured our view so far to adapt to any screen size.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec81"/>Allowing picture taking</h1></div></div></div><p>Now we <a class="indexterm" id="id533"/>are ready to move onto the programming. The first thing we need to allow the user to do is to take a new picture. In order to do that, we are going to need some code to run every time the user taps on the add button. We achieve this by connecting the trigger action of the add button to a method on our view controller. Normally we make a connection by right-click dragging from the button to the code; however, we can't do this if we can't see the interface and the code at the same time. The easiest way to do this is to show the <strong>Assistant Editor</strong>. You can do this by navigating to <strong>View</strong> | <strong>Assistant Editor</strong> | <strong>Show Assistant Editor</strong>. Also, make sure it is configured to be automatic by clicking on the bar at the top of the editor:</p><div><img alt="Allowing picture taking" src="img/B05103_11_13.jpg"/></div><p>This <a class="indexterm" id="id534"/>mode causes the second view to automatically change to the most appropriate file according to what you have selected on the left. In this case, because we are working with the interface of our view controller, it shows the code for the view controller.</p><p>Our view controller code is generated with two methods to start. <code class="literal">viewDidLoad</code> is called when the view for the view controller is loaded. Most of the time this happens when the view controller is about to be displayed for the first time. <code class="literal">didReceiveMemoryWarning</code> is called when the system starts to run low on memory. This provides you an opportunity to help the system find more memory by deleting anything that isn't necessary.</p><p>We want to start by creating a connection from the button to a new method. You can do so by right clicking on the add button and dragging to below the <code class="literal">didReceiveMemoryWarning</code> method:</p><div><img alt="Allowing picture taking" src="img/B05103_11_14.jpg"/></div><p>When you <a class="indexterm" id="id535"/>release the right mouse button, a little window will appear. There you should select <strong>Action</strong> from the <strong>Connection</strong> menu and enter <code class="literal">didTapTakePhotoButton</code>. When you click on <strong>Connect</strong>, Xcode will create a new method for you and connect it to the button. You know it is connected because there is a filled in gray circle to the left of the method. Now, every time the user taps the button, this method will be executed. Note that this method has <code class="literal">@IBAction</code> at the beginning of it. This is needed for any method that is connected to an interface element.</p><p>We want this method to present the user with an interface to take a picture. Apple provides a class for us called <code class="literal">UIImagePickerController</code> that makes this very easy for us. All we need to do is create an instance of <code class="literal">UIImagePickerController</code>, configure it to allow taking pictures, and present it to the screen. The code looks like this:</p><div><pre class="programlisting">@IBAction func didTapTakePhotoButton(sender: AnyObject) {
    let imagePicker = UIImagePickerController()
    if UIImagePickerController.isSourceTypeAvailable(.Camera) {
        imagePicker.sourceType = .Camera
    }
    self.presentViewController(
        imagePicker,
        animated: true,
        completion: nil
    )
}</pre></div><p>Lets break this code down. On the first line, we are creating our image picker. On the second line, we are checking if the current device has a camera by using the <code class="literal">isSourceTypeAvailable:</code> class method of <code class="literal">UIImagePickerController</code>. If the camera source is available, we set that as the source type for the image picker on line three. Otherwise, by default, an image picker lets the user pick an image from their photo library. Since the simulator doesn't support taking a picture, you are going to be presented with an image <a class="indexterm" id="id536"/>picker instead of a camera when simulating the app. Finally, the last line asks our view controller to present our image picker by animating it on the screen. <code class="literal">presentViewController:animated:completion:</code> is a method implemented within the <code class="literal">UIViewController</code> class, the superclass of our <code class="literal">ViewController</code>, to make it easy for us to present new view controllers. If you run the app and click on the add button, you will be asked for permission to access the photos and then it will display the photo picker. You can tap the <strong>Cancel</strong> button in the upper right and the image picker controller will be dismissed. However, if you select a photo, nothing will happen.</p><p>We need to write some code to handle the picking of a photo. To make this possible, image picker can have a delegate that receives a method call when an image is picked. We are going to make our view controller the delegate of the image picker and implement its protocol. First, we have to add a line to our action method above, that assigns our view controller as the delegate of the image picker. Add this line above the call to present the image picker:</p><div><pre class="programlisting">imagePicker.delegate = self</pre></div><p>When we do that, we will get a compiler error that says that we can't make this assignment because our view controller doesn't implement the necessary protocols. Lets change that. I like to implement each protocol as a separate extension in the same file to allow for better code separation. We need to implement both <code class="literal">UIImagePickerControllerDelegate</code> and <code class="literal">UINavigationControllerDelegate</code> according to the error. The only method that is important to us in either of these protocols is the one that is called when an image is picked. That leaves us with the following code:</p><div><pre class="programlisting">extension ViewController: UINavigationControllerDelegate {}

extension ViewController: UIImagePickerControllerDelegate {
    func imagePickerController(
        picker: UIImagePickerController,
        didFinishPickingImage image: UIImage!,
        editingInfo: [NSObject : AnyObject]!
        )
    {
        self.dismissViewControllerAnimated(true, completion: nil)
    }
}</pre></div><p>Our implementation for the <code class="literal">UINavigationControllerDelegate</code> delegate is empty but we have a simple implementation for the <code class="literal">imagePickerController:picker:didFinishPickingImage:editingInfo:</code> method. This is where we are going to add our handling code, but for now, we are just dismissing the presented view controller to return the user to the previous screen. This method does <a class="indexterm" id="id537"/>not force us to specify the view controller we are dismissing because the view controller already knows which one it is presenting. Now, if you run the app and select a photo, you will return to the previous screen but nothing else will happen. In order to make something meaningful happen with the photo, we are going to have to put a lot of other code in place. We have to both save the picture and implement our view controller to display the picture inside our collection view.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec82"/>Temporarily saving a photo</h1></div></div></div><p>To start, we <a class="indexterm" id="id538"/>are only going to concern ourselves with temporarily storing our pictures in memory. To do this, we can add an image array as a property of our view controller:</p><div><pre class="programlisting">class ViewController: UIViewController {
    
    var photos = [UIImage]()
    
    // ...
}</pre></div><p>As we saw in the image picker delegate method, UIKit provides a class <code class="literal">UIImage</code> that can represent images. Our <code class="literal">photos</code> property can store an array of these instances. This means that the first step for us is to add new images to our property when the callback is called:</p><div><pre class="programlisting">    func imagePickerController(
        picker: UIImagePickerController,
        didFinishPickingImage image: UIImage!,
        editingInfo: [NSObject : AnyObject]!
        )
    {
        self.photos.append(image)
        self.dismissViewControllerAnimated(true, completion: nil)
    }</pre></div><p>Now every time the user takes or picks a new photo, we add it to our list, which stores all of the images in memory. However, this isn't quite enough, we also want to require a label for each photo.</p><p>To support this feature, let's create a new structure called <code class="literal">Photo</code> that has an image and label property. At this point, I would create three groups in the <code class="literal">LearningCamera</code> folder: Model, View, and Controller by right-clicking on the <code class="literal">LearningCamera</code> folder and choosing <strong>New Group</strong>. I would move <code class="literal">ViewController.swift</code> into the <strong>Controller</strong> group and then create a new <code class="literal">Photo.swift</code> file by right-clicking on the <strong>Model</strong> group and selecting <strong>New File…</strong>. Just a plain <strong>Swift File</strong> is fine.</p><p>You should <a class="indexterm" id="id539"/>define your photo structure in that file:</p><div><pre class="programlisting">import UIKit

struct Photo {
    let image: UIImage
    let label: String
}</pre></div><p>We have to import UIKit because that is what defines UIImage. The rest of our structure is straightforward as it just defines our two desired properties. The default initializer will be fine for now.</p><p>Now, we can return to our <code class="literal">ViewController.swift</code> file and update our <code class="literal">photos</code> property to be of the type <code class="literal">Photo</code> instead of <code class="literal">UIImage</code>:</p><div><pre class="programlisting">var images = [Photo]()</pre></div><p>This now creates a new problem for us. How do we ask the user for the label for the image? Let's do that in a standard alert. To display an alert, UIKit has a class called <code class="literal">UIAlertController</code>. To use this, we will have to rework our function some. UIKit does not allow you to present more than one view controller from the same view controller at the same time. This means that we have to dismiss the photo picker and wait for that to complete before displaying our alert:</p><div><pre class="programlisting">self.dismissViewControllerAnimated(true) {
    // Ask User for Label
    
    let alertController = UIAlertController(
        title: "Photo Label",
        message: "How would you like to label your photo?",
        preferredStyle: .Alert
    )

    alertController.addTextFieldWithConfigurationHandler()
    {
        textField in
        let saveAction = UIAlertAction(
            title: "Save",
            style: .Default
            ) { action in
            let label = textField.text ?? ""
            let photo = Photo(image: image, label: label)
            self.photos.append(photo)
        }
        alertController.addAction(saveAction)
    }

    self.presentViewController(
        alertController,
        animated: true,
        completion: nil
     )
}</pre></div><p>Lets break <a class="indexterm" id="id540"/>down this code, as it is somewhat complex. To start, we are using the trailing closure syntax for the <code class="literal">dismissViewControllerAnimated:completion:</code> method. This closure is called once the view controller has finished animating off the screen.</p><p>Next, we are creating an alert controller with a title, message, and <code class="literal">Alert</code> as its style. Before we can display the alert controller, we have to configure it with a text field and a save action. We start by adding the text field and use the trailing closure again on <code class="literal">addTextFieldWithConfigurationHandler:</code>. This closure is called to give us an opportunity to configure the text field. We are OK with the defaults but we are going to want to know the text contained in the text field when saving so we can create our save action directly within this alert and save ourselves the hassle of getting a reference to it later.</p><p>Each action of an alert must be of the type <code class="literal">UIAlertAction</code>. In this case, we create one with the title <code class="literal">Save</code> with the default style. The last parameter of the <code class="literal">UIAlertAction</code> initializer is a closure that will be called when the user chooses that action. Again, we use the trailing closure syntax.</p><p>Inside that callback, we get the text from the text field and use that, along with our image, to create a new <code class="literal">Photo</code> instance and add it to our <code class="literal">photos</code> array.</p><p>Finally, we have to add our save action to the alert controller and then display the alert controller.</p><p>Now if you run the app, it will ask you for a label for each photo after it is chosen but it still won't appear to be showing it because we are not displaying the saved photos yet. That is our next task.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec83"/>Populating our photo grid</h1></div></div></div><p>Now<a class="indexterm" id="id541"/> that we are maintaining a list of photos, we need to display it in our collection view. A collection view is populated by providing it with a data source that implements its <code class="literal">UICollectionViewDataSource</code> protocol. Probably the most common thing to do is to have the view controller be the data source. We can do this by opening the <code class="literal">Main.storyboard</code> back up and <em>control</em> dragging from the collection view to the view controller:</p><div><img alt="Populating our photo grid" src="img/B05103_11_15.jpg"/></div><p>When <a class="indexterm" id="id542"/>you let go, select <strong>dataSource</strong> from the menu. After that, all we need to do is implement the data source protocol. The two methods we need to implement are <code class="literal">collectionView:numberOfItemsInSection:</code> and <code class="literal">collectionView:cellForItemAtIndexPath:</code>. The former allows us to specify how many cells should be displayed and the latter allows us to customize each cell for a specific index into our list. It is easy for us to return the number of cells that we want:</p><div><pre class="programlisting">extension ViewController: UICollectionViewDataSource {
    func collectionView(
        collectionView: UICollectionView,
        numberOfItemsInSection section: Int
        ) -&gt; Int
    {
        return self.photos.count
    }
}</pre></div><p>All we have to do is return the number of elements in our <code class="literal">photos</code> property.</p><p>Configuring the cell is going to take a little bit more preparation. First, we need to create our own cell subclass that can reference the image and label we created in the storyboard. All collection view cells must subclass <code class="literal">UICollectionViewCell</code>. Let's call ours <code class="literal">PhotoCollectionViewCell</code> and create a new file for it in the <strong>View</strong> group. Like we needed a connection from the storyboard to our code for tapping the add button, we need a connection for <a class="indexterm" id="id543"/>both the image and the label. However, this is a different type of connection. Instead of an action, this type of connection is called an outlet, which adds the object as a property to the view controller. We could use the same click and drag technique we used for the action, but this time we will set up the code in advance ourselves:</p><div><pre class="programlisting">import UIKit

class PhotoCollectionViewCell: UICollectionViewCell {
    @IBOutlet var imageView: UIImageView!
    @IBOutlet var label: UILabel!
}</pre></div><p>Here we have specified two properties, each with a prefix of <code class="literal">@IBOutlet</code>. This prefix is what allows us to make the connection in Interface Builder just like we did with the data source. Both types are defined as implicitly unwrapped optionals because these connections cannot be set when the instance is initialized. Instead, they are connected when loading the view.</p><p>Now that we have that setup, we can go back to the storyboard and make the connections. Currently the cell is still just the type of a generic cell so first we need to change it to our class. Find the cell inside the view hierarchy on the left and click on it. Select <strong>View</strong> | <strong>Utilities</strong> | <strong>Show Identify Inspector</strong>. In this inspection, we can set the class of the cell to our class by entering <code class="literal">PhotoCollectionViewCell</code> in the class field. Now if you navigate to <strong>View</strong> | <strong>Utilities</strong> | <strong>Show Connections Inspector</strong> you will see our two outlets listed as possible connections. Click and drag from the hollow gray circle next to <strong>imageView</strong> to the image view in the cell:</p><div><img alt="Populating our photo grid" src="img/B05103_11_16.jpg"/></div><p>Once you <a class="indexterm" id="id544"/>let go, the connection will be made. Do the same thing with the <strong>label</strong> connection to the label we created before. We also need to set a reuse identifier for our cell so that we can reference this template in code. You can do this by returning to the Attributes Inspector and entering <code class="literal">DefaultCell</code> into the <strong>Identifier</strong> text field:</p><div><img alt="Populating our photo grid" src="img/B05103_11_17.jpg"/></div><p>We are also <a class="indexterm" id="id545"/>going to need a reference to the collection view from within our view controller. This is because we will need to ask the collection view to add a cell each time a photo is saved. You can add this by writing the code first or by right clicking and dragging from the collection view to the code. Either way, you should end up with a property like this on the view controller:</p><div><pre class="programlisting">class ViewController: UIViewController {
    @IBOutlet var collectionView: UICollectionView!

    // ... 
}</pre></div><p>Then we are ready to implement the remaining data source method:</p><div><pre class="programlisting">extension ViewController: UICollectionViewDataSource {
    // ...
    
    func collectionView(
        collectionView: UICollectionView,
        cellForItemAtIndexPath indexPath: NSIndexPath
        ) -&gt; UICollectionViewCell
    {
        let cell = collectionView
            .dequeueReusableCellWithReuseIdentifier(
            "DefaultCell",
            forIndexPath: indexPath
            ) as! PhotoCollectionViewCell
        
        let photo = self.photos[indexPath.item]
        cell.imageView.image = photo.image
        cell.label.text = photo.label
        
        return cell
    }
}</pre></div><p>The first line<a class="indexterm" id="id546"/> of this implementation asks the collection view for a cell with our <code class="literal">DefaultCell</code> identifier. To understand this fully, we have to understand a little bit more about how a collection view works. A collection view is designed to handle virtually any number of cells. We could want to display thousands of cells at once but it would not be possible to have thousands of cells in memory at one time. Instead, the collection view will automatically reuse cells that have been scrolled off the screen to save on memory. We have no way of knowing whether the cell we get back from this call is new or reused, so we must always assume it is being reused. This means that anything we configure on a cell in this method, must always be reset on each call, otherwise, some old configurations may still exist from its previous configuration. We end that call by casting the result to our <code class="literal">PhotoCollectionViewCell</code> class so that we can configure our subviews properly.</p><p>Our second line is getting the correct photo out of our list. The <code class="literal">item</code> property on the <code class="literal">indexPath</code> variable is the index of the photo that we are using to configure the cell. At any time, this method could be called with any index between zero and the number returned in our previous data source method. This means that in our case, it will always be a number within our <code class="literal">photos</code> array, making it safe to assume that the index is properly within its bounds.</p><p>The next two lines set the image and label according to the photo and finally, the last line returns that cell so that the collection view can display it.</p><p>At this point, if you ran the app and added a photo you still wouldn't see anything because the collection view will not automatically reload its data when an element is added to the photos array. That is because the <code class="literal">collectionView:numberOfItemsInSection: </code>method is a callback. Callbacks are only called when other code initiates it. This method is called once when the collection view is first loaded but we must ask it to be called again manually from then on. The easiest way to do this is to call <code class="literal">reloadData</code> on the collection view when we add a photo to the list. This causes all of the data and cells to be loaded again. However, this does not look very good because the cell will just pop into existence. Instead, we want to use the <code class="literal">insertItemsAtIndexPaths </code>method. When used properly, this will cause a cell to be animated onto the screen. The important thing to remember with this method is that you must only call it after <code class="literal">collectionView:numberOfItemsInSection:</code> returns the updated amount after the insertion. This means we must call it after we have already added our photo to our property:</p><div><pre class="programlisting">let saveAction = UIAlertAction(
    title: "Save",
    style: .Default
    ) { action in
    let label = textField.text ?? ""
    let photo = Photo(image: image, label: label)
    self.photos.append(photo)

    let indexPath = NSIndexPath(
        forItem: self.photos.count - 1,
        inSection: 0
    )
    self.collectionView.insertItemsAtIndexPaths([indexPath])
}</pre></div><p>Only the last <a class="indexterm" id="id547"/>two lines of this are new. First, we create an index path for where we want to insert our new item. An index path consists of both an item and a section. All of our items exist in a single section, so we can always set that to zero. We want the item to be one less than the total count of photos because we just added it to the end of the list. The last line is simply making the call to the insert items method that takes an array of index paths.</p><p>Now you can run your app and all saved photos will be displayed in the collection view.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec84"/>Refactoring to respect model-view-controller</h1></div></div></div><p>We <a class="indexterm" id="id548"/>have already made some good progress on the core functionality of our app. However, before we move any further, we should reflect on the code we have written. Ultimately, we haven't actually written that many lines of code, but it can definitely be improved. The biggest shortcoming of our code is that we have put a lot of business logic inside our view controller. This is not a good separation of our different model, view, and controller layers. Let's take this opportunity to refactor this code into a separate type.</p><p>We will create a class called <code class="literal">PhotoStore</code> that will be responsible for storing our photos and that will implement the data source protocol. This will mean moving some of our code out of our view controller.</p><p>First, we will move the photo's property to the photo store class:</p><div><pre class="programlisting">import UIKit

class PhotoStore: NSObject {
    var photos = [Photo]()
}</pre></div><p>Note that this new photo store class inherits from <code class="literal">NSObject</code>. This is necessary for us to be able to fully satisfy the <code class="literal">UICollectionViewDataSource</code> protocol, which is our next task.</p><p>We could simply <a class="indexterm" id="id549"/>move the code from our view controller to this class, but we do not want our model to deal directly with our view layer. The current implementation creates and configures our collection view cell. Lets allow the view controller to still handle that by providing our own callback for when we need a cell for a given photo. To do that, we will first need to add a callback property:</p><div><pre class="programlisting">class PhotoStore: NSObject {
    var photos = [Photo]()
    var cellForPhoto:
        (Photo, NSIndexPath) -&gt; UICollectionViewCell
    
    init(
        cellForPhoto: (Photo,NSIndexPath) -&gt; UICollectionViewCell
        )
    {
        self.cellForPhoto = cellForPhoto

        super.init()
    }
}</pre></div><p>We need to provide an initializer now so that we can get the callback function. Next, we have to tweak our data source implementations and put them in this new class:</p><div><pre class="programlisting">extension PhotoStore: UICollectionViewDataSource {
    func collectionView(
        collectionView: UICollectionView,
        numberOfItemsInSection section: Int
        ) -&gt; Int
    {
        return self.photos.count
    }
    
    func collectionView(
        collectionView: UICollectionView,
        cellForItemAtIndexPath indexPath: NSIndexPath
        ) -&gt; UICollectionViewCell
    {
        let photo = self.photos[indexPath.item]
        return self.cellForPhoto(photo, indexPath)
    }
}</pre></div><p>The <code class="literal">collectionView:numberOfItemsInSection:</code> method can still just return the number of photos in our array, but <code class="literal">collectionView:cellForItemAtIndexPath:</code> is implemented to use the callback instead of creating a cell itself.</p><p>The second thing <a class="indexterm" id="id550"/>we need to add to this class is the ability to save a photo. Let's add a method to take a new image and label that returns the index path that should be added:</p><div><pre class="programlisting">func saveNewPhotoWithImage(
    image: UIImage,
    labeled label: String
    ) -&gt; NSIndexPath
{
    let photo = Photo(image: image, label: label)
    self.photos.append(photo)
    return NSIndexPath(
       forItem: self.photos.count - 1,
       inSection: 0
    )
}</pre></div><p>This looks identical to the code we wrote in the view controller to do this, but it is better separated.</p><p>Now our photo store is complete and we just have to update our view controller to use it instead of our old implementation. First, lets add a photo store property that is an implicitly unwrapped optional in <code class="literal">ViewController</code> so we can create it after the view is loaded:</p><div><pre class="programlisting">    var photoStore: PhotoStore!</pre></div><p>To create our photo store in <code class="literal">viewDidLoad</code>, we will call the photo store initializer and pass it a closure that can create the cell. For clarity, we will define that closure as a separate method:</p><div><pre class="programlisting">func createCellForPhoto(
    photo: Photo,
    indexPath: NSIndexPath
    ) -&gt; UICollectionViewCell
{
    let cell = self.collectionView
        .dequeueReusableCellWithReuseIdentifier(
        "DefaultCell",
        forIndexPath: indexPath
        ) as! PhotoCollectionViewCell
    
    cell.imageView.image = photo.image
    cell.label.text = photo.label
    
    return cell
}</pre></div><p>This <a class="indexterm" id="id551"/>method looks almost identical to our old <code class="literal">collectionView:cellForItemAtIndexPath:</code> implementation; the only difference is that we already have a reference to the correct photo.</p><p>This method allows our <code class="literal">viewDidLoad</code> implementation to be very simple. All we need to do is initialize the photo store with a reference to this method and make it the data source for the collection view:</p><div><pre class="programlisting">override func viewDidLoad() {
    super.viewDidLoad()
    self.photoStore = PhotoStore(
        cellForPhoto: self.createCellForPhoto
    )
    self.collectionView.dataSource = self.photoStore
}</pre></div><p>Lastly, we just have to update the save action to use the photo store:</p><div><pre class="programlisting">let saveAction = UIAlertAction(
    title: "Save",
    style: .Default
    ) { action in
    let label = textField.text ?? ""
    let indexPath = self.photoStore.saveNewPhotoWithImage(
        image,
        labeled: label
    )
    self.collectionView.insertItemsAtIndexPaths([indexPath])
}</pre></div><p>You can run the app again and it will operate as before, but now our code is modular, which will make any future changes much easier.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec85"/>Permanently saving a photo</h1></div></div></div><p>Our <a class="indexterm" id="id552"/>app works pretty well for saving pictures, but as soon as the app quits, all of the photos are lost. We need to add a way to save the photos permanently. Our refactoring of the code allows us to work primarily within the model layer now.</p><p>Before we write any code, we have to decide how we are going to store the photos permanently. There are many ways in which we can choose to save the photos, but one of the easiest is to save it to the file system, which is what we conceived of in our conception phase. Every app is provided a documents directory that is automatically backed up by the operating system as a part of normal backups. We can store our photos in there as files named after the label the user gives them. To avoid any problems with duplicate labels, where we would have multiple files named the same thing, we can nest every file inside a subdirectory named after the time the photos is saved. The time stamp will always be unique because we will never save two photos at the exact same time.</p><p>Now that we have that decided, we can start to update our photo store code. First, we will want to have an easy way to use a consistent directory for saving. We can create that by adding a method called <code class="literal">getSaveDirectory</code>. This method can be private and, as a convention, I like to group private code in a private extension:</p><div><pre class="programlisting">private extension PhotoStore {
    func getSaveDirectory() throws -&gt; NSURL {
        let fileManager = NSFileManager.defaultManager()
        return try fileManager.URLForDirectory(
            .DocumentDirectory,
            inDomain: .UserDomainMask,
            appropriateForURL: nil,
            create: true
        )
    }
}</pre></div><p>This code first gets a URL representing the documents directory from an Apple-provided class called <code class="literal">NSFileManager</code>. You may notice that <code class="literal">NSFileManager</code> has a shared instance that can be accessed through the <code class="literal">defaultManager</code> class method. We then call the <code class="literal">URLForDirectory</code> method, give it information indicating that we want the documents directory for the current user, and return the result. Note that this method can throw an error, so we marked our own method as throwing and did not allow any errors to propagate.</p><p>Now we can move on to saving all added images to disk. There are a number of things that we will need to be done. First, we need to get the current time stamp. We can do this by creating an <code class="literal">NSDate</code> instance, asking that for the time stamp and using string interpolation to turn it into a string:</p><div><pre class="programlisting">let timeStamp = "\(NSDate().timeIntervalSince1970)"</pre></div><p><code class="literal">NSDate</code> instances can represent any sort of time on any date. By default, all <code class="literal">NSDate</code> instances are created to represent the current time.</p><p>Next, we are going to want to append that onto our save directory to get the path where we are going to save the file. For that, we can use the <code class="literal">URLByAppendingPathComponent: </code>method of <code class="literal">NSURL</code>:</p><div><pre class="programlisting">let fullDirectory = directory.URLByAppendingPathComponent(
    timestamp
    )</pre></div><p>This will <a class="indexterm" id="id553"/>ensure that the proper path slash is added, if it is not already there. Now we need to make sure that this directory exists before we try to save a file to it. This is done using a method on <code class="literal">NSFileManager</code>:</p><div><pre class="programlisting">NSFileManager.defaultManager().createDirectoryAtURL(
    fullDirectory,
    withIntermediateDirectories: true,
    attributes: nil
)</pre></div><p>This method can throw if there is an error, which we will need to handle later. It is still considered a success if the directory already exists. Once we are sure that the directory has been created, we will want to create the path to the specific file using the label text:</p><div><pre class="programlisting">let fileName = "\(self.label).jpg"
let filePath = fullDirectory
    .URLByAppendingPathComponent(fileName)</pre></div><p>Here we used string interpolation to add a <code class="literal">.jpg</code> extension to the file name.</p><p>Most importantly, we will need to convert our image to data that can be saved to a file. For that, UIKit provides a function called <code class="literal">UIImageJPEGRepresentation </code>that takes the <code class="literal">UIImage</code> and returns an <code class="literal">NSData</code> instance:</p><div><pre class="programlisting">let data = UIImageJPEGRepresentation(self.image, 1)</pre></div><p>The second parameter is a value between zero and one representing the compression quality we want. In this case, we want to save the file at full quality, so we use 1. It then returns an optional data instance, so we will need to handle the scenario where it returns nil.</p><p>Finally, we need to save that data to the file path we created:</p><div><pre class="programlisting">data.writeToURL(filePath, atomically: true)</pre></div><p>This method on <code class="literal">NSData</code> simply takes the file path and a Boolean indicating if we want it to write to a temporary location before it overwrites any existing file. It also returns <code class="literal">true</code> or <code class="literal">false</code> depending on if it is successful. Unlike directory creation, this will fail if the file already exists. However, since we are using the current time stamp that should never be a problem.</p><p>Lets <a class="indexterm" id="id554"/>combine all of this logic into a method on our photo structure that we can use later to save it to disk, which throws an error in case of an error:</p><div><pre class="programlisting">struct Photo {
    // ...

    enum Error: String, ErrorType {
        case CouldntGetImageData = "Couldn't get data from image"
        case CouldntWriteImageData = "Couldn't write image data"
    }

    func saveToDirectory(directory: NSURL) throws {
        let timeStamp = "\(NSDate().timeIntervalSince1970)"
        let fullDirectory = directory
            .URLByAppendingPathComponent(timeStamp)
        try NSFileManager.defaultManager().createDirectoryAtURL(
            fullDirectory,
            withIntermediateDirectories: true,
            attributes: nil
        )
        let fileName = "\(self.label).jpg"
        let filePath = fullDirectory
            .URLByAppendingPathComponent(fileName)
        if let data = UIImageJPEGRepresentation(self.image, 1) {
            if !data.writeToURL(filePath, atomically: true) {
                throw Error.CouldntWriteImageData
            }
        }
        else {
            throw Error.CouldntGetImageData
        }
    }
}</pre></div><p>First, we define a nested enumeration for our possible errors. Then we define the method to take the root level directory where it should be saved. We allow any errors from the directory creation to propagate. We also need to throw our errors if the data comes back nil or if the <code class="literal">writeToURL:automatically:</code> method fails.</p><p>Now we need to update our <code class="literal">saveNewPhotoWithImage:labeled:</code> to use the <code class="literal">saveToDirectory:</code> method. Ultimately, if an error is thrown while saving the photo, we will want to display something to the user. That means that this method will need to just propagate the error, because the model should not be the one to display something to the user. That results in the following code:</p><div><pre class="programlisting">func saveNewPhotoWithImage(
    image: UIImage,
    labeled label: String
    ) throws -&gt; NSIndexPath
{
    let photo = Photo(image: image, label: label)
    try photo.saveToDirectory(self.getSaveDirectory())
    self.photos.append(photo)
    return NSIndexPath(
        forItem: self.photos.count - 1,
        inSection: 0
    )
}</pre></div><p>If the saving <a class="indexterm" id="id555"/>to directory fails, we will skip the rest of the method so we won't add it to our photos list. That means we need to update the view controller code that calls it to handle the error. First, let's add a method to make it easy to display an error with a given title and message:</p><div><pre class="programlisting">func displayErrorWithTitle(title: String?, message: String) {
    let alert = UIAlertController(
        title: title,
        message: message,
        preferredStyle: .Alert
    )
    alert.addAction(UIAlertAction(
        title: "OK",
        style: .Default,
        handler: nil
    ))
    self.presentViewController(
        alert,
        animated: true,
        completion: nil
    )
}</pre></div><p>This method is simple. It just creates an alert with an OK button and then presents it. Next, we can add a function to display any kind of error we will expect. It will take a title for the alert that will pop-up, so we can customize the error we are displaying for the scenario that produced it:</p><div><pre class="programlisting">func displayError(error: ErrorType, withTitle: String) {
    switch error {
    case let error as NSError:
        self.displayErrorWithTitle(
            title,
            message: error.localizedDescription
        )
    case let error as Photo.Error:
        self.displayErrorWithTitle(
            title,
            message: error.rawValue
        )
    default:
        self.displayErrorWithTitle(
            title,
            message: "Unknown Error"
        )
    }
}</pre></div><p>We expect <a class="indexterm" id="id556"/>either the built-in error type of <code class="literal">NSError</code> that will come from Apple's APIs or the error type we defined in our photo type. The localized description property of Apple's errors just creates a description in the locale the device is currently configured for. We also handle any other error scenarios by just reporting it as an unknown error.</p><p>I would also extract our save action creation to a separate method so we don't overcomplicate things when we add in our do-catch blocks. This will be very similar to our previous code but we will wrap the call to <code class="literal">saveNewPhotoWithImage:labeled:</code> in a do-catch block and call our error handling method on any thrown errors:</p><div><pre class="programlisting">func createSaveActionWithTextField(
    textField: UITextField,
    andImage image: UIImage
    ) -&gt; UIAlertAction
{
    return UIAlertAction(
        title: "Save",
        style: .Default
        ) { action in
        do {
            let indexPath = try self.photoStore
               .saveNewPhotoWithImage(
                image,
                labeled: textField.text ?? ""
                )
            self.collectionView.insertItemsAtIndexPaths([indexPath]
            )
        }
        catch let error {
            self.displayError(
                error,
                withTitle: "Error Saving Photo"
            )
        }
    }
}</pre></div><p>That leaves <a class="indexterm" id="id557"/>us with just needing to update the <code class="literal">imagePickerController:didFinishPickingImage:editingInfo:</code> method to use our new save action creating method:</p><div><pre class="programlisting">// ..

alertController.addTextFieldWithConfigurationHandler()
{
    textField in
    let saveAction = self.createSaveActionWithTextField(
        textField,
        andImage: image
    )
    alertController.addAction(saveAction)
}

// ..</pre></div><p>That completes the first half of permanently storing our photos. We are now saving the images to disk but that is useless if we don't load them from disk at all.</p><p>To load an image from disk, we can use the <code class="literal">contentsOfFile:</code> initializer of <code class="literal">UIImage</code> that returns an optional image:</p><div><pre class="programlisting">let image = UIImage(contentsOfFile: filePath.relativePath!)</pre></div><p>To convert our file path URL to a string, which is what the initializer requires, we can use the relative path property.</p><p>We can get the label for the photo by removing the file extension and getting the last component of the path:</p><div><pre class="programlisting">let label = filePath.URLByDeletingPathExtension?
    .lastPathComponent ?? ""</pre></div><p>Now we can combine this logic into an initializer on our <code class="literal">Photo</code> struct. To do this, we will also have to create a simple initializer that takes the image and label so that our other code that uses the default initializer still works:</p><div><pre class="programlisting">init(image: UIImage, label: String) {
    self.image = image
    self.label = label
}

init?(filePath: NSURL) {
    if let image = UIImage(
        contentsOfFile: filePath.relativePath!
        )
    {
        let label = filePath.URLByDeletingPathExtension?
            .lastPathComponent ?? ""
        self.init(image: image, label: label)
    }
    else {
        return nil
    }
}</pre></div><p>Lastly, we need <a class="indexterm" id="id558"/>to have the image store enumerate through the files in the documents directory calling this initializer for each one. To enumerate through a directory, <code class="literal">NSFileManager</code> has an <code class="literal">enumeratorAtFilePath:</code> method. It returns an enumerator instance that has a <code class="literal">nextObject</code> method. Each time it is called, it returns the next file or directory inside the original directory. Note that this will enumerate all children of each subdirectory it finds. This is a great example of the iterator pattern we saw in <a class="link" href="ch09.html" title="Chapter 9. Writing Code the Swift Way – Design Patterns and Techniques">Chapter 9</a>, <em>Writing Code the Swift Way – Design Patterns and Techniques</em>. We can determine if the current object is a file using the <code class="literal">fileAttributes</code> property. All of that lets us write a <code class="literal">loadPhotos</code> method like this:</p><div><pre class="programlisting">func loadPhotos() throws {
    self.photos.removeAll(keepCapacity: true)
    
    let fileManager = NSFileManager.defaultManager()
    let saveDirectory = try self.getSaveDirectory()
    let enumerator = fileManager.enumeratorAtPath(
        saveDirectory.relativePath!
    )
    while let file = enumerator?.nextObject() as? String {
        let fileType = enumerator!.fileAttributes![NSFileType]
            as! String
        if fileType == NSFileTypeRegular {
            let fullPath = saveDirectory
                .URLByAppendingPathComponent(file)
            if let photo = Photo(filePath: fullPath) {
                self.photos.append(photo)
            }
        }
    }
}</pre></div><p>The first thing <a class="indexterm" id="id559"/>we do in this method is remove all existing photos. This is to protect against calling this method when there are already photos in it. Next, we create an enumerator from our save directory. Then, we use a while loop to continue to get each next object until there are none left. Inside the loop we check if the object we just got is actually a file. If it is and we create the photo successfully with the full path, we add the photo to our photos array.</p><p>Finally, all we have to do is make sure this method is called at the appropriate time to load the photos. A great time to do this, considering we want to be able to show errors to the user, is right before the view will be displayed. As the view controllers have a method for right after the view has been loaded, there is also a method called <code class="literal">viewWillAppear: </code>that is called every time the view is about to appear. In here we can load the photos and also display any errors to the user with our <code class="literal">displayError:withTitle:</code> method:</p><div><pre class="programlisting">override func viewWillAppear(animated: Bool) {
    super.viewWillAppear(animated)

    do {
        try self.photoStore.loadPhotos()
        self.collectionView.reloadData()
    }
    catch let error {
        self.displayError(
            error,
            withTitle: "Error Loading Photos"
        )
    }
}</pre></div><p>Now if you run the app, save some photos, and quit it, your previously saved photos will be there when you run it again. We have completed the saving photos functionality!</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec86"/>Summary</h1></div></div></div><p>This app is far from being something that we could put on the store, but it gives you a good first dive into what it is like to build an iOS app. We have covered how to conceptualize an app and then how to go about making it a reality. We know how to configure an interface in a storyboard, how to run it, and we got into the practical details of saving photos both temporarily and permanently to disk and displaying those in our own custom interface. We even got some practice writing high quality code by ensuring our code sticks with the model-view-controller design pattern as best we can.</p><p>Even though we have covered a lot, this clearly isn't enough information to immediately write any other iOS app. The key is to get an insight into what the app development process looks like and to start to feel more comfortable in an iOS app project. All developers spend lots of time searching the documentation and the Internet for how to do specific things on any given platform. The key is being able to take solutions you find on the Internet or in books, determine the best one for your use case, and integrate them effectively into your own code. Over time, you will be able to do more and more on your own without looking it up, but with ever-changing frameworks and platforms, that will always be a part of your development cycle.</p><p>With that in mind, I now challenge you to complete the feature list we conceptualized. Figure out how to delete a picture and add whatever other features, usability tweaks, or visual tweaks you want. As I said before, app development is a completely new world to explore. There are so many things that you can tweak, even with this simple app; all of it will help you learn tons.</p><p>Coming up in our final chapter, we will look at where you can go from here to become the best Swift developer you possibly can.</p></div></body></html>