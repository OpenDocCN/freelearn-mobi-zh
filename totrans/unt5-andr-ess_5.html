<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Asset Bundles in Unity 5 Pro</h1></div></div></div><p>This chapter will include an overview of Asset Bundles in Unity 5. You will learn how to download new code and data in real time for Android devices. At the end of this chapter, the reader will discover the safeness technique of the asset bundles in practice.</p><p>The topics that will be covered in this chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overview of Asset Bundles in Unity 5</li><li class="listitem" style="list-style-type: disc">Downloading new code and data in real time for Android devices</li><li class="listitem" style="list-style-type: disc">Safeness techniques in practice</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec23"/>An overview of the asset bundles in Unity 5</h1></div></div></div><p>Asset bundles are <strong>Unity Pro</strong>
<a id="id272" class="indexterm"/> features only. Two main ideas of the asset bundles are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easily download content in your application</li><li class="listitem" style="list-style-type: disc">Uploading new content in your application</li></ul></div><p>Unity <a id="id273" class="indexterm"/>allows exporting your assets as files, which are known as asset bundles. Your application can download these compressed files whenever needed. This approach will reduce your final build size by streaming in: prefabs, animations, binary files, textures, audio clips, meshes, and scenes, where asset bundles will be utilized. All other asset types are supported by Unity. For binary files, you should set the extension to <code class="literal">.bytes</code> and Unity will recognize these files as <code class="literal">TextAsset</code>. To use asset bundles, you just need to create them and upload them to your server. In the Unity Editor, you can build asset bundles from your assets in the scene. In a situation when you need to upload your asset bundles to the server, you can use any data communication protocol; for example, SSH, FTP, FTPS, SFTP, or any other protocol depending on your choice. In real time, your application, which is written in your script, will download the necessary asset bundles for further work with your packed assets in these exported files.</p><p>We will cover what you should do to create the <code class="literal">AssetBundle</code> file. For this task, you should use the Unity Editor class known as <code class="literal">BuildPipeline</code>.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>If you are using any of the Unity Editor classes in your scripts, then you should always remember to keep these scripts in a folder named <code class="literal">Editor</code> anywhere in your project within any subdirectory of the <code class="literal">Assets</code> folder.</p></div></div><p>Now, let's create a simple C# script to create <code class="literal">AssetBundle</code>. First of all, we should import two Unity namespaces:</p><div><pre class="programlisting">  using UnityEngine;
  using UnityEditor;</pre></div><p>After these <a id="id274" class="indexterm"/>lines of code, you should declare your public class; for example, you can create very simple class declaration:</p><div><pre class="programlisting">  public class BuilderAssetBundle {
    // the code you will see below
  }</pre></div><p>In the next step, we will create a static function with its <code class="literal">MenuItem</code> for future selection from the Unity Editor menu:</p><div><pre class="programlisting">  [MenuItem("PacktPub/AssetBundles/Build Asset Bundle")]
  static void Build() {
    // the code you will see below
  }</pre></div><p>After that, you need to fill in your static function with just a single instruction or line of code or something similar depending on your requirements, and you will see the already finished simple class to build your <code class="literal">AssetBundle</code>:</p><div><pre class="programlisting">  BuildPipeline.BuildAssetBundle(
    Selection.activeObject, 
   Selection.GetFiltered(typeof(Object),SelectionMode.DeepAssets),
    "Assets/Your/Path/To/YourAssetBundle.unity3d",
    BuildAssetBundleOptions.CollectDependencies | 
    BuildAssetBundleOptions.CompleteAssets
  );</pre></div><p>This function creates a compressed <code class="literal">Assets/Your/Path/To/YourAssetBundle.unity3d</code> file with a list of packed assets (any from your project folder) and returns <code class="literal">true</code> if <code class="literal">AssetBundle</code> was created successfully or <code class="literal">false</code> otherwise. The first variable in this function, <code class="literal">Selection.activeObject</code>, indicates which object to use for retrieving packed assets from <code class="literal">AssetBundle</code> using the <code class="literal">AssetBundle.mainAsset</code> property. You can set this value to <code class="literal">null</code> if you are not using it. The second variable is <code class="literal">array Object[]</code> and specifies which assets you need to pack. The third variable is very simple, and it is just a location where you want to save your <code class="literal">AssetBundle</code> file. By specifically adjusting <code class="literal">BuildAssetBundleOptions</code> flags, you can dictate to include all dependencies automatically or only include complete assets. Furthermore, with these options, you can specify that you don't want your assets to be compressed in the <code class="literal">AssetBundle</code> file by setting up the <code class="literal">UncompressedAssetBundle</code> flag. If you want, you can check the <code class="literal">CRC</code> checksum of<a id="id275" class="indexterm"/> your asset bundles while downloading your exported files via the <code class="literal">WWW.LoadFromCacheOrDownload</code> call. To create asset bundles, you can use three different functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BuildPipeline.BuildAssetBundle</code>: This will build any asset type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">BuildPipeline.BuildStreamedSceneAssetBundle</code>: This will include only scenes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">BuildPipeline.BuildAssetBundleExplicitAssetNames</code>: This is similar to <code class="literal">BuildPipeline.BuildAssetBundle</code>, but with a little difference. In this function, you can indicate your string identifier for all included objects.</li></ul></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>You can create the asset bundles for the Web-Player platform and use them in a standalone platform and vice versa. Alternatively, for mobile platforms, you can use only their built files. For example, you can create the asset bundles for Android devices and use them only for Android platforms, but you cannot use them for iOS platforms and vice versa. With built files for the iOS platform, you can use them only within iOS boundaries.</p></div></div><p>In order to use your class to create the asset bundle, you need to do two simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">You should select one single or many assets in your project, which will be packed into your <code class="literal">AssetBundle</code>.</li><li class="listitem">From the Unity menu, you should navigate to <strong>PacktPub</strong> | <strong>AssetBundles</strong> | <strong>Build Asset Bundle</strong>.</li></ol></div><p>The finished script to create <code class="literal">AssetBundle</code> should be similar to the code shown here:</p><div><pre class="programlisting">using UnityEngine;
using UnityEditor;

public class BuilderAssetBundle {
  [MenuItem("PacktPub/AssetBundles/Build Asset Bundle")]
  static void Build() {
    BuildPipeline.BuildAssetBundle(
      Selection.activeObject,
      Selection.GetFiltered(
        typeof(Object),
        SelectionMode.DeepAssets
      ),
      "Assets/Your/Path/To/YourAssetBundle.unity3d",
      BuildAssetBundleOptions.CollectDependencies | 
      BuildAssetBundleOptions.CompleteAssets
    );
  }
}</pre></div><p>We've realized the asset bundles creation, now let's explore how to use them from your scripts. To use your asset bundles, you should follow the next two simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Download your <code class="literal">AssetBundle</code> files from any local storage like hard drive or remote storage like any web-server, Unity provides the <code class="literal">WWW</code> helper class for such issues.</li><li class="listitem">Load <a id="id276" class="indexterm"/>or, in other words, unpack your assets from your <code class="literal">AssetBundle</code> files in order to use them further in your game.</li></ol></div><p>In the following code, we intend to understand the case of using <code class="literal">AssetBundle</code>. First of all, we need to create a simple C# script and name it, for example, <code class="literal">ImporterAssetBundle</code>. Open the script in your code editor and change it as shown here:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ImporterAssetBundle : MonoBehaviour {
  void Start() {
    StartCoroutine(Import());
  }

  public IEnumerator Import() {
    using (WWW wwwData = WWW.LoadFromCacheOrDownload(
        "http://your-domain.com/your/path/url/new2.unity3d",
        23 // your asset bundle version, as an example only
    )) {
      yield return wwwData;
      GameObject obj = www.assetBundle.mainAsset as GameObject;
      Instantiate(obj);
      www.assetBundle.Unload(false);
    }
  }
}</pre></div><p>Attach this script as a component to your GameObject. The URL in this script is just for example, so you should set your own URL for your <code class="literal">AssetBundle</code> file. Based on this version, Unity's caching system will decide whether to download your file or not. If this file was already cached with the same version number, then Unity will speed up your application. In this script, we called <code class="literal">Import</code> co-routine in the <code class="literal">Start</code> event, but you can call this function anywhere you need and as often as you want. In <code class="literal">Import</code> co-routine, we first used <code class="literal">WWW.LoadFromCacheOrDownload</code> with the sole purpose of loading the required <code class="literal">AssetBundle</code> file by given the URL path and the version number. During the downloading process, Unity will not execute the next instructions from the <code class="literal">yield return www</code> command. Only after the download is complete will Unity run the next commands in<a id="id277" class="indexterm"/> our co-routine example.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <code class="literal">www</code> instance to retrieve <code class="literal">mainAsset</code> as a GameObject instance from the downloaded <code class="literal">AssetBundle</code></li><li class="listitem" style="list-style-type: disc">Creating a new instance in real time in the current scene of the retrieved <code class="literal">GameObject</code> instance</li><li class="listitem" style="list-style-type: disc">Unloading all the memory used for this <a id="id278" class="indexterm"/><strong>AssetBundle</strong> (for increasing the performance).</li></ul></div><p>As making projects is an iterative procedure, you will probably alter your assets not once but multiple times, which may oblige remaking the asset bundles after every change to have the capacity to test them. Despite the fact that it is conceivable to load the asset bundles in the Unity editor, it is not the best solution. Rather, while testing in the Unity editor, you ought to utilize the aide function <code class="literal">Resources.LoadAssetAtPath</code> to abstain from needing to utilize and revamp the asset bundles. The function gives you a chance to load your asset as though it were being stacked from an asset bundle, yet we will skirt the building procedure, and your assets are constantly up and coming. Let's create a new C# script that will improve our last example with some exception handling and with <code class="literal">Resources.LoadAssetAtPath</code> in event of importing within the Unity editor. Create a new script and name it, for example, <code class="literal">MyAssetBundleImporter</code>. The next step is to declare at the beginning of the file the required namespaces that we will use:</p><div><pre class="programlisting">  using UnityEngine;
  using System.Collections;
After these lines we will declare our public class:
  public class MyAssetBundleImporter {
    // the code you will see below
  }</pre></div><p>Let's declare the <code class="literal">public</code> property in this class for objects that will be retrieved from your <code class="literal">AssetBundle</code>:</p><div><pre class="programlisting">  public Object assetBundleObject;</pre></div><p>Also, in this class, let's declare our <code class="literal">public</code> and specific <code class="literal">AssetBundle</code> structure with its public properties for further usage:</p><div><pre class="programlisting">  public struct AssetBundleStruct {
    public string assetSourceName;
    public string assetSourcePath;
    public string assetBundleUrl;
    public int assetBundleVersion;
  }</pre></div><p>Next, we will declare the core of this script, the function which Unity will execute as a co-routine:</p><div><pre class="programlisting">  public IEnumerator Import&lt;T&gt;(AssetBundleStruct abs) where T : Object {}</pre></div><p>The first step in the co-routine is to initialize our <code class="literal">assetBundleObject</code> to <code class="literal">null</code>:</p><div><pre class="programlisting">  assetBundleObject = null;</pre></div><p>After that line of<a id="id279" class="indexterm"/> code, let's declare the main condition in order to decide how to import your asset bundles:</p><div><pre class="programlisting">  #if UNITY_EDITOR
    // 1st part, the code you will see below
  #else
    // 2nd part, the code you will see below
  #endif</pre></div><p>Let's create a code for the first part of the <code class="literal">if</code>/<code class="literal">else</code>/<code class="literal">endif</code> pre-processor statement:</p><div><pre class="programlisting">  assetBundleObject = Resources.LoadAssetAtPath(
    abs.assetSourcePath, typeof(T)
  );

  if (null == assetBundleObject){
    Debug.LogError("AssetBundle ERROR Path: " + abs.assetSourcePath);
    Debug.LogError("Asset Bundle could not be found !!!");
  }
  yield break;</pre></div><p>Now, we will create the code for the second part of the <code class="literal">if</code>/<code class="literal">else</code>/<code class="literal">endif</code> preprocessor statement:</p><div><pre class="programlisting">  WWW www;
  if (Caching.enabled) {
    while (false == Caching.ready) {
      yield return null;
    }
    www = WWW.LoadFromCacheOrDownload(
      abs.assetBundleUrl, abs.assetBundleVersion
    );
  } else {
    www = new WWW(abs.assetBundleUrl);
  }

  yield return www;

  if (null != www.error) {
    Debug.LogError(www.error);
    www.Dispose();
    yield break;
  }

  AssetBundle ab = www.assetBundle;
  www.Dispose();
"  www = null;
  if (string.Empty == abs.assetSourceName || null == abs.assetSourceName) {
    assetBundleObject = ab.mainAsset;
  } else {
    assetBundleObject = ab.Load(abs.assetSourceName, typeof(T));
  }

  ab.Unload(false);</pre></div><p>Let's create a simple<a id="id280" class="indexterm"/> script inherited from <code class="literal">MonoBehaviour</code>, which will show how you can use your example class <code class="literal">MyAssetBundleImporter</code>:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ExampleMyImporterUsage : MonoBehaviour {
  public MyAssetBundleImporter.AssetBundleStruct abs;
  
  private string _tmpStr;
  private Object _tmpObj;
  void Start() {
    abs = new MyAssetBundleImporter.AssetBundleStruct();
    abs.assetBundleUrl = "http://yourapp.com/your/bundle.unity3d";
    abs.assetBundleVersion = 0;
    abs.assetSourceName = "YourPrefabName";

    StartCoroutine(Import());
  }

  IEnumerator Import() {
    MyAssetBundleImporter mabi = new MyAssetBundleImporter();
    yield return StartCoroutine(mabi.Import&lt;GameObject&gt;(abs));
    if (null != mabi.assetBundleObject) {
      _tmpObj = Instantiate(mabi.assetBundleObject);
    }
  }

  void OnGUI() {
    if (null != _tmpObj) {
      _tmpStr = _tmpObj.name + " was successfully created.";
      GUILayout.Label(_tmpStr);
    } else {
      GUILayout.Label("ERROR: Cannot import your AssetBundle.");
    }
  }
}</pre></div><p>Let's describe what <a id="id281" class="indexterm"/>happened in the last script. First, we declared one public <code class="literal">AssetBundleStruct</code> variable and two private variables. After that, we created the <code class="literal">Start</code> method, where we initialized our <code class="literal">AssetBundleStruct</code> variable with the right values. Next, we called the co-routine <code class="literal">Import</code> in our <code class="literal">Start</code> function. In the <code class="literal">Import</code> co-routine, we created one single instance of our class <code class="literal">MyAssetBundleImporter</code> to call its <code class="literal">Import</code> co-routine with our initialized structure <code class="literal">abs</code>. If we imported the object and it is not equal to <code class="literal">null</code>, then we instantiate that GameObject in our scene. Also, we show the simple <code class="literal">GUI</code> label that indicates whether we successfully imported our <code class="literal">AssetBundle</code> or not. For using this (only if your <code class="literal">AssetBundle</code> was already created and uploaded) script, you should just attach it as a component to your GameObject in your scene and set up correct values. If those two simple steps were done, then you can play and test your game in the Unity editor or within your build.</p><p>If you need to get an array with all contained objects from your <code class="literal">AssetBundle</code>, you should use the function known as <code class="literal">AssetBundle.LoadAll</code>. In the event where you need to get a list of the string identifiers, you should keep a specific <code class="literal">TextAsset</code> as a map to save your assets' names there.</p><p>In the following steps, we're going to show a simple example about adjusting different texture compressions before building your asset bundle. All we need to remember is two simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In order to force reimporting your assets before building the asset bundle, you should use the <code class="literal">AssetDatabase.ImportAsset</code> function.</li><li class="listitem">After you should use <code class="literal">AssetPostprocessor.OnPreprocessTexture</code> to adjust correct values for your texture compression.</li></ol></div><p>Now, let's write a simple code example that you can use in your projects like any other examples from this book:</p><div><pre class="programlisting">  using UnityEngine;
  using UnityEditor;  </pre></div><p>As always, we declare the required namespaces (remember this script will use <code class="literal">UnityEditor</code> and should be located in <code class="literal">Editor</code> folder, we spoke earlier about this Unity requirement). The next step is to define a simple class using the following code:</p><div><pre class="programlisting">  public class TextureFormatAssetBundles {
    // the code you will see below
  }</pre></div><p>After the simple class declaration, we need to set up one <code class="literal">public</code> and <code class="literal">static</code> variable, at the same time, and three<a id="id282" class="indexterm"/> different but elementary functions (you can use any desired texture format; in this example, we use <code class="literal">DXT1</code>, <code class="literal">DXT5</code>, and <code class="literal">ETC_RGB4</code>):</p><div><pre class="programlisting">  public static TextureImporterFormat tif;

  [MenuItem("PacktPub/AssetBundles/Create Asset Bundle DXT1")]
  static void SetTextureFormatDXT1() {
    tif = TextureImporterFormat.DXT1;
    CreateAssetBundle();
  }

  [MenuItem("PacktPub/AssetBundles/Create Asset Bundle DXT5")]
  static void SetTextureFormatDXT5() {
    tif = TextureImporterFormat.DXT5;
    CreateAssetBundle();
  }

  [MenuItem("PacktPub/AssetBundles/Create Asset Bundle ETC_RGB4")]
  static void SetTextureFormatETC_RGB4() {
    tif = TextureImporterFormat.ETC_RGB4;
    CreateAssetBundle();
  }</pre></div><p>Now, we can write our main function <code class="literal">CreateAssetBundle</code> that does all the dirty work:</p><div><pre class="programlisting">  static void CreateAssetBundle() {
    // the code you will see below
  }</pre></div><p>In our first step, we call the <code class="literal">EditorUtility.SaveFilePanel</code> method in order to show the Unity dialog and to get a selected path string from it. Also, we need to return from this function an empty location variable:</p><div><pre class="programlisting">  string selectedPath = EditorUtility.SaveFilePanel(
    "Save", // TITLE
    string.Empty, // DIRECTORY PATH
    "Your AssetBundle Name", // DEFAULT FILE NAME
    "unity3d" // FILE EXTENSION
  );

  if (selectedPath.Length == 0) return;</pre></div><p>The next step is to declare an array with our selected objects:</p><div><pre class="programlisting">  Object[] selectedAssets = Selection.GetFiltered(
    typeof(Object), SelectionMode.DeepAssets
  );</pre></div><p>Further, we have to <a id="id283" class="indexterm"/>process each texture from our array in a loop in order to get path for that asset source with the help of the <code class="literal">AssetDatabase.GetAssetPath</code> method. For texture, we must use the <code class="literal">AssetDatabase.ImportAsset</code> function to force our texture preprocessing:</p><div><pre class="programlisting">  for (int i=0; i &lt; selectedAssets.Length; i++) {
    Object obj = selectedAssets[i];
    if ((obj is Texture) == false) continue;
    string texturePath = AssetDatabase.GetAssetPath(
      (UnityEngine.Object) obj
    );
    AssetDatabase.ImportAsset(texturePath);
  }</pre></div><p>After this, we have to build our <code class="literal">AssetBundle</code>:</p><div><pre class="programlisting">  BuildPipeline.BuildAssetBundle(
    Selection.activeObject,
    selectedAssets,
    selectedPath,
    BuildAssetBundleOptions.CollectDependencies |
    BuildAssetBundleOptions.CompleteAssets
  );</pre></div><p>At the last stage, we can initialize the <code class="literal">Selection.objects</code> list variable with our selected assets array in order to see all of them:</p><div><pre class="programlisting">  Selection.objects = selectedAssets;</pre></div><p>Now, we should create a very simple class (this script should be placed into the <code class="literal">Editor</code> folder, we mentioned this requirement earlier) inherited from the <code class="literal">AssetPostprocessor</code> class as shown here:</p><div><pre class="programlisting">using UnityEngine;
using UnityEditor;

public class TextureAssetsPreprocessor : AssetPostprocessor {
  void OnPreprocessTexture() {
    TextureImporter ti = assetImporter as TextureImporter;
    ti.textureFormat = TextureFormatAssetBundles.tif;
  }
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Downloading new code and data in real time for Android devices</h1></div></div></div><p>In the event of retrieving assets<a id="id284" class="indexterm"/> from your bundles, you can use three separate functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AssetBundle.Load</code>: This will load <a id="id285" class="indexterm"/>one object only by the given name; also it will block the main thread.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AssetBundle.LoadAsync</code>: This <a id="id286" class="indexterm"/>will load one object only by a given name; it will not block the main thread. Use this method for huge assets.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AssetBundle.LoadAll</code>: This will<a id="id287" class="indexterm"/> load every object from your <code class="literal">AssetBundle</code>.</li></ul></div><p>Use the <code class="literal">AssetBundle.Unload</code> method in the event of unloading assets. Let's look at a simple usage example of the asynchronous method as shown in the following code without any exception handling and any checks (just as <code class="literal">skeleton</code>):</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class GetAssetBundleAsync : MonoBehaviour {
  public string assetBundleUrl = "http://yourweb.com/yourBundle.unity3d";
  public int assetBundleVersion = 1;

  IEnumerator Start() {
    WWW www = WWW.LoadFromCacheOrDownload(
      assetBundleUrl, assetBundleVersion
    );

    yield return www;

    AssetBundle ab = www.assetBundle;

    AssetBundleRequest abr = ab.LoadAsync(
      "YourObjName", typeof(GameObject)
    );
  
    yield return abr;

    GameObject go = abr.asset as GameObject;

    ab.Unload(false);
    www.Dispose();
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Managing loaded asset bundles</h2></div></div></div><p>Asset bundles cannot be loaded<a id="id288" class="indexterm"/> if a previous bundle has not been unloaded previously:</p><div><pre class="programlisting">  AssetBundle ab = www.assetBundle;</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Try to always keep references for your imported assets, to avoid importing same assets multiple times.</p></div></div><p>Unity will throw an exception and your asset bundle (in our example, <code class="literal">ab</code> variable) variable will be <code class="literal">null</code>.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Try to unload your <code class="literal">AssetBundle</code> as early as possible.</p></div></div><p>You can use the next simple script (as shown in the following code) for your loaded bundles. All this code should be pretty clear to you, so let's look at this C# script:</p><div><pre class="programlisting">using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;

static public class YourAssetBundleDispatcher {
  static Dictionary&lt;string, YourBundleReference&gt; dictionaryBundles;

  static YourAssetBundleDispatcher() {
         dictionaryBundles = new Dictionary&lt;string, YourBundleReference&gt;();
  }

     private class YourBundleReference {
         public AssetBundle ab = null;

         public int assetBundleVersion;
         public string assetBundleUrl;

         public YourBundleReference(string url, int version) {
               assetBundleUrl = url;
               assetBundleVersion = version;
         }
     };

  public static AssetBundle 
        RetrieveAssetBundle(string abUrl, int abVersion) {
         string bundleKey = abUrl + abVersion.ToString();
       
    YourBundleReference ybr;
       
    if (dictionaryBundles.TryGetValue(bundleKey, out ybr))
               return ybr.ab;
         else
               return null;
     }

     public static IEnumerator ImportAssetBundle(string abUrl, int abVersion){
          string bundleKey = abUrl + abVersion.ToString();
       
    if (dictionaryBundles.ContainsKey(bundleKey)) {
               yield return null;
         } else {
                using(WWW www = WWW.LoadFromCacheOrDownload(abUrl, abVersion)){
                   yield return www;

                   if (www.error != null)
                         throw new Exception("WWW ERROR:" + www.error);
        YourBundleReference ybr = new YourBundleReference(
          abUrl, abVersion
        );
                   ybr.ab = www.assetBundle;
                   dictionaryBundles.Add(bundleKey, ybr);
                }
         }
  }

  public static void Dispose(string abUrl, int abVersion, bool flag) {
    string bundleKey = abUrl + abVersion.ToString();
       
    YourBundleReference ybr;

         if (dictionaryBundles.TryGetValue(bundleKey, out ybr)){
               ybr.ab.Unload(flag);
               ybr.ab = null;
               dictionaryBundles.Remove(bundleKey);
         }
     }
}</pre></div><p>You can use the <a id="id289" class="indexterm"/>dispatcher class as shown here:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

class DispatcherUsage : MonoBehaviour {
  public string assetBundleUrl;
     public int assetBundleVersion;

     AssetBundle ab;

    void Start() {
    Debug.Log("Importing your Asset Bundle");
            ab = YourAssetBundleDispatcher.RetrieveAssetBundle(
      assetBundleUrl, assetBundleVersion
    );
             if(null != ab) StartCoroutine(ImportAssetBundle());
  }

     IEnumerator ImportAssetBundle() {
         yield return StartCoroutine(
      YourAssetBundleDispatcher.ImportAssetBundle(
        assetBundleUrl, assetBundleVersion
      )
    );

         ab = YourAssetBundleDispatcher.RetrieveAssetBundle(
      assetBundleUrl, assetBundleVersion
    );
  }

  void OnDisable() {
         YourAssetBundleDispatcher.Dispose(
      assetBundleUrl, assetBundleVersion, false
    );
  }
}</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>It is possible to clone your previous instantiated objects to avoid unnecessary importing bundles (by calling Unity's function known as <code class="literal">GameObject.Instantiate</code>).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Asset bundles and binary data</h2></div></div></div><p>Unity treats binary files <a id="id290" class="indexterm"/>with a <code class="literal">.bytes</code> extension as a <code class="literal">TextAsset</code>, which <a id="id291" class="indexterm"/>can be included in your <code class="literal">AssetBundle</code>. Here's an example of the C# script shown here:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class BinaryDataExample : MonoBehaviour {
  string assetBundleUrl = 
    "http://yourweb.com/path/to/yourAssetBundle_1.unity3d";

  IEnumerator Start() {
    WWW www = WWW.LoadFromCacheOrDownload(assetBundleUrl, 1);
    yield return www;

    AssetBundle ab = www.assetBundle;

    TextAsset textAsset = ab.Load(
      "YourBinaryFileName", typeof(TextAsset)
    ) as TextAsset;

    byte[] yourBinaryData = textAsset.bytes;
  }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Asset bundles and scripts</h2></div></div></div><p>You can build<a id="id292" class="indexterm"/> your asset bundles with scripts as <code class="literal">TextAsset</code> files, which <a id="id293" class="indexterm"/>can be executable only in the event of precompiling them into an assembly. This example is shown in the following code:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class AssetBundleScript : MonoBehaviour {
  string assetBundleUrl = 
    "http://yourweb.com/your/asset/bundle_test.unity3d";

  IEnumerator Start () {
    WWW www = WWW.LoadFromCacheOrDownload (assetBundleUrl, 1);
        yield return www;

        AssetBundle ab = www.assetBundle;

        TextAsset textAsset = ab.Load(
      "yourBinaryAssetName", typeof(TextAsset)
    ) as TextAsset;

        var assmbl = System.Reflection.Assembly.Load(textAsset.bytes);
    
    GameObject gameObj = new GameObject();
        gameObj.AddComponent(
      assmbl.GetType(
        "Your_ClassName_Inherited_From_MonoBehaviour"
      )
    );
  }
  }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Asset bundle dependencies</h2></div></div></div><p>Many of your assets will <a id="id294" class="indexterm"/>depend on other assets, such as materials, textures, shaders, and so on. You can build your bundle with all those assets, but this approach can reduce the size of the <code class="literal">AssetBundle</code> file. Furthermore, this approach will not be effective if all those dependencies are used for your other bundles. Too much memory will be wasted. Instead, you can create a separate asset bundle with all those shared dependencies, which will be used by other bundles. In the event of using these dependencies, firstly, you should call the function known as <code class="literal">BuildPipeline.PushAssetDependencies</code>, and then your shared bundle can be built for other bundles. Therefore, before each new level, you should always call this function to tell Unity to put your bundle in its stack for further usage by other bundles. At the end of your bundle creation, you should always empty this stack of bundles by a command known as <code class="literal">BuildPipeline.PopAssetDependencies</code>. In your application, you should always import all your shared bundles and only after that you can import your other bundles with those dependencies. Let's see how to save separate <code class="literal">AssetBundle</code> with shared shaders (as shown here) in this action:</p><div><pre class="programlisting">using UnityEngine;

public class YourAssetBundleShaders : MonoBehaviour {
        public Shader[] assetBundleShaders;
}</pre></div><p>Create an empty GameObject <a id="id295" class="indexterm"/>and attach this script to it and save it (after populating array of shaders) as a prefab anywhere you want within your project files. The following step is to create the C# script to generate asset bundles as shown here, where <code class="literal">YourAssetBundle_2</code> requires <code class="literal">YourAssetBundle_1</code> and <code class="literal">YourAssetBundle_3</code> depends on the first and the second bundles. This is just an example, you should change it depending on your needs:</p><div><pre class="programlisting">using UnityEngine;
using UnityEditor;

public class AssetBundleGenerator {
  [MenuItem("PacktPub/AssetBundles/Generate all accessible Asset Bundles")]
       static void Generate() {
         BuildAssetBundleOptions options = 
                 BuildAssetBundleOptions.CollectDependencies | 
                    BuildAssetBundleOptions.CompleteAssets | 
                    BuildAssetBundleOptions.DeterministicAssetBundle;

    BuildPipeline.PushAssetDependencies();

             BuildPipeline.BuildAssetBundle(
      AssetDatabase.LoadMainAssetAtPath(
        "Assets/YourAssetName_1.prefab"
      ), 
      null, 
      "Your/Path/To/YourAssetBundle_1.unity3d", 
      options
    );

    BuildPipeline.PushAssetDependencies();
    BuildPipeline.BuildAssetBundle(
      AssetDatabase.LoadMainAssetAtPath(
        "Assets/YourAssetName_2.prefab"
      ), 
      null, 
      "YourPath/To/YourAssetBundle_2.unity3d", 
      options
    );

    BuildPipeline.BuildAssetBundle(
      AssetDatabase.LoadMainAssetAtPath(
        "Assets/YourAssetName_3.prefab"
      ), 
      null, 
      "YourPath/To/YourAssetBundle_3.unity3d", 
      options
    );           

    BuildPipeline.PopAssetDependencies();
    BuildPipeline.PopAssetDependencies();
  }

  [MenuItem("PacktPub/AssetBundles/Rebuild Asset Bundle")]
       static void Rebuild() {
    BuildAssetBundleOptions options = 
      BuildAssetBundleOptions.CollectDependencies | 
      BuildAssetBundleOptions.CompleteAssets | 
      BuildAssetBundleOptions.DeterministicAssetBundle;

    BuildPipeline.PushAssetDependencies();
    BuildPipeline.BuildAssetBundle(
      AssetDatabase.LoadMainAssetAtPath(
        "Assets/YourAssetBundleName_1.prefab"
      ), 
      null, 
      "YourPath/To/YourAssetBundle_1.unity3d", 
      options
    );
    
    BuildPipeline.PopAssetDependencies();
  }
  }</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Safeness techniques in practice</h1></div></div></div><p>Next, the C# script example will cover <a id="id296" class="indexterm"/>how to protect the content of your asset bundles (as shown here):</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class AssetBundleSecurityFirst : MonoBehaviour {
  string assetBundleUrl = 
    "http://yourweb.com/path/to/yourAssetBundle.unity3d";

  IEnumerator Start() {
    WWW www = WWW.LoadFromCacheOrDownload(assetBundleUrl, 1);
    yield return www;

    TextAsset textAsset = www.assetBundle.Load(
      "YourEncryptedAssetName", typeof(TextAsset)
    ) as TextAsset;
  
    /*byte[] yourDecryptedBytes = AnyDecryptionFunction(
      textAsset.bytes // your encrypted bytes
    );*/
  }
}</pre></div><p>Another secure <a id="id297" class="indexterm"/>way is to encrypt the whole asset bundle instead of just the <code class="literal">TextAsset</code> data as shown in the preceding code. Alternatively, in this approach, you cannot use the <code class="literal">WWW.LoadFromCacheOrDownload</code> method. You always need to import your bundles from <code class="literal">WWW</code> streaming as shown in the following code:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class AssetBundleSecuritySecond : MonoBehaviour {
  string assetBundleUrl = 
    "http://yourweb.com/path/to/yourAssetBundle.unity3d";

  IEnumerator Start () {
    WWW www = new WWW(assetBundleUrl);
    yield return www;
  
    /*byte[] yourEncryptedBytes = www.bytes;
    byte[] yourDecryptedBytes = 
      AnyDecryptionFunction(yourEncryptedBytes);

    AssetBundleCreateRequest assetBundleCreateRequest = 
      AssetBundle.CreateFromMemory(yourDecryptedBytes);

    yield return assetBundleCreateRequest;

    AssetBundle ab = assetBundleCreateRequest.assetBundle;*/

    // Here you can use your AssetBundle. 
    // The AssetBundle was not cached.
  }
}</pre></div><p>The last and the best protection<a id="id298" class="indexterm"/> approach is to keep your encrypted <code class="literal">AssetBundle</code> as <code class="literal">TextAsset</code> inside another (not encrypted) <code class="literal">AssetBundle</code>. Thus, we can use Unity's caching system for our asset bundles as shown here:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class AssetBundleSecurityThird : MonoBehaviour {
  string assetBundleUrl = 
    "http://yourweb.com/path/to/yourAssetBundle.unity3d";

  IEnumerator Start() {
    WWW www = WWW.LoadFromCacheOrDownload(assetBundleUrl, 1);
    yield return www;

    TextAsset textAsset = www.assetBundle.Load(
      "YourEncryptedAsset", typeof(TextAsset)
    ) as TextAsset;
  
    /*byte[] yourEncryptedBytes = textAsset.bytes;
    byte[] yourDecryptedBytes = 
      AnyDecryptionFunction(yourEncryptedBytes);

    AssetBundleCreateRequest assetBundleCreateRequest = 
      AssetBundle.CreateFromMemory(yourDecryptedBytes);
    yield return assetBundleCreateRequest;

    AssetBundle ab = assetBundleCreateRequest.assetBundle;*/
    // Here you can use your AssetBundle. The AssetBundle was cached.
  }
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we discovered asset bundles. There were a lot of code examples. We learned how to build and import your asset bundles and how to encrypt data for the asset bundle by different methods. Furthermore, in this chapter, we explored how to create and use your <code class="literal">AssetBundle</code> dependencies with other bundles. Also, we studied how to use binary data with asset bundles and executable scripts.</p><p>In the next chapter, we will introduce different optimization techniques. You will learn in practice how to use occlusion culling and level of details optimization techniques. You will see how to optimize native C# and Unity scripts. Finally, you will see how to transform native C# and JavaScript codes into Unity scripts.</p></div></body></html>