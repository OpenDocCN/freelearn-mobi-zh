- en: Chapter 8. Integrating with Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling a cab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiring a van
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting your code from one language to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the user interface classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading the app delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own custom framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift 2 is out, and we can see that it is going to replace Objective-C on iOS
    development sooner or later, however how should you migrate your Objective-C app?
    Is it necessary to rewrite everything again?
  prefs: []
  type: TYPE_NORMAL
- en: Of course you don't have to rewrite a whole application in Swift from scratch,
    you can gradually migrate it. Imagine a four year old app developed by 10 developers,
    it would take a long time to be rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, you've already seen that some of the codes we've used in this book
    have some kind of "old Objective-C fashion". The reason is that not even Apple
    computers could migrate the whole Objective-C code into Swift.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you migrate from Objective-C to Swift, step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a cab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that we work for a taxi company, which already has an app that
    allows the clients to call a taxi from it. As you may imagine, the company can
    start giving additional services rather than only using traditional cars, for
    example, let's imagine that now they want to offer hiring a van for people that
    have a lot of luggage.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to start with a pure Objective-C application, after
    which we are going to modify it for being prepared to add a Swift code in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating a project called `Chapter 8 Cab`, but in this case
    select Objective-C instead of Swift as the programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a new file to your project, select **Cocoa Touch Class,** which
    is located on the upper right-hand side of the iOS source:![How to do it…](img/00096.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then create a file called `Car`, which should be a subclass of `NSObject`:![How
    to do it…](img/00097.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that two files are created, one is called `Car.h` and the other
    one is called `Car.m`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the header file (`Car.h`) and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the class interface is created, we have to implement this class, so click
    on the file `Car.m` and type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The model part is done, now we need to create the view part.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's do something very straightforward, just add a table view onto the storyboard,
    and then link it with the view controller as an attribute, as a data source, and
    as a delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you have to modify the header file (usually called `ViewController.h`),
    add an auxiliary attribute called `vehicles` of type `NSArray`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To add some functionality to this app, go to the message file (usually called
    `ViewController.m`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Switching from the header file to its implementation or vice versa can be done
    using ** + *^* + up arrow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First let''s import the `Car.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the data source content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you have to initialize the vehicle''s attributes. Of course, here, we
    are going to use just some hard code, otherwise we would have a huge amount of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing we need to do is create an event for the user for letting him
    choose a car for booking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now test this app just to see that it is working. The next step is preparing
    this app to receive some Swift code. Before adding any Swift file we need to modernize
    this code; fortunately Xcode offers an option that does it automatically, so click
    on the **Edit** menu, then choose **Refactor**, and finally **Convert to Modern
    Objective-C Syntax…**:![How to do it…](img/00098.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you start modernizing your code, it's a good idea to commit your code
    on the version control system, if you are using one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When a dialog appears with some introduction text, press **Next**, then check
    every target that appears on the next dialog, usually they are checked but just
    in case make sure of it. On the next screen, you will see some options to modernize
    your Objective-C code, you can leave all of them with their default values, but
    it is a better idea to make sure that every option is marked "yes":![How to do
    it…](img/00099.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, you will see another dialog displaying the differences between the
    original code and the one that is going to be updated. Check the differences of
    each file by clicking on the filenames on the left-hand side:![How to do it…](img/00100.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid modernizing your code without checking the differences between the old
    and the new code, sometimes you will find modifications that are not conceptually
    right.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press **Save** and you will see a new dialog asking if you would like to enable
    automatic snapshots:![How to do it…](img/00101.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now check that your project has the code changed and it still works as before.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you migrate your Objective-C application to Swift, the first thing that
    you need to do is convert your code to Modern Objective-C Syntax. Thanks to this
    your code will be ready for being compatible with Swift integration.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that after modernizing your code, that part of your code is modified,
    for example, ID is replaced with `instancetype`, initializers receive the modifier
    `NS_DESIGNATED_INITIALIZER`, and some functions are converted into property, mainly
    those functions that start with get or set.
  prefs: []
  type: TYPE_NORMAL
- en: Usually this kind of change is considered a massive change, which of course
    has the risk of needing to roll back to the previous state. This is the reason
    why Xcode recommends you to create a snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we learned how to get an existing Objective-C app and prepare
    it for using its code with Swift. Of course, sometimes you can do it automatically
    and sometimes you have to change it manually. It is a good idea to check the modern
    Objective-C documentation. You can do it by visiting the website: [https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html](https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiring a van
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we are going to give more functionality to the cab application,
    in this case we are going to assume that the application won't call only cars,
    but also a van service will be available. In this case the van needs to specify
    its capacity, as we are modernizing the code, we will do it using Swift. Of course,
    there will always be some code to type in Objective-C, bear that in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we are going to continue with the previous app, so make a copy
    of the previous recipe and open the project copy. If you want to rename the app
    from `Chapter 8 Car` to `Chapter 8 Vehicles`, it would be good to differentiate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, click on the project navigator, then on the group that contains the source
    code, and add a new Swift file called `Van.swift`. Check that after trying to
    add it, a new dialog appears asking whether you would like to create a bridge
    file. Click on **Yes**, otherwise you will have to create a header file by yourself:![How
    to do it…](img/00102.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have accepted it, go to building settings, type `bridging` on the search
    field and check that there is a file set on the option **Objective-C Bridging
    Header**:![How to do it…](img/00103.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, check that there is a new file on the project navigator called
    `Chapter 8 Vehicles-Bridge-Header.h`, and its contents are basically empty (only
    a few comments), so let''s import the file `Car.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, click on `Car.h` and let''s add the last modifications, and create a property
    called `image`, this way we can differentiate one car from one van:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You are going to receive an error because `Car.h` doesn''t import the UIKit,
    so go to the top of this file and add the following import instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that you will have to click on `Car.m` to initialize this new property,
    so add the following code in both initializers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can click back on the Swift file and create a class that represents
    a van. In this case, we will add an attribute called `capacity`, which will represent
    the space, measured in square meters. As you may imagine, this class will be a
    subclass of a car:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we need two images for helping the user to visualize when it
    is a car and when it is a van. Drag the corresponding images from the `Resources`
    folder of this book into the **Supporting Files** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is obvious that we can''t stop here, we have to change the view controller
    for letting the new class be represented with its specific information. Click
    on the `ViewController.m` file and make the following changes: first change the
    method `cellForRowAtIndexPath`, it will be displayed in a more complete way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now the compiler is going to complain about the `Van` class, the reason is
    that you need to import it. How can we import a Swift file in Objective-C? The
    answer is very simple, just import a file called the same as your project name
    and concatenating the suffix `-Swift.h`. If your project has whitespace in its
    name, replace it with underscores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then you have to add one more element to the vehicles array, so go to the `viewDidLoad`
    and add a van object after car number 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now our first migration is done, press play and you will see that your application
    is still working, but with the possibility of hiring a van:![How to do it…](img/00104.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you mix Swift with Objective-C you have to create a bridge file in case
    of using Swift code in the Objective-C part. Usually you are guided by a wizard,
    which creates the bridge file and sets it into the building settings, but bear
    in mind that you may need to do it if the wizard doesn't appear.
  prefs: []
  type: TYPE_NORMAL
- en: You have to import every header file that you want to use in Swift. In this
    case you had to import `Car.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Swift classes can inherit from Objective-C classes, however, the opposite is
    not allowed, meaning that if you start adding Swift code into your project you
    need to be sure that you are not going to continue developing classes with Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: As you've just seen, you can treat the Swift class as an Objective-C class,
    even if you need to use methods such as `isKindOfClass`, and also the Objective-C
    was converted to Swift with its philosophy, such as creating an initializer, like
    `init(fare:Float)`, when in Objective-C its original name was `initWithFare`.
  prefs: []
  type: TYPE_NORMAL
- en: Porting your code from one language to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe we learned how to add a new code into an existing Objective-C
    project, however, you shouldn't only add new code but also, as far as possible,
    you should migrate your old code to the new Swift language.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to keep your application core on Objective-C, that's OK, but
    remember that new features are going to be added to Swift and it will be difficult
    keeping two languages on the same project.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to port part of the code, which is written in Objective-C
    to Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make a copy of the previous recipe. If you are using any version control it's
    a good time for committing your changes. If you are not using a version control
    system, check [Chapter 1](part0014_split_000.html#DB7S1-bba3081a9dc049b7aa5e4f7cc42ef8bb
    "Chapter 1. Getting Started with Xcode and Swift"), *Getting Started with Xcode
    and Swift*, to see how to add it to your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the project and add a new file called `Setup.swift`, here we are going
    to add a new class with the same name (Setup):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have this car array generator we can call it on the `viewDidLoad`
    method replacing the previous code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, press play and check that the application is still working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason we had to create a class instead of creating a function is that you
    can only export to Objective-C classes, protocols, properties, and subscripts.
    Bear that in mind in case of developing with the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to export a class to Objective-C you have two choices. The
    first one is inheriting from `NSObject` and the other one is adding the `@objc`
    attribute before your class, protocol, property, or subscript.
  prefs: []
  type: TYPE_NORMAL
- en: If you paid attention, our method returns a Swift array converted to an NSArray,
    but as you might know, they are different kinds of array. Firstly because Swift
    arrays are mutable and NSArrays are not, and the other reason is that their methods
    are different.
  prefs: []
  type: TYPE_NORMAL
- en: Can we use NSArray in Swift? The answer is yes, but I would recommend avoiding
    it; imagine once finished migrating to Swift your code still follows the old way,
    it would be another migration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Migrating from Objective-C is something that you should do with care. Don't
    try to change the whole application at once, remember that some Swift objects
    behave differently from Objective-C, for example, dictionaries in Swift have the
    key and the value types specified, but in Objective-C they can be of any type.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the user interface classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this moment you know how to migrate the model part of an application, however
    in real life we also have to replace the graphical classes. Doing it is not complicated
    but it could be a bit full of details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing with the previous recipe, make a copy of it or just commit the changes
    you have and let's continue with our migration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First create a new file called `MainViewController.swift` and start importing
    the UIKit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is creating a class called `MainViewController`. This class must
    inherit from `UIViewController` and implement the protocols `UITableViewDataSource`
    and `UITableViewDelegate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the attributes we had in the previous view controller, keeping the
    same name you used before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to implement the methods; let''s start with the table view data
    source methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this conversion is not 100% equivalent. The fare, for example, isn't
    going to be shown with two digits of precision. There is an explanation later
    for why we are not going to fix this now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is adding the event; in this case we have to do the action when
    the user selects a car:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, we need only do one more step to complete our code. In this
    case it''s the view `didLoad`. Notice that another difference from Objective-C
    and Swift is that in Swift you have to specify that you are overloading an existing
    method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our code is complete, but of course our application is still using the old code.
    To complete this operation, click on the storyboard; if the document outline isn't
    being displayed, click on the **Editor** menu and then on **Show Document Outline**:![How
    to do it…](img/00105.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you can see the document outline, click on **View Controller** that
    appears next to a yellow circle with a square inside:![How to do it…](img/00106.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then on the right-hand side, click on the identity inspector, go to the custom
    class, and change the value of the class from **ViewController** to **MainViewController**:![How
    to do it…](img/00107.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, press play and check that your application is running, select a
    car, and check that it is working. Be sure that it is working with your new Swift
    class by paying attention to the fare value, which in this case isn't shown with
    two digits of precision.![How to do it…](img/00108.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is everything done? I would say no, it's a good time to save your changes. Lastly,
    delete the original Objective-C files, because you won't need them anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, it's not so hard replacing an old view controller with a Swift
    one; the first thing you need to do is create a new view controller class with
    its protocols. Keep the same names you had on your old code for attributes and
    methods that are linked as `IBActions`, it will make the switch very straightforward;
    otherwise you will have to link again.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that you need to be sure that your changes are applied and that
    they are working, but sometimes it is a good idea to have something different,
    otherwise your application can be using the old Objective-C and you didn't realize
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to modernize your code using the Swift way instead of the old Objective-C
    style, for example, nowadays it's preferable to use interpolation rather than
    using `stringWithFormat`.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that you don't need to relink any action or outlet if you keep
    the same name. If you want to change the name of anything you might first keep
    its original name, test your app, and after that you can refactor it following
    the traditional factoring steps.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't delete the original Objective-C files until you are sure that the equivalent
    Swift file is working on every functionality.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This application had only one view controller, however applications usually
    have more than one view controller. In this case, the best way you can update
    them is one by one instead of all of them at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the app delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, there is an object that controls the events of an application,
    which is called application delegate. Usually you shouldn't have much code here,
    but a few of them you might have. For example, you may deactivate the camera or
    the GPS requests when your application goes to the background, and reactivate
    them when the app returns to active.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly it is a good idea to update this file even if you don't have any new
    code on it, so it won't be a problem in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using the version control system, commit your changes from the last
    recipe or, if you prefer, just copy your application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the previous application recipe and create a new Swift file called `ApplicationDelegate.swift`,
    then create a class with the same name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As in our previous class, we don''t have any code on the application delegate,
    so we can differentiate it by printing on the log console. Add this traditional
    application delegate on your Swift file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now go to your project navigator and expand the **Supporting Files** group.
    After that, click on the `main.m` file:![How to do it…](img/00109.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file we are going to import the magic file, the Swift header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that we have to specify that the application delegate is the new class
    we have, so replace the `AppDelegate` class on the `UIApplicationMain` call with
    `ApplicationDelegate`. Your main function should be like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's time to press play and check whether the application is working or not.
    Press the home button, or the combination *shift* + *command* + *H* if you are
    using the simulator, and again open your application. Check that you have some
    messages on your log console:![How to do it…](img/00110.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you are sure that your Swift code is working, remove the original app
    delegate and its importation on the `main.m`. Test your app just in case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could consider that we had finished this part, but actually we still have
    another step to do: removing the `main.m` file. Now, it is very easy: just click
    on the `ApplicationDelegate.swift` file, and before the class declaration, add
    the attribute `@UIApplicationMain`, then right click on the `main.h` and choose
    to delete it. Test it and your application is done.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application delegate class has always been specified at the start of an
    application. In Objective-C, it follows the C start point, which is a function
    called `main`. In iOS, you can specify the class that you want to use as an application
    delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you program for OS X, the procedure is different; you have to go to your
    `nib` file and change its class name to the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Why did we have to change the main function and then eliminate it? The reason
    is that you should avoid massive changes. If something goes wrong you won't know
    the step where you failed, so you will probably have to rollback everything again.
    If you do your migration step by step ensuring that it is still working, it means
    that in case of finding an error, it will be easier to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid making massive changes on your project; changing step by step will be
    easier to solve issues.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned the last steps of how to migrate an app from Objective-C
    to Swift code, however we have to remember that programming is not only about
    applications; you can also have a framework. In the next recipe, we are going
    to learn how to create our own framework compatible with Swift and Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own custom framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, sometimes we have code that is to be shared between applications,
    and the best way to do this is by creating a framework. In this case we are going
    to create a framework that should contain a customized view.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we are going to add only one view. This view will be painted
    with a gradient; this way you can change your application's background easily.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new project called `CustomViewsFramework`. To do it click on **File**
    | **New** | **Project** and then choose the section **Framework and Library**;
    after that choose the option **Cocoa Touch Framework**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Select **Swift** as the project language.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start adding a new file to your project, in this case you can choose from the
    **Source** section, the option **Cocoa Touch Class**:![How to do it…](img/00112.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that you have to write the new class name; let's call it `CVGradientView`.
    Also, make sure that is selected to be a subclass of `UIView` and its language
    is Swift:![How to do it…](img/00113.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the file is created and opened you can remove the comments that come by
    default, then you have to add the attribute `@IBDesignable` before the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to add some attributes; in this case we will use properties with
    an observer that will refresh the gradient view every time a property is changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you noticed, we have to implement the `refresh()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to specify some information about the gradient layer; this information
    is done following the core animation framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need the last part of this method, that is, the initializer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once it is done, we need to identify our module by going to our target build
    settings and searching for the word `module`. Now, change the **Module Identifier**
    to **CustomViewsFrameWork**:![How to do it…](img/00114.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is complete, so generate the project with ** + *b*. Now, we need
    to check that it is working, so let's create another project called `Chapter 8
    Testing Views`. Once it is created, click on the project navigator, then click
    on the target `Chapter 8 Testing Views`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here you have to select the **Build Settings** tab and change the field **Embedded
    Content Contains Swift Code** to **Yes**:![How to do it…](img/00115.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the **General** tab and go to the **Embedded Binaries** section,
    click on the plus button, and when a dialog appears just click on the button with
    the phrase **Add other…**. Here, it is asking for your framework, so go to the
    build product of your framework (it should be inside a folder called `DerivedData/CustomsViewsFramework/Build/Products/Debug-iphonesimulator/`),
    select it (the file called `CustomsViewsFramework.framework`), and press **OK**.
    Check that the linked frameworks sections will also show it:![How to do it…](img/00116.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that your app knows about this framework, you can click on the storyboard,
    then click on the only view you have (not on the view controller), go to the identity
    inspector, and change the **Class** name field to **CVGradientView** and its **Module**
    name to **CustomViewsFramework**:![How to do it…](img/00117.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press play and check that your background has changed. If you want you can
    even change your background programmatically; just click on the view controller
    file and start importing your framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, change, for example, the background colors on the view did load:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press play again and see that your background is different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason we named this project differently than the others is that frameworks
    can't have white spaces in their names. In the case of creating a project with
    white spaces in its name, you have to go to build settings and change the product
    name to something without white spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute `@IBDesignable` lets interface builder know that it should render
    the view directly in the canvas, but remember that this attribute can only be
    used if you are developing a framework; it won't work on traditional applications.
  prefs: []
  type: TYPE_NORMAL
- en: The other attribute (`@IBInspectable`) means that this property can be viewed
    and set by interface builder.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we had to mark our class and some attribute and methods as public.
    The reason is that we want them to be accessed by external modules. If we don't
    do this, it means that only our framework can access this class.
  prefs: []
  type: TYPE_NORMAL
