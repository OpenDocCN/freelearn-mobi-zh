- en: Chapter 2. Mandatory Access Controls and SELinux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 强制访问控制和SELinux
- en: 'In [Chapter 1](ch01.html "Chapter 1. Linux Access Controls"), *Linux Access
    Controls*, we introduced some of the shortcomings of a discretionary access control
    system. In these systems, the owner of an object has full control over its permissions
    flags and can demonstrate greater capabilities (for example, the ability to `chown`)
    when executing as `root` or with certain capabilities. In this chapter, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html "第一章. Linux访问控制")《Linux访问控制》中，我们介绍了基于权限的访问控制系统的不足之处。在这些系统中，对象的所有者对其权限标志拥有完全控制权，并且在以`root`身份或具有某些能力执行时可以展示出更大的能力（例如，`chown`的能力）。在本章中，我们将：
- en: Examine the fundamentals of MAC
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查MAC的基本原理
- en: Introduce some industry drivers for SELinux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些SELinux的行业驱动因素
- en: Discuss labels, users, roles, and types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论标签、用户、角色和类型
- en: Explore the implementation of tangible policy to allow and constrain object
    interaction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索实现具体策略以允许和约束对象交互
- en: Ideal MAC systems maintain the property of providing definitive access controls
    on kernel resources, such as files, irrespective of an object's owner. For instance,
    with a MAC system, the owner of an object might not have full control of its permissions.
    In Linux, the MAC framework works orthogonally to the current DAC controls. This
    means that the MAC controls do not interfere with the DAC controls. In other words,
    to avoid potential conflicts between the MAC and DAC systems, the kernel validates
    access using the DAC permissions before checking the MAC permissions. If the DAC
    permissions result in a permissions violation, then the MAC permissions are never
    checked. The kernel will validate access against the MAC permissions provider
    only when the DAC permissions pass. Failure at either level will result in a return
    of `EACCESS`. If the DAC and the MAC permissions pass, then the kernel resource
    (for example, a file descriptor) is sent back to user space.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的MAC系统保持提供对内核资源（如文件）的明确访问控制属性，无论对象的所有者是谁。例如，在MAC系统中，对象的所有者可能无法完全控制其权限。在Linux中，MAC框架与当前的DAC控制正交工作。这意味着MAC控制不会干扰DAC控制。换句话说，为了避免MAC和DAC系统之间可能发生的冲突，内核在检查MAC权限之前使用DAC权限验证访问。如果DAC权限导致权限违规，则不会检查MAC权限。内核仅在DAC权限通过时才对MAC权限提供者进行访问验证。任何级别的失败都将导致返回`EACCESS`错误。如果DAC和MAC权限都通过，则内核资源（例如，文件描述符）将返回到用户空间。
- en: In Linux, a framework called the **Linux Security Module** (**LSM**) framework
    was merged during the Linux 2.6.x series of kernels. This framework allows you
    to enable the mandatory access control systems in a build time selection by tethering
    the LSM hooks to the security provider. **Security Enhanced Linux** (**SELinux**)
    is the first consumer of this MAC security framework within the kernel and is
    an implementation of a mandatory access control system. SELinux ships in a wide
    variety of Linux systems, such as **Red Hat Enterprise Linux** (**RHEL**) and
    consequently Fedora. Recently, it has begun shipping with Android. The source
    code for SELinux can be found in the Linux source code tree under `kernel/security/selinux`
    for those wishing to review it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，一个名为**Linux安全模块**（**LSM**）的框架在Linux 2.6.x系列内核中进行了合并。这个框架允许你通过将LSM钩子绑定到安全提供者来在构建时选择启用强制访问控制系统。**安全增强型Linux**（**SELinux**）是内核中第一个使用此MAC安全框架的消费者，并且是实现强制访问控制系统的一种实现。SELinux在多种Linux系统中提供，例如**红帽企业Linux**（**RHEL**）以及随后的Fedora。最近，它已经开始与Android一起提供。对于那些希望审查它的人来说，SELinux的源代码可以在Linux源代码树中的`kernel/security/selinux`下找到。
- en: Getting back to the basics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归基本原理
- en: SELinux is a reimplementation of a design engineered by the U.S. government
    and The University of Utah known as the **FLUX Advanced Security Kernel** (**FLASK**).
    The SELinux and FLASK architecture provide a central policy file utilized while
    determining the results of access control decisions. This central policy is in
    a whitelist form. This means that all access control rules must be defined explicitly
    by the policy file. This policy file is abstracted and served by a software component
    called a security server. When the Linux kernel needs to make an access control
    decision and SELinux is enabled, the kernel interacts with the security server
    by means of the LSM hooks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux是美国政府和犹他大学的**FLUX高级安全内核**（**FLASK**）设计的重新实现。SELinux和FLASK架构提供了一个中央策略文件，在确定访问控制决策结果时使用。这个中央策略是白名单形式。这意味着所有访问控制规则都必须由策略文件明确定义。这个策略文件被抽象化，并由一个名为安全服务器的软件组件提供。当Linux内核需要做出访问控制决策并且SELinux被启用时，内核通过LSM钩子与安全服务器交互。
- en: In a running system, a process is the active entity that gets time on the CPU
    to perform tasks. The user merely invokes these processes to do the work on their
    behalf. This is an important concept. As we type this book, we trust that the
    word processors running on our machines with our credentials aren't opening our
    SSH keys and embedding them in the document metadata. Right now, the process is
    in control of the computing resources, not the user. The process is the running
    entity, it is the process that makes system calls to the kernel for resources,
    not the physical human being. With this in mind, the very first actor in this
    SELinux system is the process, typically referred to as the **subject**. It is
    the subject that accesses files. It is the subject that the security server will
    use to make access decisions on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行系统中，进程是获得CPU时间以执行任务的活跃实体。用户只是调用这些进程来代表他们完成工作。这是一个重要的概念。当我们编写这本书时，我们相信运行在我们机器上的带有我们凭据的字处理器不会打开我们的SSH密钥并将它们嵌入到文档元数据中。目前，进程控制着计算资源，而不是用户。进程是运行实体，是进程向内核发出系统调用以获取资源，而不是物理人类。考虑到这一点，SELinux系统中的第一个行为者是进程，通常被称为**主体**。它是访问文件的主体。它是安全服务器将用于做出访问决策的主体。
- en: Consequently, the subject utilizes kernel resources. This kind of kernel resource
    is an example of a **target**. The subject performs actions on the target. Naturally,
    one should ask, "What actions does a subject perform?" These are known as access
    vectors and typically correlate to the name of the syscall performed. For example,
    the subject could perform an `open` on the target. It is important to note that
    targets could be processes as well. For instance, if the system call is `ptrace`,
    the subject could be something along the lines of a debugger, and the target would
    be the process you wish to debug. A subject is frequently a process, but a target
    could be a process, socket, file, or something else.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，主体利用内核资源。这类内核资源是**目标**的一个例子。主体在目标上执行操作。自然地，人们会问：“主体执行什么操作？”这些被称为访问向量，通常与执行的系统调用的名称相关。例如，主体可以在目标上执行`open`操作。需要注意的是，目标也可以是进程。例如，如果系统调用是`ptrace`，主体可能是调试器之类的，而目标是希望调试的进程。主体通常是进程，但目标可以是进程、套接字、文件或其他。
- en: Labels
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签
- en: SELinux provides semantics for describing policies related to the targets and
    subjects using labels. Labels are the metadata associated with an object that
    maintains the subject's and target's access information. The data associated with
    this object is a string. Returning to the debugger example, the `gdb` process
    might have a subject label string of `debugger`, and the target might have a label
    of `debugee`. Then in the security policy, some semantic could be used to express
    that processes with the subject label `debugger` are allowed to debug applications
    with target label `debugee`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux通过标签提供描述与目标和主体相关的策略的语义。标签是与对象关联的元数据，它维护了主体和目标访问信息。与该对象关联的数据是一个字符串。回到调试器示例，`gdb`进程可能有一个主体标签字符串为`debugger`，而目标可能有一个标签为`debugee`。然后在安全策略中，可以使用一些语义来表示具有主体标签`debugger`的进程允许调试具有目标标签`debugee`的应用程序。
- en: 'Fortunately, and perhaps unfortunately, SELinux does not use such simple labels.
    In fact, the labels are made up of four colon-delimited fields: user, role, type,
    and level. This additional complexity affords very flexible control options.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，也许不幸的是，SELinux并不使用如此简单的标签。实际上，标签由四个由冒号分隔的字段组成：用户、角色、类型和级别。这种额外的复杂性提供了非常灵活的控制选项。
- en: Users
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户
- en: The very first field in a label identifies the user. The user field is used
    as part of the design for **user-based access controls** (**UBAC**). However,
    this is not typically associated with human users as it is with the concept of
    users in DAC. SELinux users typically define a group of traditional users. A common
    example is to identify all normal users as the SELinux user, `user_u`. Perhaps
    a separate user for system processes, such as `system_u`. By convention in the
    desktop SELinux community, user portions of the string are suffixed with a `_u`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标签中第一个字段用于标识用户。用户字段被用作**基于用户的访问控制**（**UBAC**）设计的一部分。然而，这通常与人类用户的概念不相关，而是与DAC中的用户概念相关。SELinux用户通常定义一组传统用户。一个常见的例子是将所有普通用户标识为SELinux用户`user_u`。也许为系统进程保留一个单独的用户，例如`system_u`。在桌面SELinux社区中，字符串的用户部分通常以`_u`后缀。
- en: Roles
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The second field in a label is role. The role is used as part of the design
    for **role-based access controls** (**RBAC**). Roles are used to provide additional
    granularity to the user. For instance, suppose we have the user field, `sysadm_u`,
    reserved for administrators. The administrator might be in separate tasks, and
    depending on the tasks, the role (and therefore, privileges) of users in `sysadm_u`
    may change. For example, when an administrator needs to mount and unmount file
    systems, the role field might change to `mount_admin_r`. When an administrator
    is setting the `iptables` rules, the role might change to `net_admin_r`. Roles
    allow the isolation of privileges within the scope of the tasks being performed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 标签中的第二个字段是角色。角色被用作**基于角色的访问控制**（**RBAC**）设计的一部分。角色被用来为用户提供额外的粒度。例如，假设我们有一个用户字段，`sysadm_u`，为管理员保留。管理员可能执行不同的任务，并且根据任务的不同，`sysadm_u`中用户的角色（以及因此的权限）可能会改变。例如，当管理员需要挂载和卸载文件系统时，角色字段可能会变为`mount_admin_r`。当管理员设置`iptables`规则时，角色可能会变为`net_admin_r`。角色允许在执行的任务范围内隔离权限。
- en: Types
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: Type is the third field of the colon-delimited label. The type field is evaluated
    during the **type enforcement** (**TE**) portion of SELinux's access control model.
    TE is the major component that drives SELinux's security capabilities, and it
    is at this point where the policy starts to take effect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是冒号分隔标签的第三个字段。类型字段在SELinux访问控制模型的**类型强制**（**TE**）部分进行评估。TE是驱动SELinux安全能力的最主要组件，并且正是在这一点上，策略开始发挥作用。
- en: SELinux is based on a whitelist system where everything is denied by default
    and requires explicit approval from the policy for an interaction to occur. This
    approval is initially determined from the policy via an allow rule that references
    both the subject's and target's type. SELinux types can also be assigned attributes.
    Attributes allow you to give numerous types a common set of rules. Attributes
    can help minimize the amount of types, and can be used in fashion similar to that
    of an inheritance model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux基于一个白名单系统，默认情况下一切都被拒绝，并且需要策略的明确批准才能发生交互。这种批准最初是通过策略确定的，通过一个允许规则引用了主体和目标的类型。SELinux类型也可以分配属性。属性允许你为许多类型赋予一组共同的规则。属性可以帮助最小化类型的数量，并且可以类似于继承模型的方式使用。
- en: Access vectors
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问向量
- en: Data is accessed by processes via system calls and possible user defined access
    methods. The user defined access methods are usually controlled via a userspace
    object manager. These access paths, also known as vectors, make up a set of actions
    that can be applied to the object. For instance, if a process opens a file, writes
    some data into the file, and then reads it back, the access vectors exercised
    would be `open`, `read`, and `write`. If a process debugs another process, the
    access vector would be `ptrace`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过系统调用和可能的用户定义访问方法被进程访问。用户定义的访问方法通常通过用户空间对象管理器进行控制。这些访问路径，也称为向量，构成了一组可以应用于对象的操作。例如，如果一个进程打开一个文件，向文件中写入一些数据，然后读取它，所执行的访问向量将是`open`、`read`和`write`。如果一个进程调试另一个进程，访问向量将是`ptrace`。
- en: Multilevel security
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多级安全
- en: SELinux also supports a **multilevel security** (**MLS**) model, which pays
    homage to the **Bell-LaPadula** (**BLP**) model, but alternate models could be
    used. The BLP model was created to formalize the Department of Defense's security
    policies. For example, a person with a secret clearance should not be able to
    read top-secret material. However, let's suppose this person has a brilliant idea
    that ultimately needs to be protected at the top-secret level; that data could
    then be "up-classified" to top-secret. This is referred to as "no read up or write
    down".
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux还支持**多级安全**（**MLS**）模型，该模型向**贝尔-拉帕卢拉**（**BLP**）模型致敬，但也可以使用其他模型。BLP模型是为了正式化国防部的安全政策而创建的。例如，一个拥有机密清级的个人不应该能够阅读绝密材料。然而，假设这个人有一个最终需要保护在绝密级别的绝妙想法；那么这些数据就可以被“升级”为绝密。这被称为“不向上读取或向下写入”。
- en: The SELinux implementation of this field has subfields. The first field is sensitivity,
    and will always be present. In the context of the previous example, pertinent
    sensitivities include secret and top secret. The second subfield is category,
    and might not be present. These fields also make sense in the context of government
    classification. The data itself might be compartmentalized, so while the sensitivity
    is the same, such as top secret, the data should only be disseminated to people
    within the same compartment or category. Sensitivities are defined in a hierarchical
    fashion via the dominance keyword. In a typical policy, `s0` is the lowest sensitivity
    and `sN` where `n > 0` is the highest. Thus, `s1` has a greater sensitivity than
    `s0`. Categories are sets. The controls associated with the level, which is comprised
    of sensitivities and potentially categories, follow set theory concepts, such
    as dominance and equality. In MLS security, all interactions are allowed by default,
    unlike type enforcement. Both the sensitivity and the category can be ranged,
    and categories can be enumerated. Thus, a label might have some number of sensitivities
    and different number of categories.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux对这个字段的实现有子字段。第一个字段是敏感性，它始终存在。在先前的例子中，相关的敏感性包括机密和绝密。第二个子字段是类别，可能不存在。这些字段在政府分类的背景下也有意义。数据本身可能被分类，因此虽然敏感性相同，例如绝密，但数据应仅向同一分类或类别内的人员传播。敏感性通过支配关键字以分层方式定义。在典型的策略中，`s0`是最低敏感性，而`n
    > 0`的`sN`是最高。因此，`s1`比`s0`有更高的敏感性。类别是集合。与级别相关的控制，该级别由敏感性和可能存在的类别组成，遵循集合理论概念，如支配和相等。在MLS安全中，所有交互默认允许，与类型强制不同。敏感性和类别都可以有范围，类别可以枚举。因此，一个标签可能有一些敏感性，以及不同数量的类别。
- en: Putting it together
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇总
- en: SELinux labels are quite flexible and sometimes complex. It's often beneficial
    to start with a contrived example that focuses on type enforcement. Later, we
    can add additional fields later as the need for finer granularity becomes more
    apparent. Conveniently, you can project this model to scenarios in everyday life
    to provide some sense of tangibility to the material. Dan Walsh, a prominent SELinux
    figure, posted a blog post using pets as an analogy. Let's continue on with that
    premise, but we will make some modifications as we go and define our own examples.
    It's best to start with simple type enforcement as it is the easiest to understand.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux标签非常灵活，有时也相当复杂。通常从关注类型强制的一个虚构例子开始是有益的。随后，随着对更精细粒度需求的显现，我们可以添加额外的字段。方便的是，你可以将这个模型投影到日常生活中，为材料提供一些可触摸的感觉。丹·沃尔什，一位杰出的SELinux人物，发布了一篇使用宠物作为类比的文章。让我们继续这个前提，但我们在进行中会做一些修改，并定义我们自己的例子。最好从简单的类型强制开始，因为它最容易理解。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read Dan Walsh's original blog post introducing the pet analogy at [http://opensource.com/business/13/11/selinux-policy-guide](http://opensource.com/business/13/11/selinux-policy-guide).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读丹·沃尔什（Dan Walsh）介绍宠物类比的原博文章，链接为[http://opensource.com/business/13/11/selinux-policy-guide](http://opensource.com/business/13/11/selinux-policy-guide)。
- en: 'Suppose we own a cat and a dog. We don''t want the cat to eat dog food. We
    don''t want the dog to eat cat food. At this point, we have already identified
    two subjects, a cat and a dog, and two targets, cat food and dog food. We also
    have identified an access vector, eating. We can use allow rules to implement
    our policy. Possible rules could look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有一只猫和一只狗。我们不希望猫吃狗粮。我们不希望狗吃猫粮。在这个时候，我们已经确定了两个主题，一只猫和一只狗，以及两个目标，猫粮和狗粮。我们还确定了一个访问向量，即吃。我们可以使用允许规则来实施我们的策略。可能的规则可能看起来像这样：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's use this example to start and define a basic syntax for expressing the
    access controls we would like to enforce. The first token is `allow`, stating
    we wish to allow an interaction between a subject and a target. The dog is assigned
    the type, `dog`, and the cat, `cat`. The cat food is assigned the type `cat_chow`,
    and the dog food, `dog_chow`. The access vector in this case is `eat`. With this
    basic syntax, which is also valid SELinux syntax, we restrict the animals to the
    food they should eat. Notice the `:food` annotation after the type. This is the
    class field of the target object. For instance, there might also be `dog_chow`
    `treat` and `cat_chow` classes that could indicate our desire to allow access
    to treats in a fashion that is potentially different from the way we allow access
    to foods that are not treats.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个例子开始，并定义一个基本的语法来表示我们想要实施的访问控制。第一个令牌是`allow`，表示我们希望允许主体和目标之间的交互。狗被分配类型`dog`，猫被分配类型`cat`。猫食被分配类型`cat_chow`，狗食被分配类型`dog_chow`。在这个情况下，访问向量是`eat`。使用这个基本的语法，它也是有效的SELinux语法，我们限制动物只能食用它们应该吃的食物。注意类型后面的`:food`注释。这是目标对象的类字段。例如，也可能有`dog_chow`
    `treat`和`cat_chow`类，这可以表明我们希望以与允许访问非奖励食物不同的方式允许访问奖励。
- en: 'Let''s say we get two more dogs, and our scenario has three dogs. The dogs
    are of different sizes: small, medium, and large. We want to make sure none of
    these new dogs eat others'' food. We could do something like create a new type
    for each of the dogs and prevent dogs from eating the food of other dogs. It would
    look something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们再得到两只狗，我们的场景现在有三只狗。狗的大小不同：小、中、大。我们想要确保这些新来的狗不会吃其他狗的食物。我们可以为每只狗创建一个新的类型，并防止狗吃其他狗的食物。它可能看起来像这样：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This would work; however, the total number of types would be difficult to manage,
    and that would continue to grow if we allow the large dog to eat the smaller breeds''
    food. What we could do is use MLS support to assign a sensitivity to each target
    or dog food bowl. Let''s assume the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效；然而，类型的总数将难以管理，如果我们允许大型狗吃小型犬种的食物，这个数量还会继续增长。我们可以做的是使用MLS支持为每个目标或狗食盆分配一个敏感度。让我们假设以下：
- en: The cat's food bowl has sensitivity, `tiny`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猫的食盆具有敏感度，`tiny`
- en: The small dog's food bowl has sensitivity, `small`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型狗的食盆具有敏感度，`small`
- en: The medium-sized dog's food bowl has sensitivity, `medium`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中型狗的食盆具有敏感度，`medium`
- en: The large dog's food bowl has sensitivity, `large`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型狗的食盆具有敏感度，`large`
- en: 'We also need to make sure that the subjects are labeled with the proper sensitivity
    as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保受试者被正确地标记了敏感度：
- en: The cat should have sensitivity, `tiny`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猫应该具有敏感度，`tiny`
- en: The small dog should have sensitivity, `small`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型狗应该具有敏感度，`small`
- en: The medium-sized dog should have sensitivity, `medium`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中型狗应该具有敏感度，`medium`
- en: The large dog should have sensitivity, `large`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型狗应该具有敏感度，`large`
- en: 'At this point, we need to introduce additional syntax to allow the interactions,
    since by default, MLS allows everything and TE denies everything. We''ll use `mlsconstrain`,
    to restrict interactions within the system. The rule could look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要引入额外的语法来允许交互，因为默认情况下，MLS允许所有操作，TE拒绝所有操作。我们将使用`mlsconstrain`来限制系统内的交互。规则可能看起来像这样：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This constraint only allows subjects to eat food with the same sensitivity level.
    SELinux defines the keywords `l1` and `l2`. The `l1` keyword is the level of the
    target and `l2` is the level of the source. Because the rules are part of a whitelist,
    this also prevents subjects from eating food that does not have the equivalent
    sensitivity level.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制只允许受试者食用具有相同敏感度级别的食物。SELinux定义了关键字`l1`和`l2`。`l1`关键字是目标级别的，`l2`是源级别的。因为规则是白名单的一部分，这也防止了受试者食用不具有等效敏感度级别的食物。
- en: 'Now, let''s say we get yet another large dog. Now we have two large breed dogs.
    However, they have different diets and need to access different foods. We could
    add a new type or modify an existing type, but this would have the same limitations
    that led us to use sensitivities to prevent access. We could add another sensitivity,
    but it might get confusing that there are `large1` and `large2` sensitivities.
    At this point, categories would allow us to get a bit more granular in our controls.
    Suppose we add a category denoting the breed. Our MLS portion of our label would
    look something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们得到了另一只大型狗。现在我们有两只大型品种狗。然而，它们有不同的饮食，需要访问不同的食物。我们可以添加一个新的类型或修改现有的类型，但这会有导致我们使用敏感性来防止访问的相同限制。我们可以添加另一个敏感性，但这可能会因为存在
    `large1` 和 `large2` 敏感性而变得混乱。在这个时候，类别可以让我们在控制上更加细致。假设我们添加一个表示品种的类别。我们的标签中的 MLS
    部分看起来可能像这样：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These could be used to prevent the black lab from eating the golden retriever's
    food. Now suppose you're surprised with another dog, a Saint Bernard. Let's say
    this new Bernard can eat any large dog's food, but the other large dogs can't
    eat his food. We could label the food bowls and the dogs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以用来防止黑拉布拉多狗吃金毛寻回犬的食物。现在假设你遇到了另一只狗，一只圣伯纳德狗。让我们说这只新的伯纳德可以吃任何大型狗的食物，但其他大型狗不能吃他的食物。我们可以标记食物碗和狗。
- en: '| Dog Breed | Subject label | Target label |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 狗品种 | 主题标签 | 目标标签 |'
- en: '| --- | --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Golden Retriever | `Dog:large:golden_retriver` | `dog_chow:large:golden_retriver`
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 金毛寻回犬 | `Dog:large:golden_retriver` | `dog_chow:large:golden_retriver` |'
- en: '| Black Lab | `Dog:large:black_lab` | `dog_chow:large:black_lab` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 黑拉布拉多 | `Dog:large:black_lab` | `dog_chow:large:black_lab` |'
- en: '| Saint Bernard | `Dog:large:saint_bernard, black_lab, golden_retriever` |
    `dog_chow:large:saint_bernard` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 圣伯纳德 | `Dog:large:saint_bernard, black_lab, golden_retriever` | `dog_chow:large:saint_bernard`
    |'
- en: '| Cat | `Cat:tiny` | `cat_chow:tiny` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 猫 | `Cat:tiny` | `cat_chow:tiny` |'
- en: The existing `mlsconstraint` needs modification. If the Saint Bernard ran out
    of food and went to the Black Lab's dish, the Saint Bernard would not be able
    to eat from it since the levels are not equal (`Dog:large:saint_bernard, black_lab,
    golden_retriever` is not the same as `dog_chow:large:black_lab`). Remember, the
    levels are sets, so we need to introduce some notion that if the subjects set
    dominates the target set, that interaction should be allowed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的 `mlsconstraint` 需要修改。如果圣伯纳德狗的食物吃完了，它去了黑拉布拉多狗的盘子，圣伯纳德狗将无法从那里进食，因为级别不相等（`Dog:large:saint_bernard,
    black_lab, golden_retriever` 与 `dog_chow:large:black_lab` 不相同）。记住，级别是集合，因此我们需要引入某种概念，即如果主题集合支配目标集合，那么这种交互应该被允许。
- en: 'This could be accomplished with the `dom` keyword:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过 `dom` 关键字来实现：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The dominate keyword, `dom`, differs from equality, indicating `l1` is a superset
    of `l2` In other words, the levels associated with the target, `l2`, are among
    the potentially larger set of levels associated with the subject, `l1`. At this
    point, we are able to keep all the food separated and used however we see fit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 主导关键字 `dom` 与相等性不同，表示 `l1` 是 `l2` 的超集。换句话说，与目标 `l2` 相关的级别是可能与主题 `l1` 相关的更大集合中的级别。在这个阶段，我们能够将所有食物分开并按需使用。
- en: After getting all these dogs, you realize it's time to feed them, so you get
    a bag of dog food and put some in each bowl. However, before you can add dog food
    to the bowls, we need some allow rules and labels that will let you. Remember,
    SELinux is a whitelist-based system, and everything must be explicitly allowed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在得到所有这些狗之后，你意识到是时候喂它们了，所以你拿了一袋狗粮，并把它放在每个碗里。然而，在你能够向碗中添加狗粮之前，我们需要一些允许规则和标签来允许你这样做。记住，SELinux
    是基于白名单的系统，一切都必须明确允许。
- en: 'We will label the human with the `human` label and define some rules. Oh yeah...
    don''t forget to feed the cat, as well:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用 `human` 标签标记人类，并定义一些规则。哦，对了...别忘了喂猫：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will also need to label `human` with all the sensitivities and categories,
    but this would become cumbersome when we need to add additional dogs, breeds,
    and breed sizes to our system. We could just bypass the constraint if the type
    is `human`. With this approach, we always trust `human` to put the correct food
    in the appropriate bowl:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要用所有敏感性和类别来标记 `human`，但当我们需要向系统中添加额外的狗、品种和品种尺寸时，这会变得繁琐。如果类型是 `human`，我们可以绕过这个约束。采用这种方法，我们始终相信
    `human` 会将正确的食物放入适当的碗中：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the addition of `put` in the access vectors of the MLS constraint. Viola!
    The human can now feed his ever-growing pack of animals.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意MLS约束中访问向量中`put`的增加。哇！现在人类可以喂他不断增长的动物群了。
- en: 'So your birthday rolls around, and you receive an automatic dog feeder as a
    present. You label the food dispenser, `dispenser` and modify the MLS constraints:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你的生日到了，你收到了一个自动喂食器作为礼物。你给食物分配器贴上标签，`dispenser`，并修改MLS约束：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, we see a need to condense the number of types and get organized to prevent
    having to duplicate lines. This is where attributes are quite handy. We can assign
    an attribute to our `human` and `dispenser` types by first defining the attribute:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们看到有必要减少类型数量并组织起来，以防止重复行。这正是属性很有用的地方。我们可以通过首先定义属性来给我们的`human`和`dispenser`类型分配属性：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we can add it to the type:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将其添加到类型中：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This could also be done at type declaration:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在类型声明时完成：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, we could modify the MLS statements to look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以修改MLS语句，使其看起来像这样：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s suppose you hire a maid service. You want to ensure anyone sent
    by the maid service is able to feed your pets. For that matter, let''s let your
    family members feed them, as well. This would be a good use case for the user
    capabilities. We will define the following users: `adults_u`, `kids_u`, and `maid_u`.
    Then we''ll need to add a constraint statement to allow interactions by these
    users:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你雇佣了一个家政服务。你想要确保任何由家政服务派来的人都能喂你的宠物。为了这个目的，让我们也让你的家庭成员来喂它们。这将是一个用户能力的良好用例。我们将定义以下用户：`adults_u`、`kids_u`和`maid_u`。然后我们需要添加一个约束语句来允许这些用户进行交互：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This would prevent the kids from feeding the dogs, but let the maids and adults
    feed them. Now suppose you hire a gardener. You could create yet another user,
    `gardener_u`, or you could collapse the users into a few classes and use roles.
    Let''s suppose we collapse `gardener_u` and `maid_u` into `staff_u`. There is
    no reason the gardener should be feeding the dog, so we could use role-based transitions
    to move the staff between their duties. For instance, suppose staff can perform
    more than one service, that is, the same person might garden and clean. In this
    case, they might take on the role of `gardener_r` or `maid_r`. We could use the
    role capability of SELinux to meet this need:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止孩子们喂狗，但允许女仆和成年人喂它们。现在假设你雇佣了一个园丁。你可以创建另一个用户`gardener_u`，或者你可以将用户合并成几个类别并使用角色。假设我们将`gardener_u`和`maid_u`合并为`staff_u`。园丁没有必要喂狗，因此我们可以使用基于角色的转换在职责之间移动员工。例如，假设员工可以执行多个服务，也就是说，同一个人可能既可能园艺也可能打扫。在这种情况下，他们可能承担`gardener_r`或`maid_r`的角色。我们可以使用SELinux的角色能力来满足这一需求：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Staff may only feed the dogs when they're in the `animal_care_r` role. How to
    get into and back out of that role is really the only component missing. You need
    to have a well-defined system for how the staff can move into the animal care
    role and transition back out. These transitions in SELinux occur either automatically
    via dynamic role transitions or via source code modifications. We'll assume that
    any human entity (gardener, adults, kids) all start in the `human_r` role.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 员工只能在`animal_care_r`角色下喂狗。如何进入和退出该角色实际上是唯一缺少的组件。你需要有一个明确定义的系统，以便员工可以进入动物护理角色并过渡出来。在SELinux中，这些过渡要么通过动态角色转换自动发生，要么通过源代码修改。我们假设任何人类实体（园丁、成年人、孩子）都从`human_r`角色开始。
- en: 'Dynamic role transitions work with a two-part rule, the first part allows the
    transition to occur via an allow rule:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 动态角色转换与两部分规则一起工作，第一部分允许通过允许规则进行转换：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The role transition statements are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 角色转换语句如下：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This would be a good case to attribute the `dog_chow` and `cat_chow` types
    to a new attribute, `animal_chow`, and rewrite the preceding role transitions
    to:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个将`dog_chow`和`cat_chow`类型归入新属性`animal_chow`的好案例，并重写前面的角色转换：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these role transitions, you can only go from the `human_r` role to `animal_care_r`.
    You would need to define transitions to get back as well. It's also important
    to note that you might define other roles. Suppose you define the role `gardener_r`,
    and when someone is in that role, they cannot transition to `animal_care_r`. Suppose
    your justification for this policy is that gardeners might work with chemicals
    unsafe for pets, so they would need to wash their hands before feeding pets. In
    such a situation, they should only be able to transition to `animal_care_r` from
    the `hand_wash_r` role.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些角色转换，你只能从 `human_r` 角色转换到 `animal_care_r` 角色。
- en: Complexities and best practices
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂性和最佳实践
- en: As you can now appreciate, SELinux is complex, and can be thought of as a general
    purpose "meta programming policy language". You're literally programming what
    interactions are allowed to occur in a very complex OS such as Linux, where the
    interactions themselves are often complex. Just like a programming language, you
    can do things with different styles and methods that will yield differing results.
    Perhaps using a `switch()` in that program will make it cleaner and easier to
    understand rather than an `else-if` block, even though functionally you will end
    up with the same thing. SELinux is the same; you can often accomplish things with
    one portion of the enforcement mechanisms that would be more appropriately accomplished
    using an alternate mechanism. In later chapters, we will cover the process of
    labeling the target and subject, one of the more difficult parts of the system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可以理解的那样，SELinux 是复杂的，可以被视为一种通用的“元编程策略语言”。你实际上是在编程，确定在像 Linux 这样非常复杂的操作系统（其中交互本身通常也很复杂）中允许发生哪些交互。就像一种编程语言一样，你可以用不同的风格和方法做事，从而得到不同的结果。也许在程序中使用
    `switch()` 会使其更清晰、更容易理解，而不是使用 `else-if` 块，尽管从功能上讲，你最终会得到相同的结果。SELinux 也是如此；你通常可以使用强制机制的一部分来完成事情，而这部分事情更适合使用另一种机制来完成。在后面的章节中，我们将介绍对目标和主题进行标记的过程，这是系统更困难的部分之一。
- en: When someone authors a program, they often have a set of requirements in place
    that the software should perform. These are the requirements of the software.
    In SELinux, you should do the same thing. You should gather the security requirements
    and understand the threat models you wish to protect yourself from. A well designed
    SELinux policy would meet these goals. A great design would do it in a way that
    is easy to extend. That's ultimately where careful and judicious use of the combination
    of UBAC, RBAC, TE, and MLS will help achieve the requirements and design goals.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人编写程序时，他们通常会有一套要求，即软件应该执行的操作。这些是软件的要求。在 SELinux 中，你应该做同样的事情。你应该收集安全要求并了解你希望保护自己免受其侵害的威胁模型。一个设计良好的
    SELinux 策略将满足这些目标。一个优秀的设计将以易于扩展的方式实现这些目标。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the major working portions of SELinux that include
    type enforcement, multilevel and multicategory security, as well as users and
    roles. Additionally, we saw how to apply these technologies to implement increasingly
    complex access policies to a tangible example. In the next chapter, we will move
    outside of the kernel and discover how Android works in its very unique user space.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 SELinux 的主要工作部分，包括类型强制、多级和多类别安全以及用户和角色。此外，我们还看到了如何将这些技术应用于将越来越复杂的访问策略应用于具体示例。在下一章中，我们将跳出内核，了解
    Android 在其非常独特的用户空间中是如何工作的。
