- en: Chapter 6. Tidying Up and Polishing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 整理与润色
- en: Polishing is the most important thing you'll learn in this entire book. If you
    can master the art of making your game polished, it doesn't matter how simple
    or complex it is; you'll have a great game. And yes, even though you may be a
    great programmer who hasn't had a bug in your program in years, or an artist who
    makes people faint when they see your character designs, you still need to polish
    you game. It's absolutely necessary for any modern game to be a solid experience
    for the player.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 润色是你在整本书中学到最重要的东西。如果你能掌握制作游戏润色的艺术，那么它无论简单还是复杂，你都会有一个很棒的游戏。而且，即使你可能是一个多年没有程序错误的优秀程序员，或者是一个当人们看到你的角色设计时会晕倒的艺术家，你仍然需要润色你的游戏。这对于任何现代游戏来说，让玩家有一个坚实的体验是绝对必要的。
- en: 'In this chapter, you''ll learn what it takes to clean up the game, smooth out
    the rough edges, and turn that game with cool mechanics into a fun, playable,
    and unforgettable experience. But it''s not just about making it look good. It
    needs to feel good, and the entire user experience needs to be joyful. In no particular
    order, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解清理游戏、平滑粗糙边缘，并将具有酷炫机制的游戏变成有趣、可玩且难忘体验所需的一切。但这不仅仅是让它看起来好。它需要感觉好，整个用户体验都需要是愉快的。不分先后，我们将涵盖以下内容：
- en: Button press visual
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮按下视觉效果
- en: Pulse on unit combine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位组合脉冲
- en: A tutorial
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个教程
- en: Sharing over Facebook and Twitter (and more)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Facebook 和 Twitter（以及更多）上分享
- en: Sound on/off
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音开/关
- en: Game Center leaderboards
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中心排行榜
- en: Slide transitions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动过渡
- en: Obviously, you don't have to do all of these, but if you want more people to
    play your game, chances are that they're more likely to play it if it's polished.
    Now, the biggest thing when it comes to polishing is the graphical and sound styles.
    They need to be consistent throughout, as well as visually appealing so that the
    user doesn't get confused or put off when they play your game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不必做所有这些，但如果你想让更多人玩你的游戏，他们更有可能玩它，如果它经过了打磨。现在，润色时最重要的事情是图形和声音风格。它们需要保持一致，同时也要视觉上吸引人，这样用户在玩游戏时就不会感到困惑或被吓到。
- en: That being said, if you open the `Chapter 6` project, you'll see that the game's
    graphics and fonts have been updated. It looks and feels pretty solid. The only
    thing left to do is what's being covered in this chapter (as you just saw in the
    list). So let's get to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你打开 `第六章` 项目，你会看到游戏的图形和字体已经更新。看起来和感觉都很扎实。唯一剩下要做的就是本章所涵盖的内容（正如你刚才在列表中看到的）。那么，让我们开始吧。
- en: Button press visuals
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮按下视觉效果
- en: Yeah, button press visuals are great! Cocos2d is nice enough to provide a darkening
    of the button when we touch it, but let's add a bit more animation to our buttons
    to give them more of that "clicked" feeling.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，按钮按下视觉效果很棒！Cocos2d 足够好，当触摸按钮时，它会提供按钮的暗化效果，但让我们给我们的按钮添加更多动画，让它们有更多的“点击”感觉。
- en: Modifying the CCButton class
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 CCButton 类
- en: If we just wanted an individual button to have a specific effect, we would modify
    just that single button in the place where it exists. However, we want the same
    button effect across all buttons in our game, so we need to open `CCButton.m`
    file. The easiest way to do that is to search for `CCButton` in the project and
    click on any of the links to `CCButton.m`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想让单个按钮具有特定的效果，我们只需修改它存在的位置上的那个按钮。然而，我们希望游戏中的所有按钮都有相同的效果，因此我们需要打开 `CCButton.m`
    文件。最简单的方法是在项目中搜索 `CCButton` 并点击任何指向 `CCButton.m` 的链接。
- en: 'Here, you''re going to add two functions near the top of the file: `scaleButtonUp`
    and `scaleButtonDown`. Both of them run actions on the button, and these actions
    give it a bouncy press effect found in many games:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将在文件顶部附近添加两个函数：`scaleButtonUp` 和 `scaleButtonDown`。这两个函数都在按钮上运行动作，这些动作给按钮带来了许多游戏中常见的弹跳按下效果：
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Alternatively, you can extend/subclass `CCButton` and override the methods necessary
    to create the desired effect. This method is also slightly more stable in the
    case of a Cocos2d version update that changes the default code of `CCButton`.
    But for now, we'll just modify the existing `CCButton` code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以扩展/继承 `CCButton` 并重写创建所需效果所需的方法。这种方法在 Cocos2d 版本更新更改 `CCButton` 默认代码的情况下也稍微更稳定。但就目前而言，我们只需修改现有的
    `CCButton` 代码。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then at the bottom of the `touchEntered` method, add the call to the `scaleButtonDown`
    method like so:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `touchEntered` 方法的底部添加对 `scaleButtonDown` 方法的调用，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, in `touchExited` and `touchUpInside`, you have to add the call to
    the `scaleButtonUp` methods. This is meant for the following cases: either when
    the players, finger leaves the button (indicating that it won''t be activated
    if they lift their finger), or when they actually "press" the button:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`touchExited`和`touchUpInside`中，你必须添加对`scaleButtonUp`方法的调用。这是针对以下情况：要么当玩家的手指离开按钮（表示如果他们抬起手指，它就不会被激活），要么当他们实际上“按下”按钮时：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And that's it! It took a whole 2 minutes to add that extra bit of polishing
    to our buttons. It's not something that's going to sell the game on its own, but
    it's subtle enough to give your players a feeling like, "Wow, the developers really
    took the time to make this game right!"
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！给我们的按钮添加那一点额外的抛光只花了整整2分钟。这并不是什么能单独卖出游戏的东西，但它足够微妙，能让玩家感觉到：“哇，开发者们真的花了时间来制作这个游戏！”
- en: Pulse on unit combine
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单位组合时的脉冲
- en: When our units combine, nothing special really happens. So, what we're going
    to do is add a slight pulse effect. Basically, when two units combine we want
    the unit to grow in a fashion similar to the button visual we just created (where
    it expands and then scales down again).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的单位组合时，实际上并没有发生什么特别的事情。所以，我们要做的是添加一个轻微的脉冲效果。基本上，当两个单位组合时，我们希望单位以类似于我们刚刚创建的按钮视觉（它扩张然后再次缩小）的方式增长。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also do fancy things in general when the units spawn, such as particle
    effects (for example, a subtle explosion/burst effect), sprite animations, and
    other various things.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当单位生成时，你还可以做一些花哨的事情，比如粒子效果（例如，微妙的爆炸/爆发效果）、精灵动画和其他各种事情。
- en: The key to polishing is thinking out of the box, yet looking at things you already
    have within the game to keep the aesthetic consistent and solid.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 精炼的关键是跳出思维定式，同时观察游戏中已有的东西，以保持美学的一致性和稳固性。
- en: 'To carry out the pulsing we desire, since we''ll most likely be placing the
    same code in multiple places, let''s create a method that takes in a `CCNode`
    object and applies the effect we have in mind. So in `MainScene.m`, add the following
    method somewhere in the code (preferably near the combination code):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行我们想要的脉冲效果，因为我们很可能会在多个地方放置相同的代码，让我们创建一个接受`CCNode`对象并应用我们心中所想效果的函数。所以，在`MainScene.m`中，在代码的某个地方（最好是组合代码附近）添加以下方法：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function takes into consideration the "original scale" of the unit, and
    then runs a two-action sequence of scaling up and then down. However, we want
    to make sure we stop all the current actions on the unit in the case of there
    being more than two units that combine (and we will subsequently call this function
    multiple times on the same unit).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数考虑了单位的“原始缩放”，然后运行一个向上和向下缩放的二步序列。然而，我们想确保如果有超过两个单位组合（我们将在同一单位上多次调用此函数），我们停止单位上所有当前的动作。
- en: Now that we have a function ready, let's add the calls to it in the four places
    where a unit is combined.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个函数准备好了，让我们在四个单位组合的地方添加对这个函数的调用。
- en: 'The first two places are in the `checkForCombineWithUnit` method (again, if
    you aren''t using the `Chapter 6` code here, this method isn''t implemented):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个地方在`checkForCombineWithUnit`方法中（如果你在这里没有使用“第6章”的代码，这个方法就没有实现）：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last two places are in the `checkForAnyDirectionCombine` method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`checkForAnyDirectionCombine`方法的最后两个地方：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And that's it! Run the game and combine two units, and you'll see the pulsing
    effect. Again, it's subtle, but that's exactly what we need—many subtle changes
    that add up to a lot over time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！运行游戏并组合两个单位，你就会看到脉冲效果。同样，这也是微妙的，这正是我们所需要的——许多微妙的变化随着时间的积累会变得很多。
- en: Tutorial
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南
- en: We're at the point where we need to teach our players how to play our game.
    Although you might have been able to explain the game to your testers when you
    were standing over their shoulders, you won't be able to do that for those who
    download the app from the App Store. Thus, we're in need of a tutorial, and a
    quick one because we want our players playing the game, not the tutorial.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了需要教玩家如何玩我们的游戏的时候了。虽然你可能能够在你站在测试者的肩膀上时向他们解释游戏，但你无法为从App Store下载应用的人做同样的事情。因此，我们需要一个指南，而且要快，因为我们希望玩家玩游戏，而不是玩指南。
- en: 'For this project, we''re going to have a simple tutorial that basically explains
    the main concepts of the game through only a few words and some images:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将有一个简单的指南，基本上通过几个词和一些图片来解释游戏的主要概念：
- en: Players sliding units with their fingers
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家用手指滑动单位
- en: Combining their own units
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合他们自己的单位
- en: Defeating enemy units
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 击败敌人单位
- en: Protecting the central square
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护中心广场
- en: Obviously, we are able to go a lot more in depth by explaining a few more of
    the subtle concepts, but instead, we're giving the player room to learn, experiment,
    and test things for themselves. We just want the tutorial to set them up so that
    they don't get frustrated when they either don't know what to do when the game
    starts, or lose and don't know why they lost.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以通过解释更多细微的概念来深入探讨，但相反，我们给玩家留出空间去学习、实验和亲自测试。我们只想让教程为他们做好准备，这样他们在游戏开始时不知道该做什么，或者输了却不知道为什么输时不会感到沮丧。
- en: Tutorial phase variable and the NSUserDefaults key
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 教程阶段变量和 NSUserDefaults 键
- en: We want to know at what point in the tutorial our user is. So, we need to know
    what set of text and options to display. For example, if we create a tutorial
    that uses multiple scenes, we wouldn't have needed a variable, as the scene would
    have indicated which tutorial we were on. However, because we're doing everything
    within the `MainScene` (and because we want to smoothly transition into a regular
    game after the tutorial is over), it's best to use a variable to track how far
    we've gone.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道用户在教程中的哪个阶段。因此，我们需要知道要显示哪些文本和选项。例如，如果我们创建了一个使用多个场景的教程，我们就不需要变量，因为场景会指示我们正在进行哪个教程。然而，因为我们是在
    `MainScene` 中完成所有这些（并且因为我们希望在教程结束后能够平滑地过渡到常规游戏），最好使用一个变量来跟踪我们已经走了多远。
- en: 'So (since we''ll want to access the variable in a later portion), let''s create
    an `@property` variable in `MainScene.h`, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此（因为我们将在后面的部分中需要访问这个变量），让我们在 `MainScene.h` 中创建一个 `@property` 变量，如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If it''s a good tutorial, the user learns the first time they''re going through
    it, so it''s a good assumption to set a "did they finish it?" variable to true
    after they''ve gone through all the steps. This means that we want to record in
    a variable whether or not they''ve finished the tutorial before, so we''re going
    to use `NSUserDefaults` again. Let''s define another key so that we can eliminate
    human errors as well as increase code readability. In `MainScene.h`, declare the
    following key with the rest at the top of the file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个好的教程，用户在第一次通过时就能学会，所以我们可以假设在完成所有步骤后，将“他们是否完成？”变量设置为 true。这意味着我们想在变量中记录他们之前是否完成了教程，所以我们将再次使用
    `NSUserDefaults`。让我们定义另一个键，这样我们就可以消除人为错误并提高代码的可读性。在 `MainScene.h` 文件中，在文件顶部声明以下键：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `MainScene.m`, define the key at the top, with something like the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainScene.m` 文件中，定义关键变量在顶部，可以像以下这样：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, we want to determine whether or not to show the tutorial. Since we
    have this key storing the determining factor, we can simply read that from `NSUserDefaults`
    and either run the game as normal or begin the tutorial in phase 1.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想确定是否显示教程。因为我们有一个存储决定因素的键，我们可以简单地从 `NSUserDefaults` 中读取它，然后以正常方式运行游戏或从阶段
    1 开始教程。
- en: 'So in `MainScene.m`, at the bottom of your `init` method, modify the `spawnNewEnemy`
    call to the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `MainScene.m` 文件的 `init` 方法底部，修改 `spawnNewEnemy` 调用为以下内容：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, to eliminate errors and set ourselves up for easier coding later, we
    define the `showTutorialInstructions` object (the empty body is okay for now;
    we''ll cover that next):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了消除错误并为我们之后的编码工作打下基础，我们定义了 `showTutorialInstructions` 对象（现在空体是完全可以接受的；我们将在下一节中介绍它）：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding if-else statement, you see the tutorialPhase being set to either
    0 (not going through the tutorial this time) or 1 (begin the tutorial at phase
    1), based on whether they've finished the tutorial or not. If they haven't, it
    will also spawn a new enemy at the far right with a value of 1.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 if-else 语句中，你可以看到 tutorialPhase 被设置为 0（这次不进行教程）或 1（从阶段 1 开始教程），这取决于他们是否完成了教程。如果没有完成，它还会在最右边生成一个值为
    1 的新敌人。
- en: That's the beginning of our tutorial—setting up the necessary structure. Next,
    we're going to tackle actually displaying some text, depending on what phase of
    the tutorial we're in.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们教程的开始——设置必要的结构。接下来，我们将处理根据教程所处的阶段实际显示文本。
- en: Displaying text for each phase (and CCSprite9Slice)
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示每个阶段的文本（以及 CCSprite9Slice）
- en: 'Each tutorial phase needs to have its own text. To do that, we''ll just reference
    the tutorial phase variable and assign the text to a label based on what phase
    we''re in. That said, in the `showTutorialInstructions` method that we just created,
    we add the following lines to display our initial phase 1 text:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个教程阶段都需要有自己的文本。为此，我们将仅参考教程阶段变量并将文本分配给标签，根据我们所在的阶段。也就是说，在刚刚创建的 `showTutorialInstructions`
    方法中，我们添加以下行来显示初始阶段1的文本：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the project. You'll see the text spanning across the top center of the grid.
    But code-wise, there's a lot going on in the block we just added, so let's quickly
    go over the new stuff.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你会看到文本横跨网格的顶部中央。但从代码角度来看，我们刚才添加的块中有很多内容，所以让我们快速浏览一下新内容。
- en: First, we're naming (a tag property in previous versions, but it's now a string)
    the label so that we can access the `CCNode` by searching for it later using the
    `getChildByName` function. Next, we're positioning the label at `z:2`, so we're
    ensuring that it's above everything else (the default is `z:0`, and at most, we
    have our units at `z:1`, so `z:2`, should be good).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们给标签命名（在之前的版本中是一个标签属性，但现在是一个字符串），这样我们就可以通过 `getChildByName` 函数在以后搜索它来访问
    `CCNode`。接下来，我们将标签定位在 `z:2`，这样我们就确保它位于其他所有内容之上（默认是 `z:0`，最多我们有我们的单位在 `z:1`，所以
    `z:2` 应该是合适的）。
- en: 'There''s also the `CCSprite9Slice` object, which is most likely new to you.
    If you''ve never heard of a 9-slice (or 9-patch) sprite before, refer to the following
    diagram to learn about it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为 `CCSprite9Slice` 的对象，这对你来说可能很陌生。如果你之前从未听说过9切片（或9拼图）精灵，请参考以下图表来了解它：
- en: '![Displaying text for each phase (and CCSprite9Slice)](img/image00266.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![显示每个阶段的文本（以及 CCSprite9Slice）](img/image00266.jpeg)'
- en: In short, the central section can scale in any direction, the corners do not
    scale, the top and bottom margins scale horizontally, and the left and right margins
    scale vertically.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，中心部分可以在任何方向上缩放，角落不缩放，顶部和底部边距水平缩放，左侧和右侧边距垂直缩放。
- en: You'll require the 9-slice sprite only when you want the margins to scale. In
    any other situation, it's better to use a regular `CCSprite`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要边距缩放时，才需要9切片精灵。在其他任何情况下，最好使用常规的 `CCSprite`。
- en: Since we want to keep our art style consistent, we can use `Unit.pn`g as our
    9-slice sprite, along with a 20 percent margin (the rest is whitespace anyways,
    so this is a good number to go with). Then we'll position it behind the label
    (using `z:-1`) and set the content size to slightly larger than the width and
    height of the label.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望保持我们的艺术风格一致，我们可以使用 `Unit.pn`g 作为我们的9切片精灵，并附带20%的边距（其余部分是空白，所以这是一个很好的数字）。然后我们将它定位在标签后面（使用
    `z:-1`）并将内容大小设置为略大于标签的宽度和高度。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using `CCSprite9Slice`, if you want to change the `scale` of the button,
    you must change its `contentSize` value, *not* the scale property.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `CCSprite9Slice` 时，如果你想改变按钮的 `scale`，你必须改变它的 `contentSize` 值，而不是缩放属性。
- en: Also, the margin value (or values) can only go up to a maximum of 0.5 (which
    means 50 percent of the image in any direction).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，边距值（或值）只能达到最大值0.5（这意味着在任何方向上的图像的50%）。
- en: Now we're actually going to take the tutorial to the next phase.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将教程推进到下一个阶段。
- en: Advancing the tutorial
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推进教程
- en: 'Just the fact that we have text displayed doesn''t mean we have something impressive,
    as it''s not really a tutorial up to this point. We need to implement the advanced
    portion. So, create a function called `advanceTutorial` as well as `removePreviousTutorialPhase`
    (which will be used to get rid of the previous phases'' text) and edit them like
    this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仅显示文本并不意味着我们有令人印象深刻的内容，因为到目前为止这并不是真正的教程。我们需要实现高级部分。因此，创建一个名为 `advanceTutorial`
    的函数以及 `removePreviousTutorialPhase`（将用于删除前一个阶段的文本）并按照以下方式编辑它们：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Essentially, we're saying that if we advance to the next tutorial phase, and
    the phase is less than 7, we just show the next tutorial's instructions. Otherwise,
    we simply set the `didFinishTutorial` Boolean to `true`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们是在说，如果我们推进到下一个教程阶段，并且阶段小于7，我们就显示下一个教程的说明。否则，我们只需将 `didFinishTutorial`
    布尔值设置为 `true`。
- en: 'Finally, we should include the proper text for each phase so that when we start
    advancing the tutorial phase, we can actually see the progress. So, in the `showTutorialInstructions`
    function, modify the `if` statement to look like the following (which also creates
    and displays a **How to Play** label for the first phase):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该为每个阶段包含适当的文本，这样当我们开始推进教程阶段时，我们实际上可以看到进度。所以，在`showTutorialInstructions`函数中，修改`if`语句，使其看起来像以下（它还为第一阶段创建并显示了一个**如何玩**标签）：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the preceding code can also be written in the form of switch-case
    statements.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码也可以写成switch-case语句的形式。
- en: So that's it! Let's actually take our tutorial ahead so that we can see our
    progress in action as we walk through each phase.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了！让我们实际上推进我们的教程，这样我们可以在走过每个阶段时看到我们的进展。
- en: Advancing in all the right places
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在所有正确的地方推进
- en: Since we have all the functions laid out, all we need to do is call the `advanceTutorial`
    function when we want the next phase to begin.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经安排好了所有函数，我们只需要在我们想要开始下一阶段时调用`advanceTutorial`函数。
- en: 'The first phase will advance once we''ve moved the unit for the first time,
    so in the `moveUnit` function, add the following to the bottom:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段将在我们第一次移动单位后推进，所以在`moveUnit`函数中，请在底部添加以下内容：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And hey! While we're at it, we might as well include phase 2, right? After all,
    we're just sliding once in both phases.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！既然我们已经在做了，为什么不包括第二阶段呢？毕竟，我们只是在两个阶段都滑动了一次。
- en: 'Phase 3 will end when the enemy coming in from the right is destroyed, so in
    the `handleCollisionWithFriendly` function, you need to add the following method
    call within the if statement shown here. Phase 4 will also end when a unit gets
    destroyed, so we''ll go ahead and include it as well:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段将在从右边进来的敌人被摧毁时结束，所以在`handleCollisionWithFriendly`函数中，你需要在下面的if语句中添加以下方法调用。第四阶段也将随着一个单位的摧毁而结束，所以我们将包括它：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next is going to be when tutorial phase 5 ends, which is after the user wants
    to make their move but before any unit movements have been calculated. The same
    applies to phase 6, so add the following call to the `advanceTutorial` function
    at the top of the `moveUnit` function. This is because we don''t want to accidentally
    advance the tutorial twice (which is what would happen if we add it at the bottom):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是当教程阶段5结束时，这发生在用户想要移动但任何单位移动尚未计算之前。对阶段6也是如此，所以请在`moveUnit`函数的顶部添加以下调用：这是因为我们不希望意外地推进教程两次（如果我们将其添加到底部就会发生这种情况）：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But hold on for a second! We want to ensure the same experience for every person
    in the tutorial. So, just like the way we created a custom unit at the beginning
    of the scene in the `init` method, we''re going to create a custom unit in the
    `moveUnit` function. In your `moveUnit` function, modify this `if` statement to
    create a custom unit when you''re in the corresponding tutorial phase:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！我们想要确保教程中每个人的体验都是一样的。所以，就像我们在`init`方法中在场景开始时创建自定义单位一样，我们将在`moveUnit`函数中创建一个自定义单位。在你的`moveUnit`函数中，修改这个`if`语句，在相应的教程阶段创建一个自定义单位：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Alright! With this in place, we should have a pretty solid tutorial, but it's
    still kind of clunky, and we can definitely use some polish (coincidentally, that's
    the chapter we're in). So, let's continue to make it the best tutorial that it
    can be.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！有了这个，我们应该有一个相当扎实的教程，但它仍然有点笨拙，我们肯定可以用一些润色（巧合的是，我们就在这一章）。所以，让我们继续让它成为最好的教程。
- en: Removing the previous phases' text
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除之前阶段的文本
- en: 'Right now, the old text is just piling up, so let''s clear that up. In the
    `removePreviousTutorialPhase` function, add the following block. It will grab
    the text, rename it (so that there are no naming conflicts by accident), quickly
    fade out the text, and remove it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，旧文本只是堆积起来，让我们清理一下。在`removePreviousTutorialPhase`函数中，添加以下代码块。它将获取文本，重命名它（这样就不会意外地发生命名冲突），快速淡出文本，并移除它：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There we go! But it still needs more polish. Let's add some graphical elements
    to our tutorial to better explain what we want the user to do.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！但仍然需要更多润色。让我们添加一些图形元素到我们的教程中，以便更好地解释我们希望用户做什么。
- en: Fingers pointing the way
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指示方向的指针
- en: Text is great, but what about those who can't read English? Or what about those
    who don't understand what we mean by **Drag Friendly Units**? It's best to have
    an image to show what we mean. In this case, we're going to use a small hand with
    the index finger pointing to show a drag motion in the intended direction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 文字很好，但对于那些不能阅读英语的人来说呢？或者对于那些不理解我们所说的**拖动友好单位**的人来说呢？最好有一个图像来展示我们的意思。在这种情况下，我们将使用一个小手，用食指指向，以展示预期的拖动动作。
- en: 'Here''s what we''re going to add. Notice the finger (which is being moved to
    the right and fading at the same time), as well as the text above it, which we
    added in the previous section, as shown in this screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要添加的内容。注意手指（正在向右移动并同时淡出），以及在上一个部分中添加的文本，如截图所示：
- en: '![Fingers pointing the way](img/image00267.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![手指指引方向](img/image00267.jpeg)'
- en: 'In our `showTutorialInstructions` method, we want to create a finger that will
    guide the user in the right direction. So, at the bottom of your `showTutorialInstructions`
    method, add the following block of code to create a finger and position it so
    that it points to the center of the middle square:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `showTutorialInstructions` 方法中，我们想要创建一个手指，引导用户走向正确的方向。因此，在你的 `showTutorialInstructions`
    方法的底部，添加以下代码块来创建一个手指并将其定位到中间正方形的中心：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how we've named the finger and positioned it at `z:2` (for consistency
    with the rest of our tutorial).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何命名手指并将其定位在 `z:2`（为了与我们的教程保持一致）。
- en: 'The next step is to animate our finger in the direction in which we want our
    users to slide their units. So, right after you''ve added the finger to the scene,
    make a call to the following function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是让我们的手指以我们希望用户滑动单位的方向进行动画处理。因此，在你已经将手指添加到场景之后，调用以下函数：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we just passed the finger variable directly to the function (as searching
    for a child with a matching name takes up more processing time). Now, all we need
    to do with our finger image is the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是直接将手指变量传递给函数（因为搜索具有匹配名称的子项会占用更多处理时间）。现在，我们只需要对我们手指的图像做以下操作：
- en: Fade the finger in
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 淡入手指
- en: Slide it to the right
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向右滑动
- en: Fade it out while it is sliding to the right
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在它向右滑动时逐渐淡出
- en: Wait a bit
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍等片刻
- en: Reposition the finger
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新定位手指
- en: Repeat
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复
- en: 'This seems fairly simple, right? It is, except when we want to sequence all
    of these events. In that case, the code looks fairly convoluted. This is what
    we want the function to look like:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当简单，对吧？是的，除了当我们想要按顺序排列所有这些事件时。在这种情况下，代码看起来相当复杂。这是我们希望函数看起来像这样的：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Essentially, the finger is going to fade in, slide to the right (while it's
    fading out), then get repositioned, and repeat these actions indefinitely in phase
    1 and phase 3 of the tutorial (the opposite direction for phase 2).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，手指将淡入，向右滑动（同时淡出），然后重新定位，并在教程的第一阶段和第三阶段（第二阶段相反方向）无限期地重复这些动作。
- en: Sadly, we're not done with coding for the entirety of the finger. We must still
    remove it once we wish to advance to the next phase, remember?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我们还没有完成手指的编码。当我们想要进入下一阶段时，我们必须移除它，记得吗？
- en: 'Therefore, in `removePreviousTutorialPhase`, we''re just going to add a very
    similar removal style to the label, the only difference being that we''ll apply
    it to the finger (and this time, we need to use the search function of `getChildByName`,
    as this function gets called at an undetermined time):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `removePreviousTutorialPhase` 方法中，我们只是给标签添加一个非常相似的移除样式，唯一的区别是，我们将将其应用于手指（这次，我们需要使用
    `getChildByName` 的搜索功能，因为这个函数在不确定的时间被调用）：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And that's it for the finger! We've got ourselves a finger sliding in the direction
    we want, including a nice fade in/out. We also have the text displaying and getting
    removed, advancing text, and so on. The only thing left to do is to make sure
    our users are allowed to move their units only in the direction we want them to.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些关于手指的内容！我们已经得到了一个按照我们想要的方向滑动的手指，包括漂亮的淡入淡出效果。我们还有文本显示和移除，文本前进等等。唯一剩下要做的就是确保我们的用户只能按照我们想要的方向移动他们的单位。
- en: Rejecting non-tutorial movement
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拒绝非教程移动
- en: Our tutorial works as intended only when they move in a specific order. So,
    we need to restrict their initial movements when going through the tutorial.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当他们在特定的顺序中移动时，我们的教程才能按预期工作。因此，我们需要在通过教程时限制他们的初始移动。
- en: 'In `Unit.m`, in the `touchMoved` function, we want to make sure that the unit
    can only begin to be dragged when they''re going in the correct direction in the
    first three phases. So add the following if statement to the `touchMoved` function
    (when the distance is less than `20`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Unit.m`中，在`touchMoved`函数中，我们想要确保单位只有在第一阶段三个阶段中朝正确方向移动时才能开始被拖动。因此，向`touchMoved`函数中添加以下if语句（当距离小于`20`时）：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is why we created the `tutorialPhase` object as a property—so that we can
    access the phase from within another class. But what's going on here is essentially
    a check of the tutorial phase, and if it's any one of phase 1, 2, or 3, it does
    another check to see whether `dragDirection` is indicating the correct way. There's
    a second check that's done for phase 2, as it's not allowed to be the unit with
    a value of 1.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们创建了一个`tutorialPhase`对象作为属性——这样我们就可以从另一个类中访问阶段。但这里发生的事情本质上是对教程阶段的检查，如果它是第一阶段、第二阶段或第三阶段中的任何一个，它将进行另一个检查以查看`dragDirection`是否指示正确的方向。对于第二阶段还有一个额外的检查，因为它不允许单位值为1。
- en: If any of this comes out to true, we set `isBeingDragged` to `NO` and the drag
    direction to standing (so that no unexpected behavior happens in phase 2).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些情况中的任何一个是真的，我们将`isBeingDragged`设置为`NO`，并将拖动方向设置为站立（这样在第二阶段就不会发生意外的行为）。
- en: That's it for the tutorial! It took a while, but it's not only simple and quick;
    it's also fairly comprehensive, while not affecting the experience of the game.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 教程到此结束！虽然花了一些时间，但它不仅简单快捷，而且相当全面，同时不影响游戏体验。
- en: 'Then, once our tutorial ends, it seamlessly flows into a regular game from
    that point. The other advantage is as follows: suppose players lose, don''t finish,
    or hit menu or restart; or the phone dies at some point during the tutorial. When
    they come back, the tutorial will simply start from the beginning, which is good
    and intentional.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦我们的教程结束，它将从那个点无缝地过渡到常规游戏。另一个优点是：假设玩家输了，没有完成，或者点击了菜单或重新开始；或者手机在教程期间某个时刻没电了。当他们回来时，教程将简单地从开始处重新开始，这是好的，也是故意的。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The key takeaway from the tutorial is to keep it short, save when they've completed
    it, and test all possible "dumb" ways a user could try to mess up the tutorial
    (hence the last part, about rejecting wrong movements).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从教程中得到的要点是要保持简短，在他们完成时保存，并测试所有可能的“愚蠢”方式，用户可能会尝试搞砸教程（因此有关于拒绝错误动作的最后一部分）。
- en: Sharing on Facebook and Twitter (and more)
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Facebook和Twitter（以及更多）上分享
- en: Sharing games on social media is very common these days. Our game will not be
    an exception to that. It's not only an effective marketing tool for your game,
    as users promote the game for you on their social media pages, but also a great
    way for engagement to rise, as humans love competition. Being able to share and
    compare their scores (and indirectly compete) makes users want to play the game
    even more, which makes it a win-win situation for both the developers and players.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交媒体上分享游戏现在非常普遍。我们的游戏不会是那个例外。这不仅是你游戏的营销工具，因为用户会在他们的社交媒体页面上为你推广游戏，而且也是一个提升参与度的好方法，因为人类喜欢竞争。能够分享和比较他们的分数（以及间接竞争）让用户更想玩游戏，这对开发者和玩家来说都是双赢的局面。
- en: Using the built-in share feature
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置的分享功能
- en: The easiest way to integrate Facebook, Twitter, messaging, e-mail, and other
    sharing options is through the `UIActivityView` object. It's the same sharing
    you'll see when you press the button in the bottom-left corner of the photos app.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要整合Facebook、Twitter、消息、电子邮件和其他分享选项，最简单的方法是通过`UIActivityView`对象。它就是你在照片应用左下角按钮按下时看到的相同分享方式。
- en: Basically, all we need to do is tell the `ActivityView` object what we want
    to display and what activity types we want to exclude, and then present the view
    controller over the `CCDelegate`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只需要告诉`ActivityView`对象我们想要显示什么，以及我们想要排除哪些活动类型，然后通过`CCDelegate`呈现视图控制器。
- en: First, we need to create the **Share** button.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个**分享**按钮。
- en: Creating the Share button
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建分享按钮
- en: 'In `GameOverScene.m`, add the following block of code to the `initWithScoreData`
    method. This will create a **Share** button at the bottom center of our game over
    screen:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameOverScene.m`中，将以下代码块添加到`initWithScoreData`方法中。这将在我们游戏结束屏幕的底部中央创建一个**分享**按钮：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, create the method that the share button will call when it is pressed
    (this must be added now, or else the game will crash when you reach `GameOverScene`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建当分享按钮被按下时将调用的方法（现在必须添加，否则当达到`GameOverScene`时游戏会崩溃）：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the game, and when you get to the game over screen, you'll see the share
    button in the bottom center. Right now, it doesn't do anything, so let's display
    the activity view.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，当你到达游戏结束屏幕时，你会在底部中央看到分享按钮。目前，它没有任何作用，所以让我们显示活动视图。
- en: Creating a variable for the current score
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用于当前分数的变量
- en: We need a way to track the player's current score and the score of the most
    recent play. Even though we can pass that information to the game over scene,
    unless we store that value in an instance variable, we won't be able to use it
    in our sharing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来跟踪玩家的当前分数和最近一次游戏的分数。尽管我们可以将此信息传递给游戏结束场景，除非我们将该值存储在实例变量中，否则我们无法在我们的分享中使用它。
- en: 'So, in `GameOverScene.h`, add a variable for the current score, like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`GameOverScene.h`中，添加一个用于当前分数的变量，如下所示：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, in the `initWithScoreData` method, we add the following line so that
    we can grab the total score that was passed to the scene:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`initWithScoreData`方法中，我们添加以下行，以便我们可以获取传递给场景的总分：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we're ready to actually use the score in the text that we share.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在分享的文本中使用分数了。
- en: Creating the UIActivityView object
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UIActivityView对象
- en: 'In the `openShareView` method you just created, add these few lines of code
    (explanation afterwards):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在你刚刚创建的`openShareView`方法中，添加这几行代码（之后会有解释）：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First comes the text that we're going to display. We need to keep it short for
    a few reasons. The most important reason is that Twitter allows only 140 characters,
    so we need to make sure we don't cross that. The second reason is that our potential
    future players might not read it if it's longer than a sentence or two. Finally,
    we want the *generic message* that's going to be sent to at least feel personal.
    It has to be like reading a conversation between two best friends.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是我们要显示的文本。我们需要保持它简短，有几个原因。最重要的原因是Twitter只允许140个字符，所以我们需要确保我们不会超过这个限制。第二个原因是，我们的潜在未来玩家可能不会阅读超过一两个句子的内容。最后，我们想要发送的*通用消息*至少要让人感觉是个人化的。它必须像阅读两个最好的朋友之间的对话一样。
- en: Next is the link to the App Store, which also takes in the app's ID. Notice
    the `appID` variable is just `1` through `9`. This isn't the exact app ID at the
    moment (not even for the book's project), so what we're going to do is modify
    this line of code when we create the app in iTunes Connect (or if you already
    have an app created, you can use that app ID now).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是App Store的链接，它也接受应用的ID。注意`appID`变量是`1`到`9`。目前这还不是确切的App ID（甚至不是书籍项目的App
    ID），所以当我们创建iTunes Connect中的应用时（或者如果你已经创建了一个应用，你现在可以使用那个App ID）我们将修改这一行代码。
- en: After that is the array of objects to be included in the share. Simply add them
    to an array.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是包含在分享中的对象数组。只需将它们添加到数组中即可。
- en: Finally, we create the `UIActivityViewController` object with the `objectsToShare`
    array.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`objectsToShare`数组创建`UIActivityViewController`对象。
- en: But it's not yet displaying anything, so let's handle that.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但目前还没有显示任何内容，所以让我们来处理这个问题。
- en: Displaying UIActivityViewController
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示UIActivityViewController
- en: 'After you''ve initialized the `activityVC` variable in the `openShareView`
    method, add the following block of code. It will ensure that the activity view
    doesn''t show certain activities, and then present the view controller over the
    shared `CCDelegate`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在你初始化`activityVC`变量在`openShareView`方法后，添加以下代码块。它将确保活动视图不会显示某些活动，然后通过共享的`CCDelegate`显示视图控制器：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we don't want the user to print anything, assign anything to a contact,
    or add it to their reading list (Flickr, Vimeo, and so on), we need to exclude
    these activities, which basically means they won't show up on the view that appears
    when the user taps the share button.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望用户打印任何内容，将任何内容分配给联系人，或将它们添加到他们的阅读列表（Flickr，Vimeo等），我们需要排除这些活动，这意味着它们不会出现在用户点击分享按钮时出现的视图中。
- en: 'This is a list of all the possible `UIAcitivityTypes`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个所有可能的`UIAcitivityTypes`列表：
- en: '`UIActivityTypeAddToReadingList;`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypeAddToReadingList;`'
- en: '`UIActivityTypeAirDrop;`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypeAirDrop;`'
- en: '`UIActivityTypeAssignToContact;`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypeAssignToContact;`'
- en: '`UIActivityTypeCopyToPasteboard;`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypeCopyToPasteboard;`'
- en: '`UIActivityTypeMail;`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypeMail;`'
- en: '`UIActivityTypeMessage;`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypeMessage;`'
- en: '`UIActivityTypePostToFacebook;`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypePostToFacebook;`'
- en: '`UIActivityTypePostToFlickr;`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypePostToFlickr;`'
- en: '`UIActivityTypePostToTencentWeibo;`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypePostToTencentWeibo;`'
- en: '`UIActivityTypePostToTwitter;`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypePostToTwitter;`'
- en: '`UIActivityTypePostToVimeo;`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypePostToVimeo;`'
- en: '`UIActivityTypePostToWeibo;`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypePostToWeibo;`'
- en: '`UIActivityTypePrint;`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypePrint;`'
- en: '`UIActivityTypeSaveToCameraRoll;`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIActivityTypeSaveToCameraRoll;`'
- en: So, for your own projects, feel free to include or exclude as many or as few
    of these as you wish. For example, if you're sharing a video, you can very easily
    allow Vimeo or saving the photos.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于您自己的项目，您可以随意包含或排除这些内容中的任意多少。例如，如果您正在分享一个视频，您可以非常容易地允许Vimeo或保存照片。
- en: That's it! If you run the game at this point and click on the **Share** button,
    you'll see the activity view pop up, along with the various buttons for messaging,
    e-mail, Facebook, and Twitter. Clicking on any of these will load the respective
    view, along with the message and URL that was added.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果您现在运行游戏并点击**分享**按钮，您将看到活动视图弹出，以及消息、电子邮件、Facebook和Twitter的各种按钮。点击任何一个都会加载相应的视图，以及添加的消息和URL。
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When adding this to your own project, the key thing to note is the exclusion
    list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将此添加到自己的项目中时，需要注意的关键点是排除列表。
- en: 'Here''s what the final version looks like:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终版本的外观：
- en: '![Displaying UIActivityViewController](img/image00268.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![显示UIActivityViewController](img/image00268.jpeg)'
- en: Adding a screenshot to the share
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加截图到分享
- en: Even though we're adding some text and including a link to the game on the App
    Store, we should probably also include a screenshot because it's more likely someone
    will at least check out the game if there's a screenshot attached.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们添加了一些文本并包括了一个指向App Store上游戏的链接，但我们可能还应该包括一个截图，因为如果附有截图，人们至少会检查一下游戏。
- en: That being said, we don't really want a screenshot from the game over screen,
    so we'll have to grab a screenshot of the game right before we transition to `GameOverScene`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们并不真的想要从游戏结束屏幕截取截图，所以我们必须在过渡到`GameOverScene`之前截取游戏的截图。
- en: 'So, open up `MainScene.m` and add the following method. It will take a screenshot
    of the game:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开`MainScene.m`并添加以下方法。它将截取游戏屏幕：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in the `endGame` method, let''s call the preceding method and store it
    in a local variable so that we can pass it to the `GameOverScene` data:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`endGame`方法中，让我们调用前面的方法并将其存储在局部变量中，以便我们可以将其传递给`GameOverScene`数据：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice the addition of the `@"screenshot"` key to the `scoreData` dictionary.
    This will pass our `UIImage` so that we can grab it in `GameOverScene`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在`scoreData`字典中添加了`@"screenshot"`键。这将传递我们的`UIImage`，这样我们就可以在`GameOverScene`中获取它。
- en: 'Next, in `GameOverScene.h`, add a variable for the screenshot, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`GameOverScene.h`中，添加一个用于截图的变量，如下所示：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then in our `initWithScoreData` method in `GameOverScene.m`, we want to store
    the screenshot in the variable from the dictionary using the `@"screenshot"` key:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`GameOverScene.m`中的`initWithScoreData`方法中，我们想要使用`@"screenshot"`键将截图存储在字典中的变量：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, in our `openShareView` method of the game over scene, all we need
    to do is add the screenshot variable to the `objectsToShare` array, and it will
    be automatically included:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在游戏结束场景的`openShareView`方法中，我们只需要将截图变量添加到`objectsToShare`数组中，它将自动包含：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And that's it! By running the game now and getting to the share button, you'll
    see the image, whether you share via Facebook, Twitter, messages, or e-mail.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！通过现在运行游戏并到达分享按钮，无论您是通过Facebook、Twitter、消息还是电子邮件分享，您都会看到图像。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you really want to get fancy, you can allow users to save the image just
    in case they want to keep it for their own records. To do that, just remove the
    `SaveToCameraRoll` option from the exclusion array in the `openShareView` method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想要做得更精致，您可以允许用户保存图像，以防他们想要保留自己的记录。为此，只需从`openShareView`方法中的排除数组中删除`SaveToCameraRoll`选项。
- en: 'Here''s what your game looks like with the screenshot added (sharing via Facebook):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是添加截图后的游戏外观（通过Facebook分享）：
- en: '![Adding a screenshot to the share](img/image00269.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![添加截图到分享](img/image00269.jpeg)'
- en: Turning sounds on and off
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开关声音
- en: Right now, we have sound effects and music playing all the time no matter what.
    Even though you might be someone who enjoys listening to sounds or music, when
    you design your games (as it's definitely an element that increases user engagement),
    you would want to be open to the fact that people just don't like to hear any
    sound at times. Thus, we must give them the option to turn the sound on and off.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，无论发生什么情况，我们都在播放音效和音乐。即使你可能是一个喜欢听声音或音乐的人，当你设计游戏时（这确实是一个增加用户参与度的元素），你可能会开放地接受这样一个事实：有时人们根本不喜欢听到任何声音。因此，我们必须给他们提供开关声音的选项。
- en: No options or settings? Main menu it is!
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有选项或设置？那就去主菜单吧！
- en: Since we don't have a pause screen, options, settings, or anything similar,
    we're going to add the buttons to turn the sound on and off to the main menu.
    This means that a lot less code is required to add the buttons, instead of creating
    an entirely new scene exclusively for them. This arrangement also stays consistent
    with the clean feel of the game.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有暂停屏幕、选项、设置或类似的东西，我们将把开关声音的按钮添加到主菜单中。这意味着添加按钮所需的代码要少得多，而不是为它们创建一个全新的场景。这种安排也与游戏的简洁感保持一致。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to make a pause screen and add these two buttons to it, then go
    ahead by all means. The code, however, will be slightly different from what will
    be described here because if you push a `CCScene` instead of replace (which essentially
    allows you to pause the game while going to a new scene temporarily), and then
    pop off the scene that you pushed (in other words, resume the paused game), you
    need to make sure that the correct variables get set to false.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个暂停屏幕并将这两个按钮添加到其中，那么请尽你所能去做。然而，代码将略有不同，因为如果你推入一个 `CCScene` 而不是替换（这本质上允许你在临时进入新场景的同时暂停游戏），然后弹出你推入的场景（换句话说，恢复暂停的游戏），你需要确保正确的变量被设置为
    false。
- en: Creating the buttons
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建按钮
- en: First, we're going to create the sound and music on/off buttons in the main
    menu. These are going to be a bit different from normal buttons because instead
    of just a normal button press, they're going to need to swap between the on and
    off states.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在主菜单中创建声音和音乐开/关按钮。这些按钮将与普通按钮略有不同，因为它们需要在不同状态之间切换，而不仅仅是普通的按钮点击。
- en: 'In `MenuScene.m`, let''s create the initial buttons in the `init` method:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MenuScene.m` 文件中，让我们在 `init` 方法中创建初始按钮：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then we need to make sure we create the methods that the buttons will be calling
    when they''re pressed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要确保创建按钮按下时将调用的方法：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Running the game at this point will result in what is shown in the following
    screenshot. If you press either of the buttons, they will switch between each
    other, and if you exit and come back, the buttons will be reset to their original
    state.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在此点运行游戏将导致以下截图所示的结果。如果你按下任一按钮，它们将在彼此之间切换，如果你退出并返回，按钮将重置到其原始状态。
- en: '![Creating the buttons](img/image00270.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![创建按钮](img/image00270.jpeg)'
- en: Creating the keys
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建键
- en: What we need to do to grab (and store) the sound and music variables is make
    use of `NSUserDefaults`, just as we did in the past. To remove any user error
    when coding, we want to define constants for our dictionary keys.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取（并存储）声音和音乐变量，我们需要像过去一样使用 `NSUserDefaults`。为了在编码时减少用户错误，我们希望为我们的字典键定义常量。
- en: 'Since `MainScene` has been imported into all of our classes, we can safely
    define the constant there. So, open `MainScene.h` and add the following code to
    the top of the file, along with the other constants:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `MainScene` 已经被导入到我们所有的类中，我们可以在那里安全地定义常量。因此，打开 `MainScene.h` 文件，并将以下代码添加到文件顶部，与其他常量一起：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, in `MainScene.m`, add this code at the top of the file with the rest
    of the constants so that they are defined:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `MainScene.m` 文件中，将以下代码添加到文件顶部，与所有其他常量一起，以便它们被定义：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now we're able to grab the data that's been stored as well as efficiently save
    any values if we need to.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够获取存储的数据，以及如果我们需要的话，高效地保存任何值。
- en: Grabbing the sound and music Boolean from NSUserDefaults
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 NSUserDefaults 中获取声音和音乐布尔值
- en: We want to store the data in a variable so that we don't have to read and write
    again and again from `NSUserDefaults`, and can do so only when we really need
    to.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将数据存储在变量中，这样我们就不必反复从 `NSUserDefaults` 中读取和写入，而只需在我们真正需要时进行操作。
- en: 'Therefore, in `MainScene.h`, add two Boolean variables for sound on/off and
    music on/off, like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `MainScene.h` 文件中，添加两个布尔变量用于控制声音开/关和音乐开/关，如下所示：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, after you''ve added the buttons to the scene in the `init` method of
    `MainScene.m`, read the sound and music values from `NSUserDefaults` using the
    keys you just defined:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你将按钮添加到场景中 `MainScene.m` 的 `init` 方法之后，使用你刚刚定义的键从 `NSUserDefaults` 中读取声音和音乐值：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we want to actually tell the sound and music buttons whether or not they
    should show their **X** mark or check mark. To do so, we''ll just set the selected
    value to whatever the opposite of the variable is. That''s because if the sound
    is not on, we want to show the selected version:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想实际告诉声音和音乐按钮是否应该显示它们的**X**标记或勾选标记。为此，我们将只设置选中的值为其变量的相反。这是因为如果声音没有开启，我们希望显示选中版本：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This works, but there's no way to test it, so let's actually modify the values
    when the respective buttons are pressed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但没有办法测试它，所以当按下相应的按钮时，我们实际上修改一下值。
- en: Setting and saving the values
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和保存值
- en: 'In the `soundToggle` method, we''re going to set the `isSoundOn` variable to
    the opposite of itself (toggle it on and off). Right after that, we''re going
    to set (and save) its value to the key we defined earlier:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`soundToggle`方法中，我们将把`isSoundOn`变量设置为它的相反（切换开和关）。紧接着，我们将设置（并保存）它的值到我们之前定义的键：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we''re going to do the same for the `isMusicOn` variable in the `musicToggle`
    method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们也将对`musicToggle`方法中的`isMusicOn`变量做同样的处理：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you run the game now, you'll be able to switch between the true/false variables
    of the sound and music, and when you either go to another scene and come back,
    or exit the game and come back, the values will be retained from whatever you
    last set them to. But it's still not pausing the music or turning off the sound,
    so let's fix that.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你将能够切换声音和音乐的真/假变量，并且当你要么去另一个场景然后回来，要么退出游戏然后回来时，值将保留为你最后设置的值。但音乐仍然没有暂停，声音也没有关闭，所以让我们修复这个问题。
- en: Pausing/resuming background music and sound
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停/恢复背景音乐和声音
- en: If the background music is playing when the music button is pressed, we'll need
    to pause it, and vice versa for when it's not playing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在按下音乐按钮时背景音乐正在播放，我们需要暂停它，反之亦然。
- en: 'To start, let''s go to the `musicToggle` method and add a check for the `isMusicOn`
    variable. If it is enabled, we can play the background music. Otherwise, we''ll
    just pause the music until the user turns it on again:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们转到`musicToggle`方法并添加对`isMusicOn`变量的检查。如果它被启用，我们可以播放背景音乐。否则，我们将暂停音乐，直到用户再次将其打开：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After that, we''ll also add a check to see whether the `isSoundOn` is enabled.
    If it is, we''ll play the `buttonClick` sound effect:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们还将添加一个检查来查看`isSoundOn`是否被启用。如果是，我们将播放`buttonClick`音效：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''re going to do the same for the `toggleSound` method as well as the `goToGame`
    method, both of which are methods that get called when a button is pressed. Therefore,
    we are going to play a button click sound effect (only if the sound is enabled):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将对`toggleSound`方法和`goToGame`方法做同样的处理，这两个方法都是在按钮被按下时被调用的。因此，我们将播放一个按钮点击音效（只有当声音被启用时）：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For `MenuScene`, all is done! If you press the music button and/or the sound
    button, you'll notice the effects turning on and off, just as intended. Now that
    we have handled `MenuScene`, let's go for every other location where we'll be
    playing the sound effects (and starting the music).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`MenuScene`，所有工作都已完成！如果你按下音乐按钮和/或声音按钮，你会注意到效果的开和关，正如预期的那样。现在我们已经处理了`MenuScene`，让我们继续处理其他所有我们将播放音效（以及开始音乐）的位置。
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Alternatively, you can create a class that has methods for starting and stopping
    the background music, playing certain sound effects, and playing the button click,
    all using `OALSimpleAudio`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以创建一个类，它有启动和停止背景音乐、播放特定音效和播放按钮点击的方法，所有这些方法都使用`OALSimpleAudio`。
- en: Then you can locate and replace all the instances of `OALSimpleAudio` with your
    own custom class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以找到并替换所有`OALSimpleAudio`的实例，用你自己的自定义类替换。
- en: Handling MainScene sound
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理主场景声音
- en: Since we have sound effects and music playing in just about every class of this
    game, we need to make sure they play only when the corresponding value is true.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在游戏的几乎每个类中都有音效和音乐播放，我们需要确保它们只在相应的值是true时播放。
- en: 'So for starters, let''s open `MainScene.h` and add a similar variable for a
    sound:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先，让我们打开`MainScene.h`并添加一个类似的变量用于声音：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, in the `init` method, make sure you grab the values from `NSUserDefaults`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`init`方法中，确保你从`NSUserDefaults`获取值：
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Also make sure you set the `isSoundOn` variable in the `init` method before
    you attempt to play any sound effect. If you assign the value afterwards, you
    may experience unintended results.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还确保你在尝试播放任何音效之前在`init`方法中设置`isSoundOn`变量。如果你之后分配值，你可能会遇到意外的结果。
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In `MainScene.m`, search for `OALSimpleAudio`, and go to every instance of
    it, adding the following `if` statement above it so that the sound effect plays
    only when that particular sound is enabled:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainScene.m` 中搜索 `OALSimpleAudio`，并访问每一个实例，在其上方添加以下 `if` 语句，以便仅在特定的声音被启用时播放声音效果：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There should be two in `playUnitCombineSound`, one in `goToMenu`, one in `restartGame`,
    and one in `moveUnit`. Obviously, if you have more sound effects playing, then
    you should add them there as well, but these are the five that are present at
    this point.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `playUnitCombineSound` 中应该有两个，一个在 `goToMenu` 中，一个在 `restartGame` 中，一个在 `moveUnit`
    中。显然，如果你有更多的声音效果在播放，那么你也应该在那里添加它们，但到目前为止只有这五个。
- en: Repeating for GameOverScene (and any other scenes)
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 `GameOverScene`（以及任何其他场景）重复操作
- en: 'It''s basically the same as `MainScene`, so there won''t be too much explanation.
    But all you really need to do is the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上和 `MainScene` 一样，所以不会有太多的解释。但你真正需要做的只是以下这些：
- en: Create the `isSoundOn` variable in `GameOverScene.h`
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `GameOverScene.h` 中创建 `isSoundOn` 变量。
- en: Assign the value in the `init` method from `NSUserDefaults`
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `init` 方法中从 `NSUserDefaults` 赋值
- en: Add the if statement before every sound effect that gets played
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个要播放的声音效果之前添加 if 语句
- en: Since this is your only other scene, move on to `AppDelegate`
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是你唯一的另一个场景，继续到 `AppDelegate`。
- en: Handling AppDelegate music
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 AppDelegate 音乐
- en: We need to make sure the music doesn't randomly start playing when users first
    load the game if they had decided to turn it off in a previous version.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保如果用户在之前的版本中决定关闭音乐，音乐不会在用户首次加载游戏时随机开始播放。
- en: 'So in `AppDelegate.m`, add the following if statement before the call to the
    `playBgWithLoop` method. Note that we don''t need to store it in a variable because
    we''re going to use it only once:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在 `AppDelegate.m` 中，在调用 `playBgWithLoop` 方法之前添加以下 if 语句。注意，我们不需要将其存储在变量中，因为我们只会使用它一次：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Making sure that sound/music starts enabled
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保声音/音乐开始时启用
- en: One of the things we want to make sure of is that the sound and music start
    as enabled when the user starts the game. By default, any Boolean in `NSUserDefaults`
    is false. Therefore, we need to make sure that both get set to true before the
    game starts, but only on the first time they run the game.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确保的一件事是，当用户开始游戏时，声音和音乐应该被启用。默认情况下，`NSUserDefaults` 中的任何布尔值都是 false。因此，我们需要确保在游戏开始之前，它们都被设置为
    true，但只在他们第一次运行游戏时。
- en: 'So in `AppDelegate.m`, at the very beginning of `startScene`, let''s add code
    to check whether they''ve played before:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在 `AppDelegate.m` 中，在 `startScene` 的开头，让我们添加代码来检查他们是否之前玩过：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And that's it! It took a little bit of careful planning to make sure we handled
    every case that the user could run into, but that's the entire point of polishing
    your game—making sure that no matter what your user does or can do, the game responds
    appropriately and as intended.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这需要一点仔细的计划来确保我们处理了用户可能遇到的所有情况，但这正是打磨你的游戏的全部要点——确保无论用户做什么或能做什么，游戏都能适当地、如预期地响应。
- en: Tip
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The key takeaways from adding on/off settings for sound and music are as follows:
    storing the value in the `NSUserDefaults`, grabbing that value from a local variable
    in each scene, and using that variable to determine whether you should play a
    sound effect or not. If you want to be sure you''ve gotten all the instances,
    look up the project for `OALSimpleAudio` and go through all the classes you''ve
    created.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为声音和音乐添加开关设置的关键要点如下：将值存储在 `NSUserDefaults` 中，从每个场景的局部变量中获取该值，并使用该变量来确定是否应该播放声音效果。如果你想确保你已获取了所有实例，查找项目中的
    `OALSimpleAudio` 并遍历你创建的所有类。
- en: Make sure that you check for the variable for any future sound effects you add.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查你添加的任何未来声音效果的变量。
- en: Game Center leaderboards
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中心排行榜
- en: We've already got a set of top 20 high scores that are stored on the user's
    device, so why not make a global leaderboard? In fact, even though many players
    don't use Game Center when they play games, it is yet another element that drives
    engagement. Plus (and this is the really cool part)—if you didn't know already—you
    can actually have players rate your game within Game Center. It's not even an
    extra feature or anything, as they can just tap the star count at the top of the
    leaderboard or achievement pane and it'll send the rating to the App Store.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一组存储在用户设备上的前 20 名高分，为什么不创建一个全球排行榜呢？实际上，即使许多玩家在玩游戏时没有使用 Game Center，它也是另一个推动参与度的元素。而且（这是真正酷的部分）——如果你还不知道的话——你实际上可以在
    Game Center 中让玩家对你的游戏进行评分。这甚至不是一个额外的功能，因为他们只需点击排行榜或成就面板顶部的星级数量，就会将评分发送到 App Store。
- en: Creating a leaderboard to display in our game isn't just about code, so we have
    to create the leaderboard in iTunes Connect first. Before we can create the app
    in iTunes Connect, we need to set up an App ID.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中创建一个用于显示的排行榜不仅仅是关于代码，因此我们首先需要在 iTunes Connect 中创建排行榜。在我们可以创建 iTunes Connect
    中的应用程序之前，我们需要设置一个 App ID。
- en: Creating the App ID
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 App ID
- en: At this point, if you wish to add a leaderboard, you must sign up for an Apple
    developer account if you don't have one already. In [Chapter 1](part0014.xhtml
    "Chapter 1. Refreshing Your Cocos2d Knowledge"), *Refreshing Our Cocos2d Knowledge,*
    the signup process was explained. Otherwise, if you're just following along for
    practice, feel free to do so, but you cannot create leaderboards or achievements
    without a developer account.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你想要添加排行榜，你必须注册一个 Apple 开发者账户，如果你还没有的话。在[第 1 章](part0014.xhtml "第 1 章。刷新您的
    Cocos2d 知识")，*刷新我们的 Cocos2d 知识*中，注册过程被解释了。否则，如果你只是为了练习而跟随，请随意这样做，但没有开发者账户，你不能创建排行榜或成就。
- en: First, you need to create the App ID from the developer website. Go to [https://developer.apple.com/devcenter/ios/index.action](https://developer.apple.com/devcenter/ios/index.action)
    and log in to your Apple account that has the iOS developer license on it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要从开发者网站创建 App ID。前往 [https://developer.apple.com/devcenter/ios/index.action](https://developer.apple.com/devcenter/ios/index.action)
    并登录到拥有 iOS 开发者许可证的 Apple 账户。
- en: 'Once logged in, under **iOS Dev Center**, go to the **Certificates, Identifiers
    & Profiles** section, as shown in this screenshot:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，在**iOS 开发中心**下，前往**证书、标识符和配置文件**部分，如下面的截图所示：
- en: '![Creating the App ID](img/image00271.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![创建 App ID](img/image00271.jpeg)'
- en: 'From here, go to the **Identifiers** section so that we can create an App ID,
    as shown in the following screenshot:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，前往**标识符**部分，以便我们可以创建一个 App ID，如下面的截图所示：
- en: '![Creating the App ID](img/image00272.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![创建 App ID](img/image00272.jpeg)'
- en: 'Then begin to create an App ID by clicking on the **+** button in the top-right
    corner. Here, we need to enter a name for the App ID, the name of the bundle identifier
    (which is generally reverse DNS notation; for example, [www.keitgames.com](http://www.keitgames.com)
    might have `com.keitgames.mygame` as the bundle ID), as well as any services we
    want (which we''ll leave as the default for now). This is shown in the following
    screenshot for your reference:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过点击右上角的**+**按钮开始创建 App ID。在这里，我们需要为 App ID 输入一个名称，包标识符的名称（这通常是反向 DNS 表示法；例如，[www.keitgames.com](http://www.keitgames.com)可能有
    `com.keitgames.mygame` 作为包 ID），以及我们想要的任何服务（我们目前将其保留为默认设置）。以下截图供您参考：
- en: '![Creating the App ID](img/image00273.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![创建 App ID](img/image00273.jpeg)'
- en: Make sure you use your own bundle identifier (the preceding screenshot simply
    shows an example and where it all goes).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用自己的包标识符（前面的截图仅显示了一个示例以及所有内容的位置）。
- en: Once that's done, click on **Continue** and then on **Submit**. Then the App
    ID should be created.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，点击**继续**然后点击**提交**。然后 App ID 应该就创建完成了。
- en: Next, in the Xcode project's settings, select the iOS target and update the
    bundle identifier to the one you just created.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 Xcode 项目的设置中，选择 iOS 目标并更新包标识符为你刚刚创建的那个。
- en: '![Creating the App ID](img/image00274.jpeg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![创建 App ID](img/image00274.jpeg)'
- en: Now that the bundle ID and App ID are set up, we can create the app in iTunes
    Connect, and it will allow us to set up and test our leaderboards.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，包 ID 和 App ID 已经设置好了，我们可以在 iTunes Connect 中创建应用程序，这将允许我们设置和测试我们的排行榜。
- en: Creating the app in iTunes Connect
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 iTunes Connect 中创建应用程序
- en: Creating the app in iTunes Connect is relatively simple, and is only going to
    be used as a wireframe so that we can create the leaderboards. In the next chapter,
    we'll cover all the details; for now you just need to know that the only reason
    we're setting it up in iTunes Connect now (instead of later) is for the purpose
    of setting up a leaderboard.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在iTunes Connect中创建应用相对简单，并且仅用作线框，以便我们可以创建排行榜。在下一章中，我们将涵盖所有细节；现在您只需要知道我们现在在iTunes
    Connect中设置它（而不是稍后）的唯一原因是用于设置排行榜。
- en: First, go to [https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa](https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa)
    and sign in to your developer account. Then click on **My Apps**, create a new
    app by clicking on the **+** button in the top-left corner, and click on **New
    iOS App**.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往[https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa](https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa)并登录您的开发者账户。然后点击**我的应用**，通过点击左上角的**+**按钮创建一个新应用，并点击**新iOS应用**。
- en: '![Creating the app in iTunes Connect](img/image00275.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![在iTunes Connect中创建应用](img/image00275.jpeg)'
- en: Then fill in the information it asks, including the App ID you created earlier.
    The SKU doesn't really matter, as it's for your own internal use.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后填写它要求的信息，包括您之前创建的应用ID。SKU实际上并不重要，因为它仅用于您自己的内部使用。
- en: '![Creating the app in iTunes Connect](img/image00276.jpeg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![在iTunes Connect中创建应用](img/image00276.jpeg)'
- en: Once the app has been created in iTunes connect, click on **Game Center**.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在iTunes connect中创建了应用，点击**游戏中心**。
- en: '![Creating the app in iTunes Connect](img/image00277.jpeg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![在iTunes Connect中创建应用](img/image00277.jpeg)'
- en: When it asks whether it's for a single game or multiple games, that's up to
    you to decide when creating projects on your own. But for the purpose of this
    book's project, we're going to create it for a single game.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当询问它是用于单个游戏还是多个游戏时，这取决于您在创建项目时的决定。但为了本书项目的目的，我们将为单个游戏创建它。
- en: '![Creating the app in iTunes Connect](img/image00278.jpeg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![在iTunes Connect中创建应用](img/image00278.jpeg)'
- en: After that, you'll be taken to the Game Center setup screen, and you're ready
    to move on to the next step.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将被带到游戏中心设置屏幕，然后就可以继续下一步了。
- en: Creating the leaderboard
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建排行榜
- en: From the Game Center setup section within iTunes Connect, click on the **Add
    Leaderboard** button and then on **Single Leaderboard**.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在iTunes Connect中的游戏中心设置部分，点击**添加排行榜**按钮，然后点击**单个排行榜**。
- en: '![Creating the leaderboard](img/image00279.jpeg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![创建排行榜](img/image00279.jpeg)'
- en: The leaderboard reference is for internal use within iTunes Connect, just in
    case you wish to search for it (or know at a glance which leaderboard it is).
    The **Leaderboard ID** will be used within the code, so it should be something
    unique and distinct from your other leaderboards (if you've created any). The
    score format is only whole numbers, so we'll use the **Integer** format. We want
    only the best score to be submitted (as only one score per person can exist in
    a leaderboard) and sorted from High to Low. Finally, we want the range to be from
    0 to 999,999\. Technically, we don't have to set this, but we're going to anyway.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 排行榜参考仅用于iTunes Connect内部的内部使用，以防您需要搜索它（或一眼就能知道它是哪个排行榜）。**排行榜ID**将在代码中使用，因此它应该是独特且与其他排行榜（如果您创建了任何）不同的。得分格式仅使用整数，因此我们将使用**整数**格式。我们希望只提交最佳得分（因为排行榜中每个人只能有一个得分）并按从高到低排序。最后，我们希望范围从0到999,999。技术上我们不必设置这个，但我们还是设置了。
- en: 'Next, we add a language. Here''s an example showing **English**:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一种语言。以下是一个显示**英语**的示例：
- en: '![Creating the leaderboard](img/image00280.jpeg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![创建排行榜](img/image00280.jpeg)'
- en: 'The **Name** is the title at the top of the leaderboard that the users will
    see, so we want it to be obvious which leaderboard it is. The **Score Format**
    is the same as what you just saw. The **Score Format Suffix** works as follow:
    since we have **Points**, a score of 625 will look like **625 Points** in the
    leaderboard. If you think it would look weird to include the word **Points** in
    every score, feel free to leave it out, but for now, we''re going to have it in
    there.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**是用户将看到的排行榜顶部的标题，因此我们希望它很明显，表明这是哪个排行榜。**得分格式**与您刚才看到的一样。**得分格式后缀**的作用如下：由于我们有**分数**，得分为625的排行榜将显示为**625
    分数**。如果您认为在每个得分中都包含单词**分数**看起来会很奇怪，您可以随意省略它，但到目前为止，我们将保留它。'
- en: Once all of this information has been entered, click on **Save** at the bottom.
    And voilà! It's created! What comes next is coding the Game Center login, authentication,
    leaderboard presentation, submitting the score, and everything else that comes
    with handling Game Center.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入所有这些信息后，点击底部的**保存**。哇！它已经创建好了！接下来是编写Game Center登录、验证、排行榜展示、提交分数以及处理Game Center的所有其他内容。
- en: Adding the GameKit framework
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加GameKit框架
- en: 'Before we do any coding, we need to include the GameKit framework in our project.
    So, in your project''s settings, go to the **iOS target**, then go to **Build
    Phases**, and in the **Link Binary With Libraries** section, click on the **+**
    button to add a framework to the project, as shown in this screenshot:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写任何代码之前，我们需要在我们的项目中包含GameKit框架。所以，在你的项目设置中，转到**iOS目标**，然后转到**构建阶段**，在**链接二进制与库**部分，点击**+**按钮将框架添加到项目中，如图所示：
- en: '![Adding the GameKit framework](img/image00281.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![添加GameKit框架](img/image00281.jpeg)'
- en: Then, search for `gamekit` (case insensitive), click on the `GameKit.framework`
    result, and then click on **Add**.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，搜索`gamekit`（不区分大小写），点击`GameKit.framework`的结果，然后点击**添加**。
- en: '![Adding the GameKit framework](img/image00282.jpeg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![添加GameKit框架](img/image00282.jpeg)'
- en: And we're done! Now we're ready to code.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了！现在我们准备好编写代码了。
- en: GameKit helper files
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameKit辅助文件
- en: For the sake of simplicity, you can just copy the `GKHelper` files to your project
    (make sure you have the **Copy** checkbox selected). It's not that coding the
    Game Center stuff is hard—it's the same for literally every project that has Game
    Center. So why waste time manually typing the code when you can just have the
    files ready?
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，你只需将`GKHelper`文件复制到你的项目中（确保选中了**复制**复选框）。实际上，编写Game Center代码并不难——对于有Game
    Center的每个项目都是如此。所以，为什么要在手动输入代码上浪费时间，当你可以直接准备好文件时？
- en: Essentially, what the `GKHelper` singleton class does is manage your `GKLocalPlayer`
    (the currently logged-in user in Game Center on the device), any calls to and
    from the server, and any leaderboard score posting and achievement tracking.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`GKHelper`单例类所做的是管理你的`GKLocalPlayer`（设备上Game Center当前登录的用户），以及任何来自服务器或发往服务器的调用，以及任何排行榜分数提交和成就跟踪。
- en: Tip
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `GKHelper` class was created using the online tutorial [http://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6](http://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6),
    if you're looking for more explanation. There is another guide at [http://www.appcoda.com/ios-game-kit-framework/](http://www.appcoda.com/ios-game-kit-framework/%20)
    that covers Game Center in depth. Refer to it if you're getting stuck, or still
    need extra help (as it can be confusing for those new to coding Game Center).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`GKHelper`类是使用在线教程[http://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6](http://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6)创建的，如果你需要更多解释。还有一个更深入的指南在[http://www.appcoda.com/ios-game-kit-framework/](http://www.appcoda.com/ios-game-kit-framework/%20)，它涵盖了Game
    Center的各个方面。如果你遇到困难，或者仍然需要额外帮助（对于刚开始接触Game Center编程的人来说可能会很困惑），请参考它。'
- en: '*This is important*: Suppose you''re getting this error message:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*重要提示*：假设你遇到了以下错误信息：'
- en: '[PRE52]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then you must go to device **Settings** | **Game Center** and enable **Sandbox**,
    as shown in this screenshot:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须前往设备**设置** | **游戏中心**并启用**沙盒**，如图所示：
- en: '![GameKit helper files](img/image00283.jpeg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![GameKit辅助文件](img/image00283.jpeg)'
- en: Authenticating the user
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证用户
- en: Now that everything is in place, created, and ready for use, we can begin to
    code the actual leaderboard and make it appear when users sign in to Game Center.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切就绪，创建完成，准备使用，我们可以开始编写实际的排行榜代码，并在用户登录Game Center时显示它。
- en: First, we need to authenticate the local player; that is, have them sign in
    if they aren't signed in already, or just send a request for the `GKLocalPlayer`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要验证本地玩家；也就是说，如果他们还没有登录，就让他们登录，或者只需发送一个请求来获取`GKLocalPlayer`。
- en: 'We''re going to do this at the beginning of our app, so in `AppDelegate.m`,
    import the `GKHelper.h` file and add the following method call to the top of the
    `startScene` method:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用开始时进行这一操作，所以请在`AppDelegate.m`中导入`GKHelper.h`文件，并将以下方法调用添加到`startScene`方法的顶部：
- en: '[PRE53]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If everything was done correctly, when you run the game at this point, you should
    see a banner going across the top of your screen welcoming the currently logged-in
    player. If not, it will ask them to log in.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切操作都正确，当你现在运行游戏时，你应该会在屏幕顶部看到一个横幅欢迎当前登录的玩家。如果没有，它会要求他们登录。
- en: If you're getting an error message that says something along the lines of a
    requested operation being cancelled or disabled, go to the **Settings** app and
    then to **Game Center**. Try either logging in and out again, or enabling the
    **Sandbox** mode at the bottom (see the preceding screenshot). This should fix
    it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一条错误消息，内容类似于请求的操作被取消或禁用，请前往**设置**应用，然后进入**游戏中心**。尝试重新登录和登出，或者启用底部的**沙盒**模式（参见前面的截图）。这应该可以解决问题。
- en: Creating the Game Center button
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏中心按钮
- en: 'We want a button for access to the leaderboards and other Game Center stuff,
    so in the **GameOverScene.m** file''s `init` method, add the following code. It
    will create a button in the bottom-right corner of the screen:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要一个按钮来访问排行榜和其他游戏中心内容，所以请在`GameOverScene.m`文件的`init`方法中添加以下代码。它将在屏幕的右下角创建一个按钮：
- en: '[PRE54]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also want to display the leaderboards, and this requires the `GKHelper`,
    so at the top of `GameOverScene.m`, import the `GKHelper.h` file:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要显示排行榜，这需要`GKHelper`，所以请在`GameOverScene.m`的顶部导入`GKHelper.h`文件：
- en: '[PRE55]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then create the `viewGameCenter` method, which is simply a call for presenting
    the leaderboards:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建`viewGameCenter`方法，这只是一个调用以显示排行榜：
- en: '[PRE56]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you run the game at this point and get to the game over scene, you'll see
    a button for **Game Center** in the bottom-right corner, and when clicked on (and
    if you're signed in to Game Center), it'll open the leaderboard. The only thing
    left to do now is to submit the score to Game Center so it can be seen in the
    leaderboard.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏并进入游戏结束场景，你会在屏幕右下角看到一个**游戏中心**按钮，点击它（如果你已经登录到游戏中心），它将打开排行榜。现在唯一剩下的事情是将得分提交到游戏中心，以便在排行榜中显示。
- en: Submitting the score
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交得分
- en: Since our `GKHelper` class can do all of the score reporting for us, all we
    need to do is call the respective function. Since we know `GameOverScene` will
    contain the total score from the most recent game, we can use the passed-in dictionary
    as the score value we submit to the leaderboard.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`GKHelper`类可以为我们完成所有的得分报告，我们只需要调用相应的函数。既然我们知道`GameOverScene`将包含最近一局的得分总和，我们可以使用传入的字典作为提交给排行榜的得分值。
- en: 'So, in the `init` method of `GameOverScene.m`, add a call to the `submitScore`
    function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`GameOverScene.m`的`init`方法中，添加对`submitScore`函数的调用：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: And that's it! It took a while to set up, and about 10 lines of code, but we
    have a global leaderboard.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！设置花费了一些时间，大约10行代码，但我们已经有一个全局排行榜。
- en: 'There are two things to note here:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的事项：
- en: You may want to implement achievements, but that code has not been implemented
    in the `GKHelper` class yet, so unfortunately, you're on your own. Although this
    is not too difficult, it wasn't necessary for this game, so it was skipped. As
    linked earlier, there's a great resource at [http://www.appcoda.com/ios-game-kit-framework/](http://www.appcoda.com/ios-game-kit-framework/)
    that explains how to implement achievements. It was written in March 2014, so
    the code should still work by the time you read this book.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能想实现成就，但`GKHelper`类中还没有实现这些代码，所以很遗憾，你需要自己完成。尽管这并不太难，但在这个游戏中不是必需的，所以它被跳过了。如前所述，[http://www.appcoda.com/ios-game-kit-framework/](http://www.appcoda.com/ios-game-kit-framework/)有一个很好的资源，解释了如何实现成就。它是在2014年3月写的，所以当你读到这本书的时候，代码应该仍然有效。
- en: While implementing leaderboards, if you ever run into an issue, make sure that
    everything, from the iTunes Connect setup to the Game Center to **Sandbox** mode
    and the code itself, is all in line. Game Center can be tricky and annoying. It's
    gotten better over the years, but can still be a bit finicky. If you're still
    having issues, it's likely that you're not the only one. A great place to start
    searching is Stack Overflow. If you aren't familiar with the site, don't worry.
    They have a question-and-answer format where tons of people have asked questions
    about code and other issues, and many more have given correct answers.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现排行榜时，如果你遇到任何问题，请确保从iTunes Connect设置到游戏中心、**沙盒**模式和代码本身，所有这些都在线。游戏中心可能有点棘手和令人烦恼。尽管这些年来它有所改进，但仍然可能有点挑剔。如果你仍然有问题，你可能不是唯一一个。一个很好的开始搜索的地方是Stack
    Overflow。如果你不熟悉该网站，不要担心。他们有一个问答格式，有成千上万的人提出了关于代码和其他问题的疑问，还有更多的人给出了正确的答案。
- en: And that's it for Game Center! The last thing to do to polish our project includes
    creating a custom transition between scenes to make the game feel more robust,
    instead of just instantly shifting back and forth between scenes.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是游戏中心的全部内容！为了完善我们的项目，最后要做的就是在场景之间创建一个自定义过渡，使游戏感觉更健壮，而不是只是瞬间在场景之间切换。
- en: Slide transition
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑动过渡
- en: Although it's fine for testing purposes, instant transitions between our scenes
    (as well as the game suddenly showing up when it first loads) are bad. We're going
    to add a nice quick slide between each scene. In other words, when the user taps
    a button or an event happens that's supposed to replace the scene with a new scene,
    we're going to make it seem as if all the scenes are on one giant white sheet,
    just out of view of the user.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于测试目的来说这很好，但场景之间的即时过渡（以及游戏首次加载时突然出现）是糟糕的。我们将添加一个快速的滑动过渡，在每个场景之间。换句话说，当用户点击按钮或发生应该用新场景替换场景的事件时，我们将让它看起来好像所有场景都在一个巨大的白色纸张上，只是用户看不到。
- en: Creating a generic slide function
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个通用的滑动函数
- en: Since we're going to be doing this all over the place, we need a function that's
    generic enough for us to pass to it any scene from any location, and it will do
    exactly what we want it to do.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在各个地方做这件事，我们需要一个足够通用的函数，以便我们可以将任何场景从任何位置传递给它，并且它将执行我们想要它执行的确切操作。
- en: 'So again, since `MainScene.h` is imported everywhere, we''re going to create
    our generic function in it. Open `MainScene.h` and add this enumeration above
    the `@interface` line:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于 `MainScene.h` 在所有地方都被导入，我们将在其中创建一个通用函数。打开 `MainScene.h` 文件，并在 `@interface`
    行上方添加此枚举：
- en: '[PRE58]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will allow us to tell the generic function in which direction to slide
    our scene.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们告诉通用函数将场景滑动到哪个方向。
- en: 'After that, add the following method declaration in `MainScene.h`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `MainScene.h` 文件中添加以下方法声明：
- en: '[PRE59]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The parameters this method takes are the scene you want to transition to, the
    parent (the scene you're currently on), how long you want the slide to last, and
    in what direction you want the slide to occur.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受的场景参数是你想要过渡到的场景、父级（你当前所在的场景）、你想要滑动持续多长时间，以及你想要滑动到哪个方向。
- en: 'Next, in `MainScene.m`, add the actual function. It will slide our scene into
    the view and then replace it with `CCDirector` (the detailed explanation is in
    the comments):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `MainScene.m` 文件中添加实际的功能。它将使我们的场景滑动到视图中，然后替换为 `CCDirector`（详细解释见注释）：
- en: '[PRE60]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: However, since we're moving the scenes slightly off screen in one direction
    or another, we need to make sure we have enough "background" to cover the extras.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们在一个方向或另一个方向上稍微将场景移动到屏幕外，我们需要确保我们有足够的“背景”来覆盖额外的部分。
- en: Extending the background
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展背景
- en: 'At the top of our `MainScene.m` files `init` method, we change our declaration
    of the background to the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainScene.m` 文件 `init` 方法的顶部，我们将背景的声明更改为以下内容：
- en: '[PRE61]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `z` value is set to `-2` so that we can place the new scene at `-1` (as
    seen in preceding code). Thus, even though the background is five times the width
    and the height of the screen, the new scene will still be visible when it slides
    into the view.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `z` 值设置为 `-2`，以便我们可以将新场景放置在 `-1`（如前述代码所示）。因此，即使背景是屏幕宽度和高度的五倍，当它滑动到视图中时，新场景仍然可见。
- en: Now the only thing left to do is to actually call the function.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下调用函数这一步了。
- en: Replacing the scene with a rubber band transition
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用橡皮筋过渡替换场景
- en: 'Because we made such a convenient generic function, we don''t need to do anything
    besides calling it once. So in `MainScene.m`, modify your `goToMenu` function
    to call the `rubberBandToScene` method you just created:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了一个如此方便的通用函数，我们不需要做任何事情，只需调用一次。因此，在 `MainScene.m` 文件中，修改你的 `goToMenu`
    函数以调用你刚刚创建的 `rubberBandToScene` 方法：
- en: '[PRE62]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Also modify the same line in the `endGame` method in `MainScene.m`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 还要修改 `MainScene.m` 文件中 `endGame` 方法的相同行：
- en: '[PRE63]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice that the one going to the menu is `DirectionDown`, whereas the `endGame`
    object is `DirectionUp`. Now run the game and press that **Menu** button. Beautiful
    isn't it? But that's just one of the many scene transitions we have. So let's
    handle the rest, shall we?
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，去菜单的方向是 `DirectionDown`，而 `endGame` 对象是 `DirectionUp`。现在运行游戏并按下那个**菜单**按钮。美吧？但这只是我们拥有的许多场景过渡之一。所以，让我们处理剩下的部分，好吗？
- en: Transition in MenuScene
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MenuScene 中的过渡
- en: 'When we click on the **Play** button, we''d ideally want the same effect, so
    we first need to create the extra-large background. In `MenuScene.m`, modify the
    background code to look like `MainScene`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**播放**按钮时，我们理想上希望有相同的效果，所以首先我们需要创建一个超大的背景。在`MenuScene.m`中，修改背景代码以看起来像`MainScene`：
- en: '[PRE64]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, in the `goToGame` function, we simply make a call to the generic function
    we made previously:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`goToGame`函数中，我们只需调用我们之前创建的通用函数：
- en: '[PRE65]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Transition in GameOver
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束时的过渡
- en: So far, we've gotten the to-menu and to-gameover transitions into the main game
    scene. We've also implemented the to-game transition in the main menu scene. The
    only thing left to do is to put the transition for to-menu and to-game in the
    `GameOverScene`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将进入菜单和游戏结束过渡添加到了主游戏场景中。我们还在主菜单场景中实现了进入游戏过渡。唯一剩下要做的就是将进入菜单和进入游戏的过渡放到`GameOverScene`中。
- en: 'To do this, you can do in `GameOverScene.m` what you''ve been doing so far,
    and modify the `replaceScene` line of code in the `goToMenu` and `restartGame`
    methods:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你可以在`GameOverScene.m`中做你迄今为止所做的一切，并修改`goToMenu`和`restartGame`方法中的`replaceScene`代码行：
- en: '[PRE66]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: And that's it! We've managed to not only create a custom transition (compared
    to the rather boring transitions that Cocos2d version 3.0+ comes with) but also
    implement it with ease. It adds just that bit of the "Whee! This is fun!" factor,
    which is a good thing because it's what the players will be feeling. Happy players
    means higher engagement, and higher engagement means higher ratings and more referrals
    to their friends (which means more money in your pocket).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们不仅成功创建了一个自定义过渡（与Cocos2d 3.0+版本附带的那种相当无聊的过渡相比），而且还轻松地实现了它。它增加了那么一点“哇！这很有趣！”的感觉，这是好事，因为这就是玩家会感受到的。快乐的玩家意味着更高的参与度，更高的参与度意味着更高的评分和更多的朋友推荐（这意味着你口袋里的钱更多）。
- en: Other ideas for polishing
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他润色想法
- en: 'Some other ideas for polishing that weren''t covered in this chapter are as
    follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 本章未涵盖的一些其他润色想法如下：
- en: Smoother animation for characters or units
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为角色或单位提供更平滑的动画
- en: Fluid movements (such as the Bézier effect, as covered in the previous chapter)
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流畅的动作（例如，如前一章所述的贝塞尔效果）
- en: No loading screen (ending the current scene looking exactly like how the next
    scene will begin, and transitioning instantly)
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有加载屏幕（结束当前场景看起来正好像下一个场景开始的样子，并且瞬间过渡）
- en: No crashes (yes, fix all of them)
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有崩溃（是的，修复所有这些问题）
- en: Subtle details such as background movement or brief NPC voice-overs
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些细微的细节，如背景移动或简短的NPC旁白
- en: Saving the user's spot in case of an interruption (phone call, battery dead,
    and so on)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中断（如电话、电池耗尽等）的情况下保存用户的进度
- en: But these are just a few examples. There's a million little things you could
    do to your game to make it ever so slightly better, but alas! At some point, we
    need to release the game, so that's what the next chapter is going to focus on—adding
    the finishing touches and submitting the game to Apple.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些只是几个例子。你可以在游戏中做无数的小改动来让它变得更好一点，但遗憾的是！在某个时候，我们需要发布游戏，所以下一章将专注于添加最后的修饰和将游戏提交给苹果。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned various ways to polish your game and really focus
    on some subtle, but important, elements such as on/off buttons for sound and music,
    sliding between scenes, and the social sharing feature.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了各种润色游戏的方法，并真正关注了一些微妙但重要的元素，例如声音和音乐的开关按钮、场景之间的滑动以及社交分享功能。
- en: There's always something that can be tweaked and tuned to make it more polished.
    For example, if you wish to learn more about more traditional sprite animations,
    you can do so using `CCAnimation`. There's a great reference guide for this at
    [http://www.cocos2d-swift.org/docs/api/Classes/CCAnimation.html](http://www.cocos2d-swift.org/docs/api/Classes/CCAnimation.html).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有些东西可以被调整和优化，使其更加精致。例如，如果你想了解更多关于更传统的精灵动画，你可以使用`CCAnimation`来实现。关于这方面的优秀参考指南可以在[http://www.cocos2d-swift.org/docs/api/Classes/CCAnimation.html](http://www.cocos2d-swift.org/docs/api/Classes/CCAnimation.html)找到。
- en: Notice that as of now, we still haven't come up with a name for the game. Although
    the name is something that all users will see and familiarize themselves with,
    it's not important for the development of the game, which is why it's coming last.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，到目前为止，我们还没有为游戏想出一个名字。尽管名字是所有用户都会看到并熟悉的东西，但它对游戏开发并不重要，这就是为什么它排在最后。
