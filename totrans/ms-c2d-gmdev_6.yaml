- en: Chapter 6. Tidying Up and Polishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polishing is the most important thing you'll learn in this entire book. If you
    can master the art of making your game polished, it doesn't matter how simple
    or complex it is; you'll have a great game. And yes, even though you may be a
    great programmer who hasn't had a bug in your program in years, or an artist who
    makes people faint when they see your character designs, you still need to polish
    you game. It's absolutely necessary for any modern game to be a solid experience
    for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn what it takes to clean up the game, smooth out
    the rough edges, and turn that game with cool mechanics into a fun, playable,
    and unforgettable experience. But it''s not just about making it look good. It
    needs to feel good, and the entire user experience needs to be joyful. In no particular
    order, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Button press visual
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulse on unit combine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tutorial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing over Facebook and Twitter (and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound on/off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game Center leaderboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slide transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, you don't have to do all of these, but if you want more people to
    play your game, chances are that they're more likely to play it if it's polished.
    Now, the biggest thing when it comes to polishing is the graphical and sound styles.
    They need to be consistent throughout, as well as visually appealing so that the
    user doesn't get confused or put off when they play your game.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, if you open the `Chapter 6` project, you'll see that the game's
    graphics and fonts have been updated. It looks and feels pretty solid. The only
    thing left to do is what's being covered in this chapter (as you just saw in the
    list). So let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Button press visuals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yeah, button press visuals are great! Cocos2d is nice enough to provide a darkening
    of the button when we touch it, but let's add a bit more animation to our buttons
    to give them more of that "clicked" feeling.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the CCButton class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we just wanted an individual button to have a specific effect, we would modify
    just that single button in the place where it exists. However, we want the same
    button effect across all buttons in our game, so we need to open `CCButton.m`
    file. The easiest way to do that is to search for `CCButton` in the project and
    click on any of the links to `CCButton.m`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you''re going to add two functions near the top of the file: `scaleButtonUp`
    and `scaleButtonDown`. Both of them run actions on the button, and these actions
    give it a bouncy press effect found in many games:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, you can extend/subclass `CCButton` and override the methods necessary
    to create the desired effect. This method is also slightly more stable in the
    case of a Cocos2d version update that changes the default code of `CCButton`.
    But for now, we'll just modify the existing `CCButton` code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then at the bottom of the `touchEntered` method, add the call to the `scaleButtonDown`
    method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in `touchExited` and `touchUpInside`, you have to add the call to
    the `scaleButtonUp` methods. This is meant for the following cases: either when
    the players, finger leaves the button (indicating that it won''t be activated
    if they lift their finger), or when they actually "press" the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! It took a whole 2 minutes to add that extra bit of polishing
    to our buttons. It's not something that's going to sell the game on its own, but
    it's subtle enough to give your players a feeling like, "Wow, the developers really
    took the time to make this game right!"
  prefs: []
  type: TYPE_NORMAL
- en: Pulse on unit combine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our units combine, nothing special really happens. So, what we're going
    to do is add a slight pulse effect. Basically, when two units combine we want
    the unit to grow in a fashion similar to the button visual we just created (where
    it expands and then scales down again).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also do fancy things in general when the units spawn, such as particle
    effects (for example, a subtle explosion/burst effect), sprite animations, and
    other various things.
  prefs: []
  type: TYPE_NORMAL
- en: The key to polishing is thinking out of the box, yet looking at things you already
    have within the game to keep the aesthetic consistent and solid.
  prefs: []
  type: TYPE_NORMAL
- en: 'To carry out the pulsing we desire, since we''ll most likely be placing the
    same code in multiple places, let''s create a method that takes in a `CCNode`
    object and applies the effect we have in mind. So in `MainScene.m`, add the following
    method somewhere in the code (preferably near the combination code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function takes into consideration the "original scale" of the unit, and
    then runs a two-action sequence of scaling up and then down. However, we want
    to make sure we stop all the current actions on the unit in the case of there
    being more than two units that combine (and we will subsequently call this function
    multiple times on the same unit).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a function ready, let's add the calls to it in the four places
    where a unit is combined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two places are in the `checkForCombineWithUnit` method (again, if
    you aren''t using the `Chapter 6` code here, this method isn''t implemented):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two places are in the `checkForAnyDirectionCombine` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Run the game and combine two units, and you'll see the pulsing
    effect. Again, it's subtle, but that's exactly what we need—many subtle changes
    that add up to a lot over time.
  prefs: []
  type: TYPE_NORMAL
- en: Tutorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're at the point where we need to teach our players how to play our game.
    Although you might have been able to explain the game to your testers when you
    were standing over their shoulders, you won't be able to do that for those who
    download the app from the App Store. Thus, we're in need of a tutorial, and a
    quick one because we want our players playing the game, not the tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, we''re going to have a simple tutorial that basically explains
    the main concepts of the game through only a few words and some images:'
  prefs: []
  type: TYPE_NORMAL
- en: Players sliding units with their fingers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining their own units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defeating enemy units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting the central square
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, we are able to go a lot more in depth by explaining a few more of
    the subtle concepts, but instead, we're giving the player room to learn, experiment,
    and test things for themselves. We just want the tutorial to set them up so that
    they don't get frustrated when they either don't know what to do when the game
    starts, or lose and don't know why they lost.
  prefs: []
  type: TYPE_NORMAL
- en: Tutorial phase variable and the NSUserDefaults key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to know at what point in the tutorial our user is. So, we need to know
    what set of text and options to display. For example, if we create a tutorial
    that uses multiple scenes, we wouldn't have needed a variable, as the scene would
    have indicated which tutorial we were on. However, because we're doing everything
    within the `MainScene` (and because we want to smoothly transition into a regular
    game after the tutorial is over), it's best to use a variable to track how far
    we've gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'So (since we''ll want to access the variable in a later portion), let''s create
    an `@property` variable in `MainScene.h`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s a good tutorial, the user learns the first time they''re going through
    it, so it''s a good assumption to set a "did they finish it?" variable to true
    after they''ve gone through all the steps. This means that we want to record in
    a variable whether or not they''ve finished the tutorial before, so we''re going
    to use `NSUserDefaults` again. Let''s define another key so that we can eliminate
    human errors as well as increase code readability. In `MainScene.h`, declare the
    following key with the rest at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainScene.m`, define the key at the top, with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we want to determine whether or not to show the tutorial. Since we
    have this key storing the determining factor, we can simply read that from `NSUserDefaults`
    and either run the game as normal or begin the tutorial in phase 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in `MainScene.m`, at the bottom of your `init` method, modify the `spawnNewEnemy`
    call to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, to eliminate errors and set ourselves up for easier coding later, we
    define the `showTutorialInstructions` object (the empty body is okay for now;
    we''ll cover that next):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding if-else statement, you see the tutorialPhase being set to either
    0 (not going through the tutorial this time) or 1 (begin the tutorial at phase
    1), based on whether they've finished the tutorial or not. If they haven't, it
    will also spawn a new enemy at the far right with a value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: That's the beginning of our tutorial—setting up the necessary structure. Next,
    we're going to tackle actually displaying some text, depending on what phase of
    the tutorial we're in.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text for each phase (and CCSprite9Slice)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each tutorial phase needs to have its own text. To do that, we''ll just reference
    the tutorial phase variable and assign the text to a label based on what phase
    we''re in. That said, in the `showTutorialInstructions` method that we just created,
    we add the following lines to display our initial phase 1 text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the project. You'll see the text spanning across the top center of the grid.
    But code-wise, there's a lot going on in the block we just added, so let's quickly
    go over the new stuff.
  prefs: []
  type: TYPE_NORMAL
- en: First, we're naming (a tag property in previous versions, but it's now a string)
    the label so that we can access the `CCNode` by searching for it later using the
    `getChildByName` function. Next, we're positioning the label at `z:2`, so we're
    ensuring that it's above everything else (the default is `z:0`, and at most, we
    have our units at `z:1`, so `z:2`, should be good).
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also the `CCSprite9Slice` object, which is most likely new to you.
    If you''ve never heard of a 9-slice (or 9-patch) sprite before, refer to the following
    diagram to learn about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying text for each phase (and CCSprite9Slice)](img/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In short, the central section can scale in any direction, the corners do not
    scale, the top and bottom margins scale horizontally, and the left and right margins
    scale vertically.
  prefs: []
  type: TYPE_NORMAL
- en: You'll require the 9-slice sprite only when you want the margins to scale. In
    any other situation, it's better to use a regular `CCSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to keep our art style consistent, we can use `Unit.pn`g as our
    9-slice sprite, along with a 20 percent margin (the rest is whitespace anyways,
    so this is a good number to go with). Then we'll position it behind the label
    (using `z:-1`) and set the content size to slightly larger than the width and
    height of the label.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using `CCSprite9Slice`, if you want to change the `scale` of the button,
    you must change its `contentSize` value, *not* the scale property.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the margin value (or values) can only go up to a maximum of 0.5 (which
    means 50 percent of the image in any direction).
  prefs: []
  type: TYPE_NORMAL
- en: Now we're actually going to take the tutorial to the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: Advancing the tutorial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just the fact that we have text displayed doesn''t mean we have something impressive,
    as it''s not really a tutorial up to this point. We need to implement the advanced
    portion. So, create a function called `advanceTutorial` as well as `removePreviousTutorialPhase`
    (which will be used to get rid of the previous phases'' text) and edit them like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, we're saying that if we advance to the next tutorial phase, and
    the phase is less than 7, we just show the next tutorial's instructions. Otherwise,
    we simply set the `didFinishTutorial` Boolean to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should include the proper text for each phase so that when we start
    advancing the tutorial phase, we can actually see the progress. So, in the `showTutorialInstructions`
    function, modify the `if` statement to look like the following (which also creates
    and displays a **How to Play** label for the first phase):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the preceding code can also be written in the form of switch-case
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: So that's it! Let's actually take our tutorial ahead so that we can see our
    progress in action as we walk through each phase.
  prefs: []
  type: TYPE_NORMAL
- en: Advancing in all the right places
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have all the functions laid out, all we need to do is call the `advanceTutorial`
    function when we want the next phase to begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first phase will advance once we''ve moved the unit for the first time,
    so in the `moveUnit` function, add the following to the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And hey! While we're at it, we might as well include phase 2, right? After all,
    we're just sliding once in both phases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 3 will end when the enemy coming in from the right is destroyed, so in
    the `handleCollisionWithFriendly` function, you need to add the following method
    call within the if statement shown here. Phase 4 will also end when a unit gets
    destroyed, so we''ll go ahead and include it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is going to be when tutorial phase 5 ends, which is after the user wants
    to make their move but before any unit movements have been calculated. The same
    applies to phase 6, so add the following call to the `advanceTutorial` function
    at the top of the `moveUnit` function. This is because we don''t want to accidentally
    advance the tutorial twice (which is what would happen if we add it at the bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But hold on for a second! We want to ensure the same experience for every person
    in the tutorial. So, just like the way we created a custom unit at the beginning
    of the scene in the `init` method, we''re going to create a custom unit in the
    `moveUnit` function. In your `moveUnit` function, modify this `if` statement to
    create a custom unit when you''re in the corresponding tutorial phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Alright! With this in place, we should have a pretty solid tutorial, but it's
    still kind of clunky, and we can definitely use some polish (coincidentally, that's
    the chapter we're in). So, let's continue to make it the best tutorial that it
    can be.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the previous phases' text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, the old text is just piling up, so let''s clear that up. In the
    `removePreviousTutorialPhase` function, add the following block. It will grab
    the text, rename it (so that there are no naming conflicts by accident), quickly
    fade out the text, and remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There we go! But it still needs more polish. Let's add some graphical elements
    to our tutorial to better explain what we want the user to do.
  prefs: []
  type: TYPE_NORMAL
- en: Fingers pointing the way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text is great, but what about those who can't read English? Or what about those
    who don't understand what we mean by **Drag Friendly Units**? It's best to have
    an image to show what we mean. In this case, we're going to use a small hand with
    the index finger pointing to show a drag motion in the intended direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we''re going to add. Notice the finger (which is being moved to
    the right and fading at the same time), as well as the text above it, which we
    added in the previous section, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fingers pointing the way](img/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our `showTutorialInstructions` method, we want to create a finger that will
    guide the user in the right direction. So, at the bottom of your `showTutorialInstructions`
    method, add the following block of code to create a finger and position it so
    that it points to the center of the middle square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we've named the finger and positioned it at `z:2` (for consistency
    with the rest of our tutorial).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to animate our finger in the direction in which we want our
    users to slide their units. So, right after you''ve added the finger to the scene,
    make a call to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just passed the finger variable directly to the function (as searching
    for a child with a matching name takes up more processing time). Now, all we need
    to do with our finger image is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fade the finger in
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Slide it to the right
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fade it out while it is sliding to the right
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait a bit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reposition the finger
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This seems fairly simple, right? It is, except when we want to sequence all
    of these events. In that case, the code looks fairly convoluted. This is what
    we want the function to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, the finger is going to fade in, slide to the right (while it's
    fading out), then get repositioned, and repeat these actions indefinitely in phase
    1 and phase 3 of the tutorial (the opposite direction for phase 2).
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, we're not done with coding for the entirety of the finger. We must still
    remove it once we wish to advance to the next phase, remember?
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in `removePreviousTutorialPhase`, we''re just going to add a very
    similar removal style to the label, the only difference being that we''ll apply
    it to the finger (and this time, we need to use the search function of `getChildByName`,
    as this function gets called at an undetermined time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And that's it for the finger! We've got ourselves a finger sliding in the direction
    we want, including a nice fade in/out. We also have the text displaying and getting
    removed, advancing text, and so on. The only thing left to do is to make sure
    our users are allowed to move their units only in the direction we want them to.
  prefs: []
  type: TYPE_NORMAL
- en: Rejecting non-tutorial movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our tutorial works as intended only when they move in a specific order. So,
    we need to restrict their initial movements when going through the tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Unit.m`, in the `touchMoved` function, we want to make sure that the unit
    can only begin to be dragged when they''re going in the correct direction in the
    first three phases. So add the following if statement to the `touchMoved` function
    (when the distance is less than `20`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is why we created the `tutorialPhase` object as a property—so that we can
    access the phase from within another class. But what's going on here is essentially
    a check of the tutorial phase, and if it's any one of phase 1, 2, or 3, it does
    another check to see whether `dragDirection` is indicating the correct way. There's
    a second check that's done for phase 2, as it's not allowed to be the unit with
    a value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: If any of this comes out to true, we set `isBeingDragged` to `NO` and the drag
    direction to standing (so that no unexpected behavior happens in phase 2).
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the tutorial! It took a while, but it's not only simple and quick;
    it's also fairly comprehensive, while not affecting the experience of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, once our tutorial ends, it seamlessly flows into a regular game from
    that point. The other advantage is as follows: suppose players lose, don''t finish,
    or hit menu or restart; or the phone dies at some point during the tutorial. When
    they come back, the tutorial will simply start from the beginning, which is good
    and intentional.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key takeaway from the tutorial is to keep it short, save when they've completed
    it, and test all possible "dumb" ways a user could try to mess up the tutorial
    (hence the last part, about rejecting wrong movements).
  prefs: []
  type: TYPE_NORMAL
- en: Sharing on Facebook and Twitter (and more)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing games on social media is very common these days. Our game will not be
    an exception to that. It's not only an effective marketing tool for your game,
    as users promote the game for you on their social media pages, but also a great
    way for engagement to rise, as humans love competition. Being able to share and
    compare their scores (and indirectly compete) makes users want to play the game
    even more, which makes it a win-win situation for both the developers and players.
  prefs: []
  type: TYPE_NORMAL
- en: Using the built-in share feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to integrate Facebook, Twitter, messaging, e-mail, and other
    sharing options is through the `UIActivityView` object. It's the same sharing
    you'll see when you press the button in the bottom-left corner of the photos app.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, all we need to do is tell the `ActivityView` object what we want
    to display and what activity types we want to exclude, and then present the view
    controller over the `CCDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create the **Share** button.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Share button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `GameOverScene.m`, add the following block of code to the `initWithScoreData`
    method. This will create a **Share** button at the bottom center of our game over
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the method that the share button will call when it is pressed
    (this must be added now, or else the game will crash when you reach `GameOverScene`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Run the game, and when you get to the game over screen, you'll see the share
    button in the bottom center. Right now, it doesn't do anything, so let's display
    the activity view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a variable for the current score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need a way to track the player's current score and the score of the most
    recent play. Even though we can pass that information to the game over scene,
    unless we store that value in an instance variable, we won't be able to use it
    in our sharing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in `GameOverScene.h`, add a variable for the current score, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `initWithScoreData` method, we add the following line so that
    we can grab the total score that was passed to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to actually use the score in the text that we share.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UIActivityView object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `openShareView` method you just created, add these few lines of code
    (explanation afterwards):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First comes the text that we're going to display. We need to keep it short for
    a few reasons. The most important reason is that Twitter allows only 140 characters,
    so we need to make sure we don't cross that. The second reason is that our potential
    future players might not read it if it's longer than a sentence or two. Finally,
    we want the *generic message* that's going to be sent to at least feel personal.
    It has to be like reading a conversation between two best friends.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the link to the App Store, which also takes in the app's ID. Notice
    the `appID` variable is just `1` through `9`. This isn't the exact app ID at the
    moment (not even for the book's project), so what we're going to do is modify
    this line of code when we create the app in iTunes Connect (or if you already
    have an app created, you can use that app ID now).
  prefs: []
  type: TYPE_NORMAL
- en: After that is the array of objects to be included in the share. Simply add them
    to an array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create the `UIActivityViewController` object with the `objectsToShare`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: But it's not yet displaying anything, so let's handle that.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying UIActivityViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you''ve initialized the `activityVC` variable in the `openShareView`
    method, add the following block of code. It will ensure that the activity view
    doesn''t show certain activities, and then present the view controller over the
    shared `CCDelegate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since we don't want the user to print anything, assign anything to a contact,
    or add it to their reading list (Flickr, Vimeo, and so on), we need to exclude
    these activities, which basically means they won't show up on the view that appears
    when the user taps the share button.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a list of all the possible `UIAcitivityTypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UIActivityTypeAddToReadingList;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypeAirDrop;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypeAssignToContact;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypeCopyToPasteboard;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypeMail;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypeMessage;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypePostToFacebook;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypePostToFlickr;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypePostToTencentWeibo;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypePostToTwitter;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypePostToVimeo;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypePostToWeibo;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypePrint;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIActivityTypeSaveToCameraRoll;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, for your own projects, feel free to include or exclude as many or as few
    of these as you wish. For example, if you're sharing a video, you can very easily
    allow Vimeo or saving the photos.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! If you run the game at this point and click on the **Share** button,
    you'll see the activity view pop up, along with the various buttons for messaging,
    e-mail, Facebook, and Twitter. Clicking on any of these will load the respective
    view, along with the message and URL that was added.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When adding this to your own project, the key thing to note is the exclusion
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the final version looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying UIActivityViewController](img/image00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a screenshot to the share
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though we're adding some text and including a link to the game on the App
    Store, we should probably also include a screenshot because it's more likely someone
    will at least check out the game if there's a screenshot attached.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, we don't really want a screenshot from the game over screen,
    so we'll have to grab a screenshot of the game right before we transition to `GameOverScene`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open up `MainScene.m` and add the following method. It will take a screenshot
    of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `endGame` method, let''s call the preceding method and store it
    in a local variable so that we can pass it to the `GameOverScene` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice the addition of the `@"screenshot"` key to the `scoreData` dictionary.
    This will pass our `UIImage` so that we can grab it in `GameOverScene`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `GameOverScene.h`, add a variable for the screenshot, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in our `initWithScoreData` method in `GameOverScene.m`, we want to store
    the screenshot in the variable from the dictionary using the `@"screenshot"` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our `openShareView` method of the game over scene, all we need
    to do is add the screenshot variable to the `objectsToShare` array, and it will
    be automatically included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! By running the game now and getting to the share button, you'll
    see the image, whether you share via Facebook, Twitter, messages, or e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you really want to get fancy, you can allow users to save the image just
    in case they want to keep it for their own records. To do that, just remove the
    `SaveToCameraRoll` option from the exclusion array in the `openShareView` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what your game looks like with the screenshot added (sharing via Facebook):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a screenshot to the share](img/image00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Turning sounds on and off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, we have sound effects and music playing all the time no matter what.
    Even though you might be someone who enjoys listening to sounds or music, when
    you design your games (as it's definitely an element that increases user engagement),
    you would want to be open to the fact that people just don't like to hear any
    sound at times. Thus, we must give them the option to turn the sound on and off.
  prefs: []
  type: TYPE_NORMAL
- en: No options or settings? Main menu it is!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we don't have a pause screen, options, settings, or anything similar,
    we're going to add the buttons to turn the sound on and off to the main menu.
    This means that a lot less code is required to add the buttons, instead of creating
    an entirely new scene exclusively for them. This arrangement also stays consistent
    with the clean feel of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to make a pause screen and add these two buttons to it, then go
    ahead by all means. The code, however, will be slightly different from what will
    be described here because if you push a `CCScene` instead of replace (which essentially
    allows you to pause the game while going to a new scene temporarily), and then
    pop off the scene that you pushed (in other words, resume the paused game), you
    need to make sure that the correct variables get set to false.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we're going to create the sound and music on/off buttons in the main
    menu. These are going to be a bit different from normal buttons because instead
    of just a normal button press, they're going to need to swap between the on and
    off states.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MenuScene.m`, let''s create the initial buttons in the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to make sure we create the methods that the buttons will be calling
    when they''re pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Running the game at this point will result in what is shown in the following
    screenshot. If you press either of the buttons, they will switch between each
    other, and if you exit and come back, the buttons will be reset to their original
    state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the buttons](img/image00270.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we need to do to grab (and store) the sound and music variables is make
    use of `NSUserDefaults`, just as we did in the past. To remove any user error
    when coding, we want to define constants for our dictionary keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `MainScene` has been imported into all of our classes, we can safely
    define the constant there. So, open `MainScene.h` and add the following code to
    the top of the file, along with the other constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `MainScene.m`, add this code at the top of the file with the rest
    of the constants so that they are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now we're able to grab the data that's been stored as well as efficiently save
    any values if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: Grabbing the sound and music Boolean from NSUserDefaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to store the data in a variable so that we don't have to read and write
    again and again from `NSUserDefaults`, and can do so only when we really need
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in `MainScene.h`, add two Boolean variables for sound on/off and
    music on/off, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after you''ve added the buttons to the scene in the `init` method of
    `MainScene.m`, read the sound and music values from `NSUserDefaults` using the
    keys you just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to actually tell the sound and music buttons whether or not they
    should show their **X** mark or check mark. To do so, we''ll just set the selected
    value to whatever the opposite of the variable is. That''s because if the sound
    is not on, we want to show the selected version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This works, but there's no way to test it, so let's actually modify the values
    when the respective buttons are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and saving the values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `soundToggle` method, we''re going to set the `isSoundOn` variable to
    the opposite of itself (toggle it on and off). Right after that, we''re going
    to set (and save) its value to the key we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''re going to do the same for the `isMusicOn` variable in the `musicToggle`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, you'll be able to switch between the true/false variables
    of the sound and music, and when you either go to another scene and come back,
    or exit the game and come back, the values will be retained from whatever you
    last set them to. But it's still not pausing the music or turning off the sound,
    so let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing/resuming background music and sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the background music is playing when the music button is pressed, we'll need
    to pause it, and vice versa for when it's not playing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s go to the `musicToggle` method and add a check for the `isMusicOn`
    variable. If it is enabled, we can play the background music. Otherwise, we''ll
    just pause the music until the user turns it on again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we''ll also add a check to see whether the `isSoundOn` is enabled.
    If it is, we''ll play the `buttonClick` sound effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to do the same for the `toggleSound` method as well as the `goToGame`
    method, both of which are methods that get called when a button is pressed. Therefore,
    we are going to play a button click sound effect (only if the sound is enabled):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: For `MenuScene`, all is done! If you press the music button and/or the sound
    button, you'll notice the effects turning on and off, just as intended. Now that
    we have handled `MenuScene`, let's go for every other location where we'll be
    playing the sound effects (and starting the music).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, you can create a class that has methods for starting and stopping
    the background music, playing certain sound effects, and playing the button click,
    all using `OALSimpleAudio`.
  prefs: []
  type: TYPE_NORMAL
- en: Then you can locate and replace all the instances of `OALSimpleAudio` with your
    own custom class.
  prefs: []
  type: TYPE_NORMAL
- en: Handling MainScene sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have sound effects and music playing in just about every class of this
    game, we need to make sure they play only when the corresponding value is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for starters, let''s open `MainScene.h` and add a similar variable for a
    sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `init` method, make sure you grab the values from `NSUserDefaults`:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also make sure you set the `isSoundOn` variable in the `init` method before
    you attempt to play any sound effect. If you assign the value afterwards, you
    may experience unintended results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainScene.m`, search for `OALSimpleAudio`, and go to every instance of
    it, adding the following `if` statement above it so that the sound effect plays
    only when that particular sound is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There should be two in `playUnitCombineSound`, one in `goToMenu`, one in `restartGame`,
    and one in `moveUnit`. Obviously, if you have more sound effects playing, then
    you should add them there as well, but these are the five that are present at
    this point.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating for GameOverScene (and any other scenes)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s basically the same as `MainScene`, so there won''t be too much explanation.
    But all you really need to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `isSoundOn` variable in `GameOverScene.h`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the value in the `init` method from `NSUserDefaults`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the if statement before every sound effect that gets played
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this is your only other scene, move on to `AppDelegate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling AppDelegate music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to make sure the music doesn't randomly start playing when users first
    load the game if they had decided to turn it off in a previous version.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in `AppDelegate.m`, add the following if statement before the call to the
    `playBgWithLoop` method. Note that we don''t need to store it in a variable because
    we''re going to use it only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Making sure that sound/music starts enabled
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the things we want to make sure of is that the sound and music start
    as enabled when the user starts the game. By default, any Boolean in `NSUserDefaults`
    is false. Therefore, we need to make sure that both get set to true before the
    game starts, but only on the first time they run the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in `AppDelegate.m`, at the very beginning of `startScene`, let''s add code
    to check whether they''ve played before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! It took a little bit of careful planning to make sure we handled
    every case that the user could run into, but that's the entire point of polishing
    your game—making sure that no matter what your user does or can do, the game responds
    appropriately and as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key takeaways from adding on/off settings for sound and music are as follows:
    storing the value in the `NSUserDefaults`, grabbing that value from a local variable
    in each scene, and using that variable to determine whether you should play a
    sound effect or not. If you want to be sure you''ve gotten all the instances,
    look up the project for `OALSimpleAudio` and go through all the classes you''ve
    created.'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you check for the variable for any future sound effects you add.
  prefs: []
  type: TYPE_NORMAL
- en: Game Center leaderboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already got a set of top 20 high scores that are stored on the user's
    device, so why not make a global leaderboard? In fact, even though many players
    don't use Game Center when they play games, it is yet another element that drives
    engagement. Plus (and this is the really cool part)—if you didn't know already—you
    can actually have players rate your game within Game Center. It's not even an
    extra feature or anything, as they can just tap the star count at the top of the
    leaderboard or achievement pane and it'll send the rating to the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a leaderboard to display in our game isn't just about code, so we have
    to create the leaderboard in iTunes Connect first. Before we can create the app
    in iTunes Connect, we need to set up an App ID.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the App ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, if you wish to add a leaderboard, you must sign up for an Apple
    developer account if you don't have one already. In [Chapter 1](part0014.xhtml
    "Chapter 1. Refreshing Your Cocos2d Knowledge"), *Refreshing Our Cocos2d Knowledge,*
    the signup process was explained. Otherwise, if you're just following along for
    practice, feel free to do so, but you cannot create leaderboards or achievements
    without a developer account.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create the App ID from the developer website. Go to [https://developer.apple.com/devcenter/ios/index.action](https://developer.apple.com/devcenter/ios/index.action)
    and log in to your Apple account that has the iOS developer license on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged in, under **iOS Dev Center**, go to the **Certificates, Identifiers
    & Profiles** section, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the App ID](img/image00271.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, go to the **Identifiers** section so that we can create an App ID,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the App ID](img/image00272.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then begin to create an App ID by clicking on the **+** button in the top-right
    corner. Here, we need to enter a name for the App ID, the name of the bundle identifier
    (which is generally reverse DNS notation; for example, [www.keitgames.com](http://www.keitgames.com)
    might have `com.keitgames.mygame` as the bundle ID), as well as any services we
    want (which we''ll leave as the default for now). This is shown in the following
    screenshot for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the App ID](img/image00273.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure you use your own bundle identifier (the preceding screenshot simply
    shows an example and where it all goes).
  prefs: []
  type: TYPE_NORMAL
- en: Once that's done, click on **Continue** and then on **Submit**. Then the App
    ID should be created.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the Xcode project's settings, select the iOS target and update the
    bundle identifier to the one you just created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the App ID](img/image00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that the bundle ID and App ID are set up, we can create the app in iTunes
    Connect, and it will allow us to set up and test our leaderboards.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the app in iTunes Connect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the app in iTunes Connect is relatively simple, and is only going to
    be used as a wireframe so that we can create the leaderboards. In the next chapter,
    we'll cover all the details; for now you just need to know that the only reason
    we're setting it up in iTunes Connect now (instead of later) is for the purpose
    of setting up a leaderboard.
  prefs: []
  type: TYPE_NORMAL
- en: First, go to [https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa](https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa)
    and sign in to your developer account. Then click on **My Apps**, create a new
    app by clicking on the **+** button in the top-left corner, and click on **New
    iOS App**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the app in iTunes Connect](img/image00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then fill in the information it asks, including the App ID you created earlier.
    The SKU doesn't really matter, as it's for your own internal use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the app in iTunes Connect](img/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the app has been created in iTunes connect, click on **Game Center**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the app in iTunes Connect](img/image00277.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When it asks whether it's for a single game or multiple games, that's up to
    you to decide when creating projects on your own. But for the purpose of this
    book's project, we're going to create it for a single game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the app in iTunes Connect](img/image00278.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After that, you'll be taken to the Game Center setup screen, and you're ready
    to move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the leaderboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the Game Center setup section within iTunes Connect, click on the **Add
    Leaderboard** button and then on **Single Leaderboard**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the leaderboard](img/image00279.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The leaderboard reference is for internal use within iTunes Connect, just in
    case you wish to search for it (or know at a glance which leaderboard it is).
    The **Leaderboard ID** will be used within the code, so it should be something
    unique and distinct from your other leaderboards (if you've created any). The
    score format is only whole numbers, so we'll use the **Integer** format. We want
    only the best score to be submitted (as only one score per person can exist in
    a leaderboard) and sorted from High to Low. Finally, we want the range to be from
    0 to 999,999\. Technically, we don't have to set this, but we're going to anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add a language. Here''s an example showing **English**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the leaderboard](img/image00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Name** is the title at the top of the leaderboard that the users will
    see, so we want it to be obvious which leaderboard it is. The **Score Format**
    is the same as what you just saw. The **Score Format Suffix** works as follow:
    since we have **Points**, a score of 625 will look like **625 Points** in the
    leaderboard. If you think it would look weird to include the word **Points** in
    every score, feel free to leave it out, but for now, we''re going to have it in
    there.'
  prefs: []
  type: TYPE_NORMAL
- en: Once all of this information has been entered, click on **Save** at the bottom.
    And voilà! It's created! What comes next is coding the Game Center login, authentication,
    leaderboard presentation, submitting the score, and everything else that comes
    with handling Game Center.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GameKit framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we do any coding, we need to include the GameKit framework in our project.
    So, in your project''s settings, go to the **iOS target**, then go to **Build
    Phases**, and in the **Link Binary With Libraries** section, click on the **+**
    button to add a framework to the project, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the GameKit framework](img/image00281.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then, search for `gamekit` (case insensitive), click on the `GameKit.framework`
    result, and then click on **Add**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the GameKit framework](img/image00282.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And we're done! Now we're ready to code.
  prefs: []
  type: TYPE_NORMAL
- en: GameKit helper files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of simplicity, you can just copy the `GKHelper` files to your project
    (make sure you have the **Copy** checkbox selected). It's not that coding the
    Game Center stuff is hard—it's the same for literally every project that has Game
    Center. So why waste time manually typing the code when you can just have the
    files ready?
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, what the `GKHelper` singleton class does is manage your `GKLocalPlayer`
    (the currently logged-in user in Game Center on the device), any calls to and
    from the server, and any leaderboard score posting and achievement tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GKHelper` class was created using the online tutorial [http://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6](http://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6),
    if you're looking for more explanation. There is another guide at [http://www.appcoda.com/ios-game-kit-framework/](http://www.appcoda.com/ios-game-kit-framework/%20)
    that covers Game Center in depth. Refer to it if you're getting stuck, or still
    need extra help (as it can be confusing for those new to coding Game Center).
  prefs: []
  type: TYPE_NORMAL
- en: '*This is important*: Suppose you''re getting this error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you must go to device **Settings** | **Game Center** and enable **Sandbox**,
    as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GameKit helper files](img/image00283.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Authenticating the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that everything is in place, created, and ready for use, we can begin to
    code the actual leaderboard and make it appear when users sign in to Game Center.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to authenticate the local player; that is, have them sign in
    if they aren't signed in already, or just send a request for the `GKLocalPlayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to do this at the beginning of our app, so in `AppDelegate.m`,
    import the `GKHelper.h` file and add the following method call to the top of the
    `startScene` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If everything was done correctly, when you run the game at this point, you should
    see a banner going across the top of your screen welcoming the currently logged-in
    player. If not, it will ask them to log in.
  prefs: []
  type: TYPE_NORMAL
- en: If you're getting an error message that says something along the lines of a
    requested operation being cancelled or disabled, go to the **Settings** app and
    then to **Game Center**. Try either logging in and out again, or enabling the
    **Sandbox** mode at the bottom (see the preceding screenshot). This should fix
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Game Center button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want a button for access to the leaderboards and other Game Center stuff,
    so in the **GameOverScene.m** file''s `init` method, add the following code. It
    will create a button in the bottom-right corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to display the leaderboards, and this requires the `GKHelper`,
    so at the top of `GameOverScene.m`, import the `GKHelper.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the `viewGameCenter` method, which is simply a call for presenting
    the leaderboards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game at this point and get to the game over scene, you'll see
    a button for **Game Center** in the bottom-right corner, and when clicked on (and
    if you're signed in to Game Center), it'll open the leaderboard. The only thing
    left to do now is to submit the score to Game Center so it can be seen in the
    leaderboard.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting the score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our `GKHelper` class can do all of the score reporting for us, all we
    need to do is call the respective function. Since we know `GameOverScene` will
    contain the total score from the most recent game, we can use the passed-in dictionary
    as the score value we submit to the leaderboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the `init` method of `GameOverScene.m`, add a call to the `submitScore`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! It took a while to set up, and about 10 lines of code, but we
    have a global leaderboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: You may want to implement achievements, but that code has not been implemented
    in the `GKHelper` class yet, so unfortunately, you're on your own. Although this
    is not too difficult, it wasn't necessary for this game, so it was skipped. As
    linked earlier, there's a great resource at [http://www.appcoda.com/ios-game-kit-framework/](http://www.appcoda.com/ios-game-kit-framework/)
    that explains how to implement achievements. It was written in March 2014, so
    the code should still work by the time you read this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While implementing leaderboards, if you ever run into an issue, make sure that
    everything, from the iTunes Connect setup to the Game Center to **Sandbox** mode
    and the code itself, is all in line. Game Center can be tricky and annoying. It's
    gotten better over the years, but can still be a bit finicky. If you're still
    having issues, it's likely that you're not the only one. A great place to start
    searching is Stack Overflow. If you aren't familiar with the site, don't worry.
    They have a question-and-answer format where tons of people have asked questions
    about code and other issues, and many more have given correct answers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that's it for Game Center! The last thing to do to polish our project includes
    creating a custom transition between scenes to make the game feel more robust,
    instead of just instantly shifting back and forth between scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Slide transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it's fine for testing purposes, instant transitions between our scenes
    (as well as the game suddenly showing up when it first loads) are bad. We're going
    to add a nice quick slide between each scene. In other words, when the user taps
    a button or an event happens that's supposed to replace the scene with a new scene,
    we're going to make it seem as if all the scenes are on one giant white sheet,
    just out of view of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a generic slide function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we're going to be doing this all over the place, we need a function that's
    generic enough for us to pass to it any scene from any location, and it will do
    exactly what we want it to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'So again, since `MainScene.h` is imported everywhere, we''re going to create
    our generic function in it. Open `MainScene.h` and add this enumeration above
    the `@interface` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to tell the generic function in which direction to slide
    our scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, add the following method declaration in `MainScene.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The parameters this method takes are the scene you want to transition to, the
    parent (the scene you're currently on), how long you want the slide to last, and
    in what direction you want the slide to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `MainScene.m`, add the actual function. It will slide our scene into
    the view and then replace it with `CCDirector` (the detailed explanation is in
    the comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: However, since we're moving the scenes slightly off screen in one direction
    or another, we need to make sure we have enough "background" to cover the extras.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the top of our `MainScene.m` files `init` method, we change our declaration
    of the background to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `z` value is set to `-2` so that we can place the new scene at `-1` (as
    seen in preceding code). Thus, even though the background is five times the width
    and the height of the screen, the new scene will still be visible when it slides
    into the view.
  prefs: []
  type: TYPE_NORMAL
- en: Now the only thing left to do is to actually call the function.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the scene with a rubber band transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because we made such a convenient generic function, we don''t need to do anything
    besides calling it once. So in `MainScene.m`, modify your `goToMenu` function
    to call the `rubberBandToScene` method you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Also modify the same line in the `endGame` method in `MainScene.m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the one going to the menu is `DirectionDown`, whereas the `endGame`
    object is `DirectionUp`. Now run the game and press that **Menu** button. Beautiful
    isn't it? But that's just one of the many scene transitions we have. So let's
    handle the rest, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Transition in MenuScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we click on the **Play** button, we''d ideally want the same effect, so
    we first need to create the extra-large background. In `MenuScene.m`, modify the
    background code to look like `MainScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `goToGame` function, we simply make a call to the generic function
    we made previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Transition in GameOver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've gotten the to-menu and to-gameover transitions into the main game
    scene. We've also implemented the to-game transition in the main menu scene. The
    only thing left to do is to put the transition for to-menu and to-game in the
    `GameOverScene`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you can do in `GameOverScene.m` what you''ve been doing so far,
    and modify the `replaceScene` line of code in the `goToMenu` and `restartGame`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! We've managed to not only create a custom transition (compared
    to the rather boring transitions that Cocos2d version 3.0+ comes with) but also
    implement it with ease. It adds just that bit of the "Whee! This is fun!" factor,
    which is a good thing because it's what the players will be feeling. Happy players
    means higher engagement, and higher engagement means higher ratings and more referrals
    to their friends (which means more money in your pocket).
  prefs: []
  type: TYPE_NORMAL
- en: Other ideas for polishing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some other ideas for polishing that weren''t covered in this chapter are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Smoother animation for characters or units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fluid movements (such as the Bézier effect, as covered in the previous chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No loading screen (ending the current scene looking exactly like how the next
    scene will begin, and transitioning instantly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No crashes (yes, fix all of them)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtle details such as background movement or brief NPC voice-overs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the user's spot in case of an interruption (phone call, battery dead,
    and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But these are just a few examples. There's a million little things you could
    do to your game to make it ever so slightly better, but alas! At some point, we
    need to release the game, so that's what the next chapter is going to focus on—adding
    the finishing touches and submitting the game to Apple.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned various ways to polish your game and really focus
    on some subtle, but important, elements such as on/off buttons for sound and music,
    sliding between scenes, and the social sharing feature.
  prefs: []
  type: TYPE_NORMAL
- en: There's always something that can be tweaked and tuned to make it more polished.
    For example, if you wish to learn more about more traditional sprite animations,
    you can do so using `CCAnimation`. There's a great reference guide for this at
    [http://www.cocos2d-swift.org/docs/api/Classes/CCAnimation.html](http://www.cocos2d-swift.org/docs/api/Classes/CCAnimation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that as of now, we still haven't come up with a name for the game. Although
    the name is something that all users will see and familiarize themselves with,
    it's not important for the development of the game, which is why it's coming last.
  prefs: []
  type: TYPE_NORMAL
