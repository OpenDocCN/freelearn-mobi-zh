- en: Chapter 8. Polishing to a Shine – HUD, Parallax Backgrounds, Particles, and
    More
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 精益求精——HUD、垂直背景、粒子效果等
- en: Our core gameplay mechanics are in place; now we can improve the overall user
    experience. We will turn our focus to the non-gameplay features that make our
    games shine. To start, we will add a heads-up display (**HUD**) to display the
    player's health and coin count. Then, we will implement multiple layers of parallax
    background to add depth and immersion to the game world. We will also explore
    SpriteKit's particle system, and use a particle emitter to add production value
    to the game. Combined, these steps will add to the fun of the gameplay experience,
    invite the player deeper into the game world, and impart a professional, polished
    feeling to our app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的核心游戏机制已经就绪；现在我们可以提高整体的用户体验。我们将把重点转向使我们的游戏更加出色的非游戏功能。首先，我们将添加一个抬头显示（**HUD**）来显示玩家的生命值和金币计数。然后，我们将实现多层垂直背景，为游戏世界增加深度和沉浸感。我们还将探索SpriteKit的粒子系统，并使用粒子发射器为游戏增加制作价值。这些步骤的结合将增加游戏体验的乐趣，邀请玩家更深入地进入游戏世界，并给我们的应用带来专业、精致的感觉。
- en: 'The topics in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下内容：
- en: Adding a HUD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加HUD
- en: Parallax background layers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直背景层
- en: Using the particle system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用粒子系统
- en: Granting safety as the game starts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开始时提供安全保障
- en: Adding a heads-up display
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加抬头显示
- en: Our game needs a HUD to show the player's current health and coin score. We
    can use hearts to indicate health – like classic games in the past – and draw
    text to the screen with `SKLabelNode` to display the number of coins collected.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏需要一个HUD来显示玩家的当前生命值和金币分数。我们可以用心形来表示生命值——就像过去的一些经典游戏一样——并使用`SKLabelNode`在屏幕上绘制文本以显示收集到的金币数量。
- en: We will attach the HUD to the scene itself, instead of to the `world` node,
    since it does not move as the player flies forward. We do not want to block the
    player's vision of upcoming obstacles to the right, so we will place the HUD elements
    in the top left corner of the screen.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把HUD附加到场景本身，而不是`world`节点，因为它不会随着玩家向前飞行而移动。我们不希望阻挡玩家对右侧即将到来的障碍物的视线，因此我们将HUD元素放置在屏幕的左上角。
- en: 'When we are finished, our HUD will look like this (after the player collects
    110 coins and sustains one point of damage):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们的HUD将看起来像这样（在玩家收集了110个金币并受到一点伤害后）：
- en: '![Adding a heads-up display](img/Image_B04532_08_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![添加抬头显示](img/Image_B04532_08_01.jpg)'
- en: 'To implement the HUD, follow these steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现HUD，请按照以下步骤操作：
- en: First, we need to add the HUD art assets into the game. In the asset pack, find
    the `HUD.atlas` texture atlas and add it to your project.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将HUD艺术资源添加到游戏中。在资源包中找到`HUD.atlas`纹理图集并将其添加到项目中。
- en: 'Next, we will create a `HUD` class to handle all of the HUD logic. Add a new
    Swift file to your project, `HUD.swift`, and add the following code to begin work
    on the `HUD` class:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`HUD`类来处理所有的HUD逻辑。向项目中添加一个新的Swift文件`HUD.swift`，并添加以下代码以开始对`HUD`类的工作：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need an initializer-style function to create a new `SKSpriteNode` for each
    heart shape and configure the new `SKLabelNode` for the coin counter. Add a function
    named `createHudNodes` to the `HUD` class, as follows:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个初始化风格的函数来为每个心形创建一个新的`SKSpriteNode`，并为金币计数配置新的`SKLabelNode`。向`HUD`类添加一个名为`createHudNodes`的函数，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need a function that the `GameScene` class can call to update the coin
    counter label. Add a new function to the `HUD` class named `setCoinCountDisplay`,
    as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个函数，使得`GameScene`类可以调用以更新金币计数标签。向`HUD`类添加一个名为`setCoinCountDisplay`的新函数，如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will also need a function to update the heart graphic when the player''s
    health changes. Add a new function to the `HUD` class named `setHealthDisplay`,
    as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来更新玩家生命值变化时的心形图形。向`HUD`类添加一个名为`setHealthDisplay`的新函数，如下所示：
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our `HUD` class is complete. Next, we will wire it up in the `GameScene` class.
    Open `GameScene.swift` and add a new property to the `GameScene` class, instantiating
    an instance of the `HUD` class:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`HUD`类已经完成。接下来，我们将在`GameScene`类中连接它。打开`GameScene.swift`文件，并向`GameScene`类添加一个新属性，实例化`HUD`类的一个实例：
- en: '[PRE4]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to place the `HUD` node into the scene, on top of the other game objects.
    Add this code at the bottom of the `GameScene didMoveToView` function:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`HUD`节点放置到场景中，位于其他游戏对象之上。在`GameScene didMoveToView`函数的底部添加以下代码：
- en: '[PRE5]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are ready to send health and coin updates to the `HUD`. First, we will update
    the `HUD` with health updates when the player takes damage. Inside the `GameScene
    didBeginContact` function, locate the contact cases where the player takes damage
    – when he or she touches the ground or an enemy – and add this new code (in bold),
    to send health updates to the `HUD`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备向 `HUD` 发送健康和金币更新。首先，当玩家受到伤害时，我们将使用健康更新来更新 `HUD`。在 `GameScene didBeginContact`
    函数内部，找到玩家受到伤害的接触情况——当他或她接触地面或敌人时——并添加以下（粗体）新代码，以向 `HUD` 发送健康更新：
- en: '[PRE6]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we will update the `HUD` whenever the player collects a coin. Locate
    the contact case where the player contacts a coin and call the `HUD setCoinCountDisplay`
    function (new code in bold) as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，每当玩家收集到一个金币时，我们将更新 `HUD`。找到玩家接触金币的接触情况，并调用 `HUD setCoinCountDisplay` 函数（粗体新代码）如下：
- en: '[PRE7]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the project and you should see your coin counter and health meter appear
    in the upper left hand corner, as seen in this screenshot:![Adding a heads-up
    display](img/Image_B04532_08_02.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目，你应该会看到你的金币计数器和健康仪表出现在左上角，如这个截图所示：![添加抬头显示](img/Image_B04532_08_02.jpg)
- en: Great job! Our HUD is complete. Next, we will build our background layers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们的 HUD 已经完成。接下来，我们将构建我们的背景层。
- en: Parallax background layers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视差背景层
- en: Parallax adds the feeling of depth to your game by drawing separate background
    layers and moving them past the camera at varying speeds. Very slow backgrounds
    give the illusion of distance, while fast moving backgrounds appear to be very
    close to the player. We can enhance the effect by painting faraway objects with
    increasingly desaturated colors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制单独的背景层并将它们以不同的速度移动过相机，视差为你的游戏增加了深度感。非常慢的背景给人一种距离感，而快速移动的背景看起来似乎非常接近玩家。我们可以通过用越来越不饱和的颜色绘制远处的物体来增强效果。
- en: In our game, we will achieve the parallax effect by attaching our backgrounds
    to the world, then slowly pushing the backgrounds to the right as the world moves
    left. As the world moves to the left (bringing the backgrounds with it), we will
    move the background's *x* position to the right so that the total movement is
    less than for the normal game objects. The result will be background layers that
    appear to move more slowly than the rest of our game, and thus appear farther
    away.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将通过将背景附加到世界并随着世界向左移动而缓慢地将背景推向右侧来实现视差效果。当世界向左移动（带着背景一起移动）时，我们将背景的 *x*
    位置向右移动，以便总移动距离小于正常游戏对象。结果将是背景层看起来比游戏中的其他部分移动得更慢，因此看起来更远。
- en: In addition, each background will only be 3000 points wide, but will jump forward
    at precise intervals to loop seamlessly, in a similar way to the `Ground` class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个背景将只有 3000 点宽，但将在精确的间隔内向前跳跃以无缝循环，类似于 `Ground` 类。
- en: Adding the background assets
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加背景资源
- en: 'First, add the art by following these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤添加艺术作品：
- en: Open your project's `Images.xcassets` file in Xcode.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xcode 中打开你项目中的 `Images.xcassets` 文件。
- en: In the provided game assets, locate the four background images in the `Backgrounds`
    folder.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的游戏资源中，在 `Backgrounds` 文件夹中找到四个背景图像。
- en: Drag and drop the four backgrounds into the left pane of the `Images.xcassets`
    file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个背景拖放到 `Images.xcassets` 文件的左侧面板中。
- en: 'You should see the backgrounds appear in the left pane as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到背景如这里所示出现在左侧面板中：
- en: '![Adding the background assets](img/Image_B04532_08_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![添加背景资源](img/Image_B04532_08_03.jpg)'
- en: Implementing a background class
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现背景类
- en: 'We will need a new class to manage the repositioning logic for parallax and
    seamless looping. We can instantiate a new instance of a `Background` class for
    each background layer. To create the `Background` class, add a new Swift file,
    `Background.swift`, to your project, using the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新类来管理视差和无缝循环的重定位逻辑。我们可以为每个背景层实例化一个 `Background` 类的新实例。要创建 `Background`
    类，请将一个新的 Swift 文件 `Background.swift` 添加到你的项目中，使用以下代码：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Wiring up backgrounds in the GameScene class
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GameScene 类中连接背景
- en: 'We need to make three code additions to the `GameScene` class to wire up our
    backgrounds. First, we will create an array to keep track of the backgrounds.
    Next, we will spawn the backgrounds as the scene begins. Finally, we can call
    the `Background` class `updatePosition` function from the `GameScene didSimulatePhsyics`
    function to reposition the backgrounds before every frame. Follow these steps
    to wire up the backgrounds:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`GameScene`类中添加三个代码修改来连接我们的背景。首先，我们将创建一个数组来跟踪背景。接下来，当场景开始时，我们将生成背景。最后，我们可以从`GameScene
    didSimulatePhsyics`函数中调用`Background`类的`updatePosition`函数，以便在每一帧之前重新定位背景。按照以下步骤连接背景：
- en: 'Create a new array property on the `GameScene` class itself to store our backgrounds,
    as shown here:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene`类本身上创建一个新的数组属性来存储我们的背景，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At the bottom of the `didMoveToView` function, instantiate and spawn our four
    backgrounds:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`didMoveToView`函数的底部，实例化和生成我们的四个背景：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, add the following code at the bottom of the `didSimulatePhysics` function
    to reposition the backgrounds before each frame:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`didSimulatePhysics`函数的底部添加以下代码，以便在每一帧之前重新定位背景：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the project. You should see the four background images as separate layers
    behind the action, moving past with a parallax effect. This screenshot shows the
    backgrounds as they should appear in your game:![Wiring up backgrounds in the
    GameScene class](img/Image_B04532_08_04.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目。您应该看到四个背景图像作为单独的层在动作后面移动，并带有视差效果。此截图显示了背景在您的游戏中应该出现的样子：![在GameScene类中连接背景](img/Image_B04532_08_04.jpg)
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are using the iOS simulator to test your game, it is normal to experience
    a lowered frame rate after adding these large background textures to the game.
    The game will still run well on iOS devices.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用iOS模拟器测试您的游戏，在向游戏中添加这些大型背景纹理后，帧率降低是正常的。游戏仍然可以在iOS设备上良好运行。
- en: Excellent! You have successfully implemented your background system. The background
    makes Pierre Penguin's world feel full, adding immersion to the game. Next, we
    will use a particle emitter to add a trail behind Pierre – a fun addition that
    helps the player master the controls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经成功实现了你的背景系统。背景让皮埃尔的企鹅世界感觉更加完整，增加了游戏的沉浸感。接下来，我们将使用粒子发射器在皮埃尔飞行时在其身后添加一条轨迹——这是一个有趣的添加，有助于玩家掌握控制。
- en: Checkpoint 8-A
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点8-A
- en: 'To download my project to this point, visit this URL:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载到这一点的项目，请访问此URL：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-8](http://www.thinkingswiftly.com/game-development-with-swift/chapter-8)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-8](http://www.thinkingswiftly.com/game-development-with-swift/chapter-8)'
- en: Harnessing SpriteKit's particle system
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用SpriteKit的粒子系统
- en: SpriteKit includes a powerful particle system that makes it easy to add exciting
    graphics to your game. Particle emitter nodes create many small instances of an
    image that combine together to create a great-looking effect. You can use emitter
    nodes to generate snow, fire, sparks, explosions, magic, and other useful effects
    that would otherwise require a lot of effort.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit包含一个强大的粒子系统，这使得向游戏中添加令人兴奋的图形变得容易。粒子发射器节点创建了许多图像的小实例，这些实例组合在一起创建了一个看起来很棒的效果。您可以使用发射器节点生成雪、火、火花、爆炸、魔法和其他有用的效果，这些效果在其他情况下可能需要大量的工作。
- en: For our game, you will learn to use an emitter node to create a trail of small
    dots behind Pierre Penguin as he flies, making it easier for the player to learn
    how their taps influence Pierre's flight path.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，您将学习如何使用发射器节点在皮埃尔企鹅飞行时在其身后创建一条小点轨迹，这使得玩家更容易了解他们的点击如何影响皮埃尔的飞行路径。
- en: 'When we are finished, Pierre''s dot trail will look something like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，皮埃尔的轨迹将看起来像这样：
- en: '![Harnessing SpriteKit''s particle system](img/Image_B04532_08_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![利用SpriteKit的粒子系统](img/Image_B04532_08_05.jpg)'
- en: Adding the circle particle asset
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加圆形粒子资源
- en: 'Each particle system emits multiple versions of a single image in order to
    create a cumulative particle effect. In our case, the image is a simple circle.
    To add the circle image to the game, follow these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个粒子系统都会发射单个图像的多个版本，以创建累积的粒子效果。在我们的例子中，这个图像是一个简单的圆圈。要将圆圈图像添加到游戏中，请按照以下步骤操作：
- en: Open the `Images.xcassets` file in Xcode.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode中打开`Images.xcassets`文件。
- en: Locate the `dot.png` image in the `Particles` folder of the provided game assets.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的游戏资源中找到`Particles`文件夹中的`dot.png`图像。
- en: Drag and drop the image file into the left pane of `Images.xcassets`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像文件拖放到`Images.xcassets`左侧面板中。
- en: Creating a SpriteKit Particle File
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SpriteKit粒子文件
- en: 'Xcode provides an excellent UI for creating and editing particle systems. To
    use the UI, we will add a new **SpriteKit Particle File** to our project. Follow
    these steps to add the new file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 提供了一个出色的 UI 用于创建和编辑粒子系统。要使用 UI，我们将向我们的项目添加一个新的**SpriteKit 粒子文件**。按照以下步骤添加新文件：
- en: Start by adding a new file to your project and locating the **SpriteKit Particle
    File** type. You can find this template under the **Resource** category, as shown
    here:![Creating a SpriteKit Particle File](img/Image_B04532_08_06.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向你的项目添加一个新文件，并定位到**SpriteKit 粒子文件**类型。你可以在这个**资源**类别下找到这个模板，如图所示：![创建 SpriteKit
    粒子文件](img/Image_B04532_08_06.jpg)
- en: In the following prompt, select **Snow** as the **Particle Template**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下提示中，选择**雪花**作为**粒子模板**。
- en: Name the file `PierrePath.sks` and click **Create** to add the new file to your
    project.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件命名为 `PierrePath.sks` 并点击**创建**以将新文件添加到你的项目中。
- en: 'Xcode will open the new particle emitter in the main frame, which should look
    something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 将在主框架中打开新的粒子发射器，它应该看起来像这样：
- en: '![Creating a SpriteKit Particle File](img/Image_B04532_08_07.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![创建 SpriteKit 粒子文件](img/Image_B04532_08_07.jpg)'
- en: Previewing the Snow template in Xcode's particle editor
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 的粒子编辑器中预览雪花模板
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At the time of writing, Xcode's particle editor remains quirky. If you do not
    see the white snow particle effect in the middle, try clicking anywhere in the
    dark gray center area to reposition the particle emitter – occasionally it does
    not start where expected.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Xcode 的粒子编辑器仍然有些古怪。如果你在中间看不到白色雪花粒子效果，请尝试在深灰色中心区域点击任何位置以重新定位粒子发射器 - 有时它不会从预期的位置开始。
- en: This is also useful for testing setting changes without overlap from old particles.
    Simply click anywhere in the editor to reposition the emitter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于测试不与旧粒子重叠的设置更改也很有用。只需在编辑器中点击任何位置即可重新定位发射器。
- en: 'Make sure you have the right-hand sidebar turned on by lighting up the Utilities
    button in the upper right corner of Xcode, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你打开了右侧侧边栏，通过在 Xcode 右上角点亮工具按钮，如图所示：
- en: '![Creating a SpriteKit Particle File](img/Image_B04532_08_08.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![创建 SpriteKit 粒子文件](img/Image_B04532_08_08.jpg)'
- en: 'You can use the Utilities sidebar to edit the animation qualities of the particle
    emitter. You can edit several properties: the number of particles, the lifetime
    of a particle, how fast the particles move, how they scale up or down, and so
    on. This is a fantastic tool because you can see immediate feedback from your
    changes. Feel free to experiment by changing the particle properties.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用工具栏编辑粒子发射器的动画质量。你可以编辑几个属性：粒子的数量、粒子的寿命、粒子移动的速度、粒子缩放的大小，等等。这是一个非常棒的工具，因为你可以立即看到你的更改的反馈。请随意通过更改粒子属性进行实验。
- en: Configuring the path particle settings
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置路径粒子设置
- en: 'To create Pierre''s dot trail, update your particle settings to match the settings
    shown in this screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Pierre 的点状轨迹，更新你的粒子设置以匹配此截图所示的设置：
- en: '![Configuring the path particle settings](img/Image_B04532_08_09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![配置路径粒子设置](img/Image_B04532_08_09.jpg)'
- en: You have the correct settings when your editor shows a tiny white circle with
    no apparent movement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的编辑器显示一个没有明显运动的微小白色圆圈时，你就有了正确的设置。
- en: Adding the particle emitter to the game
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将粒子发射器添加到游戏中
- en: 'We will attach our new emitter to the `Player` node, so the emitter will create
    new white circles wherever the player flies. We can easily reference the emitter
    design we just created in the editor from our code. Open `Player.swift` and add
    this code at the bottom of the `spawn` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把新的发射器连接到 `Player` 节点，这样发射器就会在玩家飞行的任何地方创建新的白色圆圈。我们可以轻松地在代码中引用编辑器中刚刚创建的发射器设计。打开
    `Player.swift` 并在 `spawn` 函数底部添加以下代码：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the project. You should see the white dots trailing behind Pierre, as shown
    here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你应该会看到 Pierre 背后拖曳的白色点，如图所示：
- en: '![Adding the particle emitter to the game](img/Image_B04532_08_10.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![将粒子发射器添加到游戏中](img/Image_B04532_08_10.jpg)'
- en: Good work. Now the player can see where they have flown, which is both fun and
    instructive. The feedback from the dots will help the player learn the sensitivity
    of the control system and thus master the game more quickly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。现在玩家可以看到他们飞行的路径，这既有趣又有教育意义。点的反馈将帮助玩家学习控制系统的灵敏度，从而更快地掌握游戏。
- en: This is just one of many special effects you can create with particle emitter
    nodes. You can explore other creative possibilities now that you know how to create,
    edit, and place particle emitters in the world. Other fun ideas include sparks
    when Pierre bumps into enemies, or gentle snow falling in the background.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是你可以使用粒子发射节点创建的许多特殊效果之一。现在你知道了如何创建、编辑和在世界中放置粒子发射器，你可以探索其他创造性的可能性。其他有趣的想法包括皮埃尔碰到敌人时产生的火花，或者在背景中轻轻飘落的雪花。
- en: Granting safety as the game starts
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏开始时提供安全保障
- en: 'You may have noticed that Pierre Penguin quickly falls to the ground as soon
    as you launch the game, which is not much fun. Instead, we can launch Pierre into
    a graceful looping arc as the game starts to give the player a moment to prepare
    for flight. To do so, open `Player.swift` and add this code at the bottom of the
    `spawn` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当你启动游戏时，皮埃尔企鹅会迅速跌落到地上，这并不是很有趣。相反，我们可以在游戏开始时将皮埃尔发射到一个优雅的循环弧线，给玩家一个准备飞行的时间。要做到这一点，打开`Player.swift`文件，在`spawn`函数的底部添加以下代码：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Checkpoint 8-B
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 8-B
- en: 'To download my project to this point, visit this URL:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下载到目前这个阶段的项目，请访问以下网址：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-8](http://www.thinkingswiftly.com/game-development-with-swift/chapter-8)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-8](http://www.thinkingswiftly.com/game-development-with-swift/chapter-8)'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We brought the game world to life in this chapter. We drew a HUD to show the
    player their remaining health and coin score, added parallax backgrounds to increase
    the depth and immersion of the world, and learned to use particle emitters to
    create special graphics in our games. In addition, we added a small delay before
    gravity drags our hero down at the beginning of each flight. Our game is fun and
    looking great!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将游戏世界栩栩如生。我们绘制了一个HUD来显示玩家的剩余生命值和金币分数，添加了透视背景以增加世界的深度和沉浸感，并学会了如何使用粒子发射器在我们的游戏中创建特殊图形。此外，我们在每次飞行开始时，在重力将我们的英雄拖下来之前添加了一个小的延迟。我们的游戏既有趣又看起来很棒！
- en: Next, we need a menu so we can restart the game without rebuilding the project
    or manually closing the application. In [Chapter 9](ch09.html "Chapter 9. Adding
    Menus and Sounds"), *Adding Menus and Sounds*, we will design a start menu, add
    a retry button when the player dies, and play sounds and music to create a deeper
    gameplay experience.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个菜单，这样我们就可以在不需要重新构建项目或手动关闭应用程序的情况下重新启动游戏。在[第9章](ch09.html "第9章。添加菜单和声音")《添加菜单和声音》中，我们将设计一个开始菜单，当玩家死亡时添加一个重试按钮，并播放声音和音乐以创造更深入的游戏体验。
