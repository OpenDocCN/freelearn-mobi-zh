- en: Chapter 8. Polishing to a Shine – HUD, Parallax Backgrounds, Particles, and
    More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our core gameplay mechanics are in place; now we can improve the overall user
    experience. We will turn our focus to the non-gameplay features that make our
    games shine. To start, we will add a heads-up display (**HUD**) to display the
    player's health and coin count. Then, we will implement multiple layers of parallax
    background to add depth and immersion to the game world. We will also explore
    SpriteKit's particle system, and use a particle emitter to add production value
    to the game. Combined, these steps will add to the fun of the gameplay experience,
    invite the player deeper into the game world, and impart a professional, polished
    feeling to our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a HUD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallax background layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the particle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting safety as the game starts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a heads-up display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game needs a HUD to show the player's current health and coin score. We
    can use hearts to indicate health – like classic games in the past – and draw
    text to the screen with `SKLabelNode` to display the number of coins collected.
  prefs: []
  type: TYPE_NORMAL
- en: We will attach the HUD to the scene itself, instead of to the `world` node,
    since it does not move as the player flies forward. We do not want to block the
    player's vision of upcoming obstacles to the right, so we will place the HUD elements
    in the top left corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are finished, our HUD will look like this (after the player collects
    110 coins and sustains one point of damage):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a heads-up display](img/Image_B04532_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement the HUD, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add the HUD art assets into the game. In the asset pack, find
    the `HUD.atlas` texture atlas and add it to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create a `HUD` class to handle all of the HUD logic. Add a new
    Swift file to your project, `HUD.swift`, and add the following code to begin work
    on the `HUD` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need an initializer-style function to create a new `SKSpriteNode` for each
    heart shape and configure the new `SKLabelNode` for the coin counter. Add a function
    named `createHudNodes` to the `HUD` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need a function that the `GameScene` class can call to update the coin
    counter label. Add a new function to the `HUD` class named `setCoinCountDisplay`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need a function to update the heart graphic when the player''s
    health changes. Add a new function to the `HUD` class named `setHealthDisplay`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `HUD` class is complete. Next, we will wire it up in the `GameScene` class.
    Open `GameScene.swift` and add a new property to the `GameScene` class, instantiating
    an instance of the `HUD` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to place the `HUD` node into the scene, on top of the other game objects.
    Add this code at the bottom of the `GameScene didMoveToView` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are ready to send health and coin updates to the `HUD`. First, we will update
    the `HUD` with health updates when the player takes damage. Inside the `GameScene
    didBeginContact` function, locate the contact cases where the player takes damage
    – when he or she touches the ground or an enemy – and add this new code (in bold),
    to send health updates to the `HUD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will update the `HUD` whenever the player collects a coin. Locate
    the contact case where the player contacts a coin and call the `HUD setCoinCountDisplay`
    function (new code in bold) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project and you should see your coin counter and health meter appear
    in the upper left hand corner, as seen in this screenshot:![Adding a heads-up
    display](img/Image_B04532_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great job! Our HUD is complete. Next, we will build our background layers.
  prefs: []
  type: TYPE_NORMAL
- en: Parallax background layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parallax adds the feeling of depth to your game by drawing separate background
    layers and moving them past the camera at varying speeds. Very slow backgrounds
    give the illusion of distance, while fast moving backgrounds appear to be very
    close to the player. We can enhance the effect by painting faraway objects with
    increasingly desaturated colors.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, we will achieve the parallax effect by attaching our backgrounds
    to the world, then slowly pushing the backgrounds to the right as the world moves
    left. As the world moves to the left (bringing the backgrounds with it), we will
    move the background's *x* position to the right so that the total movement is
    less than for the normal game objects. The result will be background layers that
    appear to move more slowly than the rest of our game, and thus appear farther
    away.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, each background will only be 3000 points wide, but will jump forward
    at precise intervals to loop seamlessly, in a similar way to the `Ground` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the background assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, add the art by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your project's `Images.xcassets` file in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the provided game assets, locate the four background images in the `Backgrounds`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the four backgrounds into the left pane of the `Images.xcassets`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the backgrounds appear in the left pane as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the background assets](img/Image_B04532_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a background class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need a new class to manage the repositioning logic for parallax and
    seamless looping. We can instantiate a new instance of a `Background` class for
    each background layer. To create the `Background` class, add a new Swift file,
    `Background.swift`, to your project, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Wiring up backgrounds in the GameScene class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to make three code additions to the `GameScene` class to wire up our
    backgrounds. First, we will create an array to keep track of the backgrounds.
    Next, we will spawn the backgrounds as the scene begins. Finally, we can call
    the `Background` class `updatePosition` function from the `GameScene didSimulatePhsyics`
    function to reposition the backgrounds before every frame. Follow these steps
    to wire up the backgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new array property on the `GameScene` class itself to store our backgrounds,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of the `didMoveToView` function, instantiate and spawn our four
    backgrounds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, add the following code at the bottom of the `didSimulatePhysics` function
    to reposition the backgrounds before each frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project. You should see the four background images as separate layers
    behind the action, moving past with a parallax effect. This screenshot shows the
    backgrounds as they should appear in your game:![Wiring up backgrounds in the
    GameScene class](img/Image_B04532_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using the iOS simulator to test your game, it is normal to experience
    a lowered frame rate after adding these large background textures to the game.
    The game will still run well on iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! You have successfully implemented your background system. The background
    makes Pierre Penguin's world feel full, adding immersion to the game. Next, we
    will use a particle emitter to add a trail behind Pierre – a fun addition that
    helps the player master the controls.
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoint 8-A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To download my project to this point, visit this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-8](http://www.thinkingswiftly.com/game-development-with-swift/chapter-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing SpriteKit's particle system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpriteKit includes a powerful particle system that makes it easy to add exciting
    graphics to your game. Particle emitter nodes create many small instances of an
    image that combine together to create a great-looking effect. You can use emitter
    nodes to generate snow, fire, sparks, explosions, magic, and other useful effects
    that would otherwise require a lot of effort.
  prefs: []
  type: TYPE_NORMAL
- en: For our game, you will learn to use an emitter node to create a trail of small
    dots behind Pierre Penguin as he flies, making it easier for the player to learn
    how their taps influence Pierre's flight path.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are finished, Pierre''s dot trail will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Harnessing SpriteKit''s particle system](img/Image_B04532_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the circle particle asset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each particle system emits multiple versions of a single image in order to
    create a cumulative particle effect. In our case, the image is a simple circle.
    To add the circle image to the game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Images.xcassets` file in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `dot.png` image in the `Particles` folder of the provided game assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the image file into the left pane of `Images.xcassets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a SpriteKit Particle File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Xcode provides an excellent UI for creating and editing particle systems. To
    use the UI, we will add a new **SpriteKit Particle File** to our project. Follow
    these steps to add the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding a new file to your project and locating the **SpriteKit Particle
    File** type. You can find this template under the **Resource** category, as shown
    here:![Creating a SpriteKit Particle File](img/Image_B04532_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following prompt, select **Snow** as the **Particle Template**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the file `PierrePath.sks` and click **Create** to add the new file to your
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Xcode will open the new particle emitter in the main frame, which should look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit Particle File](img/Image_B04532_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Previewing the Snow template in Xcode's particle editor
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, Xcode's particle editor remains quirky. If you do not
    see the white snow particle effect in the middle, try clicking anywhere in the
    dark gray center area to reposition the particle emitter – occasionally it does
    not start where expected.
  prefs: []
  type: TYPE_NORMAL
- en: This is also useful for testing setting changes without overlap from old particles.
    Simply click anywhere in the editor to reposition the emitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have the right-hand sidebar turned on by lighting up the Utilities
    button in the upper right corner of Xcode, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit Particle File](img/Image_B04532_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use the Utilities sidebar to edit the animation qualities of the particle
    emitter. You can edit several properties: the number of particles, the lifetime
    of a particle, how fast the particles move, how they scale up or down, and so
    on. This is a fantastic tool because you can see immediate feedback from your
    changes. Feel free to experiment by changing the particle properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the path particle settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create Pierre''s dot trail, update your particle settings to match the settings
    shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the path particle settings](img/Image_B04532_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You have the correct settings when your editor shows a tiny white circle with
    no apparent movement.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the particle emitter to the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will attach our new emitter to the `Player` node, so the emitter will create
    new white circles wherever the player flies. We can easily reference the emitter
    design we just created in the editor from our code. Open `Player.swift` and add
    this code at the bottom of the `spawn` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project. You should see the white dots trailing behind Pierre, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the particle emitter to the game](img/Image_B04532_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Good work. Now the player can see where they have flown, which is both fun and
    instructive. The feedback from the dots will help the player learn the sensitivity
    of the control system and thus master the game more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one of many special effects you can create with particle emitter
    nodes. You can explore other creative possibilities now that you know how to create,
    edit, and place particle emitters in the world. Other fun ideas include sparks
    when Pierre bumps into enemies, or gentle snow falling in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Granting safety as the game starts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that Pierre Penguin quickly falls to the ground as soon
    as you launch the game, which is not much fun. Instead, we can launch Pierre into
    a graceful looping arc as the game starts to give the player a moment to prepare
    for flight. To do so, open `Player.swift` and add this code at the bottom of the
    `spawn` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Checkpoint 8-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To download my project to this point, visit this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-8](http://www.thinkingswiftly.com/game-development-with-swift/chapter-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We brought the game world to life in this chapter. We drew a HUD to show the
    player their remaining health and coin score, added parallax backgrounds to increase
    the depth and immersion of the world, and learned to use particle emitters to
    create special graphics in our games. In addition, we added a small delay before
    gravity drags our hero down at the beginning of each flight. Our game is fun and
    looking great!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a menu so we can restart the game without rebuilding the project
    or manually closing the application. In [Chapter 9](ch09.html "Chapter 9. Adding
    Menus and Sounds"), *Adding Menus and Sounds*, we will design a start menu, add
    a retry button when the player dies, and play sounds and music to create a deeper
    gameplay experience.
  prefs: []
  type: TYPE_NORMAL
