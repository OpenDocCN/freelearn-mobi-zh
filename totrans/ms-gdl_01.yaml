- en: Chapter 1. Getting Started with Gradle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 使用 Gradle 入门
- en: Consider a typical IT company development center scenario. Different teams are
    working together on one enterprise project with many components. Teams are working
    on server-side technologies, frontend technologies, the messaging layer, mobile
    development and there may be a separate team responsible for Quality Assurance.
    Every team is working as per their schedule, developing their own component(s),
    unit testing and committing code, and this cycle is repeated in multiple iterations.
    So far, everybody is happy as they are able to meet the deadlines as per the software
    release dates. Then comes the integration phase, when teams have to build the
    complete project and deploy the software (which could be WAR, JAR, or any service)
    to the integration/staging environment. And then the nightmare starts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个典型的 IT 公司开发中心场景。不同的团队在一个包含许多组件的企业项目中共同工作。团队在服务器端技术、前端技术、消息层、移动开发等方面工作，可能还有一个单独的团队负责质量保证。每个团队都按照自己的进度工作，开发自己的组件，进行单元测试和提交代码，并且这个周期在多个迭代中重复。到目前为止，每个人都感到很高兴，因为他们能够按照软件发布日期按时完成工作。然后是集成阶段，当团队必须构建完整的项目并将软件（可能是
    WAR、JAR 或任何服务）部署到集成/预发布环境中时。然后噩梦开始了。
- en: Although every team has successfully followed many best practices of software
    engineering such as committing code on a daily basis, unit testing of code and
    verifying the working software on a developer's test environment, but in the integration
    or staging environment the situation has suddenly changed. The team is stuck with
    configuration and interoperation issues, localization issues, environmental issues,
    and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个团队都成功地遵循了许多软件工程的最佳实践，例如每天提交代码、对代码进行单元测试以及在开发者的测试环境中验证工作的软件，但在集成或预发布环境中，情况突然发生了变化。团队陷入了配置和互操作问题、本地化问题、环境问题等等。
- en: This might be a very common scenario for any project and the situation will
    become worse if they are not using any automated solution for the build and deployment
    process. Hence the need for an automated process or we can call a **Build Automation
    System** (**BAS**), which automates the manual task of building the project seamlessly
    and delivers the software in a repeatable, reliable, and portable fashion. BAS
    doesn't claim that there will be absolutely no issues or errors, but with BAS,
    the software can be managed in a better way, minimizing the probability of repeating
    the same error again and again.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对任何项目来说都是一个非常常见的场景，如果他们没有使用任何自动化解决方案来构建和部署流程，情况会变得更糟。因此，需要自动化流程，或者我们可以称之为
    **构建自动化系统**（**BAS**），它能够无缝地自动化构建项目的手动任务，并以可重复、可靠和可移植的方式交付软件。BAS 不声称将完全没有问题或错误，但有了
    BAS，软件可以更好地管理，最大限度地减少重复犯同样错误的可能性。
- en: Gradle is one of the advanced build automation tools available in the market.
    In the next 10 chapters, we will explore how to mitigate these problems with Gradle
    and with other related technologies. However, before we start learning Gradle,
    we need to understand what a BAS is and why we need it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 是市场上可用的先进构建自动化工具之一。在接下来的 10 章中，我们将探讨如何使用 Gradle 和其他相关技术来缓解这些问题。然而，在我们开始学习
    Gradle 之前，我们需要了解什么是 BAS 以及为什么我们需要它。
- en: Understanding Build Automation System
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解构建自动化系统
- en: The most common processes in building any software include compiling the source
    files, packaging the compiled output to a compressed format (ZIP, JAR or any other
    format), and adding the required resource files and configuration files to the
    packaging. Along with this, it may also include some other activities such as
    running static code analysis on the source code to provide feedback on the design
    and coding patterns, and another important area is Quality Assurance, which involves
    unit testing, integration testing, regression testing, and so on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 构建任何软件中最常见的流程包括编译源文件、将编译输出打包成压缩格式（ZIP、JAR 或任何其他格式），并将所需的资源文件和配置文件添加到打包中。除此之外，还可能包括一些其他活动，例如在源代码上运行静态代码分析以提供关于设计和编码模式反馈，另一个重要领域是质量保证，它涉及单元测试、集成测试、回归测试等。
- en: A BAS is part of the software life cycle, which automates the build and deployment
    phases of the software. The first phase is building the software, which is the
    process of creating the binaries or executables. The second phase is the deployment
    phase, wherein we need to install the software at a particular location. This
    phase also includes various other activities such as unpacking the bundle, localization
    of the software, configuring the software as per the environment and setting the
    environment-specific properties required to execute the software. The next important
    step is functional testing to check the behavior of the software. Once everything
    is fine, it makes a happy and smiley ending for you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: BAS 是软件生命周期的一部分，它自动化了软件的构建和部署阶段。第一阶段是构建软件，这是创建二进制文件或可执行文件的过程。第二阶段是部署阶段，其中我们需要在特定位置安装软件。此阶段还包括各种其他活动，如解包捆绑包、软件本地化、根据环境配置软件以及设置执行软件所需的环境特定属性。下一个重要步骤是功能测试，以检查软件的行为。一旦一切正常，对你来说就是一个快乐和微笑的结局。
- en: So, as a developer, writing the code and test cases is just one of the major
    tasks in **Software Development Life Cycle** (**SDLC**). Build and deployment
    is also considered as another important phase in any software life cycle. If it
    is not managed properly, it could lead to major downtime and client dissatisfaction.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一名开发者，编写代码和测试用例只是**软件开发生命周期**（**SDLC**）中的主要任务之一。构建和部署也被视为任何软件生命周期中的另一个重要阶段。如果管理不当，可能会导致重大停机时间和客户不满。
- en: Build automation allows us to automate the manual steps in the build process.
    It also helps to eliminate the redundant tasks, mitigates the risks of manual
    intervention, keeps the history of the builds, and saves the cost and time spent
    in the manual process. The goal here is to create reproducible assets every time
    you run the build script, which will not be the case, if you manually execute
    the steps every time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自动化使我们能够自动化构建过程中的手动步骤。它还有助于消除冗余任务，减轻手动干预的风险，保持构建的历史记录，并节省手动过程中的成本和时间。这里的目的是每次运行构建脚本时都创建可重复的资产，而如果你每次都手动执行步骤，则不会是这样。
- en: Many developers relate the build automation with **Continuous Integration**
    (**CI**). Do not get confused. The CI allows executing the build process, performing
    deployment activities, and many more activities. It helps to create a workflow
    for build and deployment automation. It also helps to schedule the builds and
    provides on-demand execution of builds. The schedule could be once in every hour,
    once in four hours, nightly builds or on every user commit. Some of the well known
    CI tools are Jenkins, TeamCity, Bamboo, Hudson, Cruise Control, and so on, which
    are totally different from Build tools, such as Ant, Maven, and Gradle.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者将构建自动化与**持续集成**（**CI**）联系起来。不要混淆。CI 允许执行构建过程、执行部署活动以及许多其他活动。它有助于创建构建和部署自动化的工作流程。它还帮助安排构建并提供按需执行构建。计划可以是每小时一次、每四小时一次、夜间构建或每次用户提交时。一些知名的
    CI 工具包括 Jenkins、TeamCity、Bamboo、Hudson、Cruise Control 等，它们与构建工具（如 Ant、Maven 和
    Gradle）完全不同。
- en: Need for BAS
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BAS 的必要性
- en: 'Imagine that all the preceding mentioned steps in building a software need
    to be done manually, and every developer has to perform steps on different machines.
    Now you can realize the amount of effort wasted in figuring out problems with
    build issues rather than focusing on the actual business requirements. That''s
    one of the reasons why we need a BAS. Following are some of the major activities,
    which we automate for the build system:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，所有前面提到的构建软件的步骤都需要手动完成，每个开发者都必须在不同的机器上执行步骤。现在你可以意识到，在构建问题而不是关注实际业务需求上浪费了多少努力。这就是我们需要
    BAS 的原因之一。以下是我们为构建系统自动化的主要活动之一：
- en: Translating the source code into binaries
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源代码翻译成二进制文件
- en: Packaging the binaries with configuration files to create deployable artifacts
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制文件与配置文件打包以创建可部署的工件
- en: Executing the test cases
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行测试用例
- en: Publishing the artifacts to a common repository
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将工件发布到公共仓库
- en: Deploying the artifacts to different environments (Development, QA, and Production)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将工件部署到不同的环境（开发、QA 和生产）
- en: Incremental builds
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量构建
- en: Status reports that summarize the current state of the build
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结构建当前状态的状况报告
- en: Another reason to have a BAS is to reduce the operational complexities. If a
    new member joins the team and he has to perform the manual build of the software,
    it could be a nightmare for him, if there is no automation. Rather than concentrating
    on the business requirement, most of his time will be wasted on how to compile
    it, how to run unit tests, how to execute integration tests, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个拥有构建自动化系统（BAS）的原因是减少操作复杂性。如果一个新成员加入团队，并且他必须手动构建软件，如果没有自动化，这可能会成为他的噩梦。与其专注于业务需求，他们的大部分时间将浪费在如何编译它、如何运行单元测试、如何执行集成测试等等。
- en: Actually, what he needs to know is where to commit the source code, where to
    put the resources, and what commands to execute to perform the build process.
    The build process should automatically perform all the tasks of compiling, packaging,
    running tests, uploading asserts and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，他需要知道的是在哪里提交源代码，在哪里放置资源，以及执行构建过程需要运行哪些命令。构建过程应该自动执行编译、打包、运行测试、上传断言等所有任务。
- en: The more automated the build and deployment process, the faster you will get
    the deliverables to the client. It also helps with business continuity. In case
    of any system crash or network failure, you can rebuild and deploy the software
    on back up infrastructure in much less time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署过程越自动化，你将越快地将可交付成果提供给客户。它还有助于业务连续性。在系统崩溃或网络故障的情况下，你可以在更短的时间内重建和部署软件到备份基础设施上。
- en: Some developers believe that project automation is a waste of time and why should
    they put in extra effort as their IDE performs this job. They can build the JAR,
    WAR, or any other deliverable unit with the help of IDE and deploy the same. Since
    they can build, and test it quickly, it works very well on their local system.
    The problem starts when integration happens. Thus, an automated system is required
    to avoid any manual intervention (unless it is the only option left), and to make
    builds portable, predictable and efficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者认为项目自动化是浪费时间，为什么他们要付出额外的努力，因为他们的 IDE 已经完成了这项工作。他们可以在 IDE 的帮助下构建 JAR、WAR
    或任何其他可交付单元，并部署相同的单元。由于他们可以快速构建和测试，它们在本地系统上运行得非常好。问题开始于集成发生时。因此，需要一个自动化系统来避免任何手动干预（除非这是唯一的选择），并使构建可移植、可预测和高效。
- en: Gradle overview
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle 概述
- en: Before getting into the details of Gradle, we need to understand some of the
    terminologies related to the build system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 Gradle 的细节之前，我们需要了解一些与构建系统相关的术语。
- en: There are two types of build tools, namely **imperative build tools** and **declarative
    build tools**. An imperative build tool tells the system what to do and how to
    do it. In other words, it provides a set of action statements or commands, which
    the system executes in the same order and performs those actions. You can take
    Ant as an example of the imperative build system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑工具有两种类型，即**命令式构建工具**和**声明式构建工具**。命令式构建工具告诉系统做什么以及如何做。换句话说，它提供一组动作语句或命令，系统按相同的顺序执行这些命令并执行这些动作。你可以将
    Ant 作为命令式构建系统的例子。
- en: Whereas, a declarative build tool instructs the system, telling it what you
    would like to achieve, and system will figure out how to interpret it. With a
    declarative approach, the user only needs to determine the *what*, not the *how*.
    This is one of the key innovations Maven brought to the build world, after Ant
    achieved some popularity, where we don't need to write each and every step of
    an action, and end up creating a very large and verbose build script. With Maven
    we need to write some configuration parameters for the build and the build system
    itself decides how to interpret it. Internally, the declarative layer is based
    on a powerful imperative layer, which can be accessed directly as required. Ant
    and Maven are very good and reliable build systems. They are innovative in all
    the areas for which they were designed and built. Each of them has introduced
    key innovations into the build space.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，声明式构建工具指导系统，告诉它你想要实现什么，系统将找出如何解释它。使用声明式方法，用户只需要确定*什么*，而不是*如何*。这是 Maven 在
    Ant 获得一些知名度后为构建世界带来的关键创新之一，我们不需要编写每个动作的每一步，最终创建一个非常庞大且冗长的构建脚本。使用 Maven，我们需要为构建和构建系统本身编写一些配置参数，构建系统自己决定如何解释它。内部，声明式层基于一个强大的命令式层，可以根据需要直接访问。Ant
    和 Maven 是非常好的且可靠的构建系统。它们在它们设计和构建的所有领域都是创新的。每个都为构建空间引入了关键的创新。
- en: Gradle combines the good parts of both tools and provides additional features
    and uses Groovy as a **Domain Specific Language** (**DSL**). It has power and
    flexibility of Ant tool with Maven features such as build life cycle and ease
    of use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle结合了两种工具的优点，并提供了额外的功能，同时使用Groovy作为**领域特定语言**（**DSL**）。它具有Ant工具的强大功能和Maven的构建生命周期以及易用性。
- en: Gradle is a general purpose, declarative build tool. It is general purpose because
    it can be used to build pretty much anything you care to implement in the build
    script. It is declarative, since you don't want to see lots of code in the build
    file, which is not readable and less maintainable. So, while Gradle provides the
    idea of conventions and a simple and declarative build, it also makes the tool
    adaptable and developers the ability to extend. It also provides an easy way to
    customize the default behavior and different hooks to add any third-party features.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle是一个通用、声明式的构建工具。它是通用的，因为你可以用它来构建几乎任何你在构建脚本中想要实现的东西。它是声明式的，因为你不想在构建文件中看到大量的代码，这些代码难以阅读和维护。因此，虽然Gradle提供了约定和简单、声明式构建的概念，但它也使工具具有适应性，并赋予开发者扩展的能力。它还提供了一种轻松定制默认行为和添加任何第三方功能的不同挂钩的方法。
- en: Primarily, Gradle is a JVM-language build tool, but it also supports C, C++,
    Android, and so on. You will find more information about this at [https://docs.gradle.org/current/userguide/nativeBinaries.html](https://docs.gradle.org/current/userguide/nativeBinaries.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，Gradle是一个JVM语言构建工具，但它也支持C、C++、Android等。你可以在[https://docs.gradle.org/current/userguide/nativeBinaries.html](https://docs.gradle.org/current/userguide/nativeBinaries.html)找到更多关于此的信息。
- en: It provides automation for the different phases required in a Java project,
    such as compile, package, execute test cases, and so on. It has grouped its similar
    automation tasks into plugins. When you import any plugin to a Gradle script file,
    they always come with a set of predefined tasks. To get started with Gradle, you
    need to have basic knowledge of Java. It uses Groovy as its scripting language,
    which is another JVM language. We will discuss Groovy in the next chapter. As
    the build script is written in Groovy, it tends to be much shorter, expressive,
    and clearer than those written in Ant or Maven. The amount of boilerplate code
    is much less in Gradle with use of Groovy DSL. It also leverages Maven conventions
    for familiarity, while making it easy to customize to the needs of your project.
    Developers can add new functionality or extend the existing features at any time.
    They can override the existing tasks or plugins to provide the new functionality.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它为Java项目所需的各个阶段提供自动化，例如编译、打包、执行测试用例等。它将类似的自动化任务分组为插件。当你将任何插件导入Gradle脚本文件时，它们都会附带一系列预定义的任务。要开始使用Gradle，你需要具备基本的Java知识。它使用Groovy作为其脚本语言，这也是另一种JVM语言。我们将在下一章讨论Groovy。由于构建脚本是用Groovy编写的，因此它比用Ant或Maven编写的脚本要短得多，表达性更强，也更清晰。在Gradle中使用Groovy
    DSL时，样板代码的数量要少得多。它还利用了Maven的约定以提高熟悉度，同时使其易于根据项目需求进行定制。开发者可以在任何时候添加新功能或扩展现有功能。他们可以覆盖现有任务或插件以提供新功能。
- en: Installation and quick start
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和快速入门
- en: Gradle installation is quite simple. You can download the Gradle distribution
    from the Gradle home page at [https://www.gradle.org/downloads](https://www.gradle.org/downloads),
    which is available in different formats.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的安装相当简单。你可以从Gradle主页[https://www.gradle.org/downloads](https://www.gradle.org/downloads)下载Gradle发行版，它以不同的格式提供。
- en: Pre-requisites
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前置条件
- en: Gradle requires a Java JDK or JRE to be installed, needing version 6 or higher
    (to check the Java version on your machine, use `java -version`). Some of the
    features might not work with JRE, so it is recommended to have JDK installed.
    Also, Gradle ships with its own Groovy library; therefore, Groovy does not need
    to be installed. Any existing Groovy installation is ignored by Gradle.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle需要安装Java JDK或JRE，需要版本6或更高（要在你的机器上检查Java版本，请使用`java -version`）。一些功能可能不与JRE兼容，因此建议安装JDK。此外，Gradle自带其自己的Groovy库；因此，不需要安装Groovy。Gradle会忽略任何现有的Groovy安装。
- en: 'Gradle is available in three formats:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle有三种格式可供选择：
- en: '`gradle-[version]-all.zip`: This contains the source code, the binaries, and
    the documentation'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gradle-[version]-all.zip`：此文件包含源代码、二进制文件和文档'
- en: '`gradle-[version]-bin.zip`: This contains the binaries only'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gradle-[version]-bin.zip`：此文件仅包含二进制文件'
- en: '`gradle-[version]-src.zip`: This contains the source code only, in case you
    want to extend the Gradle features'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gradle-[version]-src.zip`：此文件仅包含源代码，以防你想扩展Gradle的功能'
- en: Alternatively, you can just download `gradle-[version]-bin.zip` file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Once downloaded, you need to unpack the zip file and configure it as per your
    operating system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Gradle for Windows
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the steps for installing Gradle on Windows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Unpack the Gradle distribution on the hard drive.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Gradle's installed path (for example, `c:\gradle-2.4`) to the `GRADLE_HOME`
    variable. Note that this location should be the parent directory of the `bin`
    or the `lib` folder.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `GRADLE_HOME/bin` to the `PATH` variable.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are ready to go ahead with Gradle, verify your installation by running
    the `gradle` command with the `--version` or `-v` command-line parameter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Gradle for Mac/Linux
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following are the steps to install Gradle on the Mac/Linux operating system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Unpack the Gradle distribution.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following two lines in your initialization script (`~/.profile`).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export `GRADLE_HOME = <Gradle_Installation_Dir>`
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export `PATH=$PATH:$GRADLE_HOME/bin`
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reload the profile by executing `source ~/.profile` and execute the `gradle
    –version` command. You will be able to see a similar output as mentioned in the
    previous section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The Gradle JVM option
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradle shares the same JVM options set by the environment variable `JAVA_OPTS`.
    If you don't want to use this setting and want to pass arguments specifically
    to the Gradle runtime, you can use the environment variable `GRADLE_OPTS`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose if `JAVA_OPTS=512MB` in your system and you want to increase the default
    maximum heap size to `1024MB` for Gradle application. You can set it like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can apply this setting in the project-specific build file. Alternatively,
    we can also apply this setting to all of the Gradle build by adding the variable
    to the Gradle startup script (this will be discussed later in this chapter).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Our first script
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we learned how to install Gradle. Now it's time create
    our very first Gradle script. This script will print `Hello Gradle- This is your
    first script` on the console. Just open a text editor, type in the following three
    lines, and save the file as `build.gradle`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then execute the `gradle helloGradle` command as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, what have we done here?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We have a created a Gradle build script file called `build.gradle`. This is
    the default name given to a build file. You can give any name to the build file.
    However, to execute the script, you must use the `-b` option with your filename
    with the `gradle` command. Otherwise,the build will fail with the `Task '%TASK_NAME%'
    not found in root project '%PROJECT_NAME'."gradle [-b <file name>] [task1 task2
    ….. taskn]` error.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try the `gradle -b <buildfile_name> helloGradle` command and you should get
    the same output.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the gradle command, we have executed a task called `helloGradle`, which
    prints a line in the console. So, the parameter we passed to the gradle command
    is the task name. You can execute one to any number of tasks with the Gradle command
    and these tasks will be executed in the same order as they appear in the command
    line.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用gradle命令，我们已经执行了一个名为`helloGradle`的任务，该任务在控制台打印一行。因此，我们传递给gradle命令的参数是任务名称。您可以使用Gradle命令执行一个或多个任务，并且这些任务将按照它们在命令行中出现的顺序执行。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is a way to define the default task using the `defaultTasks` keyword,
    which will be executed by default, if user does not mention any specific task
    to execute on the build file. We'll discuss this more in [Chapter 3](ch03.html
    "Chapter 3. Managing Task"), *Managing Task*.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一种方法可以使用`defaultTasks`关键字定义默认任务，如果用户在构建文件中没有提到要执行的具体任务，则默认执行。我们将在[第3章](ch03.html
    "第3章。管理任务")*管理任务*中进一步讨论这一点。
- en: The Gradle command initializes the script, reads all tasks mentioned on the
    command-line, and executes tasks. Moreover, if any task has multiple dependencies,
    then dependent tasks are executed in alphabetical order unless those tasks themselves
    enforce the order. You can find more about task ordering in [Chapter 3](ch03.html
    "Chapter 3. Managing Task"), *Managing Task*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle命令初始化脚本，读取命令行上提到的所有任务，并执行任务。此外，如果任何任务有多个依赖项，则依赖任务将按字母顺序执行，除非这些任务本身强制执行顺序。您可以在[第3章](ch03.html
    "第3章。管理任务")*管理任务*中找到更多关于任务排序的信息。
- en: 'Remember that each Gradle build consists of three components: projects, tasks,
    and properties. Each build has at least one project and one or more tasks. The
    name of the project is the parent directory name in which the build file exists.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个Gradle构建都包含三个组件：项目、任务和属性。每个构建至少有一个项目和一个或多个任务。项目的名称是构建文件存在的父目录名称。
- en: Gradle command Line arguments
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle命令行参数
- en: Now that you have created the first working script, it is time to explore different
    command-line options supported by Gradle.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了第一个可工作的脚本，是时候探索Gradle支持的不同命令行选项了。
- en: You have already seen the usage of `-b` option to specify a build script. We'll
    start with `--help` or `-h` or `-?` to list all the options available with the
    Gradle command line.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了使用`-b`选项来指定构建脚本的使用方法。我们将从`--help`或`-h`或`-?`开始，列出Gradle命令行中所有可用的选项。
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding output, `-h` or `--help` displays many more options. We have
    truncated the output.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`-h`或`--help`显示了许多更多选项。我们已经截断了输出。
- en: You can execute the command on your systems and check all the options. Most
    of these are self-explanatory. We will discuss the usage of some of the most useful
    options in this section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的系统上执行该命令并检查所有选项。其中大部分都是自我解释的。在本节中，我们将讨论一些最有用选项的用法。
- en: Now we'll add two more tasks, `failedTask` and `test` to the `build.gradle`
    script and save the file as `sample_build.gradle`. The task named `failedTask`
    is expected to always fail due to assertion failure and the `test` task is dependent
    on the previously created task `helloGradle`. A task can succeed (executing all
    statements in the task without any exception) or it can fail (due to any exception
    or error in any line of code mentioned in the task) thus stopping the execution
    of the script.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`build.gradle`脚本中添加两个更多任务，`failedTask`和`test`，并将文件保存为`sample_build.gradle`。名为`failedTask`的任务预期将始终因断言失败而失败，而`test`任务依赖于之前创建的任务`helloGradle`。任务可以成功（在任务中执行所有语句而没有任何异常）或失败（由于任何异常或错误，这些异常或错误在任务的任何一行代码中提到），从而停止脚本的执行。
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On executing the `gradle -b sample_build.gradle failedTask test` command, we
    observe that the `test` task is never executed. As Gradle executes tasks sequentially
    as they appear on the command-line, if a task fails to execute, all the remaining
    tasks will be ignored.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`gradle -b sample_build.gradle failedTask test`命令时，我们观察到`test`任务从未被执行。由于Gradle按命令行中出现的顺序顺序执行任务，如果任务执行失败，则忽略所有剩余的任务。
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, Gradle stops the build process if any task fails to execute. This
    feature helps to get a quick feedback on the build process. If you do not want
    to stop execution of the build irrespective of any task failure and you want to
    continue with other tasks, then it can be done by using the `--continue` command-line
    option. This feature could be useful when we want to build a multimodule project,
    where some of the modules might fail due to compilation error or test failure.
    With the `–continue` option, we will get a complete status of all the modules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Gradle 如果任何任务执行失败，则会停止构建过程。这个特性有助于快速获得构建过程的反馈。如果您不想因为任何任务的失败而停止构建的执行，并且希望继续执行其他任务，则可以通过使用
    `--continue` 命令行选项来实现。当我们要构建一个多模块项目，其中一些模块可能由于编译错误或测试失败而失败时，这个特性可能很有用。使用 `–continue`
    选项，我们将获得所有模块的完整状态。
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding output, `failedTask` failed to execute. So the
    build is marked as `FAILURE`. However, this time the `test` task executed successfully.
    Also observe that the `helloGradle` task is executed before the `test` task. This
    is because we have defined the `test` task to be dependent on the `helloGradle`
    task. This is one of the ways you can create task dependencies. For now, don't
    get confused with task dependency. We will discuss the topic in detail in [Chapter
    3](ch03.html "Chapter 3. Managing Task"), *Managing Task*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的输出中看到的，`failedTask` 任务执行失败。因此，构建被标记为 `FAILURE`。然而，这次 `test` 任务执行成功。同时注意，`helloGradle`
    任务在 `test` 任务之前执行。这是因为我们已将 `test` 任务定义为依赖于 `helloGradle` 任务。这是创建任务依赖关系的一种方法。现在，请不要对任务依赖关系感到困惑。我们将在
    [第 3 章](ch03.html "第 3 章。管理任务") *管理任务* 中详细讨论这个主题。
- en: 'Now, what happens if the `helloGradle` task fails? Just add a line `assert
    1==2` into the `helloGradle` task. The assert statement forces the task to fail.
    When you look at the following output, you will find that the test tasks is not
    executed as the dependent task failed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `helloGradle` 任务失败会发生什么？只需在 `helloGradle` 任务中添加一行 `assert 1==2`。断言语句强制任务失败。当您查看以下输出时，您会发现测试任务没有执行，因为依赖的任务失败了：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding scenario, the test task is dependent on the `helloGradle` task.
    This means that, every time we execute the `test` task, the `helloGradle` task
    will be executed by default. In case you want to avoid the execution of the `helloGradle`
    task, you can use the `-x or --exclude-task` option.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的场景中，测试任务依赖于 `helloGradle` 任务。这意味着每次我们执行 `test` 任务时，`helloGradle` 任务都会默认执行。如果您想避免执行
    `helloGradle` 任务，可以使用 `-x or --exclude-task` 选项。
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another useful option is `--dry-run` or `-m`, which runs the build but does
    not execute the tasks. It is useful if you want to know the task execution order
    or you want to validate the script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的选项是 `--dry-run` 或 `-m`，它运行构建但不执行任务。如果您想了解任务执行顺序或验证脚本，这很有用。
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`--dry-run` executes all the statements which are not part of any tasks and
    are defined outside of a task block. To verify this, add a `println` statement
    anywhere outside a task block definition and observe the result.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`--dry-run` 执行不属于任何任务且定义在任务块之外的语句。为了验证这一点，在任务块定义之外添加一个 `println` 语句并观察结果。'
- en: 'So far, you must have noticed that each output displays extra information apart
    from the task output and error messages. Try the command-line option `-q` or `--quiet`
    to display only the task output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到每个输出都显示了除任务输出和错误消息之外的信息。尝试使用命令行选项 `-q` 或 `--quiet` 仅显示任务输出：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The options `--debug` (`-d`), `--info` (`-i`), `--full-stacktrace` (`-S`),
    and `--stacktrace` (`-s`) display the output with different log levels and stack
    traces. `--debug` is the most detailed log level. `--full-stacktrace` and `--stacktrace`
    show stack traces if the build fails with an exception. Try the previously executed
    command with these command-line options and observe the output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `--debug` (`-d`)、`--info` (`-i`)、`--full-stacktrace` (`-S`) 和 `--stacktrace`
    (`-s`) 以不同的日志级别和堆栈跟踪显示输出。`--debug` 是最详细的日志级别。`--full-stacktrace` 和 `--stacktrace`
    如果构建因异常失败时，会显示堆栈跟踪。尝试使用这些命令行选项执行之前执行的命令，并观察输出：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we will explore the `--daemon`, `--stop`, and `--no-daemon` options. On
    my machine, it took around 3.6 seconds to execute the preceding script. For this
    simple script, most of the execution time was spent in the initialization of Gradle.
    When we execute a Gradle command, a new Java Virtual Machine is started, then
    Gradle-specific classes and libraries are loaded, and finally the actual build
    steps are executed. Initialization and execution of Gradle can be improved using
    the `--daemon` option. This is very useful if you are working in a test-driven
    development where you need to execute unit tests frequently or you need to run
    a particular task repeatedly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探索 `--daemon`、`--stop` 和 `--no-daemon` 选项。在我的机器上，执行前面的脚本大约需要 3.6 秒。对于这个简单的脚本，大部分执行时间都花在了
    Gradle 的初始化上。当我们执行 Gradle 命令时，会启动一个新的 Java 虚拟机，然后加载 Gradle 特定的类和库，最后执行实际的构建步骤。可以使用
    `--daemon` 选项来改进 Gradle 的初始化和执行。如果你在进行测试驱动开发，需要频繁执行单元测试或者需要重复运行特定任务，这将非常有用。
- en: To start a daemon, you can use the `--daemon` option. The daemon process automatically
    expires after 3 hours of idle time. To check whether the daemon is running on
    the system, use the `ps` command in the UNIX environment, or the Process explorer
    in Windows systems. Once you have started the daemon process, again execute the
    same Gradle task. You will find an improvement in the execution time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动守护进程，可以使用 `--daemon` 选项。守护进程在空闲 3 小时后会自动过期。要检查系统上是否正在运行守护进程，在 UNIX 环境中使用
    `ps` 命令，或在 Windows 系统中使用进程资源管理器。一旦启动了守护进程，再次执行相同的 Gradle 任务。你会发现执行时间有所改善。
- en: Alternatively, you can use the `gradle.properties` file to set the system property
    `org.gradle.daemon` to enable the daemon. In this scenario, you don't need to
    specify the `--daemon` option when executing the tasks. To try it out, create
    a file called `gradle.properties` in the same directory where you created the
    `sample_build.gradle` file and add this line `org.gradle.daemon=true`. Now, run
    the gradle command and check whether the daemon process is running. The `org.gradle.daemo`
    is a property that we have set to configure the Gradle build environment. We'll
    discuss more on properties and system variables in [Chapter 6](ch06.html "Chapter 6. Working
    with Gradle"), *Working with Gradle*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `gradle.properties` 文件来设置系统属性 `org.gradle.daemon` 以启用守护进程。在这种情况下，执行任务时不需要指定
    `--daemon` 选项。要尝试一下，在创建 `sample_build.gradle` 文件相同的目录下创建一个名为 `gradle.properties`
    的文件，并添加这一行 `org.gradle.daemon=true`。现在，运行 gradle 命令并检查守护进程是否正在运行。`org.gradle.daemon`
    是我们设置的属性，用于配置 Gradle 构建环境。我们将在 [第 6 章](ch06.html "第 6 章。使用 Gradle") 中更多地讨论属性和系统变量，即
    *使用 Gradle*。
- en: To stop the daemon process, use the `gradle --stop` option. Sometimes, you may
    not want to execute Gradle tasks with the daemon process. Use the `--no-daemon`
    option with the task to ignore any running daemons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止守护进程，请使用 `gradle --stop` 选项。有时，你可能不想使用守护进程执行 Gradle 任务。使用 `--no-daemon` 选项与任务一起，忽略任何正在运行的守护进程。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although the Gradle daemon is recommended for the development environment, it
    might get corrupted occasionally. When Gradle executes user build scripts from
    multiple sources (for example, in the Continuous Integration environment), it
    might exhaust the daemon process and may cause memory leakage if resources are
    not handled properly. Therefore, it is recommended not to enable the daemon for
    staging or continuous integration environment. Apart from the command-line, Gradle
    can be executed in the **Graphical User Interface** (**GUI**) as well. In the
    next section, we'll discuss the graphical user interface supported by Gradle.
    The other important command-line options such as `–D` or `--system-prop`, `-P`
    or `--project-prop` will be discussed in [Chapter 6](ch06.html "Chapter 6. Working
    with Gradle"), *Working with Gradle*, when we explore more on building Java applications
    with Gradle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然推荐在开发环境中使用 Gradle 守护进程，但它偶尔可能会损坏。当 Gradle 从多个来源执行用户构建脚本（例如，在持续集成环境中）时，可能会耗尽守护进程，如果资源管理不当，可能会导致内存泄漏。因此，建议不要在预发布或持续集成环境中启用守护进程。除了命令行之外，Gradle
    还可以在 **图形用户界面**（**GUI**）中执行。在下一节中，我们将讨论 Gradle 支持的图形用户界面。其他重要的命令行选项，如 `–D` 或 `--system-prop`、`-P`
    或 `--project-prop`，将在 [第 6 章](ch06.html "第 6 章。使用 Gradle") 中讨论，即 *使用 Gradle*，当我们更深入地探讨使用
    Gradle 构建Java应用程序时。
- en: The Gradle GUI
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle 图形用户界面
- en: 'Apart from the command-line arguments and tools, Gradle provides a graphical
    user interface. It can be launched with the help of the following command-line
    option:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令行参数和工具之外，Gradle还提供了一个图形用户界面。您可以通过以下命令行选项启动它：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It launches a **graphical user interface** (**GUI**), which can be used to execute
    Gradle tasks directly from the GUI.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它启动了一个**图形用户界面**（**GUI**），可以直接从GUI中执行Gradle任务。
- en: '![The Gradle GUI](img/B02000_01_01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Gradle GUI](img/B02000_01_01.jpg)'
- en: Figure 1.1
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1
- en: 'It contains four tabs, which are explained as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含四个选项卡，以下是对它们的解释：
- en: '**Task Tree**: The directory, under which you executed this command, is considered
    as the parent project directory. If the `build.gradle` file is present under this
    directory, task tree will list out all the tasks available in the `build.gradle`
    file. If the `build.gradle` file is not in this directory, it will list out only
    the default tasks. You can execute any task by double-clicking on the task name.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务树**：您执行此命令的目录被视为父项目目录。如果此目录下有`build.gradle`文件，任务树将列出`build.gradle`文件中所有可用的任务。如果没有`build.gradle`文件在此目录下，它将只列出默认任务。您可以通过双击任务名称来执行任何任务。'
- en: '*Figure 1.1* displays `failedTask`, `helloGradle` and `test` tasks that we
    developed earlier along with the default Gradle tasks.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图1.1*显示了我们在早期开发的`failedTask`、`helloGradle`和`test`任务，以及默认的Gradle任务。'
- en: '**Favorites**: This works like your browser favorites, where you can save frequently
    used commands. Additionally, it provides an alias feature. In case you want to
    execute multiple tasks on the command line, you can add them here and give it
    a simple display name. For example, you can click on the plus sign and add the
    following tasks in the command-line textbox: `clean build`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收藏夹**：这类似于您的浏览器收藏夹，您可以在此处保存常用命令。此外，它还提供别名功能。如果您想在命令行上执行多个任务，您可以将其添加到此，并给它一个简单的显示名称。例如，您可以点击加号，在命令行文本框中添加以下任务：`clean
    build`。'
- en: Add `init` in the display name area. You will see that **init** appears in the
    **Favorites** area. Next time, just click on **init** to execute `clean build`
    tasks.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在显示名称区域添加`init`。您会看到**init**出现在**收藏夹**区域。下次，只需点击**init**即可执行`clean build`任务。
- en: '**Command line**: This works like the console. Here you can execute single
    or multiple inline commands. It will execute the command and will display the
    result in the lower window.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行**：这类似于控制台。在这里，您可以执行单个或多个内联命令。它将执行命令，并在下方的窗口中显示结果。'
- en: '**Setup**: Even if you started the GUI from a specific project directory, you
    can change the directory using this tab. It allows you to change your current
    directory for executing commands. Along with that, it helps to change some general
    settings such as Log level, Stack Trace output, and so on. It also allows you
    to execute other Gradle versions through the custom Gradle Executor.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：即使您从特定的项目目录启动了GUI，您也可以使用此选项卡更改目录。它允许您更改当前目录以执行命令。此外，它有助于更改一些通用设置，例如日志级别、堆栈跟踪输出等。它还允许您通过自定义Gradle执行器执行其他Gradle版本。'
- en: Start up script
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动脚本
- en: Consider this scenario, for each of your Gradle projects you have a dependency
    on a local in-house jar files. Additionally, you want to set some common environment
    variables for each of your Gradle projects (such as `GRADLE_OPTS`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景，对于您的每个Gradle项目，您都依赖于本地的内部jar文件。此外，您还希望为每个Gradle项目设置一些常见的环境变量（如`GRADLE_OPTS`）。
- en: A simple solution is to add the jar file in the dependency closure. An alternate
    solution could be to create one common build file and include this common file
    in each of the build files.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是将jar文件添加到依赖项闭包中。另一个解决方案可以是创建一个通用的构建文件，并将其包含在每个构建文件中。
- en: The simplest solution Gradle provides for these kinds of problems by introducing
    the initialization script.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle通过引入初始化脚本为这类问题提供了最简单的解决方案。
- en: Initialization scripts are no special files, but a Gradle script with the `.gradle`
    extension. However, this will execute every time before any of your build files
    execute.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化脚本并不是特殊的文件，而是一个具有`.gradle`扩展名的Gradle脚本。然而，这将在执行任何构建文件之前执行。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There can be more than one initialization script.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有多个初始化脚本。
- en: 'Some of the uses of the initialization script are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化脚本的一些用途如下：
- en: Downloading some common jars for each of your projects
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的每个项目下载一些常见的jar文件
- en: Performing common environment configuration related to system details and/or
    user details.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行与系统细节和/或用户细节相关的常见环境配置。
- en: Registering listeners and loggers.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册监听器和记录器。
- en: 'So, how does Gradle find these initialization script(s)? There are multiple
    ways to define the initialization script which are as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Gradle是如何找到这些初始化脚本的呢？定义初始化脚本有多种方式，如下所示：
- en: All the files with `.gradle` extension under `<USER_HOME>/.gradle/init.d` directory
    are treated as initialization scripts. Gradle will execute all the `.gradle` files
    under this directory before the execution of any Gradle build script.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<USER_HOME>/.gradle/init.d`目录下所有扩展名为`.gradle`的文件被视为初始化脚本。Gradle会在执行任何Gradle构建脚本之前，执行此目录下的所有`.gradle`文件。'
- en: Files named `init.gradle` under `<USER_HOME>/.gradle/` are treated as an initialization
    script.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<USER_HOME>/.gradle/`目录下名为`init.gradle`的文件被视为初始化脚本。'
- en: All the files with the `.gradle` extension under `<GRADLE_HOME>/init.d/` directory.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<GRADLE_HOME>/init.d/`目录下所有扩展名为`.gradle`的文件。'
- en: You can even specify any Gradle file as the initialization script with `-I <file
    name>` or `--init-script <file name>`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您甚至可以使用`-I <file name>`或`--init-script <file name>`指定任何Gradle文件作为初始化脚本。
- en: Note
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even if multiple files are found at the location mentioned earlier, Gradle will
    execute all the files as initialization script before executing any project build
    script.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使在前面提到的位置找到多个文件，Gradle也会在执行任何项目构建脚本之前，将这些文件作为初始化脚本执行。
- en: Following is a sample `init` script.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例`init`脚本。
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Copy and paste the preceding code and save it as `init.gradle` file under any
    of the preceding mentioned paths. The `println` statement is intentionally added
    in this file to help you understand the execution cycle of the `init` script.
    Whenever you execute any Gradle script from a directory, you will see `Hello from
    init script`. Apart from printing `Hello from init script`, this script also downloads
    `javax.mail-api-1.4.5.jar` in the Gradle cache when the script is executed for
    the first time. It will not download this library again, unless there is a change
    in the file in the repository. If you don't understand what a cache is, don't
    worry. You will learn more about cache management in the later section of this
    chapter. Remember, sometimes defining too many configurations in the init script
    could be problematic. Specifically, debugging could be difficult because the projects
    are no longer self-contained.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码复制并粘贴，保存为`init.gradle`文件，位于前面提到的任何路径下。`println`语句有意添加到该文件中，以帮助您理解`init`脚本的执行周期。每次您从目录中执行任何Gradle脚本时，您都会看到`Hello
    from init script`。除了打印`Hello from init script`之外，当脚本首次执行时，此脚本还会在Gradle缓存中下载`javax.mail-api-1.4.5.jar`。除非存储库中的文件发生变化，否则它不会再次下载此库。如果您不了解缓存是什么，请不要担心。您将在本章后面的部分学习更多关于缓存管理的内容。记住，有时在初始化脚本中定义过多的配置可能会出现问题。特别是，调试可能会很困难，因为项目不再自包含。
- en: Build life cycle
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建生命周期
- en: 'Gradle build has a life cycle, which consists of three phases: initialization,
    configuration, and execution. Understanding the build life cycle and the execution
    phases is crucial for Gradle developers. Gradle build is primarily a collection
    of tasks and a user can define the dependency between the tasks. So, even if two
    tasks depend on the same task, for example, Task C and Task B both depend on Task
    A, Gradle makes sure that Task A will execute only once throughout the execution
    of the build script.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle构建有一个生命周期，包括三个阶段：初始化、配置和执行。理解构建生命周期和执行阶段对于Gradle开发者至关重要。Gradle构建主要是任务集合，用户可以定义任务之间的依赖关系。因此，即使两个任务依赖于同一个任务，例如，任务C和任务B都依赖于任务A，Gradle也会确保任务A在整个构建脚本执行过程中只执行一次。
- en: Before executing any task, Gradle prepares a **Directed Acyclic Graph** (**DAG**)
    of all tasks for the build. It is directed because a task directly depends on
    another task. It is acyclic because, if Task A depends on Task B and if you make
    Task B depend on Task A, it will result in an error, as there can't be cyclic
    dependency between two tasks. Before executing the build script, Gradle configures
    the task dependency graph.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何任务之前，Gradle为构建准备了一个所有任务的**有向无环图**（**DAG**）。它是定向的，因为一个任务直接依赖于另一个任务。它是无环的，因为如果任务A依赖于任务B，而您让任务B依赖于任务A，这将导致错误，因为两个任务之间不能有循环依赖。在执行构建脚本之前，Gradle配置任务依赖图。
- en: Let's quickly discuss the three build phases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速讨论三个构建阶段。
- en: Initialization
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: User can create a build script for a single project as well as for a Multi-project
    build. During the initialization phase, Gradle determines which projects are going
    to take part in the build process, and creates a Project instance for each of
    these projects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以为单个项目以及多项目构建创建构建脚本。在初始化阶段，Gradle确定哪些项目将参与构建过程，并为这些项目中的每个项目创建一个项目实例。
- en: Configuration
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: This phase configures the project object. All the build scripts (in case the
    user is executing a multiproject build), which are part of the build process are
    executed without executing any task. This means whatever statements you have written
    outside of the task in the configuration block would be executed in the configuration
    phase. No tasks would be executed here; only the directed acyclic graph would
    be created for all tasks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段配置项目对象。所有构建脚本（如果用户正在执行多项目构建），作为构建过程的一部分，都会被执行，而不会执行任何任务。这意味着你在配置块中编写的所有不在任务之外的语句都会在配置阶段执行。这里不会执行任何任务；只会为所有任务创建一个有向无环图。
- en: Execution
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行
- en: In this phase, Gradle executes all tasks as per the order given in the command
    line. However, if any dependencies exist between tasks, those relationships will
    be honored first before the command-line ordering.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，Gradle按照命令行中给出的顺序执行所有任务。然而，如果任务之间存在依赖关系，这些关系将首先得到尊重，然后再按照命令行顺序执行。
- en: Cache management
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存管理
- en: The main focus of any build tool is to not only automate the build and deployment
    processes, but also how to manage the cache effectively. No software works in
    isolation. Each software depends on some third-party libraries and/or in-house
    libraries.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 任何构建工具的主要重点是不仅自动化构建和部署过程，还要有效地管理缓存。没有软件是孤立工作的。每个软件都依赖于某些第三方库和/或内部库。
- en: Any good build tool should automatically take care of software dependencies.
    It should be able to download the dependencies automatically and maintain the
    versioning. When Ant was released, this feature was not available and developers
    need to manually download the dependencies and need to maintain their versioning
    on its own. Though it was later resolved by extending Ant with Ivy.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 任何好的构建工具都应该自动处理软件依赖。它应该能够自动下载依赖项并维护版本。当Ant发布时，这个功能是不可用的，开发者需要手动下载依赖项并自己维护其版本。尽管后来通过扩展Ant以Ivy解决了这个问题。
- en: Gradle automatically downloads all dependencies given in the build file. It
    determines all the libraries needed for the project, downloads from the repositories,
    and stores them in its local cache. Next time when you run the build, it doesn't
    need to download those dependencies again (unless required) as it can reuse the
    libraries from the cache. It also downloads all the transitive dependencies.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle会自动下载构建文件中给出的所有依赖项。它确定项目所需的所有库，从存储库中下载，并将其存储在其本地缓存中。下次您运行构建时，它不需要再次下载这些依赖项（除非需要），因为它可以重用缓存中的库。它还会下载所有传递依赖项。
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有Packt出版物的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Cache location
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存位置
- en: The first question arises regarding cache, in which location Gradle maintains
    its cache. Gradle uses `<USER_HOME>/.gradle/caches` as the default directory to
    store its local cache. It might contain more than one version directory if a developer
    has used multiple versions of Gradle to build the software. The actual cache is
    divided into two parts. All the jars that are downloaded from the repositories
    can be found under `modules-2/files-2.1`. Additionally, you will also find some
    binary files that will store the metadata about the downloaded binaries. If you
    look inside the `modules-2/files-2.1` directory, it has the path in the format
    `group/name/version/checksum`, which contains the actual binary. You can find
    out more about dependency management in detail in [Chapter 5](ch05.html "Chapter 5. Dependency
    Management"), *Dependency Management*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于缓存，首先出现的问题是 Gradle 在哪个位置维护其缓存。Gradle 使用 `<USER_HOME>/.gradle/caches` 作为默认目录来存储其本地缓存。如果开发者使用多个版本的
    Gradle 来构建软件，则可能包含多个版本目录。实际的缓存分为两部分。所有从仓库下载的 JAR 文件都可以在 `modules-2/files-2.1`
    下找到。此外，你还会找到一些存储已下载二进制文件元数据的二进制文件。如果你查看 `modules-2/files-2.1` 目录，它具有 `group/name/version/checksum`
    格式的路径，其中包含实际的二进制文件。你可以在 [第 5 章](ch05.html "第 5 章。依赖项管理") *依赖项管理* 中详细了解依赖项管理。
- en: Change Cache location
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改缓存位置
- en: 'If you want to change the cache location to some other directory, other than
    default location, you need to set the following environment variables. You can
    set this variable in Windows as the environment variable and in the Unix/Linux
    in `.profile` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将缓存位置更改为除默认位置之外的目录，你需要设置以下环境变量。你可以在 Windows 中将其作为环境变量设置，在 Unix/Linux 中在
    `.profile` 文件中设置：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Cache features
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存功能
- en: Now, let's discuss some of the important features of the Gradle cache.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 Gradle 缓存的一些重要功能。
- en: Reduce the traffic
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少流量
- en: One of the main features of Gradle cache management is to reduce the network
    traffic. When you build the application for the first time, Gradle downloads all
    the dependencies into a cache, so that next time onwards it can directly fetch
    it from the cache.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 缓存管理的主要功能之一是减少网络流量。当你第一次构建应用程序时，Gradle 将所有依赖项下载到缓存中，这样下次就可以直接从缓存中获取。
- en: In case multiple repositories are configured in the build script and a JAR is
    found in the first repository, then Gradle won't search other repositories for
    the same JAR file. In another situation, if the JAR was not found in the first
    repository but was fetched from the second repository, then Gradle will store
    metadata information about the first repository, so that next time onwards the
    first repository won't be searched for the missing JAR, to save time and network
    traffic.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构建脚本中配置了多个仓库，并且在一个仓库中找到了 JAR 文件，那么 Gradle 不会在其他仓库中搜索相同的 JAR 文件。在另一种情况下，如果
    JAR 文件在第一个仓库中没有找到，但已从第二个仓库中获取，那么 Gradle 将存储关于第一个仓库的元数据信息，这样下次就不会再搜索缺失的 JAR 文件，以节省时间和网络流量。
- en: Dependency location
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖项位置
- en: Whenever Gradle downloads dependencies from the repositories, it also stores
    the repository location in its metadata. It helps to detect the changes in case
    the binaries are removed from the repositories or their structure is changed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 Gradle 从仓库下载依赖项时，它也会将其元数据中的仓库位置存储起来。这有助于检测变化，以防二进制文件从仓库中删除或其结构发生变化。
- en: Version integration
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本集成
- en: If a developer updates the Gradle version on his machine, and he has already
    downloaded libraries in an older cache, then it is reused. Gradle also provides
    tight integration with Maven's local repository. Gradle figures out whether an
    artifact has changed in the remote repository by comparing its checksum with the
    local cache. All those artifacts whose checksum matches are not downloaded. Apart
    from checksum, Gradle will consider an additional parameter to compare between
    the remote and local artifacts; Gradle uses the value of the HTTP header parameter
    *content-length* or the last modified date.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者更新了他机器上的 Gradle 版本，并且他已经下载了旧缓存中的库，那么这些库将被重用。Gradle 还提供了与 Maven 本地仓库的紧密集成。Gradle
    通过比较其校验和与本地缓存来确定远程仓库中的工件是否已更改。所有校验和匹配的工件都不会下载。除了校验和之外，Gradle 还会考虑一个额外的参数来比较远程和本地工件；Gradle
    使用 HTTP 头参数 *content-length* 或最后修改日期的值。
- en: Switching off remote checking
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭远程检查
- en: With the `--offline` command-line option, a developer can ask Gradle to only
    look at the local cache, not in the remote cache. This could be useful if the
    user is working without any network connectivity. If Gradle can't find the JAR
    in the local cache, the build will fail.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--offline` 命令行选项，开发者可以要求 Gradle 只查看本地缓存，而不是远程缓存。如果用户在没有网络连接的情况下工作，这可能很有用。如果
    Gradle 在本地缓存中找不到 JAR 文件，构建将失败。
- en: Version conflicts
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本冲突
- en: If a developer has not mentioned any specific version of dependency and there
    are multiple versions available for the download, Gradle, by default, always downloads
    the latest version of the artifact.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者没有指定任何特定的依赖版本，并且有多个版本可供下载，那么默认情况下，Gradle 总是下载最新的工件版本。
- en: Gradle with IDE
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle 与 IDE
- en: So far, in this chapter, we have worked on creating some basic Gradle scripts.
    We will conclude this chapter by creating a Java application with Gradle. To create
    a Java application, we'll be using Eclipse IDE with the Gradle plugin.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经创建了一些基本的 Gradle 脚本。我们将通过创建一个使用 Gradle 的 Java 应用程序来结束本章。为了创建 Java
    应用程序，我们将使用带有 Gradle 插件的 Eclipse IDE。
- en: With **Integrated Development Environment** (**IDE**), application development
    becomes much easier. In this section, we will explore how to install the Gradle
    plugin in Eclipse, create a simple Java application, explore Eclipse plugin tasks,
    and execute Gradle tasks from Eclipse.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **集成开发环境**（**IDE**），应用程序开发变得容易得多。在本节中，我们将探讨如何在 Eclipse 中安装 Gradle 插件、创建简单的
    Java 应用程序、探索 Eclipse 插件任务以及从 Eclipse 执行 Gradle 任务。
- en: Apart from Eclipse, another popular IDE is JetBrains IntelliJ IDEA. Gradle also
    supports IDEA plugin, which is very similar to the Eclipse plugin. However, in
    this book, we will focus only on the Eclipse plugin since it is freely available
    and is open source.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Eclipse，另一个流行的 IDE 是 JetBrains IntelliJ IDEA。Gradle 也支持 IDEA 插件，它与 Eclipse
    插件非常相似。然而，在本书中，我们将只关注 Eclipse 插件，因为它免费提供且是开源的。
- en: Installing the Gradle plugin in Eclipse
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Eclipse 中安装 Gradle 插件
- en: 'The Eclipse Integration Gradle project from the spring source ([https://github.com/spring-projects/eclipse-integration-gradle/](https://github.com/spring-projects/eclipse-integration-gradle/))
    helps the developer to work with Gradle in Eclipse. This tool offers support for:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Spring Source 的 Eclipse Integration Gradle 项目（[https://github.com/spring-projects/eclipse-integration-gradle/](https://github.com/spring-projects/eclipse-integration-gradle/））帮助开发者使用
    Eclipse 中的 Gradle。此工具提供以下支持：
- en: Working with multiprojects
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多项目
- en: Using `Gradle Import Wizard` to import Gradle projects into Eclipse
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Gradle Import Wizard` 将 Gradle 项目导入到 Eclipse
- en: Using `New Gradle Project Wizard` to create new Gradle projects
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `New Gradle Project Wizard` 创建新的 Gradle 项目
- en: UsingDependency Management to configure the classpath of the Eclipse project
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖管理来配置 Eclipse 项目的类路径
- en: Executing Gradle tasks using `Gradle Task UI`
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Gradle Task UI` 执行 Gradle 任务
- en: Integration with the Groovy Eclipse via DSLD (DSL Descriptors)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 DSLD（DSL 描述符）与 Groovy Eclipse 集成
- en: 'Following are the steps to install this plugin in Eclipse (3.7.2 or higher)
    from the update site:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Eclipse（3.7.2 或更高版本）更新站点中安装此插件的操作步骤：
- en: Launch Eclipse. Navigate to **Help** | **Install New Software**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse。导航到 **帮助** | **安装新软件**。
- en: In the **Install New Software** dialog, click on the **Add** button to add a
    new site.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **安装新软件** 对话框中，点击 **添加** 按钮以添加新站点。
- en: Enter the **Location** as `http://dist.springsource.com/release/TOOLS/gradle`
    and **Name** as `Gradle`. You can enter any meaningful name you want.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **位置** 输入为 `http://dist.springsource.com/release/TOOLS/gradle`，将 **名称** 输入为
    `Gradle`。您可以输入任何有意义的名称。
- en: Click on **OK** to add the repository.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定** 添加仓库。
- en: Select the newly created Gradle repository from the repository list.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从仓库列表中选择新创建的 Gradle 仓库。
- en: Check only the box next to **Extensions / Gradle Integration** | **Gradle IDE**.
    Click on **Next** (Refer to *Figure 1.2*).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅勾选 **扩展/Gradle 集成** | **Gradle IDE** 旁边的框。点击 **下一步**（参见图 1.2）。
- en: On the next screen, click on **Next**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，点击 **下一步**。
- en: Accept the terms and conditions and click on **Finish**. Eclipse should download
    and install Gradle IDE. Then restart Eclipse.![Installing the Gradle plugin in
    Eclipse](img/B02000_01_02.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受条款和条件并点击 **完成**。Eclipse 应该下载并安装 Gradle IDE。然后重新启动 Eclipse。![在 Eclipse 中安装
    Gradle 插件](img/B02000_01_02.jpg)
- en: Figure 1.2
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.2
- en: Working with the Gradle project in IDE
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 IDE 中使用 Gradle 项目
- en: We have successfully installed Gradle plugin. Now, we'll create a simple Gradle
    project and we'll look into few Eclipse-related important files, for example,
    `.project` and `.classpath`. Then we will build the project using the Gradle Task
    UI.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功安装 Gradle 插件。现在，我们将创建一个简单的 Gradle 项目，并查看一些与 Eclipse 相关的重要文件，例如，`.project`
    和 `.classpath`。然后我们将使用 Gradle 任务 UI 构建项目。
- en: 'Following are the steps to create a Gradle project:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建 Gradle 项目的步骤：
- en: In Eclipse, navigate to **File** | **New** | **Gradle** | **Gradle Project**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Eclipse 中，导航到 **文件** | **新建** | **Gradle** | **Gradle 项目**。
- en: In the **New Gradle Project** window, specify the project name as **FirstGradleProject**
    and select the sample project as **Java Quickstart**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新 Gradle 项目** 窗口中，将项目名称指定为 **FirstGradleProject**，并选择样本项目为 **Java Quickstart**。
- en: Click on **Finish** and wait for the build to be successful.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **完成** 并等待构建成功。
- en: 'You will find the following console output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你将找到以下控制台输出：
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output clearly shows what is going on here. Gradle initially executes a
    series of clean tasks (`cleanEclipseClasspath`, `cleanEclipse`, and so on.), then
    downloads some jar files from the Maven repository and finally executes a few
    more tasks (`eclipseJdt`, `eclipse`, and so on) to complete the build process.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示了这里正在发生的事情。Gradle 首先执行一系列清理任务（`cleanEclipseClasspath`、`cleanEclipse`
    等），然后从 Maven 仓库下载一些 jar 文件，最后执行更多任务（`eclipseJdt`、`eclipse` 等）以完成构建过程。
- en: 'The autogenerated `build.gradle` file has the following contents:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的 `build.gradle` 文件包含以下内容：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `build` file is, quite different from what we created earlier in this chapter.
    The Java and Eclipse plugin declarations were added in the beginning. Project
    properties such as `sourceCompatibility` and version were added. The repository
    was declared as `mavenCentral()`. Dependencies, common-collections, and JUnit
    were configured on `compile` and `testCompile` respectively. We'll learn each
    and every component in the next chapters; now, let's concentrate on the other
    artifacts created by the Gradle project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `build` 文件与我们在本章前面创建的文件相当不同。在开头添加了 Java 和 Eclipse 插件声明。添加了项目属性，如 `sourceCompatibility`
    和版本。仓库声明为 `mavenCentral()`。在 `compile` 和 `testCompile` 上配置了依赖项、common-collections
    和 JUnit。我们将在下一章中学习每个组件；现在，让我们专注于 Gradle 项目创建的其他工件。
- en: If you browse the source code (look for the `src` folder) of the project, you'll
    find that the application was prepopulated with some Java source code and JUnit
    test cases.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览项目的源代码（查找 `src` 文件夹），你会发现应用程序已经预填充了一些 Java 源代码和 JUnit 测试用例。
- en: Apart from the source code and build file,a few other files, namely, `.project`,
    and `.classpath` and a folder, namely, `.settings`, were added to this Java project.
    These are the default files created by Eclipse. As the name suggests, the `.project`
    file contains the metadata information about the project such as name, description
    and build specification. The `.classpath` file describes the Java dependency,
    external library dependencies, and other project dependencies. `.settings/org.eclipse.jdt.core.prefs`
    stores information such as the Java compiler version, source, and the target Java
    version. All these three files were created during the build process when the
    `eclipse` task was executed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了源代码和构建文件外，还添加了一些其他文件，即 `.project`、`.classpath` 和一个文件夹，即 `.settings`。这些都是 Eclipse
    默认创建的文件。正如其名所示，`.project` 文件包含有关项目的元数据信息，如名称、描述和构建规范。`.classpath` 文件描述了 Java 依赖项、外部库依赖项和其他项目依赖项。`.settings/org.eclipse.jdt.core.prefs`
    存储有关 Java 编译器版本、源和目标 Java 版本的信息。所有这三个文件都是在执行 `eclipse` 任务时的构建过程中创建的。
- en: 'So, we claimed that the Eclipse plugin was responsible for creating all of
    the Eclipse IDE-specific files. To confirm, first execute the `gradle cleanEclipse`
    command from the project of the base folder:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们声称 Eclipse 插件负责创建所有 Eclipse IDE 特定的文件。为了确认，首先从基本文件夹的项目中执行 `gradle cleanEclipse`
    命令：
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `cleanEclipse` task executed three more dependent tasks: `cleanEclipseClasspath`
    (removes the `.classpath` file), `cleanEclipseJdt` (removes the `.settings/org.eclipse.jdt.core.prefs`
    file), and `cleanEclipseProject` (removes the `.project` file).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`cleanEclipse` 任务执行了三个额外的依赖任务：`cleanEclipseClasspath`（删除 `.classpath` 文件）、`cleanEclipseJdt`（删除
    `.settings/org.eclipse.jdt.core.prefs` 文件）和 `cleanEclipseProject`（删除 `.project`
    文件）。'
- en: Check whether all the three files got deleted from the project, and, finally,
    execute the `gradle eclipse` command to recreate those files.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这三个文件是否已从项目中删除，最后执行 `gradle eclipse` 命令以重新创建这些文件。
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the question is if I have a Java project, how do I import that project in
    Eclipse IDE?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如果我有一个 Java 项目，我如何在 Eclipse IDE 中导入该项目？
- en: 'We have learned this already and you might have guessed it. It takes just three
    steps: add the Eclipse plugin into the build file (apply the `eclipse` plugin
    ), execute Eclipse task (`gradle eclipse`), and finally import project using **Eclipse
    File** | **Import**.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学过这个了，你可能已经猜到了。只需要三个步骤：将 Eclipse 插件添加到构建文件中（应用 `eclipse` 插件），执行 Eclipse
    任务（`gradle eclipse`），最后使用 **Eclipse 文件** | **导入** 来导入项目。
- en: Alternatively, you can use Gradle IDE. From Eclipse, select the project by navigating
    to **File** | **Import** | **Gradle** | **Gradle Project**, and then perform `Build
    Model` and finish. Use of Gradle IDE helps to avoid all the manual steps mentioned
    earlier.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 Gradle IDE。从 Eclipse 中，通过导航到 **文件** | **导入** | **Gradle** | **Gradle
    项目** 来选择项目，然后执行 `构建模型` 并完成。使用 Gradle IDE 可以帮助避免之前提到的所有手动步骤。
- en: We'll conclude this section by exploring Gradle Task UI, which enables us to
    execute tasks. Gradle task execution is supported by the standard Eclipse launching
    framework. This means that before we execute any task, we must create a standard
    Eclipse launch configuration. To create the launch configuration, navigate to
    **Gradle project** | **Run As** | and click on **Gradle Build**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过探索 Gradle 任务 UI 来结束本节，它使我们能够执行任务。Gradle 任务执行由标准的 Eclipse 启动框架支持。这意味着在执行任何任务之前，我们必须创建一个标准的
    Eclipse 启动配置。要创建启动配置，请导航到 **Gradle 项目** | **运行方式** | 并点击 **Gradle 构建**。
- en: In the text area, enter the task names you want to execute, such as `clean build`.
    Then click on **Run** to execute the tasks. The launch configuration will be saved
    as the project name by default. In *Figure 1.3*, the configuration is saved as
    **FirstGradleProject**, which is the project name.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本区域中，输入您想要执行的任务名称，例如 `clean build`。然后点击 **运行** 来执行任务。默认情况下，启动配置将保存为项目名称。在
    *图 1.3* 中，配置保存为 **FirstGradleProject**，这是项目名称。
- en: '![Working with the Gradle project in IDE](img/B02000_01_03.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![在 IDE 中使用 Gradle 项目](img/B02000_01_03.jpg)'
- en: Figure 1.3
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3
- en: This launch configuration will be saved in Eclipse, so that it can be executed
    again. To launch the previously saved configuration, **FirstGradleProject**, you
    need to navigate to **Run As** | **Gradle Build**. This will once again, execute
    the `clean build` command.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启动配置将被保存在 Eclipse 中，以便可以再次执行。要启动之前保存的配置 **FirstGradleProject**，您需要导航到 **运行方式**
    | **Gradle 构建**。这将再次执行 `clean build` 命令。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we briefly discussed what a Build Automation System is, why
    do we need it, and why Gradle is a popular Build Automation System. You also learned
    how to install Gradle and we created our first Gradle script. Then we discussed
    the command-line options, GUI support, cache management, and startup scripts.
    Finally, we concluded the chapter working with Eclipse IDE with the Gradle Plugin
    to develop a simple Java application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要讨论了什么是构建自动化系统，为什么我们需要它，以及为什么 Gradle 是一个流行的构建自动化系统。您还学习了如何安装 Gradle，并创建了我们的第一个
    Gradle 脚本。然后我们讨论了命令行选项、GUI 支持、缓存管理和启动脚本。最后，我们使用带有 Gradle 插件的 Eclipse IDE 开发了一个简单的
    Java 应用程序。
- en: All the build scripts developed in this chapter were written in Groovy, but
    we have not talked about it. So, in the next chapter, we will learn some basic
    concepts of the Groovy programming language. Next chapter is meant mainly for
    developers who already have some basic knowledge of Java and object-oriented programming
    concepts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中开发的全部构建脚本都是用 Groovy 编写的，但我们还没有讨论它。因此，在下一章中，我们将学习 Groovy 编程语言的一些基本概念。下一章主要面向已经具备一些
    Java 和面向对象编程概念基本知识的开发者。
