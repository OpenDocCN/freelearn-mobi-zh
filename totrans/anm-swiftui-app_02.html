<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor034"/>2</h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor035"/>Understanding Animation with SwiftUI</h1>
<p>In the first chapter, we covered many SwiftUI fundamentals we will see when we start building projects. In this chapter, we will look at how animations work, including timing curves and animatable properties, which will lay the foundation for the projects we build. </p>
<p>The following are the key topics we will explore:</p>
<ul>
<li>What is animation? </li>
<li>Understanding timing curves </li>
<li>Understanding animation types </li>
<li>Triggering animations </li>
<li>Exploring animatable properties</li>
</ul>
<h1 id="_idParaDest-33"><a id="_idTextAnchor036"/>Technical requirements</h1>
<p>You can find the code for this chapter on GitHub in the <code>Chapter 2</code> folder: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor037"/>What is animation?</h1>
<p>Let’s <a id="_idIndexMarker118"/>consider the book’s definition of animation. <strong class="bold">Animation</strong> is a series of static images displayed in rapid succession to create the illusion of motion. The images, or frames, are usually displayed at a rate of 24 or 30 frames per second from the beginning to the end, which is fast enough to create the illusion of continuous motion. These can be created using a variety of techniques, including hand-drawn, computer-generated, and stop-motion animations.</p>
<p>Looking at this definition, we can see that there is a start point and an end point to animation, and the images in between are all slightly different; when played, our eyes cannot pick out the individual images, which means we perceive movement or animation.</p>
<p>In SwiftUI, we have <a id="_idIndexMarker119"/>to define the start point (where the animation begins) and the end point (where the animation ends). However, when we code, we don’t actually put a bunch of still images between both end points (though we can); what we usually do is use a single image and then animate the properties of that image, such as its location on the screen, its opacity, or its color. </p>
<p>In addition to images, we can also animate RGB colors by changing their hue or the corner radius of shapes, and if we draw a shape, we can animate the individual lines (paths) or the strokes around it.</p>
<p>It works like this: if we want a rectangle to move from the bottom left to the top right of the iPhone or iPad screen, we declare it in code (that declarative syntax thing again) by using the <code>animation</code> modifier. Then SwiftUI does the magic for us, moving the object, or in SwiftUI speak, “transitioning” the object from a start point to an end point, filling in all the gaps along the way with whatever values we are working with (integers, colors, opacity, etc.). The process of going through all the values to create a smooth fluid motion is <a id="_idIndexMarker120"/>called <strong class="bold">interpolation</strong>.</p>
<p>SwiftUI fills in those gaps for us really well, but it cannot animate every property of every view. Only properties considered “animatable” can be animated; things such as a view’s color, opacity, rotation, size, position, corner radius, and strokes. Nearly all properties that have a numerical value are animatable.</p>
<p>SwiftUI includes basic animations with default or custom easing or timing curves (a timing curve refers to the speed at the start and end of the animation), as well as spring animations. Spring animations have a bouncy effect to them and can be adjusted from a slight bounce to a very pronounced bounce, similar to a rubber ball bouncing on the floor.</p>
<p>You can also change many customization options, such as the speed of an animation, add a “wait” time before the animation starts, and have an animation repeat itself.</p>
<p>Let’s continue by diving deeper into animation timing curves, seeing what they look like and how they affect an animation.</p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor038"/>Understanding timing curves</h1>
<p>Animations<a id="_idIndexMarker121"/> have what are called curves. A <strong class="bold">curve</strong>, or <a id="_idIndexMarker122"/>more specifically, a <strong class="bold">timing curve</strong>, refers to the speed at which the animation starts and how it should end.</p>
<p>SwiftUI provides several timing curves to choose from that we can use inside the <code>animation</code> modifier. It’s called a timing curve because if you were to plot each point of the animation’s movement from start to finish on a graph, and draw a line by connecting those points, most of them would create a curved line, as in this illustration:</p>
<div><div><img alt="Figure 2.1: The ease timing curves " src="img/B18674_02_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: The ease timing curves</p>
<p>This graph shows three <a id="_idIndexMarker123"/>animation timing curves: <code>easeInOut</code><code><a id="_idIndexMarker128"/></code> timing curve, the animation starts slow, speeds up, and then finally slows down before coming to a complete stop.</p>
<p>There is <a id="_idIndexMarker129"/>also a<a id="_idIndexMarker130"/> linear timing curve. An animation using this curve will have the same rate of speed at its beginning as it does at its end. If you were to plot it on a graph, it would be a straight line, like so:</p>
<div><div><img alt="Figure 2.2: The linear timing curve " src="img/B18674_02_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: The linear timing curve</p>
<p>Timing curves are <a id="_idIndexMarker131"/>not complicated – we get to choose the ones <a id="_idIndexMarker132"/>we want based on how we want the animation to look and perform. If you don’t specify a timing curve, you will get the default curve, the <code>easeInOut</code> one. We will use some of these SwiftUI-provided timing curves in our projects.</p>
<p>In the next section, I want to explain the two distinct types of animation in SWiftUI: implicit and explicit.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor039"/>Understanding animation types</h1>
<p>There are two types of animations in SwiftUI: implicit and explicit. Let’s look at what these animation types do and the difference between the two.</p>
<p>An <code>animation</code> modifier. Here is an example:</p>
<pre class="source-code">
struct ContentView: View {
    @State private var grow: CGFloat = 1
    var body: some View {
        Circle()
            .frame(width: 100, height: 100)
            .foregroundColor(.blue)
            .onTapGesture {
                self.grow += 0.5
            }
            .scaleEffect(grow)
            .animation(.default, value: grow)
    }
}</pre>
<p>In this example, we <a id="_idIndexMarker135"/>use a tap gesture to scale up the size of a circle; when tapped, the circle will grow by half its size. The <code>.animation</code> modifier uses the default animation style, which will animate the circle using an<a id="_idIndexMarker136"/> easeInOut timing curve by default.</p>
<p>You can also use other animation styles. For example, here, I added a <code>spring</code> style instead of the default style:</p>
<pre class="source-code">
var body: some View {
        Circle()
••••••••
            .scaleEffect(grow)
            .animation(.spring(dampingFraction: 0.3,blendDuration: 0.5),value: grow)
    }</pre>
<p>This style will animate the circle and add a springy effect to it.</p>
<p>So implicit animations are a convenient way to add basic animations to your SwiftUI app without having to write any explicit animation code. The animations are applied using the <code>animation</code> modifier. </p>
<p>Sometimes though, you <a id="_idIndexMarker137"/>may want more from your animation, and implicit animations may not give you the degree of control that you are looking for. In this case, you can use explicit animations instead.</p>
<p>An <code>withAnimation</code> function. Here’s an example:</p>
<pre class="source-code">
struct ContentView: View {
    @State private var scaleUp: CGFloat = 1
    var body: some View {
        Button(action: {
            //Animate the scale of the view when the button is               tapped
            withAnimation(.interpolatingSpring(stiffness: 60,               damping: 2)) {
                scaleUp *= 1.4
            }
        }) {
            Text("Scale up")
                .scaleEffect(scaleUp)  // explicit animation
        }
    }
}</pre>
<p>In this example, tapping the button will animate the scale of the text using a spring animation. The duration of the animation will be determined by the system’s default animation settings, but the curve of the animation will be customized using the <code>interpolatingSpring</code> function.</p>
<p>Additionally, you can <a id="_idIndexMarker140"/>customize the duration of the animation by specifying a <code>duration</code> parameter in the <code>interpolatingSpring</code> function. The following is an example of this:</p>
<pre class="source-code">
withAnimation(.interpolatingSpring(stiffness: 60, damping: 2, duration: 2.5)) { scaleUp *= 1.5 }</pre>
<p>This will cause the animation to last for <code>2.5</code> seconds.</p>
<p>So, the <a id="_idIndexMarker141"/>difference when using explicit animations versus implicit animations is that they can give you more control over the details of the animation, or when you want to animate multiple properties simultaneously; you can put as much code into the <code>withAnimation</code> block as needed. However, they can be more work to set up than implicit animations.</p>
<p>You can also have the animation repeat itself a pre-set number of times or indefinitely. Here’s an example of repeating the previous animation forever and auto-reversing it:</p>
<pre class="source-code">
withAnimation(.interpolatingSpring(stiffness: 60, damping: 2).repeatForever(autoreverses: true)) {
                    scaleUp *= 1.4
                }</pre>
<p>In the previous example, I altered the code in the <code>withAnimation</code> function to include the <code>repeatForever</code> option and set the <code>autoreverses</code> parameter to <code>true</code>. When you run the code, the text will scale up with a springy effect, and when it’s done bouncing (about 3 seconds or so), the animation will start over, repeating endlessly or until the app is stopped.</p>
<p>Those are the two types of animations; next is a list of ways to trigger animations.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor040"/>Triggering animations</h1>
<p>So, how<a id="_idIndexMarker142"/> do we trigger animations? There are several ways to do so in SwiftUI, including using the following SwiftUI modifiers, methods, and functions:</p>
<ul>
<li>The <code>.animation()</code> modifier: This <a id="_idIndexMarker143"/>modifier allows you to specify the type of animation used when a view appears or disappears or when its state changes.</li>
<li>The <code>withAnimation()</code> function: This <a id="_idIndexMarker144"/>function allows you to wrap a block of code that changes the state of a view, and it will automatically animate the changes.</li>
<li>A <strong class="bold">gesture</strong>: This <a id="_idIndexMarker145"/>is a way to interact with a view by performing actions such as tapping, dragging, or pinching. You can use a gesture to trigger an animation when a certain action is performed on a view.</li>
<li>A <strong class="bold">timer</strong>: This <a id="_idIndexMarker146"/>allows you to specify an animation to be performed over a certain period of time. You can use a timer to animate the changes to a view’s state over a specific duration.</li>
<li>The <code>onAppear()</code> and <code>onDisappear()</code> modifiers: These modifiers allow you to specify <a id="_idIndexMarker147"/>code to be <a id="_idIndexMarker148"/>executed when a view appears or disappears. These modifiers can trigger an animation when a view appears or disappears.</li>
<li>Button and other control views: A button, slider, picker, or other control type view in SwiftUI <a id="_idIndexMarker149"/>can be<a id="_idIndexMarker150"/> a trigger for an animation.</li>
</ul>
<p>There are other<a id="_idIndexMarker151"/> ways to trigger animations, but these are the main ones that we will cover here. Whatever you choose will depend on the specific needs of your app and the behavior you want to produce. We will explore these different triggers when we start building our projects in the coming chapters.</p>
<p>Let’s continue by looking at various properties that can be animated in SwiftUI.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor041"/>Exploring animatable properties</h1>
<p>In this section, we<a id="_idIndexMarker152"/> will explore some of the animatable properties. Here is a list of the ones that we will look at:</p>
<ul>
<li>Offset</li>
<li>Hue rotation</li>
<li>Opacity </li>
<li>Scale</li>
<li>Stroke</li>
<li>Trim</li>
<li>Corner radius</li>
</ul>
<p>Let’s take a look at them in more detail.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor042"/>The offset property</h2>
<p>The<a id="_idIndexMarker153"/> first property we will look at that is animatable is the <code>offset</code> modifier that has been placed on a rectangle shape:</p>
<pre class="source-code">
struct Offset_Example: View {
    @State private var moveRight = false
    var body: some View {
       //MARK: - ANIMATE OFFSET
        VStack {
            RoundedRectangle(cornerRadius: 20)
                .foregroundColor(.blue)
                .frame(width: 75, height: 75)
                .offset(x: moveRight ? 150 : 0, y: 350 )
                .animation(Animation.default, value: moveRight)
            Spacer()
            Button("Animate") {
                moveRight.toggle()
            }.font(.title2)
        }
    }
}</pre>
<p>After you<a id="_idIndexMarker155"/> put that code into your <code>ContentView</code> file, your preview will look like <em class="italic">Figure 2</em><em class="italic">.3</em>. When you press the <strong class="bold">Animate</strong> button, the blue rectangle will move to the right, and when you press it again, it will return to its original starting position.</p>
<div><div><img alt="Figure 2.3: Animating the offset " src="img/B18674_02_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: Animating the offset</p>
<p>This is how the code works. When the <code>moveRight</code> variable has its value toggled or changed to <code>true</code>, and the <code>offset</code> modifier has a ternary operator in there for its <code>x</code> parameter.</p>
<p>A<a id="_idIndexMarker156"/> ternary operator<a id="_idIndexMarker157"/> is an operator that accepts a Boolean <a id="_idIndexMarker158"/>variable and checks to see whether it’s <code>true</code> or <code>false</code>. If the variable is <code>true</code>, the value to the left of the colon is used, but if the variable is <code>false</code>, the value to the right of the colon is used. This makes it similar to an if statement but different because an <code>if</code> statement can check for multiple conditions.</p>
<p>So, if <code>moveRight</code> is <code>true</code>, then the rounded rectangle is placed <code>150</code> points to the right; otherwise, if <code>false</code>, it is left where it is (the <code>0</code> value means do nothing). The <code>animation</code> modifier also picks up on any change because it has the <code>moveRight</code> variable in there for the <code>value</code> parameter. This <code>value</code> parameter takes the variable that you are using for the animation. The <code>animation</code> modifier will then interpolate over the values from the start to the finish point and move the object smoothly, creating a nice, fluid animation.</p>
<p>Here’s a way to really see how the <code>animation</code> modifier is working. If you comment out the <code>animation</code> statement in the code and press the button, you will see that the object still moves <code>150</code> points to the right, but it does so instantly; there is no gliding across the screen now; the object just appears at its new location <code>150</code> points to the right. To create smooth, fluid animations, we need that <code>animation</code> modifier and its behind-the-scenes interpolating magic. This is part of the reason why we use less code in SwiftUI versus coding animation in UIKit; much of the heavy lifting is already done for us in the background with SwiftUI.</p>
<p>This was an example of animating an object from one point to another by changing the numerical value for the <code>x</code> parameter in the <code>offset</code> modifier. Let’s look at another property that’s animatable: <code>HueRotation</code>.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor043"/>Hue rotation</h2>
<p><strong class="bold">Hue rotation</strong> is a<a id="_idIndexMarker159"/> type <a id="_idIndexMarker160"/>of color effect that can be applied to views and other components. It’s a modifier that allows you to adjust the hue of a color by adding or subtracting a fixed angle from its hue value. You can use hue rotation to create a range of related colors.</p>
<p>The modifier has an <code>angle</code> parameter that takes a value in radians or degrees. That value is based on a circle, which<a id="_idIndexMarker161"/> is 360 degrees and represents a wheel of all the colors that we can think of. </p>
<p>Let’s look at an <a id="_idIndexMarker162"/>Xcode example:</p>
<pre class="source-code">
struct Hue_Rotation_Example: View {
    @State private var hueRotate = false
        var body: some View {
        //MARK: - ANIMATE HUE ROTATION
        VStack(spacing: 20) {
            Text("ANIMATE HUE ").font(.title2).bold()
            // rotate the colors and stop halfway around the               color wheel
            RoundedRectangle(cornerRadius: 25)
                .frame(width: 200, height: 200)
                .foregroundColor(.red)
                .hueRotation(Angle.degrees(hueRotate ? 180 :                   0))
                .animation(.easeInOut(duration: 2), value:                   hueRotate)
            // rotate the colors around the color wheel one               full revolution (360 degrees)
            Divider().background(Color.black)
            Text("ANIMATE HUE WITH GRADIENT").font(.title2).              bold()
            AngularGradient(gradient: Gradient(colors: [Color.              red, Color.blue]), center: .center)
                .hueRotation(Angle.degrees(hueRotate ? 360 :                   0))
                .animation(.easeInOut(duration: 2), value:                   hueRotate)
                .mask(Circle())
                .frame(width: 200, height: 200)
            Button("Animate") {
                hueRotate.toggle()
            }
            .font(.title)
        }
    }
}</pre>
<p>When <a id="_idIndexMarker163"/>you<a id="_idIndexMarker164"/> add the code into Xcode, your previews will look like <em class="italic">Figure 2</em><em class="italic">.4</em>:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div><div><img alt="Figure 2.4: Animating the hue rotation " src="img/B18674_02_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: Animating the hue rotation</p>
<p>I created two <a id="_idIndexMarker165"/>objects in this example: a rounded<a id="_idIndexMarker166"/> rectangle and an angular gradient circle. </p>
<p>In the rounded rectangle, I used a ternary operator to check whether the <code>hueRotate</code> variable is <code>true</code>. When it becomes <code>true</code> via the <strong class="bold">Animate</strong> button being pressed, the value to the left of the colon inside the ternary operator is used, 180 degrees. Then the animation starts going through the color spectrum and stops halfway through to display that color. </p>
<p>Notice the use of the <code>duration</code> function just after the timing curve. This function allows us to set the duration of the animation; do we want it to happen fast, or do we want the animation to happen over a longer period? It has one parameter, and that is the amount of time we want the animation to take to complete; for that, we use an integer value. I set the value to <code>2</code>, so it can slow things down a little, taking the animation 2 seconds to complete.</p>
<p>Looking at the angular<a id="_idIndexMarker167"/> gradient example, I’m using a value of <code>360</code> degrees. When we press the <strong class="bold">Animate</strong> button, the code animates through the entire color wheel and stops where it started (360 degrees is one revolution of a circle), thus displaying the original color. </p>
<p>Taking a look <a id="_idIndexMarker168"/>at the <code>hueRotate</code> variable inside the body of the button, we have two ways that we can start the animation. The first is by explicitly setting <code>hueRotate</code> to <code>true</code>, like this:</p>
<pre class="source-code">
hueRotate = true</pre>
<p>Or by using the <code>toggle</code> method like we’re doing in the code:</p>
<pre class="source-code">
hueRotate.toggle()</pre>
<p>The difference between these two ways of starting the animation is that firstly, the animation starts and then finishes, but it never reverses itself with subsequent button presses. If you’d like the animation to start and finish, and on the next button press reverse itself, then use the <code>toggle</code> method.</p>
<p>What’s also very interesting is that we can animate the colors of shapes and other objects, but also animate the colors that make up images, as we will see in the upcoming projects.</p>
<p>You can also use the <code>hueRotation()</code> modifier in combination with other modifiers, such as <code>brightness()</code> or <code>saturation()</code>, to create some complex and interesting color adjustments.</p>
<p>Let’s continue looking at the different properties to animate and at a very common property, <code>opacity</code>. </p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor044"/>Opacity</h2>
<p><code>opacity</code> modifier to make views appear and disappear. When we add animation to the opacity, the transition from shown to hidden is interpolated over, so it smoothly fades in and out.</p>
<p>Here's an example of adding <a id="_idIndexMarker171"/>opacity to an <a id="_idIndexMarker172"/>animation:</p>
<pre class="source-code">
struct Opacity__Example: View {
    @State private var appear = true
    var body: some View {
//MARK: - ANIMATE OPACITY
        VStack{
            Text("Appear/Disappear")
                .font(.title).bold()
            Circle()
                .foregroundColor(.purple)
                .opacity(appear ? 1 : 0)
                .animation(.easeIn, value: appear)
                .frame(height: 175)
            Button("Animate") {
                appear.toggle()
            }.font(.title2)
            //MARK: - OVERLAPPING OPACITY
            VStack{
                Text("Overlapping Opacity").bold()
                    .font(.title)
                Circle()
                    .foregroundColor(.yellow)
                    .frame(height: 100)
                    .opacity(0.5)
                Circle()
                    .foregroundColor(.red)
                    .frame(height: 100)
                    .opacity(0.5)
                    .padding(-60)
            }.padding(60)
        }
    }
}</pre>
<p>The <a id="_idIndexMarker173"/>preceding <a id="_idIndexMarker174"/>code will produce the following results, as shown in <em class="italic">Figure 2</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 2.5: Animating the opacity " src="img/B18674_02_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: Animating the opacity</p>
<p>In our first <a id="_idIndexMarker175"/>example, the animation variable is called <code>appear</code>, and it’s set to <code>true</code> as its default value, which shows the circle. When the <code>false</code>, and the circle animates itself until it completely disappears. And when the button is pressed again, the animation gets set to <code>true</code>, and the circle becomes visible again. Again, using the <code>animation</code> modifier initiates the interpolation over the start and end values, so the circle doesn’t just appear or disappear instantly; there is a gradual change of state until the end of the animation is reached.</p>
<p>The second example of the two circles overlapping at the bottom of the screen demonstrates a unique component of opacity in SwiftUI. When we apply the <code>opacity</code> modifier to a view that already had its opacity transformed, the modifier will multiply the overall effect. For example, the yellow and red circles have their opacity set at 50%, overlapping each other. The<a id="_idIndexMarker177"/> top red circle allows some of the bottom yellow circle to show through, thus<a id="_idIndexMarker178"/> multiplying the opacity effect so that area is a little darker, and at the same time, mingling the two colors, creating orange.</p>
<p>Next, let’s take a look at animating the size or scale of a view, which we can do with the <code>scaleEffect</code> modifier.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor045"/>Scale</h2>
<p>Every view has a<a id="_idIndexMarker179"/> specific size, and we can change that size by <a id="_idIndexMarker180"/>scaling it up or <a id="_idIndexMarker181"/>down with animation. We can do this with the <code>scaleEffect</code> modifier. Here’s an example of how we can animate the scale of a view:</p>
<pre class="source-code">
struct Scale_Example_One: View {
    @State private var scaleCircle = false
    var body: some View {
            //MARK: - ANIMATE THE SCALE OF A CIRCLE SHAPE
            VStack {
                Text("SCALE SHAPE").font(.title).bold()
                Circle()
                    .frame(width: 150)
                    .foregroundColor(.green)
                    .scaleEffect(scaleCircle ? 0.1 : 1)
                    .animation(.default, value: scaleCircle)
                Button("Scale Shape") {
                    scaleCircle.toggle()
                }
            }.font(.title2)
        }
    }</pre>
<p> The preceding code will produce the following results, as shown in <em class="italic">Figure 2</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 2.6: Scaling a shape " src="img/B18674_02_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: Scaling a shape</p>
<p>You should <a id="_idIndexMarker182"/>be starting<a id="_idIndexMarker183"/> to recognize much of the code that we’re using; for example, we use a <code>VStack</code> to hold our views, so they get stacked vertically, and we can use the button control as a way to start the animation.</p>
<p>In the example, I’m creating a simple green circle and using the <code>scaleEffect</code> modifier, passing in our animating variable. When the state changes to <code>true</code>, the circle scales down to one-tenth of its size, and when <code>false</code>, it goes back to its original size. </p>
<p>We’re using <a id="_idIndexMarker184"/>the <code>animation</code> modifier again with the default timing curve. The default curve is an easeInOut curve, which we discussed earlier in the chapter. An easeInOut curve will cause the animation to start slowly, then ramp up to its top speed, and then finish by easing out slowly again.</p>
<p>Let’s look <a id="_idIndexMarker185"/>at another example of scaling up and down, but instead of scaling a shape that we created using the circle initializer, we’re using a system image to show you that you can also scale images:</p>
<pre class="source-code">
struct Scale_Example_Two: View {
    @State private var scaleBug = false
    var body: some View {
        //MARK: - ANIMATE THE SCALE OF A SYSTEM IMAGE
        VStack{
            Text("SCALE IMAGE").font(.title).bold()
            Image(systemName: "ladybug.fill")
                .renderingMode(.original) //allows multicolor                   for SF Symbols
                .resizable()
                .frame(width: 150, height: 150, alignment:                   .center)
                .scaleEffect(scaleBug ? 0.1 : 1)
                .animation(.default, value: scaleBug)
                .padding(10)
            Button("Scale Image") {
                scaleBug.toggle()
            }
        }.font(.title2)
    }
}</pre>
<p>The preceding <a id="_idIndexMarker186"/>code will produce the following results, as shown in <em class="italic">Figure 2</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 2.7: Scaling an image " src="img/B18674_02_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: Scaling an image</p>
<p>This particular <a id="_idIndexMarker187"/>image is a system image from the <em class="italic">SF Symbols</em> app. If you don’t have this app yet, I highly recommend it. You can download it for free at the Apple Developer portal. In it, Apple has given us thousands of images we can use in our code. And what’s new in the latest release is that now, many of the images can be rendered in multicolor: we have to set the rendering mode to <code>.original</code> so the image gets shown with colors, instead of just black or white. </p>
<p class="callout-heading">Note</p>
<p class="callout">Not all images can be colored. Look in the SF Symbols app to see which ones can be colored.</p>
<p>Finally, in<a id="_idIndexMarker188"/> this third <a id="_idIndexMarker189"/>example of a scaling animation, we use the <code>anchor</code> method, which scales the view by the given amount in both the horizontal and vertical directions relative to an anchor point:</p>
<pre class="source-code">
struct Scale_Example_Three: View {
    @State private var scaleFromAnchor = true
    var body: some View {
                VStack{
            Text("SCALE FROM ANCHOR ").font(.title).bold()
            Image(systemName: "heart.fill")
                .renderingMode(.original) //allows the use of                   multicolor for SF Symbols
                .resizable()
                .frame(width: 150, height: 125, alignment:                   .center)
                .scaleEffect(scaleFromAnchor ? 1 : 0.2, anchor:                   .bottomTrailing)
                .animation(.default, value: scaleFromAnchor)
                .padding(10)
            Button("Scale from Anchor") {
                scaleFromAnchor.toggle()
            }
        }.font(.title2)
    }
}</pre>
<p>The <a id="_idIndexMarker190"/>preceding<a id="_idIndexMarker191"/> code will produce the following results, as shown in <em class="italic">Figure 2</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 2.8: Scaling from an anchor point " src="img/B18674_02_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: Scaling from an anchor point</p>
<p>All views have an anchor point, which is usually in the middle of the view. But we can change that anchor point, and have the animation scale the object based on where that anchor point is. In the code, I used the <code>.bottomTrailing</code> option as the anchor point, so when <a id="_idIndexMarker192"/>we press the button, the heart image scales down and toward the trailing edge (the right side of the screen), rather than scaling from the center of the object. However, SwiftUI also <a id="_idIndexMarker193"/>gives us the following anchor points to choose from:</p>
<ul>
<li><code>bottomTrailing</code></li>
<li><code>trailing </code></li>
<li><code>bottom</code></li>
<li><code>center</code></li>
<li><code>top</code></li>
<li><code>bottomLeading</code></li>
<li><code>topLeading</code></li>
<li><code>topTrailing</code></li>
<li><code>leading</code></li>
</ul>
<p>In this final section, we will look at three more properties that can be animated: <code>stroke</code>, <code>trim</code>, and <code>cornerRadius</code>.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor046"/>Stroke, trim, and corner radius</h2>
<p>Let’s now look at three more properties we can animate: the stroke of a line, the trim of a circle, and the corner radius of a rectangle.</p>
<p>The <strong class="bold">stroke</strong> of a <a id="_idIndexMarker194"/>shape is the outline or border of the<a id="_idIndexMarker195"/> shape. It has a particular color and width and can have various attributes such as line cap style or line join style. Let’s animate the stroke of a rectangle, so it gets thicker or thinner with each button press:</p>
<pre class="source-code">
struct Stroke_Example: View {
    @State private var animateStroke = false
    var body: some View {
        //MARK: - ANIMATE THE STROKE OF THE ROUNDED RECT
        VStack{
            Text("ANIMATE STROKE").font(.title).bold()
            RoundedRectangle(cornerRadius: 30)
                .stroke(Color.purple, style:                   StrokeStyle(inewidth: animateStroke ? 25 :                   1))
                .frame(width: 100, height: 100)
                .animation(.default, value: animateStroke)
            Button("Animate Stroke") {
                animateStroke.toggle()
            }
        }.font(.title2)
    }
}</pre>
<p>Either a thick or<a id="_idIndexMarker196"/> thin <a id="_idIndexMarker197"/>stroke line is created around the rectangle, as shown in <em class="italic">Figure 2</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 2.9: Animating the stroke " src="img/B18674_02_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: Animating the stroke</p>
<p>The <a id="_idIndexMarker198"/>first thing <a id="_idIndexMarker199"/>we do is define our animation variable, setting its initial value to <code>false</code>. Looking inside the <code>stroke</code> modifier, I pass the <code>animateStroke</code> variable as an argument to the line <code>width</code> parameter, so when it does become <code>true</code>, it changes <code>stroke</code> to <code>25</code> points (otherwise, it will be <code>1</code> point). Again, we also use the default timing curve inside the <code>animation</code> modifier, and when we run this, <code>stroke</code> is smoothly modified from a thickness of <code>25</code> points, then back to <code>1</code> point when the button is pressed again.</p>
<p>Here is<a id="_idIndexMarker200"/> another example where<a id="_idIndexMarker201"/> we are using the <code>trim</code> modifier this time:</p>
<pre class="source-code">
struct Trim_Example: View {
    @State private var animateTrim = false
    @State private var circleTrim: CGFloat = 1.0
    
    var body: some View {
        //MARK: - ANIMATE THE TRIM MODIFIER OF A CIRCLE
        VStack {
            Text("ANIMATE TRIM").font(.title).bold()
                .padding(.top, 10)
            Circle()
                .trim(from: 0, to: circleTrim)
                .stroke(Color.red, style: StrokeStyle(inewidth:                   30, lineCap: CGLineCap.round))
                .frame(height: 150)
                .rotationEffect(.degrees(180))
                .animation(.default, value: animateTrim)
                .padding(.bottom, 20)
            Button("Animate Trim") {
                animateTrim.toggle()
                circleTrim = animateTrim ? 0.25 : 1
            }
        }.font(.title2)
    }
}</pre>
<p>The <code>trim</code> modifier<a id="_idIndexMarker202"/> takes<a id="_idIndexMarker203"/> two parameters: <code>from</code> (meaning what part of the circle we want to start trimming from) and <code>to</code> (meaning where we want to end the trimming). The <code>from</code> parameter is set to <code>0</code>, which means there will be a complete circle on the screen as we are not trimming yet. The code produces the following results, a circle that has its line trimmed off and restored when the button is pressed, as<a id="_idIndexMarker204"/> shown in <em class="italic">Figure 2</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 2.10: Animating the trim " src="img/B18674_02_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: Animating the trim</p>
<p>Also, notice <a id="_idIndexMarker205"/>we use two <code>@State</code> variables to work with the <code>trim</code> modifier, one called <code>animateTrim</code>, to trigger the animation, and one called <code>circleTrim</code>, which is a numerical value of the <code>CGFloat</code> type. This variable will hold the amount of circle we want to trim off. Initially, it gets set to <code>1</code>, so the whole circle is visible.</p>
<p class="callout-heading">Note</p>
<p class="callout">A <code>CGFloat</code> type is <a id="_idIndexMarker206"/>a floating-point number. <strong class="bold">CG</strong> stands<a id="_idIndexMarker207"/> for <strong class="bold">Core Graphics</strong>, which is an older coding paradigm was used in Apple’s graphic framework, but is still used in SwiftUI.</p>
<p>Looking inside the<a id="_idIndexMarker208"/> button code, then <a id="_idIndexMarker209"/>within the <code>circleTrim</code> variable, we’re storing one of two values using the ternary operator: either <code>.25</code>, or <code>1</code>. This means that when <code>animateTrim</code> toggles to <code>true</code>, the code trims off 75% of the circle and leaves 25%; when <code>animateTrim</code> toggles to <code>false</code>, the value of <code>1</code> is used, which represents 100% of the circle. So, the values in the ternary operator represent how much of the circle to keep.</p>
<p>If we run the code, we see we have a nice trimming animation of this circle. The line of code called <code>CGLineCap.round</code> refers to the shape of the line that’s drawn at the end points, and it can be <code>round</code>, <code>square</code>, or <code>butt </code><code>line cap</code>.</p>
<p>And just to have a little fun here, if we go into the <code>trim</code> modifier and change the <code>from</code> parameter to <code>0.5</code> instead of <code>0</code>, we now start the drawing halfway through the circle. Run the code, and it looks like we’re animating or painting a smile and then removing the smile when we press the button again.</p>
<p class="callout-heading">Note</p>
<p class="callout">If this code seems a bit confusing, where you see the <code>trim</code> modifier being set for the circle, and the <code>circleTrim</code> variable being set in the button body, then think of the <code>trim</code> modifier as the “where” part of the trimming. This means where do we want to start and end the trimming? Then, think of the ternary operator inside the button as the “how much,” meaning how much do we want to trim off the circle and how much of it do we want to keep?</p>
<p>Let’s now move on to the final example. In this example, we will take a look at how you can animate the corner radius of a rectangle. The corner radius refers to how sharp you want to make the corners of a rectangle; you can go all the way from a 90° angle up to a much higher value to create a smooth, rounded corner. </p>
<p>All the code is <a id="_idIndexMarker210"/>similar to <a id="_idIndexMarker211"/>what we’ve used so far except for the use of the <code>cornerRadius</code> modifier. The following is an example of the code:</p>
<pre class="source-code">
struct Corner_Radius_Example: View {
    @State private var animateCornerRadius = false
    
    var body: some View {
        //MARK: - ANIMATE THE CORNER RADIUS
        VStack{
            Text("ANIMATE CORNER RADIUS").font(.title).bold()
                .padding(.top, 30)
            Rectangle()
                .foregroundColor(.green)
                .frame(width: 150, height: 150)
            .cornerRadius(animateCornerRadius ? 0 : 75)
            .animation(.default, value: animateCornerRadius)
            .padding(.bottom, 20)
            Button("Animate Corner Radius") {
                animateCornerRadius.toggle()
            }
        }.font(.title2)
    }
}</pre>
<p>This code<a id="_idIndexMarker212"/> produces<a id="_idIndexMarker213"/> the following results: a rectangle with its corner radius changed from a 90° angle all the way up to create a circle. So, we’re changing a rectangle into a circle and back again when the button is pressed, as shown in <em class="italic">Figure 2</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 2.11: Animating the corner radius " src="img/B18674_02_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11: Animating the corner radius</p>
<p>In the <a id="_idIndexMarker214"/>code, the<a id="_idIndexMarker215"/> line that’s doing most of the work is this one:</p>
<pre class="source-code">
.cornerRadius(animateCornerRadius ? 0 : 75) </pre>
<p>The <code>animateCornerRadius</code> variable gets passed into the <code>cornerRadius</code> modifier, which then gets checked for the <code>true</code> or <code>false</code> values; if it is <code>false</code>, it gets a value of <code>75</code> placed into it, which will make the size of this rectangle animate into a perfectly round circle. And when toggled back to <code>true</code>, the circle animates into a rectangle with 90-degree corners by having its corner radius changed to <code>0</code>.</p>
<p>Note that the reason why the code creates a perfect circle is that we set the frame of the rectangle’s width and height to <code>150</code> points, thus creating a square, and anytime you set a corner radius to half the width or height of a square, you will always get a perfect circle.</p>
<p>SwiftUI gives us <a id="_idIndexMarker216"/>more <a id="_idIndexMarker217"/>ways to animate objects in addition to these, and we will explore them in the coming chapters when we start building projects. </p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor047"/>Summary</h1>
<p>In this chapter, we looked at how animations work, the two types of animation in SwiftUI, implicit and explicit, and many of the properties that can be animated. These include hue rotation, opacity, a view’s position on the screen and size, stroke, trim, corner radius, and timing curves.</p>
<p>This was an important step needed to guide you along on your SwiftUI animations adventure. Remember, if a property is a numerical value, it almost always can have an animation applied to it.</p>
<p>In the next chapter, we will start working on some projects. For our first project, we will create an app similar to Apple’s breathing app (very popular on Apple watches) and learn how to combine more than one animation in a view.</p>
</div>
<div><div></div>
</div>
</body></html>