<html><head></head><body>
<div id="_idContainer045">
<h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.2.1">Understanding Animation with SwiftUI</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the first chapter, we covered many SwiftUI fundamentals we will see when we start building projects. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will look at how animations work, including timing curves and animatable properties, which will lay the foundation for the projects we build. </span></p>
<p><span class="koboSpan" id="kobo.4.1">The following are the key topics we </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">will explore:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">What is animation? </span></li>
<li><span class="koboSpan" id="kobo.7.1">Understanding timing curves </span></li>
<li><span class="koboSpan" id="kobo.8.1">Understanding animation types </span></li>
<li><span class="koboSpan" id="kobo.9.1">Triggering animations </span></li>
<li><span class="koboSpan" id="kobo.10.1">Exploring </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">animatable properties</span></span></li>
</ul>
<h1 id="_idParaDest-33"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">You can find the code for this chapter on GitHub in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">Chapter 2</span></strong></span> <span class="No-Break"><span class="koboSpan" id="kobo.15.1">folder: </span></span><a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications"><span class="No-Break"><span class="koboSpan" id="kobo.16.1">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.17.1">.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.18.1">What is animation?</span></h1>
<p><span class="koboSpan" id="kobo.19.1">Let’s </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.20.1">consider the book’s definition of animation. </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">Animation</span></strong><span class="koboSpan" id="kobo.22.1"> is a series of static images displayed in rapid succession to create the illusion of motion. </span><span class="koboSpan" id="kobo.22.2">The images, or frames, are usually displayed at a rate of 24 or 30 frames per second from the beginning to the end, which is fast enough to create the illusion of continuous motion. </span><span class="koboSpan" id="kobo.22.3">These can be created using a variety of techniques, including hand-drawn, computer-generated, and </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">stop-motion animations.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">Looking at this definition, we can see that there is a start point and an end point to animation, and the images in between are all slightly different; when played, our eyes cannot pick out the individual images, which means we perceive movement </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">or animation.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">In SwiftUI, we have </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.27.1">to define the start point (where the animation begins) and the end point (where the animation ends). </span><span class="koboSpan" id="kobo.27.2">However, when we code, we don’t actually put a bunch of still images between both end points (though we can); what we usually do is use a single image and then animate the properties of that image, such as its location on the screen, its opacity, or its color. </span></p>
<p><span class="koboSpan" id="kobo.28.1">In addition to images, we can also animate RGB colors by changing their hue or the corner radius of shapes, and if we draw a shape, we can animate the individual lines (paths) or the strokes </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">around it.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">It works like this: if we want a rectangle to move from the bottom left to the top right of the iPhone or iPad screen, we declare it in code (that declarative syntax thing again) by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">animation</span></strong><span class="koboSpan" id="kobo.32.1"> modifier. </span><span class="koboSpan" id="kobo.32.2">Then SwiftUI does the magic for us, moving the object, or in SwiftUI speak, “transitioning” the object from a start point to an end point, filling in all the gaps along the way with whatever values we are working with (integers, colors, opacity, etc.). </span><span class="koboSpan" id="kobo.32.3">The process of going through all the values to create a smooth fluid motion is </span><a id="_idIndexMarker120"/><span class="No-Break"><span class="koboSpan" id="kobo.33.1">called </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.34.1">interpolation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">SwiftUI fills in those gaps for us really well, but it cannot animate every property of every view. </span><span class="koboSpan" id="kobo.36.2">Only properties considered “animatable” can be animated; things such as a view’s color, opacity, rotation, size, position, corner radius, and strokes. </span><span class="koboSpan" id="kobo.36.3">Nearly all properties that have a numerical value </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">are animatable.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">SwiftUI includes basic animations with default or custom easing or timing curves (a timing curve refers to the speed at the start and end of the animation), as well as spring animations. </span><span class="koboSpan" id="kobo.38.2">Spring animations have a bouncy effect to them and can be adjusted from a slight bounce to a very pronounced bounce, similar to a rubber ball bouncing on </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">the floor.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">You can also change many customization options, such as the speed of an animation, add a “wait” time before the animation starts, and have an animation </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">repeat itself.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">Let’s continue by diving deeper into animation timing curves, seeing what they look like and how they affect </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">an animation.</span></span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.44.1">Understanding timing curves</span></h1>
<p><span class="koboSpan" id="kobo.45.1">Animations</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.46.1"> have what are called curves. </span><span class="koboSpan" id="kobo.46.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">curve</span></strong><span class="koboSpan" id="kobo.48.1">, or </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.49.1">more specifically, a </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">timing curve</span></strong><span class="koboSpan" id="kobo.51.1">, refers to the speed at which the animation starts and how it </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">should end.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">SwiftUI provides several timing curves to choose from that we can use inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">animation</span></strong><span class="koboSpan" id="kobo.55.1"> modifier. </span><span class="koboSpan" id="kobo.55.2">It’s called a timing curve because if you were to plot each point of the animation’s movement from start to finish on a graph, and draw a line by connecting those points, most of them would create a curved line, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">this illustration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.57.1"><img alt="Figure 2.1: The ease timing curves " src="image/B18674_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1">Figure 2.1: The ease timing curves</span></p>
<p><span class="koboSpan" id="kobo.59.1">This graph shows three </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.60.1">animation timing curves: </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">easeIn</span></strong><span class="koboSpan" id="kobo.62.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">easeOut</span></strong><span class="koboSpan" id="kobo.64.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">easeInOut</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">The</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.67.1"> beginning </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.68.1">of the animation is at the bottom left, and the end is at </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.69.1">the top right. </span><span class="koboSpan" id="kobo.69.2">In </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.70.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">easeInOut</span></strong><strong class="source-inline"><a id="_idIndexMarker128"/></strong><span class="koboSpan" id="kobo.72.1"> timing curve, the animation starts slow, speeds up, and then finally slows down before coming to a </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">complete stop.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">There is </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.75.1">also a</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.76.1"> linear timing curve. </span><span class="koboSpan" id="kobo.76.2">An animation using this curve will have the same rate of speed at its beginning as it does at its end. </span><span class="koboSpan" id="kobo.76.3">If you were to plot it on a graph, it would be a straight line, </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">like so:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.78.1"><img alt="Figure 2.2: The linear timing curve " src="image/B18674_02_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.79.1">Figure 2.2: The linear timing curve</span></p>
<p><span class="koboSpan" id="kobo.80.1">Timing curves are </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.81.1">not complicated – we get to choose the ones </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.82.1">we want based on how we want the animation to look and perform. </span><span class="koboSpan" id="kobo.82.2">If you don’t specify a timing curve, you will get the default curve, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">easeInOut</span></strong><span class="koboSpan" id="kobo.84.1"> one. </span><span class="koboSpan" id="kobo.84.2">We will use some of these SwiftUI-provided timing curves in </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">our projects.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">In the next section, I want to explain the two distinct types of animation in SWiftUI: implicit </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">and explicit.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.88.1">Understanding animation types</span></h1>
<p><span class="koboSpan" id="kobo.89.1">There are two types of animations in SwiftUI: implicit and explicit. </span><span class="koboSpan" id="kobo.89.2">Let’s look at what these animation types do and the difference between </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the two.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">implicit animation</span></strong><span class="koboSpan" id="kobo.93.1"> is an </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.94.1">animation that is automatically </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.95.1">applied to a property when its value is changed. </span><span class="koboSpan" id="kobo.95.2">In SwiftUI, implicit animations are created using the .</span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">animation</span></strong><span class="koboSpan" id="kobo.97.1"> modifier. </span><span class="koboSpan" id="kobo.97.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
struct ContentView: View {
    @State private var grow: CGFloat = 1
    var body: some View {
        Circle()
            .frame(width: 100, height: 100)
            .foregroundColor(.blue)
            .onTapGesture {
                self.grow += 0.5
            }
            .scaleEffect(grow)
            .animation(.default, value: grow)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.100.1">In this example, we </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.101.1">use a tap gesture to scale up the size of a circle; when tapped, the circle will grow by half its size. </span><span class="koboSpan" id="kobo.101.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">.animation</span></strong><span class="koboSpan" id="kobo.103.1"> modifier uses the default animation style, which will animate the circle using an</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.104.1"> easeInOut timing curve </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">You can also use other animation styles. </span><span class="koboSpan" id="kobo.106.2">For example, here, I added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">spring</span></strong><span class="koboSpan" id="kobo.108.1"> style instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">default style:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
var body: some View {
        Circle()
••••••••
            .scaleEffect(grow)
            .animation(.spring(dampingFraction: 0.3,blendDuration: 0.5),value: grow)
    }</span></pre>
<p><span class="koboSpan" id="kobo.111.1">This style will animate the circle and add a springy effect </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">So implicit animations are a convenient way to add basic animations to your SwiftUI app without having to write any explicit animation code. </span><span class="koboSpan" id="kobo.113.2">The animations are applied using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">animation</span></strong><span class="koboSpan" id="kobo.115.1"> modifier. </span></p>
<p><span class="koboSpan" id="kobo.116.1">Sometimes though, you </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.117.1">may want more from your animation, and implicit animations may not give you the degree of control that you are looking for. </span><span class="koboSpan" id="kobo.117.2">In this case, you can use explicit </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">animations instead.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">explicit animation</span></strong><span class="koboSpan" id="kobo.121.1"> is an</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.122.1"> animation you create and </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.123.1">add inside the code block using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">withAnimation</span></strong><span class="koboSpan" id="kobo.125.1"> function. </span><span class="koboSpan" id="kobo.125.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.127.1">
struct ContentView: View {
    @State private var scaleUp: CGFloat = 1
    var body: some View {
        Button(action: {
            //Animate the scale of the view when the button is               tapped
            withAnimation(.interpolatingSpring(stiffness: 60,               damping: 2)) {
                scaleUp *= 1.4
            }
        }) {
            Text("Scale up")
                .scaleEffect(scaleUp)  // explicit animation
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.128.1">In this example, tapping the button will animate the scale of the text using a spring animation. </span><span class="koboSpan" id="kobo.128.2">The duration of the animation will be determined by the system’s default animation settings, but the curve of the animation will be customized using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">interpolatingSpring</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Additionally, you can </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.132.1">customize the duration of the animation by specifying a </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">duration</span></strong><span class="koboSpan" id="kobo.134.1"> parameter in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">interpolatingSpring</span></strong><span class="koboSpan" id="kobo.136.1"> function. </span><span class="koboSpan" id="kobo.136.2">The following is an example </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">of this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
withAnimation(.interpolatingSpring(stiffness: 60, damping: 2, duration: 2.5)) { scaleUp *= 1.5 }</span></pre>
<p><span class="koboSpan" id="kobo.139.1">This will cause the animation to last for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">2.5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1"> seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">So, the </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.143.1">difference when using explicit animations versus implicit animations is that they can give you more control over the details of the animation, or when you want to animate multiple properties simultaneously; you can put as much code into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">withAnimation</span></strong><span class="koboSpan" id="kobo.145.1"> block as needed. </span><span class="koboSpan" id="kobo.145.2">However, they can be more work to set up than </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">implicit animations.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">You can also have the animation repeat itself a pre-set number of times or indefinitely. </span><span class="koboSpan" id="kobo.147.2">Here’s an example of repeating the previous animation forever and </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">auto-reversing it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
withAnimation(.interpolatingSpring(stiffness: 60, damping: 2).repeatForever(autoreverses: true)) {
                    scaleUp *= 1.4
                }</span></pre>
<p><span class="koboSpan" id="kobo.150.1">In the previous example, I altered the code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">withAnimation</span></strong><span class="koboSpan" id="kobo.152.1"> function to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">repeatForever</span></strong><span class="koboSpan" id="kobo.154.1"> option and set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">autoreverses</span></strong><span class="koboSpan" id="kobo.156.1"> parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">true</span></strong><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">When you run the code, the text will scale up with a springy effect, and when it’s done bouncing (about 3 seconds or so), the animation will start over, repeating endlessly or until the app </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">is stopped.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Those are the two types of animations; next is a list of ways to </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">trigger animations.</span></span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.162.1">Triggering animations</span></h1>
<p><span class="koboSpan" id="kobo.163.1">So, how</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.164.1"> do we trigger animations? </span><span class="koboSpan" id="kobo.164.2">There are several ways to do so in SwiftUI, including using the following SwiftUI modifiers, methods, </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">and functions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.166.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">.animation()</span></strong><span class="koboSpan" id="kobo.168.1"> modifier: This </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.169.1">modifier allows you to specify the type of animation used when a view appears or disappears or when its </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">state changes.</span></span></li>
<li><span class="koboSpan" id="kobo.171.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">withAnimation()</span></strong><span class="koboSpan" id="kobo.173.1"> function: This </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.174.1">function allows you to wrap a block of code that changes the state of a view, and it will automatically animate </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">the changes.</span></span></li>
<li><span class="koboSpan" id="kobo.176.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">gesture</span></strong><span class="koboSpan" id="kobo.178.1">: This </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.179.1">is a way to interact with a view by performing actions such as tapping, dragging, or pinching. </span><span class="koboSpan" id="kobo.179.2">You can use a gesture to trigger an animation when a certain action is performed on </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">a view.</span></span></li>
<li><span class="koboSpan" id="kobo.181.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">timer</span></strong><span class="koboSpan" id="kobo.183.1">: This </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.184.1">allows you to specify an animation to be performed over a certain period of time. </span><span class="koboSpan" id="kobo.184.2">You can use a timer to animate the changes to a view’s state over a </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">specific duration.</span></span></li>
<li><span class="koboSpan" id="kobo.186.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">onAppear()</span></strong><span class="koboSpan" id="kobo.188.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">onDisappear()</span></strong><span class="koboSpan" id="kobo.190.1"> modifiers: These modifiers allow you to specify </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.191.1">code to be </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.192.1">executed when a view appears or disappears. </span><span class="koboSpan" id="kobo.192.2">These modifiers can trigger an animation when a view appears </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">or disappears.</span></span></li>
<li><span class="koboSpan" id="kobo.194.1">Button and other control views: A button, slider, picker, or other control type view in SwiftUI </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.195.1">can be</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.196.1"> a trigger for </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">an animation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.198.1">There are other</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.199.1"> ways to trigger animations, but these are the main ones that we will cover here. </span><span class="koboSpan" id="kobo.199.2">Whatever you choose will depend on the specific needs of your app and the behavior you want to produce. </span><span class="koboSpan" id="kobo.199.3">We will explore these different triggers when we start building our projects in the </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">coming chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Let’s continue by looking at various properties that can be animated </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">in SwiftUI.</span></span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.203.1">Exploring animatable properties</span></h1>
<p><span class="koboSpan" id="kobo.204.1">In this section, we</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.205.1"> will explore some of the animatable properties. </span><span class="koboSpan" id="kobo.205.2">Here is a list of the ones that we will </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">look at:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.207.1">Offset</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.208.1">Hue rotation</span></span></li>
<li><span class="koboSpan" id="kobo.209.1">Opacity </span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.210.1">Scale</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.211.1">Stroke</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.212.1">Trim</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.213.1">Corner radius</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.214.1">Let’s take a look at them in </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">more detail.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.216.1">The offset property</span></h2>
<p><span class="koboSpan" id="kobo.217.1">The</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.218.1"> first property we will look at that is animatable is the </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">offset</span></strong><span class="koboSpan" id="kobo.220.1"> property. </span><span class="koboSpan" id="kobo.220.2">This </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.221.1">property is responsible for offsetting a view on the </span><em class="italic"><span class="koboSpan" id="kobo.222.1">x</span></em><span class="koboSpan" id="kobo.223.1">- and </span><em class="italic"><span class="koboSpan" id="kobo.224.1">y</span></em><span class="koboSpan" id="kobo.225.1">-axes, basically giving you control to place that view anywhere on the screen. </span><span class="koboSpan" id="kobo.225.2">The following is an example of animating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">offset</span></strong><span class="koboSpan" id="kobo.227.1"> modifier that has been placed on a </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">rectangle shape:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
struct Offset_Example: View {
    @State private var moveRight = false
    var body: some View {
       //MARK: - ANIMATE OFFSET
        VStack {
            RoundedRectangle(cornerRadius: 20)
                .foregroundColor(.blue)
                .frame(width: 75, height: 75)
                .offset(x: moveRight ? </span><span class="koboSpan" id="kobo.229.2">150 : 0, y: 350 )
                .animation(Animation.default, value: moveRight)
            Spacer()
            Button("Animate") {
                moveRight.toggle()
            }.font(.title2)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.230.1">After you</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.231.1"> put that code into your </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">ContentView</span></strong><span class="koboSpan" id="kobo.233.1"> file, your preview will look like </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.234.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.235.1">.3</span></em><span class="koboSpan" id="kobo.236.1">. </span><span class="koboSpan" id="kobo.236.2">When you press the </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">Animate</span></strong><span class="koboSpan" id="kobo.238.1"> button, the blue rectangle will move to the right, and when you press it again, it will return to its original </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">starting position.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.240.1"><img alt="Figure 2.3: Animating the offset " src="image/B18674_02_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.241.1">Figure 2.3: Animating the offset</span></p>
<p><span class="koboSpan" id="kobo.242.1">This is how the code works. </span><span class="koboSpan" id="kobo.242.2">When the </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">Animate</span></strong><span class="koboSpan" id="kobo.244.1"> button is pressed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">moveRight</span></strong><span class="koboSpan" id="kobo.246.1"> variable has its value toggled or changed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">true</span></strong><span class="koboSpan" id="kobo.248.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">offset</span></strong><span class="koboSpan" id="kobo.250.1"> modifier has a ternary operator in there for its </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">x</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1"> parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">A</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.254.1"> ternary operator</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.255.1"> is an operator that accepts a Boolean </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.256.1">variable and checks to see whether it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">true</span></strong><span class="koboSpan" id="kobo.258.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">false</span></strong><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">If the variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">true</span></strong><span class="koboSpan" id="kobo.262.1">, the value to the left of the colon is used, but if the variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">false</span></strong><span class="koboSpan" id="kobo.264.1">, the value to the right of the colon is used. </span><span class="koboSpan" id="kobo.264.2">This makes it similar to an if statement but different because an </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">if</span></strong><span class="koboSpan" id="kobo.266.1"> statement can check for </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">multiple conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">So, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">moveRight</span></strong><span class="koboSpan" id="kobo.270.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">true</span></strong><span class="koboSpan" id="kobo.272.1">, then the rounded rectangle is placed </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">150</span></strong><span class="koboSpan" id="kobo.274.1"> points to the right; otherwise, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">false</span></strong><span class="koboSpan" id="kobo.276.1">, it is left where it is (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">0</span></strong><span class="koboSpan" id="kobo.278.1"> value means do nothing). </span><span class="koboSpan" id="kobo.278.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">animation</span></strong><span class="koboSpan" id="kobo.280.1"> modifier also picks up on any change because it has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">moveRight</span></strong><span class="koboSpan" id="kobo.282.1"> variable in there for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">value</span></strong><span class="koboSpan" id="kobo.284.1"> parameter. </span><span class="koboSpan" id="kobo.284.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">value</span></strong><span class="koboSpan" id="kobo.286.1"> parameter takes the variable that you are using for the animation. </span><span class="koboSpan" id="kobo.286.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">animation</span></strong><span class="koboSpan" id="kobo.288.1"> modifier will then interpolate over the values from the start to the finish point and move the object smoothly, creating a nice, </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">fluid animation.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Here’s a way to really see how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">animation</span></strong><span class="koboSpan" id="kobo.292.1"> modifier is working. </span><span class="koboSpan" id="kobo.292.2">If you comment out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">animation</span></strong><span class="koboSpan" id="kobo.294.1"> statement in the code and press the button, you will see that the object still moves </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">150</span></strong><span class="koboSpan" id="kobo.296.1"> points to the right, but it does so instantly; there is no gliding across the screen now; the object just appears at its new location </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">150</span></strong><span class="koboSpan" id="kobo.298.1"> points to the right. </span><span class="koboSpan" id="kobo.298.2">To create smooth, fluid animations, we need that </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">animation</span></strong><span class="koboSpan" id="kobo.300.1"> modifier and its behind-the-scenes interpolating magic. </span><span class="koboSpan" id="kobo.300.2">This is part of the reason why we use less code in SwiftUI versus coding animation in UIKit; much of the heavy lifting is already done for us in the background </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">with SwiftUI.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">This was an example of animating an object from one point to another by changing the numerical value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">x</span></strong><span class="koboSpan" id="kobo.304.1"> parameter in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">offset</span></strong><span class="koboSpan" id="kobo.306.1"> modifier. </span><span class="koboSpan" id="kobo.306.2">Let’s look at another property that’s </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">animatable: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">HueRotation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.310.1">Hue rotation</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.311.1">Hue rotation</span></strong><span class="koboSpan" id="kobo.312.1"> is a</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.313.1"> type </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.314.1">of color effect that can be applied to views and other components. </span><span class="koboSpan" id="kobo.314.2">It’s a modifier that allows you to adjust the hue of a color by adding or subtracting a fixed angle from its hue value. </span><span class="koboSpan" id="kobo.314.3">You can use hue rotation to create a range of </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">related colors.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">The modifier has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">angle</span></strong><span class="koboSpan" id="kobo.318.1"> parameter that takes a value in radians or degrees. </span><span class="koboSpan" id="kobo.318.2">That value is based on a circle, which</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.319.1"> is 360 degrees and represents a wheel of all the colors that we can think of. </span></p>
<p><span class="koboSpan" id="kobo.320.1">Let’s look at an </span><a id="_idIndexMarker162"/><span class="No-Break"><span class="koboSpan" id="kobo.321.1">Xcode example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
struct Hue_Rotation_Example: View {
    @State private var hueRotate = false
        var body: some View {
        //MARK: - ANIMATE HUE ROTATION
        VStack(spacing: 20) {
            Text("ANIMATE HUE ").font(.title2).bold()
            // rotate the colors and stop halfway around the               color wheel
            RoundedRectangle(cornerRadius: 25)
                .frame(width: 200, height: 200)
                .foregroundColor(.red)
                .hueRotation(Angle.degrees(hueRotate ? </span><span class="koboSpan" id="kobo.322.2">180 :                   0))
                .animation(.easeInOut(duration: 2), value:                   hueRotate)
            // rotate the colors around the color wheel one               full revolution (360 degrees)
            Divider().background(Color.black)
            Text("ANIMATE HUE WITH GRADIENT").font(.title2).              bold()
            AngularGradient(gradient: Gradient(colors: [Color.              red, Color.blue]), center: .center)
                .hueRotation(Angle.degrees(hueRotate ? </span><span class="koboSpan" id="kobo.322.3">360 :                   0))
                .animation(.easeInOut(duration: 2), value:                   hueRotate)
                .mask(Circle())
                .frame(width: 200, height: 200)
            Button("Animate") {
                hueRotate.toggle()
            }
            .font(.title)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.323.1">When </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.324.1">you</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.325.1"> add the code into Xcode, your previews will look like </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.326.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.327.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">:</span></span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.329.1"><img alt="Figure 2.4: Animating the hue rotation " src="image/B18674_02_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.330.1">Figure 2.4: Animating the hue rotation</span></p>
<p><span class="koboSpan" id="kobo.331.1">I created two </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.332.1">objects in this example: a rounded</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.333.1"> rectangle and an angular gradient circle. </span></p>
<p><span class="koboSpan" id="kobo.334.1">In the rounded rectangle, I used a ternary operator to check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">hueRotate</span></strong><span class="koboSpan" id="kobo.336.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">true</span></strong><span class="koboSpan" id="kobo.338.1">. </span><span class="koboSpan" id="kobo.338.2">When it becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">true</span></strong><span class="koboSpan" id="kobo.340.1"> via the </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">Animate</span></strong><span class="koboSpan" id="kobo.342.1"> button being pressed, the value to the left of the colon inside the ternary operator is used, 180 degrees. </span><span class="koboSpan" id="kobo.342.2">Then the animation starts going through the color spectrum and stops halfway through to display that color. </span></p>
<p><span class="koboSpan" id="kobo.343.1">Notice the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">duration</span></strong><span class="koboSpan" id="kobo.345.1"> function just after the timing curve. </span><span class="koboSpan" id="kobo.345.2">This function allows us to set the duration of the animation; do we want it to happen fast, or do we want the animation to happen over a longer period? </span><span class="koboSpan" id="kobo.345.3">It has one parameter, and that is the amount of time we want the animation to take to complete; for that, we use an integer value. </span><span class="koboSpan" id="kobo.345.4">I set the value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">2</span></strong><span class="koboSpan" id="kobo.347.1">, so it can slow things down a little, taking the animation 2 seconds </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">to complete.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">Looking at the angular</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.350.1"> gradient example, I’m using a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">360</span></strong><span class="koboSpan" id="kobo.352.1"> degrees. </span><span class="koboSpan" id="kobo.352.2">When we press the </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">Animate</span></strong><span class="koboSpan" id="kobo.354.1"> button, the code animates through the entire color wheel and stops where it started (360 degrees is one revolution of a circle), thus displaying the original color. </span></p>
<p><span class="koboSpan" id="kobo.355.1">Taking a look </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.356.1">at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">hueRotate</span></strong><span class="koboSpan" id="kobo.358.1"> variable inside the body of the button, we have two ways that we can start the animation. </span><span class="koboSpan" id="kobo.358.2">The first is by explicitly setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">hueRotate</span></strong><span class="koboSpan" id="kobo.360.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">true</span></strong><span class="koboSpan" id="kobo.362.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.364.1">
hueRotate = true</span></pre>
<p><span class="koboSpan" id="kobo.365.1">Or by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">toggle</span></strong><span class="koboSpan" id="kobo.367.1"> method like we’re doing in </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.369.1">
hueRotate.toggle()</span></pre>
<p><span class="koboSpan" id="kobo.370.1">The difference between these two ways of starting the animation is that firstly, the animation starts and then finishes, but it never reverses itself with subsequent button presses. </span><span class="koboSpan" id="kobo.370.2">If you’d like the animation to start and finish, and on the next button press reverse itself, then use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">toggle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">What’s also very interesting is that we can animate the colors of shapes and other objects, but also animate the colors that make up images, as we will see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">upcoming projects.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">hueRotation()</span></strong><span class="koboSpan" id="kobo.377.1"> modifier in combination with other modifiers, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">brightness()</span></strong><span class="koboSpan" id="kobo.379.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">saturation()</span></strong><span class="koboSpan" id="kobo.381.1">, to create some complex and interesting </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">color adjustments.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Let’s continue looking at the different properties to animate and at a very common property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">opacity</span></strong><span class="koboSpan" id="kobo.385.1">. </span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.386.1">Opacity</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.387.1">Opacity</span></strong><span class="koboSpan" id="kobo.388.1"> refers</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.389.1"> to the transparency of a view, whether you</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.390.1"> can see it clearly, whether it is partially visible, or maybe you can’t see it at all. </span><span class="koboSpan" id="kobo.390.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">opacity</span></strong><span class="koboSpan" id="kobo.392.1"> modifier to make views appear and disappear. </span><span class="koboSpan" id="kobo.392.2">When we add animation to the opacity, the transition from shown to hidden is interpolated over, so it smoothly fades in </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">and out.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Here's an example of adding </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.395.1">opacity to </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">an </span></span><span class="No-Break"><a id="_idIndexMarker172"/></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">animation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
struct Opacity__Example: View {
    @State private var appear = true
    var body: some View {
//MARK: - ANIMATE OPACITY
        VStack{
            Text("Appear/Disappear")
                .font(.title).bold()
            Circle()
                .foregroundColor(.purple)
                .opacity(appear ? </span><span class="koboSpan" id="kobo.398.2">1 : 0)
                .animation(.easeIn, value: appear)
                .frame(height: 175)
            Button("Animate") {
                appear.toggle()
            }.font(.title2)
            //MARK: - OVERLAPPING OPACITY
            VStack{
                Text("Overlapping Opacity").bold()
                    .font(.title)
                Circle()
                    .foregroundColor(.yellow)
                    .frame(height: 100)
                    .opacity(0.5)
                Circle()
                    .foregroundColor(.red)
                    .frame(height: 100)
                    .opacity(0.5)
                    .padding(-60)
            }.padding(60)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.399.1">The </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.400.1">preceding </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.401.1">code will produce the following results, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.402.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.403.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.405.1"><img alt="Figure 2.5: Animating the opacity " src="image/B18674_02_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.406.1">Figure 2.5: Animating the opacity</span></p>
<p><span class="koboSpan" id="kobo.407.1">In our first </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.408.1">example, the animation variable is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">appear</span></strong><span class="koboSpan" id="kobo.410.1">, and it’s set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">true</span></strong><span class="koboSpan" id="kobo.412.1"> as its default value, which shows the circle. </span><span class="koboSpan" id="kobo.412.2">When the </span><strong class="bold"><span class="koboSpan" id="kobo.413.1">Animate</span></strong><span class="koboSpan" id="kobo.414.1"> button is</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.415.1"> pressed, the variable gets toggled to </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">false</span></strong><span class="koboSpan" id="kobo.417.1">, and the circle animates itself until it completely disappears. </span><span class="koboSpan" id="kobo.417.2">And when the button is pressed again, the animation gets set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">true</span></strong><span class="koboSpan" id="kobo.419.1">, and the circle becomes visible again. </span><span class="koboSpan" id="kobo.419.2">Again, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">animation</span></strong><span class="koboSpan" id="kobo.421.1"> modifier initiates the interpolation over the start and end values, so the circle doesn’t just appear or disappear instantly; there is a gradual change of state until the end of the animation </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">is reached.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">The second example of the two circles overlapping at the bottom of the screen demonstrates a unique component of opacity in SwiftUI. </span><span class="koboSpan" id="kobo.423.2">When we apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">opacity</span></strong><span class="koboSpan" id="kobo.425.1"> modifier to a view that already had its opacity transformed, the modifier will multiply the overall effect. </span><span class="koboSpan" id="kobo.425.2">For example, the yellow and red circles have their opacity set at 50%, overlapping each other. </span><span class="koboSpan" id="kobo.425.3">The</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.426.1"> top red circle allows some of the bottom yellow circle to show through, thus</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.427.1"> multiplying the opacity effect so that area is a little darker, and at the same time, mingling the two colors, </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">creating orange.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">Next, let’s take a look at animating the size or scale of a view, which we can do with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">scaleEffect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.431.1"> modifier.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.432.1">Scale</span></h2>
<p><span class="koboSpan" id="kobo.433.1">Every view has a</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.434.1"> specific size, and we can change that size by </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.435.1">scaling it up or </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.436.1">down with animation. </span><span class="koboSpan" id="kobo.436.2">We can do this with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">scaleEffect</span></strong><span class="koboSpan" id="kobo.438.1"> modifier. </span><span class="koboSpan" id="kobo.438.2">Here’s an example of how we can animate the scale of </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">a view:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
struct Scale_Example_One: View {
    @State private var scaleCircle = false
    var body: some View {
            //MARK: - ANIMATE THE SCALE OF A CIRCLE SHAPE
            VStack {
                Text("SCALE SHAPE").font(.title).bold()
                Circle()
                    .frame(width: 150)
                    .foregroundColor(.green)
                    .scaleEffect(scaleCircle ? </span><span class="koboSpan" id="kobo.440.2">0.1 : 1)
                    .animation(.default, value: scaleCircle)
                Button("Scale Shape") {
                    scaleCircle.toggle()
                }
            }.font(.title2)
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.441.1"> The preceding code will produce the following results, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.442.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.443.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.445.1"><img alt="Figure 2.6: Scaling a shape " src="image/B18674_02_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.446.1">Figure 2.6: Scaling a shape</span></p>
<p><span class="koboSpan" id="kobo.447.1">You should </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.448.1">be starting</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.449.1"> to recognize much of the code that we’re using; for example, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">VStack</span></strong><span class="koboSpan" id="kobo.451.1"> to hold our views, so they get stacked vertically, and we can use the button control as a way to start </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">the animation.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">In the example, I’m creating a simple green circle and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">scaleEffect</span></strong><span class="koboSpan" id="kobo.455.1"> modifier, passing in our animating variable. </span><span class="koboSpan" id="kobo.455.2">When the state changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">true</span></strong><span class="koboSpan" id="kobo.457.1">, the circle scales down to one-tenth of its size, and when </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">false</span></strong><span class="koboSpan" id="kobo.459.1">, it goes back to its original size. </span></p>
<p><span class="koboSpan" id="kobo.460.1">We’re using </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.461.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">animation</span></strong><span class="koboSpan" id="kobo.463.1"> modifier again with the default timing curve. </span><span class="koboSpan" id="kobo.463.2">The default curve is an easeInOut curve, which we discussed earlier in the chapter. </span><span class="koboSpan" id="kobo.463.3">An easeInOut curve will cause the animation to start slowly, then ramp up to its top speed, and then finish by easing out </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">slowly again.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Let’s look </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.466.1">at another example of scaling up and down, but instead of scaling a shape that we created using the circle initializer, we’re using a system image to show you that you can also </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">scale images:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
struct Scale_Example_Two: View {
    @State private var scaleBug = false
    var body: some View {
        //MARK: - ANIMATE THE SCALE OF A SYSTEM IMAGE
        VStack{
            Text("SCALE IMAGE").font(.title).bold()
            Image(systemName: "ladybug.fill")
                .renderingMode(.original) //allows multicolor                   for SF Symbols
                .resizable()
                .frame(width: 150, height: 150, alignment:                   .center)
                .scaleEffect(scaleBug ? </span><span class="koboSpan" id="kobo.468.2">0.1 : 1)
                .animation(.default, value: scaleBug)
                .padding(10)
            Button("Scale Image") {
                scaleBug.toggle()
            }
        }.font(.title2)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.469.1">The preceding </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.470.1">code will produce the following results, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.471.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.472.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.474.1"><img alt="Figure 2.7: Scaling an image " src="image/B18674_02_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.475.1">Figure 2.7: Scaling an image</span></p>
<p><span class="koboSpan" id="kobo.476.1">This particular </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.477.1">image is a system image from the </span><em class="italic"><span class="koboSpan" id="kobo.478.1">SF Symbols</span></em><span class="koboSpan" id="kobo.479.1"> app. </span><span class="koboSpan" id="kobo.479.2">If you don’t have this app yet, I highly recommend it. </span><span class="koboSpan" id="kobo.479.3">You can download it for free at the Apple Developer portal. </span><span class="koboSpan" id="kobo.479.4">In it, Apple has given us thousands of images we can use in our code. </span><span class="koboSpan" id="kobo.479.5">And what’s new in the latest release is that now, many of the images can be rendered in multicolor: we have to set the rendering mode to </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">.original</span></strong><span class="koboSpan" id="kobo.481.1"> so the image gets shown with colors, instead of just black or white. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.482.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.483.1">Not all images can be colored. </span><span class="koboSpan" id="kobo.483.2">Look in the SF Symbols app to see which ones can </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">be colored.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">Finally, in</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.486.1"> this third </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.487.1">example of a scaling animation, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">anchor</span></strong><span class="koboSpan" id="kobo.489.1"> method, which scales the view by the given amount in both the horizontal and vertical directions relative to an </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">anchor point:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
struct Scale_Example_Three: View {
    @State private var scaleFromAnchor = true
    var body: some View {
                VStack{
            Text("SCALE FROM ANCHOR ").font(.title).bold()
            Image(systemName: "heart.fill")
                .renderingMode(.original) //allows the use of                   multicolor for SF Symbols
                .resizable()
                .frame(width: 150, height: 125, alignment:                   .center)
                .scaleEffect(scaleFromAnchor ? </span><span class="koboSpan" id="kobo.491.2">1 : 0.2, anchor:                   .bottomTrailing)
                .animation(.default, value: scaleFromAnchor)
                .padding(10)
            Button("Scale from Anchor") {
                scaleFromAnchor.toggle()
            }
        }.font(.title2)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.492.1">The </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.493.1">preceding</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.494.1"> code will produce the following results, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.495.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.496.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.498.1"><img alt="Figure 2.8: Scaling from an anchor point " src="image/B18674_02_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.499.1">Figure 2.8: Scaling from an anchor point</span></p>
<p><span class="koboSpan" id="kobo.500.1">All views have an anchor point, which is usually in the middle of the view. </span><span class="koboSpan" id="kobo.500.2">But we can change that anchor point, and have the animation scale the object based on where that anchor point is. </span><span class="koboSpan" id="kobo.500.3">In the code, I used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">.bottomTrailing</span></strong><span class="koboSpan" id="kobo.502.1"> option as the anchor point, so when </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.503.1">we press the button, the heart image scales down and toward the trailing edge (the right side of the screen), rather than scaling from the center of the object. </span><span class="koboSpan" id="kobo.503.2">However, SwiftUI also </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.504.1">gives us the following anchor points to </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">choose from:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">bottomTrailing</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">trailing </span></strong></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">bottom</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">center</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">top</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">bottomLeading</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">topLeading</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">topTrailing</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">leading</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.515.1">In this final section, we will look at three more properties that can be animated: </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">stroke</span></strong><span class="koboSpan" id="kobo.517.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">trim</span></strong><span class="koboSpan" id="kobo.519.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">cornerRadius</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.523.1">Stroke, trim, and corner radius</span></h2>
<p><span class="koboSpan" id="kobo.524.1">Let’s now look at three more properties we can animate: the stroke of a line, the trim of a circle, and the corner radius of </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">a rectangle.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">stroke</span></strong><span class="koboSpan" id="kobo.528.1"> of a </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.529.1">shape is the outline or border of the</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.530.1"> shape. </span><span class="koboSpan" id="kobo.530.2">It has a particular color and width and can have various attributes such as line cap style or line join style. </span><span class="koboSpan" id="kobo.530.3">Let’s animate the stroke of a rectangle, so it gets thicker or thinner with each </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">button press:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
struct Stroke_Example: View {
    @State private var animateStroke = false
    var body: some View {
        //MARK: - ANIMATE THE STROKE OF THE ROUNDED RECT
        VStack{
            Text("ANIMATE STROKE").font(.title).bold()
            RoundedRectangle(cornerRadius: 30)
                .stroke(Color.purple, style:                   StrokeStyle(inewidth: animateStroke ? </span><span class="koboSpan" id="kobo.532.2">25 :                   1))
                .frame(width: 100, height: 100)
                .animation(.default, value: animateStroke)
            Button("Animate Stroke") {
                animateStroke.toggle()
            }
        }.font(.title2)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.533.1">Either a thick or</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.534.1"> thin </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.535.1">stroke line is created around the rectangle, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.536.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.537.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.539.1"><img alt="Figure 2.9: Animating the stroke " src="image/B18674_02_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.540.1">Figure 2.9: Animating the stroke</span></p>
<p><span class="koboSpan" id="kobo.541.1">The </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.542.1">first thing </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.543.1">we do is define our animation variable, setting its initial value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">false</span></strong><span class="koboSpan" id="kobo.545.1">. </span><span class="koboSpan" id="kobo.545.2">Looking inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">stroke</span></strong><span class="koboSpan" id="kobo.547.1"> modifier, I pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">animateStroke</span></strong><span class="koboSpan" id="kobo.549.1"> variable as an argument to the line </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">width</span></strong><span class="koboSpan" id="kobo.551.1"> parameter, so when it does become </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">true</span></strong><span class="koboSpan" id="kobo.553.1">, it changes </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">stroke</span></strong><span class="koboSpan" id="kobo.555.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">25</span></strong><span class="koboSpan" id="kobo.557.1"> points (otherwise, it will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">1</span></strong><span class="koboSpan" id="kobo.559.1"> point). </span><span class="koboSpan" id="kobo.559.2">Again, we also use the default timing curve inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">animation</span></strong><span class="koboSpan" id="kobo.561.1"> modifier, and when we run this, </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">stroke</span></strong><span class="koboSpan" id="kobo.563.1"> is smoothly modified from a thickness of </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">25</span></strong><span class="koboSpan" id="kobo.565.1"> points, then back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">1</span></strong><span class="koboSpan" id="kobo.567.1"> point when the button is </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">pressed again.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">Here is</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.570.1"> another example where</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.571.1"> we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">trim</span></strong><span class="koboSpan" id="kobo.573.1"> modifier </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">this time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
struct Trim_Example: View {
    @State private var animateTrim = false
    @State private var circleTrim: CGFloat = 1.0
    
    var body: some View {
        //MARK: - ANIMATE THE TRIM MODIFIER OF A CIRCLE
        VStack {
            Text("ANIMATE TRIM").font(.title).bold()
                .padding(.top, 10)
            Circle()
                .trim(from: 0, to: circleTrim)
                .stroke(Color.red, style: StrokeStyle(inewidth:                   30, lineCap: CGLineCap.round))
                .frame(height: 150)
                .rotationEffect(.degrees(180))
                .animation(.default, value: animateTrim)
                .padding(.bottom, 20)
            Button("Animate Trim") {
                animateTrim.toggle()
                circleTrim = animateTrim ? </span><span class="koboSpan" id="kobo.575.2">0.25 : 1
            }
        }.font(.title2)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.576.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">trim</span></strong><span class="koboSpan" id="kobo.578.1"> modifier</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.579.1"> takes</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.580.1"> two parameters: </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">from</span></strong><span class="koboSpan" id="kobo.582.1"> (meaning what part of the circle we want to start trimming from) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">to</span></strong><span class="koboSpan" id="kobo.584.1"> (meaning where we want to end the trimming). </span><span class="koboSpan" id="kobo.584.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">from</span></strong><span class="koboSpan" id="kobo.586.1"> parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">0</span></strong><span class="koboSpan" id="kobo.588.1">, which means there will be a complete circle on the screen as we are not trimming yet. </span><span class="koboSpan" id="kobo.588.2">The code produces the following results, a circle that has its line trimmed off and restored when the button is pressed, as</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.589.1"> shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.590.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.591.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.593.1"><img alt="Figure 2.10: Animating the trim " src="image/B18674_02_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.594.1">Figure 2.10: Animating the trim</span></p>
<p><span class="koboSpan" id="kobo.595.1">Also, notice </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.596.1">we use two </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">@State</span></strong><span class="koboSpan" id="kobo.598.1"> variables to work with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">trim</span></strong><span class="koboSpan" id="kobo.600.1"> modifier, one called </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">animateTrim</span></strong><span class="koboSpan" id="kobo.602.1">, to trigger the animation, and one called </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">circleTrim</span></strong><span class="koboSpan" id="kobo.604.1">, which is a numerical value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">CGFloat</span></strong><span class="koboSpan" id="kobo.606.1"> type. </span><span class="koboSpan" id="kobo.606.2">This variable will hold the amount of circle we want to trim off. </span><span class="koboSpan" id="kobo.606.3">Initially, it gets set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">1</span></strong><span class="koboSpan" id="kobo.608.1">, so the whole circle </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">is visible.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.610.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.611.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">CGFloat</span></strong><span class="koboSpan" id="kobo.613.1"> type is </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.614.1">a floating-point number. </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">CG</span></strong><span class="koboSpan" id="kobo.616.1"> stands</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.617.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.618.1">Core Graphics</span></strong><span class="koboSpan" id="kobo.619.1">, which is an older coding paradigm was used in Apple’s graphic framework, but is still used </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">in SwiftUI.</span></span></p>
<p><span class="koboSpan" id="kobo.621.1">Looking inside the</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.622.1"> button code, then </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.623.1">within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">circleTrim</span></strong><span class="koboSpan" id="kobo.625.1"> variable, we’re storing one of two values using the ternary operator: either </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">.25</span></strong><span class="koboSpan" id="kobo.627.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">1</span></strong><span class="koboSpan" id="kobo.629.1">. </span><span class="koboSpan" id="kobo.629.2">This means that when </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">animateTrim</span></strong><span class="koboSpan" id="kobo.631.1"> toggles to </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">true</span></strong><span class="koboSpan" id="kobo.633.1">, the code trims off 75% of the circle and leaves 25%; when </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">animateTrim</span></strong><span class="koboSpan" id="kobo.635.1"> toggles to </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">false</span></strong><span class="koboSpan" id="kobo.637.1">, the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">1</span></strong><span class="koboSpan" id="kobo.639.1"> is used, which represents 100% of the circle. </span><span class="koboSpan" id="kobo.639.2">So, the values in the ternary operator represent how much of the circle </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">to keep.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">If we run the code, we see we have a nice trimming animation of this circle. </span><span class="koboSpan" id="kobo.641.2">The line of code called </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">CGLineCap.round</span></strong><span class="koboSpan" id="kobo.643.1"> refers to the shape of the line that’s drawn at the end points, and it can be </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">round</span></strong><span class="koboSpan" id="kobo.645.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">square</span></strong><span class="koboSpan" id="kobo.647.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">butt </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">line cap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.651.1">And just to have a little fun here, if we go into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">trim</span></strong><span class="koboSpan" id="kobo.653.1"> modifier and change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">from</span></strong><span class="koboSpan" id="kobo.655.1"> parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">0.5</span></strong><span class="koboSpan" id="kobo.657.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">0</span></strong><span class="koboSpan" id="kobo.659.1">, we now start the drawing halfway through the circle. </span><span class="koboSpan" id="kobo.659.2">Run the code, and it looks like we’re animating or painting a smile and then removing the smile when we press the </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">button again.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.661.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.662.1">If this code seems a bit confusing, where you see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">trim</span></strong><span class="koboSpan" id="kobo.664.1"> modifier being set for the circle, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">circleTrim</span></strong><span class="koboSpan" id="kobo.666.1"> variable being set in the button body, then think of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">trim</span></strong><span class="koboSpan" id="kobo.668.1"> modifier as the “where” part of the trimming. </span><span class="koboSpan" id="kobo.668.2">This means where do we want to start and end the trimming? </span><span class="koboSpan" id="kobo.668.3">Then, think of the ternary operator inside the button as the “how much,” meaning how much do we want to trim off the circle and how much of it do we want </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">to keep?</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Let’s now move on to the final example. </span><span class="koboSpan" id="kobo.670.2">In this example, we will take a look at how you can animate the corner radius of a rectangle. </span><span class="koboSpan" id="kobo.670.3">The corner radius refers to how sharp you want to make the corners of a rectangle; you can go all the way from a 90° angle up to a much higher value to create a smooth, rounded corner. </span></p>
<p><span class="koboSpan" id="kobo.671.1">All the code is </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.672.1">similar to </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.673.1">what we’ve used so far except for the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">cornerRadius</span></strong><span class="koboSpan" id="kobo.675.1"> modifier. </span><span class="koboSpan" id="kobo.675.2">The following is an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.677.1">
struct Corner_Radius_Example: View {
    @State private var animateCornerRadius = false
    
    var body: some View {
        //MARK: - ANIMATE THE CORNER RADIUS
        VStack{
            Text("ANIMATE CORNER RADIUS").font(.title).bold()
                .padding(.top, 30)
            Rectangle()
                .foregroundColor(.green)
                .frame(width: 150, height: 150)
            .cornerRadius(animateCornerRadius ? </span><span class="koboSpan" id="kobo.677.2">0 : 75)
            .animation(.default, value: animateCornerRadius)
            .padding(.bottom, 20)
            Button("Animate Corner Radius") {
                animateCornerRadius.toggle()
            }
        }.font(.title2)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.678.1">This code</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.679.1"> produces</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.680.1"> the following results: a rectangle with its corner radius changed from a 90° angle all the way up to create a circle. </span><span class="koboSpan" id="kobo.680.2">So, we’re changing a rectangle into a circle and back again when the button is pressed, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.681.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.682.1">.11</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.684.1"><img alt="Figure 2.11: Animating the corner radius " src="image/B18674_02_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.685.1">Figure 2.11: Animating the corner radius</span></p>
<p><span class="koboSpan" id="kobo.686.1">In the </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.687.1">code, the</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.688.1"> line that’s doing most of the work is </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">this one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
.cornerRadius(animateCornerRadius ? </span><span class="koboSpan" id="kobo.690.2">0 : 75) </span></pre>
<p><span class="koboSpan" id="kobo.691.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">animateCornerRadius</span></strong><span class="koboSpan" id="kobo.693.1"> variable gets passed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">cornerRadius</span></strong><span class="koboSpan" id="kobo.695.1"> modifier, which then gets checked for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">true</span></strong><span class="koboSpan" id="kobo.697.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">false</span></strong><span class="koboSpan" id="kobo.699.1"> values; if it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">false</span></strong><span class="koboSpan" id="kobo.701.1">, it gets a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">75</span></strong><span class="koboSpan" id="kobo.703.1"> placed into it, which will make the size of this rectangle animate into a perfectly round circle. </span><span class="koboSpan" id="kobo.703.2">And when toggled back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">true</span></strong><span class="koboSpan" id="kobo.705.1">, the circle animates into a rectangle with 90-degree corners by having its corner radius changed </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">Note that the reason why the code creates a perfect circle is that we set the frame of the rectangle’s width and height to </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">150</span></strong><span class="koboSpan" id="kobo.711.1"> points, thus creating a square, and anytime you set a corner radius to half the width or height of a square, you will always get a </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">perfect circle.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">SwiftUI gives us </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.714.1">more </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.715.1">ways to animate objects in addition to these, and we will explore them in the coming chapters when we start building projects. </span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.716.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.717.1">In this chapter, we looked at how animations work, the two types of animation in SwiftUI, implicit and explicit, and many of the properties that can be animated. </span><span class="koboSpan" id="kobo.717.2">These include hue rotation, opacity, a view’s position on the screen and size, stroke, trim, corner radius, and </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">timing curves.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">This was an important step needed to guide you along on your SwiftUI animations adventure. </span><span class="koboSpan" id="kobo.719.2">Remember, if a property is a numerical value, it almost always can have an animation applied </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">In the next chapter, we will start working on some projects. </span><span class="koboSpan" id="kobo.721.2">For our first project, we will create an app similar to Apple’s breathing app (very popular on Apple watches) and learn how to combine more than one animation in </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">a view.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer046">
</div>
</div>
</body></html>