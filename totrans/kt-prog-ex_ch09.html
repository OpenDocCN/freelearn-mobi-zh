<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Creating the Place Reviewer Backend with Spring</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the Place Reviewer Backend with Spring</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">We focused on the utilization of Kotlin in the development of applications for the Android platform in the previous four chapters. The chapter we just concluded covered, extensively, the various activities involved in securing and deploying an Android application. We took a look at some best practices—in relation to security—when working with data storage as well as when communicating over a network. In addition, we discussed the necessary security considerations when handling user inputs and working with user credentials.</span></p>
<p class="p1"><span class="s1">Furthermore, we looked at various ways of securing some Android application components—such as services and broadcast receivers. Lastly, we took a step-by-step approach to properly deploying an Android application to the Google Play Store. In this chapter, we will have an in-depth look at how Kotlin can be used to develop web-based solutions – specifically with Spring—by developing the Place Reviewer application. This chapter will focus on the development of the backend of the Place Reviewer application, and the following chapter will focus on its frontend. In the course of reading through this chapter, you will learn about:</span></p>
<ul>
<li class="li1"><span class="s1">The Model-View-Controller design pattern</span></li>
<li class="li1"><span class="s1">Logstash and its use in centralizing, transforming, and stashing data.</span></li>
<li class="li1"><span class="s1">Securing a website with Spring Security</span></li>
</ul>
<p class="p1"><span class="s1">Let's dive right in to what we have to learn by first taking a look at the Model-View-Controller design pattern.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The MVC design pattern</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The MVC pattern, also known as the Model-View-Controller pattern, is an application design pattern that is used primarily for the separation of concerns within modern applications. More specifically, it is a design pattern for user interfaces that divides an application, primarily, into three distinct components. This separation of application modules into distinct parts is done for several reasons. One such reason is to isolate presentation logic from core business logic. Let us take a look at these three application components in the MVC pattern.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The model</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The model is the component that is in charge of the management of data and logic of an MVC application. As the model is the principal manager of all data and business logic, you can view it as the powerhouse of an MVC application.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The view</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">This is a visual representation of data that exists in and is generated by an application. It is the primary point of interaction that a user has with the application.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The controller</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The controller is an intermediary actor between the view and the model. It is in charge of retrieving input – primarily from the view – and feeding an appropriately transformed form of the<span class="Apple-converted-space">&#160;</span>input to the model. It is also in charge of updating the view with data whenever the need arises:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/f0cb4510-efd7-4531-8033-7b356807db73.jpg" style="width:32.17em;height:8.75em;"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing and implementing the Place Reviewer backend</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Since we have previously had hands-on experience with the process of designing a system, in this chapter, we are going to focus less on the processes involved in the designing of the Place Reviewer system. Instead, we are going to make a number of quick use case specifications for the system, identify the necessary entities that will be required for the implementation of our system's database, and delve right into the development of the system. Let us go ahead and state our use cases for the Place Reviewer system.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Use case identification</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As we did earlier on in this book, we shall commence our use case specification procedure by firstly identifying the actors of the system. Before we can identify the actors of the system, we must have a thorough understanding of what the Place Reviewer web application can do.</span></p>
<p class="p1"><span class="s1">As you may have figured out already, the Place Reviewer web application is an internet-based application that facilitates the frictionless creation of location reviews by users of the platform. Once a user has been registered, he/she is able to utilize the platform to create an opinionated review (a review based on personal experiences) of any location in the world. The user will be able to select the location that he/she wants to review with the help of a map.</span></p>
<p class="p1"><span class="s1">Now that we understand what the Place Reviewer application can do, we can go ahead and identify the actors in the Place Reviewer system. As you will have surmised by this time, the implementation of the Place Reviewer application we are going to make only has one actor—the user. The use cases of the user are as follows:</span></p>
<ul class="ol1">
<li class="li1"><span class="s1">The user uses the Place Reviewer application to create location reviews</span></li>
<li class="li1"><span class="s1">The user uses the Place Reviewer application to view reviews that were created by other users</span></li>
<li class="li1"><span class="s1">The user can view the exact location that was reviewed, by another user, on an interactive map</span></li>
<li class="li1"><span class="s1">The user can register on the Place Reviewer platform</span></li>
<li class="li1"><span class="s1">The user can logout from his/her Place Reviewer account</span></li>
</ul>
<p class="p1"><span class="s1">We have made suitable progress thus far. We have been able to state unequivocally what the Place Reviewer system does, identify the actors of the system, and clearly state the use cases of the system by its sole actor - the user. Let us go a step further by identifying the data that the system will need to cater for.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Identifying data</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As a consequence of our previous use case definitions, we can easily identify the type of data that the Place Reviewer application must cater for—by the creation of appropriate models. The first type of data is the user data and the second type is the review data. The user data, as the name implies, is the data relating to a user registered on the platform, whereas the review data is the necessary data for every review created on the platform.</span></p>
<p class="p1"><span class="s1">We will require the following data for the user: the user's email address, username, password, and account status. In addition, we will need a unique identifier for each user of the platform—a user ID—and the date on which the user was registered. With respect to the data necessary for reviews, we will need a review title, its body the content of the review, the address of the place reviewed, the name of the place reviewed, positional information of the place reviewed (its longitudinal and latitudinal coordinates), and a place ID to specifically identify the place being reviewed. In addition, a unique identifier will be required for the review being created as well as information relating to the time the review was created.</span></p>
<p class="p1"><span class="s1">At this juncture, you might be thinking: hold on, why do we have information pertaining to a place (a place name, place address, place ID, and longitude and latitude) coupled with the information of a review? Why don't we separate this information and consider it a distinct type of data we will be catering for?&#160;If you thought this, you are right, that will be a great approach to doing things if we, say, had a database table that possessed all the information of all the places we wanted to be reviewable on the platform. Sadly, we do not have any such table.</span></p>
<p class="p1"><span class="s1">Now, you may be wondering: how can we provide a user with the ability to review places of which we have no information about? The answer is simple. We utilize Google's Places API. We shall take a look at how to do this in the next chapter, but for now, hold on tight as we begin implementing the Place Reviewer backend.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up the database</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">As it is necessary for our system to store information, we need to set up a database for our application to<span class="Apple-converted-space">&#160;</span>persist data in. As we utilized Postgres as our primary datastore in a previous application we developed, we will utilize it as our primary datastore. We have already covered how to set up Postgres on various systems and as such we will not bother covering that here. Let us go ahead and create our database. Open your Terminal and run the following command:</span></p>
<pre class="p2"><span class="s1"><strong>createdb -h localhost —username=&lt;username&gt; place-reviewer</strong> </span></pre>
<p class="p2"><span class="s1">Once you run the command, a database named<kbd>&#160;place-reviewer</kbd> will be created on your system. The username you input in place of the <kbd>&lt;username&gt;</kbd> argument will be the username that you will use to connect to the database. Having set up the database for our application, we can go ahead with the implementation of the backend. We will be utilizing Spring Framework in the implementation of the backend.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing the backend</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Having established a sense of direction by specifying the various use cases of our application and setting up a database for our application to connect to, let us go straight ahead with its implementation. Open IntelliJ IDEA and create a new project with the Spring initializer. Upon clicking <span class="packt_screen">Next</span>, IntelliJ will retrieve the Spring initializer, after which you will be asked to provide certain details for the application. Do the following before proceeding to the next stage of the setup:</span></p>
<ol>
<li class="li2"><span class="s1">Input <kbd>com.example</kbd> as the group ID.</span></li>
<li class="li2"><span class="s1">Enter <kbd>place-reviewer</kbd> as the artifact ID.</span></li>
<li class="li2"><span class="s1">Select <span class="packt_screen">Maven Project</span> as the project type if it is not already selected.</span></li>
<li class="li2"><span class="s1">Leave the packaging option and Java version the way they are.</span></li>
<li class="li2"><span class="s1">Select <span class="packt_screen">Kotlin</span> as the language. This is important, as we are further learning the Kotlin language, after all.</span></li>
<li class="li2"><span class="s1">Change the version attribute to 1.0.0.</span></li>
<li class="li2"><span class="s1">Enter a description of your choice. Ours is <kbd>A nifty web application for the creation of location reviews</kbd>.</span></li>
<li class="li2"><span class="s1">Input <kbd>com.example.placereviewer</kbd> as the package name.</span></li>
</ol>
<p class="p2"><span class="s1">After filling in the required project information, proceed to the next screen by clicking <span class="packt_screen">Next</span>. We are required to select the dependencies of our project in the screen displayed to us.</span></p>
<div class="packt_infobox">The Spring initializer comes with the Spring plugin, which, at the time of writing, is only available on the IntelliJ IDEA Ultimate Edition, which requires a paid license. If you have the IntelliJ IDEA Community Edition installed, you can still develop this application. Simply generate the project using the Spring initializer utility at&#160;<a href="https://start.spring.io">https://start.spring.io</a> and import the project into IntelliJ IDEA.</div>
<p class="p2"><span class="s1">Select the Spring <span class="packt_screen">Security</span>, <span class="packt_screen">Session</span>, <span class="packt_screen">Cache</span>, and Web dependencies. In addition, select <span class="packt_screen">Thymeleaf</span> from the template engine category. Under the SQL category, select <span class="packt_screen">PostgreSQL</span>. In addition, in the <span class="packt_screen">Spring Boot Version</span> selection dropdown menu at the top of the screen, select <span class="packt_screen">2.0.0 M7</span> as the version. Upon selecting the necessary dependencies, the content should be similar to that in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/8bbc6e06-37a8-4ba8-a194-065e6632d774.jpg"/></div>
<p class="p1"><span class="s1">After asserting that you have selected the appropriate dependencies, click <span class="packt_screen">Next</span> to continue to the final setup screen. Here, you are required to provide a project name and a project location. Fill in <kbd>place-reviewer</kbd> as the project name and select the location in which you want the project to be saved on your computer:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/5bda2de8-4973-411a-8eb7-caabb200993a.jpg"/></div>
<div>
<p class="p1"><span class="s1">Once this has been done, select <span class="packt_screen">Finish</span> and wait for the project to be set up. You will be taken to a new IDE window containing the initial project files. We need not give any introductions to the structure of a Spring project, as we have already worked with one in previous chapters. Before we go further, add the following dependencies to the project's <kbd>pom</kbd> file:</span></p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-boot-starter-data-jpa<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span><span><br/>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.webjars<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>bootstrap<span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>4.0.0-beta.3<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.webjars<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>jquery<span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>3.2.1<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p class="p1"><span class="s1">Now, let's get on with connecting our application to our database.</span></p>
</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Connecting the backend to Postgres</h1>
                </header>
            
            <article>
                
<div>
<p class="p1"><span class="s1">To connect the Place Reviewer backend to the PostgreSQL database we created for it, we must modify our project's <kbd>application.properties</kbd> file to contain the necessary properties that are needed to facilitate a database connection with PostgreSQL. Open the project's <kbd>application.properties</kbd> file and add the following properties to it:</span></p>
<pre class="p1"><span class="s1">spring.jpa.hibernate.ddl-auto=create-drop<br/></span><span class="s1">spring.jpa.generate-ddl=true<br/></span><span class="s1">spring.datasource.url=jdbc:</span><span class="s2">postgresql://localhost:5432/place-reviewer<br/></span><span class="s1">spring.datasource.driver.class-name=org.postgresql.Driver<br/></span><span class="s1">spring.datasource.username=&lt;username&gt;</span></pre>
<p class="p1"><span class="s1">Insert an appropriate<span class="Apple-converted-space">&#160;</span>username where the <kbd>&lt;username&gt;</kbd> property is within the preceding code snippet. Having added the appropriate database connection properties, Spring Boot will be able to connect to the specified database upon the application start. Having set up the appropriate database connection properties for our project, let us create models for the <kbd>User</kbd> and <kbd>Review</kbd> entities we earlier identified.</span></p>
</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating models</h1>
                </header>
            
            <article>
                
<div>
<p class="p1"><span class="s1">We previously identified two distinct types of entities that must be catered for in our system: the <kbd>User</kbd> entity and the <kbd>Review</kbd> entity. It is time to create appropriate models for these entities. The first of these entities we will concern ourselves with is the User. Create a <kbd>data</kbd> package within the <kbd>com.example.placereviewer</kbd> package. Add a <kbd>model</kbd> package within the newly created <kbd>data</kbd> package. Now, add a <kbd>User.kt</kbd> file within the newly created <kbd>com.example.placereviewer.data.model</kbd> package with the following content:</span></p>
<pre><span>package </span>com.example.placereviewer.data.model<br/><br/><span>import </span>com.example.placereviewer.listener.UserListener<br/><span>import </span>org.springframework.format.annotation.<span>DateTimeFormat<br/></span><span>import </span>java.time.Instant<br/><span>import </span>java.util.*<br/><span>import </span>javax.persistence.*<br/><span>import </span>javax.validation.constraints.<span>Pattern<br/></span><span>import </span>javax.validation.constraints.<span>Size<br/></span><span><br/></span><span><br/></span><span>@Entity<br/></span><span>@Table</span>(<span>name = </span><span>"`user`"</span>)<br/><span>@EntityListeners</span>(UserListener::<span>class</span>)<br/><span>data class </span>User(<br/><span>  @Column</span>(<span>unique = </span><span>true</span>)<br/><span>  @Size</span>(<span>min = </span><span>2</span>)<br/><span>  @Pattern</span>(<span>regexp = </span><span>"^[A-Z0-9._%+-]+@[A-Z0-9.-]+</span><span>\\\\</span><span>.[A-Z] {2,6}</span><span>\$</span><span>"</span>)<br/><span>  var </span><span>email</span>: String = <span>""</span><span>,<br/></span><span>    @Column</span>(<span>unique = </span><span>true</span>)<br/><span>  var </span><span>username</span>: String = <span>""</span><span>,<br/></span><span>    @Size</span>(<span>min = </span><span>60</span><span>, </span><span>max = </span><span>60</span>)<br/><span>  var </span><span>password</span>: String = <span>""</span><span>,<br/></span><span>    @Column</span>(<span>name = </span><span>"account_status"</span>)<br/><span>  @Pattern</span>(<span>regexp = </span><span>"</span><span>\\</span><span>A(activated|deactivated)</span><span>\\</span><span>z"</span>)<br/><span>  var </span><span>accountStatus</span>: String = <span>"activated"</span><span>,<br/></span><span>    @Id<br/></span><span>    @GeneratedValue</span>(<span>strategy = </span>GenerationType.<span>AUTO</span>)<br/><span>  var </span><span>id</span>: Long = <span>0</span><span>,<br/></span><span>    @DateTimeFormat<br/></span><span>    @Column</span>(<span>name = </span><span>"created_at"</span>)<br/><span>  var </span><span>createdAt</span>: Date = Date.from(Instant.now())<br/>) {<br/><span>  @OneToMany</span>(<span>mappedBy = </span><span>"reviewer"</span><span>, </span><span>targetEntity =  </span>Review::<span>class</span>)<br/><span>  private var </span><span>reviews</span>: Collection&lt;Review&gt;? = <span>null<br/></span>}</pre>
<p class="p1"><span class="s1">We don't need spend time explaining much of what is going on in the preceding code snippet as we have prior experience with the creation of entities in Spring. In the preceding snippet, we defined a <kbd>User</kbd> entity with email, <kbd>username</kbd>, <kbd>password</kbd>, <kbd>accountStatus</kbd>, <kbd>Id</kbd>, and <kbd>createdAt</kbd> properties as its attributes. In addition, we specified that a User has many Review entities. We also specified an entity listener for the entity with the <kbd>@EntityListener</kbd> annotation. We have created neither a <kbd>Review</kbd> entity nor a <kbd>UserListener</kbd> for the <kbd>User</kbd> entity. As we are still focused on the <kbd>User</kbd> entity, let us focus on creating its entity listener before concerning ourselves with the <kbd>Review</kbd> entity. Add a new <kbd>listener</kbd> package to <kbd>com.example.placereviewer</kbd> and add a <kbd>UserListener.kt</kbd> file to it containing the following code:</span></p>
<pre><span>package </span>com.example.placereviewer.listener<br/><br/><span>import </span>com.example.placereviewer.data.model.User<br/><span>import </span>org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder<br/><span>import </span>javax.persistence.<span>PrePersist<br/></span><span>import </span>javax.persistence.<span>PreUpdate<br/></span><span><br/></span><span>class </span>UserListener {<br/><br/><span>  @PrePersist<br/></span><span>    @PreUpdate<br/></span><span>    fun </span><span>hashPassword</span>(user: User) {<br/>      user.<span>password </span>= BCryptPasswordEncoder().encode(user.<span>password</span>)<br/>    }<br/>}</pre>
<p class="p1"><span class="s1"><kbd>UserListener</kbd>&#160;has a single <kbd>hashPassword</kbd> function, which is invoked before persisting and before updating a <kbd>User</kbd> entity. The method has the single job of encoding the <kbd>password</kbd> property of a user into its bcrypt equivalent before persisting it in the database.</span></p>
<p class="p1"><span class="s1">Having created the necessary listeners for the <kbd>User</kbd> entity, let us turn our attention to the definition of a <kbd>Review</kbd> entity. Create a <kbd>Review.kt</kbd> file in <kbd>com.example.placereviewer.data.models</kbd> with the following content:</span></p>
<pre><span>package </span>com.example.placereviewer.data.model<br/><br/><span>import </span>org.springframework.format.annotation.<span>DateTimeFormat<br/></span><span>import </span>java.time.Instant<br/><span>import </span>java.util.*<br/><span>import </span>javax.persistence.*<br/><span>import </span>javax.validation.constraints.<span>Size<br/></span><span><br/></span><span>@Entity<br/></span><span>@Table</span>(<span>name = </span><span>"`review`"</span>)<br/><span>data class </span>Review(<br/><span>  @ManyToOne</span>(<span>optional = </span><span>false</span>)<br/><span>  @JoinColumn</span>(<span>name = </span><span>"user_id"</span><span>, </span><span>referencedColumnName = </span><span>"id"</span>)<br/><span>  var </span><span>reviewer</span>: User? = <span>null, <br/></span><span>    @Size</span>(<span>min = </span><span>5</span>)<br/><span>  var </span><span>title</span>: String = <span>""</span><span>,<br/></span><span>    @Size</span>(<span>min = </span><span>10</span>)<br/><span>  var </span><span>body</span>: String = <span>""</span><span>,<br/></span><span>    @Column</span>(<span>name = </span><span>"place_address"</span>)<br/><span>    @Size</span>(<span>min = </span><span>2</span>)<br/><span>  var </span><span>placeAddress</span>: String = <span>""</span><span>,<br/></span><span>    @Column</span>(<span>name = </span><span>"place_name"</span>)<br/><span>  var </span><span>placeName</span>: String = <span>""</span><span>,<br/></span><span>    @Column</span>(<span>name = </span><span>"place_id"</span>)<br/><span>  var </span><span>placeId</span>: String = <span>""</span><span>,<br/></span><span>  var </span><span>latitude</span>: Double = <span>0.0</span><span>,<br/></span><span>  var </span><span>longitude</span>: Double = <span>0.0</span><span>,<br/></span><span>    @Id<br/></span><span>    @GeneratedValue</span>(<span>strategy = </span>GenerationType.<span>AUTO</span>)<br/><span>  var </span><span>id</span>: Long = <span>0</span><span>,<br/></span><span>    @DateTimeFormat<br/></span><span>    @Column</span>(<span>name = </span><span>"created_at"</span>)<br/><span>  var </span><span>createdAt</span>: Date = Date.from(Instant.now())<br/>)</pre>
<p class="p1"><span class="s1">As can be seen in the preceding code snippet, we created a <kbd>Review</kbd> data class with the following properties: <kbd>reviewer</kbd>, <kbd>title</kbd>, <kbd>body</kbd>, <kbd>placeAddress</kbd>, <kbd>placeName</kbd>, <kbd>placeId</kbd>, <kbd>latitude</kbd>, <kbd>longitude</kbd>, <kbd>id</kbd>, and <kbd>createdAt</kbd>. The reviewer property is of the type <kbd>User</kbd>. It references the creator of the review. Every review must be created by a user. In addition, many reviews are created by a single user. We use the <kbd>@ManyToOne</kbd> annotation to properly declare this relationship between the <kbd>Review</kbd> and <kbd>User</kbd> entities.</span></p>
</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating data repositories</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As we have now set up our necessary entities, we must create repositories which we will use to access data pertaining to our entities. Create a repositories package within the <kbd>com.example.placereviewer</kbd> package. We have two entities, and as such, we shall create two repositories (one to access data pertaining to each entity). The first of the repositories will be <kbd>UserRepository</kbd> and the second will be&#160;<kbd>ReviewRepository</kbd>. Create a <kbd>UserRepository</kbd> interface file within <kbd>com.example.placereviewer.data.repository</kbd> with the following content:</span></p>
<pre><span>package </span>com.example.placereviewer.data.repository<br/><br/><br/><span>import </span>com.example.placereviewer.data.model.User<br/><span>import </span>org.springframework.data.repository.CrudRepository<br/><span><br/></span><span>interface </span>UserRepository : CrudRepository&lt;User<span>, </span>Long&gt; {<br/><br/>  <span>fun </span><span>findByUsername</span>(username: String): User?<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>findByUsername(String)</kbd> method retrieves a <kbd>User</kbd> from the database which has a username that corresponds to that passed as an argument to the function. The following is the <kbd>ReviewRepository</kbd> interface:</span></p>
<pre><span>package </span>com.example.placereviewer.data.repository<br/><br/><span>import </span>com.example.placereviewer.data.model.Review<br/><span>import </span>org.springframework.data.repository.CrudRepository<br/><span><br/></span><span>interface </span>ReviewRepository : CrudRepository&lt;Review<span>, </span>Long&gt; {<br/><br/>  <span>fun </span><span>findByPlaceId</span>(placeId: String)<br/>}</pre>
<p class="p1"><span class="s1">Having set up our entities and repositories to query these entities, we can start work on implementing the core business logic of the Place Reviewer application in the form of services and service implementations.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Place Reviewer business logic implementation</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As previously explained, in an application that adheres to the MVC design pattern, there are three primary components of consequence. These components are the model, view, and controller. The models are the components that are in charge of data management and the execution of business logic. In our Place Reviewer application, we are going to implement our models in the form of services that can be used across the backend. At this juncture, we need to create two fundamental services. The first to manage data pertaining to users of the application, and the second to manage review data.</span></p>
<p class="p1"><span class="s1">First, we must create a <kbd>UserService</kbd> interface that defines the behaviors that must be implemented by a valid <kbd>UserServiceImpl</kbd> class. We previously stated in our use cases for the Place Reviewer application that a user must be able to register (hence create an account) on the platform. As such, we must cater for this process in our model. Create a <kbd>service</kbd> package in the project's root package. Now, add the <kbd>UserService</kbd> interface to it:</span></p>
<pre><span>package </span>com.example.placereviewer.service<br/><span><br/></span><span>interface </span>UserService {<br/><br/>  <span>fun </span><span>register</span>(username: String<span>, </span>email: String<span>, </span>password: String): Boolean<br/>}</pre>
<p class="p1"><span class="s1">We declared one method that must be implemented by a valid <kbd>UserService</kbd>. This method is the <kbd>register (String, String, String)</kbd> method. <kbd>register()</kbd> takes three strings as arguments. The first is the username of the user to be registered, the second is a valid email address for the user, and the third is his/her password of choice. When invoked with appropriate arguments, <kbd>register()</kbd> attempts to register the user with his/her provided credentials and returns <kbd>true</kbd> if the user was registered successfully; otherwise, it returns <kbd>false</kbd>.</span></p>
<p class="p1"><span class="s1">The following is the implementation of the preceding <kbd>UserService</kbd>. Add it to the <kbd>service</kbd>&#160;package:</span></p>
<pre><span>package </span>com.example.placereviewer.service<br/><br/><span>import </span>com.example.placereviewer.data.model.User<br/><span>import </span>com.example.placereviewer.data.repository.UserRepository<br/><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span><br/></span><span>@Service<br/></span><span>class </span>UserServiceImpl(<span>val </span><span>userRepository</span>: UserRepository) : UserService {<br/><br/>  <span>override fun </span><span>register</span>(username: String<span>, </span>email: String<span>, <br/></span>                        password: String): Boolean {<br/>    <span>val </span>user = User(email<span>, </span>username<span>, </span>password)<br/>    u<span>serRepository</span>.save(user)<br/><br/>    <span>return true<br/></span><span>  </span>}<br/><br/>}</pre>
<p class="p1"><span class="s1">The workings of the <kbd>register()</kbd> function implemented by our <kbd>UserServiceImpl</kbd> class is straightforward. When valid username, email, and password arguments are passed to it, it creates a new object of the user - passing the appropriate arguments to its constructor. After the creation of an object of the user, the user is saved to the database with the following line:</span></p>
<pre class="p1"><span class="s1">userRepository.save(user)</span></pre>
<p class="p1"><span class="s1"><kbd>userRepository</kbd> is an instance of the <kbd>UserRepository</kbd> we created earlier. This instance is injected into the constructor of <kbd>UserServiceImpl</kbd> automatically by Spring Framework. Once the user has been saved to the database, the Boolean value <kbd>true</kbd> is returned.</span></p>
<p class="p1"><span class="s1">Up next is the implementation of a review service interface. Our review service must facilitate the creation of reviews and the listing of reviews that have been created by users of the platform. As a consequence of this requirement, we will mandate the implementation of the <kbd>createReview()</kbd> and <kbd>listReview()</kbd> methods in our user <kbd>service</kbd> interface.</span></p>
<p class="p1"><span class="s1">Add the following <kbd>ReviewService</kbd> interface to the <kbd>service</kbd> package of the project:</span></p>
<pre><span>package </span>com.example.placereviewer.service<br/><br/><span>import </span>com.example.placereviewer.data.model.Review<br/><span><br/></span><span>interface </span>ReviewService {<br/><br/>  <span>fun </span><span>createReview</span>(reviewerUsername: String<span>, </span>reviewData: Review): Boolean<br/><br/>  <span>fun </span><span>listReviews</span>(): Iterable&lt;Review&gt;<br/>}</pre>
<p class="p1"><span class="s1">The following is the <kbd>ReviewServiceImpl</kbd> class for the service we have just created. Add it, as well as all the services we will create later on in this chapter, to <kbd>com.example.placereviewer.service</kbd>:</span></p>
<pre><span>package </span>com.example.placereviewer.service<br/><br/><span>import </span>com.example.placereviewer.data.model.Review<br/><span>import </span>com.example.placereviewer.data.model.User<br/><span>import </span>com.example.placereviewer.data.repository.ReviewRepository<br/><span>import </span>com.example.placereviewer.data.repository.UserRepository<br/><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span><br/></span><span>@Service<br/></span><span>class </span>ReviewServiceImpl(<span>val </span><span>reviewRepository</span>: ReviewRepository<span>, val </span><span>userRepository</span>: UserRepository) : ReviewService {<br/><br/>  <span>override fun </span><span>listReviews</span>(): Iterable&lt;Review&gt; {<br/>    <span>return </span><span>reviewRepository</span>.findAll()<br/>  }<br/><br/>  <span>override fun </span><span>createReview</span>(reviewerUsername: String<span>, <br/></span>                            reviewData: Review): Boolean {<br/>    <span>val </span>reviewer: User? = <span>userRepository</span>.findByUsername(reviewerUsername)<br/><br/>    <span>if </span>(reviewer != <span>null</span>) {<br/>      reviewData.<span>reviewer </span>= reviewer<br/>      <span>reviewRepository</span>.save(reviewData)<br/>      <span>return true<br/></span><span>    </span>}<br/><br/>    <span>return false<br/></span><span>  </span>}<br/>}</pre>
<p class="p1"><span class="s1"><kbd>listReviews()</kbd> returns an iterable containing all the review data that has been stored within the application's database. <kbd>createReview()</kbd>, on the other hand, takes a string whose value is the username of the user creating the review and an instance of Review containing the data for the review to be created. <kbd>createReview()</kbd> first retrieves the user with the specified username by invoking the <kbd>findByUsername()</kbd> method of <kbd>UserRepository</kbd>. This user retrieved is the creator of the review—hence, the reviewer.</span></p>
<p class="p1"><span class="s1">If a null object is not returned by <kbd>UserRepository</kbd>, the user exists and as such, the retrieved user is assigned to the <kbd>reviewer</kbd> property of the review to be saved. After this assignment, the review is saved to the database and the function returns <kbd>true</kbd> – signifying that the process was successful. If no user with the username provided was found, <kbd>false</kbd> is returned by <kbd>createReview()</kbd>.</span></p>
<p class="p1"><span class="s1">Having created appropriate models in the form of services, let us work on securing our Place Reviewer application. This is an important procedure as we do not want unauthorized individuals to be able to access our application resources.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing the Place Reviewer backend</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Similar to how we went about securing the Messenger API in <a href="kt-prog-ex_ch04.html">Chapter 4</a>,&#160;<em>Designing and Implementing the Messenger Backend with Spring Boot 2.0</em></span>, <span class="s1">we shall utilize Spring Security to secure the Place Reviewer backend. Regardless of the utilization of Spring Security here, there is a slight variation to the way we are going to go about securing our application. In <a href="kt-prog-ex_ch04.html">Chapter 4</a>, <em>Designing and Implementing the Messenger Backend with Spring Boot 2.0</em>, we configured Spring Security to rely explicitly on JSON web tokens for the authorization of client applications. This time, we will rely solely on the power of Spring Security. In doing so, we will not make use of any other technology, such as JSON web tokens. Without further ado, let us begin work on securing our backend.</span></p>
<p class="p1"><span class="s1">First and foremost, we must create a custom web security configuration for our application. This custom configuration will implement Spring Framework's<span class="Apple-converted-space">&#160;</span> <kbd>WebSecurityConfigurerAdapter</kbd>. Create a <kbd>config</kbd> package in <kbd>com.example.placereviewer</kbd> and add the following&#160;<kbd>WebSecurityConfig</kbd> class:</span></p>
<pre><span>package </span>com.example.placereviewer.config<br/><span><br/></span><span>import </span>com.example.placereviewer.service.AppUserDetailsService<br/><span>import </span>org.springframework.context.annotation.<span>Bean<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration<br/></span><span>import </span>org.springframework.http.HttpMethod<br/><span>import </span>org.springframework.security.authentication.AuthenticationManager<br/><span>import </span>org.springframework.security.config.BeanIds<br/><span>import </span>org.springframework.security.config.annotation<br/>           .authentication.builders.AuthenticationManagerBuilder<br/><span>import </span>org.springframework.security.config.annotation<br/>          .web.builders.HttpSecurity<br/><span>import </span>org.springframework.security.config.annotation<br/>          .web.configuration.<span>EnableWebSecurity<br/></span><span>import </span>org.springframework.security.config.annotation<br/>          .web.configuration.WebSecurityConfigurerAdapter<br/><span>import </span>org.springframework.security.core.userdetails<br/>          .UserDetailsService<br/><span>import </span>org.springframework.security.crypto.bcrypt<br/>          .BCryptPasswordEncoder<br/><span>import </span>org.springframework.security.web<br/>          .DefaultRedirectStrategy<br/><span>import </span>org.springframework.security.web.RedirectStrategy<br/><br/><span>@Configuration<br/></span><span>@EnableWebSecurity<br/></span><span>class </span>WebSecurityConfig(<span>val </span><span>userDetailsService</span>: AppUserDetailsService) : WebSecurityConfigurerAdapter() {<br/><br/>  <span>private val </span><span>redirectStrategy</span>: RedirectStrategy = <br/>                                DefaultRedirectStrategy()<br/><br/>  <span>@Throws</span>(Exception::<span>class</span>)<br/>  <span>override fun </span><span>configure</span>(http: HttpSecurity) {<br/>    http.authorizeRequests()<br/>        .antMatchers(HttpMethod.<span>GET</span><span>,</span><span>"/register"</span>).permitAll()<br/>        .antMatchers(HttpMethod.<span>POST</span><span>,</span><span>"/users/registrations"</span>).permitAll()<br/>        .antMatchers(HttpMethod.<span>GET</span><span>,</span><span>"/css/**"</span>).permitAll()<br/>        .antMatchers(HttpMethod.<span>GET</span><span>,</span><span>"/webjars/**"</span>).permitAll()<br/>        .anyRequest().authenticated()<br/>        .and()<br/>        .formLogin()<br/>        .loginPage(<span>"/login"</span>)<br/>        .successHandler <span>{ </span>request<span>, </span>response<span>, </span>_ <span>-&gt;<br/></span><span>          </span><span>redirectStrategy</span>.sendRedirect(request<span>, </span>response<span>, </span><span>"/home"</span>)<br/>        <span>}<br/></span><span>        .</span>permitAll()<br/>        .and()<br/>        .logout()<br/>        .permitAll()<br/>  }<br/><br/>  <span>@Throws</span>(Exception::<span>class</span>)<br/>  <span>override fun </span><span>configure</span>(auth: AuthenticationManagerBuilder) {<br/>    auth.userDetailsService&lt;UserDetailsService&gt;(<span>userDetailsService</span>)<br/>        .passwordEncoder(BCryptPasswordEncoder())<br/>  }<br/><br/>  <span>@Bean</span>(<span>name = </span>[BeanIds.<span>AUTHENTICATION_MANAGER</span>])<br/>  <span>override fun </span><span>authenticationManagerBean</span>(): AuthenticationManager {<br/>    <span>return super</span>.authenticationManagerBean()<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">As we have explained earlier in this book, the <kbd>configure(HttpSecurity)</kbd> method of <kbd>WebSecurityConfig</kbd> has the task of configuring which<span class="Apple-converted-space">&#160;</span>HTTP URL paths are to be secured and which are not. With the <kbd>configure(HttpSecurity)</kbd> method, we have configured Spring Security to permit<span class="Apple-converted-space">&#160;</span>all HTTP<span class="Apple-converted-space">&#160;</span> POST requests to <kbd>/users/registrations</kbd>&#160;and GET requests whose paths match the paths <kbd>/register</kbd>, <kbd>/css</kbd>, and <kbd>/webjars/**</kbd>. In addition, we have permitted all HTTP requests to a login page that can be accessed from the path <kbd>/login</kbd>.</span></p>
<p class="p1"><span class="s1">We added a success handler to the login action which utilizes the <kbd>redirectStrategy</kbd> property that we defined for our <kbd>WebSecurityConfig</kbd> class to redirect a client to the <kbd>/home</kbd>&#160;path upon successful login of a user. Lastly, we permitted all logout requests to our backend.</span></p>
<p class="p1"><span class="s1"><kbd>configure(AuthenticationManagerBuilder)</kbd> sets up the <kbd>UserDetailsService</kbd> in use and specifies a password encoder to be used. We made use of a <kbd>BcryptPasswordEncoder</kbd> in this case. As you may have noticed, we have created no implementation of <kbd>UserDetailsService</kbd> in our project. Let us do that now. Add <kbd>AppUserDetailsService</kbd> to the <kbd>com.example.placereviewer.service</kbd> package:</span></p>
<pre><span>package </span>com.example.placereviewer.service<br/><br/><span>import </span>com.example.placereviewer.data.repository.UserRepository<br/><span>import </span>org.springframework.security.core.GrantedAuthority<br/><span>import </span>org.springframework.security.core.userdetails.User<br/><span>import </span>org.springframework.security.core.userdetails.UserDetails<br/><span>import </span>org.springframework.security.core.userdetails.UserDetailsService<br/><span>import </span>org.springframework.security.core.userdetails<br/>          .UsernameNotFoundException<span><br/></span><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span>import </span>java.util.ArrayList<br/><br/><span>@Service<br/></span><span>class </span>AppUserDetailsService(<span>private val </span><span>userRepository</span>: UserRepository) : UserDetailsService {<br/><br/>  <span>@Throws</span>(UsernameNotFoundException::<span>class</span>)<br/>  <span>override fun </span><span>loadUserByUsername</span>(username: String): UserDetails {<br/>    <span>val </span>user = <span>userRepository</span>.findByUsername(username) ?:<br/>        <span>throw </span>UsernameNotFoundException(<span>"A user with the username <br/></span><span>                                         $</span>username<span> doesn't exist"</span>)<br/><br/>    <span>return </span>User(user.<span>username</span><span>, </span>user.<span>password</span><span>, <br/></span>                ArrayList&lt;GrantedAuthority&gt;())<br/>  }<br/>}</pre>
<p class="p1"><span class="s1"><kbd>loadUsername(String)</kbd> attempts to load the <kbd>UserDetails</kbd> of a user matching the username passed to the function. If a user matching the provided username cannot be found, then a <kbd>UsernameNotFoundException</kbd> is thrown.</span></p>
<p class="p1"><span class="s1">With all this completed, you have successfully set up Spring Security for our backend. Great work!</span></p>
<p class="p1"><span class="s1">Now that we have finished work on our entities, repositories, services, service implementations, and Spring Security configuration, we can ideally begin implementing the frontend of our application. However, the implementation of the application's frontend is a task for the next chapter and as such, let us focus on other things. More specifically, let us explore the process of serving web content to a client application with Spring MVC.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Serving web content with Spring MVC</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In Spring MVC, HTTP requests are handled by controllers. Controllers are classes that have been annotated with <kbd>@Controller—</kbd>similar to how we annotate rest controllers with <kbd>@RestController</kbd>. The best way to understand the way controllers work is to have an example to scrutinize. Let us create a simple Spring MVC controller that handles HTTP GET requests sent to the <kbd>/say/hello</kbd> path by returning a view, which has the responsibility of rendering an HTML page to a user.</span></p>
<p class="p1"><span class="s1">Create a <kbd>controller</kbd> package in <kbd>com.example.placereviewer</kbd> and add the following class to it:</span></p>
<pre><span>package </span>com.example.placereviewer.controller<br/><br/><span>import </span>org.springframework.stereotype.<span>Controller<br/></span><span>import </span>org.springframework.web.bind.annotation.<span>GetMapping<br/></span><span>import </span>org.springframework.web.bind.annotation.<span>RequestMapping<br/></span><span><br/></span><span>@Controller<br/></span><span>@RequestMapping</span>(<span>"/say"</span>)<br/><span>class </span>HelloController {<br/><br/>  <span>@GetMapping</span>(<span>"/hello"</span>)<br/>  <span>fun </span><span>hello</span>(): String {<br/>    <span>return </span><span>"hello"<br/></span><span>  </span>}<br/>}</pre>
<p class="p1"><span class="s1">As can be seen, the creation of a controller is in no way a complex task. The annotation of <kbd>HelloController</kbd> with <kbd>@Controller</kbd> tells Spring that this class is a Spring MVC controller and as such is capable of handling HTTP requests. In addition, annotating <kbd>HelloController</kbd> with <kbd>@RequestMapping("/say")</kbd> specifies that the controller handles HTTP requests that have <kbd>/say</kbd>&#160;as their base paths. We defined a&#160;<kbd>hello()</kbd> action within the controller. Since this action was annotated with <kbd>@GetMapping("/hello")</kbd>, it handles GET requests to the path <kbd>/say/hello</kbd>. The string returned by <kbd>hello()</kbd> is the name of the view resource that should be rendered to the client upon the sending of a request to this route.</span></p>
<p class="p1"><span class="s1">Since&#160;<kbd>hello()</kbd> requires that a view named <kbd>hello</kbd>&#160;is returned to the client, our next task is to add such a view to our project. Views are generally added to the <kbd>templates</kbd>&#160;folder of a Spring project's <kbd>resources</kbd> directory. Add a&#160;<kbd>hello.html</kbd> file to the project by right-clicking on the templates and then selecting <span class="packt_screen">New</span> | <span class="packt_screen">HTML File</span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/eca3c1f0-78e1-4809-a037-1111921027bd.png"/></div>
<p class="p1"><span class="s1">You will be prompted to provide a name for the HTML file to be created. Input <kbd>hello</kbd> as the name and proceed:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/cab8282e-1873-464a-bbde-a3d30019b953.jpg"/></div>
<p class="p1"><span class="s1">IntelliJ IDEA will generate an HTML file in the selected directory. Once this is done, modify its content to contain the basic HTML, as shown here:</span></p>
<pre><span>&lt;!DOCTYPE </span><span>html</span><span>&gt;<br/></span><span>&lt;html </span><span>lang=</span><span>"en"</span><span>&gt;<br/></span><span>&lt;head&gt;<br/></span><span>  &lt;meta </span><span>charset=</span><span>"UTF-8"</span><span>&gt;<br/></span><span>  &lt;title&gt;</span>Hello<span>&lt;/title&gt;<br/></span><span>&lt;/head&gt;<br/></span><span>&lt;body&gt;<br/></span>Hello world!<br/><span>&lt;/body&gt;<br/></span><span>&lt;/html&gt;</span></pre>
<p class="p1"><span class="s1">We are now ready to test if the controller we created works. We will know if it works if it returns an HTML page with a message reading <kbd>Hello World!</kbd>&#160;when we send a GET request to its route path. Before we forget, we must add GET requests sent to <kbd>/say/hello</kbd>&#160;as requests permitted by Spring Security without authentication. Doing this is straightforward; simply modify <kbd>configure(HttpSecurity)</kbd> in <kbd>WebSecurityConfig</kbd> to permit GET requests to <kbd>/say/hello</kbd>, as shown in the following snippet:</span></p>
<pre><span>@Throws</span>(Exception::<span>class</span>)<br/><span>override fun </span><span>configure</span>(http: HttpSecurity) {<br/>    http.authorizeRequests()<br/>        .antMatchers(HttpMethod.<span>GET</span><span>,</span><span>"/say/hello"</span>).permitAll() <span>// added line<br/></span><span>        </span>.antMatchers(HttpMethod.<span>GET</span><span>,</span><span>"/register"</span>).permitAll()<br/>        .antMatchers(HttpMethod.<span>POST</span><span>,</span><span>"/users/registrations"</span>).permitAll()<br/>        .antMatchers(HttpMethod.<span>GET</span><span>, </span><span>"/css/**"</span>).permitAll()<br/>        .antMatchers(HttpMethod.<span>GET</span><span>, </span><span>"/webjars/**"</span>).permitAll()<br/>        .anyRequest().authenticated()<br/>        .and()<br/>        .formLogin()<br/>        .loginPage(<span>"/login"</span>)<br/>        .successHandler <span>{ </span>request<span>, </span>response<span>, </span>_ <span>-&gt;<br/></span><span>          </span><span>redirectStrategy</span>.sendRedirect(request<span>, </span>response<span>, </span><span>"/home"</span>)<br/><span>        }<br/></span><span>        </span>.permitAll()<br/>        .and()<br/>        .logout()<br/>        .permitAll()<br/>}</pre>
<p class="p1"><span class="s1">Build and run the Spring application, and then open your favorite web browser and navigate to the following URL: <kbd><span class="s2">http://localhost:5000/say/hello</span></kbd>.</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/20cb8365-0cf8-4a39-845f-11a523220e98.jpg"/></div>
<p class="p1"><span class="s1">You will be greeted enthusiastically with a&#160;<kbd>Hello World!</kbd> message.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing Spring application logs with ELK</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">When building systems that are intended to be deployed, an important thing to consider is the means by which server log files are managed. A server log is a log file that is created and maintained by a server. Log files generally consist of a list of activities that a server performed. A means of managing application log files that should be strongly considered is the use of the ELK (Elasticsearch, Logstash, and Kibana) stack. In this section, we will learn how to manage Spring application log files with the ELK stack.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generating logs with Spring</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">Before getting started with setting up an ELK stack to manage our Spring logs, we must configure Spring to generate log files. This can easily be done with a Spring project's application.properties file. Let's configure our Place Reviewer backend to generate logs.</span></p>
<p class="p3"><span class="s1">Open up the project's <kbd>application.properties</kbd> file and add the following line of code:</span></p>
<pre class="p3"><span class="s1">logging.file=application.log</span></pre>
<p class="p3"><span class="s1">This line of code configures Spring to generate and store server logs in an <kbd>application.log</kbd> file. This file will be generated and stored in the root directory of your project upon the next start of the project. What we have done is all that's necessary to configure server logs. Now, let's set up our log stack. We shall start by installing Elasticsearch.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Elasticsearch</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">Elasticsearch can be installed in four easy steps:</span></p>
<ol>
<li class="li3"><span class="s1">Download the Elasticsearch packaged in a ZIP&#160; file from <a href="https://www.elastic.co/downloads/elasticsearch"><span class="s3">https://www.elastic.co/downloads/elasticsearch</span></a>.</span></li>
<li class="li3"><span class="s1">Extract Elasticsearch from the ZIP file upon download.</span></li>
<li class="li3"><span class="s1">Run Elasticsearch from your terminal. Thus, run <kbd>bin/elasticsearch</kbd> (<kbd>bin/elasticsearch.bat</kbd> on Windows):</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/d9f3e65b-c366-467e-8cf0-eb3a3eb05ced.jpg" style="width:47.92em;height:27.33em;"/></div>
<p class="p1"><span class="s1">After executing <kbd>bin/elasticsearch</kbd> in your terminal, Elasticsearch will run on your system:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/f3e5b673-bf16-48f7-9140-10941506ef08.jpg" style="width:34.33em;height:20.33em;"/></div>
<p class="p1"><span class="s1">After running Elasticsearch, you can check if it's functioning properly by running the following command from your terminal:</span></p>
<pre class="p1"><strong><span class="s1">curl -XGET <span class="s2">http://localhost:9200</span></span></strong></pre>
<p class="p1"><span class="s1">If everything is set up correctly, you will get a response similar to the following:</span></p>
<pre class="p1"><span class="s1">{<br/></span><span class="s1"><span class="Apple-converted-space">  </span>"name" : "Df8YuN2",<br/></span><span class="s1"><span class="Apple-converted-space">  </span>"cluster_name" : "elasticsearch",<br/></span><span class="s1"><span class="Apple-converted-space">  </span>"cluster_uuid" : "Z8SYAKLNSZaMiGkYz7ihfg",<br/></span><span class="s1"><span class="Apple-converted-space">  </span>"version" : {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>"number" : "6.1.1",<br/></span><span class="s1"><span class="Apple-converted-space">    </span>"build_hash" : "bd92e7f",<br/></span><span class="s1"><span class="Apple-converted-space">    </span>"build_date" : "2017-12-17T20:23:25.338Z",<br/></span><span class="s1"><span class="Apple-converted-space">    </span>"build_snapshot" : false,<br/></span><span class="s1"><span class="Apple-converted-space">    </span>"lucene_version" : "7.1.0",<br/></span><span class="s1"><span class="Apple-converted-space">    </span>"minimum_wire_compatibility_version" : "5.6.0",<br/></span><span class="s1"><span class="Apple-converted-space">    </span>"minimum_index_compatibility_version" : "5.0.0"<br/></span><span class="s1"><span class="Apple-converted-space">  </span>},<br/></span><span class="s1"><span class="Apple-converted-space">  </span>"tagline" : "You Know, for Search"<br/></span><span class="s1">}</span></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Kibana</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Kibana's installation process is similar to that of Elasticsearch:</span></p>
<ol>
<li class="li1"><span class="s1">Download an appropriate Kibana archive from <a href="https://www.elastic.co/downloads/kibana"><span class="s2">https://www.elastic.co/downloads/kibana</span></a>.</span></li>
<li class="li1"><span class="s1">Extract Kibana from the archive.</span></li>
<li class="li1"><span class="s1">Run it with <kbd>bin/kibana</kbd>.</span></li>
</ol>
<p class="p1"><span class="s1">After downloading and running Kibana, check if it works by accessing <kbd><span class="s2">http://localhost:5601/</span></kbd> from your favorite browser. If all is working well, you will be presented with Kibana's web interface<span>:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/216b20a3-63e4-4188-9020-a9618b7581fd.jpg"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Logstash</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">To install Logstash:</span></p>
<ol>
<li class="li1"><span class="s1">Download its ZIP package from <a href="https://www.elastic.co/downloads/logstash"><span class="s3">https://www.elastic.co/downloads/logstash</span></a>.</span></li>
<li class="li1"><span class="s1">Unzip the package.</span></li>
</ol>
<p class="p1"><span class="s1">In the case of Logstash, simply downloading and running it will not suffice. We must configure it to understand the structure of our Spring log file. We do this by creating a Logstash configuration file. A Logstash config file contains three critical sections. These are the input, filter, and output sections. Each section sets up plugins that play a role in the processing of log files. Create a <kbd>logstash.conf</kbd> file in a suitable directory and add the following code to it:</span></p>
<pre class="p1"><span class="s1">input {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>file {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>type =&gt; "java"<br/></span><span class="s1"><span class="Apple-converted-space">    </span>path =&gt; "/&lt;path-to-project&gt;/place-reviewer/application.log"<br/></span><span class="s1"><span class="Apple-converted-space">    </span>codec =&gt; multiline {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>pattern =&gt; "^%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{TIME}.*"<br/></span><span class="s1"><span class="Apple-converted-space">      </span>negate =&gt; "true"<br/></span><span class="s1"><span class="Apple-converted-space">      </span>what =&gt; "previous"<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}<br/><br/></span><span class="s1">filter {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>#Tag log lines containing tab character followed by 'at' as stacktrace.<br/></span><span class="s1"><span class="Apple-converted-space">  </span>if [message] =~ "\tat" {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>grok {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>match =&gt; ["message", "^(\tat)"]<br/></span><span class="s1"><span class="Apple-converted-space">      </span>add_tag =&gt; ["stacktrace"]<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>#Grok Spring Boot's default log format<br/></span><span class="s1"><span class="Apple-converted-space">  </span>grok {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>match =&gt; [ "message", <br/></span><span class="s1"><span class="Apple-converted-space">               </span>"(?&lt;timestamp&gt;%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{TIME})<span class="Apple-converted-space">  <br/></span>                %{LOGLEVEL:level} %{NUMBER:pid} --- \[(?&lt;thread&gt;<br/>                [A-Za-z0-9-]+)\][A-Za-z0-9.]*\.(?&lt;class&gt;<br/>                [A-Za-z0-9#_]+)\s*:\s+(?&lt;logmessage&gt;.*)",<br/></span><span class="s1"><span class="Apple-converted-space">               </span>"message",<br/></span><span class="s1"><span class="Apple-converted-space">               </span>"(?&lt;timestamp&gt;%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{TIME})<span class="Apple-converted-space">  <br/></span>                %{LOGLEVEL:level} %{NUMBER:pid} --- .+? <br/>                :\s+(?&lt;logmessage&gt;.*)"<br/></span><span class="s1"><span class="Apple-converted-space">             </span>]<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>#Parsing timestamps in timestamp field<br/></span><span class="s1"><span class="Apple-converted-space">  </span>date {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>match =&gt; [ "timestamp" , "yyyy-MM-dd HH:mm:ss.SSS" ]<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}<br/><br/></span><span class="s1">output {<br/></span><span class="s1"><span class="Apple-converted-space">  </span># Print each event to stdout and enable rubydebug.<br/></span><span class="s1"><span class="Apple-converted-space">  </span>stdout {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>codec =&gt; rubydebug<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span># Send parsed log events to Elasticsearch<br/></span><span class="s1"><span class="Apple-converted-space">  </span>elasticsearch {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>hosts =&gt; ["127.0.0.1"]<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">Explaining what all plugins in the preceding code snippet do is beyond the scope of this book. Comments have been added where necessary to facilitate a better understanding. Change <kbd>path</kbd>&#160;in the file plugin of the input section to the absolute path of the Place Reviewer application's <kbd>application.log</kbd> file.</span></p>
<p class="p1"><span class="s1">Once done with the Logstash configuration file, run Logstash with the following command:</span></p>
<pre class="p1"><strong><span class="s1">/bin/logstash -f logstash.conf</span></strong></pre>
<p class="p1"><span class="s1">Logstash should begin storing stashing log events if things were configured properly. The last thing on our agenda is to configure Kibana to read the stashed data.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring Kibana</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Kibana can be easily configured to read logs that have been stashed to an Elasticsearch index. Access the Kibana web UI (<kbd><span class="s3">http://localhost:5601/</span></kbd>) and navigate to the settings management page by clicking <span class="packt_screen">Management</span> on the left navigation bar. Our first course of action in configuring Kibana is the creation of an index pattern. Click <span class="packt_screen">Index Patterns</span> on the management screen to manage the index patterns recognized by Kibana:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/13ea74c8-6f24-4bbf-b616-cb342fcfc94e.jpg"/></div>
<p class="p1"><span class="s1">Since you haven't previously created an index pattern on Kibana, you will be prompted to do so<span>:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/2e1ff624-6965-4e08-b823-a20bd0005e75.jpg"/></div>
<div>
<p class="p1"><span class="s1">Input the name of one of the indices recognized by Kibana (displayed on the screen) in the Index pattern field. After inputting an index pattern, proceed to the next step. You will be required to select a time filter field name in the next step<span>:</span></span></p>
</div>
<div class="CDPAlignCenter CDPAlign"><img src="images/9a13574a-f037-4e4c-82ff-487d662132cc.jpg"/></div>
<p class="p1"><span class="s1">Select <kbd>@timestamp</kbd> as the time filter field name in the dropdown. Having selected a time filter field, finish the creation of the index pattern by clicking <span class="packt_screen">Create Index Pattern</span>. You can manage index patterns you have created at any time from the settings management page by selecting <span class="packt_screen">Index Patterns</span>. Check your saved patterns:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/7515b35d-2558-41e9-899c-0737d268a801.jpg"/></div>
<p class="p1"><span class="s1">If you see the pattern we just created, then congratulations; you have successfully configured Kibana!</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In this chapter, we went deeper into our exploration of Kotlin and its usefulness in the development of web-based platforms by implementing the backend of the Place Reviewer application. In addition, we learned how to set up a Spring Framework project that utilizes Spring MVC to create modern applications that follow the Model-View-Controller design pattern. Furthermore, we learned how to configure Spring Security to prevent unauthenticated access to Spring web applications. Lastly, we explored the ELK stack and looked at how it can be utilized to manage server logs.</span></p>
<p class="p1"><span class="s1">In the next chapter, we will finish building the Place Reviewer application by implementing its frontend. In the process of the frontend implementation, we will learn about how we can build rich web applications with the Google Places API and how to test web applications built with Spring Framework.</span></p>
<p class="mce-root"></p>


            </article>

            
        </section>
    </div>
</body>
</html>