- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Our First .NET MAUI App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a new .NET MAUI project and customize it so
    that we can use it in the development of an app. The app that we will develop
    is a password management app. We will gradually introduce various features to
    it in the subsequent chapters. By the end of *Part 1*, we will possess a fully
    functional password management app.
  prefs: []
  type: TYPE_NORMAL
- en: Those who have prior experience with Xamarin.Forms will recall that the **Shell**
    serves as a convenient application container that simplifies app development by
    offering a unified structure for defining an application’s key components. While
    there isn’t a direct Visual Studio template for .NET MAUI Shell from Microsoft,
    we can effectively utilize the one from Xamarin.Forms. To incorporate Shell in
    our app, we’ll reuse the project template found in Xamarin.Forms. As well as from
    providing us with a proficient project template, the process of migrating the
    Xamarin.Forms Shell template to .NET MAUI will provide valuable insights into
    the migration of a Xamarin.Forms project to .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new .NET MAUI project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App startup and lifecycle management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new Xamarin.Forms project with Shell support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating this Xamarin.Forms project to .NET MAUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need Visual Studio 2022
    installed on either Windows or macOS. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the following Git
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Managing the source code in this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we will develop a password manager app incrementally in this book, the
    source code of each chapter is built on top of the previous chapters. To continuously
    improve our app, we will have separate branches for the source code of each chapter.
    If you want to clone the source code of all chapters in one command, you can clone
    it from the main branch. In the main branch, all the chapters are in separate
    folders. If you don’t want to use Git, you can also download the source code as
    a compressed file from the release area, as shown in the following screenshot
    (*Figure 2.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Source code in GitHub](img/B21554_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Source code in GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: Since new .NET MAUI releases may be available from time to time, the Git tags
    and versions in the release area will be updated according to the new .NET MAUI
    releases and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of this book can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition).'
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways to download the source code from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Download the source code in a compressed file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code can be downloaded in the release area, or use the following
    URL: [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/releases/tag/V1.0.0](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/releases/tag/V1.0.0).'
  prefs: []
  type: TYPE_NORMAL
- en: The release tag may be changed when a new release is available.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the source code per chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check out the source code for a chapter, you can use the following command,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I use the following naming convention for branches: `[xxx]/chapter[yy]`, where
    `x` is the edition number and `y` is the chapter number, such as `2nd/chapter01`.'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the source code from the main branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check out the source code of all chapters from the main branch, you can
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a new .NET MAUI project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create and configure a new .NET MAUI project, which
    will form the basis for further development of our password manager app. Given
    that the default .NET NAUI project template is a very simple one, we require a
    more robust project framework to establish the base project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms project templates provide suitable options. In particular, there
    is a template that incorporates the Shell and **Model-View-View Model** (**MVVM**)
    pattern setup. We’ll migrate this into our .NET MAUI project, which will also
    provide us with the opportunity to learn how to migrate a Xamarin.Forms project
    to .NET MAUI. Ultimately, we’ll create our very own Visual Studio project template.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new .NET MAUI project, we can use Visual Studio or the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project using Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new .NET MAUI project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Visual Studio 2022 and select **Create a new project** on the startup
    screen. This will open the **Create a new project** wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the screen, there is a search box. We can type `maui` in the search
    box, and .NET MAUI-related project templates will be shown (see *Figure 2.2*):![](img/B21554_02_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.2: New project setup – Create a new project'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are three templates for the .NET MAUI app or library:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**.NET MAUI App** – This is for a XAML-based .NET MAUI app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET MAUI Blazor Hybrid App** – This template can be used to create a .NET
    MAUI Blazor app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET MAUI Class Library** – This is the option for building a .NET MAUI class
    library. We can build shared components as a .NET MAUI class library when we develop
    a .NET MAUI app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s select **.NET MAUI App** and click the **Next** button; it goes to the
    next step to configure our new project, as shown in *Figure 2.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21554_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: New project setup – Configure your new project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the project name and solution name as `PassXYZ.Vault` and click the **Next**
    button. After the project is created, the project structure will look like *Figure
    2.4* and will display the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Common files* – In a new project, three files are included in the template
    – `App.xaml`, `MainPage.xaml`, and `MauiProgram.cs`. This is the group of files
    that we will work on throughout the book. They are platform agnostic. Both business
    logic and UI can be developed here and shared on all platforms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Platform-specific files* – There are five subfolders (`Android`, `iOS`, `MacCatalyst`,
    `Windows`, and `Tizen`) in the `Platforms` folder. Since we won’t support Tizen,
    we can remove it from our project.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resources* – A variety of resources ranging from images, fonts, splash screens,
    styles, and raw assets are in the `Resources` folder. These resources can be used
    in all supported platforms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21554_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: .NET MAUI project structure'
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET MAUI project, there is only one project structure. Later, we will
    see that the development of Xamarin.Forms involves multiple projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project using the dotnet command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although .NET MAUI was installed as part of the Visual Studio installation,
    it can also be installed independently using the command line. This flexibility
    allows the use of alternative development tools, such as Visual Studio Code, instead
    of Visual Studio. To create and build a .NET MAUI application from the command
    line, we can use the `dotnet` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out which project templates have been installed, we can refer to the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new project using the command line, we can execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the new .NET MAUI project has been created, we can build and test it. Before
    we move on to that, let’s spend some time looking at the .NET MAUI app startup
    code and lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: App startup and lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lifecycle management in .NET MAUI is crucial for efficient resource management,
    ensuring smooth and consistent user experiences, secure application handling,
    and understanding and troubleshooting app behavior. It allows the application
    to conserve resources, appropriately saving and restoring the application’s state
    when it’s in the background or foreground. It provides opportunities to perform
    certain actions when an app goes to the background, such as saving data or pausing
    activities. Moreover, it provides enhanced security by managing sensitive data
    when apps switch to and from the active state. Hence, understanding the application
    lifecycle is crucial for crafting robust, efficient, and user-friendly .NET MAUI
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET MAUI projects, app startup and lifecycle management are handled in
    the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MauiProgram.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.xaml/App.xaml.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Generic Host is used for app startup and configuration. When the application
    starts, a .NET Generic Host object is created to encapsulate an app’s resources
    and lifetime functionality, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency injection** (**DI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifecycle management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This enables apps to be initialized in a single location and provides the ability
    to configure fonts, services, and third-party libraries. This chapter will explore
    everything except DI, which will be introduced in *Chapter 6*, *Software Design
    with Dependency Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Generic Host**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are a Xamarin developer, you may not be familiar with .NET Generic Host.
    Introduced in .NET Core, .NET Generic Host is a unified hosting model for building
    cross-platform .NET applications. It provides a consistent way to configure, run,
    and manage services and background tasks across various types of .NET applications,
    such as console apps, microservices, and web applications. In .NET MAUI, the same
    pattern is borrowed and used for startup and configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the app start up code in *Listing 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.1: `MauiProgram.cs` ([https://epa.ms/MauiProgram2-1](https://epa.ms/MauiProgram2-1))'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the following in *Listing 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** In each platform, the entry point is in platform-specific code. The
    entry point calls the `CreateMauiApp` function, which is a method of the `MauiProgram`
    static class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** Inside `CreateMauiApp`, the code calls the `CreateBuilder` function,
    which is a method of the `MauiApp` static class, and returns a `MauiAppBuilder`
    instance, which provides a .NET Generic Host interface. We can use this instance
    of the .NET Generic Host interface to configure resources or services used in
    our app.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** The return value of `CreateMauiApp` is a `MauiApp` instance, which
    is the entry point of our app.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** The `App` class referenced in the `UseMauiApp` method is the root object
    of our application. Let’s review the definition of the `App` class in *Listing
    2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.2: `App.xaml.cs` ([https://epa.ms/App2-2](https://epa.ms/App2-2))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Listing 2.2*, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The `App` class is derived from the `Application` class, and the `Application`
    class is defined in the `Microsoft.Maui.Controls` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** `AppShell` is an instance of Shell, and it defines the UI of the initial
    page of the app.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application` creates an instance of the `Window` class within which the application
    will run and views will be displayed. In the `App` class, we can overwrite the
    `CreateWindow` method to manage the lifecycle, which we will see soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET MAUI app generally operates in four execution states:'
  prefs: []
  type: TYPE_NORMAL
- en: Running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deactivated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During the state transitions, the predefined lifecycle events will be triggered.
    Six cross-platform lifecycle events are defined, as we can see in *Table 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event** | **Description** | **State transition** | **Override method**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Created | This event is raised after the native window has been created.
    | Not running -> Running | `OnCreated` |'
  prefs: []
  type: TYPE_TB
- en: '| Activated | This event is raised when the window has been activated and is
    or will become the focused window. | Not running -> Running | `OnActivated` |'
  prefs: []
  type: TYPE_TB
- en: '| Deactivated | This event is raised when the window is no longer the focused
    window. However, the window might still be visible. | Running -> Deactivated |
    `OnDeactivated` |'
  prefs: []
  type: TYPE_TB
- en: '| Stopped | This event is raised when the window is no longer visible. | Deactivated
    -> Stopped | `OnStopped` |'
  prefs: []
  type: TYPE_TB
- en: '| Resumed | This event is raised when an app resumes after being stopped. |
    Stopped -> Running | `OnResumed` |'
  prefs: []
  type: TYPE_TB
- en: '| Destroying | This event is raised when the native window is destroyed and
    deallocated. | Stopped -> Not running | `OnDestroying` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Lifecycle events and override methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following Microsoft document to find out more about lifecycle
    events: [https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/app-lifecycle](https://learn.microsoft.com/en-us/dotnet/maui/fundamentals/app-lifecycle).'
  prefs: []
  type: TYPE_NORMAL
- en: These lifecycle events are associated with the instance of the `Window` class
    created by `Application`. For each event, a corresponding override method is defined.
    We can either subscribe to the lifecycle events or create override functions to
    handle lifecycle management.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to the Window lifecycle events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To subscribe to the lifecycle events, as we can see in *Listing 2.3*, at **(1)**,
    we can override the `CreateWindow` method in the `App` class to create a `Window`
    instance on which we can subscribe to events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.3: `App.xaml.cs` with lifecycle events ([https://epa.ms/App2-3](https://epa.ms/App2-3))'
  prefs: []
  type: TYPE_NORMAL
- en: In *Listing 2.3*, we revised the code of `App.xaml.cs`, and we subscribed to
    all six events so that we can run a test and observe the state in the Visual Studio
    output window. As we can see in the following debug output, we run and test our
    app in the Windows environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we launch our app, we can see that `Created` and `Activated` events are
    fired. Then, we minimize our app and we can see that `Deactivated` and `Stopped`
    events are fired. When we resume our app again, `Resumed` and `Activated` events
    are fired. Finally, we close our app, and a `Destroying` event is fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Consuming the lifecycle override methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alternatively, we can consume the lifecycle override methods. We can create
    our own derived class from the `Window` class:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, right-click on the project node and select **Add** and then
    **New Item…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Add New Item** window, select **C# Class** from the template and name
    it `PxWindow`. We created a new class, as shown next in *Listing 2.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.4: `PxWindow.cs` ([https://epa.ms/PxWindow2-4](https://epa.ms/PxWindow2-4))'
  prefs: []
  type: TYPE_NORMAL
- en: In *Listing 2.4*, we created a new class, `PxWindow`. In this class, we define
    our lifecycle override methods. We can use this new class in `App.xaml.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the modified version of `App.xaml.cs` (*Listing 2.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2.5: Modified App.xaml.cs with PxWindow (*[https://epa.ms/App2-5](https://epa.ms/App2-5)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we repeat the previous test steps, we can see the following output in
    the Visual Studio output window. The output looks very similar to the previous
    one. Basically, both approaches have the same effect on lifecycle management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have learned about app lifecycle management in .NET MAUI through the `Window`
    class. We can either subscribe to lifecycle events or override the overridable
    methods to manage the app lifecycle. *Table 2.1* shows the comparison of these
    two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were a Xamarin.Forms developer, you might know that there were lifecycle
    methods defined in the `Application` class as well. In .NET MAUI, the following
    virtual methods are still available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnStart` – Called when the application starts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSleep` – Called each time the application goes to the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnResume` – Called when the application is resumed, after being sent to the
    background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To observe the behavior of these methods, we can override the following methods
    in our `App` class, as shown in *Listing 2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.6: `App.xaml.cs` ([https://epa.ms/App2-6](https://epa.ms/App2-6))'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we test the preceding code on Windows, we can see the following debug
    message in the Visual Studio Output window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As demonstrated in *Listing 2.6*, specific methods will be activated according
    to the varying statuses of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** When the app starts, the `OnStart` method is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** When we minimize our app, the `OnSleep` method is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** When we resume the app from the taskbar, the `OnResume` method is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned about the lifecycle states of a .NET MAUI app and also learned
    that we can either subscribe to lifecycle events or use override methods to manage
    the app’s lifecycle. Let’s now focus on the configuration of resources during
    the app’s startup.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource management is one of the major differences between .NET MAUI and Xamarin.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform development presents unique challenges as each platform has its
    own method for managing resources. This diversity can pose significant management
    tasks for development teams. For instance, we must incorporate multiple image
    sizes to accommodate various resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: In Xamarin, most of the resources are managed separately in platform-specific
    projects. If we want to add an image, we must add the image files with different
    sizes to all platform projects separately.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI provides an elegant solution to manage resources effectively. The
    design goal of one single project for all supported platforms helps to manage
    resources in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET MAUI, resource files can be tagged into different categories using
    a build action based on the role they play in the project, as we can see in *Table
    2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Resource Type** | **Build Action** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Images | `MauiImage` | `dotnet_bot.svg` |'
  prefs: []
  type: TYPE_TB
- en: '| Icons | `MauiIcon` | `appicon.svg` |'
  prefs: []
  type: TYPE_TB
- en: '| Splash screen image | `MauiSplashScreen` | `appiconfg.svg` |'
  prefs: []
  type: TYPE_TB
- en: '| Fonts | `MauiFont` | `OpenSans-Regular.ttf` |'
  prefs: []
  type: TYPE_TB
- en: '| Style definition using external CSS | `MauiCss` | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Raw assets | `MauiAsset` | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| XAML UI definition | `MauiXaml` | N/A |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: .NET MAUI resource types'
  prefs: []
  type: TYPE_NORMAL
- en: The last three are not used frequently, so we will focus on examples using the
    more common resource types.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding a resource file, the build action can be set in the **Properties**
    window in Visual Studio. If we look at the project file, we can see the following
    `ItemGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we put resources according to the convention of default folder setup, the
    resources will be treated as the respective category and the build action will
    be set automatically.
  prefs: []
  type: TYPE_NORMAL
- en: App icon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our app setup, as we can see in the `ItemGroup` above, we have an SVG image
    file, `appicon.svg`, in the `Resources\AppIcon` folder, with the build action
    set to `MauiIcon`. At build time, this file is used to generate icon images on
    the target platform for various purposes, such as on the device or in the app
    store.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to move this SVG file together with other images to the `Resources\Images`
    folder. In that case, we should use the following entry in the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The downside is that the build action treats the files in the same folder inconsistently
    – `appicon.svg` resides in the **Resources\AppIcon** folder instead of **Resources\Images**
    in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Splash screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The configuration of the splash screen is similar to configuration of the app
    icon. We have an SVG image file, `splash.svg`, in the `Resources/Splash` folder,
    with the build action set to `MauiSplashScreen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Resources like app icons, splash screens, and other images are simple and can
    be directly configured in the project file.
  prefs: []
  type: TYPE_NORMAL
- en: Some frequently used resources, such as custom fonts and services, may have
    to be configured in code, or in both code and project files. We will discuss the
    configuration of custom fonts in the next section and leave DI until *Chapter
    6*, *Software Design with Dependency Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting custom font icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom fonts can be managed as part of resources. Using custom font icons, we
    can dramatically reduce the number of image resources in our app. In a mobile
    app, the visual representation is generally delivered through images. We use images
    in all kinds of navigation activities. In Android and iOS development, we need
    to manage image resources for different screen resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: There are many advantages of using custom fonts as icons instead of images.
    Font icons are vector icons instead of bitmap icons. Vector icons are scalable,
    meaning you don’t need different images with different sizes and different resolutions
    based on the device. Icon font scaling can be handled through the `FontSize` property.
    The font file size is also much smaller than the images. A font file with hundreds
    of icons in it can be only a few KB in size.
  prefs: []
  type: TYPE_NORMAL
- en: The icon color can be changed with the `TextColor` property. With static images,
    we are not able to change the icon color.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, font files can be managed in the shared project, so we don’t have to
    manage fonts separately on different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In both Xamarin.Forms and .NET MAUI, we can use a custom font (icon font) instead
    of images for application icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET MAUI, controls that display text typically have definable properties
    for configuring font settings. The properties that can be configured include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FontAttributes`, which is an enumeration with three members: `None`, `Bold`,
    and `Italic`. The default value of this property is `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontSize`, which is the property of the font size, and the type is `double`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontFamily`, which is the property of the font family, and the type is `string`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom font setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The setup of custom fonts has two stages – adding font files and configuring
    them. Custom font files can be added to a shared project in both .NET MAUI and
    Xamarin.Forms. However, the configuration process differs between them. In Xamarin.Forms,
    the configuration is handled through `AssemblyInfo.cs`. In .NET MAUI, this is
    managed via .NET Generic Host.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xamarin.Forms, the process for accomplishing this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the font file to the Xamarin.Forms shared project as an embedded resource
    (build action: `EmbeddedResource`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the font file with the assembly in a file such as `AssemblyInfo.cs`
    using the `ExportFont` attribute. An optional alias can also be specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In .NET MAUI, the process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the font files to the `Resources`->`Fonts` folder. The build action is
    set to **MauiFont**, as we can see in *Figure 2.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21554_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: .NET MAUI Resources'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of registering the font file with the assembly, .NET MAUI initializes
    most of the resources through .NET Generic Host in the startup code, as shown
    in *Listing 2.7* at **(1)**. Font files are added using the `ConfigureFonts` method,
    which is an extension method of the `MauiAppBuilder` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our project, we use the Font Awesome icon library from the following open-source
    project: [https://github.com/FortAwesome/Font-Awesome](https://github.com/FortAwesome/Font-Awesome).'
  prefs: []
  type: TYPE_NORMAL
- en: The `fa-brands-400.ttf`, `fa-regular-400.ttf`, and `fa-solid-900.ttf` font files
    can be downloaded from the preceding website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the source code in *Listing 2.7* and see how to add these fonts
    to the app configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.7: `MauiProgram.cs` ([https://epa.ms/MauiProgram2-7](https://epa.ms/MauiProgram2-7))'
  prefs: []
  type: TYPE_NORMAL
- en: In the above code, we can add fonts by calling the `ConfigureFonts` **(1)**
    method on the `MauiAppBuilder` object. To pass arguments to `ConfigureFonts`,
    we call the extension method `AddFont` of interface `IFontCollection` to add a
    font.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying font icons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To display font icons in .NET MAUI applications, the font icon data can be
    defined in a `FontImageSource` object. This class, a derivative of the `ImageSource`
    class, comprises the properties shown in *Table 2.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property name** | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Glyph` | `string` | Unicode character value, such as `"&#xf007;"` |'
  prefs: []
  type: TYPE_TB
- en: '| `Size` | `double` | The size of the font in device-independent units |'
  prefs: []
  type: TYPE_TB
- en: '| `FontFamily` | `string` | A string representing the font family, such as
    `FontAwesomeRegular` |'
  prefs: []
  type: TYPE_TB
- en: '| `Color` | `Color` | Font icon color in `Microsoft.Maui.Graphics.Color` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.3: Properties of FontImageSource'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following XAML example has a single font icon being displayed in an `Image`
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you are not familiar with the XAML syntax in the preceding example, don’t
    worry. We will cover it in the following chapter. In the preceding code, a `User`
    icon is displayed in an `Image` control, which is from the `FontAwesomeRegular`
    font family that we just added in the configuration. The `Glyph` of the `User`
    icon in the hexadecimal format is `\uf007`, presented here in C# escaped format.
    When we use it in XML, the escaped format we have to use is `&#xf007;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent C# code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we referred to a font icon using a string representation
    of a hex number for its `Glyph`. However, this is not the most practical for real-world
    usage. It’s preferable to define font glyphs as C# string constants, allowing
    more meaningful references. Several approaches can be applied here. In our case,
    we make use of the open-source **IconFont2Code** tool to generate string constants.
    **IconFont2Code** can be found on GitHub using the following URL: [https://github.com/andreinitescu/IconFont2Code](https://github.com/andreinitescu/IconFont2Code).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we use Font Awesome. Through the **IconFont2Code** website,
    we can upload the font library from our project’s `Resources\Fonts` folder. **IconFont2Code**
    then generates the corresponding code for us, as demonstrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can save the generated C# files in the `Resources\Styles` folder. The preceding
    file can be found here: `Resources\Styles\FontAwesomeRegular.cs`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding `FontAwesomeRegular` static class, a font icon can be used
    just like the normal text in a XAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added a circle plus icon to the `Button` control,
    which appears before the text `"Click me"`. In order to reference the icon name
    in the generated C# class, we introduce an `app` namespace, as defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have created our project and configured the resources that we need.
    It’s time to build and test our app.
  prefs: []
  type: TYPE_NORMAL
- en: Building and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in *Chapter 1*, *Getting Started with .NET MAUI*, we cannot
    build and test every target using a single platform. Please refer to *Table 1.8*
    for the available build targets on Windows and macOS platforms. For the sake of
    simplicity, we will build and test targets Windows and Android on Windows. For
    iOS and macOS builds, we will do it on the macOS platform.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve set things up, we can start building and debugging our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with building and testing on the Windows platform. We can choose
    the framework that we want to run or debug, depending on our needs, as depicted
    in *Figure 2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Building and debugging'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can run or debug a Windows build on a local machine by choosing **net8.0-windows10.0.19041.0**
    as the framework. However, to accomplish this, we must first enable Developer
    Mode on Windows, if it’s not yet been activated. Please refer to *Figure 2.7*
    for guidance on enabling Developer Mode on Windows 10 or 11:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Start**menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for **Developer settings** and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on **Developer Mode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you receive a warning message about Developer Mode, read it, and select **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7: Developer Mode](img/B21554_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Developer Mode'
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Android builds, testing can be done using an Android emulator or device.
    However, prior to building or debugging, we need to connect a device or set up
    an instance of an emulator. For instructions on how to configure a device or create
    an emulator instance, please refer to the following Microsoft documentation: [https://learn.microsoft.com/en-us/dotnet/maui/](https://learn.microsoft.com/en-us/dotnet/maui/).'
  prefs: []
  type: TYPE_NORMAL
- en: We can run or debug from Visual Studio (*Figure 2.6*) by selecting **net8.0-android**
    as the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can also build and run `net8.0-android` from the command
    line using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.8: Running on Android and Windows](img/B21554_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Running on Android and Windows'
  prefs: []
  type: TYPE_NORMAL
- en: After we run the app on Android and Windows targets, we can see the preceding
    screen (*Figure 2.8*).
  prefs: []
  type: TYPE_NORMAL
- en: iOS and macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re able to build and test iOS and macOS targets on a Mac computer. Given
    Microsoft’s announcement regarding the retirement of Microsoft Visual Studio 2022
    for Mac, we will proceed to demonstrate how to build and test iOS and macOS targets
    utilizing command-line operations.
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing the iOS target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build and test the iOS target, we can use the following command in the project
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To select a target iOS emulator, we need to provide the device ID using the
    following parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the device ID, we can launch Xcode on a Mac computer and go to **Windows**
    -> **Devices and Simulators**, as shown in *Figure 2.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Devices and simulators in Xcode'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an addition to building on a Mac, it’s worth noting that iOS targets can
    also be built and tested using Visual Studio 2022 on Windows, provided the configuration
    is set up accordingly. Refer to the following Microsoft documentation for instructions
    on how to deploy an iOS app using hot restart: [https://learn.microsoft.com/en-us/dotnet/maui/ios/hot-restart](https://learn.microsoft.com/en-us/dotnet/maui/ios/hot-restart).'
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing the macOS target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the macOS target, we can use the following command to build and test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In *Figure 2.10*, we can see a screenshot of our project in both iOS and macOS.
    The look and feel are similar to Android and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Running on iOS and macOS](img/B21554_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Running on iOS and macOS'
  prefs: []
  type: TYPE_NORMAL
- en: The environment setup for Android, iOS, and macOS involves platform-specific
    details. Please refer to the Microsoft documentation for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Our app works well now, but you can see that it is a very simple one with only
    one window. To lay a better foundation for our subsequent development, we will
    use Shell as the navigation framework. There is a good Shell-based template in
    Xamarin.Forms, and we can use it to create the initial code for our app.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from Xamarin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will showcase the process of migrating a Xamarin.Forms
    project template to .NET MAUI. It should be noted that this serves only as an
    example, given that there are many types of Xamarin projects. Therefore, only
    an example of migrating a Xamarin.Forms project to .NET MAUI is discussed in this
    chapter. For additional information on migrating Xamarin-native projects and other
    related topics, please refer to the Microsoft documentation: [https://learn.microsoft.com/en-us/dotnet/maui/migration/](https://learn.microsoft.com/en-us/dotnet/maui/migration/).'
  prefs: []
  type: TYPE_NORMAL
- en: Though we are primarily porting the Xamarin.Forms Shell template as an example
    in this chapter, this new project template is crucial for our subsequent developments.
    To provide further context, I will briefly introduce the planned migration of
    PassXYZ.Vault from Xamarin.Forms to .NET MAUI. This will outline the challenges
    we’ll need to tackle in this book, which should prepare you for the challenges
    you may encounter when migrating your own apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the app that we have created successfully now. We are going to develop
    a password manager app named PassXYZ.Vault in the rest of this book. Version *1.x.x*
    of this app is implemented in Xamarin.Forms, and you can find it on GitHub: [https://github.com/passxyz/Vault](https://github.com/passxyz/Vault).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version *1.x.x* is developed using Xamarin.Forms *5.0.0*. We plan to rebuild
    it using .NET MAUI and will discuss the process in this book. The .NET MAUI release
    will be labeled as *2.x.x*, and the source code will be available at the following
    location: [https://github.com/passxyz/Vault2](https://github.com/passxyz/Vault2).'
  prefs: []
  type: TYPE_NORMAL
- en: Both the *1.x.x* and *2.x.x* versions utilize Shell as the navigation framework,
    supported in .NET MAUI and Xamarin.Forms through `Microsoft.Maui.Controls.Shell`
    and `Xamarin.Forms.Shell`, respectively. Shell provides a consistent navigation
    user experience across all platforms. We will delve deeper into Shell and its
    navigation features in *Chapter 5*, *Navigation Using .NET MAUI Shell and NavigationPage*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project templates created from the Visual Studio for both .NET MAUI and Xamarin.Forms
    incorporate Shell. However, the default .NET MAUI project template contains only
    the simplest form of Shell, as seen in *Listing 2.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.8: `AppShell.xaml` ([https://epa.ms/AppShell2-8](https://epa.ms/AppShell2-8))'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainPage` is displayed in `ShellContent`, presenting a basic UI without much
    content. In our app, we will employ the **MVVM pattern** to build our user interface
    via Shell. In order to do so, boilerplate code is required that encompasses both
    the MVVM pattern and the Shell navigation structure.'
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM pattern is a frequently used UI design pattern in .NET MAUI app development.
    We will encounter it several times as we progress through the topics in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have the option of creating this code from scratch. However, the Xamarin.Forms
    template includes the boilerplate code that I used in version *1.x.x* of `PassXYZ.Vault`.
    Thus, the same project template can be created for .NET MAUI. This process also
    gives us an insight into how to migrate or reuse existing Xamarin.Forms code.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating and reusing the Shell template from Xamarin.Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.Forms provides a more versatile Shell template that can be used to generate
    boilerplate code with either flyout or tabbed Shell navigation options. We can
    set up a new Xamarin.Forms project using this template. Then, we can implement
    this boilerplate code in the .NET MAUI application that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new Xamarin.Forms project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch Visual Studio 2022 and select **Create a new project**. This opens the
    **Create a new project** wizard. In the search box, we can type `Xamarin`, and
    all Xamarin-related project templates will be shown (see *Figure 2.11*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11: New Xamarin project](img/B21554_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: New Xamarin project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Mobile App (Xamarin.Forms)** from the list and click **Next**. On
    the next screen, as shown in *Figure 2.12*, we can choose a different location
    and use the same project name, `PassXYZ.Vault`, and then click the **Create**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12: Configure the Xamarin project](img/B21554_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Configure the Xamarin project'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more step, as shown in *Figure 2.13*. Let’s select the **Flyout**
    template and click **Create**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.13: Configure the Xamarin project – Flyout](img/B21554_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Configure the Xamarin project – Flyout'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the new solution has been created, we can see that there are four projects
    in the solution, as shown in *Figure 2.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PassXYZ.Vault** – This is a .NET Standard project that is shared by other
    projects, and all platform-independent code should be here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PassXYZ.Vault.Android** – This is the Android platform-specific project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PassXYZ.Vault.iOS** – This is the iOS platform-specific project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PassXYZ.Vault.UWP** – This is the UWP-specific project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We observe that the project structure of Xamarin.Forms is quite different from
    that of .NET MAUI. The solution consists of multiple projects, with resources
    managed separately in platform-specific projects. The bulk of the development
    work is carried out in the .NET Standard project, **PassXYZ.Vault**. We will focus
    on migrating and reusing the code present in this project.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21554_02_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Xamarin.Forms project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of this Xamarin.Forms project can be found here: [https://github.com/shugaoye/PassXYZ.Vault2/tree/xamarin](https://github.com/shugaoye/PassXYZ.Vault2/tree/xamarin).'
  prefs: []
  type: TYPE_NORMAL
- en: The migration process is relatively straightforward when it does not involve
    platform-specific code. We are tackling the simplest case here, but it’s important
    to note that production code might be far more complex than this example. Therefore,
    any migration should only occur after meticulous analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s concentrate on the .NET Standard project. Its content includes the boilerplate
    code required for the MVVM pattern and Shell UI – precisely what we need. We can
    copy the files highlighted in *Table 2.4* to the .NET MAUI project and adjust
    the namespaces in the source code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below are the steps of the migration process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to *Table 2.4*, which shows a list of actions corresponding to
    the list of files and folders in the .NET Standard project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Xamarin.Forms** | **Actions** | **.NET MAUI** |'
  prefs: []
  type: TYPE_TB
- en: '| `App.xaml` | No | Keep the .NET MAUI version. It defines the instance of
    the `Application` class. |'
  prefs: []
  type: TYPE_TB
- en: '| `AppShell.xaml` | Replace | Overwrite the .NET MAUI version and change namespaces
    to .NET MAUI. This file defines the Shell navigation hierarchy. |'
  prefs: []
  type: TYPE_TB
- en: '| `Views/` | Copy | New folder in .NET MAUI project. Need to change namespaces.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewModels/` | Copy | New folder in .NET MAUI project. Need to change namespaces.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Services/` | Copy | Interface to export models. New folder in .NET MAUI
    project. Need to change namespaces. |'
  prefs: []
  type: TYPE_TB
- en: '| `Models/` | Copy | New folder in .NET MAUI project. Need to change namespaces.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.4: Actions in the .NET Standard project'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the .NET MAUI project, please refer to *Table 2.5* to replace the following
    namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Old namespace** | **New namespace** |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `using Xamarin.Forms` | `using Microsoft.Maui AND using Microsoft.Maui.Controls`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `using Xamarin.Forms.Xaml` | `using Microsoft.Maui.Controls.Xaml` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.5: Namespaces in .NET MAUI and Xamarin.Forms'
  prefs: []
  type: TYPE_NORMAL
- en: Test and fix any errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In *Figure 2.15*, we can see the list of files changed in the process:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B21554_02_15.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2.15: Changed files in migration (https://bit.ly/3NlfqvO)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this straightforward case, all the necessary changes relate to the namespace.
    However, real-world situations may not always follow this pattern. Despite the
    simplicity of the process, it can still be somewhat daunting for newcomers to
    .NET MAUI. In fact, you are not required to carry out this process yourself. As
    an alternative, I’ve created a new .NET MAUI project template that you can use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After building and testing this updated app, we’ll be able to view the outcome
    in the screenshot provided in *Figure 2.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_02_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: PassXYZ.Vault with .NET MAUI Shell'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 2.16*, we can see that there are three pages included in the default
    Shell menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '**About:** This is a page that informs users about the app’s functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browse:** This is the entry point of a list of items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logout:** This is the link to the login page where you can log in or log
    out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This boilerplate code will serve as the foundation for the further development
    of our project in this book. To encapsulate the work we’ve done in this section,
    I’ve created a corresponding Visual Studio project template. Utilizing this template
    allows us to generate the desired project structure with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this example merely illustrates the basic migration process. In a
    real-life project, numerous other factors would need to be taken into account,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving resources (font, images, and so on) out of platform folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting Customer Renderer to Handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating dependencies (NuGet packages)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing `DependencyService` to DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above list is just an example. We can only find out all the considerations
    after a detailed analysis of a project.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio project template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project template can be downloaded as a Visual Studio extension package
    from the Visual Studio Marketplace at: [https://marketplace.visualstudio.com/items?itemName=shugaoye.maui](https://marketplace.visualstudio.com/items?itemName=shugaoye.maui).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you go to the above URL, you will see the page shown in *Figure 2.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_02_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Project template in Visual Studio Marketplace'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation of this project template, we can create a new .NET MAUI
    project, as shown in *Figure 2.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A computer screen shot of a computer screen  Description automatically generated](img/B21554_02_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Creating a new .NET MAUI MVVM project'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project created using this template, the project structure is the same
    as the one in this chapter. The source code of this project template can be found
    here: [https://github.com/passxyz/MauiTemplate](https://github.com/passxyz/MauiTemplate).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a new .NET MAUI project. We learned how to configure
    our .NET MAUI app using .NET Generic Host and adjusted the resources configuration
    to utilize a custom font (Font Awesome). We also learned about the .NET MAUI application
    lifecycle and tested the process of subscribing to lifecycle events by overriding
    the `CreateWindow` method and by creating a derived class of the `Window` class.
    To generate boilerplate code with MVVM pattern and Shell support, we created a
    new .NET MAUI project template. This walkthrough served to demonstrate how to
    migrate Xamarin.Forms code to .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will learn how to create a user interface using XAML,
    which can be used to build user interfaces for WPF, UWP, Xamarin.Forms, and .NET
    MAUI. We will continue to create and enhance the user interfaces of our password
    manager app using XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  prefs: []
  type: TYPE_IMG
