<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-45"><a id="_idTextAnchor048"/>3</h1>
<h1 id="_idParaDest-46"><a id="_idTextAnchor049"/>Creating a Breathing App</h1>
<p>So far, we have looked at the SwiftUI fundamentals, some of the modifiers we can use to alter a view in a certain way, and many of the properties that can be animated. Now it’s time to put that knowledge to work and build our first project.</p>
<p>In this chapter, we will build an animation that is similar to the breathing apps that are popular on Apple watches and iPhones. There will be three animations that we will combine to make six circle views move, recreating the slow, rhythmic motions of the Apple app.</p>
<p>There is not a lot of code needed to make this app work; however, as we move through the book, we will build upon this project and gradually ramp up the difficulty.</p>
<p>The steps needed to complete the project are as follows:</p>
<ul>
<li>Setting up the project with Xcode</li>
<li>Adding the variables </li>
<li>Implementing a background color </li>
<li>Adding the circles </li>
<li>Animating the circles</li>
</ul>
<h1 id="_idParaDest-47"><a id="_idTextAnchor050"/>Technical requirements</h1>
<p>You can download the completed project from GitHub in the <code>Chapter 3</code> folder: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor051"/>Setting up the project with Xcode</h1>
<p>Let’s start by <a id="_idIndexMarker218"/>opening Xcode. Then, choose either the <strong class="bold">iOS</strong> option to just build your project on an iPhone or choose <strong class="bold">Multiplatform</strong> if you want to build this project so it runs on an iPhone, iPad, or a Mac. After that, from the list of templates, choose the one called <strong class="bold">App</strong>, and click <strong class="bold">Next</strong>.</p>
<p>Now, give the project a name. I’m calling mine <code>Animating Circles</code>, but you can name it whatever you like. Then, fill out the rest of the details on this page. The two checkboxes can be left unchecked, as we are not using <strong class="bold">Core Data</strong> or <strong class="bold">Tests</strong>. Finally, select a location to save the project. I usually just save them on my desktop.</p>
<p>We are then taken to the Xcode interface; you’ll notice that Xcode automatically imports the SwiftUI framework, so we can get right into our project.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor052"/>Adding the variables</h1>
<p>Our first task is to<a id="_idIndexMarker219"/> add some variables to keep track of the animations. There will be three animations, so in <code>ContentView</code>, we need three boolean variables for them. We need to give them an initial value of <code>false</code>, which will be changed to <code>true</code> when the app first starts up:</p>
<pre class="source-code">
struct ContentView: View {
    //animation bools
    @State var scaleUpDown = false
    @State var rotateInOut = false
    @State var moveInOut = false</pre>
<p>The variables are called <code>scaleUpDown</code>, <code>rotateInOut</code>, and <code>MoveInOut</code>. Usually, when you name your variables, you want to make them as descriptive as possible, so you don’t have to guess what they are used for and can recognize them right away, as we did here.</p>
<p>All the variables are now in place, so let’s move on to looking at the background of our animation.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor053"/>Implementing a background color</h1>
<p>For the <a id="_idIndexMarker220"/>background, we will go into the <code>body</code> computed property. This is where we add our views that will be seen on the screen by the user. The first thing we want to add is a <code>ZStack</code>; this is the main stack that’s going to hold all of the views:</p>
<pre class="source-code">
var body: some View {
      ZStack {
             }
      }</pre>
<p>The reason we use the <code>ZStack</code> versus an <code>HStack</code> or a <code>VStack</code> is we want the views stacked on each other, so they appear as only one view, and later we will animate them separately with different modifiers.</p>
<p>Inside the <code>ZStack</code>, let’s set a black background for the screen by using the <code>.foregroundColor</code> modifier, and specify the color to use; we will use black in this case:</p>
<pre class="source-code">
Rectangle() 
.foregroundColor(Color.black)</pre>
<p>The following figure shows the result of that code:</p>
<div><div><img alt="Figure 3.1: Adding a black background " src="img/B18674_03_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Adding a black background</p>
<p>As you can see, when adding a background in SwiftUI, it will cover most of the iPhone screen, but there is an area on an iPhone that is known as the “safe area.” This is the area reserved for the iPhone notch at the top (the earpiece area) and the very bottom of the phone where the colored background can’t reach.</p>
<p>SwiftUI lets us hide the safe areas by <a id="_idIndexMarker221"/>using the <code>.edgesIgnoringSafeArea</code> modifier, then passing in the value <code>.all</code>, which extends the black color to the edges of the iPhone screen on all sides. To do this, add this line of code just underneath the <code>.fourgroundColor(Color.black)</code> line you previously added:</p>
<pre class="source-code">
.edgesIgnoringSafeArea(.all)</pre>
<p>This produces a completely covered iPhone screen with a black background, as shown here:</p>
<div><div><img alt=" Figure 3.2: Using the .edgesIgnoringSafeArea modifier " src="img/B18674_03_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 3.2: Using the .edgesIgnoringSafeArea modifier</p>
<p>There <a id="_idIndexMarker222"/>are also <code>.vertical</code>, <code>.horizontal</code>, <code>.leading</code>, and <code>.trailing</code> values that you can use to make the <code>.edgesIgnoringSafeArea</code> modifier more specific depending on what part of the device you want to be ignored.</p>
<p>So, we’ve set up the background of our animation. Now it’s time to add the circles.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor054"/>Adding the circles</h1>
<p>Let’s briefly <a id="_idIndexMarker223"/>review the goal of this project. We want to make six circles grow and shrink, and at the same time rotate them, and move them in and out. The six circles will be overlapping each other, which adds a nice look as they will be partially translucent. </p>
<p>To make this work, we need some more ZStacks, and then to place the circles, in pairs, into them. How the circles are aligned in relation to each other can be likened to the numbers on a clock. Going with this clock analogy, we need a <code>ZStack</code> to hold the three pairs: </p>
<ul>
<li>The first pair of circles will be placed in the 12 and 6 o’clock positions</li>
<li>The second pair of circles will be placed in the 2 and 7 o’clock positions</li>
<li>The third pair of circles will be placed in the 10 and 4 o’clock positions</li>
</ul>
<p>Let’s see how to add these three pairs of circles.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor055"/>Adding the first pair of circles</h2>
<p>The first pair of circles<a id="_idIndexMarker224"/> we will add will be placed in the 12 and 6 o’clock positions. The following is the code we need to accomplish that:</p>
<pre class="source-code">
//MARK: - ZStack for the 12 and 6 O'clock circles
            ZStack {
                ZStack {
                    Circle().fill(LinearGradient(gradient:                       Gradient(colors: [.green, .white]),                       startPoint: .top, endPoint: .bottom))
                        .frame(width: 120, height: 120)
                        .offset(y: moveInOut ? -60 : 0)
                    
                    Circle().fill(LinearGradient(gradient:                       Gradient(colors: [.green, .white]),                       startPoint: .bottom, endPoint: .top))
                        .frame(width: 120, height: 120,                           alignment: .center)
                        .offset(y: moveInOut ? 60 : 0)
                }.opacity(0.5)</pre>
<p>This <a id="_idIndexMarker225"/>code creates two circles using the circle shape initializer. Each circle gets a gradient color that makes them lighter toward the center of the screen, and darker in the opposite direction. The gradient works by filling the circles with a smooth transition between two colors. In this case, the gradient goes from green to white. The <code>LinearGradient</code> struct is used to create the gradient, and it takes a <code>gradient</code> parameter, which is an instance of the <code>Gradient</code> struct.</p>
<p>The <code>Gradient</code> struct takes a parameter called <code>colors</code>, which is an array of color values. In this case, the <code>colors</code> parameter is set to <code>[.green, .white]</code>, which means that the gradient will transition from green to white.</p>
<p>The <code>startPoint</code> and <code>endPoint</code> parameters of the <code>LinearGradient</code> struct determine the direction of the gradient. The <code>startPoint</code> parameter is set to <code>.top</code> and the <code>endPoint</code> parameter is set to <code>.bottom</code> for the first circle, which means that the gradient will start at the top of the circle and go toward the bottom. For the second circle, the <code>startPoint</code> parameter is set to <code>.bottom</code> and the <code>endPoint</code> parameter is set to <code>.top</code>, which means that the gradient will start at the bottom of the circle and go toward the top. The look we are going for is a whiter shade of green toward the part of the circles that are just touching each other, and a darker shade of green on the opposite parts of the circles.</p>
<p>All the circles will be of the same size to start out with, which is 120 points for the width and height, and that’s accomplished using the <code>frame</code> modifier. Because we are in a <code>ZStack</code>, the two circles will be stacked on top of each other. If you would like to see both circles now, then change the <code>moveInOut</code> state property to <code>true</code>. The <code>moveInOut</code> property will be changed to true later when we add the <code>onAppear</code> modifier code, but for now, to see how the UI is shaping up, go ahead and change that property to <code>true</code>, and this is what you should see:</p>
<div><div><img alt="Figure 3.3: Twelve and six o’clock circles " src="img/B18674_03_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Twelve and six o’clock circles</p>
<p>Let’s look <a id="_idIndexMarker226"/>at the <code>moveInOut</code> variable now. Remember that I said the naming of our variables should be descriptive and should be related to what they do? Well, the <code>moveInOut</code> variable is an example of that descriptive naming, because it will move the circles in and out of each other. It does this by controlling the vertical offset of the circles that are contained within the <code>ZStack</code>. The ternary operator is responsible for setting the <code>moveInOut</code> value by choosing between two different numbers. </p>
<p>When <code>moveInOut</code> is <code>true</code>, the first circle has a <code>y</code> offset of <code>-60</code>, which moves it upward by 60 points. The second circle has a <code>y</code> offset of <code>60</code>, which moves it downward by 60 points. This results in the two circles moving toward the top and bottom of the <code>ZStack</code> respectively. When <code>moveInOut</code> is <code>false</code>, the first circle has a <code>y</code> offset of <code>0</code>, which keeps it in the center of the <code>ZStack</code>, and the second circle also has a <code>y</code> offset of <code>0</code>, which keeps it in the center of the <code>ZStack</code> as well. This results in the two circles staying in the center, overlaying each other.</p>
<p>Next, by adding<a id="_idIndexMarker227"/> the opacity modifier at the end of the <code>ZStack</code>, both circles are set to a 50% opacity. This makes it easy to see through them and the other circles that we will add, as they overlap each other during the animation, and that also makes for a nice visual as the colors blend together and darken during the overlap.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor056"/>Adding the second pair of circles</h2>
<p>Now, for <a id="_idIndexMarker228"/>the next set of circles, we’re doing almost the exact same thing... almost. Staying with our clock analogy, we need circles at the 2 and 7 o’clock marks. First, I will show you the code, then I will explain the parts that are new:</p>
<pre class="source-code">
//MARK: - ZStack for the 2 and 7 o'clock circles
                ZStack {
                    Circle().fill(LinearGradient(gradient:                       Gradient(colors: [.green, .white]),                       startPoint: .top, endPoint: .bottom))
                        .frame(width: 120, height: 120,                           alignment: .center)
                        .offset(y: moveInOut ? -60 : 0)
                    Circle().fill(LinearGradient(gradient:                       Gradient(colors: [.green, .white]),                       startPoint: .bottom, endPoint: .top))
                        .frame(width: 120, height: 120,                           alignment: .center)
                        .offset(y: moveInOut ? 60 : 0)
                }.opacity(0.5)
                    .rotationEffect(.degrees(60))</pre>
<p>We’re creating<a id="_idIndexMarker229"/> two circles with a gradient of green and white colors, which have the same width and height of 120 points, and they get offset by the animation variable, <code>moveInOut</code>. Again, depending on whether <code>moveInOut</code> is <code>true</code> or <code>false</code> will determine the placement of the circle. If it’s <code>true</code>, the circles will separate, and if <code>false</code>, they will come to the middle with one circle placed over the second circle. Next, we set the opacity of these circles to 50%, as we did with the first set of circles, to make them slightly transparent, so we can see them overlap.</p>
<p>What’s different for this set of circles is that we need to use the <code>rotationEffect</code> modifier on them. This modifier lets us rotate the placement of the circles by passing in a value for the amount of rotation we want. </p>
<p>Notice that this modifier is placed on the end of the <code>ZStack</code> that holds the two circles. This placement will make the entire <code>ZStack</code> and its children rotate, so it saves us some code as we don’t need to place the modifier on both child circles individually.</p>
<p>I’m using a value of <code>60</code> for the <code>.degrees</code> parameter, which will rotate this <code>ZStack</code> 60 degrees from the previous pair of circles. The value of <code>60</code> for the rotation is half of 120, which is the width of each circle, so this rotation will cause the circles to overlap each other by half.</p>
<p>Again, if you want to see how the two pairs of circles look, change the <code>moveInOut</code> property to <code>true</code>, and this is the result:</p>
<div><div><img alt="Figure 3.4: Two and seven o’clock circles " src="img/B18674_03_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Two and seven o’clock circles</p>
<p>Notice that we didn’t <a id="_idIndexMarker230"/>have to rotate the first pair of circles using the <code>rotationEffect</code> modifier; that’s because they’re not overlapping any other circles as they are the first pair on the screen. If we don’t use the <code>rotationEffect</code> modifier here, though, this second pair of circles will be placed exactly over the first pair of circles, and we won’t see them.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor057"/>Adding the third pair of circles</h2>
<p>Finally, for the<a id="_idIndexMarker231"/> last pair of circles on our clock, they need to be placed at the 10 and 4 o’clock marks. Here is the code:</p>
<pre class="source-code">
  //MARK: - ZStack for the 10 and 4 o'clock circles
                ZStack {
                    Circle().fill(LinearGradient(gradient:                       Gradient(colors: [.green, .white]),                       startPoint: .top, endPoint: .bottom))
                        .frame(width: 120, height: 120, alignment: .center)
                        .offset(y: moveInOut ? -60 : 0)
                    Circle().fill(LinearGradient(gradient:                       Gradient(colors: [.green, .white]),                       startPoint: .bottom, endPoint: .top))
                        .frame(width: 120, height: 120,                           alignment: .center)
                        .offset(y: moveInOut ? 60 : 0)
                }.opacity(0.5)
                    .rotationEffect(.degrees(120))</pre>
<p>Looking at this code, we can again see that very little is different from the other sets of circles. We’re adding two circles with a gradient of green and white, and with a size of 120 points. They move in and out 60 points or -60 points on the <code>y</code> axis, as we have seen, but for this pair of circles, we’re rotating them by 120 degrees, which places them at the 10 and 4 o’clock positions and completes the clock of circles. The result is shown here:</p>
<div><div><img alt="Figure 3.5: Ten and four o’clock circles – the complete design " src="img/B18674_03_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: Ten and four o’clock circles – the complete design</p>
<p>Okay, so we’ve <a id="_idIndexMarker232"/>added all of the circles. Now it’s time to add the fun part – the animation – and make them move.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor058"/>Animating the circles</h1>
<p>Now we <a id="_idIndexMarker233"/>have all our circle pairs in place, it’s time to start animating them. I’m going to add the animation code. It may look a bit strange at first, but not to worry, I will explain it line by line:</p>
<pre class="source-code">
            //MARK: - Animations
            .rotationEffect(.degrees(rotateInOut ? 90 : 0))
            .scaleEffect(scaleUpDown ? 1 : 1/4)
            .animation(Animation.easeInOut.              repeatForever(autoreverses: true).speed(1/8),               value: scaleInOut)
            .onAppear() {
                rotateInOut.toggle()
                scaleUpDown.toggle()
                moveInOut.toggle()
            }
        }
    }
}</pre>
<p>The<a id="_idIndexMarker234"/> first line of code calls the <code>rotationEffect</code> modifier. For its <code>.degrees</code> parameter, I’m passing in the <code>rotateInOut</code> variable, which is then checked by a ternary operator. The ternary operator has one of two values to choose from, <code>90</code> or <code>0</code>. If the <code>rotateInOut</code> variable is <code>true</code>, then the <code>rotationEffect</code> modifier will rotate the <code>ZStack</code> that contains all of the pairs of circles by 90 degrees. When <code>rotateInOut</code> is <code>false</code>, the <code>rotationEffect</code> modifier rotates the <code>ZStack</code> back to <code>0</code>. So, all of the circles get rotated at once to either 90 degrees or back to zero, depending on the value that <code>rotateInOut</code> contains.</p>
<p>The next line of code is the scale effect animation. For the <code>scaleEffect</code> modifier, we pass in another ternary operator that has two values to set, either <code>1</code> or <code>1/4</code>. When the <code>scaleUpDown</code> property is <code>true</code>, all the circles will be at full scale, which is reflected by the value <code>1</code>; otherwise, when the <code>scaleUpDown</code> property is <code>false</code>, all the circles will scale down to one-fourth of their size.</p>
<p>The next line of code calls the <code>.animation</code> function. This is the magic function that applies the animation to any view we put it on. We are putting it on the end of the <code>ZStack</code> that contains all of the circles, so when any values change, for example, the variables change from <code>true</code> to <code>false</code> and vice versa, then the new values will be applied to the view, which is the <code>ZStack</code> and its children. Those new values don’t get applied instantly; they are interpolated over, so the animation happens smoothly and fluidly.</p>
<p>I’m using<a id="_idIndexMarker235"/> the <code>easeInEaseOut</code> timing curve type and also adding the <code>.repeatForever</code> modifier, which will keep the animation going for as long as the app is running. And by passing the <code>true</code> value to the <code>autoreverses</code> parameter, the animation reverses itself when it completes its animations in one direction, so it can continue and animate in the opposite direction.</p>
<p>We can also set the speed of the animation. I’m using <code>1/8</code> as the value inside the <code>.speed</code> modifier, for a relatively slow animation. Since this project is similar to the familiar breathing app, I thought a slower animation rather than a faster one would be more appropriate, as the slow pace is helpful when focusing on breathing.</p>
<p>The <code>value</code> parameter requires one of our <code>@State</code> variables so it can monitor it for changes. All of the variables we are using are <code>@State</code>, and they will have their values changed at some point, so any one of them will work fine in this parameter for this code.</p>
<p>The final part of the project is to change the values in each of our variables so the animation can work. Remember we looked at different triggers for animations by using the <code>.onAppear</code> modifier. This will perform an action when the screen or view first appears and then trigger the animation. The action we want to perform as soon as the app starts up is to toggle each of the variables to their opposite states. We gave them initial values of <code>false</code>, but inside <code>onAppear</code>, they get toggled to <code>true</code>, which starts the animation.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you tested out the app earlier and changed the <code>moveInOut</code> variable to <code>true</code>, make sure to set it back to <code>false</code> again, so the animations will get triggered in the <code>onAppear</code> modifier. </p>
<p>And now we have three animations happening simultaneously:</p>
<ul>
<li>The circles are moving in and out from each other. When moving inward, the circles will overlap each other completely, and when moving out, they will separate until their edges are just touching. Again, this animation is monitored by the <code>moveInOut</code> state variable.</li>
<li>The <a id="_idIndexMarker236"/>second animation is scaling the circles by using the <code>scaleEffect</code> modifier. It takes a single parameter, which is a value between <code>0</code> and <code>1</code> that represents the amount of scaling to be applied. In this case, the <code>scaleUpDown</code> variable is being used to control the value passed to the <code>scaleEffect</code> modifier.</li>
<li>The final animation is rotating all of the circles by 90 degrees when <code>rotateInOut</code> is <code>true</code>, and rotating them back to 0 when <code>rotateInOut</code> is <code>false</code>.</li>
</ul>
<p>Run the application and have a play around with it. The following figure shows the sequence the animation will take: </p>
<div><div><img alt="Figure 3.6: Animation sequence " src="img/B18674_03_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Animation sequence</p>
<p>The best way to understand how the different modifiers and functions work is to pass in different values and by experimenting. Always feel free to use your own creativity for everything – for the<a id="_idIndexMarker237"/> parameters, things such as the color of the gradients, the size of the circles, the speed, the location, the amount of rotation, and so on. Changing the parameter values to your liking will give you a better understanding of how each modifier acts on a view.</p>
<p>Later in the book, you will learn how to add sounds and music to a project, as well as how to add buttons and slider controls. When you know how to do that, you can come back to this project and tweak it to incorporate some music, and perhaps a slider to change the speed of the animations. For example, as this is a breathing app, and some people might want to relax by taking deep breaths and holding them for a second or more, you can alter the animation to pause for any amount of time to signify the holding of one’s breath, all done through the use of various controls that you will learn about in upcoming projects.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor059"/>Summary</h1>
<p>Great job on the completion of this first project! By creating a breathing app, you’ve got to explore how to rotate, scale, and move a view to another location, all by using SwiftUI’s intuitive modifiers and design tools. We also used a special modifier that does a lot of the work in the background for us, the <code>.animation</code> modifier, which interpolates over values after we define a start and end point, and creates a smooth seamless animation from those values.</p>
<p>In the next chapter, we will continue our journey into animation and build a record player. This project will look at how to animate a view around one of its anchor points, rather than from the center, as well as adding sound and a button to start the animation.</p>
</div>
<div><div></div>
</div>
</body></html>