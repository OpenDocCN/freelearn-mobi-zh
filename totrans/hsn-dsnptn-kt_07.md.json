["```kt\ncompile \"io.reactivex.rxjava2:rxjava:2.1.14\"\n```", "```kt\nval publisher = Observable.fromArray(5, 6, 7)\n```", "```kt\npublisher.subscribe {\n    println(it)\n} // Prints 1, 2, 3\n```", "```kt\npublisher.filter {\n    it > 5\n}.map {\n    it + it\n}.subscribe {\n    println(it)\n}\n```", "```kt\nval publisher = Observable.interval(1, TimeUnit.SECONDS)\n\npublisher.subscribe {\n    println(\"P1 $it\")\n}\n\npublisher.subscribe {\n    println(\"P2 $it\")\n}\n\nThread.sleep(TimeUnit.SECONDS.toMillis(5))\n```", "```kt\nSleeping <= This was the last line in our code, actually\nP2 0     <= P2 came after P1 in code, but it comes before now\nP1 0\nP2 1\nP1 1\nP2 2\nP1 2\n```", "```kt\n...\nval subscription = publisher.subscribe {\n    println(\"P2 $it\")\n}\n\nprintln(\"Sleeping\")\nThread.sleep(TimeUnit.SECONDS.toMillis(2))\nsubscription.dispose()\n...\n```", "```kt\nSleeping\nP1 0        <= Notice that P1 is the first one now\nP2 0\nP1 1\nSleeping    <= This is after dispose/unsubscribe\nP2 1        <= But it may still take some time, so P2 prints again\nP1 2 \nP1 3\nP1 4        <= No more prints from P2, it unsubscribed\n```", "```kt\nval o = Observable.create<Int> {\n    for (i in 1..10_000) {\n        it.onNext(i)\n    }\n    it.onComplete()\n}\n```", "```kt\nval o = Observable.create<Int> {\n    it.onError(RuntimeException())\n}\n\no.subscribe {\n    println(\"All went good: $it\")\n} // OnErrorNotImplementedException\n```", "```kt\no.subscribe({\n    println(\"All went good: $it\")\n}, {\n    println(\"There was an error $it\")\n})\n```", "```kt\no.subscribe({\n    println(\"All went good: $it\")\n}, {\n    println(\"There was an error $it\")\n}, {\n    println(\"Publisher closed the stream\")\n})\n```", "```kt\npublisher.subscribe {\n    println(\"S1 $it\")\n} // Prints 10K times\n\npublisher.subscribe {\n    println(\"S2 $it\")\n} // Also prints 10K times\n```", "```kt\nval iterator = (1..10).iterator()\n\nval publisher = Observable.create<Int> {\n    while (iterator.hasNext()) {\n        val nextNumber = iterator.next()\n        it.onNext(nextNumber)\n    }\n}\n```", "```kt\npublisher.subscribeOn(Schedulers.newThread()).subscribe {\n    println(\"S1: $it\")\n    Thread.sleep(10)\n}\n\nThread.sleep(50)\n\npublisher.subscribeOn(Schedulers.newThread()).subscribe {\n    println(\"S2: $it\")\n    Thread.sleep(10)\n}\n\nThread.sleep(50)\n```", "```kt\nS1: 1\nS1: 2\nS1: 3\nS1: 4\nS1: 5\nS2: 6 <= That's where \"Subscriber 2\" begins listening\nS1: 7\nS2: 8\nS1: 9\nS2: 10\n```", "```kt\nval iterator = (1..5).iterator()\nval subject = Observable.create<Int> {\n    while (iterator.hasNext()) {\n        val number = iterator.nextInt()\n        println(\"P: $number\")\n        it.onNext(number)\n        Thread.sleep(10)\n    }\n}.observeOn(Schedulers.newThread()).publish()\n```", "```kt\nthread { // Connect is blocking, so we run in on another thread\n    subject.connect() // Tells observer when to start\n}\n```", "```kt\nThread.sleep(10)\nprintln(\"S1 Subscribes\")\nsubject.subscribeOn(Schedulers.newThread()).subscribe {\n    println(\"S1: $it\")\n    Thread.sleep(100)\n}\n\n```", "```kt\nThread.sleep(20)\n\nprintln(\"S2 Subscribes\")\nsubject.subscribeOn(Schedulers.newThread()).subscribe {\n    println(\"S2: $it\")\n    Thread.sleep(100)\n}\nThread.sleep(2000)\n```", "```kt\nP: 1 *<= Publisher starts publishing even before someone subscribes*\n*S1 Subscribes*\nP: 2\nP: 3\nS1: 3 *<= Subscriber actually missed some values*\n*S2 Subscribes*\nP: 4\nP: 5\nP: 6 *<= Publisher completes here*\nS1: 4\nS2: 4 \nS1: 5\nS2: 5 *<= Both subscribers receive same values*\n```", "```kt\n// This is a connectable Observable\nval connectableSource = Observable.fromIterable((1..3)).publish()\n\n// Should call connect() on it\ndataSource.connect()\n\n// This is regular Observable which wraps ConnectableObservable\nval regularSource = connectableSource.refCount()\n\nregularSource.connect() // Doesn't compile\n```", "```kt\nval regularSource = Observable.fromIterable((1..3)).publish().refCount()\n\nval stillRegular = Observable.fromIterable((1..3)).share()\n```", "```kt\nval dataSource = Observable.fromIterable((1..3))\n\nval multicast = PublishSubject.create<Int>()\n\nmulticast.subscribe {\n    println(\"S1 $it\")\n}\n\nmulticast.subscribe {\n    println(\"S2 $it\")\n}\n\ndataSource.subscribe(multicast)\n\nThread.sleep(1000)\n```", "```kt\nS1 1\nS2 1\nS1 2\nS2 2\nS1 3\nS2 3\n```", "```kt\nval dataSource = Observable.fromIterable((1..3)).publish()\n\nval multicast = PublishSubject.create<Int>()\n\ndataSource.subscribe(multicast)\n\nmulticast.subscribe {\n    println(\"S1 $it\")\n}\nprintln(\"S1 subscribed\")\n\nmulticast.subscribe {\n    println(\"S2 $it\")\n}\nprintln(\"S2 subscribed\")\n\ndataSource.connect()\n\nThread.sleep(1000)\n```", "```kt\nval list = (8..23).toList() // Some non trivial numbers\nval iterator = list.iterator()\nval o = Observable.intervalRange(0, list.size.toLong(), 0, 10, TimeUnit.MILLISECONDS).map {\n    iterator.next()\n}.publish()\n\nval subject = PublishSubject.create<Int>()\n\no.subscribe(subject)\n\no.connect() // Start publishing\n\nThread.sleep(20)\n\nprintln(\"S1 subscribes\")\n    subject.subscribe {\n        println(\"S1 $it\")\n    }\n    println(\"S1 subscribed\")\n\n    Thread.sleep(10)\n\n    println(\"S2 subscribes\")\n    subject.subscribe {\n        println(\"S2 $it\")\n    }\n    println(\"S2 subscribed\")\n\n    Thread.sleep(1000)\n```", "```kt\nS1 11 <= Lost 8, 9, 10\nS1 12\nS2 12 <= Lost also 11\nS1 13\nS2 13\n...\n```", "```kt\nval subject = ReplaySubject.create<Int>()\n```", "```kt\nS1 subscribes\nS1 8\nS1 9\nS1 10 <= S1 catchup \nS1 subscribed\nS1 11\nS1 12\nS2 subscribes\nS2 8\nS2 9\nS2 10\nS2 11\nS2 12 <= S2 catchup \nS2 subscribed\nS1 13 <= Regular multicast from here\nS2 13\n...\n```", "```kt\nval subject = ReplaySubject.createWithSize<Int>(2)\n```", "```kt\nS1 subscribes\nS1 9 <= lost 8\nS1 10\nS1 subscribed\nS1 11\nS2 subscribes\nS1 12\nS2 11 <= lost 8, 9, 10\nS2 12\nS2 subscribed\nS1 13\nS2 13\n...\n```", "```kt\nval subject = BehaviorSubject.create<Int>()\n```", "```kt\nS1 subscribes\nS1 10 <= This was the most recent value, 8 and 9 are lost\nS1 subscribed\nS1 11 <= First update \nS2 subscribes\nS2 11 <= This was most recent value, 8, 9 and 10 lost\nS2 subscribed\nS1 12 <= As usual from here\nS2 12 \n```", "```kt\nval subject = AsyncSubject.create<Int>()\n```", "```kt\nS1 subscribes\nS1 subscribed\nS2 subscribes\nS2 subscribed\nS1 23 <= This is the final value\nS2 23\n```", "```kt\n// Infinite sequence of 1\nval o = Observable.generate<Int> { 1 }.publish()\n...\no.connect() // Hangs here forever\n```", "```kt\nval subject = ReplaySubject.createWithSize<Int>(2).toSerialized()\n```", "```kt\nval source = Observable.create<String> {\n    var startProducing = System.currentTimeMillis()\n    for (i in 1..10_000_000) {\n        it.onNext(UUID.randomUUID().toString())\n\n        if (i % 100_000 == 0) {\n            println(\"Produced $i events in ${System.currentTimeMillis() - startProducing}ms\")\n            startProducing = System.currentTimeMillis()\n        }\n    }\n    latch.countDown()\n}\n```", "```kt\nval counter = AtomicInteger(0)\nsource.observeOn(Schedulers.newThread())\n        .subscribe( {\n            it.repeat(500)\n            if (counter.incrementAndGet() % 100_000 == 0) {\n                println(\"Consumed ${counter.get()} events\")\n            }\n        }, {\n            println(it)\n        })\n```", "```kt\nProduced 100000 events in 1116ms\nProduced 200000 events in 595ms\nProduced 300000 events in 734ms\nConsumed 100000 events\nProduced 400000 events in 815ms\nProduced 500000 events in 705ms\nConsumed 200000 events\nProduced 600000 events in 537ms\nProduced 700000 events in 390ms\nProduced 800000 events in 529ms\nProduced 900000 events in 387ms\nConsumed 300000 events\nProduced 1000000 events in 531ms\nProduced 1100000 events in 537ms\nProduced 1200000 events in 11241ms <= What happens here?\nConsumed 400000 events\nProduced 1300000 events in 19472ms\nProduced 1400000 events in 31993ms\nProduced 1500000 events in 52650ms\n```", "```kt\nval source = Flowable.create<String> ({\n    var startProducing = System.currentTimeMillis()\n    for (i in 1..10_000_000) {\n        it.onNext(UUID.randomUUID().toString())\n\n        if (i % 100_000 == 0) {\n            println(\"Produced $i events in ${System.currentTimeMillis() - startProducing}ms\")\n            startProducing = System.currentTimeMillis()\n        }\n    }\n    it.onComplete()\n    latch.countDown()\n}, BackpressureStrategy.DROP)\n```", "```kt\n...\nProduced 9500000 events in 375ms\nProduced 9600000 events in 344ms\nProduced 9700000 events in 344ms\nConsumed 2800000 events\nProduced 9800000 events in 351ms\nProduced 9900000 events in 333ms\nProduced 10000000 events in 340ms\n```", "```kt\nsource.observeOn(Schedulers.newThread())\n        .subscribe(object : Subscriber<String> {\n    lateinit var subscription: Subscription\n\n    override fun onSubscribe(s: Subscription?) {\n        s?.let {\n            this.subscription = it\n        } ?: throw RuntimeException()\n    }\n\n    override fun onNext(t: String?) {\n        ...\n    }\n\n    override fun onError(t: Throwable?) {\n        ...\n    }\n\n    override fun onComplete() {\n        ...\n    }\n})\n```", "```kt\noverride fun onNext(t: String?) {\n    println(t)\n}\n```", "```kt\noverride fun onSubscribe(s: Subscription) {\n    this.subscription = s\n    this.subscription.request(100)\n}\n```", "```kt\nval source = Flowable.create<String> ({\n    ...\n}, BackpressureStrategy.MISSING)\n```", "```kt\noverride fun onNext(t: String) {\n    t.repeat(500) // Do something\n\n    println(counter.get()) // Print index of this item\n    this.subscription.request(1) // Request next\n\n    if (counter.incrementAndGet() % 100_000 == 0) {\n        println(\"Consumed ${counter.get()} events\")\n    }\n}\n```", "```kt\nval source = Flowable.create<String> ({\n    ...\n}, BackpressureStrategy.MISSING).onBackpressureBuffer(10_000)\n```", "```kt\nval count = AtomicInteger(0)\n// This is not entirely correct, but simplifies our code\nval startTime = System.currentTimeMillis()\nval source = Flowable.generate<String> {\n        it.onNext(UUID.randomUUID().toString())\n\n        if (count.incrementAndGet() == 10_000_000) {\n            it.onComplete()\n            latch.countDown()\n        }\n\n        if (count.get() % 100_000 == 0) {\n            println(\"Produced ${count.get()} events in ${System.currentTimeMillis() - startTime}ms\")\n            startTime = System.currentTimeMillis()\n        }\n    }\n```", "```kt\nProduced 100000 events in 3650ms\nProduced 200000 events in 1942ms\nProduced 300000 events in 1583ms\nProduced 400000 events in 1630ms\n...\n```", "```kt\n<T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator)\n```", "```kt\ndata class State(val count: Int, val startTime: Long)\n```", "```kt\nval source = Flowable.generate<String, State>(\n    Callable<State> { State(0, System.currentTimeMillis()) },\n    BiFunction<State, Emitter<String>, State> { state, emitter ->\n        emitter.onNext(UUID.randomUUID().toString())\n\n        // In other cases you could use destructuring\n        val count = state.count + 1\n        var startTime = state.startTime\n        if (count == 10_000_000) {\n            emitter.onComplete()\n            latch.countDown()\n        }\n\n        if (count % 100_000 == 0) {\n            println(\"Produced ${count} events in ${System.currentTimeMillis() - startTime}ms\")\n            startTime = System.currentTimeMillis()\n        }\n\n        // Return next state\n        State(count, startTime)\n    }\n)\n```", "```kt\nval list = (8..23).toList() // Some non trivial numbers\nval iterator = list.iterator()\nval o = Observable.intervalRange(0, list.size.toLong(), 0, 10, TimeUnit.MILLISECONDS).map {\n    iterator.next()\n}.toFlowable(BackpressureStrategy.DROP).publish()\n```", "```kt\nval processor = ReplayProcessor.createWithSize<Int>(2)\n```", "```kt\no.subscribe(processor)\n\no.connect() // Start publishing\n\nThread.sleep(20)\n\nprintln(\"S1 subscribes\")\nprocessor.subscribe {\n    println(\"S1 $it\")\n}\nprintln(\"S1 subscribed\")\n\nThread.sleep(10)\n\nprintln(\"S2 subscribes\")\nprocessor.subscribe {\n    println(\"S2 $it\")\n}\nprintln(\"S2 subscribed\")\n\nThread.sleep(1000)\n```", "```kt\nS1 subscribes\nS1 9\nS1 10\nS1 subscribed\nS1 11\nS2 subscribes\nS2 10\nS2 11\nS2 subscribed\nS1 12\nS2 12\n```", "```kt\nval latch = CountDownLatch(1)\nval o = Observable.intervalRange(8L, 15L, 0L, 100L, TimeUnit.MILLISECONDS)\n\no.buffer(3).subscribe({\n    println(it)\n}, {}, { latch.countDown()})\n\nlatch.await()\n```", "```kt\n[8, 9, 10]\n[11, 12, 13]\n[14, 15, 16]\n[17, 18, 19]\n[20, 21, 22]\n```", "```kt\nval latch = CountDownLatch(1)\nval o = Observable.intervalRange(8L, 15L, 0L, 100L, TimeUnit.MILLISECONDS)\n\no.buffer(300L, TimeUnit.MILLISECONDS).subscribe ({\n    println(it)\n}, {}, { latch.countDown() })\n\nlatch.await()\n```", "```kt\n[8, 9, 10, 11]\n[12, 13, 14]\n[15, 16, 17]\n[18, 19, 20]\n[21, 22]\n```", "```kt\nval latch = CountDownLatch(1)\nval o = Observable.intervalRange(8L, 15L, 0L, 100L, TimeUnit.MILLISECONDS)\n\no.buffer(Observable.interval(200L, TimeUnit.MILLISECONDS)).subscribe ({\n    println(it)\n}, {}, { latch.countDown() })\n\nlatch.await()\n```", "```kt\n[8, 9, 10]\n[11, 12]\n[13, 14]\n[15, 16]\n[17, 18]\n[19, 20]\n[21, 22]\n[]\n```", "```kt\nval o = PublishSubject.intervalRange(8L, 15L, 0L, 100L, TimeUnit.MILLISECONDS).publish()\n\no.throttleFirst(280L, TimeUnit.MILLISECONDS).subscribe {\n    println(it)\n}\n\no.buffer(280L,  TimeUnit.MILLISECONDS).subscribe {\n    println(it)\n}\n\no.connect()\n\nThread.sleep(100 * 15)\n```", "```kt\n8\n[8, 9, 10]\n11\n[11, 12, 13]\n14\n[14, 15, 16]\n17\n[17, 18, 19]\n20\n[20, 21]\n[22]\n```", "```kt\nval o = Observable.intervalRange(8L, 15L, 5L, 100L, TimeUnit.MILLISECONDS)\n\no.throttleLast(280L, TimeUnit.MILLISECONDS).subscribe {\n    println(it)\n}\n\no.buffer(280L,  TimeUnit.MILLISECONDS).subscribe {\n    println(it)\n}\n\nThread.sleep(100 * 30)\n```", "```kt\n10\n[8, 9, 10]\n13\n[11, 12, 13]\n16\n[14, 15, 16]\n19\n[17, 18, 19]\n21\n[20, 21]\n[22]\n```"]