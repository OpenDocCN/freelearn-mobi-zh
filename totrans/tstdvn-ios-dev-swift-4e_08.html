<html><head></head><body>
		<div><h1 id="_idParaDest-96"><em class="italic"><a id="_idTextAnchor165"/>Chapter 6</em>: Testing, Loading, and Saving Data</h1>
			<p>At the moment, we have structures to hold the information of one to-do item. A usable to-do item app has to show and manage several to-do items. In addition, when the user closes the app and opens it again, they expect the to-do items to still be there.</p>
			<p>This means our app needs structures that can store and load information of a list of to-do items.</p>
			<p>In this chapter, we will add a class that stores and loads a list of to-do items to and from the filesystem of the iOS device. We will use the JSON format because it is a common choice in iOS development. It has the nice benefit in that it is easily readable by humans and computers.</p>
			<p>The chapter is structured as follows:</p>
			<ul>
				<li>Publishing changes with Combine</li>
				<li>Checking items</li>
				<li>Storing and loading <code>ToDoItem</code></li>
			</ul>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor166"/>Technical requirements </h1>
			<p>The source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter06">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter06</a>. </p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor167"/>Publishing changes with Combine</h1>
			<p>In today's iOS apps, communication between different parts is often implemented using the <strong class="bold">Combine</strong> framework <a id="_idIndexMarker152"/>by Apple. In Combine, data changes are published and can be subscribed to. This design pattern helps to decouple the code and make it easier to maintain.</p>
			<p>We will use <a id="_idIndexMarker153"/>Combine in our <code>ToDoItemStore</code> to inform, for example, the table view controller that something changed <a id="_idIndexMarker154"/>and the user interface should be updated with the new data.</p>
			<p>Open Project Navigator and select the <code>ToDoItemStoreTests</code>. Import the <code>ToDo</code> module (<code>@testable import ToDo</code>) and remove the two test method templates.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor168"/>Testing asynchronous Combine code</h2>
			<p>Up to now, all <a id="_idIndexMarker155"/>the code we've tested has been synchronous code. Publishing values in Combine is asynchronous. To be able to test Combine code, we need a way to halt the test and wait until the code we want to test is executed. <code>XCTest</code> provides <code>XCTestExpectation</code> for this task. Let's see how this works:</p>
			<ol>
				<li>Add the following code to <code>ToDoItemStoreTests</code>:<pre>// ToDoItemStoreTests.swift
func test_add_shouldPublishChange() {
  let sut = ToDoItemStore()
}</pre></li>
			</ol>
			<p>The <code>toDoItemStore</code>, but using <code>sut</code> makes it easier to read, and it also allows us to copy and paste test code into other tests when appropriate.</p>
			<ol>
				<li value="2">The test is not yet finished, but it already fails because Xcode cannot find <code>ToDoItemStore</code> in the scope. Open Project Navigator again and select the <code>ToDoItemStore.swift</code>. Add the following class definition to <code>ToDoItemStore.swift</code>:<pre>// ToDoItemStore.swift
class ToDoItemStore {
}</pre></li>
			</ol>
			<p>This is enough to make the test code compilable. </p>
			<ol>
				<li value="3">Run the <a id="_idIndexMarker157"/>tests to make sure that they all pass and we can continue writing tests. Add the following code to <code>test_add_shouldPublishChange()</code>:<pre>// ToDoItemStoreTests.swift
func test_add_shouldPublishChange() {
  let sut = ToDoItemStore()
  let publisherExpectation = expectation(
    description: "Wait for publisher in \(#file)"
  )
  var receivedItems: [ToDoItem] = []
  let token = sut.itemPublisher
}</pre></li>
			</ol>
			<p>First, we create an instance of <code>ToDoItemStore</code>. Next, we need an expectation to wait for the asynchronous execution of our Combine code. With <code>description</code>, we inform our future selves why we need this expectation. To figure out whether <code>publisher</code> worked as expected, we need to subscribe to it in the test and check the published value. We will store the value in the <code>receivedItems</code> variable.</p>
			<p>The last line is the beginning of the subscription to the publisher, but we have to pause before writing the rest because Xcode complains that <strong class="bold">Value of type 'ToDoItemStore' has no member 'itemPublisher'</strong>. This means we need to write some code in the main target to make the test compile again. </p>
			<ol>
				<li value="4">First, we need to import the Combine framework. Then, we can add the publisher, like this:<pre>// ToDoItemStore.swift
import Foundation
import Combine
 
class ToDoItemStore {
  var itemPublisher =
    CurrentValueSubject&lt;[ToDoItem], Never&gt;([])
}</pre></li>
			</ol>
			<p>If you <a id="_idIndexMarker158"/>haven't worked with Combine or Generics yet, this syntax might look a bit strange. <code>[ToDoItem]</code> in <code>&lt;[ToDoItem], Never&gt;</code> means that the publisher sends arrays of <code>ToDoItems</code>. The second part, <code>Never</code>, is the failure type of this publisher. <code>Never</code> means that this publisher cannot fail. In summary, <code>CurrentValueSubject&lt;[ToDoItem], Never&gt;([])</code> creates an instance of a <code>CurrentValueSubject</code> publisher that sends arrays of <code>ToDoItems</code> that never fail.</p>
			<p>This fixes the error reported by the static analyzer. We can switch back to the test code. </p>
			<ol>
				<li value="5">Import Combine below the existing import statements and change the code in <code>test_add_shouldPublishChange()</code> so that it looks like this:<pre>// ToDoItemStoreTests.swift
import Combine
// ...
func test_add_shouldPublishChange() {
  let sut = ToDoItemStore()
  let publisherExpectation = expectation(
    description: "Wait for publisher in \(#file)"
  )
  var receivedItems: [ToDoItem] = []
  let token = sut.itemPublisher
    .dropFirst()
    .sink { items in
      receivedItems = items
      publisherExpectation.fulfill()
    }
  let toDoItem = ToDoItem(title: "Dummy")
  sut.add(toDoItem)
}</pre></li>
			</ol>
			<p>This does <a id="_idIndexMarker159"/>not compile. But before we switch back to the production code, let's see what we added here:</p>
			<ul>
				<li>First, we drop the first published value from <code>itemPublisher</code> using <code>dropFirst()</code>. We do this because a <code>CurrentValueSubject</code> publisher publishes the first current value as soon as we subscribe to it. But in the test, we only want to assert that the changes have been published.</li>
				<li>Next, we subscribe to the publisher using <code>sink(receiveValue:)</code>. The published value is passed into the <code>receivedValue</code> parameter. You can't see the parameter name in the code because we are using the trailing closure syntax as it is common in iOS development. We store the received value into the <code>receivedItems</code> variable. At this point, the asynchronous code we waited for in the test is finished. We tell the test runner that we don't need to wait any further by calling <code>fulfill()</code> on the expectation.</li>
				<li>The last two lines in this code are the execution of the method we want to test. We assume here that <code>ToDoItemStore</code> has an <code>add(_:)</code> method that allows us to add to-do items to the item store. As we haven't written this method yet, Xcode is complaining and we have to switch back to the production code. Follow the next step for that.</li>
			</ul>
			<ol>
				<li value="6">Add <a id="_idIndexMarker160"/>the following code to <code>ToDoItemStore</code>:<pre>// ToDoItemStore.swift
func add(_ item: ToDoItem) {
}</pre></li>
			</ol>
			<p>This makes the test compilable again. </p>
			<ol>
				<li value="7">Switch back to the test code and add the last three lines in the following code to <code>test_add_shouldPublishChange()</code>:<pre>// ToDoItemStoreTests.swift
func test_add_shouldPublishChange() {
  // ... arrange ...
  let toDoItem = ToDoItem(title: "Dummy")
  sut.add(toDoItem)
  wait(for: [publisherExpectation], timeout: 1)
  token.cancel()
  XCTAssertEqual(receivedItems.first?.title,
    toDoItem.title)
}</pre></li>
			</ol>
			<p>With <code>wait(for:timeout:)</code>, we tell the test runner to wait at this point until all expectations in the <code>first</code> parameter are fulfilled. If all the expectations are not fulfilled after the timeout has passed, the test fails. Next, we cancel the publisher. If we omitted this line, the compiler could remove the subscription because it looks like it is not used anywhere in the code. In the last line, we compare the received value with what we expect.</p>
			<p>Finally, we <a id="_idIndexMarker161"/>can run the test. As expected, the test we just added fails because the publisher hasn't published anything yet.</p>
			<p>We would like to use the assertion like this: <code>XCTAssertEqual(receivedItems, [toDoItem])</code>. But this is not possible at the moment because <code>ToDoItem</code> does not conform to the <code>Equatable</code> protocol, which tells the compiler how to treat equality between two instances. We will fix that soon. But first, we need to make the tests green again.</p>
			<ol>
				<li value="8">Change the code in <code>ToDoItemStore</code> so that it looks like this:<pre>// ToDoItemStore.swift
class ToDoItemStore {
  var itemPublisher =
    CurrentValueSubject&lt;[ToDoItem], Never&gt;([])
  private var items: [ToDoItem] = [] {
    didSet {
      itemPublisher.send(items)
    }
  }
 
  func add(_ item: ToDoItem) {
    items.append(item)
  }
}</pre></li>
			</ol>
			<p>With <a id="_idIndexMarker162"/>this code, we added a <code>private</code> property to hold the to-do items in the item store. Whenever this property changes (for example, when a new item is added), it is published using the item publisher. As a result, in the <code>add(_:)</code> method, we only have to append the item to the items list.</p>
			<ol>
				<li value="9">Run the tests. All tests pass.</li>
			</ol>
			<p>Now let's tackle the problem of <code>ToDoItem</code> not being equatable.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor169"/>Making ToDoItem equatable</h2>
			<p>The step <a id="_idIndexMarker163"/>of making <code>ToDoItem</code> equatable is a refactoring step. Up to this point, the code worked without <code>ToDoItem</code> being equatable. But the <a id="_idIndexMarker164"/>readability of the test would greatly benefit if we could use <code>XCTAssertEqual</code> directly on an array of <code>ToDoItems</code>. The following steps show you how to do that:</p>
			<ol>
				<li value="1">First, add the <code>Equatable</code> protocol to the declaration of <code>ToDoItem</code>, like this:<pre>// ToDoItem.swift
struct ToDoItem: Equatable {
  // ...
}</pre></li>
				<li>Next, do <a id="_idIndexMarker165"/>the same for the <code>Location</code> structure:<pre>// Location.swift
struct Location: Equatable {
  // …
}</pre></li>
				<li>Next, add <a id="_idIndexMarker166"/>the following method to the <code>Location</code> struct:<pre>// Location.swift
static func == (lhs: Location, rhs: Location) -&gt; Bool {
  if lhs.name != rhs.name {
    return false
  }
  if lhs.coordinate == nil, rhs.coordinate != nil {
    return false
  }
  if lhs.coordinate != nil, rhs.coordinate == nil {
    return false
  }
  if let lhsCoordinate = lhs.coordinate,
      let rhsCoordinate = rhs.coordinate {
    if abs(lhsCoordinate.longitude -
      rhsCoordinate.longitude) &gt; 0.000_000_1 {
      return false
    }
    if abs(lhsCoordinate.latitude -
      rhsCoordinate.latitude) &gt; 0.000_000_1 {
      return false
    }
  }
  return true
}</pre></li>
			</ol>
			<p>If Swift cannot automatically add <code>Equatable</code> conformance (for example, because one of the <a id="_idIndexMarker167"/>properties isn't <code>Equatable</code> itself), we need to add the <code>== (lhs:rhs:)</code> class method. The method looks a bit complicated but this is <a id="_idIndexMarker168"/>just because the <code>coordinate</code> property is optional. So, we also have to respect the cases when one coordinate is nil and the other isn't.</p>
			<ol>
				<li value="4">Now, go back to <code>test_add_shouldPublishChange()</code> and replace the assertion call at the end with this:<pre>// ToDoItemStoreTests.swift
XCTAssertEqual(receivedItems, [toDoItem])</pre></li>
			</ol>
			<p>Run the tests. All tests pass. The assertion now looks way better and we assert exactly what we expect from the test. But the test is still hard to read. All that Combine code is distracting from the main objective of the test. </p>
			<p>Let's add a helper function to the test case to improve the test code:</p>
			<ol>
				<li value="1">The helper function we are going to add is inspired by a blog post (<a href="https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/">https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/</a>) by <em class="italic">John Sundell</em>. Add the following code at the end of <code>ToDoItemStoreTests.swift</code> but outside of the <code>ToDoItemStoreTests</code> class:<pre>// ToDoItemStoreTests.swift
extension XCTestCase {
  func wait&lt;T: Publisher&gt;(
    for publisher: T,
    afterChange change: () -&gt; Void) throws
  -&gt; T.Output where T.Failure == Never { 
    let publisherExpectation = expectation(
      description: "Wait for publisher in \(#file)"
    )
    var result: T.Output?
    let token = publisher
      .dropFirst()
      .sink { value in
        result = value
        publisherExpectation.fulfill()
      }
 
    change()
    wait(for: [publisherExpectation], timeout: 1)
    token.cancel() 
    let unwrappedResult = try XCTUnwrap(
      result,
      "Publisher did not publish any value"
    ) 
    return unwrappedResult
  }
}</pre></li>
			</ol>
			<p>This code is similar to the code we wrote in <code>test_add_shouldPublishChange()</code>. It is modified a bit to make it work as an extension of <code>XCTestCase</code>. </p>
			<ol>
				<li value="2">Now, we <a id="_idIndexMarker169"/>can replace the test code with the following:<pre>// ToDoItemStoreTests.swift
func test_add_shouldPublishChange() throws {
  let sut = ToDoItemStore()
  let toDoItem = ToDoItem(title: "Dummy")
  let receivedItems = try wait(for: sut.itemPublisher)
 {
    sut.add(toDoItem)
  }
  XCTAssertEqual(receivedItems, [toDoItem])
}</pre></li>
			</ol>
			<p>This change <a id="_idIndexMarker170"/>makes the test easy to understand. Run the tests again. All tests still pass.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>wait</code> method <a id="_idIndexMarker171"/>we just added to <code>XCTestCase</code> can throw an error. As a result, we had to add the <code>try</code> keyword to the call of this method. We could wrap the call in a <code>do-catch</code> block but there is a better way. When we mark the test method itself as <code>throws</code>, an error thrown during the test invocation is registered by the test runner as a test failure. This again makes the test easier to read and understand. During the course of this book, we will always use this feature of <code>XCTest</code> instead of writing <code>do-catch</code> blocks in test methods.</p>
			<ol>
				<li value="3">But how do we know that we didn't break the test? Let's make sure that the test can still fail. Go to <code>ToDoItemStore</code> and remove the <code>items.append(item)</code> line from <code>add(_:)</code>. Run the tests to make sure that the test we changed fails now.</li>
				<li>But something <a id="_idIndexMarker172"/>is strange now. The test failure is <a id="_idIndexMarker173"/>shown as gray instead of red. The reason is that the failure is in the <code>wait</code> function we added to <code>XCTestCase</code>. To make the test failure be reported at the call site of that function, we need to change the function to this (we only show the relevant lines here):<pre>// ToDoItemStoreTests.swift
extension XCTestCase {
  func wait&lt;T: Publisher&gt;(
    for publisher: T,
    afterChange change: () -&gt; Void,
    file: StaticString = #file,
    line: Uint = #line) throws
  -&gt; T.Output where T.Failure == Never {
 
    // …
    let unwrappedResult = try XCTUnwrap(
      result,
      "Publisher did not publish any value",
      file: file,
      line: line
    ) 
    return unwrappedResult
  }
}</pre></li>
			</ol>
			<p>The function now has two more parameters, <code>file</code> and <code>line</code>. They are set to the <a id="_idIndexMarker174"/>default values, <code>#file</code> and <code>#line</code>, respectively. These parameters are then used in the call to <code>XCTUnwrap</code>. When <code>XCTUnwrap</code> now fails, Xcode uses the <code>file</code> and <code>line</code> parameters to figure out <a id="_idIndexMarker175"/>where this function was called and reports the failure at the call site. Run the tests again to see the difference.</p>
			<ol>
				<li value="5">Then, make the test pass again by adding the line you deleted.</li>
			</ol>
			<p>In the next section, we will implement an essential feature for a to-do list app: <em class="italic">checking items</em>.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor170"/>Checking items</h1>
			<p>In a to-do app, the user needs to be able to mark to-do items as done. This is an important <a id="_idIndexMarker176"/>feature of a to-do app because part of the reason people use such apps is the satisfying feeling when marking a to-do as done.</p>
			<p>So, our app also needs this feature. As the process of building this app is driven by tests, we start with a new test for this feature. But before we can add the test for this feature, we need to think about how we can assert in the test that the feature works. This means we need a way to get all the to-do items that are already done. The easiest way to differentiate the done to-do items from the ones that are still to be done is with a property in the to-do item itself. This way, we can filter all the to-do items according to the value of that property.</p>
			<p>With this plan, we can start writing the test: </p>
			<ol>
				<li value="1">Add the following method to <code>ToDoItemStoreTests.swift</code>:<pre>// ToDoItemStoreTests.swift
func test_check_shouldPublishChangeInDoneItems()
 throws {
  let sut = ToDoItemStore()
  let toDoItem = ToDoItem(title: "Dummy")
  sut.add(toDoItem)
  sut.add(ToDoItem(title: "Dummy 2"))
  let receivedItems = try wait(for: sut.itemPublisher) {
    sut.check(toDoItem)
  }
}</pre></li>
			</ol>
			<p>In the first four lines of this test, we set up <code>ToDoItemStore</code> with two to-do items. Next, we wait <a id="_idIndexMarker177"/>for the publisher and try to check the to-do item. Xcode tells us that the <code>check(_:)</code> method is missing. As the test code does not compile right now, we need to switch to the production code and add the <code>check(_:)</code> method. </p>
			<ol>
				<li value="2">Go to <code>ToDoItemStore.swift</code> and add the following method:<pre>// ToDoItemStore.swift
func check(_ item: ToDoItem) {  
}</pre></li>
				<li>Run the tests to make the test code aware of this change. The test fails because the publisher does not publish anything when we call the <code>check(_:)</code> method. Change the code of the <code>check</code> method to the following:<pre>// ToDoItemStore.swift
func check(_ item: ToDoItem) {
  items.append(ToDoItem(title: ""))
}</pre></li>
			</ol>
			<p>Wait a minute! This is not what the <code>check</code> method should do. Yes, you are right. This is just the simplest code that makes the test at this stage pass. In TDD, you should always write the simplest code that makes the test pass. If you know the code is wrong, you need to add more tests until the feature actually works.</p>
			<ol>
				<li value="4">Run the tests <a id="_idIndexMarker178"/>to confirm that all tests pass. Open <code>ToDoItemStore.swift</code> and change the code in <code>test_check_shouldPublishChangeInDoneItems()</code> such that it looks like this:<pre>// ToDoItemStoreTests.swift
func test_check_shouldPublishChangeInDoneItems()
 throws {
  let sut = ToDoItemStore()
  let toDoItem = ToDoItem(title: "Dummy")
  sut.add(toDoItem)
  sut.add(ToDoItem(title: "Dummy 2"))
  let receivedItems = try wait(for: sut.itemPublisher)
 {
    sut.check(toDoItem)
 }
  let doneItems = receivedItems.filter({ $0.done })
  XCTAssertEqual(doneItems, [toDoItem])
}</pre></li>
			</ol>
			<p>The last two lines before the closing curly braces are new. In these two lines, we first filter all done to-do items, and then we assert that the result is an array with only the to-do item we checked.</p>
			<ol>
				<li value="5">The static <a id="_idIndexMarker179"/>analyzer of Xcode tells us that the <code>ToDoItem</code> type does not have a property with the name <code>done</code>. Open <code>ToDoItem.swift</code> and add this property:<pre>// ToDoItem.swift
struct ToDoItem: Equatable {
  let title: String
  let itemDescription: String?
  let timestamp: TimeInterval?
  let location: Location?
  var done = false
 
  init(title: String,
       itemDescription: String? = nil,
       timestamp: TimeInterval? = nil,
       location: Location? = nil) {
 
    self.title = title
    self.itemDescription = itemDescription
    self.timestamp = timestamp
    self.location = location
  }
}</pre></li>
			</ol>
			<p>Now, the code compiles again. Run the tests. The <code>test_check_shouldPublishChangeInDoneItems()</code> test fails because the array with the filtered items is empty. This is expected because the code we added to <code>check(_:)</code> does not check any item. It just adds a new item with an empty title.</p>
			<ol>
				<li value="6">Go back to <code>ToDoItemStore.swift</code>. We need to replace the to-do item in the array <a id="_idIndexMarker180"/>with the one in which we changed the <code>done</code> property to <code>true</code>. Replace the <code>check</code> method with the following code:<pre>// ToDoItemStore.swift
func check(_ item: ToDoItem) {
  var mutableItem = item
  mutableItem.done = true
  if let index = items.firstIndex(of: item) {
    items[index] = mutableItem
  }
}</pre></li>
			</ol>
			<p>First, we get a mutable copy of the item. Next, we change <code>done</code> to <code>true</code> and finally, we replace the item in the items array with the changed item.</p>
			<p>Even though this should make the test pass, it still fails. Click the red diamond next to the failure message to expand it. Read the message carefully. The test fails because the two arrays are not the same. The to-do item in the result array has another value in the <code>done</code> property.</p>
			<div><div><img src="img/Figure_6.01_B18127.jpg" alt="Figure 6.1 – Expanded failure message telling us that the items are different&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Expanded failure message telling us that the items are different</p>
			<p>This makes sense. By adding the <code>done</code> property, we changed how Swift figures out whether two to-do items are the same. This is not what we want. A to-do item should have an identity.</p>
			<ol>
				<li value="7">Let's add <a id="_idIndexMarker181"/>a property that provides the to-do item with an identity. Open <code>ToDoItem.swift</code> and replace the <code>ToDoItem</code> structure with the following code:<pre>// ToDoItem.swift
struct ToDoItem: Equatable {
  let id: UUID
  let title: String
  let itemDescription: String?
  let timestamp: TimeInterval?
  let location: Location?
  var done = false
  init(title: String,
       itemDescription: String? = nil,
       timestamp: TimeInterval? = nil,
       location: Location? = nil) {
    self.id = UUID()
    self.title = title
    self.itemDescription = itemDescription
    self.timestamp = timestamp
    self.location = location
  }
  static func == (lhs: ToDoItem, rhs: ToDoItem) -&gt;
 Bool {
    return lhs.id == rhs.id
  }
}</pre></li>
			</ol>
			<p>With this code, we add an ID that is set when an item is created. In addition, we use this <code>id</code> property to figure out whether two to-do items are the same.</p>
			<ol>
				<li value="8">Run the tests. All tests pass.</li>
				<li>Before we <a id="_idIndexMarker182"/>move on, we have to clean up the tests a bit. In the first line of each test, we create the system under test (<code>sut</code>). This code should be put into <code>setUpWithError()</code>. First, add the following property to <code>ToDoItemStoreTests</code>:<pre>// ToDoItemStoreTests.swift
var sut: ToDoItemStore!</pre></li>
				<li>Next, change <code>setUpWithError()</code> and <code>tearDownWithError()</code> like this:<pre>// ToDoItemStoreTests.swift
override func setUpWithError() throws {
  sut = ToDoItemStore()
}
override func tearDownWithError() throws {
  sut = nil
}</pre></li>
				<li>Now we <a id="_idIndexMarker183"/>can remove the following line of code from each of the tests:<pre>let sut = ToDoItemStore()</pre></li>
			</ol>
			<p>This makes the tests easier to understand.</p>
			<p>We can now add and check to-do items using our <code>ToDoItemStore</code>. But at the moment, the to-do items are only held in memory as long as the app runs. <code>ToDoItemStore</code> needs to store the to-do items somewhere and load them into memory as soon as the app starts again. In the next section, we will implement exactly this.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor171"/>Storing and loading ToDoItems</h1>
			<p>To test storing <a id="_idIndexMarker184"/>and loading to-do items, we first need to create an instance of the <code>ToDoItemStore</code> class, add a to-do item, destroy that store instance, and <a id="_idIndexMarker185"/>create a new one. When we add a to-do item in the first instance, all items should be stored in the filesystem. When creating the second instance, the stored items should be loaded again from the filesystem. This means when we find the item we added in the first instance after we created the second instance, storing and loading works.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor172"/>Implementing storing and loading</h2>
			<p>It is essential <a id="_idIndexMarker186"/>that the test controls the environment <a id="_idIndexMarker187"/>needed for itself. This means for storing and loading to-do items, the test needs to control where the items are stored. For example, if we used Core Data to persist the to-do items, the test would be responsible for setting up a fake Core Data store just used for the test. In our app, we will store the to-do items in a JSON file. So, the test needs to control where the JSON file is stored. Let's see how this can be done:</p>
			<ol>
				<li value="1">Add the following test method code to <code>ToDoItemStore</code>:<pre>// ToDoItemStoreTests.swift
func test_init_shouldLoadPreviousToDoItems() {
  var sut1: ToDoItemStore? = 
    ToDoItemStore(fileName: "dummy_store")
}</pre></li>
			</ol>
			<p>In this test, we don't use the instance created in <code>setUpWithError()</code> because we need to pass in the name of the store to be used. Xcode complains that we <a id="_idIndexMarker188"/>passed an argument to a call that <a id="_idIndexMarker189"/>takes no arguments. This means we have to pause writing the test code and switch to the production code. </p>
			<ol>
				<li value="2">Add the following initializer to <code>ToDoItemStore</code>:<pre>// ToDoItemStore.swift
init(fileName: String = "todoitems") {
}</pre></li>
			</ol>
			<p>This is enough to make the test compile again. This initializer allows passing the filename for the JSON file into <code>ToDoItemStore</code>. The <code>fileName</code> parameter has a default value because in the production code, the <code>ToDoItemStore</code> class should control where the file is stored. </p>
			<ol>
				<li value="3">Now we can write the rest of the test code:<pre>// ToDoItemStoreTests.swift
func test_init_shouldLoadPreviousToDoItems() {
  var sut1: ToDoItemStore? =
    ToDoItemStore(fileName: "dummy_store")
  let publisherExpectation = expectation(
    description: "Wait for publisher in \(#file)"
  )
 
  let toDoItem = ToDoItem(title: "Dummy Title")
  sut1?.add(toDoItem)
  sut1 = nil
  let sut2 = ToDoItemStore(fileName: "dummy_store")
  var result: [ToDoItem]?
  let token = sut2.itemPublisher
    .sink { value in
      result = value
      publisherExpectation.fulfill()
    }
 
  wait(for: [publisherExpectation], timeout: 1)
  token.cancel()
  XCTAssertEqual(result, [toDoItem])
}</pre></li>
			</ol>
			<p>This code <a id="_idIndexMarker190"/>looks a bit intimidating, but it <a id="_idIndexMarker191"/>only contains concepts we've already covered. Let's go over that code step by step:</p>
			<ol>
				<li>We create an instance of <code>ToDoItemStore</code> and a test expectation. </li>
				<li>Next, we add an item to the to-do item store and destroy the store by setting it to nil. </li>
				<li>Then, we create a new to-do item store and subscribe to its <code>itemPublisher</code>. But this time, we do not drop the first published value from the publisher. As the publisher is a <code>CurrentValueSubject</code> structure, the subscriber receives the current value as soon as it subscribes to the publisher. </li>
				<li>Finally, we wait for the asynchronous execution of the Combine code and assert that the published items array contains the item we added to the initial to-do item store.</li>
			</ol>
			<p>Run the tests. This test fails, because we haven't implemented storing and loading yet. Let's implement the code.</p>
			<ol>
				<li value="4">We need <a id="_idIndexMarker192"/>to store the filename in a property <a id="_idIndexMarker193"/>and access it when we store and load the items. Add the following property and change the initializer to set that property:<pre>// ToDoItemStore.swift
private let fileName: String
init(fileName: String = "todoitems") {
  self.fileName = fileName
}</pre></li>
				<li>The next step is to make <code>ToDoItem</code> convertible to JSON format. Swift can do this for us if all the properties of a type are convertible to JSON. The only thing we as the developer have to do is to add the <code>Codable</code> protocol to the type. Change the declaration of <code>ToDoItem</code> such that it reads like this:<pre>// ToDoItem.swift
struct ToDoItem: Equatable, Codable {</pre></li>
				<li>Xcode complains that <code>Location</code> property does not conform to <code>Codable</code> yet. Change the declaration of <code>Location</code> to the following:<pre>// Location.swift
struct Location: Equatable, Codable {</pre></li>
			</ol>
			<p>Now Xcode tells us that <code>Location</code> does not conform to <code>Codable</code>. Oh, bummer! <code>CLLocationCoordinate2D</code> does not conform to <code>Codable</code>. We could implement <a id="_idIndexMarker194"/>the conformance ourselves, but <a id="_idIndexMarker195"/>there is an easier way. We create a <code>Coordinate</code> struct that serves the same purpose but is <code>Codable</code>. Create a new Swift file with the <em class="italic">⌘</em><em class="italic">N</em> shortcut and call it <code>Coordinate</code>. Set <strong class="bold">Group</strong> to <strong class="bold">ToDo</strong> and make sure that it is added to the <strong class="bold">ToDo</strong> target.</p>
			<div><div><img src="img/Figure_6.02_B18127.jpg" alt="Figure 6.2 – Creating a file for the Coordinate structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Creating a file for the Coordinate structure</p>
			<ol>
				<li value="7">Add the following code to the new file:<pre>// Coordinate.swift
struct Coordinate: Codable {
  let latitude: Double
  let longitude: Double
}</pre></li>
			</ol>
			<p>As Double is Codable, a structure only consisting of Double properties is also Codable. </p>
			<ol>
				<li value="8">Now we can replace the CLLocationCoordinate2D type in Location with our new Coordinate type:<pre>// Location.swift
struct Location: Equatable, Codable {
  let name: String
  let coordinate: Coordinate?
 
  init(name: String,
       coordinate: Coordinate? = nil) {
 
    self.name = name
    self.coordinate = coordinate
  }
  // …
}</pre></li>
			</ol>
			<p>With this change, we no longer depend on Core Location and can remove its import from <code>Location.swift</code>.</p>
			<p>We have <a id="_idIndexMarker196"/>changed some code. How do we make sure <a id="_idIndexMarker197"/>that everything we implemented before still works? With our tests! To do that, we first have to disable the currently failing test because of the incomplete implementation of storing and loading to-do items. We know that this test still fails because we are not finished with the implementation. We only want to run the tests that were green before we started implementing storing and loading. Let's get started: </p>
			<ol>
				<li value="1">Go to <code>ToDoItemStoreTests</code> and add the following call of <code>XCTSkipIf(_:_:)</code> at the beginning of the test. Note that you also have to add the <code>throws</code> keyword to the test signature:<pre>// ToDoItemStoreTests.swift
func test_init_shouldLoadPreviousToDoItems() throws {
    try XCTSkipIf(true, "Just test Coordinate change")
    // …
}</pre></li>
			</ol>
			<p>With this call, we tell the test runner that it should skip this test. When we are done with the change of the coordinate type, we just have to remove this line of code to activate the test again.</p>
			<ol>
				<li value="2">Run the <a id="_idIndexMarker198"/>tests to figure out whether the <a id="_idIndexMarker199"/>coordinate change was successful or whether we missed something. The <code>test_init_setsCoordinate()</code> test does not compile because we changed the coordinate type. Replace the <code>CLLocationCoordinate2D</code> type with <code>Coordinate</code> and remove the import of <code>CoreLocation</code>:<pre>// LocationTests.swift
func test_init_setsCoordinate() throws {
  let coordinate = Coordinate(latitude: 1,
    longitude: 2)
  let location = Location(name: "",
    coordinate: coordinate)
  let resultCoordinate = try
 XCTUnwrap(location.coordinate)
  XCTAssertEqual(resultCoordinate.latitude, 1,
    accuracy: 0.000_001)
  XCTAssertEqual(resultCoordinate.longitude, 2,
    accuracy: 0.000_001)
}</pre></li>
				<li>Run the tests again. Now all tests pass.</li>
			</ol>
			<p>This is huge! For the first time, we used unit tests to make refactoring easier. We didn't have to <a id="_idIndexMarker200"/>check each and every file to see whether the <a id="_idIndexMarker201"/>coordinate property was used and whether we had to adapt the type. We just had to run the tests. Now imagine we're working on a code base with hundreds of thousands of lines of code. The confidence you gain with a good test suite makes refactoring code effortless.</p>
			<p>Go back to <code>ToDoItemStoreTests</code> and remove the <code>XCTSkipIf(_:_:)</code> call. Run the tests to confirm that <code>test_init_shouldLoadPreviousToDoItems()</code> still fails.</p>
			<p>Now that <code>ToDoItem</code> conforms to <code>Codable</code>, we can store a list of to-do items in a JSON structure: </p>
			<ol>
				<li value="1">Add the following method to <code>ToDoItemStore</code>:<pre>// ToDoItemStore.swift
private func saveItems() {
  if let url = FileManager.default
      .urls(for: .documentDirectory,
               in: .userDomainMask)
      .first?
      .appendingPathComponent(fileName) {
    do {
      let data = try JSONEncoder().encode(items)
      try data.write(to: url)
    } catch {
      print("error: \(error)")
    }
  }
}</pre></li>
			</ol>
			<p>First, we get a file URL to store the JSON file to. Next, we get a <code>Data</code> object from the to-do items and write it to the file URL. As the conversion to JSON and writing to the file URL can throw an error, we embedded these calls into a <code>do-catch</code> block.</p>
			<ol>
				<li value="2">The items <a id="_idIndexMarker202"/>need to be saved whenever <a id="_idIndexMarker203"/>something in the list of to-do items changes. Change the <code>add(_:)</code> method such that it looks like this:<pre>// ToDoItemStore.swift
func add(_ item: ToDoItem) {
  items.append(item)
  saveItems()
}</pre></li>
				<li>When we add a new item to the store, we save the list to the filesystem. We also need a method that loads the to-do items. Add the following method to <code>ToDoItemStore</code>:<pre>// ToDoItemStore.swift
private func loadItems() {
  if let url = FileManager.default
      .urls(for: .documentDirectory,
               in: .userDomainMask)
      .first?
      .appendingPathComponent(fileName) {
    do {
      let data = try Data(contentsOf: url)
      items = try JSONDecoder()
        .decode([ToDoItem].self, from: data)
    } catch {
      print("error: \(error)")
    }
  }
}</pre></li>
			</ol>
			<p>This method is the reverse of the <code>saveItems</code> method. We get the same file URL in <a id="_idIndexMarker204"/>the beginning. Then, we load the data <a id="_idIndexMarker205"/>from the filesystem and convert it from the JSON format to a list of to-do items.</p>
			<ol>
				<li value="4">We call this method in the initializer of <code>ToDoItemStore</code>:<pre>// ToDoItemStore.swift
init(fileName: String = "todoitems") {
  self.fileName = fileName
  loadItems()
}</pre></li>
			</ol>
			<p>That should make our test green. Run the tests to confirm.</p>
			<p>Depending on your configuration, your tests might indeed be green. But most probably, some of the tests in <code>ToDoItemStoreTests</code> will fail. With storing and loading to-do items, the tests now depend on the tests that ran before. This is bad and should be avoided. When tests depend on the order in which they are executed, a test suite is not reliable. Tests can fail on some computers or in some environments. We need to fix this:</p>
			<ol>
				<li value="1">First, all tests should use a dummy JSON file. So, replace the setup code in <code>ToDoItemStoreTests</code> with this:<pre>// ToDoItemStoreTests.swift
override func setUpWithError() throws {
  sut = ToDoItemStore(fileName: "dummy_store")
}</pre></li>
				<li>Second, we <a id="_idIndexMarker206"/>have to remove the JSON file <a id="_idIndexMarker207"/>after each test execution:<pre>// ToDoItemStoreTests.swift
override func tearDownWithError() throws {
  sut = nil
  if let url = FileManager.default
      .urls(for: .documentDirectory,
               in: .userDomainMask)
      .first?
      .appendingPathComponent("dummy_store") {
    try? FileManager.default.removeItem(at: url)
  }
}</pre></li>
			</ol>
			<p>I know what you are thinking. We used the code to get the file URL for the JSON file a third time. We should clean that up. No worries, we will do that next.</p>
			<p>Run all tests twice. In the second run, all tests should be green.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor173"/>Cleaning up the code</h2>
			<p>In software <a id="_idIndexMarker208"/>development, we should follow the DRY <a id="_idIndexMarker209"/>principle. <strong class="bold">DRY</strong> stands for <strong class="bold">don't repeat yourself</strong>. By copying the code that creates the file URL for the JSON file two times, we violated this principle. Let's make this code reusable.</p>
			<p>Select the <code>FileManagerExtension.swift</code> and make sure it is added to the main target of our project.</p>
			<p>Follow these steps to remove the duplicated code:</p>
			<ol>
				<li value="1">Add this extension to <code>FileManagerExtension.swift</code>:<pre>// FileManagerExtension.swift
extension FileManager {
  func documentsURL(name: String) -&gt; URL {
    guard let documentsURL = urls(for:
      .documentDirectory,
    in: .userDomainMask).first else {
      fatalError()
    }
    return documentsURL.appendingPathComponent(name)
  }
}</pre></li>
				<li>Open <code>ToDoItemStore.swift</code> and replace <code>saveItems()</code> with the following implementation:<pre>// ToDoItemStore.swift
private func saveItems() {
  let url = FileManager.default
    .documentsURL(name: fileName)
  do {
    let data = try JSONEncoder().encode(items)
    try data.write(to: url)
  } catch {
    print("error: \(error)")
  }
}</pre><p class="callout-heading">Note</p><p class="callout">Usually, you wouldn't use the <code>FileManager</code> singleton directly here. In real code, you would rather <a id="_idIndexMarker210"/>pass in the kind of storage into the <code>ToDoItemStore</code> as a dependency using Dependency Injection. We take the approach above to keep the book as short as possible and to not distract from the main topic of this section.</p></li>
				<li>Next, replace <code>loadItems()</code> with this code:<pre>// ToDoItemStore.swift
private func loadItems() {
  let url = FileManager.default
    .documentsURL(name: fileName)
  do {
    let data = try Data(contentsOf: url)
    items = try JSONDecoder()
      .decode([ToDoItem].self, from: data)
  } catch {
    print("error: \(error)")
  }
}</pre></li>
				<li>Finally, replace <code>tearDownWithError()</code> in <code>ToDoItemStoreTests.swift</code> with the following code:<pre>// ToDoItemStoreTests.swift
override func tearDownWithError() throws {
  sut = nil  
  let url = FileManager.default
    .documentsURL(name: "dummy_store")
  try? FileManager.default.removeItem(at: url)
}</pre></li>
			</ol>
			<p>Run all tests to make sure they still pass.</p>
			<ol>
				<li value="5">We are <a id="_idIndexMarker211"/>not done yet. There is one test missing. When the user checks a to-do item as done, the list of items should also be written to the filesystem. To make sure that is the case, add the following test to <code>ToDoItemStoreTests.swift</code>:<pre>func test_init_whenItemIsChecked_
 shouldLoadPreviousToDoItems() throws {
  var sut1: ToDoItemStore? =
  ToDoItemStore(fileName: "dummy_store")
  let publisherExpectation = expectation(
    description: "Wait for publisher in \(#file)"
  )
 
  let toDoItem = ToDoItem(title: "Dummy Title")
  sut1?.add(toDoItem)
  sut1?.check(toDoItem)
  sut1 = nil
  let sut2 = ToDoItemStore(fileName: "dummy_store")
  var result: [ToDoItem]?
  let token = sut2.itemPublisher
    .sink { value in
      result = value
      publisherExpectation.fulfill()
    }
 
  wait(for: [publisherExpectation], timeout: 1)
  token.cancel()
  XCTAssertEqual(result?.first?.done, true)
}</pre></li>
			</ol>
			<p>This <a id="_idIndexMarker212"/>test looks kind of like <code>test_init_shouldLoadPreviousToDoItems()</code>. But here, we check <code>toDoItem</code> before we destroy the to-do item store. In addition, we assert at the end that the loaded to-do item is checked as done.</p>
			<ol>
				<li value="6">To make this test pass, add the call to <code>saveItems()</code> within the <code>if let</code> conditional of the <code>check(_:)</code> method:<pre>func check(_ item: ToDoItem) {
  var mutableItem = item
  mutableItem.done = true
  if let index = items.firstIndex(of: item) {
    items[index] = mutableItem
    saveItems()
  }
}</pre></li>
			</ol>
			<p>Before <a id="_idIndexMarker213"/>you move on, make sure that all tests pass.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor174"/>Summary</h1>
			<p>In this chapter, we have explored how to test Combine code. To make the tests easier to understand, we introduced a helper method and improved its failure message. We figured out how to make an <code>Equatable</code> type and how this can help in unit tests. Finally, we learned how to test storing and loading a JSON file to and from the filesystem of the iOS device.</p>
			<p>With these skills, you should be able to write tests for a variety of different model scenarios. </p>
			<p>In the next chapter, we will start building the user interface. We will start with the list of to-do items.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor175"/>Exercises</h1>
			<ol>
				<li value="1">Remove the expectation from the tests that test Combine code and check whether they fail.</li>
				<li>Think about what needs to be done to check whether the stored file is indeed in JSON format. Do you think such a test is of any use?</li>
			</ol>
		</div>
	</body></html>