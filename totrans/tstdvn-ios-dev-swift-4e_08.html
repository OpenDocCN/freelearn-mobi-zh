<html><head></head><body>
		<div id="_idContainer049">
			<h1 id="_idParaDest-96"><em class="italic"><a id="_idTextAnchor165"/>Chapter 6</em>: Testing, Loading, and Saving Data</h1>
			<p>At the moment, we have structures to hold the information of one to-do item. A usable to-do item app has to show and manage several to-do items. In addition, when the user closes the app and opens it again, they expect the to-do items to still be there.</p>
			<p>This means our app needs structures that can store and load information of a list of to-do items.</p>
			<p>In this chapter, we will add a class that stores and loads a list of to-do items to and from the filesystem of the iOS device. We will use the JSON format because it is a common choice in iOS development. It has the nice benefit in that it is easily readable by humans and computers.</p>
			<p>The chapter is structured as follows:</p>
			<ul>
				<li>Publishing changes with Combine</li>
				<li>Checking items</li>
				<li>Storing and loading <strong class="source-inline">ToDoItem</strong></li>
			</ul>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor166"/>Technical requirements </h1>
			<p>The source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter06">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter06</a>. </p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor167"/>Publishing changes with Combine</h1>
			<p>In today's iOS apps, communication between different parts is often implemented using the <strong class="bold">Combine</strong> framework <a id="_idIndexMarker152"/>by Apple. In Combine, data changes are published and can be subscribed to. This design pattern helps to decouple the code and make it easier to maintain.</p>
			<p>We will use <a id="_idIndexMarker153"/>Combine in our <strong class="source-inline">ToDoItemStore</strong> to inform, for example, the table view controller that something changed <a id="_idIndexMarker154"/>and the user interface should be updated with the new data.</p>
			<p>Open Project Navigator and select the <strong class="bold">ToDoTests</strong> group. Go to the <strong class="bold">iOS</strong> | <strong class="bold">Source</strong> | <strong class="bold">Unit Test Case</strong> option to create a test case class with the name <strong class="source-inline">ToDoItemStoreTests</strong>. Import the <strong class="source-inline">ToDo</strong> module (<strong class="source-inline">@testable import ToDo</strong>) and remove the two test method templates.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor168"/>Testing asynchronous Combine code</h2>
			<p>Up to now, all <a id="_idIndexMarker155"/>the code we've tested has been synchronous code. Publishing values in Combine is asynchronous. To be able to test Combine code, we need a way to halt the test and wait until the code we want to test is executed. <strong class="source-inline">XCTest</strong> provides <strong class="source-inline">XCTestExpectation</strong> for this task. Let's see how this works:</p>
			<ol>
				<li>Add the following code to <strong class="source-inline">ToDoItemStoreTests</strong>:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_add_shouldPublishChange() {</p><p class="source-code">  let sut = ToDoItemStore()</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="bold">sut</strong> abbreviation <a id="_idIndexMarker156"/>stands for <strong class="bold">system under test</strong>. We could also write this as <strong class="source-inline">toDoItemStore</strong>, but using <strong class="source-inline">sut</strong> makes it easier to read, and it also allows us to copy and paste test code into other tests when appropriate.</p>
			<ol>
				<li value="2">The test is not yet finished, but it already fails because Xcode cannot find <strong class="source-inline">ToDoItemStore</strong> in the scope. Open Project Navigator again and select the <strong class="bold">ToDo</strong> group. Go to <strong class="bold">iOS</strong> | <strong class="bold">Source</strong> | <strong class="bold">Swift File</strong>. This will create a Swift file; let's call it <strong class="source-inline">ToDoItemStore.swift</strong>. Add the following class definition to <strong class="source-inline">ToDoItemStore.swift</strong>:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">class ToDoItemStore {</p><p class="source-code">}</p></li>
			</ol>
			<p>This is enough to make the test code compilable. </p>
			<ol>
				<li value="3">Run the <a id="_idIndexMarker157"/>tests to make sure that they all pass and we can continue writing tests. Add the following code to <strong class="source-inline">test_add_shouldPublishChange()</strong>:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_add_shouldPublishChange() {</p><p class="source-code">  let sut = ToDoItemStore()</p><p class="source-code">  let publisherExpectation = expectation(</p><p class="source-code">    description: "Wait for publisher in \(#file)"</p><p class="source-code">  )</p><p class="source-code">  var receivedItems: [ToDoItem] = []</p><p class="source-code">  let token = sut.itemPublisher</p><p class="source-code">}</p></li>
			</ol>
			<p>First, we create an instance of <strong class="source-inline">ToDoItemStore</strong>. Next, we need an expectation to wait for the asynchronous execution of our Combine code. With <strong class="source-inline">description</strong>, we inform our future selves why we need this expectation. To figure out whether <strong class="source-inline">publisher</strong> worked as expected, we need to subscribe to it in the test and check the published value. We will store the value in the <strong class="source-inline">receivedItems</strong> variable.</p>
			<p>The last line is the beginning of the subscription to the publisher, but we have to pause before writing the rest because Xcode complains that <strong class="bold">Value of type 'ToDoItemStore' has no member 'itemPublisher'</strong>. This means we need to write some code in the main target to make the test compile again. </p>
			<ol>
				<li value="4">First, we need to import the Combine framework. Then, we can add the publisher, like this:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">import Foundation</p><p class="source-code">import Combine</p><p class="source-code"> </p><p class="source-code">class ToDoItemStore {</p><p class="source-code">  var itemPublisher =</p><p class="source-code">    CurrentValueSubject&lt;[ToDoItem], Never&gt;([])</p><p class="source-code">}</p></li>
			</ol>
			<p>If you <a id="_idIndexMarker158"/>haven't worked with Combine or Generics yet, this syntax might look a bit strange. <strong class="source-inline">[ToDoItem]</strong> in <strong class="source-inline">&lt;[ToDoItem], Never&gt;</strong> means that the publisher sends arrays of <strong class="source-inline">ToDoItems</strong>. The second part, <strong class="source-inline">Never</strong>, is the failure type of this publisher. <strong class="source-inline">Never</strong> means that this publisher cannot fail. In summary, <strong class="source-inline">CurrentValueSubject&lt;[ToDoItem], Never&gt;([])</strong> creates an instance of a <strong class="source-inline">CurrentValueSubject</strong> publisher that sends arrays of <strong class="source-inline">ToDoItems</strong> that never fail.</p>
			<p>This fixes the error reported by the static analyzer. We can switch back to the test code. </p>
			<ol>
				<li value="5">Import Combine below the existing import statements and change the code in <strong class="source-inline">test_add_shouldPublishChange()</strong> so that it looks like this:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">import Combine</p><p class="source-code">// ...</p><p class="source-code">func test_add_shouldPublishChange() {</p><p class="source-code">  let sut = ToDoItemStore()</p><p class="source-code">  let publisherExpectation = expectation(</p><p class="source-code">    description: "Wait for publisher in \(#file)"</p><p class="source-code">  )</p><p class="source-code">  var receivedItems: [ToDoItem] = []</p><p class="source-code">  let token = sut.itemPublisher</p><p class="source-code">    .dropFirst()</p><p class="source-code">    .sink { items in</p><p class="source-code">      receivedItems = items</p><p class="source-code">      publisherExpectation.fulfill()</p><p class="source-code">    }</p><p class="source-code">  let toDoItem = ToDoItem(title: "Dummy")</p><p class="source-code">  sut.add(toDoItem)</p><p class="source-code">}</p></li>
			</ol>
			<p>This does <a id="_idIndexMarker159"/>not compile. But before we switch back to the production code, let's see what we added here:</p>
			<ul>
				<li>First, we drop the first published value from <strong class="source-inline">itemPublisher</strong> using <strong class="source-inline">dropFirst()</strong>. We do this because a <strong class="source-inline">CurrentValueSubject</strong> publisher publishes the first current value as soon as we subscribe to it. But in the test, we only want to assert that the changes have been published.</li>
				<li>Next, we subscribe to the publisher using <strong class="source-inline">sink(receiveValue:)</strong>. The published value is passed into the <strong class="source-inline">receivedValue</strong> parameter. You can't see the parameter name in the code because we are using the trailing closure syntax as it is common in iOS development. We store the received value into the <strong class="source-inline">receivedItems</strong> variable. At this point, the asynchronous code we waited for in the test is finished. We tell the test runner that we don't need to wait any further by calling <strong class="source-inline">fulfill()</strong> on the expectation.</li>
				<li>The last two lines in this code are the execution of the method we want to test. We assume here that <strong class="source-inline">ToDoItemStore</strong> has an <strong class="source-inline">add(_:)</strong> method that allows us to add to-do items to the item store. As we haven't written this method yet, Xcode is complaining and we have to switch back to the production code. Follow the next step for that.</li>
			</ul>
			<ol>
				<li value="6">Add <a id="_idIndexMarker160"/>the following code to <strong class="source-inline">ToDoItemStore</strong>:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">func add(_ item: ToDoItem) {</p><p class="source-code">}</p></li>
			</ol>
			<p>This makes the test compilable again. </p>
			<ol>
				<li value="7">Switch back to the test code and add the last three lines in the following code to <strong class="source-inline">test_add_shouldPublishChange()</strong>:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_add_shouldPublishChange() {</p><p class="source-code">  // ... arrange ...</p><p class="source-code">  let toDoItem = ToDoItem(title: "Dummy")</p><p class="source-code">  sut.add(toDoItem)</p><p class="source-code">  wait(for: [publisherExpectation], timeout: 1)</p><p class="source-code">  token.cancel()</p><p class="source-code">  XCTAssertEqual(receivedItems.first?.title,</p><p class="source-code">    toDoItem.title)</p><p class="source-code">}</p></li>
			</ol>
			<p>With <strong class="source-inline">wait(for:timeout:)</strong>, we tell the test runner to wait at this point until all expectations in the <strong class="source-inline">first</strong> parameter are fulfilled. If all the expectations are not fulfilled after the timeout has passed, the test fails. Next, we cancel the publisher. If we omitted this line, the compiler could remove the subscription because it looks like it is not used anywhere in the code. In the last line, we compare the received value with what we expect.</p>
			<p>Finally, we <a id="_idIndexMarker161"/>can run the test. As expected, the test we just added fails because the publisher hasn't published anything yet.</p>
			<p>We would like to use the assertion like this: <strong class="source-inline">XCTAssertEqual(receivedItems, [toDoItem])</strong>. But this is not possible at the moment because <strong class="source-inline">ToDoItem</strong> does not conform to the <strong class="source-inline">Equatable</strong> protocol, which tells the compiler how to treat equality between two instances. We will fix that soon. But first, we need to make the tests green again.</p>
			<ol>
				<li value="8">Change the code in <strong class="source-inline">ToDoItemStore</strong> so that it looks like this:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">class ToDoItemStore {</p><p class="source-code">  var itemPublisher =</p><p class="source-code">    CurrentValueSubject&lt;[ToDoItem], Never&gt;([])</p><p class="source-code">  private var items: [ToDoItem] = [] {</p><p class="source-code">    didSet {</p><p class="source-code">      itemPublisher.send(items)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  func add(_ item: ToDoItem) {</p><p class="source-code">    items.append(item)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>With <a id="_idIndexMarker162"/>this code, we added a <strong class="source-inline">private</strong> property to hold the to-do items in the item store. Whenever this property changes (for example, when a new item is added), it is published using the item publisher. As a result, in the <strong class="source-inline">add(_:)</strong> method, we only have to append the item to the items list.</p>
			<ol>
				<li value="9">Run the tests. All tests pass.</li>
			</ol>
			<p>Now let's tackle the problem of <strong class="source-inline">ToDoItem</strong> not being equatable.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor169"/>Making ToDoItem equatable</h2>
			<p>The step <a id="_idIndexMarker163"/>of making <strong class="source-inline">ToDoItem</strong> equatable is a refactoring step. Up to this point, the code worked without <strong class="source-inline">ToDoItem</strong> being equatable. But the <a id="_idIndexMarker164"/>readability of the test would greatly benefit if we could use <strong class="source-inline">XCTAssertEqual</strong> directly on an array of <strong class="source-inline">ToDoItems</strong>. The following steps show you how to do that:</p>
			<ol>
				<li value="1">First, add the <strong class="source-inline">Equatable</strong> protocol to the declaration of <strong class="source-inline">ToDoItem</strong>, like this:<p class="source-code">// ToDoItem.swift</p><p class="source-code">struct ToDoItem: Equatable {</p><p class="source-code">  // ...</p><p class="source-code">}</p></li>
				<li>Next, do <a id="_idIndexMarker165"/>the same for the <strong class="source-inline">Location</strong> structure:<p class="source-code">// Location.swift</p><p class="source-code">struct Location: Equatable {</p><p class="source-code">  // …</p><p class="source-code">}</p></li>
				<li>Next, add <a id="_idIndexMarker166"/>the following method to the <strong class="source-inline">Location</strong> struct:<p class="source-code">// Location.swift</p><p class="source-code">static func == (lhs: Location, rhs: Location) -&gt; Bool {</p><p class="source-code">  if lhs.name != rhs.name {</p><p class="source-code">    return false</p><p class="source-code">  }</p><p class="source-code">  if lhs.coordinate == nil, rhs.coordinate != nil {</p><p class="source-code">    return false</p><p class="source-code">  }</p><p class="source-code">  if lhs.coordinate != nil, rhs.coordinate == nil {</p><p class="source-code">    return false</p><p class="source-code">  }</p><p class="source-code">  if let lhsCoordinate = lhs.coordinate,</p><p class="source-code">      let rhsCoordinate = rhs.coordinate {</p><p class="source-code">    if abs(lhsCoordinate.longitude -</p><p class="source-code">      rhsCoordinate.longitude) &gt; 0.000_000_1 {</p><p class="source-code">      return false</p><p class="source-code">    }</p><p class="source-code">    if abs(lhsCoordinate.latitude -</p><p class="source-code">      rhsCoordinate.latitude) &gt; 0.000_000_1 {</p><p class="source-code">      return false</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  return true</p><p class="source-code">}</p></li>
			</ol>
			<p>If Swift cannot automatically add <strong class="source-inline">Equatable</strong> conformance (for example, because one of the <a id="_idIndexMarker167"/>properties isn't <strong class="source-inline">Equatable</strong> itself), we need to add the <strong class="source-inline">== (lhs:rhs:)</strong> class method. The method looks a bit complicated but this is <a id="_idIndexMarker168"/>just because the <strong class="source-inline">coordinate</strong> property is optional. So, we also have to respect the cases when one coordinate is nil and the other isn't.</p>
			<ol>
				<li value="4">Now, go back to <strong class="source-inline">test_add_shouldPublishChange()</strong> and replace the assertion call at the end with this:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">XCTAssertEqual(receivedItems, [toDoItem])</p></li>
			</ol>
			<p>Run the tests. All tests pass. The assertion now looks way better and we assert exactly what we expect from the test. But the test is still hard to read. All that Combine code is distracting from the main objective of the test. </p>
			<p>Let's add a helper function to the test case to improve the test code:</p>
			<ol>
				<li value="1">The helper function we are going to add is inspired by a blog post (<a href="https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/">https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/</a>) by <em class="italic">John Sundell</em>. Add the following code at the end of <strong class="source-inline">ToDoItemStoreTests.swift</strong> but outside of the <strong class="source-inline">ToDoItemStoreTests</strong> class:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">extension XCTestCase {</p><p class="source-code">  func wait&lt;T: Publisher&gt;(</p><p class="source-code">    for publisher: T,</p><p class="source-code">    afterChange change: () -&gt; Void) throws</p><p class="source-code">  -&gt; T.Output where T.Failure == Never { </p><p class="source-code">    let publisherExpectation = expectation(</p><p class="source-code">      description: "Wait for publisher in \(#file)"</p><p class="source-code">    )</p><p class="source-code">    var result: T.Output?</p><p class="source-code">    let token = publisher</p><p class="source-code">      .dropFirst()</p><p class="source-code">      .sink { value in</p><p class="source-code">        result = value</p><p class="source-code">        publisherExpectation.fulfill()</p><p class="source-code">      }</p><p class="source-code"> </p><p class="source-code">    change()</p><p class="source-code">    wait(for: [publisherExpectation], timeout: 1)</p><p class="source-code">    token.cancel() </p><p class="source-code">    let unwrappedResult = try XCTUnwrap(</p><p class="source-code">      result,</p><p class="source-code">      "Publisher did not publish any value"</p><p class="source-code">    ) </p><p class="source-code">    return unwrappedResult</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>This code is similar to the code we wrote in <strong class="source-inline">test_add_shouldPublishChange()</strong>. It is modified a bit to make it work as an extension of <strong class="source-inline">XCTestCase</strong>. </p>
			<ol>
				<li value="2">Now, we <a id="_idIndexMarker169"/>can replace the test code with the following:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_add_shouldPublishChange() throws {</p><p class="source-code">  let sut = ToDoItemStore()</p><p class="source-code">  let toDoItem = ToDoItem(title: "Dummy")</p><p class="source-code">  let receivedItems = try wait(for: sut.itemPublisher)</p><p class="source-code"> {</p><p class="source-code">    sut.add(toDoItem)</p><p class="source-code">  }</p><p class="source-code">  XCTAssertEqual(receivedItems, [toDoItem])</p><p class="source-code">}</p></li>
			</ol>
			<p>This change <a id="_idIndexMarker170"/>makes the test easy to understand. Run the tests again. All tests still pass.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">wait</strong> method <a id="_idIndexMarker171"/>we just added to <strong class="source-inline">XCTestCase</strong> can throw an error. As a result, we had to add the <strong class="source-inline">try</strong> keyword to the call of this method. We could wrap the call in a <strong class="source-inline">do-catch</strong> block but there is a better way. When we mark the test method itself as <strong class="source-inline">throws</strong>, an error thrown during the test invocation is registered by the test runner as a test failure. This again makes the test easier to read and understand. During the course of this book, we will always use this feature of <strong class="source-inline">XCTest</strong> instead of writing <strong class="source-inline">do-catch</strong> blocks in test methods.</p>
			<ol>
				<li value="3">But how do we know that we didn't break the test? Let's make sure that the test can still fail. Go to <strong class="source-inline">ToDoItemStore</strong> and remove the <strong class="source-inline">items.append(item)</strong> line from <strong class="source-inline">add(_:)</strong>. Run the tests to make sure that the test we changed fails now.</li>
				<li>But something <a id="_idIndexMarker172"/>is strange now. The test failure is <a id="_idIndexMarker173"/>shown as gray instead of red. The reason is that the failure is in the <strong class="source-inline">wait</strong> function we added to <strong class="source-inline">XCTestCase</strong>. To make the test failure be reported at the call site of that function, we need to change the function to this (we only show the relevant lines here):<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">extension XCTestCase {</p><p class="source-code">  func wait&lt;T: Publisher&gt;(</p><p class="source-code">    for publisher: T,</p><p class="source-code">    afterChange change: () -&gt; Void,</p><p class="source-code">    file: StaticString = #file,</p><p class="source-code">    line: Uint = #line) throws</p><p class="source-code">  -&gt; T.Output where T.Failure == Never {</p><p class="source-code"> </p><p class="source-code">    // …</p><p class="source-code">    let unwrappedResult = try XCTUnwrap(</p><p class="source-code">      result,</p><p class="source-code">      "Publisher did not publish any value",</p><p class="source-code">      file: file,</p><p class="source-code">      line: line</p><p class="source-code">    ) </p><p class="source-code">    return unwrappedResult</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>The function now has two more parameters, <strong class="source-inline">file</strong> and <strong class="source-inline">line</strong>. They are set to the <a id="_idIndexMarker174"/>default values, <strong class="source-inline">#file</strong> and <strong class="source-inline">#line</strong>, respectively. These parameters are then used in the call to <strong class="source-inline">XCTUnwrap</strong>. When <strong class="source-inline">XCTUnwrap</strong> now fails, Xcode uses the <strong class="source-inline">file</strong> and <strong class="source-inline">line</strong> parameters to figure out <a id="_idIndexMarker175"/>where this function was called and reports the failure at the call site. Run the tests again to see the difference.</p>
			<ol>
				<li value="5">Then, make the test pass again by adding the line you deleted.</li>
			</ol>
			<p>In the next section, we will implement an essential feature for a to-do list app: <em class="italic">checking items</em>.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor170"/>Checking items</h1>
			<p>In a to-do app, the user needs to be able to mark to-do items as done. This is an important <a id="_idIndexMarker176"/>feature of a to-do app because part of the reason people use such apps is the satisfying feeling when marking a to-do as done.</p>
			<p>So, our app also needs this feature. As the process of building this app is driven by tests, we start with a new test for this feature. But before we can add the test for this feature, we need to think about how we can assert in the test that the feature works. This means we need a way to get all the to-do items that are already done. The easiest way to differentiate the done to-do items from the ones that are still to be done is with a property in the to-do item itself. This way, we can filter all the to-do items according to the value of that property.</p>
			<p>With this plan, we can start writing the test: </p>
			<ol>
				<li value="1">Add the following method to <strong class="source-inline">ToDoItemStoreTests.swift</strong>:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_check_shouldPublishChangeInDoneItems()</p><p class="source-code"> throws {</p><p class="source-code">  let sut = ToDoItemStore()</p><p class="source-code">  let toDoItem = ToDoItem(title: "Dummy")</p><p class="source-code">  sut.add(toDoItem)</p><p class="source-code">  sut.add(ToDoItem(title: "Dummy 2"))</p><p class="source-code">  let receivedItems = try wait(for: sut.itemPublisher) {</p><p class="source-code">    sut.check(toDoItem)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>In the first four lines of this test, we set up <strong class="source-inline">ToDoItemStore</strong> with two to-do items. Next, we wait <a id="_idIndexMarker177"/>for the publisher and try to check the to-do item. Xcode tells us that the <strong class="source-inline">check(_:)</strong> method is missing. As the test code does not compile right now, we need to switch to the production code and add the <strong class="source-inline">check(_:)</strong> method. </p>
			<ol>
				<li value="2">Go to <strong class="source-inline">ToDoItemStore.swift</strong> and add the following method:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">func check(_ item: ToDoItem) {  </p><p class="source-code">}</p></li>
				<li>Run the tests to make the test code aware of this change. The test fails because the publisher does not publish anything when we call the <strong class="source-inline">check(_:)</strong> method. Change the code of the <strong class="source-inline">check</strong> method to the following:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">func check(_ item: ToDoItem) {</p><p class="source-code">  items.append(ToDoItem(title: ""))</p><p class="source-code">}</p></li>
			</ol>
			<p>Wait a minute! This is not what the <strong class="source-inline">check</strong> method should do. Yes, you are right. This is just the simplest code that makes the test at this stage pass. In TDD, you should always write the simplest code that makes the test pass. If you know the code is wrong, you need to add more tests until the feature actually works.</p>
			<ol>
				<li value="4">Run the tests <a id="_idIndexMarker178"/>to confirm that all tests pass. Open <strong class="source-inline">ToDoItemStore.swift</strong> and change the code in <strong class="source-inline">test_check_shouldPublishChangeInDoneItems()</strong> such that it looks like this:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_check_shouldPublishChangeInDoneItems()</p><p class="source-code"> throws {</p><p class="source-code">  let sut = ToDoItemStore()</p><p class="source-code">  let toDoItem = ToDoItem(title: "Dummy")</p><p class="source-code">  sut.add(toDoItem)</p><p class="source-code">  sut.add(ToDoItem(title: "Dummy 2"))</p><p class="source-code">  let receivedItems = try wait(for: sut.itemPublisher)</p><p class="source-code"> {</p><p class="source-code">    sut.check(toDoItem)</p><p class="source-code"> }</p><p class="source-code">  let doneItems = receivedItems.filter({ $0.done })</p><p class="source-code">  XCTAssertEqual(doneItems, [toDoItem])</p><p class="source-code">}</p></li>
			</ol>
			<p>The last two lines before the closing curly braces are new. In these two lines, we first filter all done to-do items, and then we assert that the result is an array with only the to-do item we checked.</p>
			<ol>
				<li value="5">The static <a id="_idIndexMarker179"/>analyzer of Xcode tells us that the <strong class="source-inline">ToDoItem</strong> type does not have a property with the name <strong class="source-inline">done</strong>. Open <strong class="source-inline">ToDoItem.swift</strong> and add this property:<p class="source-code">// ToDoItem.swift</p><p class="source-code">struct ToDoItem: Equatable {</p><p class="source-code">  let title: String</p><p class="source-code">  let itemDescription: String?</p><p class="source-code">  let timestamp: TimeInterval?</p><p class="source-code">  let location: Location?</p><p class="source-code">  var done = false</p><p class="source-code"> </p><p class="source-code">  init(title: String,</p><p class="source-code">       itemDescription: String? = nil,</p><p class="source-code">       timestamp: TimeInterval? = nil,</p><p class="source-code">       location: Location? = nil) {</p><p class="source-code"> </p><p class="source-code">    self.title = title</p><p class="source-code">    self.itemDescription = itemDescription</p><p class="source-code">    self.timestamp = timestamp</p><p class="source-code">    self.location = location</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, the code compiles again. Run the tests. The <strong class="source-inline">test_check_shouldPublishChangeInDoneItems()</strong> test fails because the array with the filtered items is empty. This is expected because the code we added to <strong class="source-inline">check(_:)</strong> does not check any item. It just adds a new item with an empty title.</p>
			<ol>
				<li value="6">Go back to <strong class="source-inline">ToDoItemStore.swift</strong>. We need to replace the to-do item in the array <a id="_idIndexMarker180"/>with the one in which we changed the <strong class="source-inline">done</strong> property to <strong class="source-inline">true</strong>. Replace the <strong class="source-inline">check</strong> method with the following code:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">func check(_ item: ToDoItem) {</p><p class="source-code">  var mutableItem = item</p><p class="source-code">  mutableItem.done = true</p><p class="source-code">  if let index = items.firstIndex(of: item) {</p><p class="source-code">    items[index] = mutableItem</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>First, we get a mutable copy of the item. Next, we change <strong class="source-inline">done</strong> to <strong class="source-inline">true</strong> and finally, we replace the item in the items array with the changed item.</p>
			<p>Even though this should make the test pass, it still fails. Click the red diamond next to the failure message to expand it. Read the message carefully. The test fails because the two arrays are not the same. The to-do item in the result array has another value in the <strong class="source-inline">done</strong> property.</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_6.01_B18127.jpg" alt="Figure 6.1 – Expanded failure message telling us that the items are different&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Expanded failure message telling us that the items are different</p>
			<p>This makes sense. By adding the <strong class="source-inline">done</strong> property, we changed how Swift figures out whether two to-do items are the same. This is not what we want. A to-do item should have an identity.</p>
			<ol>
				<li value="7">Let's add <a id="_idIndexMarker181"/>a property that provides the to-do item with an identity. Open <strong class="source-inline">ToDoItem.swift</strong> and replace the <strong class="source-inline">ToDoItem</strong> structure with the following code:<p class="source-code">// ToDoItem.swift</p><p class="source-code">struct ToDoItem: Equatable {</p><p class="source-code">  let id: UUID</p><p class="source-code">  let title: String</p><p class="source-code">  let itemDescription: String?</p><p class="source-code">  let timestamp: TimeInterval?</p><p class="source-code">  let location: Location?</p><p class="source-code">  var done = false</p><p class="source-code">  init(title: String,</p><p class="source-code">       itemDescription: String? = nil,</p><p class="source-code">       timestamp: TimeInterval? = nil,</p><p class="source-code">       location: Location? = nil) {</p><p class="source-code">    self.id = UUID()</p><p class="source-code">    self.title = title</p><p class="source-code">    self.itemDescription = itemDescription</p><p class="source-code">    self.timestamp = timestamp</p><p class="source-code">    self.location = location</p><p class="source-code">  }</p><p class="source-code">  static func == (lhs: ToDoItem, rhs: ToDoItem) -&gt;</p><p class="source-code"> Bool {</p><p class="source-code">    return lhs.id == rhs.id</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>With this code, we add an ID that is set when an item is created. In addition, we use this <strong class="source-inline">id</strong> property to figure out whether two to-do items are the same.</p>
			<ol>
				<li value="8">Run the tests. All tests pass.</li>
				<li>Before we <a id="_idIndexMarker182"/>move on, we have to clean up the tests a bit. In the first line of each test, we create the system under test (<strong class="source-inline">sut</strong>). This code should be put into <strong class="source-inline">setUpWithError()</strong>. First, add the following property to <strong class="source-inline">ToDoItemStoreTests</strong>:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">var sut: ToDoItemStore!</p></li>
				<li>Next, change <strong class="source-inline">setUpWithError()</strong> and <strong class="source-inline">tearDownWithError()</strong> like this:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">override func setUpWithError() throws {</p><p class="source-code">  sut = ToDoItemStore()</p><p class="source-code">}</p><p class="source-code">override func tearDownWithError() throws {</p><p class="source-code">  sut = nil</p><p class="source-code">}</p></li>
				<li>Now we <a id="_idIndexMarker183"/>can remove the following line of code from each of the tests:<p class="source-code">let sut = ToDoItemStore()</p></li>
			</ol>
			<p>This makes the tests easier to understand.</p>
			<p>We can now add and check to-do items using our <strong class="source-inline">ToDoItemStore</strong>. But at the moment, the to-do items are only held in memory as long as the app runs. <strong class="source-inline">ToDoItemStore</strong> needs to store the to-do items somewhere and load them into memory as soon as the app starts again. In the next section, we will implement exactly this.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor171"/>Storing and loading ToDoItems</h1>
			<p>To test storing <a id="_idIndexMarker184"/>and loading to-do items, we first need to create an instance of the <strong class="source-inline">ToDoItemStore</strong> class, add a to-do item, destroy that store instance, and <a id="_idIndexMarker185"/>create a new one. When we add a to-do item in the first instance, all items should be stored in the filesystem. When creating the second instance, the stored items should be loaded again from the filesystem. This means when we find the item we added in the first instance after we created the second instance, storing and loading works.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor172"/>Implementing storing and loading</h2>
			<p>It is essential <a id="_idIndexMarker186"/>that the test controls the environment <a id="_idIndexMarker187"/>needed for itself. This means for storing and loading to-do items, the test needs to control where the items are stored. For example, if we used Core Data to persist the to-do items, the test would be responsible for setting up a fake Core Data store just used for the test. In our app, we will store the to-do items in a JSON file. So, the test needs to control where the JSON file is stored. Let's see how this can be done:</p>
			<ol>
				<li value="1">Add the following test method code to <strong class="source-inline">ToDoItemStore</strong>:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_init_shouldLoadPreviousToDoItems() {</p><p class="source-code">  var sut1: ToDoItemStore? = </p><p class="source-code">    ToDoItemStore(fileName: "dummy_store")</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we don't use the instance created in <strong class="source-inline">setUpWithError()</strong> because we need to pass in the name of the store to be used. Xcode complains that we <a id="_idIndexMarker188"/>passed an argument to a call that <a id="_idIndexMarker189"/>takes no arguments. This means we have to pause writing the test code and switch to the production code. </p>
			<ol>
				<li value="2">Add the following initializer to <strong class="source-inline">ToDoItemStore</strong>:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">init(fileName: String = "todoitems") {</p><p class="source-code">}</p></li>
			</ol>
			<p>This is enough to make the test compile again. This initializer allows passing the filename for the JSON file into <strong class="source-inline">ToDoItemStore</strong>. The <strong class="source-inline">fileName</strong> parameter has a default value because in the production code, the <strong class="source-inline">ToDoItemStore</strong> class should control where the file is stored. </p>
			<ol>
				<li value="3">Now we can write the rest of the test code:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_init_shouldLoadPreviousToDoItems() {</p><p class="source-code">  var sut1: ToDoItemStore? =</p><p class="source-code">    ToDoItemStore(fileName: "dummy_store")</p><p class="source-code">  let publisherExpectation = expectation(</p><p class="source-code">    description: "Wait for publisher in \(#file)"</p><p class="source-code">  )</p><p class="source-code"> </p><p class="source-code">  let toDoItem = ToDoItem(title: "Dummy Title")</p><p class="source-code">  sut1?.add(toDoItem)</p><p class="source-code">  sut1 = nil</p><p class="source-code">  let sut2 = ToDoItemStore(fileName: "dummy_store")</p><p class="source-code">  var result: [ToDoItem]?</p><p class="source-code">  let token = sut2.itemPublisher</p><p class="source-code">    .sink { value in</p><p class="source-code">      result = value</p><p class="source-code">      publisherExpectation.fulfill()</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">  wait(for: [publisherExpectation], timeout: 1)</p><p class="source-code">  token.cancel()</p><p class="source-code">  XCTAssertEqual(result, [toDoItem])</p><p class="source-code">}</p></li>
			</ol>
			<p>This code <a id="_idIndexMarker190"/>looks a bit intimidating, but it <a id="_idIndexMarker191"/>only contains concepts we've already covered. Let's go over that code step by step:</p>
			<ol>
				<li>We create an instance of <strong class="source-inline">ToDoItemStore</strong> and a test expectation. </li>
				<li>Next, we add an item to the to-do item store and destroy the store by setting it to nil. </li>
				<li>Then, we create a new to-do item store and subscribe to its <strong class="source-inline">itemPublisher</strong>. But this time, we do not drop the first published value from the publisher. As the publisher is a <strong class="source-inline">CurrentValueSubject</strong> structure, the subscriber receives the current value as soon as it subscribes to the publisher. </li>
				<li>Finally, we wait for the asynchronous execution of the Combine code and assert that the published items array contains the item we added to the initial to-do item store.</li>
			</ol>
			<p>Run the tests. This test fails, because we haven't implemented storing and loading yet. Let's implement the code.</p>
			<ol>
				<li value="4">We need <a id="_idIndexMarker192"/>to store the filename in a property <a id="_idIndexMarker193"/>and access it when we store and load the items. Add the following property and change the initializer to set that property:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">private let fileName: String</p><p class="source-code">init(fileName: String = "todoitems") {</p><p class="source-code">  self.fileName = fileName</p><p class="source-code">}</p></li>
				<li>The next step is to make <strong class="source-inline">ToDoItem</strong> convertible to JSON format. Swift can do this for us if all the properties of a type are convertible to JSON. The only thing we as the developer have to do is to add the <strong class="source-inline">Codable</strong> protocol to the type. Change the declaration of <strong class="source-inline">ToDoItem</strong> such that it reads like this:<p class="source-code">// ToDoItem.swift</p><p class="source-code">struct ToDoItem: Equatable, Codable {</p></li>
				<li>Xcode complains that <strong class="bold">Type 'ToDoItem' does not conform to 'Decodable'</strong>. The reason for this is that the <strong class="source-inline">Location</strong> property does not conform to <strong class="source-inline">Codable</strong> yet. Change the declaration of <strong class="source-inline">Location</strong> to the following:<p class="source-code">// Location.swift</p><p class="source-code">struct Location: Equatable, Codable {</p></li>
			</ol>
			<p>Now Xcode tells us that <strong class="source-inline">Location</strong> does not conform to <strong class="source-inline">Codable</strong>. Oh, bummer! <strong class="source-inline">CLLocationCoordinate2D</strong> does not conform to <strong class="source-inline">Codable</strong>. We could implement <a id="_idIndexMarker194"/>the conformance ourselves, but <a id="_idIndexMarker195"/>there is an easier way. We create a <strong class="source-inline">Coordinate</strong> struct that serves the same purpose but is <strong class="source-inline">Codable</strong>. Create a new Swift file with the <em class="italic">⌘</em><em class="italic">N</em> shortcut and call it <strong class="source-inline">Coordinate</strong>. Set <strong class="bold">Group</strong> to <strong class="bold">ToDo</strong> and make sure that it is added to the <strong class="bold">ToDo</strong> target.</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_6.02_B18127.jpg" alt="Figure 6.2 – Creating a file for the Coordinate structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Creating a file for the Coordinate structure</p>
			<ol>
				<li value="7">Add the following code to the new file:<p class="source-code">// Coordinate.swift</p><p class="source-code">struct Coordinate: Codable {</p><p class="source-code">  let latitude: Double</p><p class="source-code">  let longitude: Double</p><p class="source-code">}</p></li>
			</ol>
			<p>As Double is Codable, a structure only consisting of Double properties is also Codable. </p>
			<ol>
				<li value="8">Now we can replace the CLLocationCoordinate2D type in Location with our new Coordinate type:<p class="source-code">// Location.swift</p><p class="source-code">struct Location: Equatable, Codable {</p><p class="source-code">  let name: String</p><p class="source-code">  let coordinate: Coordinate?</p><p class="source-code"> </p><p class="source-code">  init(name: String,</p><p class="source-code">       coordinate: Coordinate? = nil) {</p><p class="source-code"> </p><p class="source-code">    self.name = name</p><p class="source-code">    self.coordinate = coordinate</p><p class="source-code">  }</p><p class="source-code">  // …</p><p class="source-code">}</p></li>
			</ol>
			<p>With this change, we no longer depend on Core Location and can remove its import from <strong class="source-inline">Location.swift</strong>.</p>
			<p>We have <a id="_idIndexMarker196"/>changed some code. How do we make sure <a id="_idIndexMarker197"/>that everything we implemented before still works? With our tests! To do that, we first have to disable the currently failing test because of the incomplete implementation of storing and loading to-do items. We know that this test still fails because we are not finished with the implementation. We only want to run the tests that were green before we started implementing storing and loading. Let's get started: </p>
			<ol>
				<li value="1">Go to <strong class="source-inline">ToDoItemStoreTests</strong> and add the following call of <strong class="source-inline">XCTSkipIf(_:_:)</strong> at the beginning of the test. Note that you also have to add the <strong class="source-inline">throws</strong> keyword to the test signature:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">func test_init_shouldLoadPreviousToDoItems() throws {</p><p class="source-code">    try XCTSkipIf(true, "Just test Coordinate change")</p><p class="source-code">    // …</p><p class="source-code">}</p></li>
			</ol>
			<p>With this call, we tell the test runner that it should skip this test. When we are done with the change of the coordinate type, we just have to remove this line of code to activate the test again.</p>
			<ol>
				<li value="2">Run the <a id="_idIndexMarker198"/>tests to figure out whether the <a id="_idIndexMarker199"/>coordinate change was successful or whether we missed something. The <strong class="source-inline">test_init_setsCoordinate()</strong> test does not compile because we changed the coordinate type. Replace the <strong class="source-inline">CLLocationCoordinate2D</strong> type with <strong class="source-inline">Coordinate</strong> and remove the import of <strong class="source-inline">CoreLocation</strong>:<p class="source-code">// LocationTests.swift</p><p class="source-code">func test_init_setsCoordinate() throws {</p><p class="source-code">  let coordinate = Coordinate(latitude: 1,</p><p class="source-code">    longitude: 2)</p><p class="source-code">  let location = Location(name: "",</p><p class="source-code">    coordinate: coordinate)</p><p class="source-code">  let resultCoordinate = try</p><p class="source-code"> XCTUnwrap(location.coordinate)</p><p class="source-code">  XCTAssertEqual(resultCoordinate.latitude, 1,</p><p class="source-code">    accuracy: 0.000_001)</p><p class="source-code">  XCTAssertEqual(resultCoordinate.longitude, 2,</p><p class="source-code">    accuracy: 0.000_001)</p><p class="source-code">}</p></li>
				<li>Run the tests again. Now all tests pass.</li>
			</ol>
			<p>This is huge! For the first time, we used unit tests to make refactoring easier. We didn't have to <a id="_idIndexMarker200"/>check each and every file to see whether the <a id="_idIndexMarker201"/>coordinate property was used and whether we had to adapt the type. We just had to run the tests. Now imagine we're working on a code base with hundreds of thousands of lines of code. The confidence you gain with a good test suite makes refactoring code effortless.</p>
			<p>Go back to <strong class="source-inline">ToDoItemStoreTests</strong> and remove the <strong class="source-inline">XCTSkipIf(_:_:)</strong> call. Run the tests to confirm that <strong class="source-inline">test_init_shouldLoadPreviousToDoItems()</strong> still fails.</p>
			<p>Now that <strong class="source-inline">ToDoItem</strong> conforms to <strong class="source-inline">Codable</strong>, we can store a list of to-do items in a JSON structure: </p>
			<ol>
				<li value="1">Add the following method to <strong class="source-inline">ToDoItemStore</strong>:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">private func saveItems() {</p><p class="source-code">  if let url = FileManager.default</p><p class="source-code">      .urls(for: .documentDirectory,</p><p class="source-code">               in: .userDomainMask)</p><p class="source-code">      .first?</p><p class="source-code">      .appendingPathComponent(fileName) {</p><p class="source-code">    do {</p><p class="source-code">      let data = try JSONEncoder().encode(items)</p><p class="source-code">      try data.write(to: url)</p><p class="source-code">    } catch {</p><p class="source-code">      print("error: \(error)")</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>First, we get a file URL to store the JSON file to. Next, we get a <strong class="source-inline">Data</strong> object from the to-do items and write it to the file URL. As the conversion to JSON and writing to the file URL can throw an error, we embedded these calls into a <strong class="source-inline">do-catch</strong> block.</p>
			<ol>
				<li value="2">The items <a id="_idIndexMarker202"/>need to be saved whenever <a id="_idIndexMarker203"/>something in the list of to-do items changes. Change the <strong class="source-inline">add(_:)</strong> method such that it looks like this:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">func add(_ item: ToDoItem) {</p><p class="source-code">  items.append(item)</p><p class="source-code">  saveItems()</p><p class="source-code">}</p></li>
				<li>When we add a new item to the store, we save the list to the filesystem. We also need a method that loads the to-do items. Add the following method to <strong class="source-inline">ToDoItemStore</strong>:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">private func loadItems() {</p><p class="source-code">  if let url = FileManager.default</p><p class="source-code">      .urls(for: .documentDirectory,</p><p class="source-code">               in: .userDomainMask)</p><p class="source-code">      .first?</p><p class="source-code">      .appendingPathComponent(fileName) {</p><p class="source-code">    do {</p><p class="source-code">      let data = try Data(contentsOf: url)</p><p class="source-code">      items = try JSONDecoder()</p><p class="source-code">        .decode([ToDoItem].self, from: data)</p><p class="source-code">    } catch {</p><p class="source-code">      print("error: \(error)")</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method is the reverse of the <strong class="source-inline">saveItems</strong> method. We get the same file URL in <a id="_idIndexMarker204"/>the beginning. Then, we load the data <a id="_idIndexMarker205"/>from the filesystem and convert it from the JSON format to a list of to-do items.</p>
			<ol>
				<li value="4">We call this method in the initializer of <strong class="source-inline">ToDoItemStore</strong>:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">init(fileName: String = "todoitems") {</p><p class="source-code">  self.fileName = fileName</p><p class="source-code">  loadItems()</p><p class="source-code">}</p></li>
			</ol>
			<p>That should make our test green. Run the tests to confirm.</p>
			<p>Depending on your configuration, your tests might indeed be green. But most probably, some of the tests in <strong class="source-inline">ToDoItemStoreTests</strong> will fail. With storing and loading to-do items, the tests now depend on the tests that ran before. This is bad and should be avoided. When tests depend on the order in which they are executed, a test suite is not reliable. Tests can fail on some computers or in some environments. We need to fix this:</p>
			<ol>
				<li value="1">First, all tests should use a dummy JSON file. So, replace the setup code in <strong class="source-inline">ToDoItemStoreTests</strong> with this:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">override func setUpWithError() throws {</p><p class="source-code">  sut = ToDoItemStore(fileName: "dummy_store")</p><p class="source-code">}</p></li>
				<li>Second, we <a id="_idIndexMarker206"/>have to remove the JSON file <a id="_idIndexMarker207"/>after each test execution:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">override func tearDownWithError() throws {</p><p class="source-code">  sut = nil</p><p class="source-code">  if let url = FileManager.default</p><p class="source-code">      .urls(for: .documentDirectory,</p><p class="source-code">               in: .userDomainMask)</p><p class="source-code">      .first?</p><p class="source-code">      .appendingPathComponent("dummy_store") {</p><p class="source-code">    try? FileManager.default.removeItem(at: url)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>I know what you are thinking. We used the code to get the file URL for the JSON file a third time. We should clean that up. No worries, we will do that next.</p>
			<p>Run all tests twice. In the second run, all tests should be green.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor173"/>Cleaning up the code</h2>
			<p>In software <a id="_idIndexMarker208"/>development, we should follow the DRY <a id="_idIndexMarker209"/>principle. <strong class="bold">DRY</strong> stands for <strong class="bold">don't repeat yourself</strong>. By copying the code that creates the file URL for the JSON file two times, we violated this principle. Let's make this code reusable.</p>
			<p>Select the <strong class="bold">ToDo</strong> group in Project Navigator in Xcode and add a new Swift file (<strong class="bold">iOS</strong> | <strong class="bold">Source</strong> | <strong class="bold">Swift File</strong>). Call the file <strong class="source-inline">FileManagerExtension.swift</strong> and make sure it is added to the main target of our project.</p>
			<p>Follow these steps to remove the duplicated code:</p>
			<ol>
				<li value="1">Add this extension to <strong class="source-inline">FileManagerExtension.swift</strong>:<p class="source-code">// FileManagerExtension.swift</p><p class="source-code">extension FileManager {</p><p class="source-code">  func documentsURL(name: String) -&gt; URL {</p><p class="source-code">    guard let documentsURL = urls(for:</p><p class="source-code">      .documentDirectory,</p><p class="source-code">    in: .userDomainMask).first else {</p><p class="source-code">      fatalError()</p><p class="source-code">    }</p><p class="source-code">    return documentsURL.appendingPathComponent(name)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Open <strong class="source-inline">ToDoItemStore.swift</strong> and replace <strong class="source-inline">saveItems()</strong> with the following implementation:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">private func saveItems() {</p><p class="source-code">  let url = FileManager.default</p><p class="source-code">    .documentsURL(name: fileName)</p><p class="source-code">  do {</p><p class="source-code">    let data = try JSONEncoder().encode(items)</p><p class="source-code">    try data.write(to: url)</p><p class="source-code">  } catch {</p><p class="source-code">    print("error: \(error)")</p><p class="source-code">  }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">Usually, you wouldn't use the <strong class="source-inline">FileManager</strong> singleton directly here. In real code, you would rather <a id="_idIndexMarker210"/>pass in the kind of storage into the <strong class="source-inline">ToDoItemStore</strong> as a dependency using Dependency Injection. We take the approach above to keep the book as short as possible and to not distract from the main topic of this section.</p></li>
				<li>Next, replace <strong class="source-inline">loadItems()</strong> with this code:<p class="source-code">// ToDoItemStore.swift</p><p class="source-code">private func loadItems() {</p><p class="source-code">  let url = FileManager.default</p><p class="source-code">    .documentsURL(name: fileName)</p><p class="source-code">  do {</p><p class="source-code">    let data = try Data(contentsOf: url)</p><p class="source-code">    items = try JSONDecoder()</p><p class="source-code">      .decode([ToDoItem].self, from: data)</p><p class="source-code">  } catch {</p><p class="source-code">    print("error: \(error)")</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Finally, replace <strong class="source-inline">tearDownWithError()</strong> in <strong class="source-inline">ToDoItemStoreTests.swift</strong> with the following code:<p class="source-code">// ToDoItemStoreTests.swift</p><p class="source-code">override func tearDownWithError() throws {</p><p class="source-code">  sut = nil  </p><p class="source-code">  let url = FileManager.default</p><p class="source-code">    .documentsURL(name: "dummy_store")</p><p class="source-code">  try? FileManager.default.removeItem(at: url)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to make sure they still pass.</p>
			<ol>
				<li value="5">We are <a id="_idIndexMarker211"/>not done yet. There is one test missing. When the user checks a to-do item as done, the list of items should also be written to the filesystem. To make sure that is the case, add the following test to <strong class="source-inline">ToDoItemStoreTests.swift</strong>:<p class="source-code">func test_init_whenItemIsChecked_</p><p class="source-code"> shouldLoadPreviousToDoItems() throws {</p><p class="source-code">  var sut1: ToDoItemStore? =</p><p class="source-code">  ToDoItemStore(fileName: "dummy_store")</p><p class="source-code">  let publisherExpectation = expectation(</p><p class="source-code">    description: "Wait for publisher in \(#file)"</p><p class="source-code">  )</p><p class="source-code"> </p><p class="source-code">  let toDoItem = ToDoItem(title: "Dummy Title")</p><p class="source-code">  sut1?.add(toDoItem)</p><p class="source-code">  sut1?.check(toDoItem)</p><p class="source-code">  sut1 = nil</p><p class="source-code">  let sut2 = ToDoItemStore(fileName: "dummy_store")</p><p class="source-code">  var result: [ToDoItem]?</p><p class="source-code">  let token = sut2.itemPublisher</p><p class="source-code">    .sink { value in</p><p class="source-code">      result = value</p><p class="source-code">      publisherExpectation.fulfill()</p><p class="source-code">    }</p><p class="source-code"> </p><p class="source-code">  wait(for: [publisherExpectation], timeout: 1)</p><p class="source-code">  token.cancel()</p><p class="source-code">  XCTAssertEqual(result?.first?.done, true)</p><p class="source-code">}</p></li>
			</ol>
			<p>This <a id="_idIndexMarker212"/>test looks kind of like <strong class="source-inline">test_init_shouldLoadPreviousToDoItems()</strong>. But here, we check <strong class="source-inline">toDoItem</strong> before we destroy the to-do item store. In addition, we assert at the end that the loaded to-do item is checked as done.</p>
			<ol>
				<li value="6">To make this test pass, add the call to <strong class="source-inline">saveItems()</strong> within the <strong class="source-inline">if let</strong> conditional of the <strong class="source-inline">check(_:)</strong> method:<p class="source-code">func check(_ item: ToDoItem) {</p><p class="source-code">  var mutableItem = item</p><p class="source-code">  mutableItem.done = true</p><p class="source-code">  if let index = items.firstIndex(of: item) {</p><p class="source-code">    items[index] = mutableItem</p><p class="source-code">    saveItems()</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Before <a id="_idIndexMarker213"/>you move on, make sure that all tests pass.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor174"/>Summary</h1>
			<p>In this chapter, we have explored how to test Combine code. To make the tests easier to understand, we introduced a helper method and improved its failure message. We figured out how to make an <strong class="source-inline">Equatable</strong> type and how this can help in unit tests. Finally, we learned how to test storing and loading a JSON file to and from the filesystem of the iOS device.</p>
			<p>With these skills, you should be able to write tests for a variety of different model scenarios. </p>
			<p>In the next chapter, we will start building the user interface. We will start with the list of to-do items.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor175"/>Exercises</h1>
			<ol>
				<li value="1">Remove the expectation from the tests that test Combine code and check whether they fail.</li>
				<li>Think about what needs to be done to check whether the stored file is indeed in JSON format. Do you think such a test is of any use?</li>
			</ol>
		</div>
	</body></html>