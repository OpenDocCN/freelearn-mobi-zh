<html><head></head><body>
<div id="_idContainer045" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-108"><a id="_idTextAnchor109" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-109" class="calibre5"><a id="_idTextAnchor110" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Creating a Photo Editor Using CameraX</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In the smartphone era, taking and sharing photos has become second nature, and platforms such as Instagram have shown us how powerful a single photo can be. </span><span class="kobospan" id="kobo.3.2">For apps like these, it’s not just about snapping a picture; it’s about enhancing and personalizing that image to tell a story. </span><span class="kobospan" id="kobo.3.3">But have you ever wondered what lies behind those in-app camera buttons </span><span><span class="kobospan" id="kobo.4.1">and filters?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">Enter CameraX, Android’s go-to tool for everything camera-related. </span><span class="kobospan" id="kobo.5.2">This tool doesn’t just make capturing photos seamless; it’s also the bridge to editing and refining them. </span><span class="kobospan" id="kobo.5.3">In this chapter, we’ll get hands-on with CameraX, discovering how it can transform the Packtagram photography experience. </span><span class="kobospan" id="kobo.5.4">We’ll also design an interactive space for users to tweak and enhance their shots, adding that personal touch. </span><span class="kobospan" id="kobo.5.5">And for the cherry on top? </span><span class="kobospan" id="kobo.5.6">We’ll dive into a bit of smart tech, teaching our app to recognize photo themes and suggest </span><span><span class="kobospan" id="kobo.6.1">relevant hashtags.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">Building on our prior work – crafting the screens and feed for our Instagram-inspired app – we’re now diving deeper into the app’s features. </span><span class="kobospan" id="kobo.7.2">With CameraX, intuitive editing tools, and some clever features, we’re set to elevate our app’s </span><span><span class="kobospan" id="kobo.8.1">photo-sharing game.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.9.1">In this chapter, we will cover the </span><span><span class="kobospan" id="kobo.10.1">following topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.11.1">Getting to </span><span><span class="kobospan" id="kobo.12.1">know CameraX</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.13.1">Integrating CameraX into our </span><span><span class="kobospan" id="kobo.14.1">Packtagram app</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.15.1">Adding </span><span><span class="kobospan" id="kobo.16.1">photo-editing functionalities</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.17.1">Using </span><strong class="bold"><span class="kobospan" id="kobo.18.1">machine learning</span></strong><span class="kobospan" id="kobo.19.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.20.1">ML</span></strong><span class="kobospan" id="kobo.21.1">) to categorize photos and </span><span><span class="kobospan" id="kobo.22.1">generate hashtags</span></span></li>
</ul>
<h1 id="_idParaDest-110" class="calibre5"><a id="_idTextAnchor111" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.23.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">As in the previous chapter, you will need to have Android Studio (or another editor of your </span><span><span class="kobospan" id="kobo.25.1">preference) installed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">You can find the complete code that we will be using in this chapter in this book’s GitHub </span><span><span class="kobospan" id="kobo.27.1">repository: </span></span><a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-5" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.28.1">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-5</span></span></a><span><span class="kobospan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-111" class="calibre5"><a id="_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.30.1">Getting to know CameraX</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">Since the inception of the Android</span><a id="_idIndexMarker526" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.32.1"> platform, cameras have played a pivotal role in defining the feature set of smartphones. </span><span class="kobospan" id="kobo.32.2">From capturing moments to enabling augmented reality experiences, the camera has evolved from a mere hardware component to a powerful tool for developers. </span><span class="kobospan" id="kobo.32.3">This evolution, however, has not been without </span><span><span class="kobospan" id="kobo.33.1">its complexities.</span></span></p>
<h2 id="_idParaDest-112" class="calibre7"><a id="_idTextAnchor113" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.34.1">The evolution of camera libraries in Android</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">Since the first version</span><a id="_idIndexMarker527" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.36.1"> of Android, developers interacted</span><a id="_idIndexMarker528" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.37.1"> with the camera hardware through the Camera API; this was Android’s first attempt at giving developers the power to harness the capabilities of </span><span><span class="kobospan" id="kobo.38.1">onboard cameras.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">As devices proliferated and features such as more advanced photo hardware grew, the need for a more robust API became evident. </span><span class="kobospan" id="kobo.39.2">Consequently, Camera2 API was introduced in API level 21 (Lollipop). </span><span class="kobospan" id="kobo.39.3">While this offered more granular control over camera capabilities and supported the expanding features of new hardware, its steep learning curve made camera development challenging for many in terms of complexity and </span><span><span class="kobospan" id="kobo.40.1">performance overhead.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">Given the intricacies of Camera2 and the variances in camera hardware across different devices, developers found it increasingly difficult to provide a consistent camera experience to end users. </span><span class="kobospan" id="kobo.41.2">This fragmentation, alongside the complexity of Camera2, made it imperative for a more streamlined, </span><span><span class="kobospan" id="kobo.42.1">developer-friendly solution.</span></span></p>
<p class="calibre3"><span><span class="kobospan" id="kobo.43.1">Enter CameraX.</span></span></p>
<h2 id="_idParaDest-113" class="calibre7"><a id="_idTextAnchor114" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.44.1">The importance and advantages of CameraX</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.45.1">CameraX</span></strong><span class="kobospan" id="kobo.46.1"> is Android’s modern solution for camera</span><a id="_idIndexMarker529" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.47.1"> app development that was developed</span><a id="_idIndexMarker530" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.48.1"> with the primary goal of simplifying the process while reducing the fragmentation between devices. </span><span class="kobospan" id="kobo.48.2">Here’s why it has quickly </span><span><span class="kobospan" id="kobo.49.1">become indispensable:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.50.1">Consistency across devices</span></strong><span class="kobospan" id="kobo.51.1">: CameraX abstracts the differences between device-specific camera behaviors, ensuring that most features work consistently across a wide range </span><span><span class="kobospan" id="kobo.52.1">of devices.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.53.1">Life cycle awareness</span></strong><span class="kobospan" id="kobo.54.1">: Gone are the days of tedious life cycle management. </span><span class="kobospan" id="kobo.54.2">CameraX is integrated with Android’s life cycle libraries, meaning less boilerplate code and more focus on core </span><span><span class="kobospan" id="kobo.55.1">camera functionality.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.56.1">Use case-based approach</span></strong><span class="kobospan" id="kobo.57.1">: Instead of dealing with low-level tasks, developers can now focus on specific use cases, such as image preview, image capture, and image analysis. </span><span class="kobospan" id="kobo.57.2">This makes development faster and </span><span><span class="kobospan" id="kobo.58.1">less error-prone.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.59.1">Extensions for enhanced capabilities</span></strong><span class="kobospan" id="kobo.60.1">: With the CameraX Extensions API, developers can access device-specific features such as portrait mode, HDR, and more, further enriching the </span><span><span class="kobospan" id="kobo.61.1">camera experience.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.62.1">Backward compatibility</span></strong><span class="kobospan" id="kobo.63.1">: CameraX offers compatibility with devices running Android 5.0 (API level 21) and beyond, ensuring a wider reach </span><span><span class="kobospan" id="kobo.64.1">than Camera2.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.65.1">Performance and quality</span></strong><span class="kobospan" id="kobo.66.1">: CameraX provides optimized performance out of the box, delivering high-quality images and videos without the need for </span><span><span class="kobospan" id="kobo.67.1">extra tuning.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.68.1">In summary, CameraX has not only simplified camera app development but also bridged the gap that’s caused by hardware discrepancies. </span><span class="kobospan" id="kobo.68.2">As we delve deeper into this chapter, you’ll come to appreciate the nuances and capabilities that CameraX brings to the table, setting the stage for powerful, consistent, and high-quality camera applications </span><span><span class="kobospan" id="kobo.69.1">on Android.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">Now, let’s start using CameraX and configuring its dependencies in </span><span><span class="kobospan" id="kobo.71.1">our project.</span></span></p>
<h2 id="_idParaDest-114" class="calibre7"><a id="_idTextAnchor115" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.72.1">Setting up CameraX</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">To set up CameraX, we need to add</span><a id="_idIndexMarker531" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.74.1"> the necessary dependencies to our version catalog file, </span><strong class="source-inline"><span class="kobospan" id="kobo.75.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.76.1">, </span><span><span class="kobospan" id="kobo.77.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.78.1">
[versions]
...
</span><span class="kobospan1" id="kobo.78.2">camerax = "1.2.1"
accompanist = "0.31.1-alpha"
[libraries]
...
</span><span class="kobospan1" id="kobo.78.3">cameraCore = { module = "androidx.camera:camera-core", version.ref = "camerax" }
cameraCamera2 = { module = "androidx.camera:camera-camera2", version.ref = "camerax" }
cameraView = { module = "androidx.camera:camera-view", version.ref = "camerax" }
cameraExtensions = { module = "androidx.camera:camera-extensions", version.ref = "camerax" }
accompanist = { group = "com.google.accompanist", name = "accompanist-permissions", version.ref = "accompanist"}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.79.1">In this code block, we are adding the dependencies that are needed to use CameraX, plus a library </span><span><span class="kobospan" id="kobo.80.1">called Accompanist.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.81.1">Accompanist</span></strong><span class="kobospan" id="kobo.82.1"> is a collection of extension</span><a id="_idIndexMarker532" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.83.1"> libraries that are designed to complement Jetpack Compose. </span><span class="kobospan" id="kobo.83.2">It fills the gaps by offering utilities for specific use cases and easing the integration of Compose with other Android capabilities. </span><span class="kobospan" id="kobo.83.3">The features of Accompanist include image loading integrations, useful components such as ViewPager, tools to manage system UI insets, Compose navigation enhancements, and permissions handling. </span><span class="kobospan" id="kobo.83.4">To learn more and expand on this information, please</span><a id="_idIndexMarker533" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.84.1"> refer to the official </span><span><span class="kobospan" id="kobo.85.1">documentation: </span></span><a href="https://google.github.io/accompanist/" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.86.1">https://google.github.io/accompanist/</span></span></a><span><span class="kobospan" id="kobo.87.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.88.1">In our case, we are going to use it to simplify the process of checking and asking the user for </span><span><span class="kobospan" id="kobo.89.1">camera permissions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.90.1">Regarding the dependencies to use CameraX, we are adding </span><span><span class="kobospan" id="kobo.91.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.92.1">cameraCore</span></strong><span class="kobospan" id="kobo.93.1">: This dependency provides the core functionality of CameraX, including the ability to manage camera devices, configure capture sessions, and receive frames from the camera. </span><span class="kobospan" id="kobo.93.2">It is the foundation for all other </span><span><span class="kobospan" id="kobo.94.1">CameraX dependencies.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.95.1">cameraCamera2</span></strong><span class="kobospan" id="kobo.96.1">: This dependency provides the Camera2 implementation of CameraX, which is the most powerful and flexible way to access the camera on Android devices. </span><span class="kobospan" id="kobo.96.2">It provides low-level access to the camera’s hardware and allows for custom capture configurations and </span><span><span class="kobospan" id="kobo.97.1">processing pipelines.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.98.1">cameraView</span></strong><span class="kobospan" id="kobo.99.1">: This dependency provides a pre-built view component that integrates with CameraX to simplify the process of displaying camera preview frames. </span><span class="kobospan" id="kobo.99.2">It takes care of the layout and setup of the view so that you can focus on capturing and processing the </span><span><span class="kobospan" id="kobo.100.1">camera data.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.101.1">cameraExtensions</span></strong><span class="kobospan" id="kobo.102.1">: This dependency provides a set of extensions for CameraX that add additional features, such as support for focus peaking, image stabilization, and panorama capture. </span><span class="kobospan" id="kobo.102.2">It also includes extensions for working with ML models on </span><span><span class="kobospan" id="kobo.103.1">camera frames.</span></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.104.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.105.1">The versions in the previous code are the latest stable ones at the time of writing this book, but there will likely be new ones by the time you are </span><span><span class="kobospan" id="kobo.106.1">reading this.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.107.1">After adding these dependencies</span><a id="_idIndexMarker534" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.108.1"> to the version catalog, we need to add them to the </span><strong class="source-inline"><span class="kobospan" id="kobo.109.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.110.1"> file of the </span><strong class="source-inline"><span class="kobospan" id="kobo.111.1">:feature:stories</span></strong><span class="kobospan" id="kobo.112.1"> module, </span><span><span class="kobospan" id="kobo.113.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.114.1">
    implementation(libs.cameraCore)
    implementation(libs.cameraCamera2)
    implementation(libs.cameraView)
    implementation(libs.cameraExtensions)
    implementation(libs.androidx.camera.lifecycle)
    implementation(libs.accompanist)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.115.1">Now that our project is ready</span><a id="_idIndexMarker535" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.116.1"> to use CameraX, let’s learn more about </span><span><span class="kobospan" id="kobo.117.1">the library.</span></span></p>
<h2 id="_idParaDest-115" class="calibre7"><a id="_idTextAnchor116" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.118.1">Learning about CameraX’s core concepts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.119.1">In this section, we’ll learn about some of CameraX’s most </span><span><span class="kobospan" id="kobo.120.1">important concepts.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.121.1">View life cycle</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.122.1">CameraX, a Jetpack support library, simplifies</span><a id="_idIndexMarker536" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.123.1"> camera development</span><a id="_idIndexMarker537" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.124.1"> across Android devices, and its life-cycle-aware nature seamlessly integrates with Jetpack Compose, empowering developers to create resilient and efficient camera applications. </span><span class="kobospan" id="kobo.124.2">At the core of CameraX’s design philosophy lies its inherent support for Android’s life cycle, which eliminates the complexities of managing camera resources. </span><span class="kobospan" id="kobo.124.3">CameraX automatically handles camera start, stop, and resource release based on life cycle events, streamlining the </span><span><span class="kobospan" id="kobo.125.1">development process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.126.1">Jetpack Compose, the declarative UI toolkit for Android, is also deeply rooted in life cycle concepts. </span><span class="kobospan" id="kobo.126.2">Composables inherently possess life cycle states, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.127.1">onActive</span></strong><span class="kobospan" id="kobo.128.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.129.1">onDispose</span></strong><span class="kobospan" id="kobo.130.1">, that get triggered during their existence within the UI hierarchy. </span><span class="kobospan" id="kobo.130.2">Combining the powers of CameraX and Compose offers a harmonized approach to managing the camera’s life cycle within Composable </span><span><span class="kobospan" id="kobo.131.1">UI components.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.132.1">Image analysis</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.133.1">CameraX goes beyond</span><a id="_idIndexMarker538" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.134.1"> just capturing</span><a id="_idIndexMarker539" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.135.1"> images. </span><span class="kobospan" id="kobo.135.2">With </span><strong class="bold"><span class="kobospan" id="kobo.136.1">image analysis</span></strong><span class="kobospan" id="kobo.137.1">, developers can process live camera feeds in real time. </span><span class="kobospan" id="kobo.137.2">This is perfect for features such as barcode scanning, face detection, or even applying live filters. </span><span class="kobospan" id="kobo.137.3">Here is </span><span><span class="kobospan" id="kobo.138.1">an example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.139.1">
@Composable
fun CameraPreviewWithImageAnalysis() {
    val cameraProvider = rememberCameraProvider()
    val preview = remember { Preview.Builder().build() }
    val text = remember { mutableStateOf("Analyzing...") }
    val imageAnalyzer = ImageAnalysis.Builder()
        .setAnalyzer { image -&gt;
            // Process the image data here
            text.value = "Detected image to analyze..."
</span><span class="kobospan1" id="kobo.139.2">        }
        .build()
    LaunchedEffect(cameraProvider) {
        val useCaseBinding = UseCaseBinding.Builder()
            .addUseCases(preview, imageAnalyzer)
            .build()
        val camera =
            cameraProvider.bindToLifecycle(useCaseBinding)
        camera.close()
    }
    Box(modifier = Modifier.fillMaxSize()) {
        Preview(preview)
        Text(text.value)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.140.1">The preceding code defines a composable function called </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">CameraPreviewWithImageAnalysis</span></strong><span class="kobospan" id="kobo.142.1"> that displays a camera preview and analyzes the live camera feed, utilizing Jetpack Compose and CameraX to </span><span><span class="kobospan" id="kobo.143.1">achieve this.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.144.1">First, the </span><strong class="source-inline"><span class="kobospan" id="kobo.145.1">rememberCameraProvider</span></strong><span class="kobospan" id="kobo.146.1"> function is used to retrieve the camera provider instance, which is responsible for managing the camera’s life cycle and providing access to camera controls. </span><span class="kobospan" id="kobo.146.2">Then, a </span><strong class="source-inline"><span class="kobospan" id="kobo.147.1">Preview</span></strong><span class="kobospan" id="kobo.148.1"> instance is created using </span><strong class="source-inline"><span class="kobospan" id="kobo.149.1">Preview.Builder</span></strong><span class="kobospan" id="kobo.150.1"> to define the camera preview surface. </span><span class="kobospan" id="kobo.150.2">This preview will display the live camera feed on </span><span><span class="kobospan" id="kobo.151.1">the screen.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.152.1">After that, an </span><strong class="source-inline"><span class="kobospan" id="kobo.153.1">ImageAnalysis</span></strong><span class="kobospan" id="kobo.154.1"> instance is created using </span><strong class="source-inline"><span class="kobospan" id="kobo.155.1">ImageAnalysis.Builder</span></strong><span class="kobospan" id="kobo.156.1"> to process the live camera feed. </span><span class="kobospan" id="kobo.156.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.157.1">setAnalyzer</span></strong><span class="kobospan" id="kobo.158.1"> method is used to specify an analyzer function that will be called whenever a new image frame </span><span><span class="kobospan" id="kobo.159.1">is available.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.160.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.161.1">LaunchedEffect</span></strong><span class="kobospan" id="kobo.162.1"> block is used to start a coroutine that binds the camera preview and image analyzer to the camera’s life cycle. </span><span class="kobospan" id="kobo.162.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.163.1">bindToLifecycle</span></strong><span class="kobospan" id="kobo.164.1"> method is used to connect the use cases to the camera’s life cycle, ensuring that they start and stop automatically when the app starts </span><span><span class="kobospan" id="kobo.165.1">and stops.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.166.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">mutableStateOf</span></strong><span class="kobospan" id="kobo.168.1"> variable text is used to store the current state of the analysis. </span><span class="kobospan" id="kobo.168.2">The text variable is updated within the analyzer function to reflect the results of the </span><span><span class="kobospan" id="kobo.169.1">image analysis.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.170.1">Finally, the </span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">Box</span></strong><span class="kobospan" id="kobo.172.1"> composable</span><a id="_idIndexMarker540" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.173.1"> is used to lay out the camera</span><a id="_idIndexMarker541" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.174.1"> preview and the text. </span><span class="kobospan" id="kobo.174.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.175.1">fillMaxSize</span></strong><span class="kobospan" id="kobo.176.1"> modifier is used to make </span><strong class="source-inline"><span class="kobospan" id="kobo.177.1">Box</span></strong><span class="kobospan" id="kobo.178.1"> occupy the entire screen. </span><span class="kobospan" id="kobo.178.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.179.1">Preview</span></strong><span class="kobospan" id="kobo.180.1"> composable is placed inside </span><strong class="source-inline"><span class="kobospan" id="kobo.181.1">Box</span></strong><span class="kobospan" id="kobo.182.1"> to display the camera preview. </span><span class="kobospan" id="kobo.182.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">Text</span></strong><span class="kobospan" id="kobo.184.1"> composable is also placed inside </span><strong class="source-inline"><span class="kobospan" id="kobo.185.1">Box</span></strong><span class="kobospan" id="kobo.186.1"> to display the current state of </span><span><span class="kobospan" id="kobo.187.1">the analysis.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.188.1">This is a basic example of how to apply image analysis, but there are some already existing image analyzers, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">BarcodeScanner</span></strong><span class="kobospan" id="kobo.190.1">. </span><span class="kobospan" id="kobo.190.2">The following code is built upon the previous one, adding </span><span><span class="kobospan" id="kobo.191.1">this analyzer:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.192.1">
@Composable
fun BarcodeScannerPreview() {
    val cameraProvider = rememberCameraProvider()
    val preview = remember { Preview.Builder().build() }
    val barcodeText = remember { mutableStateOf("") }
    val barcodeScanner = BarcodeScanner.Builder()
        .setBarcodeFormats(BarcodeScannerOptions.
</span><span class="kobospan1" id="kobo.192.2">            BarcodeFormat.ALL_FORMATS)
        .build()
    LaunchedEffect(cameraProvider) {
        val imageAnalyzer = ImageAnalysis.Builder()
            .setAnalyzer { image -&gt;
                val rotation =
                    image.imageInfo.rotationDegrees
                val imageProxy =
                    InputImage.fromMediaImage(image.image,
                        rotation)
                barcodeScanner.processImage(imageProxy)
                    .addOnSuccessListener { barcodes -&gt;
                        if (barcodes.isNotEmpty()) {
                            val barcode = barcodes[0]
                            barcodeText.value =
                                barcode.displayValue
                        } else {
                            barcodeText.value = "No barcode
                                detected"
                        }
                    }
                    .addOnFailureListener { e -&gt;
                        barcodeText.value = "Barcode
                            scanning failed: ${e.message}"
                    }
            }
            .build()
        val useCaseBinding = UseCaseBinding.Builder()
            .addUseCases(preview, imageAnalyzer)
            .build()
        val camera =
            cameraProvider.bindToLifecycle(useCaseBinding)
        camera.close()
    }
    Box(modifier = Modifier.fillMaxSize()) {
        Preview(preview)
        Text(barcodeText.value)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.193.1">Similar to the previous</span><a id="_idIndexMarker542" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.194.1"> example, this code</span><a id="_idIndexMarker543" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.195.1"> defines a composable function called </span><strong class="source-inline"><span class="kobospan" id="kobo.196.1">BarcodeScannerPreview</span></strong><span class="kobospan" id="kobo.197.1"> that displays a camera preview and analyzes the live camera feed for barcodes. </span><span class="kobospan" id="kobo.197.2">However, this code specifically focuses on barcode scanning and utilizes the ML Kit </span><strong class="source-inline"><span class="kobospan" id="kobo.198.1">BarcodeScanner</span></strong><span class="kobospan" id="kobo.199.1"> library to achieve </span><span><span class="kobospan" id="kobo.200.1">this functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.201.1">First, the </span><strong class="source-inline"><span class="kobospan" id="kobo.202.1">rememberCameraProvider</span></strong><span class="kobospan" id="kobo.203.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.204.1">Preview</span></strong><span class="kobospan" id="kobo.205.1"> functions are used in the same way as they were in the previous example to retrieve the camera provider instance and create a preview instance for displaying the live </span><span><span class="kobospan" id="kobo.206.1">camera feed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.207.1">Then, a </span><strong class="source-inline"><span class="kobospan" id="kobo.208.1">BarcodeScanner</span></strong><span class="kobospan" id="kobo.209.1"> instance is created using </span><strong class="source-inline"><span class="kobospan" id="kobo.210.1">BarcodeScanner.Builder</span></strong><span class="kobospan" id="kobo.211.1">, specifying the barcode formats to be detected. </span><span class="kobospan" id="kobo.211.2">In this case, all barcode formats are specified </span><span><span class="kobospan" id="kobo.212.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">BarcodeScannerOptions.BarcodeFormat.ALL_FORMATS</span></strong></span><span><span class="kobospan" id="kobo.214.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.215.1">Following this, an </span><strong class="source-inline"><span class="kobospan" id="kobo.216.1">ImageAnalysis</span></strong><span class="kobospan" id="kobo.217.1"> instance is created using </span><strong class="source-inline"><span class="kobospan" id="kobo.218.1">ImageAnalysis.Builder</span></strong><span class="kobospan" id="kobo.219.1">, and the analyzer function is defined to process each image frame. </span><span class="kobospan" id="kobo.219.2">First, the analyzer function retrieves the image rotation from the </span><strong class="source-inline"><span class="kobospan" id="kobo.220.1">imageInfo</span></strong><span class="kobospan" id="kobo.221.1"> object. </span><span class="kobospan" id="kobo.221.2">Then, it converts the </span><strong class="source-inline"><span class="kobospan" id="kobo.222.1">ImageProxy</span></strong><span class="kobospan" id="kobo.223.1"> instance into an </span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">InputImage</span></strong><span class="kobospan" id="kobo.225.1"> format that’s compatible with ML </span><span><span class="kobospan" id="kobo.226.1">Kit’s </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.227.1">BarcodeScanner</span></strong></span><span><span class="kobospan" id="kobo.228.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.229.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.230.1">BarcodeScanner.processImage</span></strong><span class="kobospan" id="kobo.231.1"> method is called on the </span><strong class="source-inline"><span class="kobospan" id="kobo.232.1">InputImage</span></strong><span class="kobospan" id="kobo.233.1"> instance to detect barcodes. </span><span class="kobospan" id="kobo.233.2">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.234.1">OnSuccessListener</span></strong><span class="kobospan" id="kobo.235.1"> is used to handle the successful barcode detection, while </span><strong class="source-inline"><span class="kobospan" id="kobo.236.1">OnFailureListener</span></strong><span class="kobospan" id="kobo.237.1"> is used to handle any errors that occur during </span><span><span class="kobospan" id="kobo.238.1">barcode scanning.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.239.1">If barcodes are detected, the </span><strong class="source-inline"><span class="kobospan" id="kobo.240.1">displayValue</span></strong><span class="kobospan" id="kobo.241.1"> value of the first barcode is extracted and stored in the </span><strong class="source-inline"><span class="kobospan" id="kobo.242.1">barcodeText</span></strong><span class="kobospan" id="kobo.243.1"> mutable state variable. </span><span class="kobospan" id="kobo.243.2">This variable is used to update the text field with the detected </span><span><span class="kobospan" id="kobo.244.1">barcode information.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.245.1">With this, we have</span><a id="_idIndexMarker544" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.246.1"> created our first image analyzer</span><a id="_idIndexMarker545" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.247.1"> to get barcode information. </span><span class="kobospan" id="kobo.247.2">Let’s move on to the next </span><span><span class="kobospan" id="kobo.248.1">feature: </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">CameraSelector</span></strong></span><span><span class="kobospan" id="kobo.250.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.251.1">CameraSelector</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.252.1">When dealing with cameras, it’s not always</span><a id="_idIndexMarker546" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.253.1"> about just one camera – many modern devices come with multiple camera lenses. </span><span class="kobospan" id="kobo.253.2">This is where </span><strong class="source-inline"><span class="kobospan" id="kobo.254.1">CameraSelector</span></strong><span class="kobospan" id="kobo.255.1"> comes to the rescue, allowing developers to programmatically choose between, say, the front or rear camera. </span><span class="kobospan" id="kobo.255.2">Whether you’re building a selfie app or a more standard photo application, </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">CameraSelector</span></strong><span class="kobospan" id="kobo.257.1"> ensures consistent behavior across the board. </span><span class="kobospan" id="kobo.257.2">Let’s see how we can allow a user to select which camera they want </span><span><span class="kobospan" id="kobo.258.1">to use:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.259.1">
@Composable
fun CameraSelectorExample() {
    val cameraProvider = rememberCameraProvider()
    val preview = remember { Preview.Builder().build() }
    val isUsingFrontCamera = remember {
        mutableStateOf(true) }
    val cameraSelector = remember {
        if (isUsingFrontCamera.value) {
            CameraSelector.DEFAULT_FRONT_CAMERA
        } else {
            CameraSelector.DEFAULT_BACK_CAMERA
        }
    }
    val imageAnalyzer = ImageAnalysis.Builder()
        .setAnalyzer { image -&gt;
            // Process the image data here
        }
        .build()
    LaunchedEffect(cameraProvider) {
        val useCaseBinding = UseCaseBinding.Builder()
            .addUseCases(preview, imageAnalyzer)
            .build()
        val camera =
            cameraProvider.bindToLifecycle(useCaseBinding)
        camera.close()
    }
    Box(modifier = Modifier.fillMaxSize()) {
        Preview(preview)
        Column {
            Button(onClick = {
                isUsingFrontCamera.value =
                    !isUsingFrontCamera.value
            }) {
                Text("Switch Camera")
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.260.1">The preceding code will display a camera preview and a button. </span><span class="kobospan" id="kobo.260.2">Clicking the button will switch between the front and rear cameras. </span><span class="kobospan" id="kobo.260.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.261.1">isUsingFrontCamera</span></strong><span class="kobospan" id="kobo.262.1"> mutable state variable is used to keep track of which camera is currently being used. </span><span class="kobospan" id="kobo.262.2">Then, </span><strong class="source-inline"><span class="kobospan" id="kobo.263.1">cameraSelector</span></strong><span class="kobospan" id="kobo.264.1"> is updated whenever the </span><strong class="source-inline"><span class="kobospan" id="kobo.265.1">isUsingFrontCamera</span></strong><span class="kobospan" id="kobo.266.1"> variable changes. </span><span class="kobospan" id="kobo.266.2">The camera preview is automatically updated to reflect the new </span><span><span class="kobospan" id="kobo.267.1">camera selection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.268.1">It’s also possible to provide your users</span><a id="_idIndexMarker547" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.269.1"> with more control over the camera functionality. </span><span class="kobospan" id="kobo.269.2">So, let’s talk </span><span><span class="kobospan" id="kobo.270.1">about </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.271.1">CameraControls</span></strong></span><span><span class="kobospan" id="kobo.272.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.273.1">CameraControls</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.274.1">A comprehensive camera experience</span><a id="_idIndexMarker548" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.275.1"> isn’t just about capturing or analyzing an image. </span><span class="kobospan" id="kobo.275.2">It’s also about control. </span><span class="kobospan" id="kobo.275.3">With </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">CameraControls</span></strong><span class="kobospan" id="kobo.277.1">, developers gain access to an array of functions that allow them to manipulate the camera feed. </span><span class="kobospan" id="kobo.277.2">From zooming into a subject and adjusting focus for that crystal-clear shot to toggling the torch for those night-time snaps, </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">CameraControls</span></strong><span class="kobospan" id="kobo.279.1"> ensures users always get the </span><span><span class="kobospan" id="kobo.280.1">perfect shot.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.281.1">Here is an example of how to use </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">CameraControls</span></strong><span class="kobospan" id="kobo.283.1"> to zoom, adjust focus, and toggle the torch, starting with the first part of </span><span><span class="kobospan" id="kobo.284.1">the code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.285.1">
@Composable
fun CameraControlsExample() {
    val cameraProvider = rememberCameraProvider()
    val preview = remember { Preview.Builder().build() }
    val zoomLevel = remember { mutableStateOf(1.0f) }
    val focusPoint = remember { mutableStateOf(0.5f, 0.5f) }
    val isTorchEnabled = remember { mutableStateOf(false) }
    val imageAnalyzer = ImageAnalysis.Builder()
        .setAnalyzer { image -&gt;
            // Process the image data here
        }
        .build()</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.286.1">In the preceding code, we are defining</span><a id="_idIndexMarker549" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.287.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">rememberCameraProvider</span></strong><span class="kobospan" id="kobo.289.1"> function, which is used to retrieve the camera provider instance. </span><span class="kobospan" id="kobo.289.2">It manages the camera’s life cycle and provides access to camera controls. </span><span class="kobospan" id="kobo.289.3">Then, </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">Preview.Builder()</span></strong><span class="kobospan" id="kobo.291.1"> is used to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">Preview</span></strong><span class="kobospan" id="kobo.293.1"> instance, which defines the surface on which the live camera feed will </span><span><span class="kobospan" id="kobo.294.1">be displayed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.295.1">Three </span><strong class="source-inline"><span class="kobospan" id="kobo.296.1">mutableStateOf</span></strong><span class="kobospan" id="kobo.297.1"> variables are used to store the state of the zoom level, focus point, and </span><span><span class="kobospan" id="kobo.298.1">torch status:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.299.1">zoomLevel</span></strong><span class="kobospan" id="kobo.300.1">: This stores the current zoom level, ranging from 1.0f (no zoom) to 5.0f (</span><span><span class="kobospan" id="kobo.301.1">maximum zoom)</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.302.1">focusPoint</span></strong><span class="kobospan" id="kobo.303.1">: This stores the current focus point, represented as a pair of coordinates (</span><em class="italic"><span class="kobospan" id="kobo.304.1">x</span></em><span class="kobospan" id="kobo.305.1">, </span><em class="italic"><span class="kobospan" id="kobo.306.1">y</span></em><span class="kobospan" id="kobo.307.1">) within the </span><span><span class="kobospan" id="kobo.308.1">preview frame</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.309.1">isTorchEnabled</span></strong><span class="kobospan" id="kobo.310.1">: This stores the current torch status, indicating whether the torch is enabled </span><span><span class="kobospan" id="kobo.311.1">or disabled</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.312.1">Let’s continue with the next part of </span><span><span class="kobospan" id="kobo.313.1">the code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.314.1">
    LaunchedEffect(cameraProvider) {
        val cameraControl =
            cameraProvider.getCameraControl(preview)
        cameraControl.setZoomRatio(zoomLevel.value)
        cameraControl.setFocusPoint(focusPoint.value)
        cameraControl.enableTorch(isTorchEnabled.value)
        val useCaseBinding = UseCaseBinding.Builder()
            .addUseCases(preview, imageAnalyzer)
            .build()
        val camera =
            cameraProvider.bindToLifecycle(useCaseBinding)
        camera.close()
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.315.1">Here, the </span><strong class="source-inline"><span class="kobospan" id="kobo.316.1">cameraControl.getCameraControl(preview)</span></strong><span class="kobospan" id="kobo.317.1"> method</span><a id="_idIndexMarker550" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.318.1"> retrieves the </span><strong class="source-inline"><span class="kobospan" id="kobo.319.1">CameraControl</span></strong><span class="kobospan" id="kobo.320.1"> instance associated with the preview. </span><span class="kobospan" id="kobo.320.2">This instance provides access to various </span><span><span class="kobospan" id="kobo.321.1">camera controls:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.322.1">cameraControl.setZoomRatio(zoomLevel.value)</span></strong><span class="kobospan" id="kobo.323.1">: This control sets the zoom level using the value stored in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.324.1">zoomLevel</span></strong></span><span><span class="kobospan" id="kobo.325.1"> variable</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.326.1">cameraControl.setFocusPoint(focusPoint.value)</span></strong><span class="kobospan" id="kobo.327.1">: This control sets the focus point using the coordinates stored in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.328.1">focusPoint</span></strong></span><span><span class="kobospan" id="kobo.329.1"> variable</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.330.1">cameraControl.enableTorch(isTorchEnabled.value)</span></strong><span class="kobospan" id="kobo.331.1">: This control enables or disables the torch based on the value stored in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.332.1">isTorchEnabled</span></strong></span><span><span class="kobospan" id="kobo.333.1"> variable</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.334.1">Now, let’s move</span><a id="_idIndexMarker551" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.335.1"> on to the last chunk </span><span><span class="kobospan" id="kobo.336.1">of code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.337.1">
    Box(modifier = Modifier.fillMaxSize()) {
        Preview(preview)
        Column {
            Slider(
                value = zoomLevel.value,
                onValueChange = { zoomLevel.value = it },
                valueRange = 1.0f..5.0f,
                steps = 10
            ) {
                Text("Zoom")
            }
            Button(onClick = {
                val newFocusPoint = if (focusPoint.value ==
                0.5f) {
                    0.1f to 0.1f
                } else {
                    0.5f to 0.5f
                }
                focusPoint.value = newFocusPoint
                cameraControl.setFocusPoint(newFocusPoint)
            }) {
                Text("Adjust Focus")
            }
            Button(onClick = {
                isTorchEnabled.value =
                    !isTorchEnabled.value
                cameraControl.enableTorch(
                    isTorchEnabled.value)
            }) {
                Text("Toggle Torch")
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.338.1">In this last code block, the controls</span><a id="_idIndexMarker552" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.339.1"> are configured and used within the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.340.1">Column</span></strong></span><span><span class="kobospan" id="kobo.341.1"> layout:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.342.1">A </span><strong class="source-inline1"><span class="kobospan" id="kobo.343.1">Slider</span></strong><span class="kobospan" id="kobo.344.1"> component is used to adjust the zoom level. </span><span class="kobospan" id="kobo.344.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.345.1">valueRange</span></strong><span class="kobospan" id="kobo.346.1"> property defines the range of zoom levels (1.0f to 5.0f), and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.347.1">onValueChange</span></strong><span class="kobospan" id="kobo.348.1"> callback updates the </span><strong class="source-inline1"><span class="kobospan" id="kobo.349.1">zoomLevel</span></strong><span class="kobospan" id="kobo.350.1"> variable with the selected </span><span><span class="kobospan" id="kobo.351.1">zoom level.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.352.1">A </span><strong class="source-inline1"><span class="kobospan" id="kobo.353.1">Button</span></strong><span class="kobospan" id="kobo.354.1"> component triggers a change in the focus point. </span><span class="kobospan" id="kobo.354.2">When clicked, it updates the </span><strong class="source-inline1"><span class="kobospan" id="kobo.355.1">focusPoint</span></strong><span class="kobospan" id="kobo.356.1"> variable between two predefined locations (0.5f to 0.5f and 0.1f </span><span><span class="kobospan" id="kobo.357.1">to 0.1f).</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.358.1">Another </span><strong class="source-inline1"><span class="kobospan" id="kobo.359.1">Button</span></strong><span class="kobospan" id="kobo.360.1"> component toggles the torch status. </span><span class="kobospan" id="kobo.360.2">When clicked, it updates the </span><strong class="source-inline1"><span class="kobospan" id="kobo.361.1">isTorchEnabled</span></strong><span class="kobospan" id="kobo.362.1"> variable and calls </span><strong class="source-inline1"><span class="kobospan" id="kobo.363.1">cameraControl.enableTorch</span></strong><span class="kobospan" id="kobo.364.1"> to set the </span><span><span class="kobospan" id="kobo.365.1">torch accordingly.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.366.1">In conclusion, CameraX provides</span><a id="_idIndexMarker553" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.367.1"> a robust and versatile platform for developing high-quality camera applications on Android. </span><span class="kobospan" id="kobo.367.2">It offers a simplified API, streamlined use cases, and a comprehensive set of features, making it an ideal choice for building modern camera-centric apps. </span><span class="kobospan" id="kobo.367.3">Now, we are ready to use it in </span><span><span class="kobospan" id="kobo.368.1">our app.</span></span></p>
<h1 id="_idParaDest-116" class="calibre5"><a id="_idTextAnchor117" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.369.1">Integrating CameraX into our Packtagram app</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.370.1">Now that we know more</span><a id="_idIndexMarker554" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.371.1"> about CameraX, let’s start integrating</span><a id="_idIndexMarker555" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.372.1"> it into our app. </span><span class="kobospan" id="kobo.372.2">First, we will need to deal with the camera permissions, providing a way for the user to accept them. </span><span class="kobospan" id="kobo.372.3">Then, we will set up our camera preview and add the camera capture functionality to </span><span><span class="kobospan" id="kobo.373.1">our code.</span></span></p>
<h2 id="_idParaDest-117" class="calibre7"><a id="_idTextAnchor118" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.374.1">Setting up the permissions checker with Accompanist</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.375.1">There are several ways to check</span><a id="_idIndexMarker556" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.376.1"> if the camera permissions</span><a id="_idIndexMarker557" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.377.1"> have been granted, and if not, to request them: we could do this manually or use a library. </span><span class="kobospan" id="kobo.377.2">In this case, we will use the Accompanist library, as we introduced at the beginning of </span><span><span class="kobospan" id="kobo.378.1">this chapter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.379.1">Before requesting any permission at runtime, it’s fundamental to declare the same permissions in the app’s </span><strong class="source-inline"><span class="kobospan" id="kobo.380.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.381.1"> file. </span><span class="kobospan" id="kobo.381.2">This declaration informs the Android operating system of the app’s intentions. </span><span class="kobospan" id="kobo.381.3">For the camera permission, you need to add the following line within the </span><strong class="source-inline"><span class="kobospan" id="kobo.382.1">&lt;</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.383.1">manifest&gt;</span></strong></span><span><span class="kobospan" id="kobo.384.1"> tag:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.385.1">
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.386.1">While the manifest informs the system of the app’s needs, runtime permissions are about seeking the user’s explicit consent. </span><span class="kobospan" id="kobo.386.2">Ensure you always have both in place when accessing protected features or </span><span><span class="kobospan" id="kobo.387.1">user data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.388.1">Now, let’s go into the permissions checker code. </span><span class="kobospan" id="kobo.388.2">Our aim here is to create a reusable composable function that can handle the camera permission elegantly. </span><span class="kobospan" id="kobo.388.3">It should be able to request the permission, handle user</span><a id="_idIndexMarker558" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.389.1"> decisions, and, if necessary, explain</span><a id="_idIndexMarker559" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.390.1"> why the app needs </span><span><span class="kobospan" id="kobo.391.1">this permission.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.392.1">First, we need to import the </span><span><span class="kobospan" id="kobo.393.1">required libraries:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.394.1">
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.PermissionState
import com.google.accompanist.permissions.rememberPermissionState
@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun CameraPermissionRequester(onPermissionGranted: () -&gt; Unit) {
    // ... </span><span class="kobospan1" id="kobo.394.2">code ...
</span><span class="kobospan1" id="kobo.394.3">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.395.1">Here, the </span><strong class="source-inline"><span class="kobospan" id="kobo.396.1">@OptIn</span></strong><span class="kobospan" id="kobo.397.1"> annotation indicates that we’re using an experimental API from the Accompanist </span><span><span class="kobospan" id="kobo.398.1">permissions library.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.399.1">Now, inside </span><strong class="source-inline"><span class="kobospan" id="kobo.400.1">CameraPermissionRequester</span></strong><span class="kobospan" id="kobo.401.1">, we need to add </span><span><span class="kobospan" id="kobo.402.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.403.1">
val cameraPermissionState = rememberPermissionState(Manifest.permission.CAMERA)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.404.1">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.405.1">rememberPermissionState</span></strong><span class="kobospan" id="kobo.406.1"> is a helper function that recalls the current state of the camera permission. </span><span class="kobospan" id="kobo.406.2">It provides information such as whether the permission is granted, if we’ve already asked the user, or if we should show </span><span><span class="kobospan" id="kobo.407.1">a rationale.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.408.1">With the permission state in hand, we can create a UI flow that responds to </span><span><span class="kobospan" id="kobo.409.1">this state:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.410.1">Permission granted</span></strong><span class="kobospan" id="kobo.411.1">: If permission is already granted, the user can directly proceed to use </span><span><span class="kobospan" id="kobo.412.1">the camera.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.413.1">Show rationale</span></strong><span class="kobospan" id="kobo.414.1">: Sometimes, if a user denies a certain permission, it’s helpful to explain why the app needs that permission. </span><span class="kobospan" id="kobo.414.2">This is where the rationale comes </span><span><span class="kobospan" id="kobo.415.1">into play.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.416.1">Permission not yet requested</span></strong><span class="kobospan" id="kobo.417.1">: If the app hasn’t asked for the permission yet, we want to provide a button to initiate </span><span><span class="kobospan" id="kobo.418.1">the request.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.419.1">Permission denied without rationale</span></strong><span class="kobospan" id="kobo.420.1">: In some cases, users deny permissions and opt not to be asked again. </span><span class="kobospan" id="kobo.420.2">It’s good practice to guide them to the app settings if they change </span><span><span class="kobospan" id="kobo.421.1">their mind.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.422.1">Let’s learn how to handle</span><a id="_idIndexMarker560" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.423.1"> all these possible flows. </span><span class="kobospan" id="kobo.423.2">First, we will create</span><a id="_idIndexMarker561" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.424.1"> a new composable called </span><strong class="source-inline"><span class="kobospan" id="kobo.425.1">CameraPermissionRequester</span></strong><span class="kobospan" id="kobo.426.1">. </span><span class="kobospan" id="kobo.426.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.427.1">onPermissionGranted</span></strong><span class="kobospan" id="kobo.428.1"> callback is provided to handle the scenario when the camera permission has </span><span><span class="kobospan" id="kobo.429.1">been granted:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.430.1">
@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun CameraPermissionRequester(onPermissionGranted:
@Composable () -&gt; Unit) {</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.431.1">Next, we will </span><span><span class="kobospan" id="kobo.432.1">retrieve </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.433.1">cameraPermissionState</span></strong></span><span><span class="kobospan" id="kobo.434.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.435.1">
    // Camera permission state
    val cameraPermissionState = rememberPermissionState(
        android.Manifest.permission.CAMERA
    )</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.436.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.437.1">rememberPermissionState(permission)</span></strong><span class="kobospan" id="kobo.438.1"> function retrieves the current state of the specified permission. </span><span class="kobospan" id="kobo.438.2">In this case, we’re checking the status of the </span><strong class="source-inline"><span class="kobospan" id="kobo.439.1">CAMERA</span></strong><span class="kobospan" id="kobo.440.1"> permission, which is necessary for accessing the device’s camera. </span><span class="kobospan" id="kobo.440.2">The result is stored in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.441.1">cameraPermissionState</span></strong></span><span><span class="kobospan" id="kobo.442.1"> variable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.443.1">Now, let’s evaluate the different values it </span><span><span class="kobospan" id="kobo.444.1">could have:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.445.1">
    if (cameraPermissionState.status.isGranted) {
        OnPermissionGranted.invoke()</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.446.1">In the previous code block, we are starting to evaluate the </span><strong class="source-inline"><span class="kobospan" id="kobo.447.1">status.isGranted</span></strong><span class="kobospan" id="kobo.448.1"> property of the </span><strong class="source-inline"><span class="kobospan" id="kobo.449.1">cameraPermissionState</span></strong><span class="kobospan" id="kobo.450.1"> object, which indicates whether the permission has been granted. </span><span class="kobospan" id="kobo.450.2">If it’s true, it means the permission is available, and we can call the </span><strong class="source-inline"><span class="kobospan" id="kobo.451.1">onPermissionGranted</span></strong><span class="kobospan" id="kobo.452.1"> callback to proceed with using the </span><span><span class="kobospan" id="kobo.453.1">camera features.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.454.1">If it is false, this means that the permission</span><a id="_idIndexMarker562" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.455.1"> hasn’t been granted, so we will have to communicate</span><a id="_idIndexMarker563" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.456.1"> that situation to the user and give them the option to </span><span><span class="kobospan" id="kobo.457.1">grant it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.458.1">
    } else {
                Surface(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                        .padding(top = 24.dp),
                    color =
                      MaterialTheme.colorScheme.background,
        ) {
            Column(
                modifier = Modifier.padding(16.dp),
                verticalArrangement =
                    Arrangement.spacedBy(12.dp),
                horizontalAlignment =
                    Alignment.CenterHorizontally
            ) {
                val textToShow = if
                (cameraPermissionState.shouldShowRationale)
                {
                    "The camera and record audio are
                     important for this app. </span><span class="kobospan1" id="kobo.458.2">Please grant
                     the permissions."
</span><span class="kobospan1" id="kobo.458.3">                } else {
                    "Camera permission is required for this
                     feature to be available. </span><span class="kobospan1" id="kobo.458.4">Please grant
                     the permission."
</span><span class="kobospan1" id="kobo.458.5">                }
                Text(
                    text = textToShow,
                    style =
                    MaterialTheme.typography.bodyLarge.copy
                    (
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Medium
                    ),
                    color =
                    MaterialTheme.colorScheme.onBackground
                )
                Button(
                    onClick = { cameraPermissionState
                        .launchMultiplePermissionRequest()
                        },
                    colors = ButtonDefaults.buttonColors(
                        containerColor =
                        MaterialTheme.colorScheme.primary,
                        contentColor =
                        MaterialTheme.colorScheme.onPrimary
                    ),
                    contentPadding = PaddingValues(12.dp)
                ) {
                    Text("Request Permission",
                        fontSize = 14.sp,
                            fontWeight = FontWeight.Bold)
                }
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.459.1">In the previous code</span><a id="_idIndexMarker564" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.460.1"> block, we’re displaying a message</span><a id="_idIndexMarker565" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.461.1"> explaining the need for the permission and providing a </span><strong class="source-inline"><span class="kobospan" id="kobo.462.1">Button</span></strong><span class="kobospan" id="kobo.463.1"> component to initiate the permission request process. </span><span class="kobospan" id="kobo.463.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.464.1">onClick</span></strong><span class="kobospan" id="kobo.465.1"> handler of the button triggers the </span><strong class="source-inline"><span class="kobospan" id="kobo.466.1">launchPermissionRequest()</span></strong><span class="kobospan" id="kobo.467.1"> method of the </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">cameraPermissionState</span></strong><span class="kobospan" id="kobo.469.1"> object, which prompts the user to grant </span><span><span class="kobospan" id="kobo.470.1">the permission.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.471.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.472.1">launchPermissionRequest()</span></strong><span class="kobospan" id="kobo.473.1"> method opens a system dialogue requesting the user to grant the </span><strong class="source-inline"><span class="kobospan" id="kobo.474.1">CAMERA</span></strong><span class="kobospan" id="kobo.475.1"> permission. </span><span class="kobospan" id="kobo.475.2">The dialogue provides clear instructions and explains the reasons why the permission </span><span><span class="kobospan" id="kobo.476.1">is required.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.477.1">If we run this code now, we should see the two screens. </span><span class="kobospan" id="kobo.477.2">First, we will see our screen with the message to request the permissions (left). </span><span class="kobospan" id="kobo.477.3">Once we click </span><strong class="bold"><span class="kobospan" id="kobo.478.1">Request permission</span></strong><span class="kobospan" id="kobo.479.1">, we will see the system</span><a id="_idIndexMarker566" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.480.1"> prompt to accept</span><a id="_idIndexMarker567" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.481.1"> the </span><span><span class="kobospan" id="kobo.482.1">permission (right):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer041">
<span class="kobospan" id="kobo.483.1"><img alt="Figure 5.1: Camera permission requested in our app (left) and system prompt to grant capture and record permissions (right)" src="image/B19443_05_001.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"> </p>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.484.1">Figure 5.1: Camera permission requested in our app (left) and system prompt to grant capture and record permissions (right)</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.485.1">Once the permissions have been</span><a id="_idIndexMarker568" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.486.1"> granted, </span><strong class="source-inline"><span class="kobospan" id="kobo.487.1">CameraPreview</span></strong><span class="kobospan" id="kobo.488.1"> can start</span><a id="_idIndexMarker569" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.489.1"> working. </span><span class="kobospan" id="kobo.489.2">We will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.490.1">onPermissionGranted</span></strong><span class="kobospan" id="kobo.491.1"> callback to </span><span><span class="kobospan" id="kobo.492.1">show it.</span></span></p>
<h2 id="_idParaDest-118" class="calibre7"><a id="_idTextAnchor119" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.493.1">Creating our own CameraPreview</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.494.1">The following </span><strong class="source-inline"><span class="kobospan" id="kobo.495.1">CameraPreview</span></strong><span class="kobospan" id="kobo.496.1"> composable function</span><a id="_idIndexMarker570" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.497.1"> is designed to elegantly integrate CameraX into the Jetpack Compose ecosystem. </span><span class="kobospan" id="kobo.497.2">At the time of writing, there is not an official composable implementation for the CameraX preview, so we will </span><span><span class="kobospan" id="kobo.498.1">use </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.499.1">AndroidView</span></strong></span><span><span class="kobospan" id="kobo.500.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.501.1">
@Composable
@Composable
fun CameraPreview(cameraController:
LifecycleCameraController, modifier: Modifier = Modifier) {
    AndroidView(
        factory = { context -&gt;
            PreviewView(context).apply {
                implementationMode =
                  PreviewView.ImplementationMode.COMPATIBLE
            }
        },
        modifier = modifier,
        update = { previewView -&gt;
            previewView.controller = cameraController
        }
    )
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.502.1">This composable function takes two parameters: </span><strong class="source-inline"><span class="kobospan" id="kobo.503.1">cameraController</span></strong><span class="kobospan" id="kobo.504.1">, which is an instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">LifecycleCameraController</span></strong><span class="kobospan" id="kobo.506.1"> to control the camera, and an optional modifier, which is used to specify </span><span><span class="kobospan" id="kobo.507.1">layout options.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.508.1">Inside the function, an </span><strong class="source-inline"><span class="kobospan" id="kobo.509.1">AndroidView</span></strong><span class="kobospan" id="kobo.510.1"> composable is used to bridge traditional Android views with the Jetpack Compose UI framework. </span><span class="kobospan" id="kobo.510.2">The factory parameter of </span><strong class="source-inline"><span class="kobospan" id="kobo.511.1">AndroidView</span></strong><span class="kobospan" id="kobo.512.1"> is a Lambda that provides context and returns a </span><strong class="source-inline"><span class="kobospan" id="kobo.513.1">PreviewView</span></strong><span class="kobospan" id="kobo.514.1"> object. </span><span class="kobospan" id="kobo.514.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">PreviewView</span></strong><span class="kobospan" id="kobo.516.1"> object is a standard Android view that’s used to display the camera feed. </span><span class="kobospan" id="kobo.516.2">It is configured with </span><strong class="source-inline"><span class="kobospan" id="kobo.517.1">implementationMode</span></strong><span class="kobospan" id="kobo.518.1"> set to </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">COMPATIBLE</span></strong><span class="kobospan" id="kobo.520.1"> to ensure compatibility with different devices and scenarios (one of the most relevant </span><span><span class="kobospan" id="kobo.521.1">CameraX features).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.522.1">The modifier parameter of </span><strong class="source-inline"><span class="kobospan" id="kobo.523.1">AndroidView</span></strong><span class="kobospan" id="kobo.524.1"> is set to the passed modifier to allow the layout to be customized. </span><span class="kobospan" id="kobo.524.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.525.1">update</span></strong><span class="kobospan" id="kobo.526.1"> parameter is another Lambda that’s called to perform updates on </span><strong class="source-inline"><span class="kobospan" id="kobo.527.1">PreviewView</span></strong><span class="kobospan" id="kobo.528.1">. </span><span class="kobospan" id="kobo.528.2">In this case, it assigns </span><strong class="source-inline"><span class="kobospan" id="kobo.529.1">cameraController</span></strong><span class="kobospan" id="kobo.530.1"> to the controller property of </span><strong class="source-inline"><span class="kobospan" id="kobo.531.1">PreviewView</span></strong><span class="kobospan" id="kobo.532.1">, linking the camera preview </span><span><span class="kobospan" id="kobo.533.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.534.1">LifecycleCameraController</span></strong></span><span><span class="kobospan" id="kobo.535.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.536.1">Now, let’s integrate the preview into our existing code. </span><span class="kobospan" id="kobo.536.2">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.537.1">StoryContent</span></strong><span class="kobospan" id="kobo.538.1"> composable, we will include the following code, where we expect to have the </span><span><span class="kobospan" id="kobo.539.1">camera image:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.540.1">
    CameraPermissionRequester {
        Box(contentAlignment = Alignment.BottomCenter,
        modifier = Modifier.fillMaxSize()) {
            CameraPreview(
                cameraController = cameraController,
                modifier = Modifier.fillMaxSize()
            )
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.541.1">With that, we should be ready</span><a id="_idIndexMarker571" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.542.1"> to use the camera! </span><span class="kobospan" id="kobo.542.2">At this point, we’ve learned how to integrate </span><strong class="source-inline"><span class="kobospan" id="kobo.543.1">CameraPreview</span></strong><span class="kobospan" id="kobo.544.1">, check the permissions, and show the camera image stream. </span><span class="kobospan" id="kobo.544.2">Now, let’s add the possibility of saving </span><span><span class="kobospan" id="kobo.545.1">the photos!</span></span></p>
<h2 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor120" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.546.1">Adding photo-saving functionality</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.547.1">The capture functionality</span><a id="_idIndexMarker572" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.548.1"> is a staple for every app using the camera. </span><span class="kobospan" id="kobo.548.2">We will need to add some logic to our existing code to handle the capture storage. </span><span class="kobospan" id="kobo.548.3">Let’s start with a use case (where we are going to put our domain logic) to store the </span><span><span class="kobospan" id="kobo.549.1">captured image.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.550.1">Creating the SaveCaptureUseCase</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.551.1">The primary responsibility</span><a id="_idIndexMarker573" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.552.1"> of </span><strong class="source-inline"><span class="kobospan" id="kobo.553.1">SaveCaptureUseCase</span></strong><span class="kobospan" id="kobo.554.1"> will be to take</span><a id="_idIndexMarker574" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.555.1"> a bitmap object (the format we will use for our photos) and save it as an image file in the device’s gallery. </span><span class="kobospan" id="kobo.555.2">Additionally, it will handle the different approaches based on the Android version as how media storage is accessed is different, depending on </span><span><span class="kobospan" id="kobo.556.1">the version.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.557.1">For example, we will need to obtain the URI (the route in the storage of the device) where we are going to store the image. </span><span class="kobospan" id="kobo.557.2">If the user has a version of Android more recent than 9.0, the location will be different than in the previous versions. </span><span class="kobospan" id="kobo.557.3">The following code block shows what the check to obtain the corresponding route will </span><span><span class="kobospan" id="kobo.558.1">look like:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.559.1">
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {
            MediaStore.Images.Media.getContentUri(
                MediaStore.VOLUME_EXTERNAL_PRIMARY)
        } else {
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI
        }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.560.1">Here, we are evaluating if the version is major or equal to Android 9.0 and obtaining the URI using </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)</span></strong><span class="kobospan" id="kobo.562.1">. </span><span class="kobospan" id="kobo.562.2">If the version doesn’t meet those requirements, we obtain the URI from </span><strong class="source-inline"><span class="kobospan" id="kobo.563.1">MediaStore.Images.Media.EXTERNAL_CONTENT_URI</span></strong><span class="kobospan" id="kobo.564.1">. </span><span class="kobospan" id="kobo.564.2">We should take all these different cases into account so that our use case handles the different Android </span><span><span class="kobospan" id="kobo.565.1">versions properly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.566.1">Now, let’s create the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">SaveCaptureUse</span></strong></span><span><span class="kobospan" id="kobo.568.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.569.1">
class SaveCaptureUseCase(private val context: Context) {
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.570.1">Then, we can create the main function</span><a id="_idIndexMarker575" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.571.1"> of this use</span><a id="_idIndexMarker576" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.572.1"> case, </span><strong class="source-inline"><span class="kobospan" id="kobo.573.1">save()</span></strong><span class="kobospan" id="kobo.574.1">, which will take care of saving </span><span><span class="kobospan" id="kobo.575.1">the capture:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.576.1">
    suspend fun save(capturePhotoBitmap: Bitmap):
    Result&lt;Uri&gt; = withContext(Dispatchers.IO) {
        val resolver: ContentResolver =
            context.applicationContext.contentResolver
        val imageCollection = getImageCollectionUri()
        val nowTimestamp = System.currentTimeMillis()
        val imageContentValues =
            createContentValues(nowTimestamp)
        val imageMediaStoreUri: Uri? </span><span class="kobospan1" id="kobo.576.2">=
            resolver.insert(imageCollection,
                imageContentValues)
        return@withContext imageMediaStoreUri?.let { uri -&gt;
            saveBitmapToUri(resolver, uri,
                capturePhotoBitmap, imageContentValues)
        } ?: Result.failure(Exception("Couldn't create file
                                       for gallery"))
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.577.1">In this code block, we are starting to create the save function. </span><span class="kobospan" id="kobo.577.2">As it is marked as a </span><strong class="source-inline"><span class="kobospan" id="kobo.578.1">suspend</span></strong><span class="kobospan" id="kobo.579.1"> function, the save function is designed to be called within a coroutine context. </span><span class="kobospan" id="kobo.579.2">It uses </span><strong class="source-inline"><span class="kobospan" id="kobo.580.1">withContext(Dispatchers.IO)</span></strong><span class="kobospan" id="kobo.581.1"> to ensure that all I/O operations are performed on a background thread. </span><span class="kobospan" id="kobo.581.2">This is crucial for maintaining UI responsiveness as I/O operations can </span><span><span class="kobospan" id="kobo.582.1">be time-consuming.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.583.1">Next, we are declaring </span><strong class="source-inline"><span class="kobospan" id="kobo.584.1">ContextResolver</span></strong><span class="kobospan" id="kobo.585.1">. </span><span class="kobospan" id="kobo.585.2">This resolver is used to interact with </span><strong class="source-inline"><span class="kobospan" id="kobo.586.1">MediaStore</span></strong><span class="kobospan" id="kobo.587.1">, which is Android’s central repository for </span><span><span class="kobospan" id="kobo.588.1">media files.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.589.1">Then, the function will call </span><strong class="source-inline"><span class="kobospan" id="kobo.590.1">getImageCollectionUri()</span></strong><span class="kobospan" id="kobo.591.1">, a helper function that provides the appropriate URI for </span><strong class="source-inline"><span class="kobospan" id="kobo.592.1">MediaStore</span></strong><span class="kobospan" id="kobo.593.1"> based on the Android version. </span><span class="kobospan" id="kobo.593.2">This URI is where the image will be saved. </span><span class="kobospan" id="kobo.593.3">We will implement this </span><span><span class="kobospan" id="kobo.594.1">function next.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.595.1">After, the current system</span><a id="_idIndexMarker577" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.596.1"> time (</span><strong class="source-inline"><span class="kobospan" id="kobo.597.1">nowTimestamp</span></strong><span class="kobospan" id="kobo.598.1">) is captured, and </span><strong class="source-inline"><span class="kobospan" id="kobo.599.1">createContentValues (nowTimestamp)</span></strong><span class="kobospan" id="kobo.600.1"> is invoked</span><a id="_idIndexMarker578" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.601.1"> to prepare the metadata for the image. </span><span class="kobospan" id="kobo.601.2">This metadata, which is stored in a </span><strong class="source-inline"><span class="kobospan" id="kobo.602.1">ContentValues</span></strong><span class="kobospan" id="kobo.603.1"> object, includes details such as the image’s display name, </span><strong class="source-inline"><span class="kobospan" id="kobo.604.1">MIME</span></strong><span class="kobospan" id="kobo.605.1"> type, </span><span><span class="kobospan" id="kobo.606.1">and timestamps.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.607.1">The function then attempts to insert a new record into </span><strong class="source-inline"><span class="kobospan" id="kobo.608.1">MediaStore</span></strong><span class="kobospan" id="kobo.609.1"> using the resolved URI and the prepared metadata. </span><span class="kobospan" id="kobo.609.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.610.1">insert</span></strong><span class="kobospan" id="kobo.611.1"> method returns a URI that points to the newly created record. </span><span class="kobospan" id="kobo.611.2">If this operation is successful, a non-null URI is returned, representing the location of the new image record </span><span><span class="kobospan" id="kobo.612.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.613.1">MediaStore</span></strong></span><span><span class="kobospan" id="kobo.614.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.615.1">Finally, if the URI is not null, the </span><strong class="source-inline"><span class="kobospan" id="kobo.616.1">saveBitmapToUri</span></strong><span class="kobospan" id="kobo.617.1"> function is called with the resolver, the URI, the bitmap to be saved, and the image metadata. </span><span class="kobospan" id="kobo.617.2">This function handles the actual process of writing the bitmap data to the location pointed to by the URI. </span><span class="kobospan" id="kobo.617.3">We will implement </span><span><span class="kobospan" id="kobo.618.1">it soon.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.619.1">Regarding error handling, our </span><strong class="source-inline"><span class="kobospan" id="kobo.620.1">save</span></strong><span class="kobospan" id="kobo.621.1"> function uses Kotlin’s </span><strong class="source-inline"><span class="kobospan" id="kobo.622.1">Result</span></strong><span class="kobospan" id="kobo.623.1"> class for structured error handling. </span><span class="kobospan" id="kobo.623.2">If the insertion into the MediaStore is successful and the bitmap is saved correctly, the function returns </span><strong class="source-inline"><span class="kobospan" id="kobo.624.1">Result.success(Unit)</span></strong><span class="kobospan" id="kobo.625.1">. </span><span class="kobospan" id="kobo.625.2">If there is a failure at any point (for example, the URI is null, indicating that the insertion failed), the function returns </span><strong class="source-inline"><span class="kobospan" id="kobo.626.1">Result.failure</span></strong><span class="kobospan" id="kobo.627.1">, encapsulating an exception with an appropriate </span><span><span class="kobospan" id="kobo.628.1">error message.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.629.1">Now, let’s implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.630.1">getImageCollectionUri()</span></strong><span class="kobospan" id="kobo.631.1"> function, which will return the correct URI based on the </span><span><span class="kobospan" id="kobo.632.1">Android version:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.633.1">
    private fun getImageCollectionUri(): Uri =
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q)
        {
            MediaStore.Images.Media.getContentUri(
                MediaStore.VOLUME_EXTERNAL_PRIMARY)
        } else {
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI
        }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.634.1">Then, we</span><a id="_idIndexMarker579" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.635.1"> can create</span><a id="_idIndexMarker580" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.636.1"> the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.637.1">createContentValues</span></strong></span><span><span class="kobospan" id="kobo.638.1"> function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.639.1">
private fun createContentValues(timestamp: Long):
ContentValues = ContentValues().apply {
        put(MediaStore.Images.Media.DISPLAY_NAME,
            "$FILE_NAME_PREFIX${System.currentTimeMillis()}
                .jpg")
        put(MediaStore.Images.Media.MIME_TYPE, "image/jpg")
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q)
        {
            put(MediaStore.MediaColumns.DATE_TAKEN,
                timestamp)
            put(MediaStore.MediaColumns.RELATIVE_PATH,
                "${Environment.DIRECTORY_DCIM}/Packtagram")
            put(MediaStore.MediaColumns.IS_PENDING, 1)
        }
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R)
        {
            put(MediaStore.Images.Media.DATE_ADDED,
                timestamp)
            put(MediaStore.Images.Media.DATE_MODIFIED,
                timestamp)
            put(MediaStore.Images.Media.AUTHOR,
                AUTHOR_NAME)
            put(MediaStore.Images.Media.DESCRIPTION,
                DESCRIPTION)
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.640.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.641.1">createContentValues</span></strong><span class="kobospan" id="kobo.642.1"> function</span><a id="_idIndexMarker581" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.643.1"> is designed to prepare</span><a id="_idIndexMarker582" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.644.1"> the metadata for an image file before it is saved to the device’s gallery via </span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">MediaStore</span></strong><span class="kobospan" id="kobo.646.1">. </span><span class="kobospan" id="kobo.646.2">This method is pivotal in ensuring that the saved image has the correct and necessary information associated with it. </span><span class="kobospan" id="kobo.646.3">So, let’s break down </span><span><span class="kobospan" id="kobo.647.1">its functionality:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.648.1">First, the function initiates a </span><strong class="source-inline1"><span class="kobospan" id="kobo.649.1">ContentValues</span></strong><span class="kobospan" id="kobo.650.1"> object. </span><span class="kobospan" id="kobo.650.2">Here, </span><strong class="source-inline1"><span class="kobospan" id="kobo.651.1">ContentValues</span></strong><span class="kobospan" id="kobo.652.1"> is a key-value pair that’s used in Android to store a set of values that </span><strong class="source-inline1"><span class="kobospan" id="kobo.653.1">ContentResolver</span></strong><span class="kobospan" id="kobo.654.1"> can process. </span><span class="kobospan" id="kobo.654.2">It is commonly used for passing data to Android’s </span><span><span class="kobospan" id="kobo.655.1">content providers</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.656.1">Next, the display name of the image in </span><strong class="source-inline1"><span class="kobospan" id="kobo.657.1">MediaStore</span></strong><span class="kobospan" id="kobo.658.1"> is set. </span><span class="kobospan" id="kobo.658.2">We will use a predefined </span><strong class="source-inline1"><span class="kobospan" id="kobo.659.1">FILE_NAME_PREFIX</span></strong><span class="kobospan" id="kobo.660.1"> constant and append the current timestamp to it, followed by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.661.1">.jpg</span></strong><span class="kobospan" id="kobo.662.1"> extension, ensuring each saved image has a </span><span><span class="kobospan" id="kobo.663.1">unique name.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.664.1">Then, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.665.1">MIME</span></strong><span class="kobospan" id="kobo.666.1"> type of the image is set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.667.1">image/jpg</span></strong><span class="kobospan" id="kobo.668.1">. </span><span class="kobospan" id="kobo.668.2">This information is used by </span><strong class="source-inline1"><span class="kobospan" id="kobo.669.1">MediaStore</span></strong><span class="kobospan" id="kobo.670.1"> and other apps to understand the file format of </span><span><span class="kobospan" id="kobo.671.1">the image.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.672.1">We have to store it differently, depending on the Android version of </span><span><span class="kobospan" id="kobo.673.1">the device:</span></span><ul class="calibre16"><li class="calibre14"><span class="kobospan" id="kobo.674.1">For Android Q (API Level 29) and above, we must do </span><span><span class="kobospan" id="kobo.675.1">the following:</span></span><ul class="calibre16"><li class="calibre14"><span class="kobospan" id="kobo.676.1">We need to add the timestamp of when the image is being stored and use the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.677.1">MediaStore.MediaColumns.DATE_TAKEN</span></strong></span><span><span class="kobospan" id="kobo.678.1"> key.</span></span></li><li class="calibre14"><span class="kobospan" id="kobo.679.1">We must use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.680.1">createContentValues</span></strong><span class="kobospan" id="kobo.681.1"> function to specify a relative path for the image file, pointing</span><a id="_idIndexMarker583" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.682.1"> to a directory within the </span><strong class="bold"><span class="kobospan" id="kobo.683.1">Digital Camera Images</span></strong><span class="kobospan" id="kobo.684.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.685.1">DCIM</span></strong><span class="kobospan" id="kobo.686.1">) folder using </span><strong class="source-inline1"><span class="kobospan" id="kobo.687.1">put(MediaStore.MediaColumns.RELATIVE_PATH, "${Environment.DIRECTORY_DCIM}/Packtagram")</span></strong><span class="kobospan" id="kobo.688.1">. </span><span class="kobospan" id="kobo.688.2">This helps in organizing the saved images in a specific subdirectory, making them easier </span><span><span class="kobospan" id="kobo.689.1">to locate.</span></span></li><li class="calibre14"><span class="kobospan" id="kobo.690.1">We need to update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.691.1">ContentValues</span></strong><span class="kobospan" id="kobo.692.1"> instance and set </span><strong class="source-inline1"><span class="kobospan" id="kobo.693.1">IS_PENDING</span></strong><span class="kobospan" id="kobo.694.1"> to </span><strong class="source-inline1"><span class="kobospan" id="kobo.695.1">1</span></strong><span class="kobospan" id="kobo.696.1"> (true), indicating that file creation is in progress. </span><span class="kobospan" id="kobo.696.2">This is a way to inform the system and other apps that the file is not yet fully written and should not be accessed until the status </span><span><span class="kobospan" id="kobo.697.1">is reverted.</span></span></li></ul></li><li class="calibre14"><span class="kobospan" id="kobo.698.1">For Android R (API Level 30) and above, our function should add more metadata, including the date added, date modified, author name, and a description. </span><span class="kobospan" id="kobo.698.2">This is part of the enhanced metadata management in newer Android versions, allowing for more detailed information to be stored with </span><span><span class="kobospan" id="kobo.699.1">media files.</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.700.1">Now that we are handling</span><a id="_idIndexMarker584" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.701.1"> the URI that’s needed</span><a id="_idIndexMarker585" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.702.1"> to store the file, as well as the values and metadata needed to create the file, let’s proceed to do the saving itself. </span><span class="kobospan" id="kobo.702.2">To do so, we will create a new private function called </span><strong class="source-inline"><span class="kobospan" id="kobo.703.1">saveBitmapToUri</span></strong><span class="kobospan" id="kobo.704.1">, </span><span><span class="kobospan" id="kobo.705.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.706.1">
    private fun saveBitmapToUri(
        resolver: ContentResolver,
        uri: Uri,
        bitmap: Bitmap,
        contentValues: ContentValues
    ): Result&lt;Uri&gt; = kotlin.runCatching {
       resolver.openOutputStream(uri).use { outputStream -&gt;
           checkNotNull(outputStream) { "Couldn't create
               file for gallery, MediaStore output stream
                   is null»}`
           bitmap.compress(Bitmap.CompressFormat.JPEG,
               IMAGE_QUALITY, outputStream)
        }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.707.1">The function starts by attempting to open </span><strong class="source-inline"><span class="kobospan" id="kobo.708.1">OutputStream</span></strong><span class="kobospan" id="kobo.709.1"> for the given URI. </span><span class="kobospan" id="kobo.709.2">This stream is where the bitmap data will be written. </span><span class="kobospan" id="kobo.709.3">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.710.1">Resolver.openOutputStream(uri)</span></strong><span class="kobospan" id="kobo.711.1"> is used to obtain the stream, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.712.1">use</span></strong><span class="kobospan" id="kobo.713.1"> block ensures that this stream is closed properly after its operations, following the best practices in </span><span><span class="kobospan" id="kobo.714.1">resource management.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.715.1">Inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.716.1">use</span></strong><span class="kobospan" id="kobo.717.1"> block, the function</span><a id="_idIndexMarker586" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.718.1"> checks if </span><strong class="source-inline"><span class="kobospan" id="kobo.719.1">outputStream</span></strong><span class="kobospan" id="kobo.720.1"> is not </span><strong class="source-inline"><span class="kobospan" id="kobo.721.1">null</span></strong><span class="kobospan" id="kobo.722.1">, throwing</span><a id="_idIndexMarker587" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.723.1"> an exception with a descriptive message if it is. </span><span class="kobospan" id="kobo.723.2">If the stream is valid, the bitmap is compressed and written to this stream. </span><span class="kobospan" id="kobo.723.3">The compression format is set to JPEG, and the quality is determined by the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.724.1">IMAGE_QUALITY</span></strong></span><span><span class="kobospan" id="kobo.725.1"> constant.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.726.1">Now, if the image is saved successfully, we have to update and return the result. </span><span class="kobospan" id="kobo.726.2">If something has failed, we have to return </span><span><span class="kobospan" id="kobo.727.1">an error:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.728.1">
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q)
        {
            contentValues.clear()
            contentValues.put(
                MediaStore.MediaColumns.IS_PENDING, 0)
            resolver.update(uri, contentValues, null, null)
        }
        return Result.success(Unit)
    }.getOrElse { exception -&gt;
        exception.message?.let(::println)
        resolver.delete(uri, null, null)
        return Result.failure(exception)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.729.1">For devices running Android Q (API level 29) or higher, after the image is saved, the function updates the </span><strong class="source-inline"><span class="kobospan" id="kobo.730.1">MediaStore</span></strong><span class="kobospan" id="kobo.731.1"> entry to indicate that the image is no longer pending. </span><span class="kobospan" id="kobo.731.2">This is done by clearing the existing </span><strong class="source-inline"><span class="kobospan" id="kobo.732.1">contentValues</span></strong><span class="kobospan" id="kobo.733.1">, setting </span><strong class="source-inline"><span class="kobospan" id="kobo.734.1">IS_PENDING</span></strong><span class="kobospan" id="kobo.735.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.736.1">0</span></strong><span class="kobospan" id="kobo.737.1"> (false), and then updating the </span><strong class="source-inline"><span class="kobospan" id="kobo.738.1">MediaStore</span></strong><span class="kobospan" id="kobo.739.1"> entry with these new values. </span><span class="kobospan" id="kobo.739.2">This step is crucial for making the image available to the user and </span><span><span class="kobospan" id="kobo.740.1">other applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.741.1">The entire operation is wrapped in a </span><strong class="source-inline"><span class="kobospan" id="kobo.742.1">runCatching</span></strong><span class="kobospan" id="kobo.743.1"> block, which is a Kotlin construct that’s used for simplified exception handling. </span><span class="kobospan" id="kobo.743.2">This block captures any exceptions that occur during the </span><strong class="source-inline"><span class="kobospan" id="kobo.744.1">OutputStream</span></strong><span class="kobospan" id="kobo.745.1"> operation or </span><strong class="source-inline"><span class="kobospan" id="kobo.746.1">MediaStore</span></strong><span class="kobospan" id="kobo.747.1"> update. </span><span class="kobospan" id="kobo.747.2">If an exception occurs, it is logged, and the function attempts to delete the possibly corrupted or incomplete file from </span><strong class="source-inline"><span class="kobospan" id="kobo.748.1">MediaStore</span></strong><span class="kobospan" id="kobo.749.1">. </span><span class="kobospan" id="kobo.749.2">This cleanup is essential to prevent cluttering the storage with </span><span><span class="kobospan" id="kobo.750.1">unusable files.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.751.1">The function returns </span><strong class="source-inline"><span class="kobospan" id="kobo.752.1">Result&lt;Uri&gt;</span></strong><span class="kobospan" id="kobo.753.1">, indicating the success or failure of the operation. </span><span class="kobospan" id="kobo.753.2">In case of success, </span><strong class="source-inline"><span class="kobospan" id="kobo.754.1">Result.success(uri)</span></strong><span class="kobospan" id="kobo.755.1"> is returned. </span><span class="kobospan" id="kobo.755.2">In case of an exception, </span><strong class="source-inline"><span class="kobospan" id="kobo.756.1">Result.failure(exception)</span></strong><span class="kobospan" id="kobo.757.1"> is returned, encapsulating the </span><span><span class="kobospan" id="kobo.758.1">exception details.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.759.1">The only thing left will be to add</span><a id="_idIndexMarker588" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.760.1"> the parameters that</span><a id="_idIndexMarker589" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.761.1"> will be used during the development of these classes. </span><span class="kobospan" id="kobo.761.2">For simplicity, we will add them as constants, but they could also be provided to </span><span><span class="kobospan" id="kobo.762.1">the class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.763.1">
companion object {
    private const val IMAGE_QUALITY = 100
    private const val FILE_NAME_PREFIX = "YourImageName"
    private const val AUTHOR_NAME = "Your Name"
    private const val DESCRIPTION = "Your description"
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.764.1">The next step is to integrate this use case </span><span><span class="kobospan" id="kobo.765.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.766.1">StoryEditorViewModel</span></strong></span><span><span class="kobospan" id="kobo.767.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.768.1">Integrating SaveCaptureUseCase in StoryEditorViewModel</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.769.1">Here, we need to create</span><a id="_idIndexMarker590" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.770.1"> a new property </span><a id="_idIndexMarker591" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.771.1">and function in </span><strong class="source-inline"><span class="kobospan" id="kobo.772.1">StoryEditorViewModel</span></strong><span class="kobospan" id="kobo.773.1"> to store the </span><span><span class="kobospan" id="kobo.774.1">captured image:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.775.1">
class StoryEditorViewModel(
    private val saveCaptureUseCase: SaveCaptureUseCase
): ViewModel() {
    private val _isEditing = MutableStateFlow(false)
    val isEditing: StateFlow&lt;Boolean&gt; = _isEditing
    private val _imageCaptured: MutableStateFlow&lt;Uri&gt; =
        MutableStateFlow(Uri.EMPTY)
    val imageCaptured: StateFlow&lt;Uri&gt; = _imageCaptured
    fun storePhotoInGallery(bitmap: Bitmap) {
        viewModelScope.launch {
            val imageUri =
                saveCaptureUseCase.save(bitmap).getOrNull()
            if (imageUri != null) {
                _imageCaptured.value = imageUri
                _isEditing.value = true
            }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.776.1">In this </span><strong class="source-inline"><span class="kobospan" id="kobo.777.1">storePhotoInGallery</span></strong><span class="kobospan" id="kobo.778.1"> function, we are just launching a coroutine to call the </span><strong class="source-inline"><span class="kobospan" id="kobo.779.1">saveCaptureUseCase.save</span></strong><span class="kobospan" id="kobo.780.1"> method. </span><span class="kobospan" id="kobo.780.2">Then, once we’ve obtained</span><a id="_idIndexMarker592" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.781.1"> the URI, we check if it is not </span><strong class="source-inline"><span class="kobospan" id="kobo.782.1">null</span></strong><span class="kobospan" id="kobo.783.1"> and update</span><a id="_idIndexMarker593" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.784.1"> the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.785.1">imageCaptured</span></strong></span><span><span class="kobospan" id="kobo.786.1"> property.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.787.1">Finally, we are ready to add this functionality to </span><span><span class="kobospan" id="kobo.788.1">the UI.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.789.1">Adding the capture functionality to StoryContent</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.790.1">To add the capture functionality</span><a id="_idIndexMarker594" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.791.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.792.1">StoryContent</span></strong><span class="kobospan" id="kobo.793.1">, we need to add</span><a id="_idIndexMarker595" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.794.1"> a Lambda to the </span><strong class="source-inline"><span class="kobospan" id="kobo.795.1">StoryContent</span></strong><span class="kobospan" id="kobo.796.1"> composable so that whenever we use </span><strong class="source-inline"><span class="kobospan" id="kobo.797.1">StoryContent</span></strong><span class="kobospan" id="kobo.798.1">, capture handling will be delegated. </span><span class="kobospan" id="kobo.798.2">For example, in our case, we will call the already implemented </span><strong class="source-inline"><span class="kobospan" id="kobo.799.1">storePhotoInGallery</span></strong><span class="kobospan" id="kobo.800.1"> function </span><span><span class="kobospan" id="kobo.801.1">from </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.802.1">StoryEditorViewModel</span></strong></span><span><span class="kobospan" id="kobo.803.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.804.1">
@Composable
fun StoryContent(
    isEditing: Boolean = false,
    onImageCaptured: (Bitmap) -&gt; Any,
    modifier: Modifier = Modifier,
) { ... </span><span class="kobospan1" id="kobo.804.2">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.805.1">Next, let’s integrate the code that’s needed to take the capture from </span><span><span class="kobospan" id="kobo.806.1">our camera:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.807.1">
fun capturePhoto(
        context: Context,
        cameraController: LifecycleCameraController,
        onPhotoCaptured: (Bitmap) -&gt; Unit,
        onError: (Exception) -&gt; Unit
    ) {</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.808.1">The parameters we are using in the previous code block are </span><span><span class="kobospan" id="kobo.809.1">as follows:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.810.1">context</span></strong><span class="kobospan" id="kobo.811.1">: The Android context that we will use to </span><span><span class="kobospan" id="kobo.812.1">obtain </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.813.1">MainExecutor</span></strong></span><span><span class="kobospan" id="kobo.814.1">.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.815.1">cameraController</span></strong><span class="kobospan" id="kobo.816.1">: A </span><strong class="source-inline1"><span class="kobospan" id="kobo.817.1">LifecycleCameraController</span></strong><span class="kobospan" id="kobo.818.1"> object from </span><strong class="source-inline1"><span class="kobospan" id="kobo.819.1">CameraX</span></strong><span class="kobospan" id="kobo.820.1">, which controls the camera’s life cycle </span><span><span class="kobospan" id="kobo.821.1">and operations.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.822.1">onPhotoCaptured</span></strong><span class="kobospan" id="kobo.823.1">: The callback function that will be invoked when a photo is successfully captured and processed. </span><span class="kobospan" id="kobo.823.2">It accepts a </span><strong class="source-inline1"><span class="kobospan" id="kobo.824.1">Bitmap</span></strong><span class="kobospan" id="kobo.825.1"> as </span><span><span class="kobospan" id="kobo.826.1">its parameter.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.827.1">onError</span></strong><span class="kobospan" id="kobo.828.1">: A callback function to handle any errors that occur during the photo </span><span><span class="kobospan" id="kobo.829.1">capture process.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.830.1">Let’s continue by defining the </span><span><span class="kobospan" id="kobo.831.1">necessary properties:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.832.1">
val mainExecutor: Executor =
ContextCompat.getMainExecutor(context)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.833.1">Here, we will retrieve </span><strong class="source-inline"><span class="kobospan" id="kobo.834.1">MainExecutor</span></strong><span class="kobospan" id="kobo.835.1">. </span><span class="kobospan" id="kobo.835.2">This executor</span><a id="_idIndexMarker596" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.836.1"> is used to run tasks</span><a id="_idIndexMarker597" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.837.1"> on the Android main thread, which is essential for UI updates and certain CameraX operations. </span><span class="kobospan" id="kobo.837.2">It is needed </span><span><span class="kobospan" id="kobo.838.1">for </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.839.1">CameraController</span></strong></span><span><span class="kobospan" id="kobo.840.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.841.1">Next, we will execute the take </span><span><span class="kobospan" id="kobo.842.1">picture action:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.843.1">
        cameraController.takePicture(mainExecutor,
        @ExperimentalGetImage object :
        ImageCapture.OnImageCapturedCallback() {
            override fun onCaptureSuccess(image:
            ImageProxy) {
                try {
                    CoroutineScope(Dispatchers.IO).launch {
                        val correctedBitmap: Bitmap? </span><span class="kobospan1" id="kobo.843.2">=
                            image
                                ?.image
                                ?.toBitmap()
                                ?.rotateBitmap(image
                                    .imageInfo
                                    .rotationDegrees)
                        correctedBitmap?.let {
                            withContext(Dispatchers.Main) {
                                onPhotoCaptured(
                                    correctedBitmap)
                            }
                        }
                        image.close()
                    }
                } catch (e: Exception) {
                    onError(e)
                } finally {
                    image.close()
                }
            }
            override fun onError(exception:
            ImageCaptureException) {
                Log.e("CameraContent", "Error capturing
                    image", exception)
                onError(exception)
            }
        })
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.844.1">Here, we call the </span><strong class="source-inline"><span class="kobospan" id="kobo.845.1">cameraController.takePicture</span></strong><span class="kobospan" id="kobo.846.1"> method. </span><span class="kobospan" id="kobo.846.2">We will need to provide it with the executor and an </span><strong class="source-inline"><span class="kobospan" id="kobo.847.1">ImageCapture.OnImageCapturedCallback</span></strong><span class="kobospan" id="kobo.848.1"> class. </span><span class="kobospan" id="kobo.848.2">This class provides callback methods for when an image is successfully captured or when an </span><span><span class="kobospan" id="kobo.849.1">error occurs.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.850.1">In the case of </span><a id="_idIndexMarker598" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.851.1">success, we will switch to the </span><strong class="bold"><span class="kobospan" id="kobo.852.1">I/O dispatcher</span></strong><span class="kobospan" id="kobo.853.1"> so that we can process the ImageProxy transformation into a bitmap in the background. </span><span class="kobospan" id="kobo.853.2">Once it’s been transformed, we call the </span><strong class="source-inline"><span class="kobospan" id="kobo.854.1">onPhotoCaptured</span></strong><span class="kobospan" id="kobo.855.1"> Lambda from the main dispatcher. </span><span class="kobospan" id="kobo.855.2">Alternatively, if there is any error, we will receive them via the </span><strong class="source-inline"><span class="kobospan" id="kobo.856.1">onError(exception: ImageCaptureException)</span></strong><span class="kobospan" id="kobo.857.1"> callback. </span><span class="kobospan" id="kobo.857.2">Then, we will pass the error to the </span><strong class="source-inline"><span class="kobospan" id="kobo.858.1">onError</span></strong><span class="kobospan" id="kobo.859.1"> callback function, which we received as the parameter of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.860.1">capturePhoto()</span></strong></span><span><span class="kobospan" id="kobo.861.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.862.1">Now, let’s link the capture functionality</span><a id="_idIndexMarker599" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.863.1"> with our UI. </span><span class="kobospan" id="kobo.863.2">We already have</span><a id="_idIndexMarker600" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.864.1"> a button for doing the capture in our </span><strong class="source-inline"><span class="kobospan" id="kobo.865.1">StoryContent</span></strong><span class="kobospan" id="kobo.866.1"> composable, </span><strong class="source-inline"><span class="kobospan" id="kobo.867.1">OutlinedButton</span></strong><span class="kobospan" id="kobo.868.1">, so let’s see how we can call this capture function </span><span><span class="kobospan" id="kobo.869.1">from it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.870.1">
OutlinedButton(
                    onClick = { capturePhoto(
                        context = localContext,
                        cameraController =
                            cameraController,
                        onPhotoCaptured = {
                            onImageCaptured(it) },
                        onError = { /* Show error */ }
                            )
                    },
                    modifier = Modifier.size(50.dp),
                    shape = CircleShape,
                    border = BorderStroke(4.dp,
                        MaterialTheme.colorScheme.primary),
                    contentPadding = PaddingValues(0.dp),
                    colors =
                        ButtonDefaults.outlinedButtonColors
                            (contentColor =
                                MaterialTheme.colorScheme
                                    .primary)
                ) {
                }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.871.1">As we can see, we are calling</span><a id="_idIndexMarker601" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.872.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.873.1">capturePhoto</span></strong><span class="kobospan" id="kobo.874.1"> function</span><a id="_idIndexMarker602" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.875.1"> from the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.876.1">onClick</span></strong></span><span><span class="kobospan" id="kobo.877.1"> button.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.878.1">With this, we are ready to capture </span><span><span class="kobospan" id="kobo.879.1">our photos:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer042">
<span class="kobospan" id="kobo.880.1"><img alt="Figure 5.2: Image preview with the capture button" src="image/B19443_05_002.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.881.1">Figure 5.2: Image preview with the capture button</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.882.1">With that, we have created</span><a id="_idIndexMarker603" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.883.1"> a use case so that we can store</span><a id="_idIndexMarker604" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.884.1"> our photos and link the functionality with our already existing UI. </span><span class="kobospan" id="kobo.884.2">Our users can also capture and store their photos. </span><span class="kobospan" id="kobo.884.3">Next, let’s see if we can enable them so that we can edit some aspects </span><span><span class="kobospan" id="kobo.885.1">of them.</span></span></p>
<h1 id="_idParaDest-120" class="calibre5"><a id="_idTextAnchor121" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.886.1">Adding photo-editing functionalities</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.887.1">There are multiple operations</span><a id="_idIndexMarker605" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.888.1"> that we can enable for the user to edit and modify their images: we can allow them to crop, resize, and rotate the image, as well as adjust</span><a id="_idIndexMarker606" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.889.1"> the brightness and contrast, apply filters, or add </span><span><span class="kobospan" id="kobo.890.1">text overlays.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.891.1">As part of this chapter, we are going to implement two operations: a black-and-white filter and a </span><span><span class="kobospan" id="kobo.892.1">text overlay.</span></span></p>
<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor122" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.893.1">Adding filters</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.894.1">Creating filters over an existing image</span><a id="_idIndexMarker607" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.895.1"> is as easy as modifying the values</span><a id="_idIndexMarker608" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.896.1"> of the bitmap that contains the image. </span><span class="kobospan" id="kobo.896.2">There are several well-known filters, such as sepia, vintage, and black and white. </span><span class="kobospan" id="kobo.896.3">As an example, we are going to implement the black and white filter, </span><span><span class="kobospan" id="kobo.897.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.898.1">
@Composable
fun BlackAndWhiteFilter(
    imageUri: Uri,
    modifier: Modifier = Modifier
) {
    var isBlackAndWhiteEnabled by remember {
    mutableStateOf(false) }
    val localContext = LocalContext.current
    Box(modifier = modifier.fillMaxSize()) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            getBitmapFromUri(localContext, imageUri)?.let {
                val imageBitMap = it.asImageBitmap()
                val colorFilter = if
                (isBlackAndWhiteEnabled) {
                    val colorMatrix = ColorMatrix().apply {
                        setToSaturation(0f) }
                    ColorFilter.colorMatrix(colorMatrix)
                } else {
                    null
                }
                val (offsetX, offsetY) =
                    getCanvasImageOffset(imageBitMap)
                val scaleFactor =
                    getCanvasImageScale(imageBitMap)
                with(drawContext.canvas) {
                    save()
                    translate(offsetX, offsetY)
                    scale(scaleFactor, scaleFactor)
                    drawImage(
                        image = imageBitMap,
                        topLeft =
                            androidx.compose.ui.geometry
                                .Offset.Zero,
                        colorFilter = colorFilter
                    )
                    restore()
                }
            }
        }
        Button(
            onClick = { isBlackAndWhiteEnabled =
                !isBlackAndWhiteEnabled },
            modifier = Modifier.padding(16.dp)
        ) {
            Text("Apply Black and White Filter")
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.899.1">This function starts</span><a id="_idIndexMarker609" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.900.1"> by accepting </span><strong class="source-inline"><span class="kobospan" id="kobo.901.1">imageUri</span></strong><span class="kobospan" id="kobo.902.1">, which is the URI representing the image</span><a id="_idIndexMarker610" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.903.1"> to be displayed, and an optional modifier parameter to customize </span><span><span class="kobospan" id="kobo.904.1">the layout.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.905.1">Within the function, a state variable called </span><strong class="source-inline"><span class="kobospan" id="kobo.906.1">isBlackAndWhiteEnabled</span></strong><span class="kobospan" id="kobo.907.1"> is declared using </span><strong class="source-inline"><span class="kobospan" id="kobo.908.1">remember</span></strong><span class="kobospan" id="kobo.909.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.910.1">mutableStateOf</span></strong><span class="kobospan" id="kobo.911.1">, which tracks whether the black-and-white filter is applied. </span><span class="kobospan" id="kobo.911.2">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.912.1">LocalContext.current</span></strong><span class="kobospan" id="kobo.913.1"> provides the context needed to load the image from </span><span><span class="kobospan" id="kobo.914.1">the URI.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.915.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.916.1">Box</span></strong><span class="kobospan" id="kobo.917.1"> composable is used to contain the entire layout, ensuring that the content fills the available space. </span><span class="kobospan" id="kobo.917.2">Inside </span><strong class="source-inline"><span class="kobospan" id="kobo.918.1">Box</span></strong><span class="kobospan" id="kobo.919.1">, a </span><strong class="source-inline"><span class="kobospan" id="kobo.920.1">Canvas</span></strong><span class="kobospan" id="kobo.921.1"> composable is used to draw the image. </span><span class="kobospan" id="kobo.921.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.922.1">Canvas</span></strong><span class="kobospan" id="kobo.923.1"> modifier is set to fill the </span><span><span class="kobospan" id="kobo.924.1">available size.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.925.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.926.1">Canvas</span></strong><span class="kobospan" id="kobo.927.1"> composable uses the </span><strong class="source-inline"><span class="kobospan" id="kobo.928.1">getBitmapFromUri</span></strong><span class="kobospan" id="kobo.929.1"> function to load the image as a </span><strong class="source-inline"><span class="kobospan" id="kobo.930.1">Bitmap</span></strong><span class="kobospan" id="kobo.931.1">, which is then converted into </span><strong class="source-inline"><span class="kobospan" id="kobo.932.1">ImageBitmap</span></strong><span class="kobospan" id="kobo.933.1"> using the </span><strong class="source-inline"><span class="kobospan" id="kobo.934.1">asImageBitmap</span></strong><span class="kobospan" id="kobo.935.1"> extension function. </span><span class="kobospan" id="kobo.935.2">If the </span><strong class="source-inline"><span class="kobospan" id="kobo.936.1">isBlackAndWhiteEnabled</span></strong><span class="kobospan" id="kobo.937.1"> state is true, a </span><strong class="source-inline"><span class="kobospan" id="kobo.938.1">ColorMatrix</span></strong><span class="kobospan" id="kobo.939.1"> value with zero saturation is applied to create a black-and-white </span><strong class="source-inline"><span class="kobospan" id="kobo.940.1">ColorFilter</span></strong><span class="kobospan" id="kobo.941.1">. </span><span class="kobospan" id="kobo.941.2">Otherwise, no color filter </span><span><span class="kobospan" id="kobo.942.1">is applied.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.943.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.944.1">getCanvasImageOffset</span></strong><span class="kobospan" id="kobo.945.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.946.1">getCanvasImageScale</span></strong><span class="kobospan" id="kobo.947.1"> functions are used to calculate the offset and scale factor needed to center and scale the image within the canvas. </span><span class="kobospan" id="kobo.947.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.948.1">with(drawContext.canvas)</span></strong><span class="kobospan" id="kobo.949.1"> block is used to draw the image. </span><span class="kobospan" id="kobo.949.2">Within this block, </span><strong class="source-inline"><span class="kobospan" id="kobo.950.1">save</span></strong><span class="kobospan" id="kobo.951.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.952.1">restore</span></strong><span class="kobospan" id="kobo.953.1"> are called to save and restore the canvas state, ensuring that transformations do not affect subsequent drawing operations. </span><span class="kobospan" id="kobo.953.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.954.1">translate</span></strong><span class="kobospan" id="kobo.955.1"> function applies the calculated offsets, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.956.1">scale</span></strong><span class="kobospan" id="kobo.957.1"> function applies the scale factor, to fill the entire </span><strong class="source-inline"><span class="kobospan" id="kobo.958.1">Canvas</span></strong><span class="kobospan" id="kobo.959.1"> with the image. </span><span class="kobospan" id="kobo.959.2">Finally, the </span><strong class="source-inline"><span class="kobospan" id="kobo.960.1">drawImage</span></strong><span class="kobospan" id="kobo.961.1"> function draws the image on the canvas with the optional </span><span><span class="kobospan" id="kobo.962.1">color filter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.963.1">Below </span><strong class="source-inline"><span class="kobospan" id="kobo.964.1">Canvas</span></strong><span class="kobospan" id="kobo.965.1">, a </span><strong class="source-inline"><span class="kobospan" id="kobo.966.1">Button</span></strong><span class="kobospan" id="kobo.967.1"> composable is placed within </span><strong class="source-inline"><span class="kobospan" id="kobo.968.1">Box</span></strong><span class="kobospan" id="kobo.969.1">. </span><span class="kobospan" id="kobo.969.2">This button is used to toggle the </span><strong class="source-inline"><span class="kobospan" id="kobo.970.1">isBlackAndWhiteEnabled</span></strong><span class="kobospan" id="kobo.971.1"> state when clicked. </span><span class="kobospan" id="kobo.971.2">The button’s </span><strong class="source-inline"><span class="kobospan" id="kobo.972.1">onClick</span></strong><span class="kobospan" id="kobo.973.1"> Lambda updates the state variable, and the button’s text is set to </span><strong class="bold"><span class="kobospan" id="kobo.974.1">Apply Black and White Filter</span></strong><span class="kobospan" id="kobo.975.1">. </span><span class="kobospan" id="kobo.975.2">The modifier parameter</span><a id="_idIndexMarker611" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.976.1"> for the button includes padding</span><a id="_idIndexMarker612" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.977.1"> to ensure it is not placed at the edge of </span><span><span class="kobospan" id="kobo.978.1">the screen.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.979.1">Now that we have built our first filter, let’s learn how to implement </span><span><span class="kobospan" id="kobo.980.1">text overlays.</span></span></p>
<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor123" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.981.1">Adding a text overlay</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.982.1">Adding a text overlay</span><a id="_idIndexMarker613" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.983.1"> is a typical image editing</span><a id="_idIndexMarker614" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.984.1"> functionality that allows us to tag other people, add a hashtag to an image, or add an accompanying written message. </span><span class="kobospan" id="kobo.984.2">Let’s see how we can offer our users </span><span><span class="kobospan" id="kobo.985.1">this functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.986.1">First, we are going to create a composable that contains the state of the </span><strong class="source-inline"><span class="kobospan" id="kobo.987.1">Text</span></strong><span class="kobospan" id="kobo.988.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.989.1">Image</span></strong><span class="kobospan" id="kobo.990.1"> components. </span><span class="kobospan" id="kobo.990.2">This state will update as the user updates the text. </span><span class="kobospan" id="kobo.990.3">Here’s </span><span><span class="kobospan" id="kobo.991.1">the code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.992.1">
@Composable
fun ImageWithTextOverlay(capturedBitmap: Bitmap) {
    var textOverlay = remember { mutableStateOf("Add your
        text here") }
    var showTextField = remember { mutableStateOf(false) }
    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            bitmap = capturedBitmap.asImageBitmap(),
            contentDescription = "Captured Image",
            modifier = Modifier.matchParentSize()
        )
        if (showTextField) {
            TextField(
                value = textOverlay,
                onValueChange = { textOverlay = it },
                modifier = Modifier
                    .align(Alignment.Center)
                    .padding(16.dp)
            )
        }
        Text(
            text = textOverlay,
            color = Color.White,
            fontSize = 24.sp,
            modifier = Modifier.align(Alignment.Center)
        )
        FloatingActionButton(
            onClick = { showTextField = !showTextField },
            modifier = Modifier
                .align(Alignment.BottomEnd)
                .padding(16.dp)
        ) {
            Icon(Icons.Default.Edit, contentDescription =
                "Edit Text")
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.993.1">This example defines</span><a id="_idIndexMarker615" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.994.1"> a composable function</span><a id="_idIndexMarker616" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.995.1"> called </span><strong class="source-inline"><span class="kobospan" id="kobo.996.1">ImageWithTextOverlay</span></strong><span class="kobospan" id="kobo.997.1">. </span><span class="kobospan" id="kobo.997.2">It accepts a bitmap object named </span><strong class="source-inline"><span class="kobospan" id="kobo.998.1">capturedBitmap</span></strong><span class="kobospan" id="kobo.999.1">, which represents the captured image that will be displayed with a </span><span><span class="kobospan" id="kobo.1000.1">text overlay.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1001.1">The function starts by defining two pieces </span><span><span class="kobospan" id="kobo.1002.1">of state:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.1003.1">First, we have </span><strong class="source-inline1"><span class="kobospan" id="kobo.1004.1">textOverlay</span></strong><span class="kobospan" id="kobo.1005.1">, which holds the text that will be displayed over the image. </span><span class="kobospan" id="kobo.1005.2">It’s initially set to a default value of </span><strong class="bold"><span class="kobospan" id="kobo.1006.1">Add your </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1007.1">text here</span></strong></span><span><span class="kobospan" id="kobo.1008.1">.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1009.1">Then, we have a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1010.1">showTextField</span></strong><span class="kobospan" id="kobo.1011.1"> Boolean, which determines whether the text editing field (</span><strong class="source-inline1"><span class="kobospan" id="kobo.1012.1">TextField</span></strong><span class="kobospan" id="kobo.1013.1">) is visible or not. </span><span class="kobospan" id="kobo.1013.2">It’s initially set </span><span><span class="kobospan" id="kobo.1014.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1015.1">false</span></strong></span><span><span class="kobospan" id="kobo.1016.1">.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1017.1">Within the function, we use a </span><strong class="source-inline"><span class="kobospan" id="kobo.1018.1">Box</span></strong><span class="kobospan" id="kobo.1019.1"> composable as a container. </span><span class="kobospan" id="kobo.1019.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1020.1">Box</span></strong><span class="kobospan" id="kobo.1021.1"> composable allows us to layer its child components, and we set its size to fill the maximum available space. </span><span class="kobospan" id="kobo.1021.2">This creates an area where we can overlay text on top of </span><span><span class="kobospan" id="kobo.1022.1">an image.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1023.1">The first child of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1024.1">Box</span></strong><span class="kobospan" id="kobo.1025.1"> composable is an </span><strong class="source-inline"><span class="kobospan" id="kobo.1026.1">Image</span></strong><span class="kobospan" id="kobo.1027.1"> composable, which is responsible for displaying the captured photo. </span><span class="kobospan" id="kobo.1027.2">The photo is passed to this function as a bitmap, and we ensure that it fills the entire parent container, ensuring that the image takes up the whole screen </span><span><span class="kobospan" id="kobo.1028.1">space available.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1029.1">Next, we check the state of </span><strong class="source-inline"><span class="kobospan" id="kobo.1030.1">showTextField</span></strong><span class="kobospan" id="kobo.1031.1">. </span><span class="kobospan" id="kobo.1031.2">If it’s </span><strong class="source-inline"><span class="kobospan" id="kobo.1032.1">true</span></strong><span class="kobospan" id="kobo.1033.1">, we display </span><strong class="source-inline"><span class="kobospan" id="kobo.1034.1">TextField</span></strong><span class="kobospan" id="kobo.1035.1"> in the center of the screen. </span><span class="kobospan" id="kobo.1035.2">This </span><strong class="source-inline"><span class="kobospan" id="kobo.1036.1">TextField</span></strong><span class="kobospan" id="kobo.1037.1"> allows the user to input or edit the text that will be overlaid on the image. </span><span class="kobospan" id="kobo.1037.2">As the user types, the text in </span><strong class="source-inline"><span class="kobospan" id="kobo.1038.1">textOverlay</span></strong><span class="kobospan" id="kobo.1039.1"> is updated in real time thanks to the two-way binding provided by </span><span><span class="kobospan" id="kobo.1040.1">Jetpack Compose.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1041.1">Regardless of the state of </span><strong class="source-inline"><span class="kobospan" id="kobo.1042.1">showTextField</span></strong><span class="kobospan" id="kobo.1043.1">, we always display a </span><strong class="source-inline"><span class="kobospan" id="kobo.1044.1">Text</span></strong><span class="kobospan" id="kobo.1045.1"> composable. </span><span class="kobospan" id="kobo.1045.2">This component is responsible for rendering the overlay text on top of the image. </span><span class="kobospan" id="kobo.1045.3">We style this text to be white and of a reasonable font size, ensuring it’s visible against a variety </span><span><span class="kobospan" id="kobo.1046.1">of backgrounds.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1047.1">Finally, at the bottom corner of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1048.1">Box</span></strong><span class="kobospan" id="kobo.1049.1"> composable, we place </span><strong class="source-inline"><span class="kobospan" id="kobo.1050.1">FloatingActionButton</span></strong><span class="kobospan" id="kobo.1051.1">. </span><span class="kobospan" id="kobo.1051.2">This button, when clicked, toggles the visibility of </span><strong class="source-inline"><span class="kobospan" id="kobo.1052.1">TextField</span></strong><span class="kobospan" id="kobo.1053.1">, allowing the user to switch between viewing the overlaid text and editing it. </span><span class="kobospan" id="kobo.1053.2">The button is intuitively designed with an edit icon, signaling its purpose to </span><span><span class="kobospan" id="kobo.1054.1">the user.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1055.1">Now, imagine that we want to allow</span><a id="_idIndexMarker617" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1056.1"> the user to move the text whenever</span><a id="_idIndexMarker618" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1057.1"> they want in the image. </span><span class="kobospan" id="kobo.1057.2">Let’s implement some drag-and-drop magic. </span><span class="kobospan" id="kobo.1057.3">We will start by updating the </span><strong class="source-inline"><span class="kobospan" id="kobo.1058.1">ImageWithTextOverlay</span></strong> <span><span class="kobospan" id="kobo.1059.1">composable function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1060.1">
@Composable
fun ImageWithTextOverlay(capturedBitmap: Bitmap) {
    var textOverlay = remember { mutableStateOf("Your text
        here") }
    var showTextField = remember { mutableStateOf(false) }
    var textPosition by remember {
        mutableStateOf(Offset.Zero) }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1061.1">In this updated version of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1062.1">ImageWithTextOverlay</span></strong><span class="kobospan" id="kobo.1063.1"> composable function, we’ve introduced an interactive feature that allows users to drag and position the text overlay anywhere on the image. </span><span class="kobospan" id="kobo.1063.2">To achieve this, we added a new state variable, </span><strong class="source-inline"><span class="kobospan" id="kobo.1064.1">textPosition</span></strong><span class="kobospan" id="kobo.1065.1">, initialized to </span><strong class="source-inline"><span class="kobospan" id="kobo.1066.1">Offset.Zero</span></strong><span class="kobospan" id="kobo.1067.1">. </span><span class="kobospan" id="kobo.1067.2">This state holds the current position of the text overlay on the screen. </span><span class="kobospan" id="kobo.1067.3">Now, we must create a new composable function, </span><strong class="source-inline"><span class="kobospan" id="kobo.1068.1">DraggableText</span></strong><span class="kobospan" id="kobo.1069.1">, to handle the text display and its </span><span><span class="kobospan" id="kobo.1070.1">draggable functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1071.1">Let’s add this </span><strong class="source-inline"><span class="kobospan" id="kobo.1072.1">DraggableText</span></strong><span class="kobospan" id="kobo.1073.1"> to our </span><span><span class="kobospan" id="kobo.1074.1">existing code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1075.1">
    val imageModifier = Modifier.fillMaxSize()
    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            bitmap = capturedBitmap.asImageBitmap(),
            contentDescription = "Captured Image",
            modifier = imageModifier
        )
        if (showTextField) {
            TextField(
                value = textOverlay,
                onValueChange = { textOverlay = it },
                modifier = Modifier
                    .align(Alignment.Center)
                    .padding(16.dp)
            )
        }
        DraggableText(
            text = textOverlay,
            position = textPosition,
            onPositionChange = { newPosition -&gt;
                textPosition = newPosition },
            modifier = Modifier
                .offset { IntOffset(textPosition.x.toInt(),
                    textPosition.y.toInt()) }
                .align(Alignment.Center)
        )
        FloatingActionButton(
            onClick = { showTextField = !showTextField },
            modifier = Modifier
                .align(Alignment.BottomEnd)
                .padding(16.dp)
        ) {
            Icon(Icons.Default.Edit, contentDescription =
                "Edit Text")
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1076.1">Here, the existing functionality</span><a id="_idIndexMarker619" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1077.1"> for editing the text</span><a id="_idIndexMarker620" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1078.1"> through </span><strong class="source-inline"><span class="kobospan" id="kobo.1079.1">TextField</span></strong><span class="kobospan" id="kobo.1080.1"> is the same. </span><span class="kobospan" id="kobo.1080.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1081.1">TextField</span></strong><span class="kobospan" id="kobo.1082.1"> field appears when the user wishes to edit the text, facilitated by a floating action button. </span><span class="kobospan" id="kobo.1082.2">This button toggles the visibility of </span><strong class="source-inline"><span class="kobospan" id="kobo.1083.1">TextField</span></strong><span class="kobospan" id="kobo.1084.1">, allowing users to switch seamlessly between editing the text and adjusting </span><span><span class="kobospan" id="kobo.1085.1">its position.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1086.1">Now, we are ready to create the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1087.1">DraggableText</span></strong></span><span><span class="kobospan" id="kobo.1088.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1089.1">
@Composable
fun DraggableText(
    text: String,
    position: Offset,
    onPositionChange: (Offset) -&gt; Unit,
    modifier: Modifier = Modifier
) {</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1090.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1091.1">DraggableText</span></strong><span class="kobospan" id="kobo.1092.1"> composable takes several parameters, including the text to display, its current position, and a callback function, </span><strong class="source-inline"><span class="kobospan" id="kobo.1093.1">onPositionChange</span></strong><span class="kobospan" id="kobo.1094.1">, which updates this position. </span><span class="kobospan" id="kobo.1094.2">Within </span><strong class="source-inline"><span class="kobospan" id="kobo.1095.1">DraggableText</span></strong><span class="kobospan" id="kobo.1096.1">, we utilize the draggable modifier on the </span><strong class="source-inline"><span class="kobospan" id="kobo.1097.1">Text</span></strong><span class="kobospan" id="kobo.1098.1"> composable. </span><span class="kobospan" id="kobo.1098.2">This modifier is pivotal as it allows the text to be moved across the screen. </span><span class="kobospan" id="kobo.1098.3">As the user drags the text, the drag offset is updated, which, in turn, updates the </span><strong class="source-inline"><span class="kobospan" id="kobo.1099.1">textPosition</span></strong><span class="kobospan" id="kobo.1100.1"> state in the main </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1101.1">ImageWithTextOverlay</span></strong></span><span><span class="kobospan" id="kobo.1102.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1103.1">Finally, define  the variables</span><a id="_idIndexMarker621" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1104.1"> that are needed</span><a id="_idIndexMarker622" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1105.1"> and the </span><strong class="source-inline"><span class="kobospan" id="kobo.1106.1">Text</span></strong><span class="kobospan" id="kobo.1107.1"> composable to show </span><span><span class="kobospan" id="kobo.1108.1">the text:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1109.1">
    var dragOffset = remember { mutableStateOf(position) }
    Text(
        text = text,
        color = Color.White,
        fontSize = 24.sp,
        modifier = modifier
            .offset {
                IntOffset(dragOffset.value.x.roundToInt(),
                    dragOffset.value.y.roundToInt()) }
            .pointerInput(Unit) {
                detectDragGestures { change, dragAmount -&gt;
                    change.consume()
                    dragOffset.value =
                        Offset((dragOffset.value.x +
                            dragAmount.x),
                                (dragOffset.value.y +
                                    dragAmount.y))
                    onPositionChange(dragOffset.value)
                }
            }
            .background(
                color = Color.Black.copy(alpha = 0.5f),
                shape = RoundedCornerShape(8.dp)
            )
    )</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1110.1">We begin by initializing a state to hold the current drag offset. </span><span class="kobospan" id="kobo.1110.2">This state will track the position of the text as it </span><span><span class="kobospan" id="kobo.1111.1">is dragged.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1112.1">Next, we define the </span><strong class="source-inline"><span class="kobospan" id="kobo.1113.1">Text</span></strong><span class="kobospan" id="kobo.1114.1"> composable to display our draggable text. </span><span class="kobospan" id="kobo.1114.2">To control the positioning of the text, we use the offset modifier, which positions the text based on the current </span><span><span class="kobospan" id="kobo.1115.1">drag offset.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1116.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1117.1">pointerInput</span></strong><span class="kobospan" id="kobo.1118.1"> modifier</span><a id="_idIndexMarker623" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1119.1"> allows us to handle drag gestures</span><a id="_idIndexMarker624" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1120.1"> on the text element. </span><span class="kobospan" id="kobo.1120.2">Within the </span><strong class="source-inline"><span class="kobospan" id="kobo.1121.1">detectDragGestures</span></strong><span class="kobospan" id="kobo.1122.1"> block, we update the drag offset by adding the drag amount to the current offset each time the user drags the text. </span><span class="kobospan" id="kobo.1122.2">The gesture change is consumed to indicate that the drag event has been handled, and we call a function to handle any additional actions that are needed when the </span><span><span class="kobospan" id="kobo.1123.1">position changes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1124.1">And with that, here are the two filters we </span><span><span class="kobospan" id="kobo.1125.1">have created:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer043">
<span class="kobospan" id="kobo.1126.1"><img alt="Figure 5.3: The black and white filter composable (left) and text overlay (right)" src="image/B19443_05_003.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1127.1">Figure 5.3: The black and white filter composable (left) and text overlay (right)</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1128.1">At this point, we have already</span><a id="_idIndexMarker625" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1129.1"> implemented some cool</span><a id="_idIndexMarker626" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1130.1"> features for our users, such as a black-and-white filter and the possibility to add a caption. </span><span class="kobospan" id="kobo.1130.2">So, why don’t leverage the use of ML to build outstanding features? </span><span class="kobospan" id="kobo.1130.3">We’ll look at this in the </span><span><span class="kobospan" id="kobo.1131.1">next section.</span></span></p>
<h1 id="_idParaDest-123" class="calibre5"><a id="_idTextAnchor124" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1132.1">Using ML to categorize photos and generate hashtags</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1133.1">ML is a branch of </span><strong class="bold"><span class="kobospan" id="kobo.1134.1">artificial intelligence</span></strong><span class="kobospan" id="kobo.1135.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1136.1">AI</span></strong><span class="kobospan" id="kobo.1137.1">) that focuses on building systems</span><a id="_idIndexMarker627" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1138.1"> that can learn</span><a id="_idIndexMarker628" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1139.1"> from and make decisions</span><a id="_idIndexMarker629" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1140.1"> based on data. </span><span class="kobospan" id="kobo.1140.2">Unlike</span><a id="_idIndexMarker630" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1141.1"> traditional software, which follows explicitly programmed instructions, ML algorithms use statistical techniques to enable computers to improve at tasks with experience. </span><span class="kobospan" id="kobo.1141.2">The fundamental premise of ML is to develop algorithms that can receive input data and use statistical analysis to predict or make decisions about some aspect of </span><span><span class="kobospan" id="kobo.1142.1">the data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1143.1">ML is a huge field that is outside the scope of this book, but we still can do interesting things using already-built libraries. </span><span class="kobospan" id="kobo.1143.2">For example, </span><strong class="bold"><span class="kobospan" id="kobo.1144.1">ML Kit</span></strong><span class="kobospan" id="kobo.1145.1"> is a powerful ML solution</span><a id="_idIndexMarker631" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1146.1"> offered by Google for mobile developers that provides a suite of ready-to-use APIs for various ML tasks, both on-device and cloud-based. </span><span class="kobospan" id="kobo.1146.2">These functionalities are designed to be easily integrated into mobile applications, facilitating the use of ML without requiring deep expertise in the field. </span><span class="kobospan" id="kobo.1146.3">Here’s an overview of the key functionalities</span><a id="_idIndexMarker632" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1147.1"> offered by </span><span><span class="kobospan" id="kobo.1148.1">ML Kit:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1149.1">Image labeling</span></strong><span class="kobospan" id="kobo.1150.1">: Identifies objects, locations, activities, animal species, products, and more within </span><span><span class="kobospan" id="kobo.1151.1">an image.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1152.1">Text recognition</span></strong><span class="kobospan" id="kobo.1153.1">: Extracts text from images. </span><span class="kobospan" id="kobo.1153.2">This can be useful for </span><strong class="bold"><span class="kobospan" id="kobo.1154.1">optical character recognition</span></strong><span class="kobospan" id="kobo.1155.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1156.1">OCR</span></strong><span class="kobospan" id="kobo.1157.1">) applications, such as scanning</span><a id="_idIndexMarker633" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1158.1"> documents, business cards, or any printed or </span><span><span class="kobospan" id="kobo.1159.1">handwritten text.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1160.1">Face detection</span></strong><span class="kobospan" id="kobo.1161.1">: Detects faces in an image, including key facial features such as eyes and nose, and characteristics such as smiles or head tilt. </span><span class="kobospan" id="kobo.1161.2">This is useful in applications such as photo tagging and </span><span><span class="kobospan" id="kobo.1162.1">facial recognition.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1163.1">Barcode scanning</span></strong><span class="kobospan" id="kobo.1164.1">: Reads and scans barcodes and QR codes. </span><span class="kobospan" id="kobo.1164.2">It supports various formats, including UPC, EAN, Code 39, </span><span><span class="kobospan" id="kobo.1165.1">and others.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1166.1">Object detection and tracking</span></strong><span class="kobospan" id="kobo.1167.1">: Identifies and tracks objects in an image or video stream. </span><span class="kobospan" id="kobo.1167.2">This feature is useful in scenarios such as real-time </span><span><span class="kobospan" id="kobo.1168.1">video analysis.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1169.1">You can learn more</span><a id="_idIndexMarker634" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1170.1"> about ML Kit’s features </span><span><span class="kobospan" id="kobo.1171.1">at </span></span><a href="https://developers.google.com/ml-kit" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.1172.1">https://developers.google.com/ml-kit</span></span></a><span><span class="kobospan" id="kobo.1173.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1174.1">As an example, we are going</span><a id="_idIndexMarker635" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1175.1"> to create the logic to identify and label elements</span><a id="_idIndexMarker636" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1176.1"> in the photo that could be used in the future to categorize the images or create automatic hashtags. </span><span class="kobospan" id="kobo.1176.2">We will start by adding the corresponding dependencies </span><span><span class="kobospan" id="kobo.1177.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1178.1">libs.versions.toml</span></strong></span><span><span class="kobospan" id="kobo.1179.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1180.1">
[versions]
...
</span><span class="kobospan1" id="kobo.1180.2">ml-labeling = "17.0.5"
[libraries]
...
</span><span class="kobospan1" id="kobo.1180.3">mlKitLabeling= { group = "com.google.mlkit", name = "image-labeling", version.ref="ml-labeling"}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1181.1">Then, we will add these dependencies to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1182.1">build.gradle</span></strong><span class="kobospan" id="kobo.1183.1"> file of the module. </span><span class="kobospan" id="kobo.1183.2">This is where we are creating this </span><span><span class="kobospan" id="kobo.1184.1">functionality (</span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1185.1">feature:stories</span></strong></span><span><span class="kobospan" id="kobo.1186.1">):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1187.1">
    implementation(libs.mlKitLabeling)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1188.1">Now, we can create</span><a id="_idIndexMarker637" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1189.1"> the actual code. </span><span class="kobospan" id="kobo.1189.2">We are going</span><a id="_idIndexMarker638" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1190.1"> to leverage the image analysis feature from CameraX and analyze the preview using MLKitLabeling before using the results to write them in over the image. </span><span class="kobospan" id="kobo.1190.2">To do this, we will create a new preview composable just for </span><span><span class="kobospan" id="kobo.1191.1">this feature:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1192.1">
@Composable
fun CameraPreviewWithImageLabeler(cameraController: LifecycleCameraController, modifier: Modifier = Modifier) {
    val context = LocalContext.current
    var labels by remember {
        mutableStateOf&lt;List&lt;String&gt;&gt;(emptyList()) }
    val cameraProviderFuture = remember {
        ProcessCameraProvider.getInstance(context) }
    val previewView = remember { PreviewView(context) }
    val imageAnalysis = remember {
        ImageAnalysis.Builder()
            .setTargetResolution(Size(1280, 720))
            .setBackpressureStrategy(
                ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
            .build()
    }
    DisposableEffect(Unit) {
        val cameraProvider = cameraProviderFuture.get()
        val preview = Preview.Builder().build().also {
            it.setSurfaceProvider(
                previewView.surfaceProvider)
        }
        val cameraSelector =
            CameraSelector.DEFAULT_BACK_CAMERA
        cameraProvider.bindToLifecycle(
            context as LifecycleOwner, cameraSelector,
                preview, imageAnalysis)
        onDispose {
            cameraProvider.unbindAll()
        }
    }
    imageAnalysis.setAnalyzer(ContextCompat.getMainExecutor
    (context)) { imageProxy -&gt;
        processImageProxyForLabeling(imageProxy) {
        detectedLabels -&gt;
            labels = detectedLabels
        }
    }
    Box(modifier = modifier) {
        AndroidView(
            factory = { previewView },
            modifier = modifier
        )
        Canvas(modifier = Modifier.fillMaxSize()) {
            drawIntoCanvas { canvas -&gt;
                val paint = android.graphics.Paint().apply
                {
                    color = android.graphics.Color.RED
                    textSize = 60f
                }
                labels.forEachIndexed { index, label -&gt;
                    canvas.nativeCanvas.drawText(label,
                        10f, 100f + index * 70f, paint)
                }
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1193.1">The start of this function</span><a id="_idIndexMarker639" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1194.1"> is pretty similar to our already</span><a id="_idIndexMarker640" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1195.1"> existing </span><strong class="source-inline"><span class="kobospan" id="kobo.1196.1">CameraPreview</span></strong><span class="kobospan" id="kobo.1197.1"> composable. </span><span class="kobospan" id="kobo.1197.2">After</span><a id="_idIndexMarker641" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1198.1"> the camera provider</span><a id="_idIndexMarker642" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1199.1"> is defined, an </span><strong class="source-inline"><span class="kobospan" id="kobo.1200.1">ImageAnalysis</span></strong><span class="kobospan" id="kobo.1201.1"> instance is configured with a target resolution of 1,280x720 pixels and a backpressure strategy set to </span><strong class="source-inline"><span class="kobospan" id="kobo.1202.1">STRATEGY_KEEP_ONLY_LATEST</span></strong><span class="kobospan" id="kobo.1203.1"> to process the latest </span><span><span class="kobospan" id="kobo.1204.1">image frame.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1205.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1206.1">imageAnalysis.setAnalyzer</span></strong><span class="kobospan" id="kobo.1207.1"> method sets an analyzer to process image frames using ML Kit’s Image Labeler. </span><span class="kobospan" id="kobo.1207.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1208.1">processImageProxyForLabeling</span></strong><span class="kobospan" id="kobo.1209.1"> function is called to process each image frame. </span><span class="kobospan" id="kobo.1209.2">The detected labels are passed to a Lambda function that updates the </span><strong class="source-inline"><span class="kobospan" id="kobo.1210.1">labels</span></strong><span class="kobospan" id="kobo.1211.1"> state variable. </span><span class="kobospan" id="kobo.1211.2">We will see how to implement this </span><span><span class="kobospan" id="kobo.1212.1">function shortly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1213.1">In the end, the </span><strong class="source-inline"><span class="kobospan" id="kobo.1214.1">Box</span></strong><span class="kobospan" id="kobo.1215.1"> composable is used to overlay </span><strong class="source-inline"><span class="kobospan" id="kobo.1216.1">PreviewView</span></strong><span class="kobospan" id="kobo.1217.1"> and a </span><strong class="source-inline"><span class="kobospan" id="kobo.1218.1">Canvas</span></strong><span class="kobospan" id="kobo.1219.1"> composable. </span><span class="kobospan" id="kobo.1219.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1220.1">Canvas</span></strong><span class="kobospan" id="kobo.1221.1"> composable is used to draw the detected labels on top of the camera preview. </span><span class="kobospan" id="kobo.1221.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1222.1">drawIntoCanvas</span></strong><span class="kobospan" id="kobo.1223.1"> method accesses the native </span><strong class="source-inline"><span class="kobospan" id="kobo.1224.1">canvas</span></strong><span class="kobospan" id="kobo.1225.1"> for drawing. </span><span class="kobospan" id="kobo.1225.2">A </span><strong class="source-inline"><span class="kobospan" id="kobo.1226.1">Paint</span></strong><span class="kobospan" id="kobo.1227.1"> object is configured with a red color and a text size of 60 pixels. </span><span class="kobospan" id="kobo.1227.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1228.1">forEachIndexed</span></strong><span class="kobospan" id="kobo.1229.1"> method iterates over the labels list, drawing each label at a specified position on </span><span><span class="kobospan" id="kobo.1230.1">the canvas.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1231.1">Now, let’s learn how we can implement the </span><span><span class="kobospan" id="kobo.1232.1">image analyzer:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1233.1">
@OptIn(ExperimentalGetImage::class)
private fun processImageProxyForLabeling(imageProxy:
ImageProxy, onLabelsDetected: (List&lt;String&gt;) -&gt; Unit) {
    val mediaImage = imageProxy.image
    if (mediaImage != null) {
        val image = InputImage.fromMediaImage(mediaImage,
            imageProxy.imageInfo.rotationDegrees)
        val labeler =
        ImageLabeling.getClient(
            ImageLabelerOptions.DEFAULT_OPTIONS)
        labeler.process(image)
            .addOnSuccessListener { labels -&gt;
                val labelNames = labels.map { it.text }
                onLabelsDetected(labelNames)
            }
            .addOnFailureListener { e -&gt;
                e.printStackTrace()
            }
            .addOnCompleteListener {
                imageProxy.close()
            }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1234.1">This function takes</span><a id="_idIndexMarker643" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1235.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.1236.1">ImageProxy</span></strong><span class="kobospan" id="kobo.1237.1"> object and a callback</span><a id="_idIndexMarker644" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1238.1"> function, </span><strong class="source-inline"><span class="kobospan" id="kobo.1239.1">onLabelsDetected</span></strong><span class="kobospan" id="kobo.1240.1">, as parameters, where</span><a id="_idIndexMarker645" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1241.1"> the callback</span><a id="_idIndexMarker646" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1242.1"> function is invoked with a list of </span><span><span class="kobospan" id="kobo.1243.1">detected labels.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1244.1">Within the function, </span><strong class="source-inline"><span class="kobospan" id="kobo.1245.1">mediaImage</span></strong><span class="kobospan" id="kobo.1246.1"> is extracted from the </span><strong class="source-inline"><span class="kobospan" id="kobo.1247.1">ImageProxy</span></strong><span class="kobospan" id="kobo.1248.1"> object. </span><span class="kobospan" id="kobo.1248.2">If </span><strong class="source-inline"><span class="kobospan" id="kobo.1249.1">mediaImage</span></strong><span class="kobospan" id="kobo.1250.1"> is not </span><strong class="source-inline"><span class="kobospan" id="kobo.1251.1">null</span></strong><span class="kobospan" id="kobo.1252.1">, it is converted into </span><strong class="source-inline"><span class="kobospan" id="kobo.1253.1">InputImage</span></strong><span class="kobospan" id="kobo.1254.1"> using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1255.1">InputImage.fromMediaImage</span></strong><span class="kobospan" id="kobo.1256.1"> method, which requires the media image and the rotation degrees </span><span><span class="kobospan" id="kobo.1257.1">from </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1258.1">imageProxy</span></strong></span><span><span class="kobospan" id="kobo.1259.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1260.1">An instance of the image labeler is obtained by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.1261.1">ImageLabeling.getClient</span></strong><span class="kobospan" id="kobo.1262.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.1263.1">ImageLabelerOptions.DEFAULT_OPTIONS</span></strong><span class="kobospan" id="kobo.1264.1">. </span><span class="kobospan" id="kobo.1264.2">This sets up the labeler with default configuration options suitable for general-purpose </span><span><span class="kobospan" id="kobo.1265.1">image labeling.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1266.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1267.1">labeler.process</span></strong><span class="kobospan" id="kobo.1268.1"> method</span><a id="_idIndexMarker647" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1269.1"> processes </span><strong class="source-inline"><span class="kobospan" id="kobo.1270.1">InputImage</span></strong><span class="kobospan" id="kobo.1271.1"> asynchronously. </span><span class="kobospan" id="kobo.1271.2">After, the processing</span><a id="_idIndexMarker648" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1272.1"> outcome</span><a id="_idIndexMarker649" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1273.1"> is handled by </span><span><span class="kobospan" id="kobo.1274.1">two</span></span><span><a id="_idIndexMarker650" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.1275.1"> listeners:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.1276.1">In </span><strong class="source-inline1"><span class="kobospan" id="kobo.1277.1">addOnSuccessListener</span></strong><span class="kobospan" id="kobo.1278.1">, the function receives a list of labels if the processing is successful. </span><span class="kobospan" id="kobo.1278.2">Each label in this list represents an element identified in the image, accompanied by a confidence score. </span><span class="kobospan" id="kobo.1278.3">The function iterates through these labels, logging the identified element (</span><strong class="source-inline1"><span class="kobospan" id="kobo.1279.1">label.text</span></strong><span class="kobospan" id="kobo.1280.1">) and its confidence score (</span><strong class="source-inline1"><span class="kobospan" id="kobo.1281.1">label.confidence)</span></strong><span class="kobospan" id="kobo.1282.1">. </span><span class="kobospan" id="kobo.1282.2">In future iterations, we could use this information to auto-create automatic overlays over the image or to inform the user of which could be the best hashtags for </span><span><span class="kobospan" id="kobo.1283.1">the image.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1284.1">In case of any failure during image processing, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1285.1">addOnFailureListener</span></strong><span class="kobospan" id="kobo.1286.1"> is invoked, which logs the error. </span><span class="kobospan" id="kobo.1286.2">This error handling is crucial for diagnosing issues that might occur during the ML process, such as problems with the input image or internal errors in the ML Kit </span><span><span class="kobospan" id="kobo.1287.1">processing pipeline.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1288.1">Now, if we replace our </span><strong class="source-inline"><span class="kobospan" id="kobo.1289.1">CameraPreview</span></strong><span class="kobospan" id="kobo.1290.1"> composable with the </span><strong class="source-inline"><span class="kobospan" id="kobo.1291.1">CameraPreviewImageLabeler</span></strong><span class="kobospan" id="kobo.1292.1"> composable, we should see the results of the image analysis </span><span><span class="kobospan" id="kobo.1293.1">taking place:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer044">
<span class="kobospan" id="kobo.1294.1"><img alt="Figure 5.4: ML labeling taking place in the live preview" src="image/B19443_05_004.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1295.1">Figure 5.4: ML </span><a href="https://developer.android.com/ml" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.1296.1">labeling taking place in the liv</span></a><span class="kobospan" id="kobo.1297.1">e preview</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1298.1">If you want</span><a id="_idIndexMarker651" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1299.1"> to know</span><a id="_idIndexMarker652" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1300.1"> more</span><a id="_idIndexMarker653" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1301.1"> about what</span><a id="_idIndexMarker654" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1302.1"> can be done</span><a id="_idIndexMarker655" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1303.1"> with the ML Kit library, check </span><span><span class="kobospan" id="kobo.1304.1">out </span></span><a href="https://developer.android.com/ml" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.1305.1">https://developer.android.com/ml</span></span></a><span><span class="kobospan" id="kobo.1306.1">.</span></span></p>
<h1 id="_idParaDest-124" class="calibre5"><a id="_idTextAnchor125" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1307.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1308.1">In this chapter, we started by familiarizing ourselves with CameraX, a key component of the Android Jetpack suite. </span><span class="kobospan" id="kobo.1308.2">We learned how to set up CameraX in our applications while enabling features such as live camera preview and </span><span><span class="kobospan" id="kobo.1309.1">image capture.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1310.1">Moving on, we delved into the practical implementation of capturing images using CameraX. </span><span class="kobospan" id="kobo.1310.2">Additionally, we introduced basic image editing functionalities, guiding you through the process of creating a filter and adding a text overlay. </span><span class="kobospan" id="kobo.1310.3">These skills are pivotal in enhancing the interactivity and user experience of </span><span><span class="kobospan" id="kobo.1311.1">photography apps.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1312.1">Finally, we unveiled the integration of Google’s ML Kit, demonstrating how to add advanced ML capabilities to the app. </span><span class="kobospan" id="kobo.1312.2">We explored how to use ML Kit to identify elements in images, such as objects. </span><span class="kobospan" id="kobo.1312.3">This experience highlighted the practical application of these technologies in enhancing the functionality of </span><span><span class="kobospan" id="kobo.1313.1">photography apps.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1314.1">At this point, you should have gained valuable insights and practical skills in building feature-rich photography apps using CameraX and </span><span><span class="kobospan" id="kobo.1315.1">ML Kit.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1316.1">In the next chapter, we will give life to those images by learning how to capture and edit video for our </span><span><span class="kobospan" id="kobo.1317.1">Packtagram app.</span></span></p>
</div>
</body></html>