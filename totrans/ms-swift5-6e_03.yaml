- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning about Variables, Constants, Strings, and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first program I ever wrote was written in BASIC and was the typical Hello
    World application. This application was exciting at first, but the excitement
    of printing static text wore off pretty quickly. For my second application, I
    used BASIC's input command to ask the user for a name and then printed out a custom
    "hello" message with the name they entered. At the age of 12, it was pretty cool
    to display `Hello Han Solo`. This application led me to create numerous Mad Libs-style
    applications that prompted the user for various words, and then put those words
    into a story that was displayed after the user had entered all the required words.
    These applications introduced me to, and taught me, the importance of variables.
    Every useful application I've created since then has used variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are variables and constants?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between explicit and inferred typing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are numeric, string, and Boolean types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining how enumerations work in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining how Swift's operators work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We recognize that Swift is becoming very popular on platforms outside of the
    Apple eco-system. Therefore, starting with this chapter, in the downloadable code
    samples, we will be including both a Swift playground and a `.swift` code file
    for all the sample code. This will enable you to easily try the samples on whichever
    platform you wish. This is a new feature starting with the *Mastering Swift 5.3*,
    *Sixth Edition* book. Let's start our tour of the Swift language by understanding
    what constants and variables are.
  prefs: []
  type: TYPE_NORMAL
- en: Constants and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constants and variables associate an identifier (such as `myName` or `currentTemperature`)
    with a value of a particular type (such as the `String` or `Integer` type), where
    the identifier can be used to retrieve the value. The difference between a constant
    and a variable is that a variable can be updated or changed, while a constant
    cannot be changed once a value is assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: Constants are good for defining values that you know will never change, like
    the temperature that water freezes at or the speed of light. Constants are also
    good for defining a value that we use many times throughout our application, such
    as a standard font size or the maximum number of characters in a buffer. There
    will be numerous examples of constants throughout this book, and it is recommended
    that we use constants rather than variables whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Variables tend to be more common in software development than constants. This
    is mainly because developers tend to prefer variables over constants. In Swift,
    the compiler will warn us if we declare a variable whose value never changes.
    We can make useful applications without using constants (although it is good practice
    to use them); however, it is almost impossible to create a useful application
    without variables.
  prefs: []
  type: TYPE_NORMAL
- en: The use of constants is encouraged in Swift. If we do not expect or want a value
    to change, we should declare it as a constant. This adds a very important safety
    constraint to our code that ensures that the value never changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use almost any character in the naming/identifier of a variable or
    constant (even Unicode characters); however, there are a few rules that you must
    follow:'
  prefs: []
  type: TYPE_NORMAL
- en: An identifier must not contain any whitespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must not contain any mathematical symbols or arrows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier must not contain private-use or invalid Unicode characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must not contain line or box-drawing characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must not start with a number, but it can contain numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Swift keyword as an identifier is strongly discouraged but if you do,
    surround it with backticks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keywords are words that are used by the Swift programming language. Some examples
    of keywords that you will see in this chapter are `var` and `let`. You should
    avoid using Swift keywords as identifiers to avoid confusion when reading your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Defining constants and variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constants and variables must be defined prior to using them. To define a constant,
    you use the `let` keyword, and to define a variable, you use the `var` keyword.
    The following code shows how to define both constants and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can declare multiple constants or variables in a single line by separating
    them with a comma. For example, we could shrink the preceding four lines of code
    down to two lines, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can change the value of a variable to another value of a compatible type;
    however, as we noted earlier, we cannot change the value of a constant. Let's
    look at the following playground. Can you tell what is wrong with the code from
    the error message?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16683_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Error thrown as a constant cannot be changed'
  prefs: []
  type: TYPE_NORMAL
- en: Did you figure out what was wrong with the code? Any physicist can tell you
    that we cannot change the speed of light, and in our code, `speedOfLightKmSec`
    is a constant, so we cannot change it here either. When we attempted to change
    the `speedOfLightKmSec` constant, an error was thrown. We can change the value
    of `highTemperature` without an error because it is a variable. We have mentioned
    the difference between variables and constants a couple of times because it is
    a very important concept to grasp, especially when we move on to define mutable
    and immutable collection types in *Chapter 5*, *Using Swift Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: When something is mutable, that means we are able to change it, and when we
    say something is immutable, that means we are unable to change it.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift is a type-safe language, which means we are required to define the types
    of the values we are going to store in a variable. We will get an error if we
    attempt to assign a value to a variable that is of the wrong type. The following
    playground shows what happens if we attempt to put a string value into a variable
    that expects integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: We will go over the most popular types later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Type-safety error in a Swift playground'
  prefs: []
  type: TYPE_NORMAL
- en: Swift performs a type check when it compiles code, and so it will flag any mismatched
    types with an error. The error message in this playground explains quite clearly
    that we are trying to insert a string value into an integer variable.
  prefs: []
  type: TYPE_NORMAL
- en: How does Swift know that the constant `integerVar` is of the integer type? Swift
    uses type inference to figure out the appropriate type. Let's look at what type
    inference is.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type inference allows us to omit the variable type when the variable is defined
    with an initial value. The compiler will infer the type based on that initial
    value. For example, in Objective-C, we would define an integer like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the compiler that the `myInt` variable is of the `Int` type, and
    that the initial value is the number `1`. In Swift, we would define the same integer
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift infers that the variable type is an integer because the initial value
    is an integer. Let''s look at a couple more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the compiler will correctly infer that variable `x`
    is a `Double`, variable `y` is a `String`, and variable `z` is a `Boolean`, based
    on their initial values. We are able to explicitly define a variable type. However,
    it is recommended that we only do this if we are not assigning an initial value
    to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type inference is a very nice feature in Swift and is one that you will probably
    get used to very quickly. However, there are times when we would like to explicitly
    define a variable''s type. For example, in the preceding example, the variable
    `x` is inferred to be `Double`, but what if we wanted the variable type to be
    `Float`? We can explicitly define a variable type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `Float` declaration (the colon and the word `Float`) after the variable
    identifier. This tells the compiler to define this variable to be of the `Float`
    type and gives it an initial value of `3.14`. When we define a variable in this
    manner, we need to make sure that the initial value is the same type as what we
    defined the variable to be. If we try to give a variable an initial value that
    is a different type than what we defined the variable as, then we receive an error.
    As an example, the following line will throw an error because we are explicitly
    defining the variable to be that of the `Float` type, while we are trying to put
    a `String` value in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to explicitly define the variable type if we are not setting an
    initial value. For example, the following line of code is invalid because the
    compiler does not know what type to set the variable `x` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this code in our application, we will receive a **Type annotation
    missing in pattern** error. If we are not setting an initial value for a variable,
    we are required to define the variable type, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to explicitly define a variable type, let's look at
    some of the most commonly used types.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift contains many of the standard numeric types that are suitable for storing
    various integer and floating-point values. Let's start by looking at the integer
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Integer types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An integer is a whole number and can be either signed (positive, negative,
    or zero) or unsigned (positive or zero). Swift provides several **Integer** types
    of different sizes. *Table 3.1* shows the value ranges for the different integer
    types on a 64-bit system:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Minimum | Maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `Int8` | -128 | 127 |'
  prefs: []
  type: TYPE_TB
- en: '| `Int16` | -32,768 | 32,767 |'
  prefs: []
  type: TYPE_TB
- en: '| `Int32` | -2,147,483,648 | 2,147,483,647 |'
  prefs: []
  type: TYPE_TB
- en: '| `Int64` | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
  prefs: []
  type: TYPE_TB
- en: '| `Int` | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
  prefs: []
  type: TYPE_TB
- en: '| `UInt8` | 0 | 255 |'
  prefs: []
  type: TYPE_TB
- en: '| `UInt16` | 0 | 65,535 |'
  prefs: []
  type: TYPE_TB
- en: '| `UInt32` | 0 | 4,294,967,295 |'
  prefs: []
  type: TYPE_TB
- en: '| `UInt64` | 0 | 18,446,744,073,709,551,615 |'
  prefs: []
  type: TYPE_TB
- en: '| `UInt` | 0 | 18,446,744,073,709,551,615 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: Different Integer types available on Swift'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice from the chart that unsigned integers begin with a U (`UInt`,
    `UInt8`…), while signed integers do not (`Int`, `Int8`).
  prefs: []
  type: TYPE_NORMAL
- en: Unless there is a specific reason to define the size of an integer, I would
    recommend using the standard `Int` or `UInt` types. This will save you from needing
    to convert between different types of integers later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, the `Integer` type and other numerical types are actually named types
    and are implemented in the Swift standard library using structures. This gives
    us a consistent mechanism for the memory management of all the data types, as
    well as properties that we can access. For the preceding chart, I retrieved the
    minimum and maximum values of each `Integer` type using the `min` and `max` properties
    of the `Integer` types. Look at the following playground to see how these values
    were retrieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B16683_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Ranges of different numerical types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integers can also be represented as binary, octal, and hexadecimal numbers.
    We just need to add a prefix to the number to tell the compiler which base the
    number should be in. The prefix takes the form of a zero, followed by the base
    specifier. *Table 3.2* shows the prefix for each numerical base:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Base | Prefix |'
  prefs: []
  type: TYPE_TB
- en: '| Decimal | None |'
  prefs: []
  type: TYPE_TB
- en: '| Binary | 0b |'
  prefs: []
  type: TYPE_TB
- en: '| Octal | 0o |'
  prefs: []
  type: TYPE_TB
- en: '| Hexadecimal | 0x |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.2: Prefixes for each numerical base'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following playground shows how the number 95 is represented in each of
    the numerical bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Defining values with different numerical bases'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift also allows us to insert arbitrary underscores in our numeric literals.
    This can improve the readability of our code without changing the underlying value.
    As an example, if we were defining the speed of light, which is constant, we could
    define it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Swift compiler will ignore these underscores and interpret this value as
    if the underscores were not there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Integer` type in Swift has a method named `isMultiple(of:)`, which can
    be very useful. This method allows us to check if one number is the multiple of
    another number. Prior to this method, we would have used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `isMultiple(of:)` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While this new method really doesn't eliminate a lot of code, it does make our
    code much easier to read and understand. Now, let's look at floating-point and
    `Double` types.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point and Double values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A floating-point number is a number with a decimal component. There are two
    standard floating-point types in Swift: `Float` and `Double`. The `Float` type
    represents a 32-bit floating-point number, while the `Double` type represents
    a 64-bit floating-point number. While the `Float` type is a 32-bit floating-point
    number, Swift actually supports four floating-point types. These are `Float16`,
    `Float32`, `Float64`, and `Float80`. Remember, when the `Float` type is used,
    it is a 32-bit floating-point number; if you want to use the other precisions,
    you will need to define it.'
  prefs: []
  type: TYPE_NORMAL
- en: Swift 5.3, with Swift Evolution SE-0277, added the `Float16` type to the Swift
    language because it is commonly used in graphics programming and also machine
    learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended that we use the `Double` type over the `Float` type unless
    there is a specific reason to use the latter. The `Double` type has a precision
    of at least 15 decimal digits, while the `Float` type''s precision can be as small
    as six decimal digits. Let''s look at an example of how this can affect our application
    without us knowing. *Figure 3.5* shows the results of what happens if we add two
    decimal numbers together using both a `Float` type and a `Double` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Calculations in Float and Double'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding screenshot, the first two decimal numbers that
    we are adding contain nine digits past the decimal point; however, the results
    in the `Float` type only contain seven digits, while the results in the `Double`
    type contain the full nine digits. This loss of precision can cause issues if
    we are working with currency or other numbers that need accurate calculations,
    as we can see when we compare the results in the second set of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you use type inference for a decimal number, Swift will default
    to a `Double` type rather than a `Float` type.
  prefs: []
  type: TYPE_NORMAL
- en: What if we have two variables, where one is an integer and the other is a double?
    Do you think we can add them as the following code shows?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we put the preceding code into a playground, we would receive the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This error lets us know that we are trying to add two different types of numbers,
    which is not allowed. To add an `Int` and a `Double` type together, we need to
    convert the integer value into a double value. The following code shows how to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we use the `Double()` function to initialize a `Double` value with
    the `Int` value. All numeric types in Swift have an initializer to do these types
    of conversion. These initializers are called **convenience initializers**, similar
    to the `Double()` function shown in the preceding code sample. For example, the
    following code shows how you can initialize a `Float` or `uint16` value with an
    integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Generally, when we are adding two different types together, we will want to
    convert the number with the least floating-point precision, like an integer or
    float, to the type with the highest precision, like a double.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Boolean** values are often referred to as logical values because they can
    be either `true` or `false`. Swift has a built-in `Boolean` type that accepts
    one of the two built-in Boolean constants: `true` and `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean constants and variables can be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Boolean values are especially useful when working with conditional statements,
    such as the `if`, `while`, and `guard` statements. For example, what do you think
    this code would do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you answered that this code would print out `YEA, I cannot wait to learn
    it`, then you would be correct. This line is printed out because the `isSwiftCool`
    Boolean type is set to `true`, while the `isItRaining` variable is set to `false`;
    therefore, the `Get a rain coat` message is not printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most languages, if we wanted to toggle the value of a Boolean variable,
    we would have to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, the Boolean type has a method called `toggle()` that lets us toggle
    the value of the variable. This is used if we do not know the value that''s stored
    in the variable. For example, if the `isItRaining` constant was a variable instead
    and we wanted to change the value, but we did not know what it actually was, we
    could use the following line of code to change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As with the Integer's `isMultiple(of:)` method, this makes our code much easier
    to read and understand. Now, let's look at the `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: The String type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **string** is an ordered collection of characters, such as `Hello` or `Swift`,
    and is represented by the `String` type. We have seen several examples of strings
    in this book, and therefore the following code should look familiar. This code
    shows how to define two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a string using a multiline string literal. The following
    code shows how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we put three double quotes around the multiline string. We can
    use quotes in our multiline string to quote specific text. The following code
    shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since a string is an ordered collection of characters, we can iterate through
    each character of a string. The following code shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will display the results that are shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Iterating through the string''s characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `map()` function, as shown in *Figure 3.6*, of the `String`
    type to retrieve each character, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will look at the `map()` method and how it works later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which we can add one string to another. We can concatenate
    them or include them in-line. To concatenate two strings, we can use the `+` or
    `+=` operators. The following code shows both ways in which we can concatenate
    two strings. The first example appends `stringB` to the end of `stringA`, and
    the results are put into the new `stringC` variable. The second example appends
    `string` directly to the end of `stringA`, without creating a new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To include a string in-line with another string, we use a special sequence
    of characters: `\()`. The following code shows how to include a string interpolation
    with another string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, `stringB` will contain the message `Hello Jon`, because
    Swift will replace the `\(stringA)` sequence of characters with the value of the
    `stringA` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Swift 5, we have the ability to create raw strings. In previous
    versions of Swift, if we wanted to include quotes or backslashes in a string,
    we had to *escape* it out using a backslash, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With a raw string, the double quotes and backslashes are treated as part of
    the string literal, and so we do not need to escape them. The following example
    shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the hashtag and double quotes at the start and end of the string. That
    tells Swift that this is a raw string. This makes it much easier to read what
    the string actually contains. If we wanted to append another string in-line, as
    we did previously, we would use the `\#()` character sequence. The following code
    illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this code would be a `str2` variable containing the following
    string: **The answer is 42**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, we define the mutability of variables and collections by using the
    `var` and `let` keywords. If we define a string as a variable using `var`, the
    string is mutable, meaning that we can change and edit the value. If we define
    a string as a constant using `let`, the string is immutable, meaning that we cannot
    change or edit the value once it is set. The following code shows the difference
    between a mutable and an immutable string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings in Swift have two methods that can convert the case of the string.
    These methods are `lowercased()` and `uppercased()`. The following example demonstrates
    these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, the results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift provides four ways to compare a string; these are string equality, prefix
    equality, suffix equality, and `isEmpty`. The following example demonstrates these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: String comparison methods in Swift'
  prefs: []
  type: TYPE_NORMAL
- en: The `isEmpty()` method checks to see if the string contains any characters or
    not. The string equality (`==`) checks to see if the characters (which are case-sensitive)
    in the two strings are the same. The prefix and suffix equality checks to see
    if the string starts with or ends with a specific string. The prefix and suffix
    equality is case-sensitive as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace all the occurrences of a target string with another string,
    which is done with the `replacingOccurrances(of:)` method. The following code
    demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will print `one, two, three, four` to the screen because
    we are replacing all the occurrences of `to` with `two` in the `stringOne` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `replacingOccurrences(of:)` method is only available on Apple
    platforms and is not available for other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also retrieve substrings and individual characters from our strings;
    however, when we retrieve a substring from a string, that substring is an instance
    of the `Substring` type and not the `String` type. The `Substring` type contains
    most of the same methods as the `String` type, so you can use them in a similar
    way. Unlike `String` types, however, they are meant to be used only for short
    periods of time, only while we are working with the value. If you need to use
    a `Substring` type for a long period of time, you should convert it into a `String`
    type. The following example shows how we can work with substrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used the subscript path to retrieve the substring
    between a start and end index. The indices are created with the `index(_: offsetBy:)`
    function. The first property in the `index(_: offsetBy:)` function gives the index
    of where we wish to start, and the `offsetBy` property tells us how much to increase
    the index by.'
  prefs: []
  type: TYPE_NORMAL
- en: The `path[..<startIndex]` line creates a substring from the beginning of the
    string to the index, while the `path[endIndex...]` line creates a substring from
    the index to the end of the string. We then use the last property to get the last
    character of the string and the first property to get the first character.
  prefs: []
  type: TYPE_NORMAL
- en: The `..<` operator that we saw in the previous example is known as a **half-open
    range operator**. We will look at the different range operators at the end of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the number of characters in a string by using the `count` property.
    The following example shows how you can use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This completes our whirlwind tour of strings. We went through these properties
    and functions very quickly, but we will be using strings extensively throughout
    this book, so there will be a lot of code to help you get familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples group multiple values into a single compound type. These values are not
    required to be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to define a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, an unnamed tuple was created that contains two strings,
    two integers, and one double. The values of the tuple can be decomposed into a
    set of variables, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `city` variable will contain `Boston`, the `name`
    variable will contain `Red Sox`, the `wins` variable will contain `97`, the `losses`
    variable will contain `65`, and finally the `percent` variable will contain `59.9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of the tuple can also be retrieved by specifying the location of
    the value. The following example shows how we can retrieve values by their location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Naming tuples, known as **named tuples**, allows us to avoid the decomposition
    step. A named tuple associates a name (key) with each element of the tuple. The
    following example shows how to create a named tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Values from a named tuple can be accessed using the dot syntax. In the preceding
    code, we can access the `city` element of the tuple like this: `team.city`. In
    the preceding code, the `team.city` element will contain `Boston`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are incredibly useful and can be used for all sorts of purposes. I have
    found that they are very useful for replacing classes and structures that are
    designed to simply store data and do not contain any methods. They are also very
    useful for returning multiple values, of different types, from a function. Now,
    let's look at enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerations (also known as **enums**) are a special data type that enables
    us to group related types together and use them in a type-safe manner. Enumerations
    in Swift are not tied to integer values as they are in other languages, such as
    C or Java. In Swift, we are able to define an enumeration with a type (string,
    character, integer, or floating-point value) and then define its actual value
    (known as the **raw value**). Enumerations also support features that are traditionally
    only supported by classes, such as computed properties and instance methods. We
    will discuss these advanced features in depth in *Chapter 7*, *Classes, Structures,
    and Protocols*. In this section, we will look at the traditional features of enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define an enumeration that contains a list of `Planets`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: When defining the enumeration type, the name of the enumeration should
    be uppercase, like other types. The member values can be uppercase or lowercase;
    however, it should be preferred to use lowercase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values defined in an enumeration are considered to be the member values
    (or simply the members) of the enumeration. In most cases, you will see the member
    values defined like they are in the preceding example because it is easy to read;
    however, there is a shorter version. This shorter version lets us define multiple
    members in a single line, separated by commas, as the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `Planets` enumeration like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The type for the `planetWeLiveOn` and `furthestPlanet` variables is inferred
    when we initialize the variable with one of the member values of the `Planets`
    enumeration. Once the variable type is inferred, we can then assign a new value
    without the `Planets` prefix, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can compare an enumeration value using the traditional equals (`==`) operator
    or by using a `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: We will learn about the Swift `switch` statement in *Chapter 6*, *Control
    Flow*, later in this book. For now, we wanted to illustrate its use with the enumeration
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use the equals operator and the `switch`
    statement with an enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Enumerations can come prepopulated with raw values, which are required to be
    of the same type. The following example shows how to define an enumeration with
    string values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example creates an enumeration with three types of devices. We
    then use the `rawValue` property to retrieve the stored value for the `Tablet`
    member of the `Devices` enumeration. This example will print a message saying,
    `We are using an iPad`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another `Planets` enumeration, but this time, we''ll assign numbers
    to the members, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The big difference between these last two enumeration examples is that in the
    second example, we only assign a value to the first member (`mercury`). If integers
    are used for the raw values of an enumeration, then we do not have to assign a
    value to each member. If no value is present, the raw values will be auto-incremented.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, enumerations can also have associated values. Associated values allow
    us to store additional information, along with member values. This additional
    information can vary each time we use the member. It can also be of any type,
    and the types can be different for each member. Let''s look at how we might use
    associate types by defining a `Product` enumeration, which contains two types
    of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we begin by defining a `Product` enumeration with
    two members: `Book` and `Puzzle`. The `Book` member has associated values of the
    `Double`, `Int`, and `Int` types, while the `Puzzle` member has associated values
    of the `Double` and `Int` types. Notice that we are using named associated types,
    where we assign a name for each associated type. We then create two products,
    `masterSwift` and `worldPuzzle`. We assign the `masterSwift` variable a value
    of `Product.Book` with the associated values of `49.99`, `2017`, and `310`. We
    then assign the `worldPuzzle` variable a value of `Product.Puzzle` with the associated
    values of `9.99` and `200`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can then check the `Product` enumeration using a `switch` statement, as we
    did in an earlier example. We then extract the associated values within the `switch`
    statement. In this example, we extracted the associated values as constants with
    the `let` keyword, but you can also extract the associated values as variables
    with the `var` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put the previous code into a playground, the following results will
    be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We are able to opt into the conformance of the `Comparable` protocols with
    our enumerations that have no associated values or associated values, which themselves
    conform to the `Comparable` protocol. By conforming to the `Comparable` protocol,
    we are able to compare cases of the same enum using the `<` and `>` operators.
    Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you do not understand what protocols are or how a type can conform
    to them at this point. We will be going over protocols in *Chapter 9*, *Protocols
    and Protocol Extensions*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we defined an enumeration that defined the different
    grade levels. By `adding : Comparable` after the enumeration declaration, we are
    adding conformance to the `Comparable` protocol. We then created a constant that
    defined what our acceptable grade level was. We are now able to compare any variable
    that contains a `Grades` value with the `acceptableGrade` constant to make sure
    it contains an acceptable grade, as shown in our example.'
  prefs: []
  type: TYPE_NORMAL
- en: Synthesized Comparable conformance for enumerations was added to Swift in version
    5.3 with Swift Evolution SE-0266 and is one of the features I am most excited
    about. It allows us to conform to the `Comparable` protocol with our enumerations,
    without having to write the code, to conform to the protocol ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In future chapters in this book, we will look at additional features of enumerations
    and see why they can be so powerful. So far in this book, we have used operators
    in a number of examples. Let's take a closer look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An operator is a symbol or combination of symbols that we can use to check,
    change, or combine values. We have used operators in most of the examples so far
    in this book, but we did not specifically call them operators. In this section,
    we will show you how to use most of the basic operators that Swift supports.
  prefs: []
  type: TYPE_NORMAL
- en: Swift supports most standard C operators and also improves on some of them to
    eliminate several common coding errors. For example, the assignment operator does
    not return a value, which prevents it from being used where we are meant to use
    the equality operator, which is two equal signs (`==`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the operators in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The assignment operator initializes or updates a variable. Here is a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The comparison operators return a Boolean value of `true` if the statement is
    `true` or a Boolean value of `false` if the statement is not `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The arithmetic operators perform the four basic mathematical operations. Here
    are some prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The remainder operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The remainder operator calculates the remainder if the first operand is divided
    by the second operand. In other languages, this is sometimes referred to as the
    modulo or modulus operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Compound assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compound assignment operators combine an arithmetic operator with an assignment
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The closed range operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The closed range operator defines a range that runs from the first number to
    the second number. The numbers are separated by three dots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example. Note that we will cover the `for` loop in *Chapter 6*,
    *Control Flow*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This example would print out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The half-open range operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The half-open range operator defines a range that runs from the first number
    to one, minus the second number. The numbers are separated by two dots and the
    less than sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This example would print out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in the closed range operator, the line `Number: 3` was printed
    out, but with the half open range operator, it wasn''t.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also one-side range operators that we use with arrays. We will look
    at those in *Chapter 5*, *Using Swift Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary conditional operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ternary conditional operator assigns a value to a variable based on the
    evaluation of a comparison operator or `Boolean` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The logical NOT operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logical `NOT` operator inverts a `Boolean` value. Here is a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The logical AND operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logical `AND` operator returns `true` if both operands are `true`; otherwise,
    it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The logical OR operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logical `OR` operator returns `true` if either of the operands are `true`.
    Here is a prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: For those who are familiar with C or similar languages, these operators should
    look pretty familiar. For those of you who aren't that familiar with the C operators,
    rest assured that, once you begin using them frequently, they will become second
    nature.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered topics ranging from variables and constants to data
    types and operators. The items in this chapter will act as the foundation for
    every application that you write; therefore, it is important to understand the
    concepts we discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have seen that we should prefer constants to variables when
    the value is not going to change. Swift will give you a compile-time warning if
    you set but never change a variable's value. We also saw that we should prefer
    type inference over declaring a type.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric and string types, which are implemented as primitives in other languages,
    are named types that are implemented with structures in Swift. In future chapters,
    you will see why this is important. One of the most important things to remember
    from this chapter is that, if a variable contains a nil value, you must declare
    it as an optional.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at Swift optional types. The optional type
    in Swift can be one of the hardest concepts to grasp if you are used to languages
    that don't use them.
  prefs: []
  type: TYPE_NORMAL
