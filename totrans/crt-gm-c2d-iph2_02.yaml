- en: Chapter 2. Match 3 and Recursive Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now move to a modern classic game that features addictive gameplay,
    predictive coding, and artificial randomness. We will also work with recursive
    methods—methods that call themselves repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic state machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting matches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predictive logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project is…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be building a Match 3 game in this chapter. This game is heavily influenced
    by several of the extremely popular games of the genre, but we will be sticking
    to core mechanics in this chapter. What is being left out? We will not be including
    any special modes for matching four or five gems in a row, though those matches
    will still be scored. We will explore one approach to avoiding a "no more moves"
    situation using predictive logic and artificial randomness. We will assume you
    have familiarity with the basic structural concepts from [Chapter 1](ch01.html
    "Chapter 1. Thanks for the Memory Game"), *Thanks for the Memory Game*, so we
    will dive directly into the Match 3-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be using classes with names such as `MAMenuLayer`, `MAPlayfieldLayer`,
    `MAMenuScene`, and `MAPlayfieldScene` throughout the book. The two-letter prefix
    will be different for each game (`MT` for [Chapter 1](ch01.html "Chapter 1. Thanks
    for the Memory Game"), *Thanks for the Memory Game*, `MA` for this chapter, and
    so on), but the role each class plays will be the same. This structure is our
    foundational nomenclature, so we should assume we have classes named in this fashion
    in each project.
  prefs: []
  type: TYPE_NORMAL
- en: Basic gem interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this game, we only really have one type of object to play with—we will refer
    to these playing pieces as gems, since that is the most commonly used image in
    Match 3 games. We will look at some of the internals of the `MAGem` class, and
    then move on to how we actually handle the gems before tackling the more intricate
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: The MAGem header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start out by looking at the header for the `MAGem` class, which is a subclass
    of `CCSprite`. We have a couple of new things here. We are using the `@class`
    statement to tell this class that there is another class called `MAPlayfieldLayer`
    that exists, but we don't want to import that class here. `MAGem` will be imported
    by `MAPlayfieldLayer`, and we don't want to get stuck in an infinite "import"
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAGem.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will notice we begin the class with two sections of `typedef enum`. This
    is a C construct that is basically an integer constant. Inside the curly braces
    is a comma-separated list of all of the named elements we want to use, and after
    the closing curly brace, we give a name to this enumerated value. In the first
    `typedef` statement, we are establishing that we have a new object type called
    `GemType`. Valid values for this are `kGemAnyType`, `kGem1`, `kGem2`, and so on.
    You will also notice that the first value is assigned to an integer, `0`. If you
    omit this assignment, the named values will automatically be assigned unique integer
    values. Because we have explicitly declared that the first value is `0`, the compiler
    will automatically assign incremental integers to the remaining values. This gives
    a small peek at the flexibility of these values. Even though we use the named
    values for them, we can also treat them as integers if there is a need. For example,
    `kGem1` and the integer value `1` are identical and can be used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have built these `typedef` sections, we can treat the `GemType` and
    `GemState` types the same as any other valid data type, as we have done in the
    variable declarations. These will also be valid to use in any other class that
    imports the `MAGem` class.
  prefs: []
  type: TYPE_NORMAL
- en: One important feature we have added to the `MAGem` class is a primitive state
    machine. We use the `gemState` variable to hold the current state of the gem.
    The gem can only be in a single state at a time. The possible states are `kGemNew`,
    `kGemIdle`, `kGemScoring`, and `kGemMoving` (as defined in the second `typedef
    enum` statement). These could also be handled by a series of `BOOL` variables
    for each state, but that gets confusing very quickly. Since the states are mutually
    exclusive, using a single state variable is the preferred way to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: The MAGem class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we turn our attention to the `MAGem.m` file. Because `MAGem` is a subclass
    of `CCSprite`, we have intentionally avoided overriding any methods. Although
    it is common to override the `init` method, we are taking an alternate approach
    here. All of our instance variables will be set by the calling method, not by
    the `init` method. This illustrates the fact that there is not a single right
    answer to any situation. This approach actually leads to slightly fewer lines
    of code, since the gems will only be created by a single method in our `MAPlayfieldLayer`
    class. Functionally, there is no difference between setting these values in a
    custom `init` method versus the approach taken here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAGem.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have a few helper methods in this class that will make the matching logic
    easier. Look at the method `isGemSameAs` in this class. Since this is in the `MAGem`
    class, we can pass it another `MAGem` instance as an argument, and it compares
    the `gemType` variables to determine whether they are the same type of gem. If
    they are the same, we return `YES`. If they are different, we return `NO`. We
    follow the same pattern for the `isGemInSameRow` and `isGemInSameColumn` methods.
    The code in these methods is extremely simple but will allow us to simplify how
    we interact with the gems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAGem.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `isGemBeside` method is a little more involved. We first check to see whether
    the two gems in question (the current gem and `otherGem`) are in the same row,
    using the method we just saw. We also check to see whether the `colNum` variable
    of the `otherGem` object is either one greater or one less than the current gem.
    If this is true, we return `YES`. We then check to see whether `otherGem` is in
    the same column and whether they are in adjacent rows, in the same manner. This
    method (with the other `isGem` methods) will make comparisons between gems trivial
    to implement later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAGem.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we see the `highlightGem` and `stopHighlightGem` methods.
    These will be used when the player touches a gem. The gem will hop up and down
    when it is selected. `stopHighlightGem` makes a call to the `resetGemPosition`
    method in the `GameLayer` class. We do this because the gem itself has no knowledge
    of where it is supposed to be on the screen. We could migrate the positioning
    code into the `MAGem` class to avoid this cross-class calling, but this works
    well, so we will leave it this way.
  prefs: []
  type: TYPE_NORMAL
- en: Generating gems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build a new subclass of `CCLayer`, called `MAPlayfieldLayer`, and we
    will set up a couple of methods to control all gem creation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Combined, these two methods take care of creating a new gem, assigning all
    variables (including the `GameLayer` variable we use to refer to the layer from
    the `MAGem` class), and putting the gem into play. Why two methods? The `addGemForRow:`
    method takes control over three aspects of the addition: adding the gem to the
    layer, setting the position to a position higher than the screen, and calling
    the method to drop the gem into its proper position. The `generateGemsForRow:`
    method does everything except putting the gem into play. We do this because there
    are situations where we want to create a gem without making it visible, such as
    when we build the initial board.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are keeping a reference to the playfield layer inside the `MAGem` class
    (in the `setGameLayer:` line in the `generate` methods), we need to be memory-conscious
    and set that property to `nil` when the gem's `dealloc` method is run.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAGem.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Building the playfield
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The creation of a basic playfield is very similar to the setup for the Memory
    game in [Chapter 1](ch01.html "Chapter 1. Thanks for the Memory Game"), *Thanks
    for the Memory Game*, with some slight variations. We do not want the playfield
    to start with three-in-a-row matches, so we want to check for matching situations
    and change the gems around to make sure the board is "clean" when the game starts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we iterate through all positions and call `generateGemForRow:`
    for each slot on the board. As you recall, the `generateGemForRow:` method does
    not add the gems to the layer, so we can manipulate the board before we introduce
    it to the player. We call the `fixStartingMatches` method to correct any starting
    three-in-a-row situations, and then we iterate through all of the gems in the
    `gemsInPlay` array and add them to the board. (You may notice that, when a gem
    is first added, it is set to the state `kGemNew`, and when it is added to the
    board, it is changed to `kGemIdle`. This is to avoid any accidental matches occurring
    when a new gem has been created but is not yet visible. By the time we add it
    to the board, it is ready to play, so `kGemIdle` is the correct state at that
    time.) Now we need to see how the `fixStartingMatches` method works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This method starts with the `checkForMatchesOfType` method, which we will cover
    shortly. For now, we only need to know that it reviews all gems in the `gemsInPlay`
    array and any three-in-a-row matching gems are added to the `gemMatches` array.
    This method calls that check, and if there are any gems in the `gemMatches` array,
    it destroys the first gem in the `gemMatches` array and creates a new replacement.
    After it has replaced this *one* gem, it calls itself, so it can check the entire
    board again. Why not fix all of them at once? The `gemMatches` array contains
    *all* matches, which means that if there is only a single three-in-a-row match
    on the board, there are three gems in the array. We only need to replace one of
    those gems to "fix" this match on the board, so the other two gems in that match
    will be unchanged. To help visually explain this, look at the following comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the playfield](img/9007_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the board was first generated, it created an instant match, as seen within
    the red box in the left image. After the `fixStartingMatches` method was run,
    it replaced the first gem in the match (the top one, in this case) and replaced
    it with a new, randomly generated gem. There is no longer a three-in-a-row match,
    so we are done. The `fixStartingMatches` method will run itself again after this
    one gem is changed, just to make sure we don't have another match situation. When
    all three-in-a-row match conditions have been fixed in this manner, the game setup
    can continue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the remainder of the book, we will be focusing on the implementation (`.m`)
    files. With a few exceptions, we will not be spending time going over the details
    of the headers, so you will want to consult the code bundle for this book if you
    are uncertain about a variable or property that is used within the code presented
    here. Our goal is primarily to understand how the various methods and objects
    power the games, and most of the important details are in the implementation files.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is only one method left to see the initial board built. The method `checkForMatchesOfType`
    takes a `desiredGemState` value as a parameter. We do this because, during the
    initial board setup, we only want to check gems that are in the state `kGemNew`.
    Later, during actual gameplay, we only want to check for matches when the gems
    are in the state `kGemIdle`. (During gameplay, the gems in the `kGemNew` state
    will be outside the visible screen before they are dropped on to the screen, and
    we definitely do not want to include them in matches until they drop into position.)
    Let''s look at the method now, in two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m` (`checkForMatchesOfType`, part 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This method looks a little daunting, so let''s take it apart. We have two main
    sections, one for the horizontal matches and one for vertical matches. What we
    see in the preceding code is just the horizontal match checking. The outer *for*
    loop iterates through all of the gems in the `gemsInPlay` array, naming this gem
    `aGem`. We immediately check to make sure `aGem` has the `desiredGemState` value
    we are looking for. If not, the rest of this section is skipped. If the `gemState`
    has the `desiredGemState` value, we start a second *for* loop on the same `gemsInPlay`
    array, this time calling the gem being evaluated `bGem`. We check to see whether
    the following conditions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aGem` is the same type as `bGem` (using the `isGemSameAs` method)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aGem` is in the same row as `bGem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aGem`''s `colNum` is equal to the `bGem`''s `colNum` – 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bGem` is in the `desiredGemState`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If all these conditions are true, it means that the `aGem` being evaluated
    has an identical gem to the right of it. So, we have a two-in-a-row situation.
    Now we start a third *for* loop using the `gemsInPlay` array, the same as the
    other two loops. With the third loop, we break the conditions into two separate
    *if* statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aGem`''s `colNum` is equal to `cGem`''s `colNum` – 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cGem`''s gem state is equal to the `desiredGemState`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And in the second *if* statement, we check these statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aGem` is of the same type as `cGem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aGem` is in the same row as `cGem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all of these conditions are true, we have made a three-in-a-row match. All
    three gems involved in the matching are then added to the `gemMatches` array.
    Instead of adding the gems directly to the array, we use the method `addGemToMatch`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because we are checking the whole board, we often find multiple matches that
    involve the same gem. Since we only want each matching gem represented once, the
    `addGemToMatch` method checks to make sure the gem is not already in the array
    before adding it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can take a look at the second half of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m` (`checkForMatchesOfType`, part 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The second half of this method checks for vertical matches. You will notice
    that the code looks strikingly similar to the horizontal check we just reviewed
    in detail. The vertical check is almost the same as the horizontal, except that
    all references to rows and columns are reversed. Everything else is in the same
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting touches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a board built, we need to add some mechanics to move the gems
    so we can make matches. Let''s look at the touch handlers, starting with the `ccTouchBegan`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `ccTouchBegan` method controls whether we track a specific touch. If we
    have reached a "game over" condition (indicated by the `gameOver` variable), we
    go back to the menu. We also trigger the same `replaceScene` method if `backButton`
    is touched. We handle these situations in `ccTouchBegan`, so we can override any
    other logic that might be going on and can leave the game whenever we want to.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first time we have encountered the `gemsTouched` array, so we will
    explain it here. When the player touches any gem, we add that gem to the `gemsTouched`
    array. When we have two gems in the `gemsTouched` array, we swap the position
    of the gems and check for a match. If there are two gems in the array, we know
    something else is happening in the game (swapping gems, checking for matches,
    moving gems around, and so on), so we stop tracking the touch at that point. If
    we have less than two gems in the array, we iterate through the `gemsInPlay` array
    to determine which (if any) gem was touched. When we find one, we return `YES`
    to allow the touch to be tracked.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a touch being tracked, the handler continues with the `ccTouchMoved`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is not much here. This method passes everything along to our own `touchHelper`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As the player slides their finger on the board, `ccTouchMoved` will be triggered
    constantly, which in turn will call the `touchHelper` method repeatedly. The first
    check is to make sure that we don't already have two objects in the `gemsTouched`
    array (the same "protection" as in `ccTouchBegan`) and to make sure we don't have
    any gems moving (where the `gemsMoving` variable is `YES`). If we do, we call
    `return`, to stop tracking this touch.
  prefs: []
  type: TYPE_NORMAL
- en: If the touch comes in contact with a gem, and the gem is not already in the
    `gemsTouched` array, we play a sound, add it to the `gemsTouched` array, and send
    a message to the gem to run the `highlightGem` method. Since this code is called
    from the `ccTouchMoved` method, each gem will be added to the array (up to the
    stated maximum of two) as we swipe across multiple gems. We have swipe detection
    without needing any gesture detection code.
  prefs: []
  type: TYPE_NORMAL
- en: The final *if* statement is to check whether we have gathered two gems in the
    `gemsTouched` array. If we have, we first check to make sure the gems are adjacent
    (the `isGemBeside` method). If they are adjacent, we call `swapGem` and pass the
    two gems to that method. If not, we stop highlighting the first gem in the array
    and remove it from the `gemsTouched` array, so the second touch is now the only
    gem in the `gemsTouched` array.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the final touch handler method, `ccTouchEnded`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What's going on here? The checks that we needed in the `ccTouchEnded` method
    are exactly the same checks that we used in the `ccTouchMoved` method, so we can
    call the same code, rather than copying all the code into both methods; this is
    why we created the `touchHelper` method. Looking at both the `ccTouchMoved` and
    `ccTouchEnded` methods together, we have the flexibility to be able to swipe or
    tap on gems to select them. `ccTouchMoved` is only called when the touch moves
    (that is, a swipe), so a simple tap will not activate the code in that method.
    The `ccTouchEnded` method is only called when the touch ends (that is, the finger
    is lifted off the screen). By triggering the same code in both places, we can
    cover both styles of player interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Moving gems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s briefly look at the methods we use to handle gem movements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `swapGem` method is very basic. We use temporary variables to assist with
    swapping the `rowNum` and `colNum` values of the two gems passed to the method.
    After they are changed, we call the `moveToNewSlotForGem` method on both gems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `moveToNewSlotForGem` method first sets the gem's state to `kGemMoving`,
    so this gem will not take part in any matching logic while in motion. Then, we
    use a `CCMoveTo` action to move the gem where it should be (based on the new `rowNum`
    and `colNum` variables we just assigned to it), play a sound effect, and then
    call the `gemIsAtRest` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `gemIsAtRest` method resets the gem's state, so it is now `kGemIdle`. This
    means it will now be allowed to participate in any matching checks that are performed
    on the board. We also set the `checkMatches` variable to `YES`. This is the trigger
    we use to identify that the board is now stable enough to check for a potential
    match.
  prefs: []
  type: TYPE_NORMAL
- en: Checking moves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are close to completing a basic Match 3 game. Let's look at a couple more
    methods we need to finish it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should be familiar enough with the way the gem arrays are handled
    in this code, and so you should find this method pretty simple. First, we call
    the `checkForMatchesOfType` method to populate the `gemMatches` array with matching
    gems (if any are found). If we find any matches, all matching gems are sent to
    the `animateGemRemoval` method. Once that loop is complete, we remove all gems
    from the `gemMatches` array. If we have any gems in the `gemsTouched` array, we
    call `stopHighlightGem` on them. If there were two gems in that array, it means
    we had a move that did not make a match, so we call `swapGem` to move them back
    to where they started from. After that has been resolved, we clear the `gemsTouched`
    array. By the end of this method, the two temporary arrays are empty and all matches
    have been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Removing gems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s look at the methods used to remove gems from the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These three methods, taken together, handle everything we need to neatly animate
    a matched gem. `changeGemFace` uses a method we haven''t seen before. Since all
    of our images are part of the same `CCSpriteBatchNode`, we are able to use the
    `setDisplayFrame` method to change the image of the sprite on the fly. Here, we
    replace the gem''s image with the "boom" image. We move it up the screen and fade
    it out, so it disappears from the board neatly. (We also update the score and
    add time to the timer, but we won''t be discussing those features of the game
    here. If you don''t use a score or a timer, you can easily remove those actions.)
    There is one important method called from the `removeGem` method, `fillHolesFromGem`.
    Let''s see what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method looks for any gems that are in the same column as the passed gem,
    `aGem`. We iterate through the `gemsInPlay` array, looking for any gems in a row
    above `aGem`, reset their `rowNum` variable to one row lower, and then trigger
    the `moveToNewSlotForGem` method. This will effectively fill in any gaps in the
    board. It doesn't add any new gems to the board, but collapses them all downward
    so any remaining holes are at the top of the board. (The `smartFill` method is
    covered in the *Predictive logic* section of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: The update method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now turn our attention to the `update` method, which will tie it all together.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now we tie together a couple of loose ends in the code. We start with the `gemsMoving`
    `BOOL`, which we used in the touch handler. We set the value in the `update` method
    by iterating through all the gems to determine whether there are any gems in the
    state `kGemMoving`. If any gems are moving, `gemsMoving` is set to `YES`.
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOL` `checkMatches` is next. If this variable has been set to `YES`, we
    run the `checkMove` method. As we saw earlier, this method takes care of handling
    all the matching logic and removal of matched gems. At the end of this *if* statement,
    we reset the `checkMatches` variable to `NO` to indicate the matches are resolved.
    (We will discuss `checkMovesRemaining` in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: The final portion of the core `update` method checks to see if we don't have
    enough gems on the board and if nothing is moving. If both of these conditions
    are true, we call the `addGemsToFillBoard` method to fill in any missing gems.
    (There are also the timer update and the game-over checks at the end. We will
    not be discussing those here, so the code details have been omitted. Please see
    the accompanying code for those portions of the update method.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We iterate through all the spaces on the board, and then, through all the gems
    in the `gemsInPlay` array. If we find a gem in that slot, we set the `missing`
    variable to `NO`. If we do not find a gem in a given slot (that is, `missing =
    YES`), we call the `addGemForRow` method to add a new random gem to fill in that
    slot.
  prefs: []
  type: TYPE_NORMAL
- en: Predictive logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have mostly covered straightforward code that takes care of basic
    game mechanics. There is one problem, though. The game can produce a board that
    is impossible to make a move on. Worse, we have no way of knowing that there are
    no more moves remaining. We aim to correct that deficiency now, in a rather dense
    method called `checkMovesRemaining`. First, we should cover the basic concept
    of how this is accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, the `checkForMatchesOfType` method we reviewed earlier did a
    good job of finding any actual matches on the board. We could code this predictive
    method in that style, but it quickly gets confusing since you need to be able
    to determine matches up to five gems in a row to get an accurate count of moves
    remaining. Here, we take another approach by writing the `gemType` values into
    a "C-style" array, so we can easily get a single view of the whole board without
    massive nested loops.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge is determining all the possible ways a player can legally move
    a gem and how the board would look after the move. We iterate through all positions
    from the bottom left corner, and we will test what happens if the gem is moved
    to the right, and also what happens if the gem is moved up. Even though the player
    can also move left and down, those will already be taken care of because swapping
    one gem downwards is the same as swapping the one below it upwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start our test scenarios by creating a "letter map" of the board area, with
    the letter "a" representing the board slot being evaluated, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predictive logic](img/9007_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will use this letter map and assign variables to represent the value at each
    specified position in the array. For example, the variable `f` is at location
    `row+1` and `col+1`, relative to the letter *a*. From there, we will test a "deformed"
    version of the map, first with the *a* and *b* positions swapped, and then by
    testing *a* and *e* swapped. From there, we count up all the matches that can
    be made with a single move, and we set that as the `movesRemaining` variable.
    (This code is pretty long, but there's no good way to break it up here.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep the positioning straight, you can see that we have put in a textual
    version of the letter map into the code. This is a convenience, since trying to
    read the patterns from the code itself is rather tiresome and challenging. When
    we look at possible matches after deforming the board, there are four possible
    ways we can match for each of the deformations, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predictive logic](img/9007_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To assist with this checking, we add a helper method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Any combination of five gems could result in a match of three, four, or five
    in a row. We pass five gems in a row to this method, and it checks for five in
    a row first, then four in a row, and then three in a row. It is an *if…else-if*
    structure because a five-in-a-row match would also trigger as four-in-a-row and
    three-in-a-row matches, so we let it act as a waterfall to avoid over-counting
    the matches. You will also notice that we are making sure that one of the variables
    is not `0`. As we saw in the `checkMovesRemaining` method itself, we only record
    the gem type for gems that are in the `kGemIdle` state. All other gem states (`kGemMoving`,
    `kGemScoring`, and `kGemNew`), as well as positions off the board, will be represented
    as `0` in the map.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now, we can evaluate the board to see all potential moves. Then what? We
    could put in a trigger in the `update` method to flash a "no more moves" message
    and cause game over, but that's no fun, is it? Our goal is to make a game that
    will keep going forever. This is where we are finally ready to find out details
    of the `smartFill` method we saw in the code earlier. This is a really long method,
    listed in its entirety. It is a critical method to the process, so please bear
    with us.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename**: `MAPlayfieldLayer.m`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This structure of code should look familiar to you, as it uses the same design
    structure as the `checkMovesRemaining` method. It uses the same "map" array concept,
    albeit with fewer variables needed for this method. There are two subtle differences
    in the top portion of the code. The first is that if the `gemsMoving` variable
    is `YES`, we schedule the `smartFill` method with an interval of `0.05` and immediately
    exit the method (with the `return` statement). The first thing the method does,
    in fact, is unschedule itself if it was already scheduled. This causes the `smartFill`
    method to wait until the board has stabilized with nothing moving. This allows
    us to always check a static board without worrying about the difference between
    an empty slot and a slot with a moving gem.
  prefs: []
  type: TYPE_NORMAL
- en: The second interesting portion of the top of the method is the check for whether
    `movesRemaining` is greater than or equal to six. If that is true, we have plenty
    of moves remaining, so the `addGemsToFillBoard` method we saw earlier will be
    called, which will generate random gems to fill in the board. Why six? Ideally,
    we would want to be able to kick in this `smartFill` method only when we are down
    to one or two moves remaining, but since a single move has the potential of eliminating
    several other moves (by shifting the board, or by using gems that were also potentially
    part of another match), testing showed six is a safe number to use to avoid a
    deadlocked board.
  prefs: []
  type: TYPE_NORMAL
- en: We also have one difference in the way the map is populated. In this case, we
    check if any position is outside of the actual board area and assign a value of
    `-1`. If it is a "hole in the board", it will be assigned `0`. In this way, we
    can make sure we are only filling in the board itself, and not areas outside the
    board. (These external `-1` values are sometimes called **sentinel values** because
    they guard the edges of the board.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our fill-in map for the `smartFill` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Artificial randomness](img/9007_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The goal is to fill in the holes in the board with something that will be usable
    in making a match. We do this by copying a nearby gem, so we can guarantee a match.
    However, depending on where on the board the hole is, we cannot always guarantee
    there will be a single gem we can always clone (relative to the hole), so we iterate
    through a few likely possibilities until we find one and then call `smartFill`
    again to take care of any further holes. You will notice that, in all situations,
    we clone two gems and leave the third gem to be set as `kGemAnyType`—randomized.
    This gives us some level of randomness that adds spice to the situation, even
    as we spoon feed the player a viable board.
  prefs: []
  type: TYPE_NORMAL
- en: This `smartFill` method does not do a complete job by itself; it can leave small
    1- or 2-gem holes if there is a four-in-a-row or five-in-a-row match. The remaining
    holes will be filled in by the call to the `addGemsToFillBoard` method in the
    update loop. This is by design, since we did not want to add even more code to
    handle artificial randomness for 4- and 5-gem holes. The added calculations required
    are not necessary to fulfill our goal of keeping the game going. As a final note,
    if you want to remove all of the "artificial randomness", you only have to comment
    out the call to the `smartFill` method at the end of the `fillHolesFromGem` method
    . Of course, then you will need to add a "no more moves" handler to react to that
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of ground in a short period of time, and we've covered
    more than one approach to some of the challenges this game presents to us. We
    have learned how to control a grid of gems with the appearance of gravity (in
    other words, filling in holes), we have learned how to match by using nested *for*
    loops. We have also learned how to check for matches and how to check for predictive
    matches using a "C-style" array without forcing ourselves to use C-style arrays
    throughout the code. Finally, we addressed the idea of artificial randomness to
    give the player an ongoing game experience without risking a "no more moves" situation.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for this chapter also includes both scoring and a progress timer,
    which we saw traces of but didn't really discuss here. The implementation is very
    simple, so we leave it to you, the reader, to explore these features on your own.
    The example "tests" contained within the sample projects included with the cocos2d
    download are a great resource for lesser-known classes, such as `CCProgressTimer`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will tackle a classic mole-whacking game, and learn
    how to trick the player's eye.
  prefs: []
  type: TYPE_NORMAL
