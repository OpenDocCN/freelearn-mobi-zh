- en: Chapter 2. Match 3 and Recursive Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。三合一和递归方法
- en: We will now move to a modern classic game that features addictive gameplay,
    predictive coding, and artificial randomness. We will also work with recursive
    methods—methods that call themselves repeatedly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向一款现代经典游戏，这款游戏具有上瘾的游戏玩法、预测编码和人工随机性。我们还将使用递归方法——这些方法是反复调用自身的。
- en: 'In this chapter, we cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Basic state machines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本状态机
- en: Detecting matches
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测匹配
- en: Predictive logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测逻辑
- en: Artificial randomness
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工随机性
- en: The project is…
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目是……
- en: We will be building a Match 3 game in this chapter. This game is heavily influenced
    by several of the extremely popular games of the genre, but we will be sticking
    to core mechanics in this chapter. What is being left out? We will not be including
    any special modes for matching four or five gems in a row, though those matches
    will still be scored. We will explore one approach to avoiding a "no more moves"
    situation using predictive logic and artificial randomness. We will assume you
    have familiarity with the basic structural concepts from [Chapter 1](ch01.html
    "Chapter 1. Thanks for the Memory Game"), *Thanks for the Memory Game*, so we
    will dive directly into the Match 3-specific code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个三合一游戏。这款游戏受到了该类型中几个非常受欢迎的游戏的极大影响，但我们将坚持在本章中遵循核心机制。被省略了什么？虽然这些匹配仍然会被计分，但我们不会包括匹配四个或五个宝石的特殊模式。我们将探索使用预测逻辑和人工随机性避免“没有更多移动”情况的一种方法。我们假设你已经熟悉了[第1章](ch01.html
    "第1章。感谢记忆游戏")中的基本结构概念，即《感谢记忆游戏》，因此我们将直接进入三合一特定的代码。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will be using classes with names such as `MAMenuLayer`, `MAPlayfieldLayer`,
    `MAMenuScene`, and `MAPlayfieldScene` throughout the book. The two-letter prefix
    will be different for each game (`MT` for [Chapter 1](ch01.html "Chapter 1. Thanks
    for the Memory Game"), *Thanks for the Memory Game*, `MA` for this chapter, and
    so on), but the role each class plays will be the same. This structure is our
    foundational nomenclature, so we should assume we have classes named in this fashion
    in each project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用诸如`MAMenuLayer`、`MAPlayfieldLayer`、`MAMenuScene`和`MAPlayfieldScene`之类的类名。每个游戏的前两个字母前缀将不同（`MT`用于[第1章](ch01.html
    "第1章。感谢记忆游戏")，《感谢记忆游戏》，`MA`用于本章，等等），但每个类扮演的角色将是相同的。这种结构是我们的基础命名法，因此我们应该假设在每个项目中都有以这种方式命名的类。
- en: Basic gem interaction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本宝石交互
- en: In this game, we only really have one type of object to play with—we will refer
    to these playing pieces as gems, since that is the most commonly used image in
    Match 3 games. We will look at some of the internals of the `MAGem` class, and
    then move on to how we actually handle the gems before tackling the more intricate
    logic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这款游戏中，我们实际上只有一种类型的对象可以玩耍——我们将这些游戏棋子称为宝石，因为在三合一游戏中，这是最常用的图像。我们将查看`MAGem`类的内部结构，然后继续探讨在处理更复杂的逻辑之前，我们实际上是如何处理宝石的。
- en: The MAGem header
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MAGem头文件
- en: We start out by looking at the header for the `MAGem` class, which is a subclass
    of `CCSprite`. We have a couple of new things here. We are using the `@class`
    statement to tell this class that there is another class called `MAPlayfieldLayer`
    that exists, but we don't want to import that class here. `MAGem` will be imported
    by `MAPlayfieldLayer`, and we don't want to get stuck in an infinite "import"
    loop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看`MAGem`类的头文件，它是`CCSprite`的子类。这里有几个新事物。我们使用`@class`语句来告诉这个类存在另一个名为`MAPlayfieldLayer`的类，但我们不想在这里导入该类。`MAGem`将由`MAPlayfieldLayer`导入，我们不希望陷入无限“导入”循环。
- en: '**Filename**: `MAGem.h`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAGem.h`'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will notice we begin the class with two sections of `typedef enum`. This
    is a C construct that is basically an integer constant. Inside the curly braces
    is a comma-separated list of all of the named elements we want to use, and after
    the closing curly brace, we give a name to this enumerated value. In the first
    `typedef` statement, we are establishing that we have a new object type called
    `GemType`. Valid values for this are `kGemAnyType`, `kGem1`, `kGem2`, and so on.
    You will also notice that the first value is assigned to an integer, `0`. If you
    omit this assignment, the named values will automatically be assigned unique integer
    values. Because we have explicitly declared that the first value is `0`, the compiler
    will automatically assign incremental integers to the remaining values. This gives
    a small peek at the flexibility of these values. Even though we use the named
    values for them, we can also treat them as integers if there is a need. For example,
    `kGem1` and the integer value `1` are identical and can be used interchangeably.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们以两个`typedef enum`部分开始这个类。这是一个C语言结构，基本上是一个整数常量。在大括号内是一个以逗号分隔的列表，列出了我们想要使用的所有命名元素，在大括号关闭后，我们给这个枚举值起一个名字。在第一个`typedef`语句中，我们建立了一个新的对象类型`GemType`。这个类型的有效值有`kGemAnyType`、`kGem1`、`kGem2`等等。你也会注意到第一个值被分配给一个整数`0`。如果你省略了这个分配，命名值将自动被分配唯一的整数值。因为我们明确声明第一个值是`0`，编译器将自动将增量整数分配给剩余的值。这让我们窥见了这些值的灵活性。尽管我们使用命名值，但在需要的情况下我们也可以将它们视为整数。例如，`kGem1`和整数值`1`是相同的，可以互换使用。
- en: Once we have built these `typedef` sections, we can treat the `GemType` and
    `GemState` types the same as any other valid data type, as we have done in the
    variable declarations. These will also be valid to use in any other class that
    imports the `MAGem` class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了这些`typedef`部分，我们就可以像使用任何其他有效数据类型一样使用`GemType`和`GemState`类型，就像我们在变量声明中所做的那样。这些也可以在导入`MAGem`类的任何其他类中使用。
- en: One important feature we have added to the `MAGem` class is a primitive state
    machine. We use the `gemState` variable to hold the current state of the gem.
    The gem can only be in a single state at a time. The possible states are `kGemNew`,
    `kGemIdle`, `kGemScoring`, and `kGemMoving` (as defined in the second `typedef
    enum` statement). These could also be handled by a series of `BOOL` variables
    for each state, but that gets confusing very quickly. Since the states are mutually
    exclusive, using a single state variable is the preferred way to handle this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`MAGem`类中的一个重要特性是原始状态机。我们使用`gemState`变量来保存宝石的当前状态。宝石一次只能处于一个状态。可能的状态有`kGemNew`、`kGemIdle`、`kGemScoring`和`kGemMoving`（如第二个`typedef
    enum`语句中定义的）。这些也可以通过为每个状态使用一系列`BOOL`变量来处理，但这会很快变得混乱。由于状态是互斥的，使用单个状态变量是处理这种状态的首选方式。
- en: The MAGem class
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`MAGem`类'
- en: Now we turn our attention to the `MAGem.m` file. Because `MAGem` is a subclass
    of `CCSprite`, we have intentionally avoided overriding any methods. Although
    it is common to override the `init` method, we are taking an alternate approach
    here. All of our instance variables will be set by the calling method, not by
    the `init` method. This illustrates the fact that there is not a single right
    answer to any situation. This approach actually leads to slightly fewer lines
    of code, since the gems will only be created by a single method in our `MAPlayfieldLayer`
    class. Functionally, there is no difference between setting these values in a
    custom `init` method versus the approach taken here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向`MAGem.m`文件。因为`MAGem`是`CCSprite`的子类，所以我们有意避免了重写任何方法。尽管重写`init`方法是常见的做法，但在这里我们采取了不同的方法。所有实例变量都将由调用方法设置，而不是由`init`方法设置。这说明了任何情况下都没有唯一的正确答案。这种方法实际上导致代码行数略有减少，因为宝石只会在我们的`MAPlayfieldLayer`类中的单个方法中创建。在功能上，在自定义`init`方法中设置这些值与这里采取的方法之间没有区别。
- en: '**Filename**: `MAGem.m`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAGem.m`'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have a few helper methods in this class that will make the matching logic
    easier. Look at the method `isGemSameAs` in this class. Since this is in the `MAGem`
    class, we can pass it another `MAGem` instance as an argument, and it compares
    the `gemType` variables to determine whether they are the same type of gem. If
    they are the same, we return `YES`. If they are different, we return `NO`. We
    follow the same pattern for the `isGemInSameRow` and `isGemInSameColumn` methods.
    The code in these methods is extremely simple but will allow us to simplify how
    we interact with the gems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们有一些辅助方法将使匹配逻辑更容易。看看这个类中的 `isGemSameAs` 方法。由于这个方法在 `MAGem` 类中，我们可以传递另一个
    `MAGem` 实例作为参数，并比较 `gemType` 变量以确定它们是否是相同类型的宝石。如果是相同的，我们返回 `YES`。如果它们不同，我们返回 `NO`。我们遵循相同的模式为
    `isGemInSameRow` 和 `isGemInSameColumn` 方法。这些方法中的代码非常简单，但将使我们能够简化与宝石的交互方式。
- en: '**Filename**: `MAGem.m`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAGem.m`'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `isGemBeside` method is a little more involved. We first check to see whether
    the two gems in question (the current gem and `otherGem`) are in the same row,
    using the method we just saw. We also check to see whether the `colNum` variable
    of the `otherGem` object is either one greater or one less than the current gem.
    If this is true, we return `YES`. We then check to see whether `otherGem` is in
    the same column and whether they are in adjacent rows, in the same manner. This
    method (with the other `isGem` methods) will make comparisons between gems trivial
    to implement later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`isGemBeside` 方法稍微复杂一些。我们首先检查两个相关的宝石（当前宝石和 `otherGem`）是否在同一行，使用我们刚刚看到的方法。我们还检查
    `otherGem` 对象的 `colNum` 变量是否比当前宝石大或小一。如果是这样，我们返回 `YES`。然后我们检查 `otherGem` 是否在同一列，并且它们是否在相邻的行，以同样的方式。这个方法（以及其他
    `isGem` 方法）将使宝石之间的比较在以后实现时变得非常简单。'
- en: '**Filename**: `MAGem.m`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAGem.m`'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we see the `highlightGem` and `stopHighlightGem` methods.
    These will be used when the player touches a gem. The gem will hop up and down
    when it is selected. `stopHighlightGem` makes a call to the `resetGemPosition`
    method in the `GameLayer` class. We do this because the gem itself has no knowledge
    of where it is supposed to be on the screen. We could migrate the positioning
    code into the `MAGem` class to avoid this cross-class calling, but this works
    well, so we will leave it this way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到 `highlightGem` 和 `stopHighlightGem` 方法。这些方法将在玩家触摸宝石时使用。当宝石被选中时，它会上下跳动。`stopHighlightGem`
    方法会调用 `GameLayer` 类中的 `resetGemPosition` 方法。我们这样做是因为宝石本身并不知道它应该在屏幕上的位置。我们可以将定位代码迁移到
    `MAGem` 类中以避免这种跨类调用，但这样做效果很好，所以我们将保持这种方式。
- en: Generating gems
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成宝石
- en: We will build a new subclass of `CCLayer`, called `MAPlayfieldLayer`, and we
    will set up a couple of methods to control all gem creation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个新的子类 `CCLayer`，命名为 `MAPlayfieldLayer`，并设置几个方法来控制所有宝石的创建。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Combined, these two methods take care of creating a new gem, assigning all
    variables (including the `GameLayer` variable we use to refer to the layer from
    the `MAGem` class), and putting the gem into play. Why two methods? The `addGemForRow:`
    method takes control over three aspects of the addition: adding the gem to the
    layer, setting the position to a position higher than the screen, and calling
    the method to drop the gem into its proper position. The `generateGemsForRow:`
    method does everything except putting the gem into play. We do this because there
    are situations where we want to create a gem without making it visible, such as
    when we build the initial board.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法共同负责创建一个新的宝石，分配所有变量（包括我们从 `MAGem` 类引用层所使用的 `GameLayer` 变量），并将宝石放入游戏中。为什么有两个方法？`addGemForRow:`
    方法控制添加的三个方面：将宝石添加到层中，设置位置高于屏幕，并调用将宝石掉落到正确位置的方法。`generateGemsForRow:` 方法做所有的事情，除了将宝石放入游戏中。我们这样做是因为有些情况下我们想要创建一个宝石而不使其可见，例如当我们构建初始棋盘时。
- en: Since we are keeping a reference to the playfield layer inside the `MAGem` class
    (in the `setGameLayer:` line in the `generate` methods), we need to be memory-conscious
    and set that property to `nil` when the gem's `dealloc` method is run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `MAGem` 类内部（在 `generate` 方法中的 `setGameLayer:` 行）保留了对游戏区域层的引用，我们需要注意内存使用，并在宝石的
    `dealloc` 方法运行时将该属性设置为 `nil`。
- en: '**Filename**: `MAGem.m`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAGem.m`'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building the playfield
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏区域
- en: The creation of a basic playfield is very similar to the setup for the Memory
    game in [Chapter 1](ch01.html "Chapter 1. Thanks for the Memory Game"), *Thanks
    for the Memory Game*, with some slight variations. We do not want the playfield
    to start with three-in-a-row matches, so we want to check for matching situations
    and change the gems around to make sure the board is "clean" when the game starts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 基本游戏区域的创建与第 1 章[“Thanks for the Memory Game”]中记忆游戏的设置非常相似，有一些细微的差别。我们不希望游戏区域以三子连珠的匹配开始，因此我们想要检查匹配情况并改变宝石的位置，以确保游戏开始时棋盘是“干净”的。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `MAPlayfieldLayer.m`'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this method, we iterate through all positions and call `generateGemForRow:`
    for each slot on the board. As you recall, the `generateGemForRow:` method does
    not add the gems to the layer, so we can manipulate the board before we introduce
    it to the player. We call the `fixStartingMatches` method to correct any starting
    three-in-a-row situations, and then we iterate through all of the gems in the
    `gemsInPlay` array and add them to the board. (You may notice that, when a gem
    is first added, it is set to the state `kGemNew`, and when it is added to the
    board, it is changed to `kGemIdle`. This is to avoid any accidental matches occurring
    when a new gem has been created but is not yet visible. By the time we add it
    to the board, it is ready to play, so `kGemIdle` is the correct state at that
    time.) Now we need to see how the `fixStartingMatches` method works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们遍历所有位置，并对棋盘上的每个槽位调用 `generateGemForRow:` 方法。如您所回忆的，`generateGemForRow:`
    方法不会将宝石添加到层中，因此我们可以在将其介绍给玩家之前操纵棋盘。我们调用 `fixStartingMatches` 方法来纠正任何三子连珠的起始情况，然后遍历
    `gemsInPlay` 数组中的所有宝石并将它们添加到棋盘上。（您可能会注意到，当宝石首次添加时，它被设置为状态 `kGemNew`，而当它被添加到棋盘上时，它被更改为
    `kGemIdle`。这是为了避免在创建新宝石但尚未可见时发生任何意外匹配。当我们将其添加到棋盘上时，它已经准备好游戏，所以 `kGemIdle` 是当时正确的状态。）现在我们需要看看
    `fixStartingMatches` 方法是如何工作的。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `MAPlayfieldLayer.m`'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This method starts with the `checkForMatchesOfType` method, which we will cover
    shortly. For now, we only need to know that it reviews all gems in the `gemsInPlay`
    array and any three-in-a-row matching gems are added to the `gemMatches` array.
    This method calls that check, and if there are any gems in the `gemMatches` array,
    it destroys the first gem in the `gemMatches` array and creates a new replacement.
    After it has replaced this *one* gem, it calls itself, so it can check the entire
    board again. Why not fix all of them at once? The `gemMatches` array contains
    *all* matches, which means that if there is only a single three-in-a-row match
    on the board, there are three gems in the array. We only need to replace one of
    those gems to "fix" this match on the board, so the other two gems in that match
    will be unchanged. To help visually explain this, look at the following comparison:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法从 `checkForMatchesOfType` 方法开始，我们将在稍后介绍。现在，我们只需要知道它会审查 `gemsInPlay` 数组中的所有宝石以及任何三子连珠匹配的宝石，并将它们添加到
    `gemMatches` 数组中。这个方法调用那个检查，如果有任何宝石在 `gemMatches` 数组中，它将销毁 `gemMatches` 数组中的第一个宝石并创建一个新的替代品。在替换了这
    *一个* 宝石之后，它调用自身，以便再次检查整个棋盘。为什么不一次性修复所有这些呢？`gemMatches` 数组包含 *所有* 匹配，这意味着如果棋盘上只有一个三子连珠匹配，数组中有三个宝石。我们只需要替换这些宝石中的一个来“修复”棋盘上的这个匹配，所以那个匹配中的其他两个宝石将保持不变。为了帮助直观地解释这一点，请看以下比较：
- en: '![Building the playfield](img/9007_02_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![构建游戏区域](img/9007_02_01.jpg)'
- en: When the board was first generated, it created an instant match, as seen within
    the red box in the left image. After the `fixStartingMatches` method was run,
    it replaced the first gem in the match (the top one, in this case) and replaced
    it with a new, randomly generated gem. There is no longer a three-in-a-row match,
    so we are done. The `fixStartingMatches` method will run itself again after this
    one gem is changed, just to make sure we don't have another match situation. When
    all three-in-a-row match conditions have been fixed in this manner, the game setup
    can continue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当棋盘首次生成时，它创建了一个即时匹配，如左图中的红色框所示。在运行 `fixStartingMatches` 方法后，它替换了匹配中的第一个宝石（在这种情况下是上面的一个），并用一个新随机生成的宝石替换了它。不再有三子连珠的匹配，所以我们完成了。`fixStartingMatches`
    方法将在更改这个宝石之后再次运行，只是为了确保我们不会出现另一个匹配情况。以这种方式纠正所有三子连珠的匹配条件后，游戏设置可以继续。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the remainder of the book, we will be focusing on the implementation (`.m`)
    files. With a few exceptions, we will not be spending time going over the details
    of the headers, so you will want to consult the code bundle for this book if you
    are uncertain about a variable or property that is used within the code presented
    here. Our goal is primarily to understand how the various methods and objects
    power the games, and most of the important details are in the implementation files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将关注实现（`.m`）文件。除了一些例外，我们不会花费时间详细说明头文件，所以如果你对这里使用的变量或属性不确定，请查阅本书的代码包。我们的主要目标是理解各种方法和对象如何驱动游戏，而大多数重要细节都在实现文件中。
- en: Checking for matches
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查匹配
- en: 'There is only one method left to see the initial board built. The method `checkForMatchesOfType`
    takes a `desiredGemState` value as a parameter. We do this because, during the
    initial board setup, we only want to check gems that are in the state `kGemNew`.
    Later, during actual gameplay, we only want to check for matches when the gems
    are in the state `kGemIdle`. (During gameplay, the gems in the `kGemNew` state
    will be outside the visible screen before they are dropped on to the screen, and
    we definitely do not want to include them in matches until they drop into position.)
    Let''s look at the method now, in two parts:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下唯一的方法是查看初始棋盘的构建。`checkForMatchesOfType`方法接受一个`desiredGemState`值作为参数。我们这样做是因为，在初始棋盘设置期间，我们只想检查处于`kGemNew`状态的宝石。稍后，在实际游戏过程中，我们只想在宝石处于`kGemIdle`状态时检查匹配。
    （在游戏过程中，`kGemNew`状态的宝石在它们被投放到屏幕上之前将位于可见屏幕之外，我们绝对不希望在它们落入位置之前将它们包括在匹配中。）现在让我们分两部分来看这个方法：
- en: '**Filename**: `MAPlayfieldLayer.m` (`checkForMatchesOfType`, part 1)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m` (`checkForMatchesOfType`，第一部分)'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method looks a little daunting, so let''s take it apart. We have two main
    sections, one for the horizontal matches and one for vertical matches. What we
    see in the preceding code is just the horizontal match checking. The outer *for*
    loop iterates through all of the gems in the `gemsInPlay` array, naming this gem
    `aGem`. We immediately check to make sure `aGem` has the `desiredGemState` value
    we are looking for. If not, the rest of this section is skipped. If the `gemState`
    has the `desiredGemState` value, we start a second *for* loop on the same `gemsInPlay`
    array, this time calling the gem being evaluated `bGem`. We check to see whether
    the following conditions are true:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法看起来有点令人畏惧，所以让我们将其拆解。我们有两个主要部分，一个用于水平匹配，一个用于垂直匹配。在先前的代码中我们看到的是水平匹配检查。外部的`for`循环遍历`gemsInPlay`数组中的所有宝石，将这个宝石命名为`aGem`。我们立即检查以确保`aGem`具有我们正在寻找的`desiredGemState`值。如果不是，则跳过本节剩余部分。如果`gemState`具有`desiredGemState`值，我们开始在同一个`gemsInPlay`数组上启动第二个`for`循环，这次将正在评估的宝石称为`bGem`。我们检查以下条件是否成立：
- en: '`aGem` is the same type as `bGem` (using the `isGemSameAs` method)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aGem`与`bGem`类型相同（使用`isGemSameAs`方法）'
- en: '`aGem` is in the same row as `bGem`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aGem`与`bGem`在同一行'
- en: '`aGem`''s `colNum` is equal to the `bGem`''s `colNum` – 1'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aGem`的`colNum`等于`bGem`的`colNum`减1'
- en: '`bGem` is in the `desiredGemState`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bGem`处于`desiredGemState`状态'
- en: 'If all these conditions are true, it means that the `aGem` being evaluated
    has an identical gem to the right of it. So, we have a two-in-a-row situation.
    Now we start a third *for* loop using the `gemsInPlay` array, the same as the
    other two loops. With the third loop, we break the conditions into two separate
    *if* statements:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些条件都成立，这意味着正在评估的`aGem`右侧有一个相同的宝石。因此，我们有一个两连珠的情况。现在我们开始使用`gemsInPlay`数组启动第三个`for`循环，就像其他两个循环一样。在第三个循环中，我们将条件分成两个单独的`if`语句：
- en: '`aGem`''s `colNum` is equal to `cGem`''s `colNum` – 2'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aGem`的`colNum`等于`cGem`的`colNum`减2'
- en: '`cGem`''s gem state is equal to the `desiredGemState`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cGem`的宝石状态等于`desiredGemState`'
- en: 'And in the second *if* statement, we check these statements:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`if`语句中，我们检查以下这些陈述：
- en: '`aGem` is of the same type as `cGem`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aGem`与`cGem`类型相同'
- en: '`aGem` is in the same row as `cGem`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aGem`与`cGem`在同一行'
- en: If all of these conditions are true, we have made a three-in-a-row match. All
    three gems involved in the matching are then added to the `gemMatches` array.
    Instead of adding the gems directly to the array, we use the method `addGemToMatch`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些条件都成立，我们就完成了一个三连珠匹配。所有参与匹配的三个宝石随后被添加到`gemMatches`数组中。我们不是直接将宝石添加到数组中，而是使用`addGemToMatch`方法。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because we are checking the whole board, we often find multiple matches that
    involve the same gem. Since we only want each matching gem represented once, the
    `addGemToMatch` method checks to make sure the gem is not already in the array
    before adding it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要检查整个板子，我们经常发现涉及相同宝石的多个匹配。由于我们只想让每个匹配的宝石被表示一次，`addGemToMatch`方法在添加宝石之前会检查宝石是否已经在数组中。
- en: 'Now we can take a look at the second half of the method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看这个方法的下半部分：
- en: '**Filename**: `MAPlayfieldLayer.m` (`checkForMatchesOfType`, part 2)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `MAPlayfieldLayer.m` (`checkForMatchesOfType`, 第二部分)'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The second half of this method checks for vertical matches. You will notice
    that the code looks strikingly similar to the horizontal check we just reviewed
    in detail. The vertical check is almost the same as the horizontal, except that
    all references to rows and columns are reversed. Everything else is in the same
    structure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的下半部分检查垂直匹配。你会注意到代码看起来与我们在详细审查中刚刚审查的水平检查非常相似。垂直检查几乎与水平检查相同，只是所有关于行和列的引用都被反转了。其他所有内容都处于相同的结构中。
- en: Collecting touches
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集触摸
- en: 'Now that we have a board built, we need to add some mechanics to move the gems
    so we can make matches. Let''s look at the touch handlers, starting with the `ccTouchBegan`
    method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经搭建好了板子，我们需要添加一些机械装置来移动宝石，以便我们能够进行匹配。让我们看看触摸处理程序，从`ccTouchBegan`方法开始：
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `MAPlayfieldLayer.m`'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ccTouchBegan` method controls whether we track a specific touch. If we
    have reached a "game over" condition (indicated by the `gameOver` variable), we
    go back to the menu. We also trigger the same `replaceScene` method if `backButton`
    is touched. We handle these situations in `ccTouchBegan`, so we can override any
    other logic that might be going on and can leave the game whenever we want to.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ccTouchBegan`方法控制我们是否跟踪特定的触摸。如果我们达到了“游戏结束”的条件（由`gameOver`变量指示），我们就回到菜单。如果触摸了`backButton`，我们也会触发相同的`replaceScene`方法。我们在`ccTouchBegan`中处理这些情况，这样我们就可以覆盖可能正在进行的任何其他逻辑，并且可以在我们想要的时候离开游戏。'
- en: This is the first time we have encountered the `gemsTouched` array, so we will
    explain it here. When the player touches any gem, we add that gem to the `gemsTouched`
    array. When we have two gems in the `gemsTouched` array, we swap the position
    of the gems and check for a match. If there are two gems in the array, we know
    something else is happening in the game (swapping gems, checking for matches,
    moving gems around, and so on), so we stop tracking the touch at that point. If
    we have less than two gems in the array, we iterate through the `gemsInPlay` array
    to determine which (if any) gem was touched. When we find one, we return `YES`
    to allow the touch to be tracked.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次遇到`gemsTouched`数组，所以我们将在这里解释它。当玩家触摸任何宝石时，我们将该宝石添加到`gemsTouched`数组中。当我们有两个宝石在`gemsTouched`数组中时，我们交换宝石的位置并检查是否有匹配。如果数组中有两个宝石，我们知道游戏中正在发生其他事情（交换宝石、检查匹配、移动宝石等），所以我们停止跟踪触摸。如果我们数组中的宝石少于两个，我们遍历`gemsInPlay`数组以确定是否触摸了任何（如果有）宝石。当我们找到时，我们返回`YES`以允许跟踪触摸。
- en: Now that we have a touch being tracked, the handler continues with the `ccTouchMoved`
    method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在跟踪一个触摸，处理程序继续执行`ccTouchMoved`方法。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `MAPlayfieldLayer.m`'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is not much here. This method passes everything along to our own `touchHelper`
    method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多内容。这个方法将所有内容都传递给我们的`touchHelper`方法。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `MAPlayfieldLayer.m`'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As the player slides their finger on the board, `ccTouchMoved` will be triggered
    constantly, which in turn will call the `touchHelper` method repeatedly. The first
    check is to make sure that we don't already have two objects in the `gemsTouched`
    array (the same "protection" as in `ccTouchBegan`) and to make sure we don't have
    any gems moving (where the `gemsMoving` variable is `YES`). If we do, we call
    `return`, to stop tracking this touch.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在板上滑动手指时，`ccTouchMoved`会不断被触发，这反过来又会反复调用`touchHelper`方法。第一次检查是确保我们已经在`gemsTouched`数组中有两个对象（与`ccTouchBegan`中的相同“保护”），并确保我们没有任何正在移动的宝石（`gemsMoving`变量为`YES`）。如果有，我们调用`return`来停止跟踪这个触摸。
- en: If the touch comes in contact with a gem, and the gem is not already in the
    `gemsTouched` array, we play a sound, add it to the `gemsTouched` array, and send
    a message to the gem to run the `highlightGem` method. Since this code is called
    from the `ccTouchMoved` method, each gem will be added to the array (up to the
    stated maximum of two) as we swipe across multiple gems. We have swipe detection
    without needing any gesture detection code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果触摸接触到宝石，并且宝石尚未在 `gemsTouched` 数组中，我们将播放声音，将其添加到 `gemsTouched` 数组中，并发送消息给宝石以运行
    `highlightGem` 方法。由于此代码是从 `ccTouchMoved` 方法中调用的，因此当我们滑动多个宝石时，每颗宝石都将添加到数组中（最多达到声明的两个）。我们有了滑动检测，而无需任何手势检测代码。
- en: The final *if* statement is to check whether we have gathered two gems in the
    `gemsTouched` array. If we have, we first check to make sure the gems are adjacent
    (the `isGemBeside` method). If they are adjacent, we call `swapGem` and pass the
    two gems to that method. If not, we stop highlighting the first gem in the array
    and remove it from the `gemsTouched` array, so the second touch is now the only
    gem in the `gemsTouched` array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 *if* 语句是检查我们是否在 `gemsTouched` 数组中收集到了两颗宝石。如果有，我们首先检查确保宝石是相邻的（使用 `isGemBeside`
    方法）。如果它们是相邻的，我们调用 `swapGem` 并将两颗宝石传递给该方法。如果不是，我们停止突出显示数组中的第一颗宝石，并将其从 `gemsTouched`
    数组中删除，这样第二次触摸现在就是 `gemsTouched` 数组中唯一的宝石。
- en: Now let's look at the final touch handler method, `ccTouchEnded`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看最终的触摸处理方法，`ccTouchEnded`。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What's going on here? The checks that we needed in the `ccTouchEnded` method
    are exactly the same checks that we used in the `ccTouchMoved` method, so we can
    call the same code, rather than copying all the code into both methods; this is
    why we created the `touchHelper` method. Looking at both the `ccTouchMoved` and
    `ccTouchEnded` methods together, we have the flexibility to be able to swipe or
    tap on gems to select them. `ccTouchMoved` is only called when the touch moves
    (that is, a swipe), so a simple tap will not activate the code in that method.
    The `ccTouchEnded` method is only called when the touch ends (that is, the finger
    is lifted off the screen). By triggering the same code in both places, we can
    cover both styles of player interaction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？在 `ccTouchEnded` 方法中我们需要进行的检查与我们在 `ccTouchMoved` 方法中使用的检查完全相同，因此我们可以调用相同的代码，而不是将所有代码复制到两个方法中；这就是我们创建
    `touchHelper` 方法的原因。同时查看 `ccTouchMoved` 和 `ccTouchEnded` 方法，我们能够灵活地通过滑动或轻触宝石来选择它们。`ccTouchMoved`
    只在触摸移动时（即滑动）被调用，所以简单的点击不会激活该方法中的代码。`ccTouchEnded` 方法只在触摸结束时（即手指从屏幕上抬起）被调用。通过在两个地方触发相同的代码，我们可以覆盖两种玩家交互方式。
- en: Moving gems
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动宝石
- en: 'Let''s briefly look at the methods we use to handle gem movements:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看看我们用来处理宝石移动的方法：
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `swapGem` method is very basic. We use temporary variables to assist with
    swapping the `rowNum` and `colNum` values of the two gems passed to the method.
    After they are changed, we call the `moveToNewSlotForGem` method on both gems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`swapGem` 方法非常基础。我们使用临时变量来帮助交换传递给该方法的两颗宝石的 `rowNum` 和 `colNum` 值。在它们改变之后，我们在两颗宝石上调用
    `moveToNewSlotForGem` 方法。'
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `moveToNewSlotForGem` method first sets the gem's state to `kGemMoving`,
    so this gem will not take part in any matching logic while in motion. Then, we
    use a `CCMoveTo` action to move the gem where it should be (based on the new `rowNum`
    and `colNum` variables we just assigned to it), play a sound effect, and then
    call the `gemIsAtRest` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveToNewSlotForGem` 方法首先将宝石的状态设置为 `kGemMoving`，因此在这颗宝石移动时，它将不会参与任何匹配逻辑。然后，我们使用
    `CCMoveTo` 动作将宝石移动到它应该去的位置（基于我们刚刚分配给它的新的 `rowNum` 和 `colNum` 变量），播放音效，然后调用 `gemIsAtRest`
    方法。'
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `gemIsAtRest` method resets the gem's state, so it is now `kGemIdle`. This
    means it will now be allowed to participate in any matching checks that are performed
    on the board. We also set the `checkMatches` variable to `YES`. This is the trigger
    we use to identify that the board is now stable enough to check for a potential
    match.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`gemIsAtRest` 方法重置宝石的状态，因此现在它是 `kGemIdle`。这意味着它现在将允许参与在板上进行的任何匹配检查。我们还设置了 `checkMatches`
    变量为 `YES`。这是我们用来识别板现在足够稳定，可以检查潜在匹配的触发器。'
- en: Checking moves
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查移动
- en: We are close to completing a basic Match 3 game. Let's look at a couple more
    methods we need to finish it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将完成一个基本的匹配3游戏。让我们看看我们还需要完成游戏的几个方法。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By now, you should be familiar enough with the way the gem arrays are handled
    in this code, and so you should find this method pretty simple. First, we call
    the `checkForMatchesOfType` method to populate the `gemMatches` array with matching
    gems (if any are found). If we find any matches, all matching gems are sent to
    the `animateGemRemoval` method. Once that loop is complete, we remove all gems
    from the `gemMatches` array. If we have any gems in the `gemsTouched` array, we
    call `stopHighlightGem` on them. If there were two gems in that array, it means
    we had a move that did not make a match, so we call `swapGem` to move them back
    to where they started from. After that has been resolved, we clear the `gemsTouched`
    array. By the end of this method, the two temporary arrays are empty and all matches
    have been resolved.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经足够熟悉在这段代码中处理宝石数组的方式，因此你应该觉得这个方法相当简单。首先，我们调用`checkForMatchesOfType`方法，用匹配的宝石（如果找到的话）填充`gemMatches`数组。如果我们找到任何匹配项，所有匹配的宝石都会被发送到`animateGemRemoval`方法。一旦这个循环完成，我们就从`gemMatches`数组中移除所有宝石。如果我们有宝石在`gemsTouched`数组中，我们会调用它们上的`stopHighlightGem`。如果数组中有两个宝石，这意味着我们有一个没有匹配的移动，所以我们会调用`swapGem`将它们移回到起始位置。在那之后，我们清除`gemsTouched`数组。到这个方法结束时，两个临时数组都是空的，所有匹配项都已解决。
- en: Removing gems
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除宝石
- en: 'Now let''s look at the methods used to remove gems from the board:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看用于从棋盘上移除宝石的方法：
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These three methods, taken together, handle everything we need to neatly animate
    a matched gem. `changeGemFace` uses a method we haven''t seen before. Since all
    of our images are part of the same `CCSpriteBatchNode`, we are able to use the
    `setDisplayFrame` method to change the image of the sprite on the fly. Here, we
    replace the gem''s image with the "boom" image. We move it up the screen and fade
    it out, so it disappears from the board neatly. (We also update the score and
    add time to the timer, but we won''t be discussing those features of the game
    here. If you don''t use a score or a timer, you can easily remove those actions.)
    There is one important method called from the `removeGem` method, `fillHolesFromGem`.
    Let''s see what it does:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个方法结合起来，处理了我们为了整洁地动画匹配宝石所需的所有内容。`changeGemFace`使用了一个我们之前没有见过的方法。由于我们所有的图像都是同一个`CCSpriteBatchNode`的一部分，我们能够使用`setDisplayFrame`方法在运行时更改精灵的图像。在这里，我们用“爆炸”图像替换宝石的图像。我们将其向上移动屏幕并淡出，使其从棋盘上整洁地消失。（我们也会更新分数并给计时器加时，但在这里我们不会讨论这些游戏功能。如果你不使用分数或计时器，你可以轻松地移除这些动作。）有一个重要的方法是从`removeGem`方法中调用的，叫做`fillHolesFromGem`。让我们看看它做了什么：
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method looks for any gems that are in the same column as the passed gem,
    `aGem`. We iterate through the `gemsInPlay` array, looking for any gems in a row
    above `aGem`, reset their `rowNum` variable to one row lower, and then trigger
    the `moveToNewSlotForGem` method. This will effectively fill in any gaps in the
    board. It doesn't add any new gems to the board, but collapses them all downward
    so any remaining holes are at the top of the board. (The `smartFill` method is
    covered in the *Predictive logic* section of this chapter.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法寻找任何与传递的宝石`aGem`在同一列的宝石。我们遍历`gemsInPlay`数组，寻找任何在`aGem`上方一行的宝石，将它们的`rowNum`变量重置为低一排，然后触发`moveToNewSlotForGem`方法。这将有效地填充棋盘上的任何间隙。它不会在棋盘上添加任何新的宝石，但将它们全部向下折叠，使任何剩余的空位都在棋盘顶部。（`smartFill`方法在本章的*预测逻辑*部分有所介绍。）
- en: The update method
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新方法
- en: We now turn our attention to the `update` method, which will tie it all together.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将注意力转向`update`方法，它将把所有这些内容串联起来。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we tie together a couple of loose ends in the code. We start with the `gemsMoving`
    `BOOL`, which we used in the touch handler. We set the value in the `update` method
    by iterating through all the gems to determine whether there are any gems in the
    state `kGemMoving`. If any gems are moving, `gemsMoving` is set to `YES`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将代码中的几个松散的结尾串联起来。我们从一个在触摸处理程序中使用的`gemsMoving` `BOOL`开始。我们在`update`方法中通过遍历所有宝石来确定是否有任何宝石处于`kGemMoving`状态。如果有任何宝石在移动，`gemsMoving`会被设置为`YES`。
- en: The `BOOL` `checkMatches` is next. If this variable has been set to `YES`, we
    run the `checkMove` method. As we saw earlier, this method takes care of handling
    all the matching logic and removal of matched gems. At the end of this *if* statement,
    we reset the `checkMatches` variable to `NO` to indicate the matches are resolved.
    (We will discuss `checkMovesRemaining` in the next section).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `BOOL` 类型的 `checkMatches`。如果这个变量被设置为 `YES`，我们运行 `checkMove` 方法。正如我们之前看到的，这个方法负责处理所有匹配逻辑和移除匹配的宝石。在这个
    `if` 语句的末尾，我们将 `checkMatches` 变量重置为 `NO` 以指示匹配已解决。（我们将在下一节讨论 `checkMovesRemaining`。）
- en: The final portion of the core `update` method checks to see if we don't have
    enough gems on the board and if nothing is moving. If both of these conditions
    are true, we call the `addGemsToFillBoard` method to fill in any missing gems.
    (There are also the timer update and the game-over checks at the end. We will
    not be discussing those here, so the code details have been omitted. Please see
    the accompanying code for those portions of the update method.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 核心的 `update` 方法的最后一部分检查棋盘上是否宝石不足且没有任何移动。如果这两个条件都成立，我们调用 `addGemsToFillBoard`
    方法来填充任何缺失的宝石。（在游戏结束时的计时器更新和游戏结束检查也有。我们在这里不会讨论这些，所以省略了代码细节。请参阅附带的代码以了解更新方法的这些部分。）
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We iterate through all the spaces on the board, and then, through all the gems
    in the `gemsInPlay` array. If we find a gem in that slot, we set the `missing`
    variable to `NO`. If we do not find a gem in a given slot (that is, `missing =
    YES`), we call the `addGemForRow` method to add a new random gem to fill in that
    slot.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历棋盘上的所有空间，然后遍历 `gemsInPlay` 数组中的所有宝石。如果我们在这个槽位中找到一个宝石，我们将 `missing` 变量设置为
    `NO`。如果我们没有在给定的槽位中找到一个宝石（即 `missing = YES`），我们将调用 `addGemForRow` 方法来添加一个新的随机宝石以填充该槽位。
- en: Predictive logic
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测逻辑
- en: So far, we have mostly covered straightforward code that takes care of basic
    game mechanics. There is one problem, though. The game can produce a board that
    is impossible to make a move on. Worse, we have no way of knowing that there are
    no more moves remaining. We aim to correct that deficiency now, in a rather dense
    method called `checkMovesRemaining`. First, we should cover the basic concept
    of how this is accomplished.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要介绍了处理基本游戏机制的直接代码。然而，有一个问题。游戏可能会生成一个无法进行移动的棋盘。更糟糕的是，我们无法知道是否还有剩余的移动。我们的目标是现在纠正这个缺陷，采用一种称为
    `checkMovesRemaining` 的密集方法。首先，我们应该了解如何实现这一基本概念。
- en: If you recall, the `checkForMatchesOfType` method we reviewed earlier did a
    good job of finding any actual matches on the board. We could code this predictive
    method in that style, but it quickly gets confusing since you need to be able
    to determine matches up to five gems in a row to get an accurate count of moves
    remaining. Here, we take another approach by writing the `gemType` values into
    a "C-style" array, so we can easily get a single view of the whole board without
    massive nested loops.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们之前审查的 `checkForMatchesOfType` 方法在找到棋盘上的任何实际匹配方面做得很好。我们可以用那种风格编写这个预测方法，但由于需要能够确定最多五个连续宝石的匹配，以获得剩余移动的准确计数，这会很快变得混乱。在这里，我们通过将
    `gemType` 值写入一个“C样式”数组来采取另一种方法，这样我们可以轻松地获得整个棋盘的单个视图，而无需使用大量的嵌套循环。
- en: The challenge is determining all the possible ways a player can legally move
    a gem and how the board would look after the move. We iterate through all positions
    from the bottom left corner, and we will test what happens if the gem is moved
    to the right, and also what happens if the gem is moved up. Even though the player
    can also move left and down, those will already be taken care of because swapping
    one gem downwards is the same as swapping the one below it upwards.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于确定玩家可以合法移动宝石的所有可能方式以及移动后棋盘的形状。我们从左下角的所有位置开始遍历，我们将测试如果宝石向右移动会发生什么，以及如果宝石向上移动会发生什么。尽管玩家也可以向左和向下移动，但这些已经被处理了，因为向下交换一个宝石等同于向上交换下面的宝石。
- en: 'We start our test scenarios by creating a "letter map" of the board area, with
    the letter "a" representing the board slot being evaluated, like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个表示棋盘区域的“字母映射”来开始我们的测试场景，其中字母“a”代表正在评估的棋盘槽位，如下所示：
- en: '![Predictive logic](img/9007_02_02.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![预测逻辑](img/9007_02_02.jpg)'
- en: We will use this letter map and assign variables to represent the value at each
    specified position in the array. For example, the variable `f` is at location
    `row+1` and `col+1`, relative to the letter *a*. From there, we will test a "deformed"
    version of the map, first with the *a* and *b* positions swapped, and then by
    testing *a* and *e* swapped. From there, we count up all the matches that can
    be made with a single move, and we set that as the `movesRemaining` variable.
    (This code is pretty long, but there's no good way to break it up here.)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个字母映射并分配变量来表示数组中每个指定位置的价值。例如，变量`f`位于相对于字母*a*的`row+1`和`col+1`位置。从那里，我们将测试映射的“变形”版本，首先交换*a*和*b*的位置，然后测试*a*和*e*交换。从那里，我们计算单次移动可以形成的所有匹配，并将这个值设置为`movesRemaining`变量。（这段代码相当长，但在这里没有很好的分割方式。）
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To keep the positioning straight, you can see that we have put in a textual
    version of the letter map into the code. This is a convenience, since trying to
    read the patterns from the code itself is rather tiresome and challenging. When
    we look at possible matches after deforming the board, there are four possible
    ways we can match for each of the deformations, as illustrated here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持定位清晰，你可以看到我们将字母映射的文本版本放入了代码中。这是一个便利之处，因为试图从代码本身读取模式相当繁琐且具有挑战性。当我们查看变形后的棋盘上的可能匹配时，对于每种变形，我们有四种可能的匹配方式，如图所示：
- en: '![Predictive logic](img/9007_02_03.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![预测逻辑](img/9007_02_03.jpg)'
- en: To assist with this checking, we add a helper method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了协助这项检查，我们添加了一个辅助方法。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Any combination of five gems could result in a match of three, four, or five
    in a row. We pass five gems in a row to this method, and it checks for five in
    a row first, then four in a row, and then three in a row. It is an *if…else-if*
    structure because a five-in-a-row match would also trigger as four-in-a-row and
    three-in-a-row matches, so we let it act as a waterfall to avoid over-counting
    the matches. You will also notice that we are making sure that one of the variables
    is not `0`. As we saw in the `checkMovesRemaining` method itself, we only record
    the gem type for gems that are in the `kGemIdle` state. All other gem states (`kGemMoving`,
    `kGemScoring`, and `kGemNew`), as well as positions off the board, will be represented
    as `0` in the map.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 五种宝石的任何组合都可能导致三、四或五连珠匹配。我们将五颗连珠传递给这个方法，它首先检查五连珠，然后是四连珠，接着是三连珠。这是一个`if…else-if`结构，因为五连珠匹配也会触发四连珠和三连珠匹配，所以我们让它像瀑布一样作用，以避免重复计数匹配。你也会注意到我们确保其中一个变量不是`0`。正如我们在`checkMovesRemaining`方法本身所看到的，我们只为处于`kGemIdle`状态的宝石记录宝石类型。所有其他宝石状态（`kGemMoving`、`kGemScoring`和`kGemNew`），以及棋盘外的位置，在地图中都将表示为`0`。
- en: Artificial randomness
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工随机性
- en: So now, we can evaluate the board to see all potential moves. Then what? We
    could put in a trigger in the `update` method to flash a "no more moves" message
    and cause game over, but that's no fun, is it? Our goal is to make a game that
    will keep going forever. This is where we are finally ready to find out details
    of the `smartFill` method we saw in the code earlier. This is a really long method,
    listed in its entirety. It is a critical method to the process, so please bear
    with us.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以评估棋盘以查看所有可能的走法。然后呢？我们可以在`update`方法中添加一个触发器，显示“没有更多走法”的消息并导致游戏结束，但这没有乐趣，对吧？我们的目标是制作一个可以永远进行下去的游戏。这就是我们最终准备好找出之前在代码中看到的`smartFill`方法细节的时候。这是一个非常长的方法，完整列出。这是过程中的一个关键方法，所以请耐心等待。
- en: '**Filename**: `MAPlayfieldLayer.m`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`MAPlayfieldLayer.m`'
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This structure of code should look familiar to you, as it uses the same design
    structure as the `checkMovesRemaining` method. It uses the same "map" array concept,
    albeit with fewer variables needed for this method. There are two subtle differences
    in the top portion of the code. The first is that if the `gemsMoving` variable
    is `YES`, we schedule the `smartFill` method with an interval of `0.05` and immediately
    exit the method (with the `return` statement). The first thing the method does,
    in fact, is unschedule itself if it was already scheduled. This causes the `smartFill`
    method to wait until the board has stabilized with nothing moving. This allows
    us to always check a static board without worrying about the difference between
    an empty slot and a slot with a moving gem.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结构应该对你来说很熟悉，因为它使用了与 `checkMovesRemaining` 方法相同的设计结构。它使用了相同的“地图”数组概念，尽管这个方法需要的变量较少。代码的上部有两个细微的差异。第一个是，如果
    `gemsMoving` 变量是 `YES`，我们将 `smartFill` 方法安排在 `0.05` 的时间间隔后执行，并立即退出方法（使用 `return`
    语句）。实际上，这个方法的第一件事就是如果它已经被安排，就取消安排自己。这导致 `smartFill` 方法等待棋盘稳定下来，没有任何东西在移动。这允许我们始终检查一个静态的棋盘，而不用担心空槽和带有移动宝石的槽之间的差异。
- en: The second interesting portion of the top of the method is the check for whether
    `movesRemaining` is greater than or equal to six. If that is true, we have plenty
    of moves remaining, so the `addGemsToFillBoard` method we saw earlier will be
    called, which will generate random gems to fill in the board. Why six? Ideally,
    we would want to be able to kick in this `smartFill` method only when we are down
    to one or two moves remaining, but since a single move has the potential of eliminating
    several other moves (by shifting the board, or by using gems that were also potentially
    part of another match), testing showed six is a safe number to use to avoid a
    deadlocked board.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的顶部第二个有趣的片段是检查 `movesRemaining` 是否大于或等于六。如果是这样，我们就有很多剩余的移动，所以之前看到的 `addGemsToFillBoard`
    方法将被调用，这将生成随机宝石来填充棋盘。为什么是六？理想情况下，我们希望只在只剩下一个或两个移动时启动这个 `smartFill` 方法，但由于单个移动有可能消除其他几个移动（通过移动棋盘或使用也可能是另一个匹配的一部分的宝石），测试表明六是一个避免棋盘死锁的安全数字。
- en: We also have one difference in the way the map is populated. In this case, we
    check if any position is outside of the actual board area and assign a value of
    `-1`. If it is a "hole in the board", it will be assigned `0`. In this way, we
    can make sure we are only filling in the board itself, and not areas outside the
    board. (These external `-1` values are sometimes called **sentinel values** because
    they guard the edges of the board.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充地图的方式上，我们也有一些不同。在这种情况下，我们会检查是否有任何位置超出了实际棋盘区域，并分配一个值为 `-1`。如果是一个“棋盘上的洞”，它将被分配
    `0`。这样，我们可以确保我们只填充棋盘本身，而不是棋盘外的区域。（这些外部的 `-1` 值有时被称为 **哨兵值**，因为它们守护着棋盘的边缘。）
- en: 'Here is our fill-in map for the `smartFill` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们为 `smartFill` 方法准备的填充地图：
- en: '![Artificial randomness](img/9007_02_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![人工随机](img/9007_02_04.jpg)'
- en: The goal is to fill in the holes in the board with something that will be usable
    in making a match. We do this by copying a nearby gem, so we can guarantee a match.
    However, depending on where on the board the hole is, we cannot always guarantee
    there will be a single gem we can always clone (relative to the hole), so we iterate
    through a few likely possibilities until we find one and then call `smartFill`
    again to take care of any further holes. You will notice that, in all situations,
    we clone two gems and leave the third gem to be set as `kGemAnyType`—randomized.
    This gives us some level of randomness that adds spice to the situation, even
    as we spoon feed the player a viable board.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是用可以用于制作匹配的东西填充棋盘上的洞。我们通过复制附近的宝石来实现这一点，这样我们可以保证匹配。然而，根据洞在棋盘上的位置，我们并不能总是保证有一个可以复制的单个宝石（相对于洞），所以我们迭代几个可能的位置，直到找到一个，然后再次调用
    `smartFill` 方法来处理任何进一步的洞。你会注意到，在所有情况下，我们都复制两个宝石，并留下第三个宝石设置为 `kGemAnyType`——随机化。这给我们带来了一定程度的随机性，即使在向玩家提供可行的棋盘时，也能增加一些趣味性。
- en: This `smartFill` method does not do a complete job by itself; it can leave small
    1- or 2-gem holes if there is a four-in-a-row or five-in-a-row match. The remaining
    holes will be filled in by the call to the `addGemsToFillBoard` method in the
    update loop. This is by design, since we did not want to add even more code to
    handle artificial randomness for 4- and 5-gem holes. The added calculations required
    are not necessary to fulfill our goal of keeping the game going. As a final note,
    if you want to remove all of the "artificial randomness", you only have to comment
    out the call to the `smartFill` method at the end of the `fillHolesFromGem` method
    . Of course, then you will need to add a "no more moves" handler to react to that
    situation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`smartFill`方法本身并不能完成完整的工作；如果存在四连或五连匹配，它可能会留下小的1-或2颗宝石的空隙。剩余的空隙将在更新循环中调用`addGemsToFillBoard`方法时被填充。这是有意为之，因为我们不想为处理4颗和5颗宝石的空隙添加更多的代码来处理人工随机性。所需的额外计算并不必要，因为我们不希望为了保持游戏进行而添加更多代码。作为最后的说明，如果你想要移除所有的“人工随机性”，你只需要在`fillHolesFromGem`方法末尾注释掉对`smartFill`方法的调用。当然，那么你将需要添加一个“没有更多移动”的处理程序来应对这种情况。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot of ground in a short period of time, and we've covered
    more than one approach to some of the challenges this game presents to us. We
    have learned how to control a grid of gems with the appearance of gravity (in
    other words, filling in holes), we have learned how to match by using nested *for*
    loops. We have also learned how to check for matches and how to check for predictive
    matches using a "C-style" array without forcing ourselves to use C-style arrays
    throughout the code. Finally, we addressed the idea of artificial randomness to
    give the player an ongoing game experience without risking a "no more moves" situation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在短时间内，我们覆盖了大量的内容，并且对于这个游戏向我们提出的某些挑战，我们探讨了不止一种方法。我们学习了如何通过重力（换句话说，填充空隙）来控制宝石网格，我们学习了如何使用嵌套的*for*循环进行匹配。我们还学习了如何检查匹配，以及如何使用“C风格”数组检查预测性匹配，而不必在代码中强制使用C风格数组。最后，我们讨论了人工随机性的概念，以给玩家提供持续的游戏体验，同时避免“没有更多移动”的情况。
- en: The code bundle for this chapter also includes both scoring and a progress timer,
    which we saw traces of but didn't really discuss here. The implementation is very
    simple, so we leave it to you, the reader, to explore these features on your own.
    The example "tests" contained within the sample projects included with the cocos2d
    download are a great resource for lesser-known classes, such as `CCProgressTimer`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包包括评分和进度计时器，我们在之前的讨论中提到了这些功能的痕迹，但并未深入探讨。实现方式非常简单，所以我们留给读者自行探索这些功能。包含在cocos2d下载示例项目中的“测试”示例是一个很好的资源，特别是对于像`CCProgressTimer`这样的不太为人所知的类。
- en: In the next chapter, we will tackle a classic mole-whacking game, and learn
    how to trick the player's eye.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解决一个经典的敲击地鼠游戏，并学习如何欺骗玩家的眼睛。
