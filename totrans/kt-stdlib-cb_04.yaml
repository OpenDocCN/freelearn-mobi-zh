- en: Powerful Data Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Composing and consuming collections the easy way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic `null` removal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting data with custom comparators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building strings based on dataset elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing data into subsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming data with  `map` and `flatMap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folding and reducing datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on exploring standard library support for declarative-style
    operations on collections. The following recipes present solutions to different
    types of programming problems related to dataset transformations, reductions,
    and grouping. We will learn how to approach data processing operations with a
    functional programming style, together with the powerful data-processing extensions
    built into the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Composing and consuming collections the easy way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kotlin standard library provides a number of handy extensions that make
    collections creation and merging easy and safe. We are going to learn them step
    by step. Let''s assume we have the following `Message` class defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we are going to create two sample collections containing `Message`
    instances and merge them into one list of `Message` objects. Next, we are going
    to iterate through the list of messages and print their text to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin standard library provides two basic interfaces which represent collection
    data structure—`Collection` and `MutableCollection`, both extending the `Iterable`
    interface. The first one defines an immutable collection that only supports read
    access to its elements. The second interface allows us to both add and remove
    elements. There are also more specialized interfaces that extend the `Collection`
    and `MutableCollection` base types, such as `List`, `MutableList`, `Set`, and
    `MutableSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many functions available for creating collections of different types.
    The most commonly used ones are the `<T> listOf(vararg elements: T)` function,
    which instantiates a `List` instance, and `<T> mutableListOf(vararg elements:
    T)`, which returns an instance of `MutableList` for the elements given as a function''s
    arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s declare two lists containing sample data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Merge `sentMessages` and `inboxMessages` into one collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the text of the `Message` objects stored in the `allMessages` list
    to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the result, our code is going to print the following text to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In order to add elements of one collection to another, we are using the `+`
    operator. The standard library overloads this operator with the code responsible
    for merging elements of two `Collection` type instances collections into one instance.
    The `sentMessages` and `inboxMessages` variables are declared as `List` instances.
    The `plus` function returns a new `Collection` instance, containing elements of
    the `sentMessages` and `inboxMessages` lists. Finally, we use the `forEach()`
    function to iterate through the next elements of the list. In the lambda block
    passed to the `forEach` function, we are print the `text` property of the current
    `Message` to the console. We are destructuring the lambda's argument of the `Message`
    type and accessing its text property directly inside the `println()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library also overloads a `-` operator for the Collection type.
    We could use it to subtract some elements from the collection. For example, we
    could use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And we would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also use the standard `for` loop to implement the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can learn more about destructuring declarations in the *Destructuring types*
    recipe in [Chapter 2](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml), *Expressive
    Functions and Adjustable Interfaces*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you'd like to master lambda expressions, you can take a look at the *Working
    effectively with lambdas and closures *recipe from [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml), *Shaping
    Code with Kotlin Functional Programming Features*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering datasets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filtering is one of the most common programming challenges in the data processing
    field. In this recipe, we are going to explore the standard library''s built-in
    extension functions that provide an easy way to filter the `Iterable` data types.
    Let''s assume we have the following `Message` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getMessages()` function returns the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are going to apply a filtering operation to the `getMessages()` function
    that will return only the messages with the `Folder.INBOX` property and with the
    `sender` property equal to `Agat`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the filtering transformation, we are going to use the `Iterable<T>.filter(predicate:
    (T) -> Boolean)` extension function provided by the standard library. The `filter()`
    function takes a predicate function that returns `true` or `false` values for
    the given element of the generic `Iterable` dataset type `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apply filtering to the `getMessages()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate through the filtered messages and print their messages to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are applying the `filter` function to the results of the `ge``tMessages()`
    function. We pass a lambda block to the `filter` function, which returns a Boolean
    for each of the list's elements. The `filter` function returns a list containing
    filtered objects. Finally, we use the `forEach()` function to iterate through
    the next elements of the list. In the lambda block passed to the `forEach` function,
    we print the `text` property of the current `Message` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the code from the preceding section is going to print the following
    output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin standard library offers corresponding `filter()` extension functions
    for other types, such as `Array`, `Sequence`, and `Map`. There are also many variations
    of the filter function that can be useful for specific scenarios. You can find
    all of them in the official documentation of the Kotlin standard library `kotlin.collections`
    package at [http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections](http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to master lambda expressions, you can take a look at the *Working
    effectively with lambdas and closures* recipe from [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml), *Shaping
    Code with Kotlin Functional Programming Features*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic null removal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with poorly designed APIs of servers or external libraries, we
    often need to deal with receiving null return values. Thankfully, there are a
    number of standard library features that allow us to handle null values effectively.
    In this recipe, we are going to implement a data preprocessing operation which
    will remove all the nulls from the dataset automatically. Let''s say we are working
    with an external API that provides us with the latest news feed. Unfortunately,
    it''s not null-safe and can return random null values. For example, let''s assume
    we have a `getNews(): List<News>` function that returns the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `News` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apply the `filterNotNull` function to the `getNews()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a result, we are going to get the following output printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the code without the `filterNotNull()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Iterable.filterNotNull()` extension function removes all the null values
    from the original dataset. Under the hood, it copies non-null values to a newly
    created `List` instance. That's why it is more efficient to use sequences instead
    of collections in order to provide lazy evaluation for large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Filtering data sets* recipe*, *we explored how to use the basic `filter()`
    function form provided by the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you'd like to master lambda expressions, you can take a look at the *Working
    effectively with lambdas and closures* recipe from [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml), *Shaping
    Code with Kotlin Functional Programming Features*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting data with custom comparators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to explore the support for sorting collections'
    elements by their properties.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume we are dealing with the two collections of the `Message` type
    declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These are provided by the `allMessages` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print the text of consecutive messages from the `allMessages` list, we
    get the following text printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That doesn't look right. The messages should be displayed in chronological order.
    That means they should be sorted by the `time` property.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apply the `sortedBy` function to the `allMessages` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the sorted elements to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we run the preceding code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, all the messages are sorted properly and the conversation makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If our collection consisted of objects that implement the Comparable interface,
    we would be able to sort it simply by applying a `sorted()` function to it. The
    Kotlin standard library also provides more specialized versions of the `sortedBy()`
    function, such as `sortedByDescending()` and `sortedWith()`. The first one works
    as a base-sorting function, but it returns the dataset sorted with the opposite
    order. The `sortedWith()` function allows us to sort the list with a custom comparator.
    For example, to sort a collection of the `Message` type elements first by `sender` and
    next by the `time` property, we could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Building strings based on dataset elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we face the problem of generating text based on collections'' elements.
    This is where the `Iterable.joinToString()` extension function can help. For example,
    we can consider working on an email-message-forwarding feature. When a user clicks
    the forward button, the original message''s body text is concatenated, with the
    prefix looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we are going to implement a function that is going to generate
    the recipients'' string, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For a given list of `Address` type objects, it is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare the `generateRecipientsString()` function header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by removing all the `null` items from the `recipient` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform collection elements of the `Address` type to the `String` type elements
    corresponding to the `Address.emailAddress` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the `joinToString()` function in order to merge collection elements into
    the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `generateRecipientsString()` function uses the `Iterable.joinToString()`
    extension function from the standard library `kotlin.collections` package to generate
    the output string. The `joinToString()` function takes three parameters—the separator
    character, which is used to concatenate the next substrings, the prefix, and the
    suffix strings. It is invoked on a collection of String values. We are also applying
    the preprocessing operations that are responsible for removing the `null` values
    from the list of the `Address` objects and mapping the `Address` type to the `String` corresponding
    to the `Address.emailAddress` property.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could also use another version of the `joinToString()` function to simplify
    the logic of our `generateRecipientsString()` function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it takes the additional argument in the form of an inlined lambda
    block, which acts as a transformation function that is being applied to each of
    the `recipients` collection elements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore dataset mapping operations in more depth, you can read the *Data
    transformation with the map and flatMap* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing data into subsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common data-processing task is to divide a collection of data into subsets. In
    this recipe, we are going to explore standard library functions that allow us
    to buffer a collection into smaller chunks. Let''s say we have a list containing
    a large number of `Message` type objects and we would like to transform it into
    collections of sub-lists of a constant size. For example, the transformation would
    take the original collection of *n* elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And it would then split it into a collection of four element subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by declaring the `Message` class that we are going to use in the
    following recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare the `messages` variable that stores the sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apply the `windowed()` function to the `messages` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `transform: (List<T>) -> R` transformation function as an additional,
    inline parameter to the windowed function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `windowed` function splits the original list of messages into sublists
    of a specified size. As a result, we get the `List<List<Message>>` type assigned
    to the `pagedMessages` handle. We could print the next message subsets with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As the result, we get the following output printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `windowed` function takes four parameters—the size of the window, a flag
    saying whether partial windows should be created, a step value, and an optional
    transforming function that is responsible for converting each of the generated
    windows. In our scenario, we are using a window size equal to `4`. This is why
    we need to specify the step value as equal to `4` as well because we want to have
    consecutive `Message` instances stored in the next windows. We also set the `partialWindows` argument
    to `true`, otherwise, the last window containing a single message would be omitted.
    The last param of the `windowed` function allows us to map each of the windows
    into another type. We are mapping each of sublists returned by the `windowed()`
    function into the `List<String>` type. There is also another version of the `windowed`
    function, without the last mapping parameter, so it can be treated as the optional
    one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is also a handy wrapper of the `windowed()` function provided, called
    `chunked()`. It doesn't require the step argument and sets it automatically to
    the window size value. It would be a good fit for this recipe's problem, however,
    the `windowed()` function was explained as it's more basic.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other functions available that solve different list and collection
    division scenarios, such as the `subList()` ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html))
    and `partition()` ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html))
    functions. You can find out more about them in official docs using the provided
    links.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transformation with map and flatMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The support for declarative data mapping operations is one of the basic and
    most powerful features in the functional data-processing domain. Often, when working
    with data, we need to transform a collection of a specific type into another type.
    It's also a common scenario to generate a list of objects from each element of
    a collection and to merge all of those new objects in a target collection together.
    Those are the use cases where the `map()` and `flatMap()` extension functions
    help.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to use both of them to implement a mapping data
    transformation. Let''s imagine we are working on the part of the system responsible
    for managing university department lectures. We are given the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a `getStudents(): List<Student>` function, which returns a list
    of all students from the database. We want to implement the `getLecturesOfCoursesWithSubscribedStudents()`
    function, which is going to to transform the `getStudents()` result to compute
    a list of lecturers whose courses are subscribed to by at least one student.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare a function header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the `flatMap` operation to the list of students:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Limit the collections'' elements to distinct values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Map the collection of the `Course` type elements to their corresponding `Lecturer`
    type properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following `flatMap` operation, the `getLecturesOfCoursesWithSubscribedStudents()`
    function is transforms the collection of the `Student` type objects into the collection
    of the `Course` type by merging elements of the `Student.courses: Collection<Course>`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As the result, the preceding code returns the `Collection<Course>` type. The
    collection returned by the `flatMap` operation contains a set of all the courses
    all of the students (obtained from the `getStudents()` function) are subscribed
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in order to remove duplicated courses, we append the chain of operations
    with the `distinct()` function. Then, we use the `map()` function. It is responsible
    for transforming every single element of the `Course` type into its corresponding
    `Lecturer` type from the `Course.lecturer` property. Finally, we are applying
    the `distinct()` function once again to return the list of lecturers with no duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map()` and `flatMap()` extension functions are also available for the `Map`
    data structure type. They are useful when it comes to converting a map to a list
    of objects transformed from the map's key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Folding and reducing data sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the `map()` operator takes a list of a given size and returns another
    list of the same size and of the modified type, the `fold()` and `reduce()` operations applied
    to the data set return a single element, composed of the consecutive elements
    of the data set. This may sound like a simple scenario for using a plain, imperative-style
    loop and local accumulator variable that holds a current state and is updated
    at each iteration. We can consider the simple task of summing up integer values.
    Let''s consider that we want to compute a sum of consecutive integers from `0`
    to `10`. We could achieve it using a simple `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is an alternative, functional way of performing such computations,
    using the `fold()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The second approach is desirable whenever we implement a chain of functional
    data-processing operations. Compared to the for loop, the `fold` function doesn't
    enforce consuming the collection elements explicitly and can be easily used together
    with other functional operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are going make use of the `fold` function when implementing
    the function responsible for processing the audio album tracks. Let''s assume
    we are given the following data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'and the sample `Album` class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We want to implement an extension function for the `Album` type that will return
    a relative start time for the `Track` given as an argument. For example, the start
    time of the `Growing Up Beside You` track should be 468 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare an extension function for the `Album` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute the start time for the given `Track` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a safety check for the `track` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the very beginning, our function does a safety check for the `track` argument
    passed to it to verify whether it belongs to the current `Album` instance. If
    the given track is not found within the `Album.tracks` collection, the `IllegalArgumentException`
    exception is thrown.  Next, we create a sublist from the `tracks` property elements
    containing only the elements from the `0` index to the index of the `track` passed
    as the function parameter. This sublist is created using the `take()` operator.
    Then, we map each of the `Track` type elements to the `Int` type corresponding
    to the duration of the track. Finally, we apply the `fold` function, to sum the `durationInSeconds` property
    values of the consecutive `Track` elements. The `fold` function takes the `initial`
    argument responsible for initializing the internal `accumulator` variable holding
    the current state of the folding result.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we pass 0 as the `initial` value, which corresponds to the album
    start time. In the second argument passed to the `fold` function, we are defining
    how the `accumulator` should be updated with each of the consecutive `durationInSeconds`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the `Album.getStartTime()` function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library provides a similar function, named `reduce()`*, *which
    does the same operation as `fold`. The difference between the two is that `fold`takes
    an explicit initial value, whereas `reduce` uses the first element from the list
    as the initial value.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin standard library provides built-in support for the dataset *group
    by* operation. In this recipe, we are going to explore how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we are working with the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a `getStudents(): List<Student>` function that returns a list
    of all the students from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the `getStudents(): List<Student>` function, we are going to implement
    the `getCoursesWithSubscribedStudents(): Map<Course, List<Student>>` function
    responsible for extracting the map of all the courses students are subscribed
    to, and the list of students subscribed to each of the courses.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare a function header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Map each of the students to the list of the course-student pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Group the course-student pairs by `Course`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply a mapping transformation to the `Pair<Course, List<Student>>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply a `toMap()` function at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by transforming the list of students to list of the `Pair<Course,
    Student>` type with the `flatMap()` function. Next, we apply the `groupBy()` function
    to group those pairs by a distinct `Course` instance. As the result of the grouping
    operation, we receive data of the following type—`Map.Entry<Course, List<Pair<Course,
    Student>>>`. We need to convert the `Map.Entry.value` property type to the `List<Student>`
    type. We achieve it with the following mapping transforming function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As a result, each `Course` instance is associated with a list of students subscribed
    to it (`Pair<Course, List<Student>>`). Note that the infix `to` function is being
    used to instantiate the Pair type. Finally, we invoke the `toMap()` function,
    which produces the final `Map<Course, List<Students>>` instance from the list
    of course-student pairs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also modify our map building operation to a more concise form by using
    the `mapValues` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this recipe uses destructuring types declarations in mapping operations.
    If you'd like to learn more about this, you can take a look at the *Destructuring
    types *recipe from [Chapter 2](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml), *Expressive
    Functions and Adjustable Interfaces*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
