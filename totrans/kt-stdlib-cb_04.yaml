- en: Powerful Data Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的数据处理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Composing and consuming collections the easy way
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单地组合和消费集合
- en: Filtering datasets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤数据集
- en: Automatic `null` removal
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动移除`null`
- en: Sorting data with custom comparators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义比较器排序数据
- en: Building strings based on dataset elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据数据集元素构建字符串
- en: Dividing data into subsets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据划分为子集
- en: Transforming data with  `map` and `flatMap`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`map`和`flatMap`转换数据
- en: Folding and reducing datasets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集折叠和缩减
- en: Grouping data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分组
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter focuses on exploring standard library support for declarative-style
    operations on collections. The following recipes present solutions to different
    types of programming problems related to dataset transformations, reductions,
    and grouping. We will learn how to approach data processing operations with a
    functional programming style, together with the powerful data-processing extensions
    built into the standard library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍标准库对声明式操作集合的支持。以下菜谱展示了针对数据集转换、缩减和分组的不同类型编程问题的解决方案。我们将学习如何以函数式编程风格处理数据处理操作，以及标准库中内置的强大数据处理扩展。
- en: Composing and consuming collections the easy way
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单地组合和消费集合
- en: 'The Kotlin standard library provides a number of handy extensions that make
    collections creation and merging easy and safe. We are going to learn them step
    by step. Let''s assume we have the following `Message` class defined:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库提供了一些方便的扩展，使得集合创建和合并变得简单且安全。我们将逐步学习它们。假设我们定义了以下`Message`类：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this recipe, we are going to create two sample collections containing `Message`
    instances and merge them into one list of `Message` objects. Next, we are going
    to iterate through the list of messages and print their text to the console.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建两个包含`Message`实例的样本集合，并将它们合并成一个`Message`对象的列表。接下来，我们将遍历消息列表，并将它们的文本打印到控制台。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Kotlin standard library provides two basic interfaces which represent collection
    data structure—`Collection` and `MutableCollection`, both extending the `Iterable`
    interface. The first one defines an immutable collection that only supports read
    access to its elements. The second interface allows us to both add and remove
    elements. There are also more specialized interfaces that extend the `Collection`
    and `MutableCollection` base types, such as `List`, `MutableList`, `Set`, and
    `MutableSet`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库提供了两个基本接口，用于表示集合数据结构——`Collection`和`MutableCollection`，两者都扩展了`Iterable`接口。第一个接口定义了一个不可变集合，它只支持对其元素的读取访问。第二个接口允许我们添加和删除元素。还有更多专门化的接口扩展了`Collection`和`MutableCollection`基本类型，例如`List`、`MutableList`、`Set`和`MutableSet`。
- en: 'There are many functions available for creating collections of different types.
    The most commonly used ones are the `<T> listOf(vararg elements: T)` function,
    which instantiates a `List` instance, and `<T> mutableListOf(vararg elements:
    T)`, which returns an instance of `MutableList` for the elements given as a function''s
    arguments.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '有许多函数可用于创建不同类型的集合。最常用的函数是`<T> listOf(vararg elements: T)`，它实例化一个`List`实例，以及`<T>
    mutableListOf(vararg elements: T)`，它返回一个`MutableList`实例，作为函数参数给出的元素。'
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s declare two lists containing sample data:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明两个包含样本数据的列表：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Merge `sentMessages` and `inboxMessages` into one collection:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sentMessages`和`inboxMessages`合并到一个集合中：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Print out the text of the `Message` objects stored in the `allMessages` list
    to the console:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储在`allMessages`列表中的`Message`对象的文本打印到控制台：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As the result, our code is going to print the following text to the console:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的代码将打印以下文本到控制台：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to add elements of one collection to another, we are using the `+`
    operator. The standard library overloads this operator with the code responsible
    for merging elements of two `Collection` type instances collections into one instance.
    The `sentMessages` and `inboxMessages` variables are declared as `List` instances.
    The `plus` function returns a new `Collection` instance, containing elements of
    the `sentMessages` and `inboxMessages` lists. Finally, we use the `forEach()`
    function to iterate through the next elements of the list. In the lambda block
    passed to the `forEach` function, we are print the `text` property of the current
    `Message` to the console. We are destructuring the lambda's argument of the `Message`
    type and accessing its text property directly inside the `println()` function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一个集合的元素添加到另一个集合中，我们使用了 `+` 操作符。标准库通过合并两个 `Collection` 类型实例集合的元素到单个实例的代码来重载此操作符。`sentMessages`
    和 `inboxMessages` 变量被声明为 `List` 实例。`plus` 函数返回一个新的 `Collection` 实例，包含 `sentMessages`
    和 `inboxMessages` 列表中的元素。最后，我们使用 `forEach()` 函数遍历列表的下一个元素。在传递给 `forEach` 函数的 lambda
    块中，我们将当前 `Message` 的 `text` 属性打印到控制台。我们在 `println()` 函数内部直接访问 lambda 的 `Message`
    类型参数的文本属性。
- en: There's more...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The standard library also overloads a `-` operator for the Collection type.
    We could use it to subtract some elements from the collection. For example, we
    could use it like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库还为 `Collection` 类型重载了 `-` 操作符。我们可以用它从集合中减去一些元素。例如，我们可以这样使用它：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And we would get the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We could also use the standard `for` loop to implement the iteration:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用标准的 `for` 循环来实现迭代：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: You can learn more about destructuring declarations in the *Destructuring types*
    recipe in [Chapter 2](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml), *Expressive
    Functions and Adjustable Interfaces*
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在第 2 章 *Expressive Functions and Adjustable Interfaces* 中的 *Destructuring
    types* 菜单中了解更多关于解构声明的信息，[第 2 章](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml)。
- en: If you'd like to master lambda expressions, you can take a look at the *Working
    effectively with lambdas and closures *recipe from [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml), *Shaping
    Code with Kotlin Functional Programming Features*
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想掌握 lambda 表达式，可以查看第 3 章 *Working effectively with lambdas and closures*
    中的 *Shaping Code with Kotlin Functional Programming Features* 菜单，[第 3 章](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml)。
- en: Filtering datasets
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤数据集
- en: 'Filtering is one of the most common programming challenges in the data processing
    field. In this recipe, we are going to explore the standard library''s built-in
    extension functions that provide an easy way to filter the `Iterable` data types.
    Let''s assume we have the following `Message` class declaration:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是数据处理领域中最常见的编程挑战之一。在本菜谱中，我们将探索标准库的内置扩展函数，这些函数提供了一种简单的方式来过滤 `Iterable` 数据类型。假设我们有一个以下
    `Message` 类声明：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `getMessages()` function returns the following data:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`getMessages()` 函数返回以下数据：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are going to apply a filtering operation to the `getMessages()` function
    that will return only the messages with the `Folder.INBOX` property and with the
    `sender` property equal to `Agat`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对 `getMessages()` 函数应用一个过滤操作，只返回具有 `Folder.INBOX` 属性和 `sender` 属性等于 `Agat`
    的消息。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To implement the filtering transformation, we are going to use the `Iterable<T>.filter(predicate:
    (T) -> Boolean)` extension function provided by the standard library. The `filter()`
    function takes a predicate function that returns `true` or `false` values for
    the given element of the generic `Iterable` dataset type `T`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '为了实现过滤转换，我们将使用标准库提供的 `Iterable<T>.filter(predicate: (T) -> Boolean)` 扩展函数。`filter()`
    函数接受一个返回 `true` 或 `false` 值的谓词函数，用于给定泛型 `Iterable` 数据集类型 `T` 的元素。'
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Apply filtering to the `getMessages()` function:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `getMessages()` 函数应用过滤：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Iterate through the filtered messages and print their messages to the console:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历过滤后的消息并将它们的消息打印到控制台：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We are applying the `filter` function to the results of the `ge``tMessages()`
    function. We pass a lambda block to the `filter` function, which returns a Boolean
    for each of the list's elements. The `filter` function returns a list containing
    filtered objects. Finally, we use the `forEach()` function to iterate through
    the next elements of the list. In the lambda block passed to the `forEach` function,
    we print the `text` property of the current `Message` to the console.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将 `filter` 函数应用于 `ge``tMessages()` 函数的结果。我们将一个 lambda 块传递给 `filter` 函数，该函数为列表的每个元素返回一个布尔值。`filter`
    函数返回一个包含过滤对象的列表。最后，我们使用 `forEach()` 函数遍历列表的下一个元素。在传递给 `forEach` 函数的 lambda 块中，我们将当前
    `Message` 的 `text` 属性打印到控制台。
- en: 'As a result, the code from the preceding section is going to print the following
    output to the console:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，上一节中的代码将在控制台打印以下输出：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Kotlin standard library offers corresponding `filter()` extension functions
    for other types, such as `Array`, `Sequence`, and `Map`. There are also many variations
    of the filter function that can be useful for specific scenarios. You can find
    all of them in the official documentation of the Kotlin standard library `kotlin.collections`
    package at [http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections](http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 标准库为其他类型提供了相应的 `filter()` 扩展函数，例如 `Array`、`Sequence` 和 `Map`。还有许多过滤函数的变体，这些变体可以用于特定场景。您可以在
    Kotlin 标准库 `kotlin.collections` 包的官方文档中找到它们，网址为 [http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections](http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html)。
- en: See also
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to master lambda expressions, you can take a look at the *Working
    effectively with lambdas and closures* recipe from [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml), *Shaping
    Code with Kotlin Functional Programming Features*
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想掌握 lambda 表达式，你可以查看第 3 章 *有效地使用 lambda 和闭包* 菜谱，来自 *使用 Kotlin 函数式编程特性塑造代码*。
- en: Automatic null removal
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动移除空值
- en: 'While working with poorly designed APIs of servers or external libraries, we
    often need to deal with receiving null return values. Thankfully, there are a
    number of standard library features that allow us to handle null values effectively.
    In this recipe, we are going to implement a data preprocessing operation which
    will remove all the nulls from the dataset automatically. Let''s say we are working
    with an external API that provides us with the latest news feed. Unfortunately,
    it''s not null-safe and can return random null values. For example, let''s assume
    we have a `getNews(): List<News>` function that returns the following data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '当与服务器或外部库的糟糕设计 API 一起工作时，我们经常需要处理接收空返回值的情况。幸运的是，有一些标准库特性允许我们有效地处理空值。在本菜谱中，我们将实现一个数据预处理操作，该操作将自动从数据集中移除所有空值。假设我们正在与一个提供最新新闻源的外部
    API 一起工作。不幸的是，它不是空安全的，可能会返回随机的空值。例如，让我们假设我们有一个 `getNews(): List<News>` 函数，它返回以下数据：'
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `News` class is defined as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`News` 类定义如下：'
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Apply the `filterNotNull` function to the `getNews()` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `filterNotNull` 函数应用于 `getNews()` 函数：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As a result, we are going to get the following output printed to the console:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将得到以下输出打印到控制台：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In contrast, the code without the `filterNotNull()` function is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，没有 `filterNotNull()` 函数的代码如下：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will print the following output to the console:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台打印以下输出：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Iterable.filterNotNull()` extension function removes all the null values
    from the original dataset. Under the hood, it copies non-null values to a newly
    created `List` instance. That's why it is more efficient to use sequences instead
    of collections in order to provide lazy evaluation for large datasets.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable.filterNotNull()` 扩展函数从原始数据集中移除所有空值。在底层，它将非空值复制到新创建的 `List` 实例中。这就是为什么在处理大型数据集时，使用序列而不是集合以提供延迟求值更有效的原因。'
- en: See also
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In the *Filtering data sets* recipe*, *we explored how to use the basic `filter()`
    function form provided by the standard library
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *过滤数据集* 菜谱中，我们探讨了如何使用标准库提供的基本 `filter()` 函数
- en: If you'd like to master lambda expressions, you can take a look at the *Working
    effectively with lambdas and closures* recipe from [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml), *Shaping
    Code with Kotlin Functional Programming Features*
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想掌握lambda表达式，你可以查看第3章的*有效使用lambda和闭包*菜谱，*使用Kotlin函数式编程特性塑造代码*。
- en: Sorting data with custom comparators
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义比较器进行数据排序
- en: In this recipe, we are going to explore the support for sorting collections'
    elements by their properties.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索按集合元素属性对集合元素进行排序的支持。
- en: Getting started
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'Let''s assume we are dealing with the two collections of the `Message` type
    declared as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理以下声明的两个`Message`类型集合：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These are provided by the `allMessages` variable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些由`allMessages`变量提供：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we print the text of consecutive messages from the `allMessages` list, we
    get the following text printed to the console:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印出`allMessages`列表中连续消息的文本，我们将在控制台得到以下文本输出：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That doesn't look right. The messages should be displayed in chronological order.
    That means they should be sorted by the `time` property.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不太对。消息应该按时间顺序显示。这意味着它们应该按`time`属性排序。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Apply the `sortedBy` function to the `allMessages` collection:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sortedBy`函数应用于`allMessages`集合：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Print the sorted elements to the console:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将排序后的元素打印到控制台：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If we run the preceding code, we get the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们得到以下输出：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, all the messages are sorted properly and the conversation makes sense.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有消息都已正确排序，对话也变得有意义。
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If our collection consisted of objects that implement the Comparable interface,
    we would be able to sort it simply by applying a `sorted()` function to it. The
    Kotlin standard library also provides more specialized versions of the `sortedBy()`
    function, such as `sortedByDescending()` and `sortedWith()`. The first one works
    as a base-sorting function, but it returns the dataset sorted with the opposite
    order. The `sortedWith()` function allows us to sort the list with a custom comparator.
    For example, to sort a collection of the `Message` type elements first by `sender` and
    next by the `time` property, we could write the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的集合由实现Comparable接口的对象组成，我们就可以通过对其应用`sorted()`函数来简单地对其进行排序。Kotlin标准库还提供了`sortedBy()`函数的更多专用版本，例如`sortedByDescending()`和`sortedWith()`。第一个是一个基础排序函数，但它返回按相反顺序排序的数据集。`sortedWith()`函数允许我们使用自定义比较器对列表进行排序。例如，为了按`sender`属性首先排序，然后按`time`属性排序`Message`类型元素的集合，我们可以编写以下代码：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Building strings based on dataset elements
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于数据集元素构建字符串
- en: 'Sometimes, we face the problem of generating text based on collections'' elements.
    This is where the `Iterable.joinToString()` extension function can help. For example,
    we can consider working on an email-message-forwarding feature. When a user clicks
    the forward button, the original message''s body text is concatenated, with the
    prefix looking something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们会遇到根据集合元素生成文本的问题。这就是`Iterable.joinToString()`扩展函数能帮到的地方。例如，我们可以考虑实现一个电子邮件转发功能。当用户点击转发按钮时，原始消息的正文文本被连接起来，前缀看起来像这样：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this recipe, we are going to implement a function that is going to generate
    the recipients'' string, for example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个函数，该函数将生成收件人的字符串，例如：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For a given list of `Address` type objects, it is defined as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的`Address`类型对象列表，它定义如下：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Declare the `generateRecipientsString()` function header:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`generateRecipientsString()`函数头：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Start by removing all the `null` items from the `recipient` parameter:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先从`recipient`参数中移除所有`null`项：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Transform collection elements of the `Address` type to the `String` type elements
    corresponding to the `Address.emailAddress` property:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Address`类型的集合元素转换为与`Address.emailAddress`属性对应的`String`类型元素：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Apply the `joinToString()` function in order to merge collection elements into
    the string:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将集合元素合并成字符串，应用`joinToString()`函数：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `generateRecipientsString()` function uses the `Iterable.joinToString()`
    extension function from the standard library `kotlin.collections` package to generate
    the output string. The `joinToString()` function takes three parameters—the separator
    character, which is used to concatenate the next substrings, the prefix, and the
    suffix strings. It is invoked on a collection of String values. We are also applying
    the preprocessing operations that are responsible for removing the `null` values
    from the list of the `Address` objects and mapping the `Address` type to the `String` corresponding
    to the `Address.emailAddress` property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateRecipientsString()`函数使用标准库`kotlin.collections`包中的`Iterable.joinToString()`扩展函数来生成输出字符串。`joinToString()`函数接受三个参数——分隔符字符，用于连接下一个子字符串，前缀和后缀字符串。它在一个字符串值的集合上调用。我们还应用了预处理操作，负责从`Address`对象的列表中删除`null`值并将`Address`类型映射到与`Address.emailAddress`属性对应的`String`。'
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We could also use another version of the `joinToString()` function to simplify
    the logic of our `generateRecipientsString()` function implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`joinToString()`函数的另一个版本来简化`generateRecipientsString()`函数实现中的逻辑：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, it takes the additional argument in the form of an inlined lambda
    block, which acts as a transformation function that is being applied to each of
    the `recipients` collection elements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它采用额外的形式为内联lambda块的形式的参数，该参数充当应用于每个`recipients`集合元素的转换函数。
- en: See also
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To explore dataset mapping operations in more depth, you can read the *Data
    transformation with the map and flatMap* recipe
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解数据集映射操作，您可以阅读*使用map和flatMap进行数据转换*菜谱
- en: Dividing data into subsets
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据划分为子集
- en: 'A common data-processing task is to divide a collection of data into subsets. In
    this recipe, we are going to explore standard library functions that allow us
    to buffer a collection into smaller chunks. Let''s say we have a list containing
    a large number of `Message` type objects and we would like to transform it into
    collections of sub-lists of a constant size. For example, the transformation would
    take the original collection of *n* elements:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的数据处理任务是将数据集合划分为子集。在这个菜谱中，我们将探索标准库函数，这些函数允许我们将集合缓冲到更小的块中。假设我们有一个包含大量`Message`类型对象的列表，我们希望将其转换成固定大小的子列表集合。例如，转换将原始集合的*n*个元素：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And it would then split it into a collection of four element subsets:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其分割成包含四个元素子集的集合：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start by declaring the `Message` class that we are going to use in the
    following recipe:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先声明一个`Message`类，我们将在下面的菜谱中使用它：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s declare the `messages` variable that stores the sample data:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个存储样本数据的`messages`变量：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Apply the `windowed()` function to the `messages` list:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`windowed()`函数应用于`messages`列表：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a `transform: (List<T>) -> R` transformation function as an additional,
    inline parameter to the windowed function:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将一个`transform: (List<T>) -> R`转换函数作为额外的内联参数添加到`windowed`函数中：'
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `windowed` function splits the original list of messages into sublists
    of a specified size. As a result, we get the `List<List<Message>>` type assigned
    to the `pagedMessages` handle. We could print the next message subsets with the
    following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`windowed`函数将原始消息列表分割成指定大小的子列表。结果，我们得到`List<List<Message>>`类型分配给`pagedMessages`处理。我们可以使用以下代码打印下一个消息子集：'
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As the result, we get the following output printed to the console:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到以下输出打印到控制台：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `windowed` function takes four parameters—the size of the window, a flag
    saying whether partial windows should be created, a step value, and an optional
    transforming function that is responsible for converting each of the generated
    windows. In our scenario, we are using a window size equal to `4`. This is why
    we need to specify the step value as equal to `4` as well because we want to have
    consecutive `Message` instances stored in the next windows. We also set the `partialWindows` argument
    to `true`, otherwise, the last window containing a single message would be omitted.
    The last param of the `windowed` function allows us to map each of the windows
    into another type. We are mapping each of sublists returned by the `windowed()`
    function into the `List<String>` type. There is also another version of the `windowed`
    function, without the last mapping parameter, so it can be treated as the optional
    one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`windowed`函数接受四个参数——窗口大小、一个标志表示是否应创建部分窗口、一个步长值以及一个可选的转换函数，该函数负责转换生成的每个窗口。在我们的场景中，我们使用窗口大小等于`4`。这就是为什么我们需要将步长值也指定为`4`，因为我们希望将连续的`Message`实例存储在下一个窗口中。我们还设置了`partialWindows`参数为`true`，否则包含单个消息的最后一个窗口将被省略。`windowed`函数的最后一个参数允许我们将每个窗口映射到另一个类型。我们将`windowed()`函数返回的每个子列表映射到`List<String>`类型。还有一个`windowed`函数的另一个版本，没有最后一个映射参数，因此它可以被视为可选的。'
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is also a handy wrapper of the `windowed()` function provided, called
    `chunked()`. It doesn't require the step argument and sets it automatically to
    the window size value. It would be a good fit for this recipe's problem, however,
    the `windowed()` function was explained as it's more basic.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了一个`windowed()`函数的便捷包装器，称为`chunked()`。它不需要步长参数，并自动将其设置为窗口大小值。它非常适合这个问题的解决方案，然而，`windowed()`函数被解释为更基础的。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: There are other functions available that solve different list and collection
    division scenarios, such as the `subList()` ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html))
    and `partition()` ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html))
    functions. You can find out more about them in official docs using the provided
    links.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一些其他函数可供使用，用于解决不同的列表和集合划分场景，例如`subList()`函数（[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html)）和`partition()`函数（[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html)）。您可以通过提供的链接在官方文档中了解更多关于它们的信息。
- en: Data transformation with map and flatMap
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用map和flatMap进行数据转换
- en: The support for declarative data mapping operations is one of the basic and
    most powerful features in the functional data-processing domain. Often, when working
    with data, we need to transform a collection of a specific type into another type.
    It's also a common scenario to generate a list of objects from each element of
    a collection and to merge all of those new objects in a target collection together.
    Those are the use cases where the `map()` and `flatMap()` extension functions
    help.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对声明式数据映射操作的支持是函数式数据处理领域的基本且最强大的功能之一。通常，当处理数据时，我们需要将特定类型的集合转换成另一种类型。从集合的每个元素生成对象并将所有这些新对象合并到目标集合中也是一个常见的场景。这些就是`map()`和`flatMap`扩展函数能够帮助的场景。
- en: 'In this recipe, we are going to use both of them to implement a mapping data
    transformation. Let''s imagine we are working on the part of the system responsible
    for managing university department lectures. We are given the following types:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用这两个函数来实现映射数据转换。让我们想象我们正在处理负责管理大学系讲座的系统的一部分。我们得到了以下类型：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also have a `getStudents(): List<Student>` function, which returns a list
    of all students from the database. We want to implement the `getLecturesOfCoursesWithSubscribedStudents()`
    function, which is going to to transform the `getStudents()` result to compute
    a list of lecturers whose courses are subscribed to by at least one student.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还有一个`getStudents(): List<Student>`函数，它从数据库中返回所有学生的列表。我们想要实现`getLecturesOfCoursesWithSubscribedStudents()`函数，该函数将`getStudents()`的结果转换成计算一个列表，其中包含至少有一名学生订阅的课程讲师。'
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Declare a function header:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个函数头：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Apply the `flatMap` operation to the list of students:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对学生列表应用`flatMap`操作：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Limit the collections'' elements to distinct values:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制集合元素的值为唯一值：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Map the collection of the `Course` type elements to their corresponding `Lecturer`
    type properties:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Course`类型元素的集合映射到它们对应的`Lecturer`类型属性：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'With the following `flatMap` operation, the `getLecturesOfCoursesWithSubscribedStudents()`
    function is transforms the collection of the `Student` type objects into the collection
    of the `Course` type by merging elements of the `Student.courses: Collection<Course>`
    property:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '以下`flatMap`操作将`getLecturesOfCoursesWithSubscribedStudents()`函数将`Student`类型对象的集合转换为`Course`类型对象的集合，通过合并`Student.courses:
    Collection<Course>`属性中的元素：'
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As the result, the preceding code returns the `Collection<Course>` type. The
    collection returned by the `flatMap` operation contains a set of all the courses
    all of the students (obtained from the `getStudents()` function) are subscribed
    to.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，前面的代码返回了`Collection<Course>`类型。`flatMap`操作返回的集合包含所有学生（从`getStudents()`函数获取）订阅的所有课程的集合。
- en: Next, in order to remove duplicated courses, we append the chain of operations
    with the `distinct()` function. Then, we use the `map()` function. It is responsible
    for transforming every single element of the `Course` type into its corresponding
    `Lecturer` type from the `Course.lecturer` property. Finally, we are applying
    the `distinct()` function once again to return the list of lecturers with no duplicates.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了去除重复的课程，我们使用`distinct()`函数来追加操作链。然后，我们使用`map()`函数。它负责将`Course`类型的每个元素转换为从`Course.lecturer`属性对应的`Lecturer`类型。最后，我们再次应用`distinct()`函数，以返回没有重复的讲师列表。
- en: There's more...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `map()` and `flatMap()` extension functions are also available for the `Map`
    data structure type. They are useful when it comes to converting a map to a list
    of objects transformed from the map's key-value pairs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`和`flatMap()`扩展函数也适用于`Map`数据结构类型。当需要将映射转换为从映射的键值对转换的对象列表时，它们非常有用。'
- en: Folding and reducing data sets
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据集的折叠和归约
- en: 'While the `map()` operator takes a list of a given size and returns another
    list of the same size and of the modified type, the `fold()` and `reduce()` operations applied
    to the data set return a single element, composed of the consecutive elements
    of the data set. This may sound like a simple scenario for using a plain, imperative-style
    loop and local accumulator variable that holds a current state and is updated
    at each iteration. We can consider the simple task of summing up integer values.
    Let''s consider that we want to compute a sum of consecutive integers from `0`
    to `10`. We could achieve it using a simple `for` loop:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`map()`操作符接受给定大小的列表并返回另一个大小相同且类型修改后的列表，但应用于数据集的`fold()`和`reduce()`操作返回一个单一元素，由数据集的连续元素组成。这听起来可能像使用简单的命令式循环和局部累加变量（它持有当前状态并在每次迭代中更新）的简单场景。我们可以考虑一个简单的任务，即求整数值的总和。假设我们想要计算从`0`到`10`的连续整数的总和。我们可以使用一个简单的`for`循环来实现它：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'However, there is an alternative, functional way of performing such computations,
    using the `fold()` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种替代的函数式方法可以执行这样的计算，使用`fold()`函数：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The second approach is desirable whenever we implement a chain of functional
    data-processing operations. Compared to the for loop, the `fold` function doesn't
    enforce consuming the collection elements explicitly and can be easily used together
    with other functional operators.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现一系列函数式数据处理操作时，第二种方法更可取。与for循环相比，`fold`函数不强制显式消费集合元素，并且可以很容易地与其他函数式操作符一起使用。
- en: 'In this recipe, we are going make use of the `fold` function when implementing
    the function responsible for processing the audio album tracks. Let''s assume
    we are given the following data types:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`fold`函数来实现处理音频专辑曲目时负责的函数。假设我们给出了以下数据类型：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'and the sample `Album` class instance:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以及示例`Album`类实例：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We want to implement an extension function for the `Album` type that will return
    a relative start time for the `Track` given as an argument. For example, the start
    time of the `Growing Up Beside You` track should be 468 seconds.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要实现一个针对`Album`类型的扩展函数，该函数将为作为参数给出的`Track`返回一个相对起始时间。例如，`Growing Up Beside
    You`这首曲子的起始时间应该是468秒。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare an extension function for the `Album` class:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个针对`Album`类的扩展函数：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Compute the start time for the given `Track` argument:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算给定`Track`参数的起始时间：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add a safety check for the `track` argument:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`track`参数添加一个安全检查：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At the very beginning, our function does a safety check for the `track` argument
    passed to it to verify whether it belongs to the current `Album` instance. If
    the given track is not found within the `Album.tracks` collection, the `IllegalArgumentException`
    exception is thrown.  Next, we create a sublist from the `tracks` property elements
    containing only the elements from the `0` index to the index of the `track` passed
    as the function parameter. This sublist is created using the `take()` operator.
    Then, we map each of the `Track` type elements to the `Int` type corresponding
    to the duration of the track. Finally, we apply the `fold` function, to sum the `durationInSeconds` property
    values of the consecutive `Track` elements. The `fold` function takes the `initial`
    argument responsible for initializing the internal `accumulator` variable holding
    the current state of the folding result.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，我们的函数对传入的`track`参数进行安全检查，以验证它是否属于当前的`Album`实例。如果给定的曲目在`Album.tracks`集合中未找到，则抛出`IllegalArgumentException`异常。接下来，我们创建一个子列表，只包含`tracks`属性元素中的从`0`索引到作为函数参数传递的`track`索引的元素。这个子列表是通过使用`take()`操作符创建的。然后，我们将每个`Track`类型的元素映射到对应的`Int`类型，即曲目的持续时间。最后，我们应用`fold`函数，以累加连续`Track`元素的`durationInSeconds`属性值。`fold`函数接受一个`initial`参数，该参数负责初始化内部`accumulator`变量，该变量持有折叠结果的当前状态。
- en: In our case, we pass 0 as the `initial` value, which corresponds to the album
    start time. In the second argument passed to the `fold` function, we are defining
    how the `accumulator` should be updated with each of the consecutive `durationInSeconds`
    values.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将0作为`initial`值传递，这对应于专辑的起始时间。在传递给`fold`函数的第二个参数中，我们定义了如何使用每个连续的`durationInSeconds`值更新`accumulator`。
- en: 'Let''s test the `Album.getStartTime()` function in action:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下`Album.getStartTime()`函数的实际效果：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code returns the following output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回以下输出：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There's more...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The standard library provides a similar function, named `reduce()`*, *which
    does the same operation as `fold`. The difference between the two is that `fold`takes
    an explicit initial value, whereas `reduce` uses the first element from the list
    as the initial value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一个名为`reduce()`的类似函数，它执行与`fold`相同的操作。这两个函数之间的区别在于`fold`需要一个显式的初始值，而`reduce`则使用列表中的第一个元素作为初始值。
- en: Grouping data
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分组
- en: The Kotlin standard library provides built-in support for the dataset *group
    by* operation. In this recipe, we are going to explore how to use it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库为数据集*按组分组*操作提供了内置支持。在本菜谱中，我们将探讨如何使用它。
- en: 'Let''s assume we are working with the following types:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理以下类型：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We also have a `getStudents(): List<Student>` function that returns a list
    of all the students from the database.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还有一个`getStudents(): List<Student>`函数，它返回数据库中所有学生的列表。'
- en: 'Given the `getStudents(): List<Student>` function, we are going to implement
    the `getCoursesWithSubscribedStudents(): Map<Course, List<Student>>` function
    responsible for extracting the map of all the courses students are subscribed
    to, and the list of students subscribed to each of the courses.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '给定`getStudents(): List<Student>`函数，我们将实现`getCoursesWithSubscribedStudents():
    Map<Course, List<Student>>`函数，该函数负责提取所有学生订阅的课程映射以及每个课程订阅的学生列表。'
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare a function header:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个函数头：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Map each of the students to the list of the course-student pairs:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个学生映射到课程-学生配对的列表：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Group the course-student pairs by `Course`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照课程对课程-学生配对进行分组：
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Apply a mapping transformation to the `Pair<Course, List<Student>>` type:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`Pair<Course, List<Student>>`类型应用映射转换：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Apply a `toMap()` function at the end:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后应用一个`toMap()`函数：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by transforming the list of students to list of the `Pair<Course,
    Student>` type with the `flatMap()` function. Next, we apply the `groupBy()` function
    to group those pairs by a distinct `Course` instance. As the result of the grouping
    operation, we receive data of the following type—`Map.Entry<Course, List<Pair<Course,
    Student>>>`. We need to convert the `Map.Entry.value` property type to the `List<Student>`
    type. We achieve it with the following mapping transforming function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `flatMap()` 函数将学生列表转换为 `Pair<Course, Student>` 类型的列表。接下来，我们应用 `groupBy()`
    函数将这些配对按不同的 `Course` 实例进行分组。分组操作的结果是以下类型的数据——`Map.Entry<Course, List<Pair<Course,
    Student>>>`。我们需要将 `Map.Entry.value` 属性的类型转换为 `List<Student>` 类型。我们通过以下映射转换函数实现它：
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As a result, each `Course` instance is associated with a list of students subscribed
    to it (`Pair<Course, List<Student>>`). Note that the infix `to` function is being
    used to instantiate the Pair type. Finally, we invoke the `toMap()` function,
    which produces the final `Map<Course, List<Students>>` instance from the list
    of course-student pairs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个 `Course` 实例都与订阅它的学生列表相关联（`Pair<Course, List<Student>>`）。请注意，这里使用了中缀 `to`
    函数来实例化 Pair 类型。最后，我们调用 `toMap()` 函数，它从课程-学生配对列表生成最终的 `Map<Course, List<Students>>`
    实例。
- en: There's more...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can also modify our map building operation to a more concise form by using
    the `mapValues` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `mapValues` 函数将我们的映射构建操作修改为更简洁的形式：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: See also
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The code in this recipe uses destructuring types declarations in mapping operations.
    If you'd like to learn more about this, you can take a look at the *Destructuring
    types *recipe from [Chapter 2](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml), *Expressive
    Functions and Adjustable Interfaces*.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本食谱中的代码在映射操作中使用了解构类型声明。如果您想了解更多关于这个话题的信息，可以查看第 2 章中的 *Destructuring types* 食谱，*Expressive
    Functions and Adjustable Interfaces*。
