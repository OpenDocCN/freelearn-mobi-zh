<html><head></head><body>
		<div><h1 id="_idParaDest-42"><em class="italic"><a id="_idTextAnchor078"/>Chapter 3</em>: Test-Driven Development in Xcode</h1>
			<p>For <strong class="bold">test-driven development </strong>(<strong class="bold">TDD</strong>), we<a id="_idIndexMarker044"/> need a way to write and execute unit tests. We could write the tests into the main target of our Xcode project but that would be impractical. We would have to separate the test code from the production code somehow, and we would have to write some scripts that execute the text code and gather feedback about the results of the tests.</p>
			<p>Fortunately, this has already been done. It all started in 1998, when the Swiss company Sen:te developed OCUnit, a testing framework for Objective-C (hence the OC prefix). OCUnit was a port of SUnit, a testing framework that Kent Beck had written for Smalltalk in 1994.</p>
			<p>With Xcode 2.1, Apple added OCUnit to Xcode. One reason for this step was that they used it to develop Core Data at the same time that they developed Tiger, the OS with which Core Data was shipped. Bill Bumgarner, an Apple engineer, wrote this later in a blog post:</p>
			<p class="author-quote">"Core Data 1.0 is not perfect, but it is a rock solid product that I'm damned proud of. The quality and performance achieved could not have been done without the use of unit testing. Furthermore, we were able to perform highly disruptive operations to the codebase very late in the development cycle. The end result was a vast increase in performance, a much cleaner codebase, and rock solid release."</p>
			<p>Apple realized how valuable unit tests can be when developing complex systems in a changing environment. They wanted third-party developers to benefit from unit tests as well. OCUnit could be (and has been) added to Xcode by hand before version 2.1. But by including it in the <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>), the investment in time that was needed to start unit testing was reduced a lot, and as a result, more people started to write tests.</p>
			<p>In 2008, OCUnit was integrated into the iPhone SDK 2.2 to allow unit testing of iPhone apps.</p>
			<p>Finally, in 2013, unit testing became a first-class citizen in Xcode 5 with the introduction of XCTest. With XCTest, Apple added specific user interface elements to Xcode that helped with testing, which allowed running specific tests, finding failing tests quickly, and getting an overview of all the tests. We will go over the testing user interface in Xcode later in this chapter. But, first, we will take a look at TDD using Xcode in action. This chapter sets the foundation we need to start building our first app using TDD.</p>
			<p>These are the main sections we will cover in this chapter:</p>
			<ul>
				<li>An example of TDD</li>
				<li>Finding information about tests in Xcode</li>
				<li>Running tests</li>
				<li>Setting up and tearing down</li>
				<li>Debugging tests</li>
			</ul>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor079"/>Technical requirements</h1>
			<p>All the code in this chapter is uploaded (in complete form) here:</p>
			<p><a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter03">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter03</a></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor080"/>An example of TDD</h1>
			<p>For this TDD<a id="_idIndexMarker045"/> example, we are going to use the same project we created in <a href="B18127_01_ePub.xhtml#_idTextAnchor018"><em class="italic">Chapter 1</em></a>, <em class="italic">Your First Unit Tests</em>. Open the FirstDemo project in Xcode, and run the tests by hitting <em class="italic">⌘</em><em class="italic">U</em>. The test we wrote to explore the custom assert function is failing. We don't need this test anymore. Delete it.</p>
			<p>Let's say we are building an app for a blogging platform. When writing a new post, the user puts in a headline for the post. All the words in the headline should start with an uppercase<a id="_idIndexMarker046"/> letter.</p>
			<p>To start the TDD workflow, we need a failing test. The following questions need to be considered when writing the test:</p>
			<ul>
				<li><strong class="bold">Precondition</strong>: What is the state of the system before we invoke the method?</li>
				<li><strong class="bold">Invocation</strong>: How should the signature of the method look? What are the input parameters (if any) of the method?</li>
				<li><strong class="bold">Assertion</strong>: What is the expected result of the method invocation?</li>
			</ul>
			<p>For our blogging app example, here are some possible answers to these questions:</p>
			<ul>
				<li><strong class="bold">Precondition</strong>: None.</li>
				<li><code>makeHeadline</code>.</li>
				<li><strong class="bold">Assertion</strong>: The resulting string should be the same, but all the words should start with an uppercase letter.</li>
			</ul>
			<p>This is enough to get us started. Enter the red step.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor081"/>Capitalize headline – red</h2>
			<p>The<a id="_idIndexMarker047"/> following steps bring us to the first red state of our TDD journey:</p>
			<ol>
				<li>Open <code>FirstDemoTests.swift</code>, and add the following code to the <code>FirstDemoTests</code> class:<pre>// FirstDemoTests.sw<a id="_idTextAnchor082"/><a id="_idTextAnchor083"/>ift
func 
 test_makeHeadline_shouldCapitalisePassedInString() {
  let blogger = Blogger()
}</pre></li>
			</ol>
			<p>This isn't a complete test method yet because we aren't really testing anything. But we have to stop writing the test at this point because the compiler complains that it <code>Blogger</code> but we haven't added it yet.</p>
			<p>Following the TDD workflow, we need to add code until the compiler stops printing errors. Remember that <strong class="bold">code does not compile</strong> within a test means "the test is<a id="_idIndexMarker048"/> failing." And a failing test means we need to write code until the test does not fail anymore.</p>
			<ol>
				<li value="2">Add a Swift file <code>Blogger.swift</code> to the main target with the following code:<pre>// Blogger.swift
import Foundation
struct Blogger { 
}</pre></li>
			</ol>
			<p>Xcode replaces the error in the test with a warning that we do not use the <code>blogger</code> variable. That's true. So let's use it. </p>
			<ol>
				<li value="3">Change the test code such that it looks like this:<pre>// FirstDemoTests.swift
func
 test_makeHeadline_shouldCapitalisePassedInString() {
  let blogger = Blogger(<a id="_idTextAnchor084"/><a id="_idTextAnchor085"/>)
  let headline = blogger.makeHeadline(from: "the
    Accessibility inspector")
}</pre></li>
			</ol>
			<p>The test is still not complete. But again we have to stop because the compiler is complaining, this time with the message <strong class="bold">Value of type 'Blogger' has no member 'makeHeadline'</strong>. So even with these few lines of code, you can already see how the test is "driving" the development. Step by step, we add code to the test and to the production code to implement the feature we are trying to build.</p>
			<ol>
				<li value="4">As the test<a id="_idIndexMarker049"/> is failing (not compiling) right now, we need to switch back to the <code>Blogger</code> struct and add some more code:<pre>// Blogger.swift
struct Blogger {
  func makeHeadline(from input: String) -&gt; String {
    return ""
  }
}</pre></li>
			</ol>
			<p>Again, this changes the error in the test code to a warning that we are not using the headline variable. This is true. But we aren't finished with the test yet. </p>
			<ol>
				<li value="5">We will use the variable next. Add the following assertion to the test method:<pre>// FirstDemoTests.swift
func 
 test_makeHeadline_shouldCapitalisePassedInString() {
  let blogger = Blogger()
  let headline = blogger.makeHeadline(from: "the 
    Accessibility inspecto<a id="_idTextAnchor086"/><a id="_idTextAnchor087"/>r")
  XCTAssertEqual(headline, "The Accessibility 
    Inspector")
}</pre></li>
			</ol>
			<p>This makes the test compile. Run the tests with the keyboard shortcut <em class="italic">⌘</em><em class="italic"> </em><em class="italic">U</em>.</p>
			<p>The test we just added compiles and fails. We can move on to the green phases in the TDD workflow.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor088"/>Capitalize headline – green</h2>
			<p>The test fails because the string that is returned from <code>makeHeadline(from:)</code> is just an empty <a id="_idIndexMarker050"/>string. But the method should return the capitalized version of the input string <code>The Accessibility inspector</code>. </p>
			<p>Following the TDD workflow, we need to go back to the implementation and add the simplest code that makes the test pass. In <code>Blogger.swift</code>, change the code of <code>makeHeadline(from:)</code> such that it reads like this:</p>
			<pre>func makeHeadline(from input: String) -&gt; Stri<a id="_idTextAnchor089"/><a id="_idTextAnchor090"/>ng {
  return "The Accessibility Inspector"
}</pre>
			<p>This code is stupid and wrong, but it is the simplest code that makes the test pass. Run the tests (<em class="italic">⌘</em><em class="italic"> U</em>) to make sure that this is actually the case.</p>
			<p>Even though the code we just wrote is useless for the feature we are trying to implement, it still has value for us, the developers. It tells us that we need another test.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor091"/>Capitalize headline – refactor</h2>
			<p>Before writing more tests, we need to refactor the existing ones. In the production code, there is nothing to refactor. This code couldn't be simpler or more elegant.</p>
			<p>But the test can be improved. Right now, the relevant information for the test is kind of unstructured. It's not a big problem but maybe we can improve the readability of the test by following these steps:</p>
			<ol>
				<li value="1">Replace the <code>test_makeHeadline_shouldCapitalisePassedInString()</code> test method with the following code:<pre>func 
 test_makeHeadline_shouldCapitalisePassedInStri<a id="_idTextAnchor092"/><a id="_idTextAnchor093"/>ng() {
  let blogger = Blogger()
  let input = "the Accessibility inspector"
  let result = blogger.makeHeadline(from: input)
  let expected = "The Accessibility Inspector"
  XCTAssertEqual(result, expected)
}</pre></li>
			</ol>
			<p>By using <a id="_idIndexMarker051"/>variables in the test, we make it easier to understand. The names of the variables inform the reader of the test about the purpose of these values. One value is the input, one is the result, and one is the expected value.</p>
			<p>Run the tests. All the tests should still pass. But how do we know whether the tests still test the same thing as they did earlier? In most cases, the changes we'll make while refactoring the tests don't need to be tested themselves. But, sometimes (such as in this case), it is good to make sure that the test still works. This means that we need a failing test again. </p>
			<ol>
				<li value="2">Go to <code>makeHeadline(from:)</code> and change the returned string like this:<pre>func makeHeadline(from input: String) -&gt; String {
  return "The Accessibility"
}</pre></li>
			</ol>
			<p>We have removed the last word from the return string. Run the tests again to make sure that the test now fails. </p>
			<ol>
				<li value="3">Now change the returned string back to <code>The Accessibility Inspector</code> to make the test pass again. Confirm that all tests pass again by running the tests.</li>
			</ol>
			<p>By making the test fail on purpose and fixing it in the next step, we have proven that the test can fail. This is important because writing a test that always passes can easily happen. For example, if you forget to add an <code>assert</code> function or the <code>assert</code> function is never reached because of some conditionals in the test, the test is always<a id="_idIndexMarker052"/> reported as green.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Always confirm that the test can fail!</p>
			<p>We already know that the implementation is not correct. The <code>makeHeadline(from:)</code> method always returns the same string and ignores the string that gets passed into the method. But all tests we have passed. When all tests pass, but we know that we are not finished with the feature yet, this means we need another test. In TDD, we always start with a failing test.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor094"/>Capitalize headline 2 – red</h2>
			<p>The production code we have written to make the previous test pass only works for one specific headline. But the feature we want to implement has to work for all possible headlines. Add the following test to <code>FirstDemoTests.swift</code>:</p>
			<pre>// FirstDemoTes<a id="_idTextAnchor095"/><a id="_idTextAnchor096"/>ts.swift
func test_makeHeadline_shouldCapitalisePassedInString_2() {
  let blogger = Blogger()
  let input = "The contextual action menu"
 
  let result = blogger.makeHeadline(from: input) 
  let expected = "The Contextual Action Menu"
  XCTAssertEqual(result, expected)
}</pre>
			<p>Run the tests. This new test obviously fails. Now, take a break. Go for a walk or prepare some beverages. Seriously, go away from the computer for half an hour or so.</p>
			<p>Let's make<a id="_idIndexMarker053"/> the tests green.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor097"/>Capitalize headline 2 – green</h2>
			<p>Open <code>Blogger.swift</code>, and replace the implementation of <code>makeHeadline(from:)</code> with the following code:</p>
			<pre>// Blogger.swift
func makeHeadline(from input: String) -&gt;<a id="_idTextAnchor098"/><a id="_idTextAnchor099"/> String {
  let words = input.components(separatedBy: " ")
  var headline = ""
  for var word in words {
    let firstCharacter = word.remove(at: word.startIndex)
    headline +=
      "\(String(firstCharacter).uppercased())\(word) "
  }
  headline.remove(at: headline.index(before:
    headline.endIndex))
  return headline
}</pre>
			<p>It's OK to be shocked by this implementation. With this code, I'm trying to make the point that, in the green step of TDD, any code is good as long as it makes the test pass. We'll improve this code in the next section.</p>
			<p>Let's go through this implementation step by step:</p>
			<ol>
				<li value="1">Split the string into words.</li>
				<li>Iterate over the words, and remove the first character and change it to uppercase. Add the changed character to the beginning of the word. Add this word with a trailing space to the headline string.</li>
				<li>Remove the last space and return the string.</li>
			</ol>
			<p>Run the tests. All the tests pass. The next thing to perform in the TDD workflow is refactoring.</p>
			<p class="callout-heading">Tip </p>
			<p class="callout">Do not skip <a id="_idIndexMarker054"/>refactoring. This step is as important as the red and the green step. You are not done until there is nothing to refactor anymore.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor100"/>Capitalize headline 2 – refactor</h2>
			<p>Let's start our refactoring with the tests:</p>
			<ol>
				<li value="1">The two <code>makeHeadline</code> tests both start with creating an instance of <code>Blogger</code>. This is a repetition of code and a good candidate for refactoring.</li>
			</ol>
			<p>Add the following property at the beginning of the <code>FirstDemoTests</code> class:</p>
			<pre>// FirstDemoT<a id="_idTextAnchor101"/><a id="_idTextAnchor102"/>ests.swift
var blogger: Blogger!</pre>
			<ol>
				<li value="2">Remember that the <code>setUp()</code> method is called before each test is executed. So, it is the perfect place to initialize the <code>blogger</code> property:<pre>// FirstDemoTests.swift
override func setUpWithError()<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/> throws {
  blogger = Blogger()
}</pre></li>
				<li>Each test should clean up after it has run. So, add the following code to <code>tearDownWithError()</code>:<pre>// FirstDemoTests.swift
override func tearDownWithError() <a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>throws {
  blogger = nil
}</pre></li>
				<li>Now we can remove the <code>let blogger = Blogger()</code> line from the headline<a id="_idIndexMarker055"/> tests. Run the tests to make sure that they still compile and run.</li>
				<li>Now we need to refactor the implementation code. The implementation we have right now looks like it was translated from Objective-C to Swift (if you haven't used Objective-C yet, you have to trust me on this). But Swift is different and has many concepts that make it possible to write less code that is easier to read. Let's make the implementation swifter. Replace <code>makeHeadline(from:)</code> with the following code:<pre>// Blogger.swift
func makeHeadline(from input: String) -&gt; String {
  return input.capitalized
}</pre></li>
			</ol>
			<p>How cool is that? Swift even comes with a method on the <code>String</code> class to do exactly that. Run the tests again to make sure we didn't break anything with the refactoring. All the tests should still pass.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor107"/>A recap</h2>
			<p>In this section, we have added a feature to our project using the TDD workflow. We started with a failing test. We made the test pass. And, finally, we refactored the code to be clean. The steps you have seen here seem so simple and insignificant that you may think that you could skip some of the tests and still be good. But then it's not TDD anymore. The beauty of TDD is that the steps are so easy that you do not have to think about them. You just have to remember what the next step is.</p>
			<p>Because the steps and the rules are so easy, you don't have to waste your brainpower thinking about <a id="_idIndexMarker056"/>what the steps actually mean. The only thing you have to remember is red, green, and refactor. As a result, you can concentrate on the difficult part: <em class="italic">writing tests</em>, <em class="italic">making them pass</em>, and <em class="italic">improving code</em>.</p>
			<p>Now that we know how to write tests, let's see where we can find information about our tests in Xcode.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor108"/>Finding information about tests in Xcode</h1>
			<p>With Xcode 5 <a id="_idIndexMarker057"/>and the introduction of XCTest, unit <a id="_idIndexMarker058"/>testing became tightly integrated into Xcode. Apple added many UI elements to navigate to tests, run specific tests, and find information about failing tests. Over the years, they improved the integration further. One key element here is the <strong class="bold">test navigator</strong>.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor109"/>Test navigator</h2>
			<p>To open the <a id="_idIndexMarker059"/>test <a id="_idIndexMarker060"/>navigator, click the diamond with the minus sign in the navigator panel or use the shortcut <em class="italic">⌘</em><em class="italic"> 6</em>:</p>
			<div><div><img src="img/Figure_3.01_B18127.jpg" alt="Figure 3.1 – The test navigator in Xcode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The test navigator in Xcode</p>
			<p>The test <a id="_idIndexMarker061"/>navigator shows<a id="_idIndexMarker062"/> all tests in the open project or workspace. In the preceding screenshot, you can see the test navigator for our demo project. In the project, there are two test targets, one for the unit tests and one for the UI tests. For complex apps, it can be useful to have more than one unit tests target, but this is beyond the scope of this book. The number of tests is shown right behind the name of the test target. In our case, there are three tests in the unit tests target. </p>
			<p>At the bottom of the navigator is a filter control with which you can filter the shown tests. As soon as you start typing, the shown tests are filtered using fuzzy matching. There's a button in the control showing a diamond with a cross:</p>
			<div><div><img src="img/Figure_3.02_B18127.jpg" alt="Figure 3.2 – The button in the test navigator to only show the failing tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – The button in the test navigator to only show the failing tests</p>
			<p>If this button<a id="_idIndexMarker063"/> is selected, only <a id="_idIndexMarker064"/>the failing tests are shown in the list. With the button on the right, you can filter all skipped tests.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor110"/>Test overview</h2>
			<p>Xcode also has<a id="_idIndexMarker065"/> a test overview where all the results of the tests are collected in one place. To open it, select <strong class="bold">Report navigator</strong> in the navigator panel, and select the last test in the list:</p>
			<div><div><img src="img/Figure_3.03_B18127.jpg" alt="Figure 3.3 – Access the overview of the tests in the report navigator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Access the overview of the tests in the report navigator</p>
			<p>You can also select<a id="_idIndexMarker066"/> other tests in the list if you want to compare test runs with each other. In the editor on the right-hand side, an overview of all the tests from the selected test run is shown:</p>
			<div><div><img src="img/Figure_3.04_B18127.jpg" alt="Figure 3.4 – Overview of the tests of the last test run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Overview of the tests of the last test run</p>
			<p>When you hover <a id="_idIndexMarker067"/>over one of the tests with the mouse pointer, a circle with an arrow to the right appears. If you click on the arrow, Xcode opens the test in the editor.</p>
			<p>In the report navigator, there is also the <strong class="bold">Log</strong> item. It shows all the tests in a tree-like structure. Here is an example of what this looks like:</p>
			<div><div><img src="img/Figure_3.05_B18127.jpg" alt="Figure 3.5 – Log of the test reports&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Log of the test reports</p>
			<p>The logs show the<a id="_idIndexMarker068"/> test cases (in this example, one test case) and the tests within the test cases (in this example, two failing and one passing test). In addition to this, you can also seethe time each test case and even each test needs to execute.</p>
			<p>In TDD, it is important for the tests to execute quickly. You want to be able to execute the whole test suite in less than a second. Otherwise, the whole workflow is dominated by test execution and testing can distract your focus and concentration. You should never be tempted to switch to another application (such as Safari) because the tests will take half a minute.</p>
			<p>If you notice that the test suite takes too long to be practical, open the logs and search for the tests that slow down testing and try to make the tests faster.</p>
			<p>Now that we have seen where we can find information about our tests, in the next section we will explore the different ways to run tests.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor111"/>Running tests</h1>
			<p>Xcode provides<a id="_idIndexMarker069"/> many different ways to execute tests. You have already seen two ways to execute all the tests in the test suite: go to the <strong class="bold">Project</strong> | <strong class="bold">Test</strong> menu item or use the <em class="italic">⌘</em><em class="italic">U</em> keyboard shortcut.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor112"/>Running one specific test</h2>
			<p>In TDD, you<a id="_idIndexMarker070"/> normally want to run all the tests as often as possible. Running the tests gives you confidence that the code does what you intended when you wrote the tests. In addition to this, you want immediate feedback (that is, a failing test) whenever new code breaks a seemingly unrelated feature. Immediate feedback means that your memory of the changes that broke the feature is fresh, and the fix is made quickly.</p>
			<p>Nevertheless, sometimes, you need to run one specific test, but don't let it become a habit. To run one specific test, you can click on the diamond visible next to the test method:</p>
			<div><div><img src="img/Figure_3.06_B18127.jpg" alt="Figure 3.6 – Run one specific test by clicking the diamond next to the test method in the gutter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Run one specific test by clicking the diamond next to the test method in the gutter</p>
			<p>When you click on it, the production code is compiled and launched in the simulator or on the device, and the test is executed.</p>
			<p>There is another way to execute exactly one specific test. When you open the test navigator and hover over one test, a circle with a play icon is shown next to the test method name:</p>
			<div><div><img src="img/Figure_3.07_B18127.jpg" alt="Figure 3.7 – Click the diamond next to the test in the test navigator to run this test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Click the diamond next to the test in the test navigator to run this test</p>
			<p>Again, if you click on this test, it is run exclusively.</p>
			<p>The test framework identifies tests by the prefix of the method name. If you want to run all tests but <a id="_idIndexMarker071"/>one, remove the <code>test</code> prefix from the beginning of this test's method name.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor113"/>Running all tests in a test case</h2>
			<p>In the same way <a id="_idIndexMarker072"/>as running one specific test, you can run all the tests of a specific test case. Click on the diamond next to the definition of the test case, or click on the play button that appears when you hover over the test case name in the test navigator.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor114"/>Running a group of tests</h2>
			<p>You can <a id="_idIndexMarker073"/>choose to run a group of tests by editing the build scheme. To edit the build scheme, click on the scheme in the toolbar in Xcode, and then click on <strong class="bold">Edit Scheme...</strong>:</p>
			<div><div><img src="img/Figure_3.08_B18127.jpg" alt="Figure 3.8 – Open the scheme editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Open the scheme editor</p>
			<p>Then, select <strong class="bold">Test</strong>, and expand the test suite by clicking on the small triangle. On the right-hand <a id="_idIndexMarker074"/>side, there is a column called <strong class="bold">Tests</strong>:</p>
			<div><div><img src="img/Figure_3.09_B18127.jpg" alt="Figure 3.9 – Test setting in the scheme editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Test setting in the scheme editor</p>
			<p>The selected scheme only runs the tests that are checked. By default, all the tests are checked, but you can uncheck some tests if you need to. But don't forget to check all the tests again when you are finished.</p>
			<p>As an alternative, you can add a build scheme for a group of tests that you want to run regularly without running all tests.</p>
			<p>But as <a id="_idIndexMarker075"/>mentioned earlier, you should run the complete test suite as often as possible.</p>
			<p>The following section shows how to add code that is run before and after each test invocation.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor115"/>Setting up and tearing down</h1>
			<p>We have <a id="_idIndexMarker076"/>already<a id="_idIndexMarker077"/> seen the <code>setUpWithError()</code> and <code>tearDownWithError()</code> instance methods earlier in this chapter. The code in the <code>setUpWithError()</code> instance method is run before each test invocation. In our example, we used <code>setUpWithError()</code> to initialize the <code>Blogger</code> that we wanted to test. As it was run before each test invocation, each test used its own instance of <code>Blogger</code>. The changes we made to this particular instance in one test didn't affect the other test. The tests are executed independently of each other.</p>
			<p>The <code>tearDownWithError()</code> instance method is run after each test invocation. Use <code>tearDownWithError()</code> to perform the necessary cleanup. In<a id="_idTextAnchor116"/><a id="_idTextAnchor117"/><a id="_idTextAnchor118"/><a id="_idTextAnchor119"/><a id="_idTextAnchor120"/> the example, we set the <code>blogger</code> to <code>nil</code> in the <code>tea<a id="_idTextAnchor121"/><a id="_idTextAnchor122"/>rDownWithError()</code> method.</p>
			<p>In addition to the instance methods, there are also the <code>setUp()</code> and <code>tearDown()</code> class methods. These are run before and after all the tests of a test case, respectively.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor123"/>Debugging tests</h1>
			<p>Sometimes, but not<a id="_idIndexMarker078"/> often, you may need to debug your tests. As with normal code, you can set breakpoints in test code. The debugger then stops the execution of the code at that breakpoint. You can also set breakpoints in the code that will be tested to check whether you have missed something or whether the code you'd like to test is actually executed.</p>
			<p>To get a feeling of how this works, let's add an error to a test in the preceding example and debug it: </p>
			<ol>
				<li value="1">Open <code>FirstDemoTests.swift</code> and replace the test method <code>test_makeHeadline_shouldCapitalisePassedInString_2()</code> with this code<a id="_idTextAnchor124"/><a id="_idTextAnchor125"/>:<pre>// FirstDemoTests.swift
func 
 test_makeHeadline_shouldCapital<a id="_idTextAnchor126"/><a id="_idTextAnchor127"/>isePassedInString_2()
 { 
  let input = "The contextual action menu"  
  let result = blogger.makeHeadline(from: input)
  let expected = "The ContextuaI Action Menu"
  XCTAssertEqual(result, expected)
}</pre></li>
			</ol>
			<p>Have you seen <a id="_idIndexMarker079"/>the error that we have introduced? The value of the string expected has a typo. The last character in <code>Contextual</code> is an uppercase "i" and not a lowercase "l". Run the tests. The test fails and Xcode tells you what the problem is. </p>
			<ol>
				<li value="2">But for the sake of this exercise, let's set a breakpoint in the line with the <code>XCTAssertEqual()</code> function. Click on the area on the left-hand side of the line where you want to set a breakpoint. You have to click on the area next to the red diamond. As a result, your editor will look similar to the following:</li>
			</ol>
			<div><div><img src="img/Figure_3.10_B18127.jpg" alt="Figure 3.10 – Add a breakpoint in the line with the assertion&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Add a breakpoint in the line with the assertion</p>
			<ol>
				<li value="3">Run the tests again. The execution of the tests stops at the breakpoint. Open the debug console if it is not already open (go to <code>(lldb)</code> and a<a id="_idIndexMarker080"/> blinking cursor. Put in <code>po expected</code> and hit <em class="italic">Return</em>. <code>po</code> is the "print object" command. As the name suggests, it prints a representation of the object:<pre>(lldb) po expected
"The ContextuaI Action Menu"</pre></li>
				<li>Now print the value of the result:<pre>(lldb) po result
"The Contextual Action Menu"</pre></li>
			</ol>
			<p>So, with the help of the debugger, you can find out what is happening.</p>
			<p>As we have seen, the debugger is attached to the running app when we run the tests. This means breakpoints in production code are also hit when we run the tests.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To learn more about the debugger, search for <code>lldb</code> in the Apple documentation.</p>
			<p>For now, keep the typo in the <code>expected</code> string constant as it is, but remove the breakpoint by dragging it with the mouse from the area to the left of the editor.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor128"/>A breakpoint that breaks on test failure</h2>
			<p>Xcode has a<a id="_idIndexMarker081"/> built-in breakpoint that breaks on test failures. When this breakpoint is set, the execution of the tests is stopped, and a debug session is started whenever a test fails.</p>
			<p>Usually, this is not what you want because in TDD, failing tests are normal and you don't need a debugger to find out what's going on. You explicitly wrote the test to fail at the beginning of the TDD workflow cycle.</p>
			<p>But in case you need to debug one or more failing tests, it's good to know how this breakpoint is activated. Open the breakpoint navigator:</p>
			<div><div><img src="img/Figure_3.11_B18127.jpg" alt="Figure 3.11 – The breakpoint navigator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – The breakpoint navigator</p>
			<p>At the bottom of the navigator view is a button with a plus sign (+). Click on it, and select <strong class="bold">Test Failure Breakpoint</strong>:</p>
			<div><div><img src="img/Figure_3.12_B18127.jpg" alt="Figure 3.12 – Select Test Failure Breakpoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Select Test Failure Breakpoint</p>
			<p>As the name suggests, this breakpoint stops the execution of the tests whenever a test fails. We still have a failing test in our example. Run the tests to see the breakpoint in action.</p>
			<p>The debugger stops at the line with the assertion because the tests fail. Like in the preceding example, you get a debug session so that you can put in <code>LLDB</code> commands to find out why the test failed.</p>
			<p>Remove the <a id="_idIndexMarker082"/>breakpoint again because it's not very practical while performing TDD. In TDD, we have failing tests all the time. A test failure breakpoint would disturb the TDD flow too much.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor129"/>The test again feature</h2>
			<p>Now, let's fix the error<a id="_idIndexMarker083"/> in the tests and learn how to run the previous test again. Open <code>FirstDemoTests.swift</code> and run only the failing test by clicking on the diamond symbol next to the test method. The test still fails. Fix it by changing the last character in <code>ContextuaI</code> to "l" in the <code>expected</code> string constant. Then, go to <strong class="bold">Product</strong> | <strong class="bold">Perform Action</strong> | <strong class="bold">Test "test_makeHeadline_shouldCapitalisePassedInString_2()"<a id="_idTextAnchor130"/> Again</strong>, or use the shortcut <em class="italic">⌃⌥⌘</em><em class="italic">G</em> to run just the previous test again. The shortcut is especially useful when you are working on one specific feature and you need to test whether the implementation<a id="_idIndexMarker084"/> is sufficient already.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor131"/>Summary</h1>
			<p>In this chapter, we explored how unit testing and TDD works in Xcode. We saw real tests testing real code. Using the different test-related features of Xcode, we learned to write, run, and fix tests and to find test-relevant information. All this is important for the rest of the book. We need to know how to use Xcode when doing TDD.</p>
			<p>In the next chapter, we will figure out the app we are going to build using test-driven development.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor132"/>Exercises</h1>
			<ol>
				<li value="1">Write a test for a method that reverses a string. Write the code that makes the test pass.</li>
				<li>Write a test for a method that takes a headline and creates a filename from it. In the filename, make sure that spaces are replaced by <code>_</code> and it only contains lowercase characters.</li>
			</ol>
		</div>
	</body></html>