["```java\n#version 300 es\n\n// Define amplitude for Wobble Shader\n#define AMPLITUDE           1.2\n\n// Geometries vertex and normal information\nlayout(location = 0) in vec4  VertexPosition;\nlayout(location = 1) in vec3  Normal;\n\n// Model View Project and Normal matrix\nuniform mat4 ModelViewProjectionMatrix, ModelViewMatrix;\nuniform mat3 NormalMatrix;\n\nuniform float Time; // Timer\n\n// Output variable for fragment shader\nout vec3    nNormal, eyeCoord;\n\nvoid main(){\n    nNormal   = normalize ( NormalMatrix * Normal );\n    eyeCoord  = vec3 ( ModelViewMatrix * VertexPosition );\n    vec4 VertexCoord = VertexPosition;\n    VertexCoord.y += sin(VertexCoord.x+Time)*AMPLITUDE;\n    gl_Position = ModelViewProjectionMatrix * VertexCoord;\n}\n```", "```java\n#define RIPPLE_AMPLITUDE 0.05\n#define FREQUENCY 5.0\n#define PI 3.14285714286\nvoid main(){\n    nNormal   = normalize ( NormalMatrix * Normal );\n    eyeCoord  = vec3 ( ModelViewMatrix * VertexPosition );\n    vec4    VertexCoord = VertexPosition;\n    float distance = length(VertexCoord);\n VertexCoord.y = sin( 2.0 * PI * distance * FREQUENCY + Time)\n * RIPPLE_AMPLITUDE;\n    gl_Position = ModelViewProjectionMatrix * VertexCoord;\n}\n```", "```java\n    #version 300 es\n    // Vertex information\n    layout(location = 0) in vec4  VertexPosition;\n    layout(location = 1) in vec3  Normal;\n\n    // Model View Project and Normal matrix\n    uniform mat4 ModelViewProjectionMatrix, ModelViewMatrix;\n    uniform mat3    NormalMatrix;\n\n    // output variable to fragment shader\n    out vec3 nNormal, eyeCoord, ObjectCoord;\n\n    void main() {\n        nNormal     = normalize ( NormalMatrix * Normal );\n        eyeCoord    = vec3 (ModelViewMatrix * VertexPosition);\n        ObjectCoord = VertexPosition.xyz;\n        gl_Position = ModelViewProjectionMatrix * VertexPosition;\n    }\n    ```", "```java\n    // Reuse the Light and Material properties. . \n    in vec3 eyeCoord;    // Vertex eye coordinate\n    in vec3 ObjectCoord; // Vertex object coordinate \n    layout(location = 0) out vec4 outColor;\n\n    vec3 PhongShading(){ \n      . . . . . .   // Reuse Phong shading code.\n    }\n\n    void main() {\n        if (objectCoord.x  > 0.0 && objectCoord.z  > 0.0)\n            FinalColor = vec4(1.0, 0.0, 0.0, 1.0);\n        else if (objectCoord.x  > 0.0  && objectCoord.z  < 0.0)\n            FinalColor = vec4(0.0, 01.0, 0.0, 1.0);\n        else if (objectCoord.x  < 0.0  && objectCoord.z  > 0.0)\n            FinalColor = vec4(0.0, 01.0, 1.0, 1.0);\n        else if (objectCoord.x  < 0.0  && objectCoord.z  < 0.0)\n            FinalColor = vec4(1.0, 0.0, 1.0, 1.0);\n\n        FinalColor = FinalColor  * vec4(PhongShading(), 1.0);\n    }\n    ```", "```java\n// Reuse the Light and Material properties. . \nin vec3 eyeCoord;    // Vertex eye coordinate\nin vec3 ObjectCoord; // Vertex object coordinate \nlayout(location = 0) out vec4 outColor;\n\nvec3 PhongShading(){ \n  . . . . . .// Reuse Phong shading code.\n}\n\nvoid main() {\n    //Debuging Shader with Model coordinates\n    if (objectCoord.x  > 0.9 )\n        FinalColor = vec4(1.0, 0.0, 0.0, 1.0);\n    else if (objectCoord.x  > 0.8 )\n        FinalColor = vec4(1.0, 1.0, 0.0, 1.0);\n    else if (objectCoord.x  > 0.7 )\n        FinalColor = vec4(1.0, 0.0, 1.0, 1.0);\n    else if (objectCoord.x  > 0.6 )\n        FinalColor = vec4(0.60, 0.50, 0.40, 1.0);\n    else if (objectCoord.x  > 0.5 )\n        FinalColor = vec4(0.30, 0.80, 0.90, 1.0);\n    else\n        FinalColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (objectCoord.z  > 0.9 )\n        FinalColor = vec4(1.0, 0.0, 0.0, 1.0);\n    else if (objectCoord.z  > 0.8 )\n        FinalColor = vec4(1.0, 1.0, 0.0, 1.0);\n    else if (objectCoord.z  > 0.7 )\n        FinalColor = vec4(1.0, 0.0, 1.0, 1.0);\n    else if (objectCoord.z  > 0.6 )\n        FinalColor = vec4(0.60, 0.50, 0.40, 1.0);\n    else if (objectCoord.z  > 0.5 )\n        FinalColor = vec4(0.30, 0.80, 0.90, 1.0);\n\n    FinalColor = FinalColor  * vec4(PhongShading(), 1.0);\n}\n```", "```java\n#version 300 es\n// Reuse the variables . . . no change\nvec3 PhongShading(){\n   // Reuse Phong shading code.\n   . . . . . .\n   return ambient + diffuse + sIntensity * specular;\n}\n\n// Model and Dot color\nuniform vec3 ModelColor, DotColor;\n\n// Output color for fragment\nlayout(location = 0) out vec4 FinalColor;\n\n// Size of the logical square\nuniform float Side;\n\n// Dot size 25% of Square size\nfloat DotSize   = Side * 0.25;\nvec2 Square     = vec2(Side, Side);\n\nvoid main() {\n    vec2 position = mod(gl_FragCoord.xy, Square) - Square*0.5;\n    float length = length(position);\n    float inside = step(length,DotSize);\n\n    FinalColor = vec4(mix(ModelColor, DotColor, inside), 1.0);\n    FinalColor = FinalColor * vec4(GouraudShading(), 1.0);\n}\n```", "```java\nvec2 position = mod(gl_FragCoord.xy, Square) - Square*0.5;\n```", "```java\n   inside  = step(length,DotSize);\n```", "```java\nfloat step(float edge, float x);\n```", "```java\nuniform float   RadianAngle;\nvoid main() {\n    float cos  = cos(RadianAngle); // Calculate Cos of Theta\n    float sin  = sin(RadianAngle); // Calculate Sin of Theta\n\n    mat2 rotation  = mat2(cos, sin, -sin, cos);\n    vec2 position  = mod( rotation * gl_FragCoord.xy, Square) \n    - Square*0.5;\n    float length  = length(position);\n    float inside  = step(length,DotSize);\n\n    FinalColor = vec4(mix(ModelColor, DotColor, inside), 1.0);\n    FinalColor = FinalColor * vec4(PhongShading(), 1.0);\n}\n```", "```java\n    // Brick uniform parameters\n    uniform vec3  BrickColor, MortarColor;\n    uniform vec2  RectangularSize, BrickPercent;\n\n    // Object coordinates of the mesh\n    in vec3    ObjectCoord;\n\n    vec3 PhongShading(){ //Reuse code for Phong shading\n       . . . . . .\n       return ambient + diffuse + specular;\n    }\n\n    vec3  color;\n    vec2  position, useBrick;\n\n    void main() {\n        position = ObjectCoord.xy / RectangularSize;\n\n       // Displace rows alternately after 0.5 decimals\n        if (fract(position.y * 0.5) > 0.5){\n            position.x += 0.5;\n        }\n\n        position = fract(position);\n        useBrick = step(position, BrickPercent);\n        color    = mix(MortarColor, BrickColor, \n                          useBrick.x * useBrick.y);\n        FinalColor  = vec4(color * PhongShading(), 1.0);\n    }\n    ```", "```java\n        BrickColor = ProgramGetUniformLocation(program,\"BrickColor\");\n        MortarColor= ProgramGetUniformLocation(program, \"MortarColor\");\n\n        if (BrickColor >= 0)\n           {glUniform3f(BrickColor, 1.0, 0.3, 0.2 );}\n        if (MortarColor >= 0)\n           {glUniform3f(MortarColor, 0.85, 0.86, 0.84);}\n    ```", "```java\n        RectangularSize= ProgramGetUniformLocation(program,\"RectangularSize\");\n        BrickPercent = ProgramGetUniformLocation(program,\"BrickPercent\");\n        if (RectangularSize >= 0)\n           {glUniform2f(RectangularSize, 0.40, 0.10 );}\n        if (BrickPercent >= 0)\n           {glUniform2f(BrickPercent, 0.90, 0.85 );}\n    ```", "```java\n    if (fract(position.y * 0.5) > 0.5)\n    {\n        position.x += 0.5;\n    }\n```", "```java\nposition = fract(position);\nuseBrick = step(position, BrickPercent);\ncolor    = mix(MortarColor,BrickColor,useBrick.x * useBrick.y);\n```", "```java\ngenType mix(genType x, genType y, genType a);\n```", "```java\n    #version 300 es\n    precision mediump float;\n    layout(location = 0) out vec4 outColor;\n\n    in vec3  ObjectCoord;\n\n    // Size of the logical cube\n    uniform float Side;\n    uniform float DotSize;\n    vec3 Cube       = vec3(Side, Side, Side);\n    vec3 RenderColor= vec3(0.0, 0.0, 0.0);\n\n    // Front and Back face Model(mesh)/polka dot color\n    uniform vec3 ModelColor, DotColor, BackSideModelColor, BackSideDotColor;\n\n    void main() {\n\n        float insideSphere, length;\n        vec3 position = mod(ObjectCoord, Cube) â€“ Cube*0.5;\n        // Note: length() can also be used here\n        length = sqrt( (position.x*position.x) +\n        (position.y*position.y) + (position.z*position.z) );\n        insideSphere = step(length,DotSize);\n\n        // Determine color based on front/back shading\n     if (gl_FrontFacing){){           \n       RenderColor=vec3(mix(ModelColor,DotColor,insideSphere));\n           outColor = vec4(RenderColor , 1.0);\n        }\n        else{\n           RenderColor==vec3(mix(BackSideModelColor,BackSideDotColor, insideSphere));\n            outColor = vec4(RenderColor, 1.0);\n        }\n    }\n    ```", "```java\n    vec3 position = mod(ObjectCoord, Cube) - Cube/0.5;\n```", "```java\nlength = sqrt( (position.x*position.x) +\n (position.y*position.y)+(position.z*position.z));\n```", "```java\n    insideSphere = step(length,DotSize);\n```", "```java\n#version 300 es\n// Many lines skipped . . . \nlayout(location = 0) out vec4 FinalColor;\nvec3 GouraudShading( bool frontSide )\n{\n // Reuse two sides shade recipe PhongShading code here\n   return ambient + diffuse + specular;\n}\n\nin vec3  ObjectCoord;\nuniform float Side, DotSize;\nvec3 Square     = vec3(Side, Side, Side);\nvec3 RenderColor;\n\n// Front and Back face polka dot color\nuniform vec3 ModelColor, DotColor, BackSideModelColor, BackSideDotColor;\n\n// Variable for toggling the use of discard keyword\nuniform int toggleDiscardBehaviour;\n\nvoid main() {\n\n    float insideCircle, length;\n    vec3 position = mod(ObjectCoord, Square) - Square/2.0;\n\n   length = sqrt( (position.x*position.x) +\n          (position.y*position.y)+(position.z*position.z));\n    insideCircle      = step(length,DotSize);\n\n // The toggleDiscardBehaviour change the behavior\n // automatically after fixed interval time.\n // The timer is controlled from the OpenGL ES program.\n if(toggleDiscardBehaviour == 0){\n if (insideCircle != 0.0)\n discard;\n }\n else{\n if (insideCircle == 0.0)\n discard;\n }\n\n // Determine final color based on front and back shading\n    if (gl_FrontFacing){\n     RenderColor = vec3(mix( ModelColor, DotColor, insideCircle));\n     FinalColor = vec4(RenderColor * PhongShading(true), 1.0);\n    }\n    else{\n     RenderColor=vec3(mix(BackSideModelColor, \n     BackSideDotColor, insideCircle));\n     FinalColor=vec4(RenderColor * PhongShading(false), 1.0);\n    }\n}\n```", "```java\n    #version 300 es\n    // Vertex layout information\n    layout(location = 0) in vec4  VertexPosition;\n    layout(location = 1) in vec3  Normal;\n    layout(location = 2) in vec2  TexCoords;\n\n    // Model View Projection Normal matrix\n    uniform mat4    ModelViewProjectionMatrix, ModelViewMatrix;\n    uniform mat3    NormalMatrix;\n\n    out vec3    nNormal, eyeCoord;\n    out vec2    TextureCoord;\n\n    void main()\n    {\n        nNormal      = normalize ( NormalMatrix * Normal );\n        eyeCoord     = vec3 ( ModelViewMatrix * VertexPosition );\n        TextureCoord = TexCoords;\n\n        gl_Position = ModelViewProjectionMatrix * VertexPosition;\n    }\n    ```", "```java\n    vec3 PhongShading( bool frontSide ){\n       // Reuse the Phong shading code.\n       return ambient + diffuse + specular;\n    }\n\n    in vec2    TextureCoord;\n    layout(location = 0) out vec4 FinalColor;\n\n       // Scale factor of the texture coord & Grid strip width\n       uniform float texCoordMultiplyFactor, stripWidth;  \n\n    void main() {\n       // multiplicationFactor scales number of stripes\n       vec2 t = TextureCoord * texCoordMultiplyFactor;\n\n       // The stripWidth is used to define the line width\n       if (fract(t.s) < stripWidth  || fract(t.t) < stripWidth ){\n       // Front Face coloring\n          if (gl_FrontFacing){ \n             FinalColor = vec4(PhongShading(true), 1.0);\n          }\n          // Back Face coloring\n          else{ \n              FinalColor = vec4(GouraudShading(false), 1.0);\n          }\n       }\n          // Throw the fragment\n          else{ \n          discard;\n       }\n    }\n    ```", "```java\nvec2 t = TextureCoord * texCoordMultiplyFactor;\n```", "```java\n   if (fract(t.s) < stripWidth  || fract(t.t) < stripWidth ){\n   //Front Face coloring  \n   if (gl_FrontFacing) \n   { outColor = vec4( GouraudShadingGouraud(true), 1.0); }\n   //Back Face coloring \n   else{ \n   { outColor = vec4( GouraudShadingGouraud(false), 1.0); }\n   }\n   // Throw the fragment \n   else{ \n   discard;\n   }\n```"]