- en: Collections Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合框架
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: How to merge two collections
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何合并两个集合
- en: Splitting original collection into pair of collections
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始集合拆分为一对集合
- en: Sorting a list by specified comparator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按指定比较器对列表进行排序
- en: Sorting in descending order
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降序排序
- en: Parsing a JSON response using Gson
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Gson 解析 JSON 响应
- en: How to filter and map using lambda expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 lambda 表达式进行过滤和映射
- en: How to sort a list of objects and keep null objects at the end
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对对象列表进行排序并保持 null 对象在末尾
- en: How to implement a lazy list in Kotlin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中实现一个懒列表
- en: How to pad a string in Kotlin
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中填充字符串
- en: How to flatten an array or map
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何展平数组或映射
- en: How to sort collection by multiple fields in Kotlin
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中按多个字段对集合进行排序
- en: How to use limit in Kotlin list
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 列表中使用 `limit`
- en: How to create a 2D array in Kotlin
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中创建二维数组
- en: How to skip the first N entries in Kotlin
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中跳过前 N 个条目
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Collections framework is useful when we want to process items in a collection.
    If you have worked with Java, you are probably familiar with collections framework.
    The most common use of collections framework are maps, sets, lists, and so on.
    Kotlin too has its collection framework, but it's much better than Java's collection
    framework because, in Kotlin, we can leverage the functional programming approach
    to make our code more concise and easy to work with. So, let's dive into the recipes
    related to Kotlin's collection framework.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要处理集合中的项目时，集合框架非常有用。如果你使用过 Java，你可能熟悉集合框架。集合框架最常见的使用是映射、集合、列表等。Kotlin 也有自己的集合框架，但它比
    Java 的集合框架更好，因为在 Kotlin 中，我们可以利用函数式编程方法使我们的代码更加简洁且易于使用。因此，让我们深入了解与 Kotlin 集合框架相关的食谱。
- en: How to merge two collections
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何合并两个集合
- en: In this recipe, we will see how to merge two or more collections into one. However,
    before we move ahead, we need to understand the difference between mutable and
    immutable types. An immutable type object is an object that cannot be changed.
    For example, if we define an immutable list, we won't be able to add other objects
    to it. With that in mind, let's start the recipe!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看到如何将两个或多个集合合并为一个。然而，在我们继续之前，我们需要了解可变类型和不可变类型之间的区别。不可变类型对象是一个不能被改变的对象。例如，如果我们定义一个不可变列表，我们就无法向其中添加其他对象。考虑到这一点，让我们开始这个食谱！
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for coding. You can use whichever IDE you like as
    long as it is able to compile and run Kotlin code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 进行编码。只要它能够编译和运行 Kotlin 代码，你可以使用你喜欢的任何 IDE。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can create a list in Kotlin with the `listOf` method. However, the list
    returned by this method is an immutable list, so we need to create a mutable list
    in order to add objects to it. Let''s check out the mentioned steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `listOf` 方法在 Kotlin 中创建一个列表。然而，此方法返回的列表是一个不可变列表，因此我们需要创建一个可变列表以便向其中添加对象。让我们查看提到的步骤：
- en: 'Let''s create two lists, `listA` and `listB`, as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建两个列表，`listA` 和 `listB`，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the type declaration is inferred from the objects inside the `listOf/mutableListOf`
    method, we won't need to declare the type declaration explicitly. So, the preceding
    code will be rewritten as `mutableListOf("a","a","b")`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型声明是从 `listOf/mutableListOf` 方法内的对象中推断出来的，我们就不需要显式地声明类型声明。因此，前面的代码将被重写为 `mutableListOf("a","a","b")`。
- en: 'Now, we will try to add the contents of `listA` in `listB`. For that purpose,
    we will require the `addAll()` method:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将尝试将 `listA` 的内容添加到 `listB` 中。为此，我们将需要 `addAll()` 方法：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s the output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another way to merge two lists is using `union`. This returns the unique elements
    of the combined collection:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并两个列表的另一种方法是使用 `union`。这返回组合集合的唯一元素：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, mutable sets can be merged too, the only difference is that `addAll`
    in a set will be similar to what we will receive with the `union` method; since
    it''s a set, only a unique value is allowed:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，可变集合也可以合并，唯一的区别是集合中的 `addAll` 将类似于我们使用 `union` 方法将获得的结果；由于它是一个集合，只允许唯一值：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want to merge two maps, you will need the `putAll()` method, as `addAll`
    and `union` are not present for the `map`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要合并两个映射，你需要 `putAll()` 方法，因为 `addAll` 和 `union` 对于 `map` 来说是不存在的：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that key `a` was defined in both the maps, but the one that comes later
    (in this case, `mapB`) wins.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，键 `a` 在两个映射中都定义了，但后来出现的那个（在这种情况下，`mapB`）是获胜者。
- en: Splitting original collection into pair of collections
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将原始集合拆分为一对集合
- en: There are times when you wish that you could just split a list into sublists
    without going into the `for` and `while` loops. Kotlin provides you with a function
    just for this occasion. In this recipe, we will see how to split a list based
    on some criteria.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能希望只需将列表拆分为子列表，而不需要进入`for`和`while`循环。Kotlin为您提供了专门为此目的的函数。在本菜谱中，我们将了解如何根据某些标准拆分列表。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用IntelliJ IDEA来编写和运行Kotlin代码；您可以使用任何能够完成相同任务的IDE。
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: 'Kotlin provides a `partition` function. According to the documentation of the
    partition function it does the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin提供了一个`partition`函数。根据`partition`函数的文档，它执行以下操作：
- en: Splits the original array into a pair of lists, where the first list contains
    elements for which predicate yielded true, while the second list contains elements
    for which predicate yielded false.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始数组拆分为一对列表，其中第一个列表包含谓词返回true的元素，而第二个列表包含谓词返回false的元素。
- en: 'Let''s understand it more clearly by going through this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个示例更清楚地理解它：
- en: 'In this example, we will create a list of numbers, and we want to split this
    list into two sublists: one having odd numbers and the other having even numbers:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，我们将创建一个数字列表，并希望将此列表拆分为两个子列表：一个包含奇数，另一个包含偶数：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see in the preceding example, we need to put the condition in the
    predicate inside the `partition` block. The returned object is a `Pair` object,
    holding the two sublists.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前一个示例所示，我们需要在`partition`块中将条件放入谓词中。返回的对象是一个`Pair`对象，包含两个子列表。
- en: 'The `partition` function also works with the `set` collection in a similar
    way:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`partition`函数也可以以类似的方式与`set`集合一起使用：'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s take a look at the implementation of the `partition` function in Kotlin:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Kotlin中`partition`函数的实现：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the `partition` function is just an abstraction, that saves
    you from writing long for loops, but internally it does it the same old way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`partition`函数只是一个抽象，它可以帮助您避免编写冗长的循环，但内部它仍然以相同的方式执行。
- en: There's more…
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `partition` function works in a similar way with arrays as well. Here are
    its different usages. Each of them works similarly, just producing lists of different
    types:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition`函数与数组一起使用时也以类似的方式工作。以下是它的不同用法。每个用法都类似，只是产生不同类型的列表：'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sorting a list by specified comparator
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据指定的比较器对列表进行排序
- en: Sorting a list is one of the most common operations done on the list. When we
    try to sort a list of custom objects, we need to specify the comparator. Let's
    see how we can sort a list by the specified comparator.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对列表进行排序是列表上执行的最常见操作之一。当我们尝试对自定义对象列表进行排序时，我们需要指定比较器。让我们看看我们如何根据指定比较器对列表进行排序。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用IntelliJ IDEA来编写和运行Kotlin代码；您可以使用任何能够完成相同任务的IDE。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: 'In the following examples, we will try to sort objects based on certain properties.
    This will give us an idea of how to sort based on the specified comparator:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将尝试根据某些属性对对象进行排序。这将给我们一个关于如何根据指定比较器进行排序的思路：
- en: 'Let''s create a `Person` class with age property. We will be sorting a list
    of person objects based on age:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个具有年龄属性的`Person`类。我们将根据年龄对人员对象列表进行排序：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To sort a list based on the specified comparator, we need to use the `sortedBy`
    function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要根据指定的比较器对列表进行排序，我们需要使用`sortedBy`函数：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Kotlin also provides a `sortedWith` method, where you can specify your own
    implementation of comparator:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin还提供了一个`sortedWith`方法，您可以在其中指定自己的比较器实现：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `sortedBy` function is syntactic sugar provided by Kotlin. Internally, it's
    calling the `sortedWith` method that takes in a comparator.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortedBy`函数是Kotlin提供的语法糖。内部，它调用接受比较器的`sortedWith`方法。'
- en: 'Now, let''s see the implementation of the `sortBy` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`sortBy`函数的实现：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `sortBy` function calls the `sortedWith` method inside it, which is as following*:*
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortBy`函数在其内部调用`sortedWith`方法，如下所示：*'
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sorting in descending order
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降序排序
- en: In the last recipe, we saw how to sort a list with a specified comparator. We
    provide the comparator, and it sorts it accordingly. Interestingly, Kotlin also
    provides a method to sort items of a list in descending order. In this recipe,
    we will see how to sort a collection of primitive objects as well as custom objects
    in descending order. So let's get started!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们看到了如何使用指定的比较器对列表进行排序。我们提供比较器，然后它按相应的方式排序。有趣的是，Kotlin还提供了一个方法来按降序对列表中的项目进行排序。在这个菜谱中，我们将看到如何按降序对原始对象以及自定义对象进行排序。所以，让我们开始吧！
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用IntelliJ IDEA来编写和运行Kotlin代码；您可以使用任何可以完成相同任务的IDE。
- en: How to do it…
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will now see how to sort in descending order using some examples:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过一些示例来了解如何使用降序排序：
- en: 'First, we will try to sort a simple list of integers:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将尝试对一个简单的整数列表进行排序：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s use our list of `Person` from the preceding recipe. To sort it
    in descending order, this is what we will do:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用前面菜谱中的`Person`列表。为了按降序排序，我们将这样做：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s the output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The `sortedByDescending` works a bit like `sortedBy`. Internally, both use
    the `sortedWith` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortedByDescending`的工作方式有点像`sortedBy`。内部，两者都使用`sortedWith`函数：'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the implementation of `compareByDescending`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`compareByDescending`的实现：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that just the order of variables is reversed to produce the descending
    order.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只需反转变量的顺序即可产生降序。
- en: Parsing a JSON response using Gson
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gson解析JSON响应
- en: In this recipe, we will learn how to parse JSON. JSON is the most widely used
    data type for API responses. We will be using Gson, an open source library by
    Google. It's fast, and it scales very well even with a huge response.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何解析JSON。JSON是API响应中最广泛使用的数据类型。我们将使用Google的开源库Gson。它速度快，即使响应很大也能很好地扩展。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio for this purpose, and JSONObject is provided
    by Android SDK. We will be using Gson for JSON parsing. You can add it to your
    project by adding the following lines to your `build.gradle` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio来完成这个任务，JSONObject由Android SDK提供。我们将使用Gson进行JSON解析。您可以通过将以下行添加到您的`build.gradle`文件中来将其添加到您的项目中：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now, let''s follow these steps to parse JSON data using Gson. For example,
    we will use a raw string here to keep things simple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤使用Gson解析JSON数据。例如，我们将在这里使用一个原始字符串来保持事情简单：
- en: 'First, we will create dummy JSON data using a raw string, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下方式创建一个模拟的JSON数据，使用原始字符串：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we will create a data class to hold this data. Here''s how our data class
    looks:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个数据类来保存这些数据。以下是我们的数据类看起来像这样：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we will use `Gson` to parse the JSON string:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`Gson`来解析JSON字符串：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now you can use it just like a Kotlin object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用它就像一个Kotlin对象一样。
- en: There's more…
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容…
- en: You can create the data class automatically using some Android Studio plugins.
    One of the most widely used plugins is **RoboPOJOGenerator** ( [https://github.com/robohorse/RoboPOJOGenerator](https://github.com/robohorse/RoboPOJOGenerator)
    ).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一些Android Studio插件自动创建数据类。最广泛使用的插件之一是**RoboPOJOGenerator** ([https://github.com/robohorse/RoboPOJOGenerator](https://github.com/robohorse/RoboPOJOGenerator)
    )。
- en: How to filter and map using lambda expressions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用lambda表达式进行过滤和映射
- en: In this recipe, we will learn how to transform a list using a `map` function
    in Kotlin, and how to filter the list with whichever criteria we like. We will
    be using lambda functions, which provide a great way to do functional programming.
    So let's get started.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用Kotlin中的`map`函数转换列表，以及如何根据我们喜欢的任何标准过滤列表。我们将使用lambda函数，它为函数式编程提供了一种很好的方式。所以，让我们开始吧。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用IntelliJ IDEA来编写和运行Kotlin代码；您可以使用任何可以完成相同任务的IDE。
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: First, let's see how to use the **filter** function on a list. The filter function
    returns a list containing all elements matching the given predicate. We will create
    a list of numbers and filter the list based on even or odd.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在列表上使用**filter**函数。filter函数返回一个包含所有匹配给定谓词的元素的列表。我们将创建一个数字列表，并根据偶数或奇数来过滤列表。
- en: The `filter` method is good for an immutable collection as it doesn't modify
    the original collection but returns a new one. In the filter method, we need to
    implement the predicate. The predicate, like the condition, is based on the list
    that is filtered.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法对于不可变集合很好，因为它不会修改原始集合，而是返回一个新的集合。在`filter`方法中，我们需要实现谓词。谓词，就像条件一样，基于被过滤的列表。'
- en: 'For example, we know that even items will follow `it%2==0`. So the corresponding
    filter method will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们知道偶数项将遵循`it%2==0`。因此，相应的过滤方法将如下所示：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Another variant of the filter function is `filterNot`, which, as the name suggests,
    returns a list containing all elements not matching the given predicate.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤函数的另一个变体是`filterNot`，正如其名称所暗示的，它返回一个包含所有不匹配给定谓词的元素的列表。
- en: 'Another cool lambda function is `map`. It transforms the list and returns a
    new one:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个酷炫的lambda函数是`map`。它转换列表并返回一个新的列表：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A variant of the `map` function is `mapIndexed`. It provides the index along
    with the item in its construct:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数的一个变体是`mapIndexed`。它在其构造中提供了索引和项：'
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How to sort a list of objects and keep null objects at the end
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何对列表中的对象进行排序并保持null对象在末尾
- en: We have already seen how to sort a list based on a specified parameter using
    a comparator. However, so far, we have worked with lists having non-null values.
    In this recipe, we will see how to sort a list of objects, which have the null
    property (on which we are sorting). So let's get started.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用比较器根据指定参数对列表进行排序。然而，到目前为止，我们一直在处理具有非null值的列表。在这个菜谱中，我们将看到如何对具有null属性（我们根据该属性进行排序）的对象列表进行排序。所以让我们开始吧。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用IntelliJ IDEA来编写和运行Kotlin代码；你可以自由使用任何可以完成相同任务的IDE。
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Now, let''s follow these steps to sort a list, while keeping null objects at
    the end:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们遵循以下步骤来排序列表，同时保持null对象在末尾：
- en: 'Let''s create a `Person` class having an age property that can be null:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个具有年龄属性（可以是null）的`Person`类：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s create a list of `Person` objects:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`Person`对象列表：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we want to sort them in ascending order, while keeping the null items
    at the end:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望按升序对它们进行排序，同时保持null项在末尾：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We have used the `sortedWith` method. According to documentation, `sortedWith`
    does this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`sortedWith`方法。根据文档，`sortedWith`是这样做的：
- en: Returns a sequence that yields elements of this sequence sorted according to
    the specified comparator.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个序列，该序列根据指定的比较器生成此序列的元素。
- en: 'Apart from that, we''ve made use of the `kotlin.comparisons` package, which
    provides us two main functions used in the preceding solution:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了那个之外，我们还使用了`kotlin.comparisons`包，它为我们提供了在前面解决方案中使用的主要两个函数：
- en: '`public inline fun <T: Comparable<T>> nullsLast()`: This method provides a
    comparator of nullable comparable values considering null value greater than any
    other value. That''s how we can get the null items at the end, because they are
    considered bigger than any other values.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public inline fun <T: Comparable<T>> nullsLast()`: 这个方法提供了一个比较器，用于考虑可空可比较值，其中null值大于任何其他值。这就是我们能够在末尾获取null项的原因，因为它们被认为比任何其他值都大。'
- en: '`compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K)`:
    This function accepts a comparator (such as `nullsLast()`) and a function that
    provides values for the comparator, and then combines them into a new comparator.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K)`:
    这个函数接受一个比较器（例如`nullsLast()`）和一个为比较器提供值的函数，然后将它们组合成一个新的比较器。'
- en: How to implement a lazy list in Kotlin
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中实现懒列表的方法
- en: 'If the value of an element or expression is not evaluated when it''s defined,
    but rather when it is first accessed, it is said to be **lazily evaluated**. There
    are many situations where it comes in handy. For example, you might have a list
    A and you want to create a filtered list from it, let''s call it list B. If you
    do something like the following, the filter operation will be performed during
    the declaration of B:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个元素或表达式的值在定义时没有被评估，而是在首次访问时才被评估，那么它被称为**延迟评估**。有许多情况它都很有用。例如，你可能有一个列表A，你想要从它创建一个过滤后的列表，让我们称它为列表B。如果你做如下操作，过滤操作将在B的声明期间执行：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This forces the program to initialize B as soon as it is defined. While this
    may not be a big deal for a small list, it can cause latency with bigger objects.
    Also, we can delay the object creation until we first need it. In this recipe,
    we will learn how we can implement a lazy list.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使程序在定义 B 时立即初始化它。虽然这对小列表来说可能不是什么大问题，但它可能导致大对象的延迟。此外，我们可以在第一次需要时再创建对象。在这个菜谱中，我们将学习如何实现一个惰性列表。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 来编写和运行 Kotlin 代码；您可以使用任何可以完成相同任务的 IDE。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现它…
- en: 'To create a lazy list, we need to convert the list into a sequence. A sequence represents
    lazily evaluated collections. Let''s understand it with an example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个惰性列表，我们需要将列表转换为序列。序列表示惰性评估的集合。让我们用一个例子来理解它：
- en: 'In the given example, let''s first filter a list based on elements being odd
    or even:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的例子中，让我们首先根据元素是奇数还是偶数来过滤列表：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is the output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding example, the filter function was evaluated only when the object
    was defined.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`filter` 函数仅在对象被定义时被评估。
- en: 'Now, let''s convert the list into a sequence. Converting the list to a sequence
    is just one step away; you can convert any list to a sequence using the `.asSequence()` method,
    or by `Sequence{ createIterator() }`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将列表转换为序列。将列表转换为序列只需一步之遥；您可以使用 `.asSequence()` 方法或通过 `Sequence{ createIterator()
    }` 将任何列表转换为序列：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you run the preceding code, you won''t see any output in the console, because
    the object hasn''t been created yet. It will be created when list B is first accessed:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行前面的代码，您在控制台中将看不到任何输出，因为对象尚未创建。它将在列表 B 首次访问时创建：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `filter` function was evaluated when the items were accessed. This is called
    **lazy evaluation**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问项目时，`filter` 函数被评估。这被称为**惰性求值**。
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Sequences in Kotlin are potentially unbounded and are used when the length
    of the list is not known in advance (much like Streams in Java 8). Since it can
    be infinite, lazy evaluation is needed for this type of structure. Consider this
    example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的序列可能是无界的，并且当列表的长度事先未知时（类似于 Java 8 中的 Streams）会使用它。由于它可以无限大，因此需要惰性求值来处理这种类型的结构。考虑以下示例：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, `generateSequence` generates a sequence of infinite numbers, but when
    we call `take(10)`, only 10 items are evaluated and printed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`generateSequence` 生成一个无限数字的序列，但当我们调用 `take(10)` 时，只有 10 个项目被评估和打印。
- en: How to pad a string in Kotlin
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中填充字符串
- en: Sometimes, to keep up with the length of the string, we pad the string with
    some characters. In many communication protocols, keeping the standard length
    of the payload is vital.  Kotlin makes it very easy to pad the string with any
    character and length. Let's see how to use it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了保持字符串的长度，我们会用一些字符填充字符串。在许多通信协议中，保持有效载荷的标准长度至关重要。Kotlin 使得用任何字符和长度填充字符串变得非常容易。让我们看看如何使用它。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 来编写和运行 Kotlin 代码；您可以使用任何可以完成相同任务的 IDE。
- en: How to do it…
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现它…
- en: 'In this recipe, we will use the `kotlin.stdlib` library of Kotlin. Specifically,
    we will be working with the `padStart` and `padEnd` functions. Let''s now follow
    the given steps to understand how to use these functions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Kotlin 的 `kotlin.stdlib` 库。具体来说，我们将使用 `padStart` 和 `padEnd` 函数。现在，让我们按照给定的步骤来了解如何使用这些函数：
- en: 'Let''s see an example of the `padStart` function:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看 `padStart` 函数的一个例子：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is the output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we look at an example of `padEnd`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们看看 `padEnd` 的一个例子：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here''s the output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The padding functions are needed to expand the string to a certain length using
    the character provided with the function. So, if the length of the padded string
    is less than the string itself, it will just return the same string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 填充函数需要使用函数提供的字符将字符串扩展到一定长度。因此，如果填充后的字符串长度小于原始字符串，它将只返回相同的字符串。
- en: 'Another key thing to note is that by default, the padding character is a space
    character. This is the implementation of the `padStart` function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的关键点是，默认情况下，填充字符是空格字符。这是 `padStart` 函数的实现：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, the default value for `padChar` is a space character, and it
    is called on a String object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`padChar` 的默认值是空格字符，并且它是在一个字符串对象上调用的。
- en: How to flatten an array or map
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何展开数组或映射
- en: In the previous few recipes of this chapter, we learned how to create multidimension
    arrays. In this recipe, we will see how we can convert them to a 1D list, or *flatten*
    it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几个食谱中，我们学习了如何创建多维数组。在本食谱中，我们将看到如何将它们转换为 1D 列表，或 *flatten* 它们。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 编写和运行 Kotlin 代码；您可以使用任何可以完成相同任务的 IDE。
- en: How to do it…
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We will be using the `.flatten` method of the `kotlin.stdlib` library. It takes
    in an array or collection and returns a single list of all elements from all collections/arrays
    in the given collection/array.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `kotlin.stdlib` 库的 `.flatten` 方法。它接受一个数组或集合，并返回一个包含给定集合/数组中所有元素的单一列表。
- en: 'For example, with an array of arrays:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用数组数组：
- en: '`[[1,2,3],[1,2,3],[1,2,3]] -> [1,2,3,1,2,3,1,2,3]`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[1,2,3],[1,2,3],[1,2,3]] -> [1,2,3,1,2,3,1,2,3]`'
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For example, with a list of lists:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用列表列表：
- en: '`[[1,2,3],[1,2,3],[1,2,3]] -> [1,2,3,1,2,3,1,2,3]`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[1,2,3],[1,2,3],[1,2,3]] -> [1,2,3,1,2,3,1,2,3]`'
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s take a look at the implementation of the `flatten()` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `flatten()` 函数的实现：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, it's just adding the items from iterables (array or lists) in
    a new list and returning that list.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这只是在新的列表中添加来自可迭代对象（数组或列表）的项目，并返回该列表。
- en: How to sort collection by multiple fields in Kotlin
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中按多个字段排序集合
- en: In this recipe, we will learn how to sort a collection by multiple fields in
    Kotlin. This often comes in handy when we want to give precedence to an object
    over another object when both have equal value on a specific property. For example,
    we might have a list of `Student` objects and want to arrange them in ascending
    order of age, but if two students have the same age, we will order them based
    on their GPA. In this recipe, we will see how to handle use cases like this. So
    let's get started!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在 Kotlin 中按多个字段对集合进行排序。当我们想要在两个对象在特定属性上具有相等值时给予一个对象比另一个对象优先权时，这通常很有用。例如，我们可能有一个
    `Student` 对象的列表，并希望按年龄升序排列它们，但如果两个学生的年龄相同，我们将根据他们的 GPA 排序。在本食谱中，我们将看到如何处理此类用例。那么，让我们开始吧！
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 编写和运行 Kotlin 代码；您可以使用任何可以完成相同任务的 IDE。
- en: How to do it…
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Now, let''s follow these steps to sort based on multiple fields of an object:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤根据对象的多个字段进行排序：
- en: 'First, let''s create the `Student` class:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建 `Student` 类：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, create a list of `Student` objects:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个 `Student` 对象的列表：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To sort it on multiple fields, we simply need to do this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按多个字段排序，我们只需这样做：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we print it now, we will get the following output:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在打印它，我们将得到以下输出：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have used the `sortedWith` function, which takes in a comparator. The comparator
    is provided by the `compareBy` function. The `compareBy` has an overload that
    takes multiple functions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `sortedWith` 函数，它接受一个比较器。比较器由 `compareBy` 函数提供。`compareBy` 有一个可以接受多个函数的重载：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see in the preceding code, `vararg` allows us to take multiple functions
    in its construct and returns a comparator, which feeds the `sortedWith` function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面代码中所见，`vararg` 允许我们在其构造函数中接受多个函数，并返回一个比较器，该比较器将数据传递给 `sortedWith` 函数。
- en: Note that sorting with multiple fields works like sort by field 1, then by field
    2, then by field 3, and so on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用多个字段排序的工作方式是按字段 1 排序，然后按字段 2 排序，然后按字段 3 排序，依此类推。
- en: How to use limit in Kotlin list
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 列表中使用 limit
- en: In this recipe, we will learn how to take specific items from the list. We will
    use the `kotlin.stdlib` library for this purpose.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何从列表中获取特定项。我们将为此目的使用 `kotlin.stdlib` 库。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 编写和运行 Kotlin 代码；您可以使用任何可以完成相同任务的 IDE。
- en: How to do it…
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We will be using the `take` function and its variants for limiting the items
    in the list.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `take` 函数及其变体来限制列表中的项。
- en: '`take(n)`: Returns a list of the first n items:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`take(n)`: 返回前 n 个元素的列表：'
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`takeLast(n)`: Returns a list containing the last [n] elements:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeLast(n)`: 返回包含最后 [n] 个元素的列表：'
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`takeWhile{ predicate }`: Returns a list containing the first elements satisfying
    the given [predicate]:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeWhile{ predicate }`: 返回包含满足给定 [谓词] 的第一个元素的列表：'
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`takeLastWhile{predicate}`: Works a bit like `takeWhile`, except that it evaluates
    the list from the end.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeLastWhile{谓词}`：与 `takeWhile` 类似，但它从列表的末尾评估。'
- en: '`takeIf { predicate }`: Returns `` `this` `` value if it satisfies the given
    [predicate], or `` `null` `` if it doesn''t:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeIf { 谓词 }`：如果它满足给定的 [谓词]，则返回 `this` 值，如果不满足，则返回 `null`：'
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that the `it` inside the `takeIf` lambda represents the list itself, and
    not just an element of list.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`takeIf` lambda 中的 `it` 代表列表本身，而不仅仅是列表的一个元素。
- en: How to create a 2D array in Kotlin
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中创建二维数组
- en: '2D arrays are useful for data representation in certain situations such as
    board games, images, and so on. In Java, we can represent a 2D array by doing
    the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如棋盘游戏、图像等，二维数组对于数据表示非常有用。在 Java 中，我们可以通过以下方式表示二维数组：
- en: '[PRE68]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Since Kotlin brings new syntax, let's see how to work with a 2D array in Kotlin.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kotlin 带来了新的语法，让我们看看如何在 Kotlin 中处理二维数组。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 编写和运行 Kotlin 代码；你可以自由使用任何可以完成相同任务的 IDE。
- en: How to do it…
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s now follow the given steps to create a 2D array in Kotlin:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照给定的步骤在 Kotlin 中创建一个二维数组：
- en: 'We can create a simple 2D array in Kotlin using this syntax:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法在 Kotlin 中创建一个简单的二维数组：
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, `n` represents the dimension of the array. Here, we have used the `Array`
    class of Kotlin, which represents an array (specifically, a Java array when targeting
    the JVM platform). We have initialized the `Array` object by passing the size
    and initializer:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`n` 代表数组的维度。在这里，我们使用了 Kotlin 的 `Array` 类，它代表一个数组（特别是当针对 JVM 平台时，是 Java 数组）。我们通过传递大小和初始化器来初始化
    `Array` 对象：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Our dimension is `n`, and as an initializer, we are passing a 1D array, which
    then gives a structure of a 2D array. If you want to initialize the 2D array with
    a specific value, you need to pass it in the initializer. Consider this example:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的维度是 `n`，作为初始化器，我们传递一个一维数组，然后它提供了一个二维数组的结构。如果你想要使用特定的值初始化二维数组，你需要将其传递给初始化器。考虑以下示例：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The preceding 2D array will be initialized by all `-1`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述二维数组将被初始化为所有 `-1`。
- en: 'We can also use the `arrayOf` construct to create a 2D array by passing two
    1D arrays:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用 `arrayOf` 构造函数通过传递两个一维数组来创建一个二维数组：
- en: '[PRE72]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: There's more…
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can also create your own function by extending Kotlin''s code. For example,
    creating a method, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过扩展 Kotlin 的代码来创建自己的函数。例如，创建一个方法，如下所示：
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This can enable you to create a 2D array quite easily, just by doing the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下操作轻松创建二维数组：
- en: '[PRE74]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can also create a list of lists in a similar fashion. Here''s an example
    of a list of lists:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以以类似的方式创建一个列表的列表。以下是一个列表的列表的示例：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is its output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的输出：
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How to skip the first "n" entries in Kotlin
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中跳过前 "n" 个条目
- en: In this recipe, we will learn how to drop entries in a collection. First, we
    will see how to drop the first *n* items, then we will see how to drop the last
    *n* items, and finally, we will see how to use a predicate while dropping the
    elements from the collection.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在集合中删除条目。首先，我们将看到如何删除前 *n* 个项目，然后我们将看到如何删除最后 *n* 个项目，最后，我们将看到如何在删除集合中的元素时使用谓词。
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 编写和运行 Kotlin 代码；你可以自由使用任何可以完成相同任务的 IDE。
- en: How to do it…
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the following steps, we will learn to skip the first *n* entries of a Kotlin
    list:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何跳过 Kotlin 列表中的前 *n* 个条目：
- en: 'First, let''s see how to drop the first *n* items in a collection. We will
    be using a list, but it also works with an array. Also, we will be using `kotlin.stdlib`, which
    contains the functions required in this recipe. The function to use here is `drop`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何删除集合中的前 *n* 个项目。我们将使用列表，但它也可以与数组一起使用。此外，我们将使用 `kotlin.stdlib`，它包含本食谱中所需的函数。这里要使用的函数是
    `drop`：
- en: '[PRE77]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To skip the last *n* items in the collection, you need to use the `dropLast` function:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要跳过集合中的最后 *n* 个项目，你需要使用 `dropLast` 函数：
- en: '[PRE78]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This lambda function drops the item while the predicate returns true:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 lambda 函数在谓词返回 true 时删除项目：
- en: '[PRE79]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This function drops the items at the end while the condition is satisfied.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数在满足条件的情况下删除末尾的项目。
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works…
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `drop` function returns a new list by skipping the first n items. Internally,
    it just uses the usual `for` loops and performs some checks on whether the input
    is an array or a list.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop` 函数通过跳过前 n 个元素返回一个新的列表。内部实现上，它只是使用了普通的 `for` 循环，并对输入是否为数组或列表进行了一些检查。'
