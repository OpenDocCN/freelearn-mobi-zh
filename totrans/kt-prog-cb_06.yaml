- en: Collections Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to merge two collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting original collection into pair of collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a list by specified comparator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting in descending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a JSON response using Gson
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to filter and map using lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to sort a list of objects and keep null objects at the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a lazy list in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to pad a string in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to flatten an array or map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to sort collection by multiple fields in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use limit in Kotlin list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a 2D array in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to skip the first N entries in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections framework is useful when we want to process items in a collection.
    If you have worked with Java, you are probably familiar with collections framework.
    The most common use of collections framework are maps, sets, lists, and so on.
    Kotlin too has its collection framework, but it's much better than Java's collection
    framework because, in Kotlin, we can leverage the functional programming approach
    to make our code more concise and easy to work with. So, let's dive into the recipes
    related to Kotlin's collection framework.
  prefs: []
  type: TYPE_NORMAL
- en: How to merge two collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to merge two or more collections into one. However,
    before we move ahead, we need to understand the difference between mutable and
    immutable types. An immutable type object is an object that cannot be changed.
    For example, if we define an immutable list, we won't be able to add other objects
    to it. With that in mind, let's start the recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for coding. You can use whichever IDE you like as
    long as it is able to compile and run Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create a list in Kotlin with the `listOf` method. However, the list
    returned by this method is an immutable list, so we need to create a mutable list
    in order to add objects to it. Let''s check out the mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two lists, `listA` and `listB`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the type declaration is inferred from the objects inside the `listOf/mutableListOf`
    method, we won't need to declare the type declaration explicitly. So, the preceding
    code will be rewritten as `mutableListOf("a","a","b")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will try to add the contents of `listA` in `listB`. For that purpose,
    we will require the `addAll()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to merge two lists is using `union`. This returns the unique elements
    of the combined collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, mutable sets can be merged too, the only difference is that `addAll`
    in a set will be similar to what we will receive with the `union` method; since
    it''s a set, only a unique value is allowed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to merge two maps, you will need the `putAll()` method, as `addAll`
    and `union` are not present for the `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that key `a` was defined in both the maps, but the one that comes later
    (in this case, `mapB`) wins.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting original collection into pair of collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you wish that you could just split a list into sublists
    without going into the `for` and `while` loops. Kotlin provides you with a function
    just for this occasion. In this recipe, we will see how to split a list based
    on some criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin provides a `partition` function. According to the documentation of the
    partition function it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Splits the original array into a pair of lists, where the first list contains
    elements for which predicate yielded true, while the second list contains elements
    for which predicate yielded false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand it more clearly by going through this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create a list of numbers, and we want to split this
    list into two sublists: one having odd numbers and the other having even numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, we need to put the condition in the
    predicate inside the `partition` block. The returned object is a `Pair` object,
    holding the two sublists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `partition` function also works with the `set` collection in a similar
    way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of the `partition` function in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `partition` function is just an abstraction, that saves
    you from writing long for loops, but internally it does it the same old way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `partition` function works in a similar way with arrays as well. Here are
    its different usages. Each of them works similarly, just producing lists of different
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sorting a list by specified comparator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting a list is one of the most common operations done on the list. When we
    try to sort a list of custom objects, we need to specify the comparator. Let's
    see how we can sort a list by the specified comparator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following examples, we will try to sort objects based on certain properties.
    This will give us an idea of how to sort based on the specified comparator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `Person` class with age property. We will be sorting a list
    of person objects based on age:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort a list based on the specified comparator, we need to use the `sortedBy`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin also provides a `sortedWith` method, where you can specify your own
    implementation of comparator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sortedBy` function is syntactic sugar provided by Kotlin. Internally, it's
    calling the `sortedWith` method that takes in a comparator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the implementation of the `sortBy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `sortBy` function calls the `sortedWith` method inside it, which is as following*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Sorting in descending order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we saw how to sort a list with a specified comparator. We
    provide the comparator, and it sorts it accordingly. Interestingly, Kotlin also
    provides a method to sort items of a list in descending order. In this recipe,
    we will see how to sort a collection of primitive objects as well as custom objects
    in descending order. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now see how to sort in descending order using some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will try to sort a simple list of integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use our list of `Person` from the preceding recipe. To sort it
    in descending order, this is what we will do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sortedByDescending` works a bit like `sortedBy`. Internally, both use
    the `sortedWith` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the implementation of `compareByDescending`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that just the order of variables is reversed to produce the descending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a JSON response using Gson
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to parse JSON. JSON is the most widely used
    data type for API responses. We will be using Gson, an open source library by
    Google. It's fast, and it scales very well even with a huge response.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ll be using Android Studio for this purpose, and JSONObject is provided
    by Android SDK. We will be using Gson for JSON parsing. You can add it to your
    project by adding the following lines to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s follow these steps to parse JSON data using Gson. For example,
    we will use a raw string here to keep things simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create dummy JSON data using a raw string, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a data class to hold this data. Here''s how our data class
    looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will use `Gson` to parse the JSON string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use it just like a Kotlin object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create the data class automatically using some Android Studio plugins.
    One of the most widely used plugins is **RoboPOJOGenerator** ( [https://github.com/robohorse/RoboPOJOGenerator](https://github.com/robohorse/RoboPOJOGenerator)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: How to filter and map using lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to transform a list using a `map` function
    in Kotlin, and how to filter the list with whichever criteria we like. We will
    be using lambda functions, which provide a great way to do functional programming.
    So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's see how to use the **filter** function on a list. The filter function
    returns a list containing all elements matching the given predicate. We will create
    a list of numbers and filter the list based on even or odd.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` method is good for an immutable collection as it doesn't modify
    the original collection but returns a new one. In the filter method, we need to
    implement the predicate. The predicate, like the condition, is based on the list
    that is filtered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we know that even items will follow `it%2==0`. So the corresponding
    filter method will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Another variant of the filter function is `filterNot`, which, as the name suggests,
    returns a list containing all elements not matching the given predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another cool lambda function is `map`. It transforms the list and returns a
    new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A variant of the `map` function is `mapIndexed`. It provides the index along
    with the item in its construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How to sort a list of objects and keep null objects at the end
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen how to sort a list based on a specified parameter using
    a comparator. However, so far, we have worked with lists having non-null values.
    In this recipe, we will see how to sort a list of objects, which have the null
    property (on which we are sorting). So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s follow these steps to sort a list, while keeping null objects at
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `Person` class having an age property that can be null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a list of `Person` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to sort them in ascending order, while keeping the null items
    at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used the `sortedWith` method. According to documentation, `sortedWith`
    does this:'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a sequence that yields elements of this sequence sorted according to
    the specified comparator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from that, we''ve made use of the `kotlin.comparisons` package, which
    provides us two main functions used in the preceding solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public inline fun <T: Comparable<T>> nullsLast()`: This method provides a
    comparator of nullable comparable values considering null value greater than any
    other value. That''s how we can get the null items at the end, because they are
    considered bigger than any other values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K)`:
    This function accepts a comparator (such as `nullsLast()`) and a function that
    provides values for the comparator, and then combines them into a new comparator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a lazy list in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the value of an element or expression is not evaluated when it''s defined,
    but rather when it is first accessed, it is said to be **lazily evaluated**. There
    are many situations where it comes in handy. For example, you might have a list
    A and you want to create a filtered list from it, let''s call it list B. If you
    do something like the following, the filter operation will be performed during
    the declaration of B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This forces the program to initialize B as soon as it is defined. While this
    may not be a big deal for a small list, it can cause latency with bigger objects.
    Also, we can delay the object creation until we first need it. In this recipe,
    we will learn how we can implement a lazy list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a lazy list, we need to convert the list into a sequence. A sequence represents
    lazily evaluated collections. Let''s understand it with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the given example, let''s first filter a list based on elements being odd
    or even:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the filter function was evaluated only when the object
    was defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s convert the list into a sequence. Converting the list to a sequence
    is just one step away; you can convert any list to a sequence using the `.asSequence()` method,
    or by `Sequence{ createIterator() }`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you won''t see any output in the console, because
    the object hasn''t been created yet. It will be created when list B is first accessed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` function was evaluated when the items were accessed. This is called
    **lazy evaluation**.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequences in Kotlin are potentially unbounded and are used when the length
    of the list is not known in advance (much like Streams in Java 8). Since it can
    be infinite, lazy evaluation is needed for this type of structure. Consider this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, `generateSequence` generates a sequence of infinite numbers, but when
    we call `take(10)`, only 10 items are evaluated and printed.
  prefs: []
  type: TYPE_NORMAL
- en: How to pad a string in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, to keep up with the length of the string, we pad the string with
    some characters. In many communication protocols, keeping the standard length
    of the payload is vital.  Kotlin makes it very easy to pad the string with any
    character and length. Let's see how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the `kotlin.stdlib` library of Kotlin. Specifically,
    we will be working with the `padStart` and `padEnd` functions. Let''s now follow
    the given steps to understand how to use these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of the `padStart` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we look at an example of `padEnd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The padding functions are needed to expand the string to a certain length using
    the character provided with the function. So, if the length of the padded string
    is less than the string itself, it will just return the same string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another key thing to note is that by default, the padding character is a space
    character. This is the implementation of the `padStart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the default value for `padChar` is a space character, and it
    is called on a String object.
  prefs: []
  type: TYPE_NORMAL
- en: How to flatten an array or map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous few recipes of this chapter, we learned how to create multidimension
    arrays. In this recipe, we will see how we can convert them to a 1D list, or *flatten*
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the `.flatten` method of the `kotlin.stdlib` library. It takes
    in an array or collection and returns a single list of all elements from all collections/arrays
    in the given collection/array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with an array of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[1,2,3],[1,2,3],[1,2,3]] -> [1,2,3,1,2,3,1,2,3]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, with a list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[1,2,3],[1,2,3],[1,2,3]] -> [1,2,3,1,2,3,1,2,3]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of the `flatten()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's just adding the items from iterables (array or lists) in
    a new list and returning that list.
  prefs: []
  type: TYPE_NORMAL
- en: How to sort collection by multiple fields in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to sort a collection by multiple fields in
    Kotlin. This often comes in handy when we want to give precedence to an object
    over another object when both have equal value on a specific property. For example,
    we might have a list of `Student` objects and want to arrange them in ascending
    order of age, but if two students have the same age, we will order them based
    on their GPA. In this recipe, we will see how to handle use cases like this. So
    let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s follow these steps to sort based on multiple fields of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the `Student` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a list of `Student` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort it on multiple fields, we simply need to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print it now, we will get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used the `sortedWith` function, which takes in a comparator. The comparator
    is provided by the `compareBy` function. The `compareBy` has an overload that
    takes multiple functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, `vararg` allows us to take multiple functions
    in its construct and returns a comparator, which feeds the `sortedWith` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that sorting with multiple fields works like sort by field 1, then by field
    2, then by field 3, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to use limit in Kotlin list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to take specific items from the list. We will
    use the `kotlin.stdlib` library for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the `take` function and its variants for limiting the items
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`take(n)`: Returns a list of the first n items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`takeLast(n)`: Returns a list containing the last [n] elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`takeWhile{ predicate }`: Returns a list containing the first elements satisfying
    the given [predicate]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`takeLastWhile{predicate}`: Works a bit like `takeWhile`, except that it evaluates
    the list from the end.'
  prefs: []
  type: TYPE_NORMAL
- en: '`takeIf { predicate }`: Returns `` `this` `` value if it satisfies the given
    [predicate], or `` `null` `` if it doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `it` inside the `takeIf` lambda represents the list itself, and
    not just an element of list.
  prefs: []
  type: TYPE_NORMAL
- en: How to create a 2D array in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2D arrays are useful for data representation in certain situations such as
    board games, images, and so on. In Java, we can represent a 2D array by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Since Kotlin brings new syntax, let's see how to work with a 2D array in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now follow the given steps to create a 2D array in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a simple 2D array in Kotlin using this syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `n` represents the dimension of the array. Here, we have used the `Array`
    class of Kotlin, which represents an array (specifically, a Java array when targeting
    the JVM platform). We have initialized the `Array` object by passing the size
    and initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Our dimension is `n`, and as an initializer, we are passing a 1D array, which
    then gives a structure of a 2D array. If you want to initialize the 2D array with
    a specific value, you need to pass it in the initializer. Consider this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The preceding 2D array will be initialized by all `-1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also use the `arrayOf` construct to create a 2D array by passing two
    1D arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also create your own function by extending Kotlin''s code. For example,
    creating a method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This can enable you to create a 2D array quite easily, just by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a list of lists in a similar fashion. Here''s an example
    of a list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: How to skip the first "n" entries in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to drop entries in a collection. First, we
    will see how to drop the first *n* items, then we will see how to drop the last
    *n* items, and finally, we will see how to use a predicate while dropping the
    elements from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and running Kotlin code; you are free
    to use any IDE that can do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will learn to skip the first *n* entries of a Kotlin
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how to drop the first *n* items in a collection. We will
    be using a list, but it also works with an array. Also, we will be using `kotlin.stdlib`, which
    contains the functions required in this recipe. The function to use here is `drop`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To skip the last *n* items in the collection, you need to use the `dropLast` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This lambda function drops the item while the predicate returns true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This function drops the items at the end while the condition is satisfied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `drop` function returns a new list by skipping the first n items. Internally,
    it just uses the usual `for` loops and performs some checks on whether the input
    is an array or a list.
  prefs: []
  type: TYPE_NORMAL
