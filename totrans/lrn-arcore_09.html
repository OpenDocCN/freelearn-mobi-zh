<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Blending Light for Architectural Design</h1>
                </header>
            
            <article>
                
<p class="mce-root">This is the first of two chapters where we will build real-world AR apps that you can learn from and show off to friends and family. Unlike in the previous chapters, this time we will build our AR app from nothing. That way, we can learn the specific details needed for incorporating ARCore into a Unity project. We have a lot to cover in this chapter, so let's get started. Listed here is a quick summary of the main topics we will cover:</p>
<ul>
<li>Setting up the project</li>
<li><span>P</span>lacing content</li>
<li><span>Building the UI</span></li>
<li>Interacting with the virtual</li>
<li>Lighting and shadows</li>
</ul>
<p>The premise for our app will be an AR tool for architecture and design. The designing apps are very popular in AR right now and fit very well with the toolkit ARCore provides.</p>
<div class="mce-root packt_infobox">Being able to virtually place objects in or over a real-world object and instantly see how it looks has a tremendous benefit to designers and architects. Now a designer using an AR app can instantly transform a space with their vision. Imagine never having to move a couch 15 times to get it just right, ever again.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the project</h1>
                </header>
            
            <article>
                
<p>We will use the sample project as a template for creating a new project. At the time of writing, doing an ARCore asset import with the beta version still requires considerable project setup. Ideally, we would like to create a project from scratch, but we will do the next best thing. The next best thing will be to clone the project from GitHub into a new folder of our choice. You can start by opening up Command Prompt and following these steps:</p>
<ol>
<li>Create a new folder off your root or working folder and download the ARCore template by executing the following commands:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir ARCore</strong><br/><strong>cd ARCore</strong><br/><strong>git clone https://github.com/google-ar/arcore-unity-sdk.git ARCoreDesign</strong></pre>
<ol start="2">
<li>This will create a new folder. Switch to it and download the project template from GitHub.</li>
<li>Open up Unity to the project dialog and click on <span class="packt_screen"><strong>Open</strong></span>.</li>
<li>Use the folder dialog to find and select the <kbd>ARCoreDesign</kbd> folder we just downloaded the code to, as shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/03d52c88-72fb-43a3-932b-7903453ced1b.png" style="width:58.17em;height:38.83em;"/><span><br/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Opening the ARCoreDesign project</div>
<ol start="5">
<li>Wait for Unity to load. <span>Ensure that you watch for any compiler errors at the bottom of the editor status bar. If you see them, it means you may have a version conflict or that something's changed. Check your version and try to upgrade or downgrade, as needed.</span></li>
<li>The first thing we will do is organize our folder structure. Create a new folder called <kbd>ARCore<span><span>_</span></span>Design</kbd><strong> </strong>in the <span class="packt_screen">Project</span> window by right-clicking (<em>Ctrl</em> + Click on Mac) on the <kbd>Assets</kbd> folder and selecting <span class="packt_screen">Create</span> | <span class="packt_screen">Folder</span> from the context menu.</li>
</ol>
<p> </p>
<ol start="7">
<li>Directly underneath the new folder, add folders for <kbd>Scripts</kbd>, <kbd>Prefabs</kbd>, <kbd>Scenes</kbd>, <kbd>Materials</kbd>, and <kbd>Models</kbd>, as illustrated:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/ed9bedf2-bf49-4779-b1d0-121514a3d820.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting up the folder structure</div>
<p>The technique we just used for setting up the project is useful when you are dealing with other sample projects you want to make your own. Unity manages a project by the folder and the name corresponds to the folder name. We won't worry about setting up source control as you can do this on your own, as you see fit.</p>
<div class="packt_tip">If you are setting up this project for anything other than learning, you should definitely consider a source code solution at this point. Dropbox or other file sharing solutions will work in a pinch, but it's not something that will work for more than one developer. There are plenty of free and fairly simple solutions that work with Unity, so take some time and pick one that works for you.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the scene</h1>
                </header>
            
            <article>
                
<p>In order for us to save some time, we will load the <kbd>HelloAR</kbd> scene and modify it to meet our needs. Follow along the given steps:</p>
<ol>
<li>Open the <kbd>HelloAR</kbd> scene in the <kbd>Assets/GoogleARCore/HelloARExample/Scenes</kbd> folder by double-clicking on it.</li>
<li>From the menu, select <span class="packt_screen">File</span> | <span class="packt_screen">Save Scene as</span>, save the scene in the new <kbd>Assets/ARCore_Design/Scenes</kbd> folder, and name it as <kbd>Main</kbd>.</li>
</ol>
<div class="packt_infobox">Apart from the samples we worked with earlier, from now on, if we need to modify a file, we will copy it to a new appropriate folder, and rename it. This is a good practice to follow when modifying external assets. That way, when you update the asset with a new version, your changes will not be overwritten.</div>
<ol start="3">
<li>From the menu, select <strong><span class="packt_screen">Edit</span></strong> | <strong><span class="packt_screen">Project Settings</span></strong> | <strong><span class="packt_screen">Player</span></strong>. </li>
<li>At the <span class="packt_screen">Inspector</span> window, click on the <span class="packt_screen">Android</span> tab and edit the <span class="packt_screen">Package Name</span> to <kbd>com.Packt.ARCoreDesign</kbd>, as shown in the following screen excerpt:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="assets/490bff9b-fa75-4704-b508-4a05bd59a6db.png" style="width:23.92em;height:40.33em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Editing the package name in the Player settings</div>
<ol start="5">
<li>From the menu, select <span class="packt_screen">File</span> | <span class="packt_screen">Build Settings</span>.</li>
<li>Click on the checkbox on the <kbd>HelloAR</kbd> scene to turn it off. Then, click on <span class="packt_screen">Add Open Scenes</span> to add the new <kbd>Main</kbd> scene to the build. Ensure that the <span class="packt_screen">Android</span> option is selected for the <span class="packt_screen">Platform</span>, and confirm that everything is set, as shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/5ee94210-c52d-48bf-92cd-c6fa1f99826f.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the Build Settings</div>
<ol start="7">
<li>
<p>Connect your device and then click on <span class="packt_screen">Build And Run</span>. You will be prompted to save the APK. Enter the same name you used for the package (<kbd>com.Packt.ARCoreDesign</kbd>) and click on <span class="packt_screen">Save</span>. This will kick off the build. A first build can take a while, so grab a beverage or take a quick break.</p>
</li>
<li>Run the app on your device and confirm that everything runs as you expect it to. If anything fails, refer to <a href="e7c0bdd1-e380-4498-af5a-fe9e627eb6cb.xhtml" target="_blank">Chapter 11</a>, <em><span>Performance Tips and Troubleshooting</span></em>, for help.</li>
</ol>
<div class="packt_tip">As you work through the exercises in this chapter, try and build as often as possible. A build can quickly tell you if you have any major issues.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying the base scene</h1>
                </header>
            
            <article>
                
<p>The next thing we will do is just modify the base scene for our needs. Open up Unity and follow along:</p>
<ol>
<li>Select and drag the <span class="packt_screen">PointCloud</span> object in the <span class="packt_screen">Hierarchy</span> window and drop it into the <kbd>Assets/ARCoreDesign/Prefabs</kbd> folder in the <span class="packt_screen">Project</span> window, as shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/f7a5e0a3-93eb-400f-9296-ca231e812b88.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Creating a prefab with the PointCloud object</div>
<ol start="2">
<li>This will create a <span class="packt_screen">Prefab</span> of the <span class="packt_screen">PointCloud</span> object. Think of a <span class="packt_screen">Prefab</span> as a template or almost like a class. Anytime we want to reuse the <span class="packt_screen">PointCloud</span> object, we can drag it into a scene or instantiate it.</li>
<li>Select the <span class="packt_screen">PointCloud</span> object in the <span class="packt_screen">Hierarchy</span> window and type the <span class="packt_screen">Delete</span> key. Find it, and click on it. This will delete the object; we don't need it right now.</li>
<li>Rename the <kbd>ExampleController</kbd> object in the <span class="packt_screen">Hierarchy</span> window to <kbd>SceneController</kbd>.</li>
<li>Select the <kbd>Assets/ARCoreDesign/Scripts</kbd> folder and from the menu, select <span class="packt_screen">Assets</span> | <span class="packt_screen">Create</span> | <span class="packt_screen">C# Script</span>. Name the script <kbd>SceneController</kbd>. Then, double-click on it to open the script in your favorite code editor.</li>
<li>Now, get back to Unity. Enter <kbd>helloarcontroller</kbd> in the <span class="packt_screen">Project</span> search pane to filter the window to the script. Double-click on the script to open it in your code editor.</li>
<li>Copy the entire <kbd>HelloARController.cs</kbd> script and paste it over the contents of the <kbd>SceneController.cs</kbd> file; yes, all of it. We are essentially making a copy. Rename your class and change the namespace, like this:</li>
</ol>
<pre style="padding-left: 60px">namespace Packt.ARCoreDesign<br/>{<br/><strong>...  //code omitted</strong><br/>public class SceneController : MonoBehaviour  <strong>//rename me</strong><br/><em><strong>...  </strong></em><strong>//code omitted</strong><br/>}  <strong>// don't forget the closing brace at the end</strong></pre>
<ol start="8">
<li>We wrap all our new code files with a <kbd>namespace</kbd> in order to avoid naming conflicts. Naming conflicts happen more frequently in Unity if you use a lot of assets. Generally, if you are new to Unity, you will use a lot of third-party assets.</li>
<li>Make sure that all the following new <kbd>using</kbd> statements are identified, as follows:</li>
</ol>
<pre style="padding-left: 60px"> using System.Collections.Generic;<br/> using GoogleARCore;<br/> using UnityEngine;<br/> using UnityEngine.Rendering; <br/> <strong>using GoogleARCore.HelloAR;</strong><br/><br/>#if UNITY_EDITOR<br/>    using Input = GoogleARCore.InstantPreviewInput; <br/>#endif</pre>
<ol start="10">
<li>Save the file and return to Unity. Be sure to watch for any compiler errors.</li>
<li>Select the <kbd>SceneController</kbd> object in the <span class="packt_screen">Hierarchy</span> window and click on the <span class="packt_screen">Add</span> <span class="packt_screen">Component</span> button in the <span class="packt_screen">Inspector</span> window.</li>
<li>Enter <kbd>scene</kbd> in the search pane and then select the <span class="packt_screen">Scene Controller</span> script, as shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/ffd8a509-28f9-48b4-ac52-62c33f3f2854.png" style="width:32.92em;height:44.25em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Adding the Scene Controller script as a component</div>
<ol start="13">
<li>Click on the bullseye icon to set the properties for the <span class="packt_screen">Scene Controller</span>. Ensure that they match <span class="packt_screen">Hello AR Controller (Script)</span>. When all the properties match, click on the <strong>Gear</strong> icon beside the <span class="packt_screen">Hello AR Controller (Script)</span> and select <span class="packt_screen">Remove Component</span> from the context menu. You should now be left with just the <span class="packt_screen">Scene Controller (Scene</span><span class="packt_screen">)</span> component with the same properties set.</li>
<li>Connect, build, and run the app on your device. If you encounter any issues, check for compiler errors and ensure that you set up the components correctly.</li>
</ol>
<p>We can, of course, create duplicates for all the main scripts, but this will work for now. Obviously, we have a lot more work to do, but this is a good place to start. Ensure that you save the <kbd>scene</kbd> and your project. In the next section, we will look to change the content which we allow our user to place and choose where to place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The environment and placing content</h1>
                </header>
            
            <article>
                
<p>We have already covered the basics of how to interact with the environment in order to place content. What we want to do now is swap out and add new content (sorry Andy). After all, the whole premise of our design app is visualizing in AR how new furniture or other items look in a space. Let's get to it by opening up your favorite web browser and follow along:</p>
<ol>
<li>Browse to <a href="https://www.turbosquid.com/">turbosquid.com</a>. <strong>TurboSquid</strong> is an excellent resource for 3D models, both free and paid.</li>
</ol>
<div class="packt_tip">For AR / VR and mixed apps, you will generally want your models to be less detailed. Mobile devices such as Android don't render fine detailed models well. Before you purchase any models, ensure that you understand what your device's rendering limitations are.</div>
<ol start="2">
<li>Search for <kbd>ligne roset</kbd><strong> </strong>on the site.</li>
</ol>
<div class="packt_tip">You can, of course, use any FBX model you like, but try using the one suggested the first time. Working with 3D models can be frustrating if you are unsure what you are doing.</div>
<ol start="3">
<li>Filter your search to free models and select <span class="packt_screen">Ligne Roset Citta sofa and armchair</span>, as shown:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/52fa1323-fec8-4b47-a223-294ab57aa1a5.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Downloading models from TurboSquid</div>
<ol start="4">
<li>Click on the <span class="packt_screen">Download</span> button. You may have to create an account and then sign in first.</li>
<li>Click on the link marked <kbd>Ligne_Roset_Citta_FBX.zip</kbd>. This will download the zip file.</li>
<li>Unzip the file into a new folder and then open the folder. Select and drag the <kbd>mpm_vol.07_p24.FBX</kbd> file into Unity and drop it into the <kbd>Assets/ARCore/Models</kbd> folder, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/74e3bbae-0624-42ec-a21c-05817927c500.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Dragging the model into the Models folder</div>
<ol start="7">
<li>Select the model and then, in the <span class="packt_screen">Inspector</span> window, confirm that <span class="packt_screen">Model</span> | <span class="packt_screen">Scale</span> <span class="packt_screen">Factor</span> is set correctly, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/33d9f6d9-8305-458a-ba11-3370267db246.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Checking the model scale after import</div>
<ol start="8">
<li>In this example, the model is using <span class="packt_screen">File Scale</span>, which is set at <kbd>0.001</kbd>. You may need to adjust this depending on what scale your model uses. Right now, this scale works.</li>
<li><span>Our model comes complete with <kbd>chair</kbd> and <kbd>sofa</kbd>. Fortunately, we can break these apart relatively easily.</span> Drag and drop the model into an open area of the <span class="packt_screen">Hierarchy</span> window. You should see the <kbd>chair</kbd> and <kbd>sofa</kbd> get added to the scene.</li>
<li>Click on an empty area in the <span class="packt_screen">Hierarchy</span> window again to disable the model selection.</li>
<li>From the menu, select <span class="packt_screen">GameObject</span> | <span class="packt_screen">Create Empty</span>; rename the object as <kbd>sofa</kbd>. Do this again to create another new object and name it <kbd>armchair</kbd>. Ensure that the <kbd>armchair</kbd> and <kbd>sofa</kbd> <span>game objects </span>are set on an origin pose with a position of (<kbd>0</kbd>, <kbd>0</kbd>, <kbd>0</kbd>) and rotation of (<kbd>0</kbd>, <kbd>0</kbd>, <kbd>0</kbd>). If you need help, select the object and check the <span class="packt_screen">Inspector</span> window.</li>
</ol>
<p> </p>
<ol start="12">
<li>Expand the <span class="packt_screen">mpm_vol.07_p24</span> model, and drag the child <kbd>armchair</kbd> object and drop it on the new <kbd>armchair</kbd> game object. Repeat this process for the sofa piece, and your <span class="packt_screen">Hierarchy</span> window should resemble the following:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/d8c1f431-29bb-41e2-8e3b-9731981b6790.png" style="width:35.25em;height:26.58em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Creating two new models</div>
<ol start="13">
<li>What we just did is create new anchor points and then break apart our model. Anchor points allow us to adjust a model with respect to the fixed anchor. You will often need to do this in cases where the modeling software used a different reference. This is the case with our model. Select the <span class="packt_screen">24 Ligne Roset Citta armchair</span> child object and check the <span class="packt_screen">Inspector</span> window.</li>
</ol>
<p> </p>
<ol start="14">
<li>Change the position of the <kbd>armchair</kbd> <span class="packt_screen">Transform</span> to (<kbd>0</kbd>, <kbd>0.25</kbd>, <kbd>0</kbd>), as illustrated here:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/1485b522-a1b1-437d-af67-a510529269e0.png" style="width:33.08em;height:14.83em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the position transform of the armchair</div>
<ol start="15">
<li>Ensure that the position is set to <span class="packt_screen">X</span>=<kbd>0</kbd> and <span class="packt_screen">Y</span>=<kbd>-.25</kbd> and leave the <span class="packt_screen">Rotation</span> as it is. We are offsetting the position of the <kbd>armchair</kbd> from where it was and down a little. This is because ARCore currently tends to track planes too high; hopefully, this will be fixed by the <span>time of </span>release. In any case, you can adjust the offset of the <span>position of the </span><kbd>chair</kbd> anytime and anyway you want later.</li>
<li>Drag the <kbd>armchair</kbd> object from the <span class="packt_screen">Hierarchy</span> window and drop it into the <kbd>Assets/ARCoreDesign/Prefabs</kbd> folder. Repeat this process for the <kbd>sofa</kbd> object as well. This will create a prefab of the <kbd>armchair</kbd> and <kbd>sofa</kbd>.</li>
<li>Delete the <kbd>armchair</kbd>, <kbd>sofa</kbd>, and original <span class="packt_screen">mpm_vol.07_p24</span> objects from the <span class="packt_screen">Hierarchy</span> window.</li>
<li>Select the <kbd>SceneController</kbd> object in the <span class="packt_screen">Hierarchy</span> window and then in the <span class="packt_screen">Inspector</span> window, set <span class="packt_screen">Andy Android Prefab</span> to the <kbd>armchair</kbd> prefab, as shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/ef1b9b10-5956-454d-a4b5-e4d0f87c60b9.png" style="width:35.42em;height:53.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the prefab slot on SceneController</div>
<ol start="19">
<li>Save the project, connect, and run the app on your device. Let some surfaces appear and then place a chair or two. Feel free to go back and swap for the sofa. Note that you may want to adjust the <kbd>sofa</kbd> model's position as well.</li>
</ol>
<p>Good, now we can place some furniture, except that you will soon realize that the planes are more in the way now. Let's see how we can turn <span>the planes in the next section </span>on and off when we start adding in some UI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the UI</h1>
                </header>
            
            <article>
                
<p>At this point, we want to give the user the ability to clear a scene and turn off the planes. The planes are helpful to identify surfaces we can drop objects onto, but they really distract from the experience. We will do this by building a dead simple UI with a couple of buttons. Fortunately, Unity has a very powerful UI system called <strong>uGUI</strong>, which will allow us to quickly do this. Open up the Unity editor to the <kbd>Main</kbd> scene and follow along:</p>
<ol>
<li>Click on an open area of the <span class="packt_screen">Hierarchy</span> window to ensure that your selection is cleared. We do this to avoid attaching objects to other objects mistakenly.</li>
<li>From the menu, select <span class="packt_screen">GameObject</span> | <strong><span class="packt_screen">UI</span></strong> | <span class="packt_screen"><strong>Canvas</strong></span>. Name the new object as <kbd>UI</kbd> and ensure that the properties for this object match the <span class="packt_screen">Inspector</span> window in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/cb5a0093-6165-4801-996d-3ad07905c8f3.png" style="width:40.08em;height:52.83em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the properties of a new UI canvas</div>
<ol start="3">
<li>The settings we use on this <span class="packt_screen">Canvas</span> allow our child <kbd>UI</kbd> objects to scale automatically with screen size based on a specific resolution. If we didn't do this, our <kbd>UI</kbd> controls would scale differently on each device. This allows us to keep a consistent look, which is a good thing.</li>
<li>Select the <span class="packt_screen">UI</span> canvas and from the menu, select <span class="packt_screen">GameObject</span> | <span class="packt_screen">UI</span> | <span class="packt_screen">Panel</span> to add a new child panel to the canvas.</li>
<li>Select the new <span class="packt_screen">Panel</span> object. In the <span class="packt_screen">Inspector</span> window, click on <span class="packt_screen">Add Component</span> and then search for and add a <span class="packt_screen">Grid Layout Group</span> component. Then, set the properties of this component to match the following screen excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/05e70b16-7363-49bc-9b48-7255e8c6593c.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the Group Layout Grid (Script) properties</div>
<ol start="6">
<li><span class="packt_screen">Grid Layout Group</span> is a useful tool for automatically laying out objects. The layout will automatically resize itself and adjust its child grid components.</li>
<li>With the <span class="packt_screen">Panel</span> still selected, change the <span class="packt_screen">Image</span> component's <span class="packt_screen">Color</span> property to transparent. Do this by clicking on <span class="packt_screen">Color Selector Area</span> next to the <span class="packt_screen">Color</span> property and set the color to <kbd>#FFFFFF00</kbd> or <kbd>Alpha 0</kbd>.</li>
<li>Select the <span class="packt_screen">Panel</span> object in the <span class="packt_screen">Hierarchy</span> window and from the menu, select <span class="packt_screen">GameObject</span> | <span class="packt_screen">UI</span> | <span class="packt_screen">Button</span>. Rename the button as <span class="packt_screen">Clear</span>.</li>
<li>Expand the <span class="packt_screen">Clear</span> button and select the child object. Change the <span class="packt_screen">Text</span> components <span class="packt_screen"><strong>Text</strong></span> property to <span class="packt_screen">Clear</span>.</li>
</ol>
<p> </p>
<ol start="10">
<li>Repeat the sixth and seventh steps for a new button called <span class="packt_screen">Planes</span>. When you are done, your <span class="packt_screen">Hierarchy</span> window and <span class="packt_screen">Game</span> window should resemble the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/a8a4f994-564a-4029-8867-831b58c20050.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">The finished buttons and panel in 2D view</div>
<ol start="11">
<li>You can view your scene in 2D view by clicking on the <span class="packt_screen">2D</span> button at the top of the <span class="packt_screen">Scene</span> window. This is useful for previewing the <span class="packt_screen">UI</span> elements you are building. You can use your mouse and keyboard to adjust the view on your own after that.</li>
<li>Connect, build, and run. The buttons don't work yet, but change the orientation and see how the buttons scale.</li>
</ol>
<div class="packt_tip">Feel free to style these buttons as you wish; after all, this is your app too. You can also add a slide in menu if you wanted. There are plenty of excellent resources and good books available on Unity uGUI development that can guide you on how to extend the UI for your look and feel.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scripting the buttons</h1>
                </header>
            
            <article>
                
<p>The obvious next step is to get those buttons working. Of course, we need to add a little bit of scripting, shown as follows:</p>
<ol>
<li>Open the <kbd>SceneController</kbd> script we created earlier in your code editor. Just before the <kbd>Update</kbd> method, insert the following section of code:</li>
</ol>
<pre style="padding-left: 60px">private List&lt;GameObject&gt; m_sceneObjects = new List&lt;GameObject&gt;();<br/>private List&lt;GameObject&gt; m_scenePlanes = new List&lt;GameObject&gt;();<br/>private bool m_planeOnState;<br/>public void ClearScene()<br/>{<br/>  foreach(var obj in m_sceneObjects)<br/>  {<br/>    Destroy(obj);<br/>  }<br/>  m_sceneObjects.Clear();<br/>}<br/>public void Planes()<br/>{<br/>  m_planeOnState = !m_planeOnState;<br/>  //turn plane visibility on or off<br/>  foreach(var plane in m_scenePlanes)<br/>  {<br/>    plane.SetActive(m_planeOnState);<br/>  }<br/>}</pre>
<ol start="2">
<li>In this code, we first create some lists to store scene objects (<kbd>m_sceneObjects</kbd>) and planes (<kbd>m_scenePlanes</kbd>), with a new <kbd>boolean</kbd> to track the state of the planes <kbd>m_planeOnState</kbd> (visible or not). Next, we add two new methods (<kbd>ClearScene</kbd> and <kbd>Planes</kbd>). <kbd>ClearScene</kbd> iterates over <kbd>m_sceneObjects</kbd> using <kbd>foreach</kbd> and removes the object from the scene with the <kbd>Destroy</kbd> method. <kbd>Destroy</kbd> is the method used to remove and clean up game objects from a scene. The <kbd>Planes</kbd> method flips the state of <kbd>m_planeOnState</kbd> and then loops through the planes and sets their state with <kbd>SetActive</kbd>. If an object is active, it means that it is visible and being updated in a scene. An inactive object is disabled and does not render.</li>
</ol>
<div class="packt_tip">We are staying consistent with the same naming conventions in this example in order to match the code style. If using <kbd>m_</kbd> to denote a private member variable is not your style, don't use it. You may also want to refactor this code and replace names such as <kbd>andyObject</kbd> with something more appropriate. Visual Studio has a great set of refactoring tools that make tasks like this easy.</div>
<ol start="3">
<li>Scroll down in the <span class="packt_screen"><kbd>Update</kbd></span> method and add the line after the line identified:</li>
</ol>
<pre style="padding-left: 60px"><strong>var andyObject = Instantiate... </strong>//after me<br/>m_sceneObjects.Add(andyObject);</pre>
<ol start="4">
<li>This line of code just adds the <kbd>andyObject</kbd> (poorly named now) to our list of scene objects. The <kbd>andyObject</kbd> is first instantiated with the <kbd>Instantiate</kbd> method. Think of <kbd>Instantiate</kbd> as the opposite of <kbd>Destroy</kbd>.</li>
</ol>
<p> </p>
<ol start="5">
<li>Scroll back up and add the line after the line identified:</li>
</ol>
<pre style="padding-left: 60px"><strong>GameObject planeObject = Instantiate... </strong>//after me<strong><br/></strong><span>m_scenePlanes.Add(planeObject);</span></pre>
<ol start="6">
<li>The same thing here, we are adding the newly instantiated <kbd>planeObject</kbd> to our list of scene planes.</li>
<li>Save the file and return to Unity. We now need to hook up the buttons. As always, wait for the compiler to finish in order to ensure that you didn't create a syntax error.</li>
<li>Select the <span class="packt_screen">Clear</span> button and in the <span class="packt_screen"><strong>Inspector</strong></span> window, scroll to the <span class="packt_screen"><strong>Button</strong></span> component. Click on the <span class="packt_screen">+</span> button at the bottom to add a new event handler, and then set the properties of the handler to those shown here:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/c82a669e-ecb8-4d41-85ac-9ee0a49fe484.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Adding the button event handler</div>
<ol start="9">
<li>Repeat the process for the <span class="packt_screen">Planes</span> button. This time though, connect the <kbd>Planes</kbd> method.</li>
<li>Connect, build, and run. Try to place an object and then use the buttons to clear it.</li>
</ol>
<p>Now, you should be able turn on and off the plane visibility and clear any objects you created. In the next section, we will extend our UI to allow the user to interact with the objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with the virtual</h1>
                </header>
            
            <article>
                
<p>We want our users to be able to place and then move or adjust their object's pose as they need to. If you recall, a pose represents the six degrees of freedom that an object can be represented in in 3D space. Before we start posing an object though, we need to be able to select an object. After we select an object, we want to be able to outline it in order to identify it to the user as selected. Since outlining the object sounds like an essential first step, let's tackle that first. Follow along the given steps to create the object outlining:</p>
<ol>
<li>Go back to Unity. Create a new folder in the <kbd>Assets/ARCoreDesign/Materials</kbd> folder and name it <kbd>Shaders</kbd>.</li>
<li>Right-click (<em>Ctrl</em> + Click on Mac) inside the new folder within the <span class="packt_screen">Project</span> window and from the <span class="packt_screen">Context</span> menu, select <span class="packt_screen">Create</span> | <span class="packt_screen">Shader</span> | <span class="packt_screen">Standard Surface Shader</span>. Name the new shader <kbd>ARMobileSpecularOutline</kbd>.</li>
<li>Double-click on the <kbd>ARMobileSpecularOutline</kbd> shader to open it in your code editor.</li>
<li>Delete the contents of the file. We will replace it with the ARCore mobile specular shader we used earlier.</li>
<li>Open the <kbd>MobileSpecularWithLightEstimation.shader</kbd> file in your text editor and copy the entire contents to your clipboard. The file is in the <kbd>Assets/GoogleARCore/HelloARExample/Materials/Shaders</kbd> folder.</li>
<li>Paste the contents of your clipboard to the new <kbd>ARMobileSpecularOutline.shader</kbd> file we just created. Again, we are copying the sample source and converting it to our own.</li>
</ol>
<div class="packt_infobox">While this shader is a copy of our light estimation shader and will use light estimation, we want to try and keep our variable names as succinct as possible. Normally, we will add light estimation to the name of the shader. However, in this, we will use an AR prefix to remind us that this shader uses light estimation and is optimized for AR.</div>
<ol start="7">
<li>Edit the name of the shader, top line, to the following:</li>
</ol>
<pre style="padding-left: 60px">Shader "ARCoreDesgin/ARMobileSpecularOutline"</pre>
<ol start="8">
<li>Next, we have several edits to do at the top of the file. Change the <span class="packt_screen">Properties</span> section to the following by adding the new lines not highlighted:</li>
</ol>
<pre style="padding-left: 60px"><strong>Properties</strong><br/><strong>{</strong><br/>  _Albedo ("Albedo", Color) = (1, 1, 1, 1)<br/>  <em><strong>_</strong></em><strong>Shininess ("Shininess", Range (0.03, 1)) = 0.078125</strong><br/><strong>  _MainTex ("Base (RGB) Gloss (A)", 2D) = "white" {}</strong><br/><strong>  [NoScaleOffset] _BumpMap ("Normalmap", 2D) = "bump" {}</strong><br/>  _Outline ("_Outline", Range(0,0.1)) = 0<br/>  _OutlineColor ("Color", Color) = (1, 1, 1, 1)<br/><strong>}</strong></pre>
<ol start="9">
<li>This adds three new properties: <kbd>_Albedo</kbd>, <strong><kbd>_Outline</kbd></strong>, and <strong><kbd>_OutlineColor</kbd></strong>. We added <kbd>_Albedo</kbd> in order to set a color on our materials without using a texture. <kbd>_Outline</kbd> defines the size of the outline, and <kbd>_OutlineColor</kbd> refers to the color.</li>
<li>After the <span>identified </span>lines, inject the following block of code:</li>
</ol>
<pre style="padding-left: 60px"><strong>Tags { "RenderType"="Opaque" }</strong><br/><strong>LOD 250  </strong>//after me<br/>Pass {<br/>  Tags { "RenderType"="Opaque" }<br/>  Cull Front<br/> <br/>  CGPROGRAM<br/> <br/>  #pragma vertex vert<br/>  #pragma fragment frag<br/>  #include "UnityCG.cginc"<br/> <br/>  struct v2f {<br/>    float4 pos : SV_POSITION;<br/>  };<br/>  float _Outline;<br/>  float4 _OutlineColor;<br/> <br/>  float4 vert(appdata_base v) : SV_POSITION {<br/>    v2f o;<br/>    o.pos = UnityObjectToClipPos(v.vertex);<br/>    float3 normal = mul((float3x3) UNITY_MATRIX_MV, v.normal);<br/>    normal.x *= UNITY_MATRIX_P[0][0];<br/>    normal.y *= UNITY_MATRIX_P[1][1];<br/>    o.pos.xy += normal.xy * _Outline;<br/>      return o.pos;<br/>    }<br/> <br/>    half4 frag(v2f i) : COLOR {<br/>      return _OutlineColor;<br/>    }<br/> <br/>    ENDCG<br/>  }</pre>
<ol start="11">
<li>This block of code is the part that creates the outline and does this by rendering a second time. It does this using the <kbd>Pass</kbd> keyword. Inside <kbd>Pass</kbd>, we can see more tags being defined and another start to a shader program with <kbd>CGPROGRAM</kbd>. The second block is a <strong><kbd>vertex</kbd></strong>/<kbd>fragment</kbd> shader and if you look inside the <kbd>vert</kbd> function, you can see where the outline is calculated. It does this by projecting the models vertex <kbd>normal</kbd> a distance determined by <kbd>_Outline</kbd>. Then, in the <kbd>frag</kbd> function, we just return the outline color. Again, don't panic if this looks intimidating, it is.</li>
<li>The last thing we need to do is add the new <kbd>_Albedo</kbd> property to our surface shader and add code to use it. Scroll down and add the following line after the identified <span>line</span>:</li>
</ol>
<pre style="padding-left: 60px"><strong>fixed _GlobalLightEstimation; </strong> //after me<br/>float4 _Albedo;</pre>
<ol start="13">
<li>Scroll down further to the <kbd>surf</kbd> function and modify the following line:</li>
</ol>
<pre style="padding-left: 60px"><strong>from</strong> o.Albedo = tex.rgb;<br/><br/><strong>to</strong> o.Albedo = tex.rgb * _Albedo;</pre>
<ol start="14">
<li>All this is done to apply the <kbd>Albedo</kbd> color to the texture. If there is no texture, a value of <kbd>1.0</kbd> is used, which means just the <kbd>Albedo</kbd> color is shown. We needed to add this bit because our imported models didn't come with textures, and we didn't want to have to use a texture.</li>
<li>Save the file and return to Unity. Ensure that you see no compiler errors.</li>
</ol>
<p>That completes the outline shader, but, of course, we want to test how it works. Let's create a new material and set it on our model to see how this looks:</p>
<ol>
<li>Create a new material called <kbd>ARMobileSpecularOutline_Green</kbd><strong> </strong>in the <kbd>Assets/ARCoreDesign/Materials</kbd> folder.</li>
<li>Change the new material's shader to use the newly created shader <strong><span class="packt_screen">ARCoreDesign</span></strong> | <strong><span class="packt_screen">ARMobileSpecularOutline</span></strong>.</li>
<li>Set the <kbd>Albedo</kbd> color to a pleasant green, perhaps <kbd>#09D488FF</kbd>. Set the <span class="packt_screen">Shininess</span> to about <kbd>0.5</kbd> or so, you decide.</li>
</ol>
<div class="packt_infobox">The actual color of the fabric material is <kbd>#8F8E2A</kbd>; use that color if you don't want such an obvious difference.</div>
<ol start="4">
<li>Set <kbd>_Outline</kbd> to <kbd>0.02</kbd>, which is still quite thick, but obvious. Use this value for now, and you can change it later.</li>
<li>Select the <kbd>sofa</kbd> prefab in the <kbd>Assets/ARCoreDesign/Prefabs</kbd> folder and replace the <strong>fabric</strong> material with the new <strong><span class="packt_screen">ARMobileSpecularOutline_Green</span></strong>, as shown:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/bb4b80c1-43fc-4c9a-95db-39150bbbc0e5.png" style="width:31.00em;height:38.08em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Changing the sofa prefab to use the new material</div>
<ol start="6">
<li>Save your project. Connect, build, and then run. Place a <kbd>chair</kbd> and see how it looks.</li>
</ol>
<p>We have our outline shader in place, but now we need to programmatically turn the outline on when a user selects an object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the object outliner</h1>
                </header>
            
            <article>
                
<p>We will build an <kbd>ObjectOutliner</kbd> class to handle the outlining for us. Follow along as we build the pieces to turn the outline on and off as the user selects an object:</p>
<ol>
<li>Create a new C# script called <kbd>ObjectOutliner</kbd> in the <kbd>Assets/ARCoreDesign/Scripts</kbd> folder.</li>
<li>Replace all of the pregenerated script with the following:</li>
</ol>
<pre style="padding-left: 60px">namespace Packt.ARCoreDesign<br/>{<br/>    using System.Collections;<br/>    using System.Collections.Generic;<br/>    using UnityEngine;<br/>       <br/>    public class ObjectOutliner : MonoBehaviour<br/>    {<br/>        public int MaterialSlot;<br/>        public Material DefaultMaterial;<br/>        public Material OutlineMaterial;<br/>        public bool outlineOn; <br/>        public void Outline()<br/>        {<br/>            outlineOn = !outlineOn;<br/>            var renderer = GetComponent&lt;MeshRenderer&gt;();<br/>            Material[] mats = renderer.materials;<br/>            if (outlineOn)<br/>            {<br/>                mats[MaterialSlot] = OutlineMaterial;<br/>            }<br/>            else<br/>            {<br/>                mats[MaterialSlot] = DefaultMaterial;<br/>            }<br/>            renderer.materials = mats;<br/>        }<br/>    }<br/>}</pre>
<ol start="3">
<li>This class basically just swaps the material of an object with its outlined or default material every time <kbd>Outline</kbd> is called.</li>
<li>Next, open the <kbd>SceneController.cs</kbd> script in your code editor. We have to wrap the <kbd>Session Raycast</kbd> call in the <span class="packt_screen"><kbd>Update</kbd></span> method with our own <kbd>Physics Raycast</kbd>. Add the following code around the highlighted code section, as follows:</li>
</ol>
<pre style="padding-left: 60px">RaycastHit rayHit;<br/>if (Physics.Raycast(FirstPersonCamera.ScreenPointToRay(touch.position), out rayHit, 2))<br/>  {<br/>    var outliner = rayHit.collider.gameObject.GetComponent&lt;ObjectOutliner&gt;();<br/>    if (outliner != null)<br/>    {                    <br/>      outliner.Outline();<br/>    }<br/>  }<br/>  else<br/>  {<br/>    <strong>// Raycast against the location the player touched to search for planes.                 </strong><br/><strong>    TrackableHit hit;</strong><br/><strong>    TrackableHitFlags raycastFilter = TrackableHitFlags.PlaneWithinPolygon |</strong><br/><strong>    TrackableHitFlags.FeaturePointWithSurfaceNormal;</strong><br/><br/><strong>    if (Frame.Raycast(touch.position.x, touch.position.y, raycastFilter, out hit))</strong><br/><strong>    {</strong><br/><strong>      var andyObject = Instantiate(AndyAndroidPrefab, hit.Pose.position, hit.Pose.rotation);</strong><br/><strong>      m_sceneObjects.Add(andyObject);</strong><br/><strong>      // Create an anchor to allow ARCore to track the hitpoint as understanding of the physical</strong><br/><strong>      // world evolves.</strong><br/><strong>      var anchor = hit.Trackable.CreateAnchor(hit.Pose);</strong><br/><br/><strong>      // Andy should look at the camera but still be flush with the plane.</strong><br/><strong>      if ((hit.Flags &amp; TrackableHitFlags.PlaneWithinPolygon) != TrackableHitFlags.None)</strong><br/><strong>      {</strong><br/><strong>        // Get the camera position and match the y-component with the hit position.</strong><br/><strong>        Vector3 cameraPositionSameY = FirstPersonCamera.transform.position;</strong><br/><strong>        cameraPositionSameY.y = hit.Pose.position.y;</strong><br/><br/><strong>        // Have Andy look toward the camera respecting his "up" perspective, which may be from ceiling.</strong><br/><strong>        andyObject.transform.LookAt(cameraPositionSameY, andyObject.transform.up);</strong><br/><strong>       }</strong><br/><br/><strong>       // Make Andy model a child of the anchor.</strong><br/><strong>       andyObject.transform.parent = anchor.transform;</strong><br/><strong>     }/end of Frame.Raycast</strong><br/>  }</pre>
<ol start="5">
<li>This section of code uses the <kbd>Raycast</kbd> method of the <kbd>Physics</kbd> object. <kbd>Physics</kbd> is the object that encapsulates the Unity physics engine. <kbd>Raycast</kbd> is a method we use, just like <kbd>Frame.Raycast</kbd> we saw earlier, to cast a ray and check for any collisions. Normally, you filter out objects to test before you run a ray cast operation, because it is so expensive. You can see how this is done with <kbd>Session</kbd> in the setup of the <kbd>raycastFilter</kbd>, where the filter is set to test for planes, but you can also set this point as well. This will allow you to easily apply wall coverings, for instance. In our case, since we are using <kbd>Physics</kbd> to do the <kbd>Raycast</kbd>, we can ensure that you only get physics objects. The ARCore planes don't have physics objects attached to them.</li>
<li>Save the file and return to Unity.</li>
<li>Locate the <kbd>armchair</kbd> prefab in the <kbd>Assets/ARCoreDesign/Prefabs</kbd> folder and expand it to see the inner model.</li>
<li>Select the armchair model and then, in the <span class="packt_screen">Inspector</span> window, click on <span class="packt_screen">Add Component</span>. Add a <span class="packt_screen">Box Collider</span> to the object; the <span class="packt_screen">Box Collider</span> will automatically adjust its size to surround the model. The <kbd>Physics</kbd> engine just tests for collisions against a collider and not the object. This is why we don't have to worry about our ARCore planes and points. If you add other models and want them selectable, then always use the simplest collider that best fits your shape. By simple, we mean less polygons. For instance, don't use a sphere collider when a <span class="packt_screen">Box Collider</span> will do.</li>
<li><span>Click on the</span> <span class="packt_screen">Add Component</span> <span>button again and this time, add</span> our new <span class="packt_screen">Object Outliner Script</span> to the object <span><span>and set its properties to what is shown in the following excerpt:</span></span></li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/9423d466-4b01-4cc8-a94a-0f5419b18a80.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting up the Object Outliner properties</div>
<ol start="10">
<li><span class="packt_screen">Default Material</span> represents the base look of the model. Then, we set the <span class="packt_screen">Outline Material</span> to our outline material we created earlier. Lastly, we set the slot we want to replace. The element we want to replace is <span class="packt_screen">Element 1</span>, so we put <kbd>1</kbd> in the <span class="packt_screen">Material Slot</span> property.</li>
<li>Save the project, build, and run. Place a chair and then select it.</li>
</ol>
<p>Now you can place a chair, select it, and then deselect it. If you note that it is difficult to select an object, ensure that you check that the collider is sufficiently large to engulf the object. In our example, the automatically created collider for the armchair is slightly off; perhaps we can fix that issue with one of the exercise questions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Positioning the chair</h1>
                </header>
            
            <article>
                
<p>The last step is to allow the user to move the chair after they select it. Fortunately, we can do all that in code. Open up your code editor to the <kbd>SceneController.cs</kbd> file and follow along:</p>
<ol>
<li>Add a new <kbd>public</kbd> variable to the top of the class after the line identified:</li>
</ol>
<pre style="padding-left: 60px"><strong>public GameObject m_andyAndroidPrefab; </strong>//after me<br/>public float MoveSpeed = .1f;</pre>
<ol start="2">
<li>This new <kbd>float MoveSpeed</kbd> sets the speed at which the user can move an object. You can also think of it as the move sensitivity. We set it to the default value of <kbd>.1f</kbd> here, but feel free to change it in the <span class="packt_screen">Inspector</span> later when testing.</li>
<li>Locate the following highlighted section of code and replace it with this:</li>
</ol>
<pre style="padding-left: 60px"><strong>if (Input.touchCount &lt; 1 || (touch = Input.GetTouch(0)).phase != TouchPhase.Began)</strong><br/><strong>{</strong><br/><strong>  return;</strong><br/><strong>}  </strong>//replace me with<br/><br/>if (Input.touchCount &lt; 1) return;<br/>touch = Input.GetTouch(0);<br/>if (touch.phase == TouchPhase.Began) //handle a single touch<br/>{   <strong>//starting single touch</strong></pre>
<ol start="4">
<li>The previous code made sure to only test the for starting touches. Instead, we now want to check when a <kbd>touch</kbd> starts and then as the user moves their finger. Since our previous <kbd>Physics</kbd> raycast code wrapped the <kbd>Session</kbd> raycast code, we now need to wrap it again with code that tests for a first touch and move events, which is what our second <kbd>if</kbd> statement does.</li>
<li>Scroll to the line identified and add the following code before the end of the <kbd>Update</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">    // Make Andy model a child of the anchor.<br/>    andyObject.transform.parent = anchor.transform;<br/><strong>  }</strong><br/><strong>} //after me</strong><em><strong><br/></strong></em><br/>}  <strong>//be sure to add the brace</strong><br/>else if (touch.phase == TouchPhase.Moved)<br/>{<br/>  var change = FirstPersonCamera.transform.forward * touch.deltaPosition.y;<br/>  change += FirstPersonCamera.transform.right * touch.deltaPosition.x;<br/>  change *= Time.deltaTime * MoveSpeed;<br/><br/>  foreach (var obj in m_sceneObjects)<br/>  {<br/>    var outliner = obj.GetComponentInChildren&lt;ObjectOutliner&gt;();<br/>    if (outliner != null &amp;&amp; outliner.outlineOn)<br/>    {<br/>      obj.transform.position += change;<br/>    }<br/>  }<br/>}</pre>
<ol start="6">
<li>The code we are adding here handles when the user is moving their finger. We then calculate a <kbd>change</kbd> vector relative to the camera's position. This transforms the <kbd>forward</kbd> or <em>z</em> axis relative to the camera by a delta position of the <em>y</em> axis in 2D, which more or less means that as the user moves their finger up and down on the screen, the object will move in and out on the <kbd>forward</kbd> axis, relative to the camera. To the <kbd>change</kbd> vector, we then add the <kbd>right</kbd> or <em>x</em> axis vector relative to the camera and modified by the delta of the user's finger along the x axis in 2D. Thus, when a user moves their finger left or right across the screen, the model will move left-right along the <kbd>right</kbd> axis relative to the camera.</li>
<li>Scroll up and change the <strong>if</strong> statement to add the new highlighted code starting with <strong>&amp;&amp;</strong>:</li>
</ol>
<pre style="padding-left: 60px">if (outliner != null <strong>&amp;&amp; outliner.outlineOn == false</strong>)<br/>{<br/>  outliner.Outline();<br/>}</pre>
<ol start="8">
<li>This change just ensures that if the object is highlighted and selected again, the <kbd>Outline</kbd> method is not called. We no longer want to toggle the selection, but we will leave the <kbd>Outline</kbd> method this way for ease of use. Next, we want to handle when a user touches away from an object. In that case, we want to disable all the outlined objects.<br/>
If, at any point, you lose track or get frustrated, take a look at the finished project available as part of the code.</li>
<li>Scroll down to the code identified and insert the new code to clear the outlines on the selected objects:</li>
</ol>
<pre style="padding-left: 60px"><strong>else</strong><br/><strong>{  //after me</strong><br/>  //touched outside, reset all outlined objects<br/>  foreach (var obj in m_sceneObjects)<br/>  {<br/>    var outliner = obj.GetComponentInChildren&lt;ObjectOutliner&gt;();<br/>    if (outliner != null &amp;&amp; outliner.outlineOn)<br/>    {<br/>      outliner.Outline();<br/>    }<br/>  }<br/><br/><strong>TrackableHit hit;  //before me</strong></pre>
<ol start="10">
<li>This code loops through the game <kbd>m_scene_Objects</kbd>, finds the <kbd>ObjectOutliner</kbd> component, and then uses that to test whether the outline is on. If the outline is on, it turns it off with a call to <kbd>Outline</kbd>, perhaps poorly named now.</li>
<li>Connect, build, and run. Wait for the surfaces to track and then place a <kbd>chair</kbd>. Touch to select and then use your finger to move the <kbd>chair</kbd> around. You can also adjust your position relative to the <kbd>chair</kbd> and watch how the object responds, all in real time.</li>
<li>Press the volume down and power button at the same time to take a screenshot. Compare your picture to the following one:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/724d754d-478e-499c-a004-37c97823b829.png" style="width:16.75em;height:29.75em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">A virtual armchair placed and moved</div>
<p>Not bad, but we can probably do a bit better. In the next section, we will get back into lighting and work on the lighting and shadows of our objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lighting and shadows</h1>
                </header>
            
            <article>
                
<p>Lighting is an essential element in our scenes, but as we have already seen, it takes some work to get it right. In this section, we will revisit lighting and also tackle adding shadows. Adding shadows to our objects will make them look like they are really there. We will start with adding shadows, so open up Unity and follow along:</p>
<ol>
<li>Create a new shader called <kbd>UnlitShadowReceiver</kbd> in the <kbd>Assets/ARCoreDesign/Materials/Shaders</kbd> folder.</li>
<li>Double-click on the new shader to open it in your code editor.</li>
<li>Select all the autogenerated code and delete it. Then, add the following code:</li>
</ol>
<pre style="padding-left: 60px">Shader "ARCoreDesign/UnlitShadowReceiver" <br/>{<br/> Properties<br/> { <br/>  _Color("Main Color", Color) = (1,1,1,1) <br/>  _MainTex("Base (RGB)", 2D) = "white" {} <br/>  _Cutoff("Cutout", Range(0,1)) = 0.5 <br/> }<br/> SubShader<br/> { <br/>  Pass<br/>  { <br/>   Alphatest Greater[_Cutoff] SetTexture[_MainTex] <br/>  } <br/>  <br/>  Pass<br/>  { <br/>   Blend DstColor Zero Tags{ "LightMode" = "ForwardBase" }<br/>   <br/>   CGPROGRAM<br/>   #pragma vertex vert<br/>   #pragma fragment frag<br/>   #include "UnityCG.cginc"<br/>   #pragma multi_compile_fwdbase<br/>   #include "AutoLight.cginc"<br/>   <br/>   struct v2f <br/>   {<br/>    float4 pos : SV_POSITION; LIGHTING_COORDS(0,1)<br/>   };<br/>   v2f vert(appdata_base v) <br/>   {<br/>    v2f o; <br/>    o.pos = UnityObjectToClipPos(v.vertex);<br/>    TRANSFER_VERTEX_TO_FRAGMENT(o);<br/>    return o; <br/>   }<br/>   fixed4 frag(v2f i) : COLOR <br/>   {<br/>    float attenuation = LIGHT_ATTENUATION(i);<br/>    return attenuation;<br/>   } <br/>  ENDCG<br/>  }<br/> }<br/> Fallback "Transparent/Cutout/VertexLit" <br/>}</pre>
<ol start="4">
<li>This shader is an example of a transparent shadow receiver. The shader works in two passes. In the first pass, we essentially clear the texture based on a cutoff alpha value. This allows us to turn an object transparent and still receive a shadow. The second pass draws the shadow using a vertex and fragment shader. Feel free to spend time studying this shader further.</li>
</ol>
<div class="packt_infobox">As ARCore matures, there will likely be more versions of transparent shadow receivers available. Plan to search for other options or other ways to improve this form of shader in the future.</div>
<ol start="5">
<li>Save the file and return to Unity.</li>
<li>Create a new material in the <kbd>Assets/ARCoreDesign/Materials</kbd> folder and name it as <kbd>UnlitShadowReceiver</kbd>. Set the properties of the material, as shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/27221d4d-4f02-48c3-9210-28747142050f.png" style="width:26.25em;height:14.33em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the properties on the UnlitShadowReceiver material</div>
<ol start="7">
<li>Select and drag the <kbd>armchair</kbd> prefab from the <kbd>Assets/ARCoreDesign/Materials</kbd> folder in the <span class="packt_screen"><strong>Project</strong></span> window and drop it in an open area of the <span class="packt_screen"><strong>Hierarchy</strong></span> window. We want to adjust our prefab a bit, and this is the easiest way.</li>
<li>From the menu, select <span class="packt_screen"><strong>GameObject</strong></span> | <span class="packt_screen"><strong>3D</strong></span> | <span class="packt_screen"><strong>Plane</strong></span>. Expand the <kbd>armchair</kbd> object and drag the <span class="packt_screen">Plane</span> onto the <span class="packt_screen">24 Ligne Roset Citta armchair</span> child object.</li>
<li>Select <span class="packt_screen">Plane</span> and reset the position to (<kbd>0</kbd>, <kbd>0</kbd>, <kbd>0</kbd>) and scale to (<kbd>0.1</kbd>, <kbd>1</kbd>, <kbd>0.1</kbd>) on the <span class="packt_screen">Transform</span>.<strong> </strong>Set the material to new <span class="packt_screen">UnlitShadowReceiver</span>, as shown in the following excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/f94766c1-8af9-4b1e-8508-eb753131fd2c.png" style="width:31.58em;height:36.83em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the Plane material to UnlitShadowReceiver</div>
<ol start="10">
<li>Select the armchair object in the <span class="packt_screen"><strong>Hierarchy</strong></span> window and then in the <kbd>Inspector</kbd> window, click on the <span class="packt_screen">Apply</span> button beside the <span class="packt_screen">Prefab</span> properties to save the prefab. Leave the prefab in the scene for now, but we will want to delete it later.</li>
</ol>
<p>We just created our transparent shadow receiver shader and then set it on a plane that we added to our prefab. We need to do this in order for our object, the <kbd>armchair</kbd>, to correctly cast a shadow on our new transparent receiver. Next, we need to turn on shadows, as the ARCore example has them disabled by default.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Turning the shadows on</h1>
                </header>
            
            <article>
                
<p>Follow along to turn shadows <span>back on</span>:</p>
<ol>
<li>Select the <span class="packt_screen">Directional Light</span> in the <span class="packt_screen">Hierarchy</span> window and set the lights properties as shown:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/c51bcbed-9280-44c7-94b0-ffa9adef9e32.png" style="width:26.08em;height:30.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Turning on shadows for the Directional Light</div>
<ol start="2">
<li>As soon as you change the <span class="packt_screen">Shadow Type</span>, you should see an immediate change in the <span class="packt_screen">Scene</span> window with the armchair now showing a shadow underneath. If you are unable to see a shadow yet, don't panic, we likely need to just adjust the quality settings.</li>
</ol>
<div class="packt_infobox">The ARCore example uses a blob texture for a shadow on the Andy model. By updating this to use a shader, we now have automatic support for any object you want to add. Just remember to adjust the plane to the object. If you wanted to add a painting or other wall hanging, you would set the plane vertical with the object.</div>
<ol start="3">
<li>From the menu, select <span class="packt_screen">Edit</span> | <span class="packt_screen">Project Settings</span> | <span class="packt_screen">Quality</span>. Set the <span class="packt_screen">Android</span> build to use the highest quality settings by <span class="packt_screen">Default</span> by clicking on the arrow icon underneath the <span class="packt_screen">Levels</span> for <span class="packt_screen">Android</span>. This is shown in the <span>following</span> excerpt:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/986bfe82-8c1d-4414-a08c-74ab1c6cacf4.png" style="width:22.83em;height:31.92em;"/> </div>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting the Quality setting for the build </div>
<ol start="4">
<li>Make sure and apply the changes to the prefab again. This just assures us that are changes are saved before we delete the prefab from the scene.</li>
<li>Select and delete the <kbd>armchair</kbd> object from the scene.</li>
</ol>
<div class="packt_infobox">We are using the highest quality settings in this example. For the most part, ARCore apps will run on relatively new devices, which means we can attempt to push the limits. If you find that the quality settings are crashing your device or not rendering correctly, then try dropping the quality on the build a level. You may want to do this anyway to improve your app's performance.</div>
<ol start="6">
<li>Connect, build, and run. Place a chair and see the difference, as shown:</li>
</ol>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/835e551e-9c60-4d57-8aad-6396c0a51f67.png" style="width:45.33em;height:22.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Example of the complete app with lighting and shadows</div>
<p>This is as far as we will go with the app in this chapter. Feel free to enhance the app on your own and take time to complete some of the optional exercises on your own. If the shadow doesn't show up correctly go back and edit the shadow settings on the light and the quality settings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p class="mce-root"><em>Answer the following questions on your own</em>:</p>
<ol>
<li>Change the model in the app to the <kbd>sofa</kbd> or even another object.</li>
<li>Add the changes we made to the <kbd>Environmental Light</kbd> script in order to track the light direction.</li>
<li>Add other objects to the app and allow the user a choice on which to place.</li>
<li>Allow the user to place vertical objects. Hint—you will need to render vertical planes now, yes ARCore does recognize vertical planes.</li>
<li>Allow the user to rotate the model. Hint<span>—</span>you may have to add some control handles.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>With that, we have completed our simple example of a design app. We were able to complete all the major technical items we wanted to accomplish. We started with setting up a new Unity project using the ARCore example as a template. This saved us some time in what would have otherwise become a very long chapter. Next, we learned how to import new models from sites such as <a href="https://www.turbosquid.com/">TurboSquid</a> and how to set them up as prefabs for later use. Then, we built a simple UI to allow us to clear the tracking planes from the view and clear any models. After that, we added the ability for a user to select and move an object in the AR scene. This required us to enhance one of the ARCore example shaders and heavily modify the <kbd>SceneController</kbd> script. Finally, we tackled shadows by turning on lights and adding a transparent shadow receiver to our object prefab.</p>
<p>ARCore is well suited for the next wave of HoloLens or mixed reality low-cost headsets. In the next chapter, we take a bit of a break from AR and dive into mixed reality, where we will build a multiplayer app called <kbd>HoloCore</kbd>.</p>


            </article>

            
        </section>
    </body></html>