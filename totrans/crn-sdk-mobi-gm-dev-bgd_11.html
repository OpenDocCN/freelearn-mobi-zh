<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Implementing In-App Purchases</h1></div></div></div><div><blockquote class="blockquote"><p>In-App Purchase is an optional feature, which developers can use to embed a store directly within an app. Sometimes you may want to extend more features in your current game to keep your consumers interested in playing. Here's your chance and possibly more revenue in your pocket!<a id="id712" class="indexterm"/>
</p></blockquote></div><div><blockquote class="blockquote"><p>This chapter only concerns with In-App Purchases in the Apple iTunes Store for the iOS platform. If you are a paid Corona SDK subscriber, In-App Purchase support for Android via Google's Google Play Store (not available on Kindle Fire and Nook) is available in the Daily Builds page starting with build 2012.760. The Daily Builds can be found at:<a class="ulink" href="http://developer.anscamobile.com/downloads/daily-builds"> http://developer.anscamobile.com/downloads/daily-builds</a>. Android developers who want to implement In-App Purchases in their apps can use this as an alternative.</p></blockquote></div><p>We'll cover the following in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Consumable, non-consumable, and subscription purchases</li><li class="listitem" style="list-style-type: disc">Making transactions</li><li class="listitem" style="list-style-type: disc">Restoring purchased items</li><li class="listitem" style="list-style-type: disc">Initializing Corona's store module</li><li class="listitem" style="list-style-type: disc">Creating and testing In-App Purchases on a device</li></ul></div><p>Ready, set, go!</p><div><div><div><div><h1 class="title"><a id="ch11lvl1sec01"/>The wonders of In-App Purchase</h1></div></div></div><p>The purpose of implementing In-App Purchase is to add an in-app payment functionality to collect payment for enhanced functionality or additional content usable in your game. The following are options of incorporating this feature:<a id="id713" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A game that offers new level packs to play outside of the default content</li><li class="listitem" style="list-style-type: disc">A freemium game that allows you to purchase virtual currency to create/build new assets during gameplay</li><li class="listitem" style="list-style-type: disc">Adding additional characters or special power ups to enhance game elements</li></ul></div><p>These are some examples that can be done with In-App Purchases.<a id="id714" class="indexterm"/>
</p><p>In-App Purchases allow users to purchase additional content within an application. The App Store manages transaction information only. Developers cannot use the App Store to deliver content. So, either you bundle content with your app when you ship it waiting to be unlocked upon purchase, or you have to work out your own system to download the data if you wish to deliver content.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec01"/>Types of In-App Purchases</h2></div></div></div><p>There are several In-App Purchase types you can apply in your apps. They are as follows:<a id="id715" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Consumable:</strong> These are products that must be purchased each time the user needs that item. They're typically a one-time service, such as money in an app where you need to pay for supplies to build structures.<a id="id716" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Non-consumable:</strong> These are products that only need to be purchased once by the user. This could be additional level packs in a game.<a id="id717" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Auto-renewable subscription:</strong> These are products that allow the user to purchase in-app content for a set duration of time. An example of an auto-renewable subscription would be a magazine or newspaper that takes advantage of the auto-renewing functionality built into iOS.<a id="id718" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Free subscriptions:</strong> These are used to put free subscription content in newsstands. Once a user signs up for a free subscription, it will be available on all devices associated with the user's Apple ID. Note that free subscriptions do not expire and can only be offered in newsstand-enabled apps.<a id="id719" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Non-renewing subscriptions:</strong> Similar to auto-renewable subscriptions, this is a non-renewing subscription that requires a user to renew each time the subscription is due to expire. Your app must contain code that recognizes when the expiration occurs. It must also prompt the user to purchase a new subscription. An auto-renewable subscription eliminates these steps.<a id="id720" class="indexterm"/></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec02"/>Corona's store module</h1></div></div></div><p>Applying In-App Purchases in your application can be a little mind-boggling and a tedious process. Integrating it with Corona requires calling the <code class="literal">store</code> module:<a id="id721" class="indexterm"/>
</p><div><pre class="programlisting">store = require("store")
</pre></div><p>The <code class="literal">store</code> module is already incorporated into the Corona API, similar to Facebook and Game Network. You can find more information on Corona's <code class="literal">store</code> module at the following URL:<a class="ulink" href="http://developer.anscamobile.com/reference/in-app-purchases"> http://developer.anscamobile.com/reference/in-app-purchases</a>.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec02"/>store.init()</h2></div></div></div><p>This must be called when handling store transactions to your app. It activates In-App Purchases and allows you to receive callbacks with the listener function you specify.<a id="id722" class="indexterm"/>
</p><p>Syntax:<a id="id723" class="indexterm"/>
</p><div><pre class="programlisting">store.init( listener )
</pre></div><p>Parameters:</p><p>
<code class="literal">listener</code>—This function that will handle transaction callback events.<a id="id724" class="indexterm"/>
</p><p>Example:</p><p>The following blocks determine the transaction states that can occur during an In-App Purchase. The four different states are: purchased, restored, cancelled, and failed.<a id="id725" class="indexterm"/>
</p><div><pre class="programlisting">function transactionCallback( event )
local transaction = event.transaction
<strong>if transaction.state == "purchased" then
</strong>
print("Transaction successful!")
print("productIdentifier", transaction.productIdentifier)
print("receipt", transaction.receipt)
print("transactionIdentifier", transaction.identifier)
print("date", transaction.date)
<strong>elseif transaction.state == "restored" then</strong>
print("Transaction restored (from previous session)")
print("productIdentifier", transaction.productIdentifier)
print("receipt", transaction.receipt)
print("transactionIdentifier", transaction.identifier)
print("date", transaction.date)
print("originalReceipt", transaction.originalReceipt)
print("originalTransactionIdentifier", transaction.originalIdentifier)
print("originalDate", transaction.originalDate)
<strong>elseif transaction.state == "cancelled" then</strong>
print("User cancelled transaction")
<strong>elseif transaction.state == "failed" then</strong>
print("Transaction failed, type:", transaction.errorType, transaction.errorString)
else
store module, Corona APIstore module, Corona APIstore.init()print("unknown event")
end
-- Once we are done with a transaction, call this to tell the store
-- we are done with the transaction.
-- If you are providing downloadable content, wait to call this until
-- after the download completes.
<strong>store.finishTransaction( transaction )</strong>
end
<strong>store.init( transactionCallback )</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec01"/>event.transaction</h3></div></div></div><p>The object containing the transaction.<a id="id727" class="indexterm"/>
</p><p>The transaction object supports the following read-only properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">state</code>—A string containing the state of the transaction. Valid values are<code class="literal">"purchased", "restored", "cancelled"</code>, and<code class="literal">"failed"</code>.<a id="id728" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">productIdentifier</code>—The product identifier associated with the transaction.<a id="id729" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">receipt</code>—A unique receipt returned from the store. It is returned as a hexadecimal string.<a id="id730" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">identifier</code>—A unique transaction identifier returned from the store. It is a string.<a id="id731" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">date</code>—The date of when the transaction occurred.<a id="id732" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">originalReceipt</code>—A unique receipt returned from the store from the original purchase attempt. This is mostly relevant in a case of a restore. It is returned as a hexadecimal string.<a id="id733" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">originalIdentifier</code>—A unique transaction identifier returned from the store from the original purchase attempt. This is mostly relevant in a case of a restore. It is a string.<a id="id734" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">originalDate</code>—The date of when the original transaction occurred. This is mostly relevant in a case of a restore.<a id="id735" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">errorType</code>—The type of error that occurred when the state is<code class="literal">"failed"</code> (a string).<a id="id736" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">errorString</code>—A descriptive error message of what went wrong in the<code class="literal">"failed"</code> case.<a id="id737" class="indexterm"/></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec03"/>store.loadProducts()</h2></div></div></div><p>This method retrieves information about items available for sale. This includes the price of each item, a name, and a description.<a id="id738" class="indexterm"/>
</p><p>Syntax:</p><div><pre class="programlisting">store.loadProducts( arrayOfProductIdentifiers, listener )
<a id="id739" class="indexterm"/>
</pre></div><p>Parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">arrayOfProductIdentifiers</code>—An array with each element containing a string of the Product ID of the In-App product you want to know about.<a id="id740" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">listener</code>—A callback function that is invoked when the store finishes retrieving the product information.<a id="id741" class="indexterm"/></li></ul></div><p>Example:<a id="id742" class="indexterm"/>
</p><p>The following block displays the list of products that are available in the app. Information about the product can be retrieved from the <code class="literal">loadProductsCallback()</code> function and determines whether it is valid or invalid.<a id="id743" class="indexterm"/>
</p><div><pre class="programlisting"><strong>-- Contains your Product ID's set in iTunes Connect
local listOfProducts =
{
"com.mycompany.InAppPurchaseExample.Consumable",
"com.mycompany.InAppPurchaseExample.NonConsumable",
"com.mycompany.InAppPurchaseExample.Subscription",
}</strong>
function loadProductsCallback ( event )
print("showing valid products", #event.products)
for i=1, #event.products do
print(event.products[i].title)
print(event.products[i].description)
print(event.products[i].price)
print(event.products[i].productIdentifier)
end
print("showing invalidProducts", #event.invalidProducts)
for i=1, #event.invalidProducts do
print(event.invalidProducts[i])
end
end
<strong>store.loadProducts( listOfProducts, loadProductsCallback )</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec02"/>event.products</h3></div></div></div><p>When <code class="literal">store.loadProducts()</code> returns its requested list of products, you can access the array of product information through the <code class="literal">event.products</code> property.<a id="id744" class="indexterm"/>
</p><p>Product information such as title, description, price, and the product identifier is contained in a table.</p><p>Syntax:<a id="id745" class="indexterm"/>
</p><div><pre class="programlisting">event.products
</pre></div><p>Each entry in the <code class="literal">event.products</code> array supports the following fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">title</code>—The localized name of the item</li><li class="listitem" style="list-style-type: disc"><code class="literal">description</code>—The localized description of the item</li><li class="listitem" style="list-style-type: disc"><code class="literal">price</code>—The price of an item (as a number)</li><li class="listitem" style="list-style-type: disc"><code class="literal">productIdentifier</code>—The product identifier</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec03"/>event.invalidProducts</h3></div></div></div><p>When <code class="literal">store.loadProducts()</code> returns its requested list of products, any products you requested that are not available for sale will be returned in an array. Access the array of invalid products through the <code class="literal">event.invalidProducts</code> property.<a id="id746" class="indexterm"/>
</p><p>It is a Lua array containing the product identifier string requested from <code class="literal">store.loadProducts()</code>.</p><p>Syntax:</p><div><pre class="programlisting">event.invalidProducts
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec04"/>store.canMakePurchases</h2></div></div></div><p>This returns true if purchases are allowed, false otherwise. Corona's API can check if purchasing is possible. iOS devices provide a setting that disables purchasing. This can be used to avoid purchasing apps accidentally.<a id="id747" class="indexterm"/>
</p><p>Example:<a id="id748" class="indexterm"/>
</p><div><pre class="programlisting">if store.canMakePurchases then
store.purchase( listOfProducts )
else
print("Store purchases are not available")
end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec05"/>store.purchase()</h2></div></div></div><p>
<code class="literal">store.purchase()</code> Initiates a purchase transaction on a provided list of products.<a id="id749" class="indexterm"/>
</p><p>This function will send out purchase requests to the store. The listener specified in <code class="literal">store.init()</code> will be invoked when the store finishes processing the transaction.<a id="id750" class="indexterm"/>
</p><p>Syntax:<a id="id751" class="indexterm"/>
</p><div><pre class="programlisting">store.purchase( arrayOfProducts )
</pre></div><p>Parameters:<a id="id752" class="indexterm"/>
</p><p>
<code class="literal">arrayOfProducts</code>—An array specifying the products you want to buy.</p><p>Example:<a id="id753" class="indexterm"/>
</p><div><pre class="programlisting">store.purchase{ "com.mycompany.InAppPurchaseExample.Consumable"
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec06"/>store.finishTransaction()</h2></div></div></div><p>This method notifies the App Store that a transaction is complete.<a id="id754" class="indexterm"/>
</p><p>After you finish handling a transaction, you must call <code class="literal">store.finishTransaction()</code> on the transaction object. If you don't do this, the App Store will think your transaction was interrupted and will attempt to resume it on the next application launch.</p><p>Syntax:<a id="id755" class="indexterm"/>
</p><div><pre class="programlisting">store.finishTransaction( transaction )
</pre></div><p>Parameters:</p><p>
<code class="literal">transaction</code> - The transaction object belonging to the transaction you want to mark as finished.<a id="id756" class="indexterm"/>
</p><p>Example:<a id="id757" class="indexterm"/>
</p><div><pre class="programlisting">store.finishTransaction( transaction )
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec07"/>store.restore()</h2></div></div></div><p>Any previously purchased items that have been wiped clean from a device or upgraded to a new device can be restored on the users account without paying for the product again. The <code class="literal">store.restore()</code> API initiates this process. Transactions can be restored by the <code class="literal">transactionCallback</code> listener, which is registered with <code class="literal">store.init()</code>. Transaction state will be<code class="literal">"restored"</code> and your app may then make use of the<code class="literal">"originalReceipt", "originalIdentifier"</code>, and<code class="literal">"originalDate"</code> fields of the transaction object.<a id="id758" class="indexterm"/>
</p><p>Syntax:<a id="id759" class="indexterm"/>
</p><div><pre class="programlisting">store.restore()
</pre></div><p>Example:</p><p>The block will run through the <code class="literal">transactionCallback()</code> function and determine if a product has been previously purchased from the application. If the result is true, <code class="literal">store.restore()</code> will initiate the process of retrieving the product without asking the user to pay for it again.<a id="id760" class="indexterm"/>
</p><div><pre class="programlisting">function transactionCallback( event )
local transaction = event.transaction
if transaction.state == "purchased" then
print("Transaction successful!")
print("productIdentifier", transaction.productIdentifier)
print("receipt", transaction.receipt)
print("transactionIdentifier", transaction.identifier)
print("date", transaction.date)
<strong>elseif transaction.state == "restored" then</strong>
print("Transaction restored (from previous session)")
print("productIdentifier", transaction.productIdentifier)
print("receipt", transaction.receipt)
print("transactionIdentifier", transaction.identifier)
store.restore()store.restore()exampleprint("date", transaction.date)
print("originalReceipt", transaction.originalReceipt)
print("originalTransactionIdentifier", transaction.originalIdentifier)
print("originalDate", transaction.originalDate)
<strong>elseif transaction.state == "cancelled" then</strong>
print("User cancelled transaction")
<strong>elseif transaction.state == "failed" then</strong>
print("Transaction failed, type:", transaction.errorType, transaction.errorString)
else
print("unknown event")
end
-- Once we are done with a transaction, call this to tell the store
-- we are done with the transaction.
-- If you are providing downloadable content, wait to call this until
-- after the download completes.
<strong>store.finishTransaction( transaction )</strong>
end
store.init( transactionCallback )
<strong>store.restore()</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec03"/>Create an In-App Purchase</h1></div></div></div><p>Before reading on, make sure you know how to create an App ID and Distribution Provisioning Profile from the iOS Provisioning Portal. Also, make sure you already know how to manage new applications in iTunes Connect. If you're unsure, please refer to<a class="link" href="ch10.html" title="Chapter 10. Optimizing, Testing, and Shipping your Games"> Chapter 10</a>,<em> Optimizing, Testing, and Shipping your Games</em>, for more information. The following are the things that need to be ready in your app before creating an In-App Purchase:<a id="id762" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Distribution Certificate already made for your app.</li><li class="listitem" style="list-style-type: disc">An explicit App ID for your application that is, <code class="literal">com.companyname.appname</code>. Do not substitute a wild-card character (asterisk *). The<strong> Bundle ID</strong> needs to be completely unique to use the In-App Purchase function.</li><li class="listitem" style="list-style-type: disc">An ad-hoc Distribution Provisioning Profile (used for testing In-App Purchases). When you're ready to submit an app with In-App Purchase, an App Store Distribution Provisioning Profile is required.<div><img src="img/1888_11_01.jpg" alt="Create an In-App Purchase"/></div></li><li class="listitem" style="list-style-type: disc">Have your application information set up in iTunes Connect. You do not have to have your binary uploaded to create or test In-App Purchases.</li><li class="listitem" style="list-style-type: disc">Make sure that you already have an iOS Paid Applications contract in effect with Apple. If you don't have, you'll need to request one in<strong> Contracts, Tax, and Banking</strong> located on the iTunes Connect home page. You will need to provide your banking and tax information in order to offer In-App Purchases in your apps.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec04"/>Time for action—creating the In-App Purchase in iTunes Connect</h1></div></div></div><p>We'll be implementing an In-App Purchase through iTunes Connect and create a scenario in a sample application that will call a transaction. Let's create the Product ID that will use in our In-App Purchase.<a id="id763" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Log in to iTunes Connect. On the home page, select<strong> Manage Your Applications</strong>. Select the application you plan to add an In-App Purchase to.</li><li class="listitem">Once you're on the app summary page, click on the<strong> Manage In-App Purchases</strong> button and then click on the<strong> Create New</strong> button on the top-left corner.<div><img src="img/1888_11_02.jpg" alt="Time for action—creating the In-App Purchase in iTunes Connect"/></div></li><li class="listitem">You will be brought to a page that shows you a summary of the type of In-App Purchases you can create. For this example,<strong> Non-Consumable</strong> is selected. We'll be creating a product that only needs to be purchased once.</li><li class="listitem">In the next page is the area you fill in the information about the product. The information applies to consumable, non-consumable, and non-renewing Subscription In-App Purchases. Fill out the<strong> Reference Name</strong> and<strong> Product ID</strong> for your product. The<strong> Product ID</strong> needs to be a unique identifier and can be any alphanumeric sequence of letters and numbers (that is, <code class="literal">com.companyname.appname.productid).</code><a id="id764" class="indexterm"/><div><h3 class="title"><a id="note23"/>Note</h3><p>Auto-Renewable subscriptions require you to generate a shared secret. If you are to use Auto-Renewable Subscriptions in your app, then on the<strong> Manage in-App Purchases</strong> page, click on the<strong> View or generate a shared secret</strong> link. You will be brought to a page to generate the shared secret. Click on the<strong> Generate</strong> button. The shared secret will display a string of 32 randomly generated alphanumeric characters. When you choose Auto-Renewable Subscriptions, the difference from the other In-App Purchase types is that you have to choose the duration between auto-renewals of your product. For more information on Auto-Renewable Subscriptions, go to:<a class="ulink" href="http://https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide.pdf"> https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide.pdf</a>.</p></div><div><img src="img/1888_11_03.jpg" alt="Time for action—creating the In-App Purchase in iTunes Connect"/></div></li><li class="listitem">Click on the<strong> Add Language</strong> button. Select the language that will be used for the In-App Purchase. Add a<strong> Display Name</strong> for your product and a short description about it. When you're done, click on the<strong> Save</strong> button.<div><img src="img/1888_11_04.jpg" alt="Time for action—creating the In-App Purchase in iTunes Connect"/></div></li><li class="listitem">In<strong> Pricing and Availability</strong>, make sure that<strong> Yes</strong> is selected for<strong> Cleared for Sale</strong>. In the<strong> Price Tier</strong> drop-down menu, select the price you plan to sell your In-App Purchase. In this example,<strong> Tier 1</strong> is selected. In<strong> Screenshot for Review</strong>, you'll need to upload a screenshot of your In-App Purchase. If you're testing on an ad-hoc build, the screenshot is not necessary. Once you're ready for distribution, the screenshot is required so the In-App Purchase can be reviewed upon submittal. Click on the<strong> Save</strong> button when done.<a id="id765" class="indexterm"/><div><img src="img/1888_11_05.jpg" alt="Time for action—creating the In-App Purchase in iTunes Connect"/></div></li><li class="listitem">You will see a summary of the In-App Purchase you created on the next page. Click on the<strong> Done</strong> button if all the information looks correct.<a id="id766" class="indexterm"/><div><img src="img/1888_11_06.jpg" alt="Time for action—creating the In-App Purchase in iTunes Connect"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec08"/>What just happened?</h2></div></div></div><p>Adding a new In-App Purchase is a rather simple process. The information contained in the<strong> Product ID</strong> is what will be called upon during a transaction. Managing the type of In-App Purchase is entirely up to what type of product you want to sell in your game. This example demonstrates the purpose of taking a non-consumable product that represents purchasing/unlocking a new level in a game. It's a common scenario for users that want to sell level packs.<a id="id767" class="indexterm"/>
</p><p>Your application does not have to be completed to test In-App Purchases. All that is required is to have your application information set up in iTunes Connect so you can manage In-App Purchase features.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec05"/>Time for action—using the Corona store module to create an In-App Purchase</h1></div></div></div><p>Now that we have set up our Product ID for our In-App Purchase in iTunes Connect, we can implement it into our app to purchase the product we're going to sell. A sample menu app of<strong> Breakout</strong> was created to demonstrate how to purchase levels within an application. The app contains two levels in the level select screen. The first one is available by default and the second one is locked and can only be unlocked by purchasing it for $0.99. We're going to create a level select screen so it acts in that manner.<a id="id768" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">In the <code class="literal">Chapter 11</code> folder, copy the <code class="literal">Breakout In-App Purchase Demo</code> project folder to your desktop. You can download the project files accompanying this book from the Packt website. You will notice that the configuration, libraries, assets and <code class="literal">.lua</code> files needed are included.</li><li class="listitem">Create a new levelselect.lua file and save it to the project folder.</li><li class="listitem">Set up the scene with the following variables and saving/loading functions. The most important variable of all is <code class="literal">local store = require("store")</code> which calls the <code class="literal">store</code> module for In-App Purchases.<a id="id769" class="indexterm"/><div><pre class="programlisting">local storyboard = require( "storyboard" )
local scene = storyboard.newScene()
local ui = require("ui")
local movieclip = require( "movieclip" )
<strong>local store = require("store")</strong>
---------------------------------------------------------------------------------
-- BEGINNING OF YOUR IMPLEMENTATION
---------------------------------------------------------------------------------
local menuTimer
-- AUDIO
local tapSound = audio.loadSound( "tapsound.wav" )
--***************************************************
-- saveValue() --&gt; used for saving high score, etc.
--***************************************************
local saveValue = function( strFilename, strValue )
-- will save specified value to specified file
local theFile = strFilename
local theValue = strValue
local path = system.pathForFile( theFile, system.DocumentsDirectory )
-- io.open opens a file at path. returns nil if no file found
local file = io.open( path, "w+" )
if file then
-- write game score to the text file
file:write( theValue )
io.close( file )
end
end
--***************************************************
-- loadValue() --&gt; load saved value from file (returns loaded value as string)
--***************************************************
local loadValue = function( strFilename )
-- will load specified file, or create new file if it doesn't exist
local theFile = strFilename
local path = system.pathForFile( theFile, system.DocumentsDirectory )
-- io.open opens a file at path. returns nil if no file found
local file = io.open( path, "r" )
if file then
-- read all contents of file into a string
local contents = file:read( "*a" )
io.close( file )
return contents
else
-- create file b/c it doesn't exist yet
file = io.open( path, "w" )
file:write( "0" )
io.close( file )
return "0"
end
end
-- DATA SAVING
local level2Unlocked = 1
local level2Filename = "level2.data"
local loadedLevel2Unlocked = loadValue( level2Filename )
</pre></div></li><li class="listitem">Create the <code class="literal">createScene()</code> event and remove the<code class="literal">"mainmenu", "level1"</code>, and<code class="literal">"level2"</code> scenes.<div><pre class="programlisting">-- Called when the scene's view does not exist:
function scene:createScene( event )
local screenGroup = self.view
-- completely remove maingame and options
storyboard.removeScene( "mainmenu" )
storyboard.removeScene( "level1" )
storyboard.removeScene( "level2" )
print( "\nlevelselect: createScene event" )
end
</pre></div></li><li class="listitem">Next, create the <code class="literal">enterScene()</code> event and an array that contains a string of the<strong> Product ID</strong> set as an In-App Purchase in iTunes Connect.<a id="id771" class="indexterm"/><div><pre class="programlisting">function scene:enterScene( event )
local screenGroup = self.view
print( "levelselect: enterScene event" )
local listOfProducts =
{
-- These Product IDs must already be set up in your store
<strong>-- Replace Product ID with a valid one from iTunes Connect
"com.companyname.appname.NonConsumable", -- Non Consumable In-App Purchase</strong>
}
</pre></div></li><li class="listitem">Add a local blank table for <code class="literal">validProducts</code> and <code class="literal">invalidProducts</code>. Create a local function called <code class="literal">unpackValidProducts()</code> that checks valid and invalid Product IDs.<div><pre class="programlisting">local validProducts = {}
local invalidProducts = {}
local unpackValidProducts = function()
print ("Loading product list")
if not validProducts then
native.showAlert( "In-App features not available", "initStore() failed", { "OK" } )
else
print( "Found " .. #validProducts .. " valid items ")
for i=1, #invalidProducts do
-- Debug: display the product info
native.showAlert( "Item " .. invalidProducts[i] .. " is invalid.",{ "OK" } )
print("Item " .. invalidProducts[i] .. " is invalid.")
end
end
end
</pre></div></li><li class="listitem">Create a local function called <code class="literal">loadProductsCallback()</code> with an <code class="literal">event</code> parameter. Set up the handler to receive product information with <code class="literal">print</code> statements.<a id="id772" class="indexterm"/><div><pre class="programlisting">local loadProductsCallback = function( event )
-- Debug info for testing
print("loadProductsCallback()")
print("event, event.name", event, event.name)
print(event.products)
print("#event.products", #event.products)
validProducts = event.products
invalidProducts = event.invalidProducts
unpackValidProducts ()
end
</pre></div></li><li class="listitem">Create a local function called <code class="literal">transactionCallback()</code> with an <code class="literal">event</code> parameter. Add in several cases of results that are supposed to occur for every <code class="literal">transaction.state</code>. When the store is done with the transaction, call <code class="literal">store.finishTransaction(event.transaction)</code> before the end of the function. Set up another local function called <code class="literal">setUpStore()</code> with an <code class="literal">event</code> parameter to call <code class="literal">store.loadProducts(listOfProducts, loadProductsCallback)</code>.<a id="id773" class="indexterm"/><div><pre class="programlisting">local transactionCallback = function( event )
if event.transaction.state == "purchased" then
print("Transaction successful!")
<strong>saveValue( level2Filename, tostring(level2Unlocked) )</strong>
elseif event.transcation.state == "restored" then
print("productIdentifier", event.transaction.productIdentifier)
print("receipt", event.transaction.receipt)
print("transactionIdentifier", event.transaction.transactionIdentifier)
print("date", event.transaction.date)
print("originalReceipt", event.transaction.originalReceipt)
elseif event.transaction.state == "cancelled" then
print("Transaction cancelled by user.")
elseif event.transaction.state == "failed" then
print("Transaction failed, type: ", event.transaction.errorType, event.transaction.errorString)
local alert = native.showAlert("Failed ", infoString,{ "OK" })
else
print("Unknown event")
local alert = native.showAlert("Unknown ", infoString,{ "OK" })
end
-- Tell the store we are done with the transaction.
store.finishTransaction( event.transaction )
end
local setupMyStore = function(event)
store.loadProducts( listOfProducts, loadProductsCallback )
print ("After store.loadProducts(), waiting for callback")
end
</pre></div></li><li class="listitem">Set up the display objects for the background and level 1 button.<a id="id774" class="indexterm"/><div><pre class="programlisting">local backgroundImage = display.newImageRect( "levelSelectScreen.png", 480, 320 )
backgroundImage.x = 240; backgroundImage.y = 160
screenGroup:insert( backgroundImage )
local level1Btn = movieclip.newAnim({"level1btn.png"}, 200, 60)
level1Btn.x = 240; level1Btn.y = 100
screenGroup:insert( level1Btn )
local function level1touch( event )
if event.phase == "ended" then
audio.play( tapSound )
storyboard.gotoScene( "loadlevel1", "fade", 300 )
end
end
level1Btn:addEventListener( "touch", level1touch )
level1Btn:stopAtFrame(1)
</pre></div></li><li class="listitem">Set up the level 2 button placement.<div><pre class="programlisting">-- LEVEL 2
local level2Btn = movieclip.newAnim({"levelLocked.png","level2btn.png"}, 200, 60)
level2Btn.x = 240; level2Btn.y = 180
screenGroup:insert( level2Btn )
</pre></div></li><li class="listitem">Use the local <code class="literal">onBuyLevel2Touch(event)</code> function and create an <code class="literal">if</code> statement to check when <code class="literal">event.phase == ended and level2Unlocked ~= tonumber(loadedLevel2Unlocked)</code> so the scene changes to <code class="literal">mainmenu.lua</code>.<div><pre class="programlisting">local onBuyLevel2Touch = function( event )
if event.phase == "ended" and level2Unlocked ~= tonumber(loadedLevel2Unlocked) then
audio.play( tapSound )
storyboard.gotoScene( "mainmenu", "fade", 300 )
</pre></div></li><li class="listitem">Within the same <code class="literal">if</code> statement, create a local function called <code class="literal">buyLevel2()</code> with a <code class="literal">product</code> parameter to call the <code class="literal">store.purchase()</code> function.<a id="id775" class="indexterm"/><div><pre class="programlisting">local buyLevel2 = function ( product )
print ("Congrats! Purchasing " ..product)
-- Purchase the item
if store.canMakePurchases then
store.purchase( {validProducts[1]} )
else
native.showAlert("Store purchases are not available, please try again later", { "OK" } ) Will occur only due to phone setting/account restrictions
end
end
-- Enter your product ID here
<strong>-- Replace Product ID with a valid one from iTunes Connect
buyLevel2("com.companyname.appname.NonConsumable")</strong>
</pre></div></li><li class="listitem">Add in an <code class="literal">elseif</code> statement to check when level 2 has been purchased and unlocked once the transaction has been completed.<a id="id776" class="indexterm"/><div><pre class="programlisting">elseif event.phase == "ended" and level2Unlocked == tonumber(loadedLevel2Unlocked) then
audio.play( tapSound )
storyboard.gotoScene( "loadlevel2", "fade", 300 )
end
end
level2Btn:addEventListener( "touch", onBuyLevel2Touch )
if level2Unlocked == tonumber(loadedLevel2Unlocked) then
level2Btn:stopAtFrame(2)
end
</pre></div></li><li class="listitem">Activate the In-App Purchase with <code class="literal">store.init()</code> and call <code class="literal">transactionCallback()</code> as the parameter. Also call <code class="literal">setupMyStore()</code> with a timer set at 500 milliseconds.<div><pre class="programlisting">store.init(transactionCallback)
timer.performWithDelay (500, setupMyStore)
</pre></div></li><li class="listitem">Create the close UI button and a local function called <code class="literal">onCloseTouch()</code> with an event parameter. Set the function transition scenes to <code class="literal">loadmainmenu.lua</code> upon release of the close button. Close the <code class="literal">enterScene()</code> event with <code class="literal">end</code>.<a id="id777" class="indexterm"/><div><pre class="programlisting">local closeBtn
local onCloseTouch = function( event )
if event.phase == "release" then
audio.play( tapSound )
storyboard.gotoScene( "loadmainmenu", "fade", 300 )
end
end
closeBtn = ui.newButton{
defaultSrc = "closebtn.png",
defaultX = 100,
defaultY = 30,
overSrc = "closebtn.png",
overX = 105,
overY = 35,
onEvent = onCloseTouch,
id = "CloseButton",
text = "",
font = "Helvetica",
textColor = { 255, 255, 255, 255 },
size = 16,
emboss = false
}
closeBtn.x = 80; closeBtn.y = 280
closeBtn.isVisible = false
screenGroup:insert( closeBtn )
menuTimer = timer.performWithDelay( 200, function() closeBtn.isVisible = true; end, 1 )
end
</pre></div></li><li class="listitem">Create the <code class="literal">exitScene()</code> and <code class="literal">destroyScene()</code> events. Within the <code class="literal">exitScene()</code> event, cancel the <code class="literal">menuTimer</code> timer. Add in all the event listeners to the scene events and <code class="literal">return scene</code>.<a id="id778" class="indexterm"/><div><pre class="programlisting">-- Called when scene is about to move offscreen:
function scene:exitScene()
if menuTimer then timer.cancel( menuTimer ); end
print( "levelselect: exitScene event" )
end
-- Called prior to the removal of scene's "view" (display group)
function scene:destroyScene( event )
print( "((destroying levelselect's view))" )
end
-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )
-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )
-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )
-- "destroyScene" event is dispatched before view is unloaded, which can be
scene:addEventListener( "destroyScene", scene )
return scene
</pre></div></li><li class="listitem">Save the file and run the project in the Corona simulator. When you select the<strong> Play</strong> button, you will notice a<strong> 1</strong> button and a<strong> Locked</strong> button on the level select screen. By pressing the<strong> Locked</strong> button it calls the store to make a transaction. You will notice a <code class="literal">print</code> statement in the terminal that displays what<strong> Product ID</strong> is being referred to for purchase. The full In-App Purchase features cannot be tested in the simulator. You will have to create a distribution build and upload it to an iOS device to instigate a purchase in the store.<a id="id780" class="indexterm"/><div><img src="img/1888_11_07.jpg" alt="Time for action—using the Corona store module to create an In-App Purchase"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec09"/>What just happened?</h2></div></div></div><p>In this example, we used the <code class="literal">saveValue()</code> and <code class="literal">loadValue()</code> functions from the <code class="literal">BeebeGames</code> class to implement how our locked level will go from locked to unlocked using movieclips as buttons. The array in <code class="literal">local listOfProducts</code> displays a Product ID in a string format. The<strong> Product ID</strong> in this example needs to be a non-consumable In-App Purchase type and has to be an existing one in iTunes Connect.<a id="id781" class="indexterm"/>
</p><p>The <code class="literal">unpackValidProducts()</code> function checks how many valid and invalid items are in the In-App Purchase. The <code class="literal">loadProductsCallback()</code> function receives the product information in the store. The <code class="literal">transactionCallback(event)</code> function checks every state—<code class="literal">"purchased","restored", "cancelled"</code>, and<code class="literal">"failed"</code>. When a<code class="literal">"purchased"</code> state is achieved within the In-App Purchase, the <code class="literal">saveValue()</code> function is called to change the value of <code class="literal">level2.data</code>. When the transaction is completed, <code class="literal">store.finishTransaction(event.transaction)</code> needs to be called to tell the store you are done with your purchase.</p><p>The <code class="literal">setupMyStore(event)</code> function calls <code class="literal">store.loadProducts(listOfProducts, loadProductsCallback)</code> and checks the available Product ID(s) in the application. The event is handled once <code class="literal">store.init(transactionCallback)</code> is initialized and <code class="literal">setupMyStore()</code> is called.</p><p>The <code class="literal">onBuyLevel2Touch(event)</code> function allows us to check when an In-App Purchase has been made for the locked level. When the user is able to purchase and accepts the In-App Purchase, the transaction is processed and the value of <code class="literal">level2Unlocked</code> will match that of <code class="literal">tonumber(loadedLevel2Unlocked)</code>. The <code class="literal">buyLevel2(product)</code> function validates the purchased item with <code class="literal">store.purchase()</code> once the Product ID returns valid.</p><p>After the In-App Purchase, the screen transitions to the main menu to allow the<strong> Locked</strong> button to change to the level<strong> 2</strong> button. Once the button has changed to frame 2, level 2 is accessible.<a id="id782" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec10"/>Have a go hero—handling multiple product IDs</h2></div></div></div><p>Now that you know how to create an In-App Purchase for one product, try adding more than one in the same application. The scenarios are open-ended.<a id="id783" class="indexterm"/>
</p><p>You can add the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More levels for purchases</li><li class="listitem" style="list-style-type: disc">New characters the user can play as if your game has a feature user character.</li><li class="listitem" style="list-style-type: disc">New background scenes for your application</li></ul></div><p>How you handle new products for your store is up to you.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec06"/>Testing In-App Purchases</h1></div></div></div><p>You want to make sure that purchases work correctly. Apple provides a sandbox environment that allows you to test your app In-App Purchases. The sandbox environment uses the same model as the App Store, but does not process actual payments. Transactions return as if payments were processed successfully. It is a requirement to test In-App Purchases in a sandbox environment before submitting them for review by Apple.<a id="id784" class="indexterm"/>
</p><p>When testing in the sandbox environment, you'll need to create a separate user test account that is different from your current iTunes Connect account. Using your current account is not allowed to test your store in the sandbox.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec11"/>User test accounts</h2></div></div></div><p>While logged into your iTunes Connect account, you'll have to select the<strong> Manage Users</strong> link from the home page. Select<strong> Test User</strong> on the<strong> Select User Type</strong> page. Add a new user and make sure that the test account uses an e-mail address that is not associated with any other Apple account. All test accounts should only be used in the test environment when testing In-App Purchases. Click on the<strong> Save</strong> button when all the information is filled in.<a id="id785" class="indexterm"/>
</p><p>Once your user test account is created, you'll have to make sure that you're signed out of your Apple account in the<strong> Store</strong> settings of your device. This will keep non-test accounts from being used when testing In-App Purchases. You're only allowed to sign in to your user test account when prompted in the In-App Purchase sandbox when testing your application. Do not sign in to your test account before the application is launched. This will prevent it from invalidating your test account.<a id="id786" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec07"/>Time for action—testing the In-App Purchase with the Breakout In-App Purchase demo</h1></div></div></div><p>Before you can test an In-App Purchase on an iOS device, make sure that you have a test user account already made in iTunes Connect. Also, make sure that you created a distribution build using an ad-hoc Distribution Provisioning Profile for the app to test In-App Purchase features. If you followed all the earlier steps in this chapter, testing a purchase through the store will work accordingly.<a id="id787" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">In the Corona simulator, create a distribution build of the Breakout In-App Purchase Demo. Once the build has been compiled, upload the build to your iOS device.</li><li class="listitem">Keep your device connected to your machine and launch Xcode. In the toolbar, select<strong> Windows</strong> |<strong> Organizer</strong>. Once you're in<strong> Organizer</strong>, select the device that is connected in the<strong> Devices</strong> section and then select<strong> Console</strong>. This will allow you to check the console output of your device to catch debug messages from your code, (that is, <code class="literal">print</code> statements) and any application crashes.</li><li class="listitem">Before launching the application, you'll need to select the<strong> Settings</strong> icon on your device. Scroll up until you see the<strong> Store</strong> icon and select it.<div><img src="img/1888_11_08.jpg" alt="Time for action—testing the In-App Purchase with the Breakout In-App Purchase demo"/></div></li><li class="listitem">Sign out of your iTunes Store account if you're logged in so you can test In-App Purchases in the sandbox environment.<a id="id788" class="indexterm"/><div><img src="img/1888_11_09.jpg" alt="Time for action—testing the In-App Purchase with the Breakout In-App Purchase demo"/></div></li><li class="listitem">Launch the Breakout In-App Purchase demo from your device. Select the<strong> Play</strong> button and then select the<strong> Locked</strong> button. The screen will transition back to the main menu and a window will pop up to confirm your In-App Purchase. Click on<strong> OK</strong> to continue with the purchase.<a id="id789" class="indexterm"/><div><img src="img/1888_11_10.jpg" alt="Time for action—testing the In-App Purchase with the Breakout In-App Purchase demo"/></div></li><li class="listitem">Next you will be greeted with another window to sign in with your Apple ID. This is where you will log in with your test user account you created in iTunes Connect. Do not sign in with your actual Apple account ID used to log in to iTunes Connect.<a id="id790" class="indexterm"/><div><img src="img/1888_11_11.jpg" alt="Time for action—testing the In-App Purchase with the Breakout In-App Purchase demo"/></div></li><li class="listitem">Once you're logged in, select the<strong> Play</strong> button again. You will notice that the<strong> 2</strong> button has been unlocked. When you select it, you will have access to that scene.<a id="id791" class="indexterm"/><div><img src="img/1888_11_12.jpg" alt="Time for action—testing the In-App Purchase with the Breakout In-App Purchase demo"/></div></li><li class="listitem">Exit out of the app and refer to the console. You will notice the output from the device and some familiar <code class="literal">print</code> statements from our code. The console log displays the<strong> Product ID</strong> used for the In-App Purchase and informs you if it is valid and if the transaction was successful.<a id="id792" class="indexterm"/><div><img src="img/1888_11_13.jpg" alt="Time for action—testing the In-App Purchase with the Breakout In-App Purchase demo"/></div></li><li class="listitem">If you want to make sure that the In-App Purchase actually worked, delete the application from your device and log out of your user test account. Upload the same build to your device. No need to create a new one. Launch the application and run the In-App Purchase again. Log in using the same user test account. You should receive a pop-up window that mentions you already purchased the product and asks you if you want to download it again for free. Receiving a notification means your In-App Purchase was successful!<a id="id793" class="indexterm"/><div><img src="img/1888_11_14.jpg" alt="Time for action—testing the In-App Purchase with the Breakout In-App Purchase demo"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec12"/>What just happened?</h2></div></div></div><p>It is important to follow the In-App Purchase test steps accordingly. To make sure you're getting accurate results in the sandbox environment, signing out of your Apple account from the<strong> Store</strong> settings is the key to this whole process.<a id="id794" class="indexterm"/>
</p><p>Once you launch the application and call the store function by clicking on the<strong> Locked</strong> button, you will notice the display name and price of the In-App Purchase. It should match what you created in iTunes Connect if you implemented it correctly.</p><p>When you log in using the test user account you created in iTunes Connect, the transaction should go through without any errors assuming there are no server issues on Apple's side or connection problems on the device.<strong> Level 2</strong> on the level select screen will be unlocked and accessible. Congratulations! You have created an In-App Purchase!</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec13"/>Have a go hero—using other In-App Purchase types</h2></div></div></div><p>In the Breakout In-App Purchase demo, we focused more on non-consumable In-App Purchases. Try integrating consumable, auto-renewable subscriptions, or non-renewing subscriptions to your own apps.<a id="id795" class="indexterm"/>
</p><p>Apps that feature consumable products are games that require currency to buy or build things in a free-to-play environment. Subscription products can be focused towards games that are never-ending and are constantly updated with new levels or may require an online server to interact in a multiplayer environment. See what you can come up with!</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec14"/>Pop quiz—all about In-App Purchases</h2></div></div></div><div><ol class="orderedlist"><li class="listitem">What are non-consumable purchases?<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. Products that only need to be purchased once by the user.</li><li class="listitem" style="list-style-type: none">b. Products that need to be purchased each time the user needs the item.</li><li class="listitem" style="list-style-type: none">c. Products that allow the user to purchase content for a set duration of time.</li><li class="listitem" style="list-style-type: none">d. A subscription that requires a user to renew it each time it expires.</li></ul></div></li><li class="listitem">What is true about testing In-App Purchases?<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. You need to be logged in to your account at all times.</li><li class="listitem" style="list-style-type: none">b. Your Apple account is used to test In-App Purchases.</li><li class="listitem" style="list-style-type: none">c. Log in to your user test account when prompted in In-App Purchase sandbox.</li><li class="listitem" style="list-style-type: none">d. None of the above.</li></ul></div></li><li class="listitem">What type of Provisioning Profile must be used to test In-App Purchases?<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. Development Provisioning Profile.</li><li class="listitem" style="list-style-type: none">b. Ad-hoc Distribution Provisioning Profile.</li><li class="listitem" style="list-style-type: none">c. App Store Distribution Provisioning Profile.</li><li class="listitem" style="list-style-type: none">d. None of the above.</li></ul></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec08"/>Summary</h1></div></div></div><p>We can finally see the light at the end of the tunnel. By now, you should have an idea on how to implement In-App Purchases in to your games. It is a very lengthy process to organize, set up the code, and testing accurate purchases in the sandbox environment.</p><p>The following were discussed in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up Product IDs for In-App Purchases in iTunes Connect</li><li class="listitem" style="list-style-type: disc">Implementing purchase items using Corona's <code class="literal">store</code> module</li><li class="listitem" style="list-style-type: disc">Adding test user accounts in iTunes Connect</li><li class="listitem" style="list-style-type: disc">Testing In-App Purchases on a device</li></ul></div><p>Grasping the concept of In-App Purchasing can take some time. It is best to study the sample code and review the functions pertaining to Corona's <code class="literal">store</code> module.</p><p>Check out Apple's In-App Purchase Programming Guide at:<a class="ulink" href="http://https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf"> https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StoreKitGuide/StoreKitGuide.pdf</a> and the In-App Purchases in the API Reference section of Anscamobile's site:<a class="ulink" href="http://developer.anscamobile.com/reference/index/app-purchases"> http://developer.anscamobile.com/reference/index/app-purchases</a> for more references pertaining to this topic.</p><p>After 11 chapters, we have reached the end of this book. You now have obtained enough knowledge to create your own applications to sell in the App Store or Google Play Store. Hopefully all the information you have acquired has been helpful. I look forward to hearing about the games you have developed using Corona SDK!</p></div></body></html>