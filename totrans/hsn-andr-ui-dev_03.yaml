- en: Taking Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动
- en: Handling events is an essential part of any application; they are the raw input
    data for a user interface and how we interact with our users (rather than just
    presenting them with data). Android has an event model that will be instantly
    familiar to anyone who has programmed Java on their desktop--you attach listener
    objects to the widgets, and they deliver events to you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事件是任何应用程序的基本部分；它们是用户界面的原始输入数据，以及我们如何与用户互动（而不仅仅是向他们展示数据）。Android有一个事件模型，对于任何在桌面上的Java程序员来说都会立刻熟悉——你将监听器对象附加到小部件上，它们将事件传递给你。
- en: Event listeners in Android take the form of interfaces that you need to implement
    in order to receive the events. Each possible event type is declared as a method
    on the relevant interface. To receive a notification that the user has *clicked*
    or *tapped* on a widget, you use the `OnClickListener` interface, which declares
    a method--`onClick(View)`--which will be invoked when the relevant widget receives
    what it considers a click gesture from the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的事件监听器以接口的形式存在，你需要实现这些接口以接收事件。每个可能的事件类型都在相关接口上声明为一个方法。为了接收用户在某个小部件上*点击*或*轻触*的通知，你使用`OnClickListener`接口，该接口声明了一个方法——`onClick(View)`——当相关小部件接收到它认为的用户点击手势时，该方法将被调用。
- en: 'In this chapter, we''ll take a look at events on Android, and how best to implement
    them. Specifically, we''ll be taking a closer look at the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Android中的事件，以及如何最佳地实现它们。具体来说，我们将更深入地研究以下内容：
- en: How Android dispatches events, and how it affects your program and user experience
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android如何分发事件，以及它如何影响你的程序和用户体验
- en: Different ways to implement event listeners and their pros and cons
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现事件监听器的不同方式及其优缺点
- en: How to wrap groups of events into logical classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将事件组封装到逻辑类中
- en: How to make events always happen quickly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使事件始终快速发生
- en: Understanding Android event requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Android事件要求
- en: 'Android has a number of requirements around events delivered from the user
    interface that are important to be aware of, because they directly affect the
    user''s experience and the perceived performance of your application. Android
    runs the **main** thread of an application as an event loop, rather than having
    a separate **event loop** or **event dispatcher** thread. This is an extremely
    important concept to understand, because this thread and event queue are shared
    between the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Android对从用户界面传递的事件有一系列要求，这些要求非常重要，因为它们直接影响到用户体验和应用程序感知性能。Android将应用程序的**主**线程作为一个事件循环来运行，而不是有一个单独的**事件循环**或**事件分发器**线程。这是一个极其重要的概念，因为这条线程和事件队列在以下方面是共享的：
- en: All the events from the user interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有来自用户界面的事件
- en: The drawing requests from the widgets, where they paint themselves
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件的绘图请求，即它们绘制自己的地方
- en: The layout system and all the calculations for positioning and sizing widget
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局系统以及所有定位和尺寸小部件的计算
- en: A variety of system-level events (such as network state changes)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种系统级事件（如网络状态变化）
- en: 'This makes the *main* thread of the application a precious resource--every
    frame of an animation has to run through this event loop as a separate event,
    as does every layout pass, and every event from the user interface widget. On
    the other side of this contract, there are three other important factors to know
    and understand:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得应用程序的**主**线程成为一项宝贵的资源——动画的每一帧都必须作为一个单独的事件通过这个事件循环运行，布局的每一遍，以及用户界面小部件的每一个事件也是如此。在合同的另一边，还有三个其他重要因素需要了解和理解：
- en: All method calls to user interface elements must be done on the main thread
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对用户界面元素的所有方法调用都必须在主线程上执行
- en: No networking is allowed on the main thread
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线程上不允许进行网络操作
- en: Every event *slice* on the main thread is externally timed, and long-running
    events may cause your application to be terminated through an Application Not
    Responding dialog displayed to the user (which is as bad as crashing in most cases)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线程上的每个事件*切片*都是外部计时的，长时间运行的事件可能会导致你的应用程序通过向用户显示应用程序无响应对话框而被终止（这在大多数情况下与崩溃一样糟糕）
- en: So, it's vital that we have models in place to avoid using the main thread more
    than is absolutely required. Every time you run something on the main thread,
    you're taking time away from vital systems such as graphics rendering and input
    events. This will cause your application to appear to stutter and become unresponsive.
    Fortunately, Android has many utilities to help, and there are a few extra steps
    that can be taken as a developer, which will reduce the complexity and help ensure
    the best possible user experience.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有必要建立模型来避免过度使用主线程。每次你在主线程上运行某些操作时，你都会从图形渲染和输入事件等关键系统中夺取时间。这将导致你的应用程序看起来卡顿，变得无响应。幸运的是，Android有许多工具可以帮助，作为开发者，可以采取一些额外的步骤来减少复杂性，并确保最佳的用户体验。
- en: Listening for some events
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听某些事件
- en: 'When listening for user-interface events in Android, you''ll typically hook
    up a listener object of some sort to the widgets you want to receive events on.
    However, how the listener object is defined may follow a number of different patterns,
    and listeners can take a number of different forms. You''ll often see a simple
    anonymous class being defined as the listener, which is something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Android中监听用户界面事件时，你通常会连接一个监听器对象到你想接收事件的组件上。然而，监听器对象的定义可能遵循多种不同的模式，监听器也可以有多种形式。你经常会看到定义一个简单的匿名类作为监听器，这可能是这样的：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, while this pattern is common (especially because the much shorter
    lambda syntax was only introduced in Java 8, and Android didn''t properly support
    it until 2017), it''s not always your best choice for several reasons:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这种模式很常见（特别是由于lambda语法的引入仅限于Java 8，并且Android直到2017年才正确支持它），但它并不总是你的最佳选择，有多个原因：
- en: This anonymous class is not reusable at all. It serves one purpose, for a single
    object in the entire application.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个匿名类根本不可重用。它只服务于一个目的，在整个应用程序中的一个单一对象。
- en: You just allocated a new object that will also need to be garbage collected.
    This is not a big deal, but can sometimes be avoided or minimized by grouping
    listeners into classes that handle multiple related events.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你刚刚分配了一个新的对象，它也需要被垃圾回收。这不是什么大问题，但有时可以通过将监听器分组到处理多个相关事件的类中来避免或最小化这种情况。
- en: Any local variables from `onCreate` that are captured by the anonymous inner
    class must have references copied over into the new class as fields. You don't
    see this happen, but the compiler does it automatically (it's why the fields must
    be final).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中定义的任何局部变量，如果被匿名内部类捕获，必须将引用复制到新类作为字段。你可能看不到这个过程发生，但是编译器会自动完成这个操作（这就是为什么字段必须是final的）。
- en: 'If Java 8 is available on your project, you can, of course, use lambdas, and
    shorten the syntax. However, this still results in an anonymous inner class being
    created. Another pattern for listening for events is to have the class that contains
    the layout (typically an `Activity` or `Fragment`) implement the listener interfaces,
    and use a `switch` statement to handle events from different widgets:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目中有Java 8，当然可以使用lambda表达式，并缩短语法。然而，这仍然会导致创建一个匿名内部类。另一种监听事件的模式是让包含布局的类（通常是`Activity`或`Fragment`）实现监听器接口，并使用`switch`语句来处理来自不同组件的事件：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This has two advantages: there are no new listener objects, and all the layout
    and event logic is now encapsulated within the `Activity` class. The `switch`
    statement carries a tiny overhead, but as the layout increases in size, it becomes
    a lot of boilerplate to maintain and somewhat encourages you to place simple event
    code directly into the `onClick` method, instead of always just dispatching to
    another method. This simple event code almost always leads to more complex event
    code, and eventually to a horrible mess in your code base.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个优点：没有新的监听器对象，并且所有的布局和事件逻辑现在都被封装在`Activity`类中。`switch`语句带来了一点点开销，但随着布局的增大，维护这些样板代码变得很多，这多少会鼓励你直接在`onClick`方法中放置简单的事件代码，而不是总是只是调用另一个方法。这种简单的事件代码几乎总是导致更复杂的事件代码，最终在你的代码库中造成混乱。
- en: 'So, what is the right way to handle events? The answer is that there isn''t
    one, but when deciding how to handle events, you should always consider how you
    will reuse the event handler code--don''t repeat yourself. For the date selection
    widget from the last chapter, the expectation is that when the user taps on the
    date, they will see a calendar dialog open, allowing them to choose a new date.
    This will need an event handler, and such a handler should be reusable since you
    may want it elsewhere, so follow these steps to build the date-picker event listener:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，处理事件的最佳方式是什么？答案是并没有一种方法，但在决定如何处理事件时，你应该始终考虑你将如何重用事件处理器的代码--不要重复自己。对于上一章中的日期选择小部件，预期当用户点击日期时，他们将看到一个日历对话框打开，允许他们选择新日期。这需要一个事件处理器，并且这样的处理器应该是可重用的，因为你可能希望它在其他地方使用，所以按照以下步骤构建日期选择器事件监听器：
- en: 'Right-click on your default package (that is, `com.packtpub.claim`) and select
    New| Java Class:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击你的默认包（即 `com.packtpub.claim`），然后选择“新建| Java 类”：
- en: '![](img/3b39a6a6-872e-41ca-b8a7-ec5badc6ee32.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b39a6a6-872e-41ca-b8a7-ec5badc6ee32.png)'
- en: Name the new class `ui.DatePickerWrapper`; Android Studio will create a new
    package named `ui` automatically and place `DatePickerWrapper` inside it.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `ui.DatePickerWrapper`；Android Studio 将自动创建一个名为 `ui` 的新包，并将 `DatePickerWrapper`
    放入其中。
- en: 'In the Interfaces list, add the following listener interfaces (use commas "`,`"
    to separate the interfaces):'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接口列表中，添加以下监听器接口（使用逗号 "`,`" 分隔接口）：
- en: '`android.view.View.OnClickListener`: To receive an event when the user taps
    on the date picker'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.view.View.OnClickListener`：当用户点击日期选择器时接收事件'
- en: '`android.view.View.OnFocusChangeListener`: To receive an event if the date
    picker receives keyboard focus; this is important to handle if the user chooses
    to navigate the form using the "next" button on the keyboard, or has a physical
    keyboard attached to their device'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.view.View.OnFocusChangeListener`：当日期选择器获得键盘焦点时接收事件；如果用户选择使用键盘上的“下一个”按钮导航表单，或者设备连接了物理键盘，则处理此事件很重要。'
- en: '`android.app.DatePickerDialog.OnDateSetListener`: To receive an event when
    the user selects a new date from `DatePickerDialog`:'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.app.DatePickerDialog.OnDateSetListener`：当用户从 `DatePickerDialog` 中选择新日期时接收事件：'
- en: '![](img/45838db5-91bb-4c6e-b3a1-bb60ae7cbb3a.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45838db5-91bb-4c6e-b3a1-bb60ae7cbb3a.png)'
- en: Click OK to create the new package and class.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新包和类。
- en: 'If Android Studio has not created the skeleton methods for the listeners, select
    class name as `DatePickerWrapper` in the source, and use the code assistant to
    implement the methods:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Android Studio 没有为监听器创建骨架方法，请在源代码中选择类名为 `DatePickerWrapper`，并使用代码助手实现这些方法：
- en: '![](img/9cceaca6-0ba5-425b-9a6a-eb28cb70d41e.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9cceaca6-0ba5-425b-9a6a-eb28cb70d41e.png)'
- en: 'Now you''ll need a way to format the date string for the user, and it should
    be localized, so declare a `java.text.DateFormat` for this purpose:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要一种方式来格式化日期字符串供用户使用，并且它应该是本地化的，因此声明一个 `java.text.DateFormat` 用于此目的：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This class is a wrapper, and will also need some fields to keep track of what
    it is wrapping, namely, the `TextView`, where it will display the date to the
    user (and where the user can tap to open the date picker dialog), an instance
    of `DatePickerDialog` to display to the user, and the currently selected/displayed
    `Date`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此类是一个包装器，还需要一些字段来跟踪它所包装的内容，即 `TextView`，其中它将向用户显示日期（并且用户可以点击以打开日期选择器对话框），一个用于向用户显示的
    `DatePickerDialog` 实例，以及当前所选/显示的 `Date`：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need a simple constructor that will capture `TextView` for display,
    and set it up as a date display and configure the events:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一个简单的构造函数，它将捕获用于显示的 `TextView`，并将其设置为日期显示并配置事件：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we''ll need getter and setter-like methods to change and retrieve the
    state of the date picker:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要类似 getter 和 setter 的方法来更改和检索日期选择器的状态：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we can actually handle the event, we need a method to display `DatePickerDialog`
    that will allow the user to change the date:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实际处理事件之前，我们需要一个方法来显示 `DatePickerDialog`，这将允许用户更改日期：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we need to complete the event listener methods so that when the user
    selects the displayed date, we open the `DatePickerDialog`, allowing them to change
    the selected date:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要完成事件监听器方法，以便当用户选择显示的日期时，我们打开 `DatePickerDialog`，允许他们更改所选日期：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we need to handle the event that comes back from the `DatePickerDialog`,
    indicating that the user has chosen a date:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要处理从 `DatePickerDialog` 返回的事件，该事件指示用户已选择日期：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you have a class that can turn any `TextView` object into a space where
    the user can select a date via the standard `DatePickerDialog`. This is an ideal
    example of a good place to encapsulate events; you actually have three different
    event handlers that perform a related group of actions, and maintain user interface
    state in a single class that can be reused throughout your application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个可以将任何`TextView`对象转换成用户可以通过标准`DatePickerDialog`选择日期的空间的类。这是一个很好的封装事件的例子；你实际上有三个不同的事件处理器执行一组相关的操作，并在一个可以被整个应用程序重用的类中维护用户界面状态。
- en: Wiring the CaptureClaimActivity events
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接CaptureClaimActivity事件
- en: 'Now that we have a way for the user to pick a date for their travel expense
    claims, we need to actually wire it into the `CaptureClaimActivity`, which is
    where all the logic and wiring for the screen will live. To start wiring the events
    for the `CaptureClaimActivity`, follow these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种让用户为他们的旅行费用报销选择日期的方法，我们需要将其实际连接到`CaptureClaimActivity`，这是所有屏幕逻辑和连接将存在的位置。要开始连接`CaptureClaimActivity`的事件，请按照以下步骤操作：
- en: Open the `CaptureClaimActivity.java` file in Android Studio.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开`CaptureClaimActivity.java`文件。
- en: 'Now, declare a new field in the class (before the `onCreate` method) for the
    `DatePickerWrapper` that you wrote (Android Studio can help by writing the import
    for you):'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在类中（在`onCreate`方法之前）声明一个新的字段用于你编写的`DatePickerWrapper`（Android Studio可以通过为你编写导入语句来帮助你）：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You''ll note that (by default) the `FloatingActionButton` object is wired up
    with a simple anonymous event handler that will look something like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到（默认情况下），`FloatingActionButton`对象与一个简单的匿名事件处理器连接，其外观可能如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is how many once off events get wired up (as discussed earlier in this
    chapter), but it's not what we want to do here, so remove that entire block of
    code.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是许多一次性事件是如何连接的（如本章前面所讨论的），但这不是我们想要做的，所以删除整个代码块。
- en: 'At the end of the `onCreate` method instantiate the `DatePickerWrapper` object
    by searching for the `date` `TextView` you added to the layout:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法的末尾，通过搜索你添加到布局中的`date` `TextView`来实例化`DatePickerWrapper`对象：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You don't need to hold any other references to the `date` `TextView`, since
    you'll only ever need to access it through the `DatePickerWrapper` class. Try
    running your application now, and see how the date picker works.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不需要保留对`date` `TextView`的任何其他引用，因为你将只通过`DatePickerWrapper`类访问它。现在尝试运行你的应用程序，看看日期选择器是如何工作的。
- en: 'In the application, you''ll note that you can select the category icons, and
    they will work exactly as expected. However, the label following them isn''t wired
    up at all, and no labels will be displayed, leaving the user confused as to what
    they are actually selecting. To fix this, you''ll need another event listener
    that sets the content of the label when the state of the `RadioButton` widgets
    is changed. This is another case where a specialized listener class will make
    sense; since it''ll be usable anytime, you have a group of icon `RadioButton`
    widgets and a single label for all of them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用中，你会注意到你可以选择类别图标，并且它们将按预期工作。然而，跟在它们后面的标签完全没有连接，不会显示任何标签，使用户对实际选择的内容感到困惑。为了解决这个问题，你需要另一个事件监听器，当`RadioButton`小部件的状态改变时，它会设置标签的内容。这是一个专门监听器类很有意义的情况；因为它可以在任何时候使用，你有一组图标`RadioButton`小部件和一个为所有这些小部件共享的标签：
- en: Right-click on the `ui` package and select New | Java Class.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`ui`包，选择“新建”|“Java类”。
- en: Name the new class as `IconPickerWrapper`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`IconPickerWrapper`。
- en: Add `android.widget.RadioGroup.OnCheckedChangeListener` to the interfaces box.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`android.widget.RadioGroup.OnCheckedChangeListener`添加到接口框中。
- en: 'Create a field for the `TextView` label, and a constructor to capture it:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`TextView`标签创建一个字段，并创建一个构造函数来捕获它：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a method to set the label text content:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来设置标签文本内容：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Complete the `onCheckedChange` method to set the label text from the `contentDescription`
    field of the selected `RadioButton`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成设置标签文本的`onCheckedChange`方法，从所选`RadioButton`的`contentDescription`字段中设置：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a very straightforward class, but it also potentially serves other
    purposes in your application, and it only makes two assumptions about the `RadioGroup`
    it will be connected to:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的类，但它也可能在你的应用程序中服务于其他目的，并且它只对将要连接的`RadioGroup`做出了两个假设：
- en: Every `RadioButton` has a valid ID
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`RadioButton`都有一个有效的ID
- en: Every `RadioButton` has a `contentDescription` that will serve as a text label
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`RadioButton`都有一个`contentDescription`，它将作为文本标签使用
- en: 'Going back to `CaptureClaimActivity`, you''ll want to wire this new listener
    into the layout through the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`CaptureClaimActivity`，您将通过以下步骤将此新监听器连接到布局：
- en: 'Before the `onCreate` method, create a new field to keep track of the `RadioGroup`,
    where the user can select the category icon:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法之前，创建一个新的字段来跟踪用户可以从中选择类别图标的`RadioGroup`：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, at the end of the `onCreate` method, you''ll need to find this `RadioGroup`
    in the layout, and instantiate its event handler:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`onCreate`方法的末尾，您需要找到布局中的`RadioGroup`，并实例化其事件处理器：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, set the default selection to `other`; this action will also trigger
    the event handler before the screen is presented to the user. This means the label
    will also be populated when the user first sees the Capture Claim screen:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将默认选择设置为`other`；此操作还会在屏幕呈现给用户之前触发事件处理器。这意味着当用户第一次看到捕获报销屏幕时，标签也会被填充：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now if you run the application again, you'll see the labels defined to appear
    beneath the selected icons as you toggle through the category icons.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您再次运行应用程序，您将看到定义的标签在切换类别图标时出现在所选图标下方。
- en: Handling events from other activities
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理来自其他活动的事件
- en: On Android, you'll often find that you want to send your user to another `Activity`
    to do something, and then return them to your current `Activity` with the result
    of that action. Good examples are having the user pick a contact, or take a photo
    with the camera app. In these cases, Android uses a system of special events that
    are built into the `Activity` class. For capturing travel expense claims, your
    user needs to be able to go select a file to attach things such as photos or email
    attachments to their claim.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，您经常会发现您想要将用户发送到另一个`Activity`去做某事，然后带着该动作的结果返回到当前`Activity`。好的例子包括让用户选择联系人或使用相机应用程序拍照。在这些情况下，Android使用一个内置在`Activity`类中的特殊事件系统。对于捕获旅行费用报销，您的用户需要能够选择文件以附加照片或电子邮件附件等。
- en: In order to present them with a familiar file chooser (and avoid writing a file
    chooser ourselves), you'll need to use this mechanism. However, to read files
    from outside of your application's private space, you'll need it to ask the user
    for permissions. Anytime an application needs access to potentially sensitive
    data (public directories, the device's camera or microphones, contact list, and
    so on), you need permission from the user. In versions of Android prior to 6.0,
    this was done during installation; the application declared what permissions it
    needed, and the user could choose to not install it. However, this mechanism isn't
    very flexible to users, and was changed in 6.0 so that applications must now ask
    for permission at runtime.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户提供一个熟悉的文件选择器（并避免自己编写文件选择器），您需要使用此机制。然而，为了从应用程序的私有空间之外读取文件，您需要请求用户的权限。每当应用程序需要访问可能敏感的数据（公共目录、设备的相机或麦克风、联系人列表等）时，您需要用户的权限。在Android
    6.0之前的版本中，这是在安装期间完成的；应用程序声明它需要的权限，用户可以选择不安装它。然而，这种机制对用户来说不够灵活，并在6.0中进行了更改，使得应用程序现在必须在运行时请求权限。
- en: 'In order to access the user''s files, the application will both declare that
    it requires the permission, and will also include the code to ask for permission
    while it''s running (covering both cases):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问用户的文件，应用程序将声明它需要权限，并在运行时包含请求权限的代码（覆盖两种情况）：
- en: 'Open the `CaptureClaimActivity` class, and make the class implement the `View.OnClickListener`
    interface:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CaptureClaimActivity`类，并使该类实现`View.OnClickListener`接口：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create two new constants to hold the request codes. Anytime your user leaves
    your current `Activity`, and you are expecting a result, you need a request code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个新的常量来保存请求代码。每当您的用户离开当前`Activity`，并且您期望得到结果时，您需要一个请求代码：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `onCreate` method, find the line where the Android Studio template captures
    the `FloatingActionButton`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，找到Android Studio模板捕获`FloatingActionButton`的行：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Rename the button to `attach`, as follows (use the Android Studio refactoring
    to change the ID, and the ID in the layout file will be changed as well):'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮重命名为`attach`，如下所示（使用Android Studio重构更改ID，布局文件中的ID也将相应更改）：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, set `OnClickListener` for the `FloatingActionButton` to `Activity`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为`FloatingActionButton`设置`OnClickListener`为`Activity`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, at the end of the `CaptureClaimActivity`, implement the `onClick` method,
    and delegate the click from the `FloatingActionButton`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`CaptureClaimActivity`的末尾实现`onClick`方法，并将`FloatingActionButton`的点击事件委托：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Your application will need permission to read the content from outside its
    own private space. Open the `manifests` folder in the file browser, and open the
    `AndroidManifest.xml` file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的应用程序需要权限才能从其自身的私有空间外读取内容。在文件浏览器中打开 `manifests` 文件夹，并打开 `AndroidManifest.xml`
    文件：
- en: '![](img/5210edbb-3122-4226-bd6d-1cddd9927762.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5210edbb-3122-4226-bd6d-1cddd9927762.png)'
- en: 'At the top of the file within the `manifest` element, but before the application
    element, add the following permission declaration:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `manifest` 元素内的文件顶部，但在应用程序元素之前，添加以下权限声明：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding permission only works for versions of Android where permissions
    were requested during installation; on Android 6.0 and newer, you need to check
    and request permissions at runtime. Doing this when the user taps on the `FloatingActionButton`
    to attach a file is the best time, as this is just before they actually choose
    a file that you will need permission to read. Implement the `onAttachClick` method,
    starting with a check for the permission, and request the permission if it''s
    not already granted:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的权限仅适用于在安装期间请求权限的 Android 版本；在 Android 6.0 及更高版本中，你需要在运行时检查和请求权限。当用户点击 `FloatingActionButton`
    附加文件时进行此操作是最佳时机，因为这正是在他们实际选择你将需要权限读取的文件之前：实现 `onAttachClick` 方法，从检查权限开始，如果尚未授予，则请求权限：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now the app can request that the system start an `Activity`, allowing the user
    to choose any openable file. This is where the `REQUEST_ATTACH_FILE` constant
    you defined earlier starts getting used:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，应用程序可以请求系统启动一个 `Activity`，允许用户选择任何可打开的文件。这就是你之前定义的 `REQUEST_ATTACH_FILE`
    常量开始被使用的地方：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we failed the preceding permission check, the system will have launched
    a dialog asking whether the user would grant permission to access external files.
    When the user returns from this dialog, a method named `onRequestPermissionsResult`
    will be invoked. Here, you need to check whether they granted your request, and
    if so, you can simply trigger the `onAttachClick()` method to continue the process
    smoothly:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们之前的权限检查失败，系统将启动一个对话框询问用户是否授予访问外部文件的权限。当用户从该对话框返回时，将调用一个名为 `onRequestPermissionsResult`
    的方法。在这里，你需要检查他们是否授予了你的请求，如果是的话，你可以简单地触发 `onAttachClick()` 方法以顺利继续流程：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now when the system returns from the file chooser `Activity`, it will invoke
    a method called `onActivityResult`, which is very similar in structure to the
    `onRequestPermissionResult` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当系统从文件选择器 `Activity` 返回时，它将调用一个名为 `onActivityResult` 的方法，这个方法的结构与 `onRequestPermissionResult`
    方法非常相似：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding `onActivityResult`, you simply check whether it''s responding
    to your request to attach a file, and then delegate the rest to a method that
    will need to handle the resulting data:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的 `onActivityResult` 中，你只需检查它是否响应了你附加文件的请求，然后将剩余的操作委托给一个需要处理结果数据的方法：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Verify that the `resultCode` was okay and that the data is valid:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `resultCode` 是否正常，并且数据是否有效：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For now, you''ll just want a `Toast` to pop up showing that this code has run;
    later, you can build the complete logic to attach the selected file. A `Toast`
    is a small message that appears and then disappears with no user interaction,
    perfect for temporary messages or debugging:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，你只需要一个 `Toast` 弹出显示此代码已运行；稍后，你可以构建完整的逻辑来附加选定的文件。`Toast` 是一个出现后消失的小消息，无需用户交互，非常适合临时消息或调试：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, if you run the application and tap on the floating action *attach* button,
    you''ll be rewarded with a permission request (if you''re running Android 6 or
    higher, on earlier versions the permission is granted as part of the installation),
    and then the option to select a file with whatever file selection systems you
    might have available on your emulator or device. Once you have chosen a file,
    you''ll be returned to the `CaptureClaimActivity` and the selected `Uri` will
    be displayed in a `Toast` message on the screen:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行应用程序并点击浮动操作 *附加* 按钮，你将获得一个权限请求（如果你运行的是 Android 6 或更高版本，在早期版本中权限是作为安装过程的一部分授予的），然后你可以使用你模拟器或设备上可用的任何文件选择系统选择文件。一旦你选择了文件，你将返回到
    `CaptureClaimActivity`，选定的 `Uri` 将在屏幕上的 `Toast` 消息中显示：
- en: '![](img/2278ca49-4dbc-4f1a-8529-437fb5493b50.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2278ca49-4dbc-4f1a-8529-437fb5493b50.png)'
- en: This might not look like much, but it's all you need to access the file later
    on and attach it to the claim that the user is capturing. When you need to send
    your user to another Activity, you're hooking into Android's `Activity` to `Activity`
    messaging systems through methods such as `onActivityResult` and `onRequestPermissionsResult`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不多，但这是您以后访问文件并附加到用户正在捕获的声明所需的所有内容。当您需要将用户发送到另一个Activity时，您将通过`onActivityResult`和`onRequestPermissionsResult`等方法将Android的`Activity`到`Activity`的消息系统挂钩。
- en: Making events quick
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使事件处理快速
- en: 'Android places very strict limits on the use of threads in applications: every
    application has a main thread, where all user-interface related code must run,
    but any long-running code will cause an error. Any attempt at networking on the
    main thread will result in a `NetworkOnMainThreadException` immediately, as networking
    by its very nature will block the main thread for too long, making the application
    unresponsive.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Android对应用程序中线程的使用施加了非常严格的限制：每个应用程序都有一个主线程，所有与用户界面相关的代码都必须在此线程上运行，但任何长时间运行的代码都会导致错误。在主线程上尝试进行网络操作将立即导致`NetworkOnMainThreadException`，因为网络操作的本质会阻塞主线程太长时间，使应用程序无响应。
- en: This means most tasks that you will want to perform should take place on a background
    worker thread. This will also provide you with a form of isolation from the user
    interface, as typically you will capture the user interface state on the main
    thread, pass the state to the background thread, process the event and then, send
    the result back to the main thread where you will update the user interface. How
    do we know that the state we capture will be consistent? The answer is that because
    user interface code can only run on the main thread, while you read the state
    of the widgets, any events that would change their state are blocked until you
    are finished (because they must also occur on the main thread). The message queue
    and threading rules avoid the need for locks and other thread protection mechanisms
    by ensuring that only one unit of code (in the form of a message) is processed
    at a time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您想要执行的大多数任务应该在后台工作线程上执行。这还将为您提供一种与用户界面的隔离形式，因为通常您会在主线程上捕获用户界面状态，将状态传递到后台线程，处理事件，然后，将结果发送回主线程，在那里您将更新用户界面。我们如何知道我们捕获的状态将是一致的？答案是，因为用户界面代码只能在主线程上运行，而您读取小部件的状态时，任何会改变其状态的事件都会被阻塞，直到您完成（因为它们也必须在主线程上发生）。消息队列和线程规则通过确保一次只处理一个代码单元（以消息的形式）来避免锁和其他线程保护机制的需求。
- en: Android tasks that require larger amounts of background processing time are
    usually written using the `AsyncTask` class provided by the Android platform (or
    one of its child classes). `AsyncTask` has methods for running code on a background
    worker, and publishing status updates to the main thread (and receiving these
    update messages), along with several other utility structures. This makes it ideally
    suited to tasks such as downloading large files, where the user needs to be kept
    informed of the download's progress. However, most event handlers you will implement
    won't need anywhere near to this level of complexity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要大量后台处理时间的Android任务通常使用Android平台提供的`AsyncTask`类（或其子类）编写。`AsyncTask`具有在后台工作线程上运行代码的方法，以及向主线程发布状态更新（并接收这些更新消息），以及几个其他实用结构。这使得它非常适合像下载大文件这样的任务，用户需要了解下载的进度。然而，您将要实现的多数事件处理器不需要接近这种复杂程度。
- en: 'Most event handlers are relatively lightweight, but that doesn''t mean that
    it will perform quickly on all devices in all situations. You can''t control what
    else the user is busy doing with their device, and a simple database query can
    end up taking much longer than expected. As such, it''s better to push event processing
    to background threads wherever the event is not purely a user-interface update
    (that is, showing a dialog or similar). Even fairly small tasks should be moved
    to a background thread so that the main thread can continue consuming the user''s
    input; this will keep your application responsive. Here''s the pattern you should
    try and follow when implementing event handlers:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数事件处理器相对轻量级，但这并不意味着它在所有设备和所有情况下都会快速执行。您无法控制用户在设备上忙于做什么，一个简单的数据库查询可能会比预期的花费更长的时间。因此，最好将事件处理推送到后台线程，只要事件不是纯粹的用户界面更新（即显示对话框或类似内容）。即使是相当小的任务也应该移动到后台线程，这样主线程就可以继续消耗用户的输入；这将保持您的应用程序响应。以下是实现事件处理器时应尝试遵循的模式：
- en: '**On the Main Thread**: First, capture any required parameters'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在主线程上**：首先，捕获任何所需的参数'
- en: '**On a Background Worker**: Process the user''s event and data'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在后台工作者上**：处理用户的事件和数据'
- en: '**On the Main Thread**: End by updating the user interface with the new state'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在主线程上**：最后，通过更新用户界面来更新新状态'
- en: 'If you keep to this pattern, the application will always appear responsive
    to your users, since processing their data isn''t stopping their events from being
    processed (events which may be them scrolling through a large list, for example).
    However, `AsyncTask` is not a great fit for these smaller events (such as attaching
    a file to a claim), so here''s how to write a simple class (in a similar style
    to the command pattern) that will run first some code on the background and then
    pass the result of that code to another method on the main thread, perfect for
    carrying out smaller events:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您坚持这种模式，应用程序将始终对用户保持响应，因为处理数据不会阻止处理他们的事件（例如，他们可能正在滚动一个大型列表）。然而，`AsyncTask`
    并不适合这些较小的事件（例如，将文件附加到索赔），因此以下是如何编写一个简单的类（类似于命令模式的风格）的示例，它将首先在后台运行一些代码，然后将该代码的结果传递到主线程上的另一个方法，非常适合执行较小的事件：
- en: Right-click on your root package (that is, `com.packtpub.claim`) and choose
    New| Java Class.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您的根包（即 `com.packtpub.claim`），然后选择 New| Java Class。
- en: Name the class `util.ActionCommand`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类命名为 `util.ActionCommand`。
- en: Change the Modifiers to make the new class `Abstract`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将修饰符更改为使新类 `Abstract`。
- en: Click OK to create the new package (`util`) and class.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 OK 创建新包（`util`）和类。
- en: 'Change the class definition to include generic parameters for a "parameter"
    and a "returned" type:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类定义修改为包含用于“参数”和“返回值”的泛型参数：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At the top of the new class, create a static constant that refers to the application
    main thread via an `android.os.Handler` object:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新类顶部创建一个静态常量，通过 `android.os.Handler` 对象引用应用程序的主线程：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A `Handler` object is how you gain access to another thread's message-queue
    in Android. In this case, any message or `Runnable` object posted to this `Handler`
    will be run on the main thread as soon as possible. You can also post tasks to
    be run at specific times or after a specified delay. This is the preferred method
    of creating timers on Android.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，`Handler` 对象是用来访问另一个线程的消息队列的方式。在这种情况下，任何发送到这个 `Handler` 的消息或 `Runnable`
    对象都将尽可能快地在主线程上运行。您还可以发布需要在特定时间或延迟后运行的任务。这是在 Android 中创建计时器的首选方法。
- en: 'Create three method declarations for running code on the background worker,
    the main thread, and one for handling errors (with a default implementation):'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个方法声明，用于在后台工作者、主线程上运行代码以及处理错误（具有默认实现）：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, create two variations of an exec method that will be used to start the
    `ActionCommand` objects. The first one uses the standard `Executor` provided by
    `AsyncTask` that uses a single background thread to process tasks (this is the
    most common behavior you will want in an application):'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建两个 exec 方法的变体，用于启动 `ActionCommand` 对象。第一个使用 `AsyncTask` 提供的标准 `Executor`，该
    `Executor` 使用单个后台线程来处理任务（这是您在应用程序中希望看到的最常见行为）：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding method, we submit an `ActionCommandRunner` object to the background
    `Executor` object; this is a `private` inner class that will carry the state between
    the background and main thread, which keeps the `ActionCommand` classes reusable
    and stateless:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们向后台 `Executor` 对象提交一个 `ActionCommandRunner` 对象；这是一个 `private` 内部类，将在后台和主线程之间传递状态，这使
    `ActionCommand` 类可重用且无状态：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`ActionCommandRunner` will be in one of the three possible states: background,
    foreground, or error. Declare three constants as names, and a field to keep track
    of which state the object is in:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ActionCommandRunner` 将处于三种可能状态之一：后台、前台或错误。声明三个常量作为名称，并声明一个字段来跟踪对象所处的状态：'
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, you''ll need fields for the `ActionCommand` being run, and the current
    value. The `value` field is a catch-all in this class holding either the input
    parameter, the output from the background code, or the `Exception` thrown from
    the background code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要为正在运行的 `ActionCommand` 和当前值创建字段。`value` 字段是本类的一个通配符，它包含输入参数、后台代码的输出或从后台代码抛出的
    `Exception`：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, create methods to handle each of the `ActionCommandRunner` states:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建处理每个 `ActionCommandRunner` 状态的方法：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, create the `run` method that will call the preceding `onBackground`,
    `onForeground` or `onError` method depending on the current execution state of
    `ActionCommandRunner`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个`run`方法，该方法将根据`ActionCommandRunner`的当前执行状态调用前面的`onBackground`、`onForeground`或`onError`方法：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This class makes it very easy to create and reuse small tasks, which can be
    extended, composed, mocked, and tested in isolation. It's a good idea whenever
    creating a new event handler to consider a command pattern or something similar
    so that the event isn't coupled to the widget or even the screen that you are
    busy with. This allows for better code reuse, and keeps code easier to test since
    you can test the event handler without the screen that it will be part of later.
    You can also make these classes even more modular by writing them as `abstract`
    classes with only their `onBackground` methods implemented, allowing the result
    to be processed in different ways by subclasses.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使得创建和重用小型任务变得非常容易，这些任务可以被扩展、组合、模拟和单独测试。在创建新的事件处理器时，考虑命令模式或类似模式是个好主意，这样事件就不会与您正在忙于的部件或屏幕耦合。这允许更好的代码重用，并使代码更容易测试，因为您可以在它将作为其中一部分的屏幕出现之前测试事件处理器。您还可以通过将它们编写为仅实现其`onBackground`方法的`abstract`类来使这些类更加模块化，允许子类以不同的方式处理结果。
- en: Multiple event listeners
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个事件监听器
- en: Unlike many other event systems, however, many Android components only allow
    a single event listener of certain types; this diverges from platforms such as
    Java desktop, or JavaScript in the browser, where any number of **click** listeners
    can be attached to a single element. In Android, click listeners are almost always
    **set** rather than **added**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其他许多事件系统不同，许多Android组件仅允许某些类型的事件有单个事件监听器；这与Java桌面平台或浏览器中的JavaScript不同，在这些平台上，可以为单个元素附加任意数量的**点击**监听器。在Android中，点击监听器几乎总是**设置**而不是**添加**。
- en: This is actually a clever tradeoff--having multiple listeners for each event
    means that you need at least an array of them; the array needs to be sized and
    copied when it runs out of space, while it's actually very seldom that multiple
    listeners are needed. Multiple listeners also means that the widgets must traverse
    the list every time they want to dispatch events, so sticking to a single listener
    simplifies the code, and reduces the amount of required memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个巧妙的权衡——为每个事件拥有多个监听器意味着你需要至少一个监听器数组；当数组空间不足时，需要对其进行大小调整和复制，但实际上很少需要多个监听器。多个监听器还意味着小部件每次想要分发事件时都必须遍历列表，因此坚持使用单个监听器可以简化代码，并减少所需的内存量。
- en: 'If you ever find yourself needing more than one listener for an event and widget
    that only provides a single listener slot, simply write a simple delegate class,
    like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要一个事件和仅提供单个监听器槽的小部件的多个监听器，只需简单地编写一个简单的委托类，如下所示：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding pattern allows compact and flexible multilistener delegation in
    the cases where you might need it. The `CopyOnWriteArrayList` class is an ideal
    listener container, as its internal array is only ever as large as the number
    of elements, so it remains compact (rather than having a buffer space like `ArrayList`
    and similar implementations).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式允许在可能需要的情况下进行紧凑和灵活的多监听器委托。`CopyOnWriteArrayList`类是一个理想的监听器容器，因为其内部数组的大小始终与元素数量相同，因此它保持紧凑（而不是像`ArrayList`和类似实现那样有缓冲空间）。
- en: Test your knowledge
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: What's the best way to implement event handlers?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现事件处理器的最佳方式是什么？
- en: As an anonymous inner class
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为匿名内部类
- en: By making the `Activity` a listener
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`Activity`设为监听器
- en: As a class per listener
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为每个监听器一个类
- en: There isn't one
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有特定的条件
- en: What are the conditions for any methods that change the state of a user-interface
    widget?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变用户界面小部件状态的任何方法需要满足哪些条件？
- en: They must be called from a background thread
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须从后台线程调用
- en: They must be thread-safe
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须线程安全
- en: They must be called from the main thread
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须从主线程调用
- en: They must be called from the graphics thread
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须从图形线程调用
- en: Code running as part of an event handler should fulfill which of the following
    conditions?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为事件处理程序运行的部分代码应满足以下哪些条件？
- en: Be surrounded by a synchronized block
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被一个同步块包围
- en: Run as quickly as possible
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快运行
- en: Only interact with the user interface
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅与用户界面交互
- en: When requesting data from another `Activity`, the data is returned through which
    of these?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从另一个`Activity`请求数据时，数据是通过以下哪种方式返回的？
- en: An event listener you add to the `Activity` object
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加到`Activity`对象中的事件监听器
- en: A callback on your `Activity` object
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对您的`Activity`对象上的回调
- en: A message placed on your application's message queue
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置在您应用程序的消息队列上的消息
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Android uses several different mechanisms when delivering events within its
    applications, each one tailored to the type of event being delivered and the intended
    recipient of the event. Most user-interface events are delivered to a single listener
    registered to each widget, but that doesn't stop the same listener from handling
    multiple event types from different widgets. This sort of design will reduce the
    load on the system and the amount of memory used, and will often help in producing
    more reusable code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Android在应用程序内部传递事件时使用了几种不同的机制，每种机制都针对传递的事件类型和事件预期的接收者进行了定制。大多数用户界面事件都传递给每个小部件注册的单个监听器，但这并不妨碍同一个监听器处理来自不同小部件的多个事件类型。这种设计将减少系统负载和内存使用量，并且通常有助于生成更多可重用的代码。
- en: Event handlers are often written badly and become anonymous inner classes that,
    while starting life as a simple delegate to another method, eventually become
    bloated and unmaintainable blocks of code. It's often better to isolate the event
    handlers from their environment from the beginning as this encourages them to
    be reused, and makes them easier to test and maintain. Some event handler classes
    (such as `DatePickerWrapper`) handle different types of events in a way that is
    related, allowing for a single class to encapsulate a small, reusable bit of logic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器通常编写得不好，最终变成了匿名内部类，这些类最初可能只是另一个方法的简单委托，但最终会变得臃肿且难以维护。通常最好从一开始就将事件处理器与其环境隔离开来，因为这鼓励它们被重用，并使它们更容易进行测试和维护。一些事件处理器类（如`DatePickerWrapper`）以相关的方式处理不同类型的事件，允许单个类封装一小块可重用的逻辑。
- en: In the next chapter, we'll explore more of how to build reusable and more easily
    testable user interfaces, by breaking down user interfaces into smaller components.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过将用户界面分解成更小的组件来构建可重用且易于测试的用户界面。
