- en: Chapter 10. Data Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking where your IP is from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking your phone activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling your stocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a voting device using CouchDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might know, nowadays it is very difficult to imagine an app that doesn't
    store anything on hard disk. Simple apps such as a calculator or a compass might
    not need to store any information, but usually you will need to create apps with
    more complex features and that will need to keep information even if the device
    reboots.
  prefs: []
  type: TYPE_NORMAL
- en: When you have to store a minimum amount of information such as a simple date,
    or just the current app version, you can use a file as we have done in the previous
    chapters of this book, but when you have to store a few records with different
    data structures, you need the help of a database.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to use databases on Swift and you
    will see the advantages of each method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, storing information on a mobile app is done with a local database.
    To do that, it is very common to use SQLite because even if it is a bit limited,
    this database has some advantages, such as it is a serverless database, it is
    zero-configuration, and it is built in iOS and Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we are going to download an SQLite file; therefore you will
    need an SQLite client for reading this file. So beside the iFunBox downloaded
    in the previous chapter, you will also need to download a program such as SQLiteBrowser
    ([http://sqlitebrowser.org/](http://sqlitebrowser.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Chapter 10 SQLite`; keep in mind where you saved
    this recipe because we are going to complete it in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the project is created, click on the **General** tab and scroll down until
    you get to the section **Linked Frameworks and Libraries**. Click on the plus
    sign for adding a new library and select `libsqlite3.tbd`:![How to do it…](img/00144.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, let''s create a new bridging file by adding a new header file called
    `BridgingHeader.h`; check that it is set as a bridging header in the **Build Settings**.
    In this file, include the `sqlite3.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add a new file called `SQLite.swift`; here we are going to start coding
    a class called `SQLite` and inside of it an enumeration called `status`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create two attributes, one for the connection with the database
    and another one for the current connection status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is creating a read-only computed attribute that returns the current
    connection status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, you can create a method that opens a connection with the database.
    For this method, we will need only the filename as an argument; however, we are
    going to store it in the documents folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last detail for this class is the deinitializer that should close the database
    connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The model part is done; now let's create the view part by clicking on the storyboard
    and adding a label, a text field, and a button, something similar to this layout:![How
    to do it…](img/00145.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now connect the text field with the view controller and call it `databaseNameTextField`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it is done, you can create an action for the only button; in this case
    we are going to open the database connection, create a table and check whether
    everything was done successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This app is done. Better off saying, this first version is done; now press play
    and write a filename for your database, such as `mydatabase`, and then press the
    button for creating a database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's check the real application, so open your iFunBox and search for the
    app `Chapter 10 SQLite`; open its `Document` folder, select the only file that
    is in this folder, then press the button **Copy to Mac** and save it in your local
    documents folder:![How to do it…](img/00146.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have the empty database, let's check whether we are able to open it.
    Open your Sqlite browser (only supports 8.3 and below) and click on the **Open**
    **Database** button:![How to do it…](img/00147.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the database file you have downloaded and open it. After that, you should
    see on the main panel and on the database schema a table called `ips`, which means
    that your database was created successfully and it can create a table without
    any errors:![How to do it…](img/00148.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite is not a framework; rather, it is a library that uses the traditional
    C functions instead of Objective-C or Swift objects.
  prefs: []
  type: TYPE_NORMAL
- en: As you might know, using C functions implies using C types; that's the reason
    we had to use `UnsafeMutablePointer<CChar>` for the error message and `COpaquePointer`
    for the database handle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`COpaquePointer` represents a C pointer such as `UnsafeMutablePointer`, but
    it is used when you can''t represent the pointer type on Swift, such as some structs,
    for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we used three SQLite functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlite3_open`: This function opens a database. It creates a new database file
    if one doesn''t exist. This function receives as an argument the file name and
    a handle pointer by reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't want to create a database file, you can use in-memory databases;
    check it out at [https://www.sqlite.org/inmemorydb.html](https://www.sqlite.org/inmemorydb.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sqlite3_close`: This function closes the connection with the database and
    frees the resources that are being used for this connection. Bear in mind that
    C has no objects, no garbage collector, and no automatic reference counter; therefore,
    if you don''t free the resources, they are going to be there until your application
    finishes or crashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_exec`: This function executes an SQL statement; in this case it wasn''t
    really necessary because we just want to check whether the file was created or
    not; however sometimes SQLite creates only an empty file if you don''t use the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQLite has a lot of options and functions; you can check out more about it
    at the official website: [https://www.sqlite.org/cintro.html](https://www.sqlite.org/cintro.html).
    Now that you know how to create a database, let''s work with it, creating registers
    and querying results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking where your IP is from
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need to query from a remote database, but as you know, SQLite
    works with a local database, meaning that you have to populate it before querying.
    In this recipe, we are going to convert a CSV file into an SQLite database and
    after that we are going to query some results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we are going to need a CSV file with the ranges of IPs of each
    country. There are some websites that give or sell it to you. You can download
    it free from [https://db-ip.com/db/download/country](https://db-ip.com/db/download/country).
    Uncompress it, and add it into your SQLite application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now this file is called `dbip-country-2014-12.csv`, but it changes its
    name every month, so replace the filename where it is mentioned with the one you
    have.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start completing the SQLite class by adding two additional methods,
    one of which is for executing statements that don''t return any result, such as
    insert, delete, and update queries. To do it, click on the file `SQLite.swift`
    and inside the SQLite class add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s add a new file called `Functions.swift` in your project. This file
    will contain some auxiliary functions. The first function that we are going to
    create is the one that reads a CSV file and returns its contents inside a double
    array of string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need two additional functions related to the IP string; the first one
    will check whether the input string has an IPv4 format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next function will convert the IP from a string to an unsigned integer;
    it will allow us to compare if an IP is in a range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have finished with the auxiliaries functions, now we have to update the storyboard.
    Go to your storyboard and add two more buttons, one with the word **Populate**
    and another one with the word **Search**, something similar to the following screenshot:![How
    to do it…](img/00149.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to set these buttons as hidden by default, because we are not going
    to insert any register before creating the database. To do it, click on one of
    these new buttons, go to the attribute inspector, check the **Hidden** option,
    and then repeat the operation with the other button:![How to do it…](img/00150.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the storyboard is done, we have to update the view controller. Let''s
    start by connecting the label and the three buttons with the view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We still need another attribute that is the database connection, which is inside
    the action of creating a database, so what we are going to do is move the declaration
    with the initialization from inside the method `createDatabase` to outside of
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we are working near the `createDatabase` method, we can take advantage of
    it and update it by hiding some unneeded views and displaying only the **Populate**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that we can connect the **Populate** button with a new action. This action
    will be called `populate` and it will call an `insert` statement on our database
    then it will display the **Search** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you might imagine, we need to develop the search action. First, it needs
    to check whether the input is correct and after that it will look for the IP range
    where it belongs. If it is able to find it, it will show the country where the
    IP belongs, otherwise it will show that the country wasn''t found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again we have completed another app and we need to test it. Press play,
    write on the test field `mydatabase`, and press **Create database**. Now you should
    see only the populate button on screen, tap on it—it will take a while until it
    finishes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you would like to know when the app starts writing to disk when you are
    developing, you can click on the debugger navigator and then on the disk report,
    and you should see some bars with the disk-writing activity, as shown in the following
    image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00151.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The last step is looking for the country of a specific IP, so type an IP in
    the text field when it appears, for example `74.125.230.52` and press **Search**.
    You should receive an alert displaying where this IP is from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL has two kinds of queries:'
  prefs: []
  type: TYPE_NORMAL
- en: There are queries that modify the data structure, such as `CREATE TABLE` and
    `ALTER TABLE`, or modify the data content, such as `INSERT`, `DELETE`, or `UPDATE`,
    which are going to be shown in the next section. These queries usually don't return
    any data. For this kind of query you can use the function `sqlite3_exec`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries that retrieve information such as `SELECT`. Here you have to work in
    a different way; you need to use the function `sqlite3_prepare_v2` for executing
    the query and `sqlite3_step` for retrieving each record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you check the SQLite API documentation you will see that `sqlite3_exec` can
    also return a result from a `SELECT` statement; however it needs a pointer to
    a function for each record received (what is called a callback).
  prefs: []
  type: TYPE_NORMAL
- en: If you have developed your function in C you can have a pointer to it by using
    a variable of type `CFunctionPointer`, but bear in mind that this data type can't
    be used for pointing to Swift functions. Make sure that SQLite has its own constants,
    such as `SQLITE_OK` for indicating that the operation has finished successfully,
    `SQLITE_ROW`, which tells us that it could receive a record from the statement
    result, or `SQLITE_DONE`, which is saying that there are no more records on this
    statement result.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we had a common case of converting a text file into database records.
    Check in detail when you need to do a similar task. First we added every record
    in an array; it took approximately 80 megabytes of RAM by the time we finished
    inserting the records. This isn't a problem because even low-end devices such
    as the iPhone 4S has 512 megabytes of RAM, but if you decide to load the cities'
    IP database, it can consume a lot of memory, so you would probably need to split
    the file or store each record directly on the database without using an intermediate
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Another detail is that we didn't use transactions, meaning that if for any reason
    we had to stop inserting it halfway, we will need to remove every record previously
    inserted; otherwise we can have duplicated records or errors when trying to reinsert
    everything again.
  prefs: []
  type: TYPE_NORMAL
- en: 'One good question is: Why did we use IP ranges instead of one record for each
    IP? The reason is very simple: space. If we were going to use one record for each
    IP we would need 4,294,967,296 records; if each record occupies 1 kilobyte of
    disk space it would need 4,398,046,511,104 bytes (~4 terabytes), which we don''t
    have on any Apple mobile device except for Apple computers, but it wouldn''t be
    worth wasting such space for only an IP table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good question is: Why did we have to convert IP strings into an unsigned
    integer? Even if you see an IP as a sequence of four numbers, actually it is a
    32-bit unsigned integer, which allows us to compare if an IP is inside a range;
    otherwise we would do a string comparison, which is not valid.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite has a lot of functions, some of which are used more often than others
    and some of which are more specialized than others; for this reason it's a good
    idea to check the C functions that are available at [https://www.sqlite.org/c3ref/intro.html](https://www.sqlite.org/c3ref/intro.html)
    and the SQL statements at [https://www.sqlite.org/lang.html](https://www.sqlite.org/lang.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here you learned how to use the SQLite on an application, however it gives us
    some work to do because SQLite is not a framework, it is a C library. In the next
    recipe, we are going to learn how to use an SQLite "precooked" class for saving
    time when developing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking your phone activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you would like to track where your phone received (or made) a call
    by recording when a human head was close to the phone, so you want to create an
    app that will register data such as the current time and the phone coordinates
    every time that the proximity sensor detects that something is near the front
    face of the phone.
  prefs: []
  type: TYPE_NORMAL
- en: Although we are going to use SQLite again, we are not going to write any SQL
    statement. This time we are going to use a framework that uses only Swift types
    and objects; that way we don't have to worry about converting types from Swift
    to C and from C to Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe we will need to download an external framework called `SQLite.Swift`.
    To do it, open your favorite browser and go to [https://github.com/stephencelis/SQLite.swift](https://github.com/stephencelis/SQLite.swift).
    Once the website is open, click on the icon Download ZIP. If you have used Safari,
    the downloaded file was probably unzipped. In case of using another web browser,
    unzip it yourself by double-clicking on the file icon on your finder window. Using
    this framework requires Xcode 6.1 or greater, so make sure that you are using
    an updated version of Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: As this recipe will use the proximity sensor, it is necessary to use it with
    a physical phone, otherwise you won't be able create any records.
  prefs: []
  type: TYPE_NORMAL
- en: If you are ready to start, create a new project called `Chapter 10 Activity
    Recording`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all we need to add the `SQLite.Swift` into our project. To do it, just
    drag the `SQLite.Swift` Xcode project file (`SQLite.xcodeproj`) into your project;
    you shall now see two projects on the project navigator:![How to do it…](img/00152.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on your project for adding this framework, so click on the **General**
    tab of your target, scroll down to **Linked Frameworks and Libraries**, and click
    on the plus sign. When the dialog appears you can check that there is a section
    called **Workspace** with two frameworks with the same name; select the one that
    is done for iOS:![How to do it…](img/00153.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press the plus sign again and select another framework: the `CoreLocation`
    framework.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As, in this recipe, we are going to develop only the view controller, we are
    not going to add any new file. So, click directly on the storyboard and add to
    your view a text field and a button. Remove the text of your text field and change
    the button label to **Print records**. Now connect the text field with the view
    controller and call it `textView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect the button with a new action called `printRecords`; we are not going
    to develop it right now, just leave it empty for future use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now click on the view controller file and place the prompt at the beginning
    of this file. Here, we have to import two frameworks beside the UIKit: `SQLite`
    and `CoreLocation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we start developing the view controller code, we are going to create
    an auxiliary type for our common variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we will need to use the core location for receiving the current location,
    we will need to implement the view controller as a core location delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can add the attributes, we will need one database connection for the
    location manager and another one for keeping the last location received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is time to develop the methods, starting with the `viewDidLoad`; here we
    need to set everything up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see we have a few methods to implement. Let''s start with the `openDatabase`,
    which creates the database and handles the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is creating the database structure; it will create a table called
    `activity` with its columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The database initialization is done; we need to start receiving information
    about the device position by setting up the core location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you know, we need to implement the method that updates the current location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to get notifications from the proximity sensor; to do it we need
    to use the notification center:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, when we receive a proximity sensor change, the method `proximity`
    will be called; that''s the moment when we have to store in the database that
    an activity has started or ended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create the method that returns the variables that are related
    to the activity table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last part of the development is the button event, which was empty until
    now. We just need to retrieve data from the activity table and add it to the text
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is one more step that you might need to do: click on the Info.plist of
    your project and add a new row. In this row, set `NSLocationAlwaysUsageDescription`
    for the key and `This app needs GPS` as the value. The reason for it is that on
    iOS 8 when you request permission to use the GPS (Core Location), it is ignored
    if there is no message. Some people say that it is a bug and it should be fixed
    soon.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, the app is done and we need to test it, so press play and put your
    phone next to your head as if you were talking on it. Repeat this a few times,
    and then check the table content by pressing the button. Your result should be
    something similar to this screenshot:![How to do it…](img/00154.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SQLite.Swift` is a good layer over the SQLite library. You can create a database
    by creating an object of database type. You can define the table fields with a
    generic class called **Expression**. This class works with integers (`Int`), double
    precision (`Double`), strings, and Boolean types (`Bool`). All of them can be
    declared as optionals, meaning that the database can store null values on it.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use methods such as insert or update for adding or changing a record;
    both of these receive a type called setter, which is like the relationship between
    a field and its value. To create an object of Setter type you have to use the
    operator `<-`.
  prefs: []
  type: TYPE_NORMAL
- en: For retrieving results, you can iterate over a query object like we did with
    the `for` loop and access its fields with the subscript using the expression fields
    as an index.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the filter method for retrieving only the records that complain
    with a criteria, such as the where clause on the SQL language.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you could see with this framework, we didn't have the need of writing SQL
    statements; however `SQLite.Swift` allows you to work with SQL statements if you
    want. To do it you can use methods such as run or prepare.
  prefs: []
  type: TYPE_NORMAL
- en: Another excellent feature of `SQLite.Swift` is that it is transaction ready.
    The method transaction and how it works for using transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Apple has another solution for using a database over its own layer, called **Core
    Data**. In the next recipe, we are going to learn how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling your stocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of an application connected with a database came from the need to keep
    some data, even if the application finishes. However, SQL is another language
    and you have to repeat some developments twice, such as a new field on a class
    is also a new field on the database.
  prefs: []
  type: TYPE_NORMAL
- en: When Xerox developed the first window system based on Smalltalk, it didn't use
    any kind of database. The argument for it is that if an application doesn't finish,
    the data will always be on the RAM memory.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is very intelligent, however we know that the real world doesn't work
    like that. Applications crash and finish and devices need to reboot sometimes.
    Beside these facts, you also need to consider that, until today, RAM memory was
    still more expensive than hard disk. The new iPhone 6, for example, has only 1
    gigabyte of RAM and at least 32 gigabytes of permanent storage.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the problems just mentioned, Apple recommends using its own ORM called
    **Core Data**. An **ORM** is a framework that allows your objects to be stored
    on a permanent storage system without wasting time writing SQL statements. Actually
    what Core Data does is write the SQL for us.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to develop a small app using Core Data by simulating
    a product control of a warehouse.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start creating a new app called `Chapter 10 Stock Control`, however make sure
    that the option **Use Core Data** is checked as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will need to create a database model. Don't think in SQLite when creating
    this model because there will be some different types. So click on the file `Chapter_10_Stock_Control.xcdatamodeld`;
    here you should see a different layout with some empty fields. Let's start by
    pressing the sign that is located over the text **Add Entity**:![How to do it…](img/00156.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new entity to `Product`:![How to do it…](img/00157.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, add three attributes for this entity, one called `name`, which should
    be of type string, `price` that is a double, and `units`, which is an integer
    of 32 bits:![How to do it…](img/00158.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's all for the data part. Now we need to click on the storyboard file. Select
    the only view controller you have by clicking on it and go to the **Editor** menu,
    expand the **Embedded In** option and select **Navigation Controller**:![How to
    do it…](img/00159.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we don't want the navigation bar for this app, you can click on the navigation
    controller just created and uncheck the option **Show Navigation Bar** that is
    on attribute inspector:![How to do it…](img/00160.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a button on the only view controller we have with the text **New product**;
    under it add a table view. You should have a layout similar to the following one:![How
    to do it…](img/00161.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now go to the view controller and import `CoreData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, you have to add the `UITableViewDataSource` protocol to the view controller;
    that way we display results on the table view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now connect the table view with the view controller as a data source and as
    an attribute of it. As we are adding an attribute we can also add a new attribute
    that will contain our records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it is done, we have to implement the methods that update the table view
    information. In this case, the number of records is the size of the array but
    their contents are the values of some keys of the `NSManagedObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Imagine that when we create a new record, it''s necessary to reload the table
    view data. We could create a button for refreshing it, but it wouldn''t be so
    intuitive, so the best way we can do it is, when the view appears again, we can
    refresh the data as well as updating the product array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Good, press play and what happens? Nothing! The reason is that we are able to
    list the records but not to insert them, so it is time to add functionality to
    the **New product** button. Return to the storyboard and add a new view controller,
    put it on the right-hand side of the previous one and click on the **New product**
    button with the ** key pressed and drag it to the new view controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press play, of course you are not going to see any records, but if you tap on
    the button you can see that a new view is called. At this moment we need to develop
    this view, however, before we continue, it needs a view controller file; in this
    case you have to add a new file of type Cocoa Touch Class and name it `NewProductViewController`.
    Make sure that it inherits from **UIViewController**:![How to do it…](img/00162.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to your storyboard and change the class of this view controller on the
    identity inspector to the new file created:![How to do it…](img/00163.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's create a layout for this view. We have to add three text fields (one
    for each entity field), three labels for explaining what these fields are about,
    one button for saving the records, and one label just for displaying the view
    title (as we don't have the navigation bar):![How to do it…](img/00164.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the layout is done we have to connect the text field to the new product
    view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last part we need to do is the save button development. As it is going
    to use a few `CoreData` classes, you have to start by importing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now connect your `save` button with an action called save and develop it by
    retrieving the text fields data and saving it with core data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last step is testing your app. Press play, and add a few products such as
    computers, potatoes, and cars, and check that they appear on your table view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have to be very thankful to Apple because old versions of Xcode didn''t
    have the option of creating a `CoreData` application, which meant that the code
    for initialization done on the `AppDelegate` class had to be done manually. What
    it does is create some attributes such as `managedObjectModel` that read the entity
    model and interpret it; the `persistentStoreCoordinator` then converts from core
    data to a persistent system (SQLite by default, but it can be configured to be
    an XML file, for example), and a very important one: `managedObjectContext`; this
    object controls the objects/records that belong to `CoreData`.'
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, every time we had to use something from `CoreData` we had to
    access the `AppDelegate` class a few times. If you prefer, you can create your
    own singleton class and transfer the `CoreData` code over there.
  prefs: []
  type: TYPE_NORMAL
- en: When we need a new record, we need an object of type `NSManagedObject`. If it
    is a new record we can ask for the help of the method `insertNewObjectForEntityForName`
    from the `NSEntityDescription` class. Accessing its fields is very easy; we just
    need to use `valueForKey` for retrieving its value or setValue for modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to access the objects, you have to use `NSFetchRequest`, which is
    like an SQL statement. The `managedObjectContext` is the one that can execute
    this request and return its data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to filter some data, you can use `NSPredicate`, which is something
    like the where clause of SQL.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen some ways of storing data into your local device, but how about a
    network database? In the next recipe we are going to use a centralized database
    for storing our data.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a voting device using CouchDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned before, usually on mobile apps we access a local database, but
    sometimes we need to use only one database with a lot of devices connected to
    it. For example, when you do a Google query you don't download the whole Google
    index onto your mobile phone, you just request some information and retrieve the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to learn how to use a centralized database, in this
    case we are going to use a database called CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe you need to download a CouchDB server. I assume that you are
    developing on a Mac computer, so it will be demonstrated with Mac OS X. In case
    you prefer to use another platform, such as Linux or Windows, feel free to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download CouchDB from [http://couchdb.apache.org](http://couchdb.apache.org).
    Once it is downloaded and unzipped, right click on its icon and choose the option
    **Show Package Contents** from the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now follow the path `Contents/Resources/couchdbx-core/etc/couchdb`; here you
    should see a file called `default.ini`. Open it and search for the variable `bind_address`.
    Here you have to change from 127.0.0.1 to 0.0.0.0\. Now return to the folder where
    the CouchDB app is located and open the app by double-clicking on it. Your web
    browser should open displaying the CouchDB front-end (called **Futon**); keep
    it open for checking the results later.
  prefs: []
  type: TYPE_NORMAL
- en: A big detail that you have to bear in mind is that if you are going to use a
    physical device it must use the same Wi-Fi network as your computer; otherwise
    your device won't be able to find your database server.
  prefs: []
  type: TYPE_NORMAL
- en: Return to your Xcode and create a new project called `Chapter 10 Voting`. Here
    you won't need `CoreData`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is setting the database. Go to your web browser and click on
    the button Create database. If for any reason you closed your browser, just type
    the URL `http://127.0.0.1:5984/_utils/`. When the website asks for a database
    name, write `voting`:![How to do it…](img/00166.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this database we need to add a few documents. So press on the button
    that says **New document**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Documents in CouchDB are JSON dictionaries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the first document, click on **Source** and complete it as shown in the
    following code. Do not modify the _id value, leave the one that CouchDB gave you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good, now press save document and let''s repeat the operation with another
    document; this way we can be sure that the questions are being received from the
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create an update handler, which is like a function that receives
    some data and completes a document for us. Click on new document and this time
    we need to change the document id because it will be called `_design/voting`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The database part is done; therefore you have to go back to your Xcode project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Explaining how CouchDB works is out of the scope of this book; if you would
    like to learn how to use this database, there are good books and tutorials about
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you've returned to your Xcode project, click on the storyboard and add
    two labels and three buttons to your view. Write `TODAY'S QUESTION` on the first
    label, which should be located at the top of the view. Below it, place the other
    label, which will contain the received question, and under that the three buttons.
    Don't worry about the text of these components, they will be changed programmatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, we have to link some components with the view controller; in this
    case we have to connect the question label and the three buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Besides that, we will also add two attributes, one for the document id and
    another one for the common part of the request''s URL. Remember that if you are
    using a device, you have to change the IP from `127.0.0.1` to the one of your
    computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect the three buttons with the same action called `vote`. Leave this action
    empty for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the application starts we need to receive the current questions that our
    database has, so let''s just start calling a function that will do it for us on
    the `viewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you might imagine, we have to implement the `chooseQuestion` method. This
    method will call the action `_all_docs`, which returns the ID of every document
    on the database, including the special document `_design/voting`. Once we have
    received the document we can choose one of them and request its data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the application has decided which document it wants, we can request its
    data. The mechanism is similar to the previous one, but with the difference that
    when we receive the data we have to update the UI. As you know it must be done
    on the main thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you press play now you are going to see a screen like the following one.
    It means that you have received a question with its possible answers from the
    database. However, if you choose any answer, nothing happens:![How to do it…](img/00167.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it''s time to implement the vote action. The idea is to check which button
    was pressed and then send this information with the device id to the database.
    This way our vote will be registered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application is done, so now we have to check that it communicates with the
    database correctly. Press play again and choose an answer. You should receive
    an alert view thanking you, which is a good sign. After that go to the web browser
    again and open the chosen document; check that your device ID is there on the
    answer that you have selected:![How to do it…](img/00168.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have worked with remote SQL databases you might know that usually you
    need a driver/connector, which should be compatible with your platform and can
    also be blocked by some firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'CouchDB is a NoSQL database that works by exchanging JSON messages via http
    protocol, which makes our life easier, because we didn''t have to add any controller,
    just receive and send JSON messages. Due to the way that this database works we
    had to develop a function for updating/inserting a new vote on the client size;
    remember that Swift is not JavaScript: adding a new element into a JSON array
    can give us more work than just developing a simple function.'
  prefs: []
  type: TYPE_NORMAL
- en: Why did we have to cast to `NSArray` and `NSDictionary` a few times? The reason
    is that the `NSJSONSerialization` was created on the Objective-C era, meaning
    that it is still not 100% prepared for Swift.
  prefs: []
  type: TYPE_NORMAL
- en: It is true that the way we worked could be better organized. The ideal way is
    by creating a layer for CouchDB, such as a framework or a library, however this
    task will be left as homework.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned different ways of using databases on Swift; some
    of them are very straightforward and others require a better analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn some new tricks, mainly those that
    are related to the new Xcode 6 and the iOS 8.
  prefs: []
  type: TYPE_NORMAL
