- en: Chapter 10. Data Access
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。数据访问
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Creating an SQLite database
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 SQLite 数据库
- en: Checking where your IP is from
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的 IP 地址来自哪里
- en: Tracking your phone activity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪你的手机活动
- en: Controlling your stocks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制你的股票
- en: Designing a voting device using CouchDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CouchDB 设计投票设备
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As you might know, nowadays it is very difficult to imagine an app that doesn't
    store anything on hard disk. Simple apps such as a calculator or a compass might
    not need to store any information, but usually you will need to create apps with
    more complex features and that will need to keep information even if the device
    reboots.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，如今很难想象一个不将任何内容存储在硬盘上的应用程序。像计算器或指南针这样的简单应用程序可能不需要存储任何信息，但通常你需要创建具有更复杂功能的应用程序，并且即使在设备重启的情况下也需要保留信息。
- en: When you have to store a minimum amount of information such as a simple date,
    or just the current app version, you can use a file as we have done in the previous
    chapters of this book, but when you have to store a few records with different
    data structures, you need the help of a database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要存储最小量的信息，如简单的日期或当前应用程序版本时，你可以使用文件，就像我们在本书的前几章中所做的那样，但当你需要存储具有不同数据结构的几个记录时，你需要数据库的帮助。
- en: In this chapter, we are going to learn how to use databases on Swift and you
    will see the advantages of each method.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在 Swift 中使用数据库，你将看到每种方法的优点。
- en: Creating an SQLite database
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SQLite 数据库
- en: Usually, storing information on a mobile app is done with a local database.
    To do that, it is very common to use SQLite because even if it is a bit limited,
    this database has some advantages, such as it is a serverless database, it is
    zero-configuration, and it is built in iOS and Mac OS X.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在移动应用程序中存储信息是通过本地数据库完成的。为此，使用 SQLite 非常常见，因为尽管它有些限制，但这个数据库有一些优点，例如它是一个无服务器数据库，它是零配置的，并且它是内置在
    iOS 和 Mac OS X 中的。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we are going to download an SQLite file; therefore you will
    need an SQLite client for reading this file. So beside the iFunBox downloaded
    in the previous chapter, you will also need to download a program such as SQLiteBrowser
    ([http://sqlitebrowser.org/](http://sqlitebrowser.org/)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将下载一个 SQLite 文件；因此你需要一个 SQLite 客户端来读取这个文件。所以除了在上一章中下载的 iFunBox，你还需要下载一个程序，如
    SQLiteBrowser ([http://sqlitebrowser.org/](http://sqlitebrowser.org/))。
- en: Create a new project called `Chapter 10 SQLite`; keep in mind where you saved
    this recipe because we are going to complete it in the next recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter 10 SQLite` 的新项目；请记住你保存此菜谱的位置，因为我们将在下一个菜谱中完成它。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: When the project is created, click on the **General** tab and scroll down until
    you get to the section **Linked Frameworks and Libraries**. Click on the plus
    sign for adding a new library and select `libsqlite3.tbd`:![How to do it…](img/00144.jpeg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当项目创建完成后，点击 **常规** 选项卡，向下滚动直到你到达 **链接框架和库** 部分点击加号以添加新的库，并选择 `libsqlite3.tbd`：![如何做…](img/00144.jpeg)
- en: 'After that, let''s create a new bridging file by adding a new header file called
    `BridgingHeader.h`; check that it is set as a bridging header in the **Build Settings**.
    In this file, include the `sqlite3.h`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让我们创建一个新的桥接文件，通过添加一个名为 `BridgingHeader.h` 的新头文件；检查它是否在 **构建设置** 中设置为桥接头。在这个文件中，包含
    `sqlite3.h`：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now add a new file called `SQLite.swift`; here we are going to start coding
    a class called `SQLite` and inside of it an enumeration called `status`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个名为 `SQLite.swift` 的新文件；在这里，我们将开始编写一个名为 `SQLite` 的类，并在其中定义一个名为 `status`
    的枚举：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s create two attributes, one for the connection with the database
    and another one for the current connection status:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个属性，一个用于与数据库的连接，另一个用于当前连接状态：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is creating a read-only computed attribute that returns the current
    connection status:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个只读的计算属性，它返回当前连接状态：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, you can create a method that opens a connection with the database.
    For this method, we will need only the filename as an argument; however, we are
    going to store it in the documents folder:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你可以创建一个方法来打开与数据库的连接。对于这个方法，我们只需要一个文件名作为参数；然而，我们将将其存储在文档文件夹中：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last detail for this class is the deinitializer that should close the database
    connection:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类的最后一个细节是析构器，它应该关闭数据库连接：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The model part is done; now let's create the view part by clicking on the storyboard
    and adding a label, a text field, and a button, something similar to this layout:![How
    to do it…](img/00145.jpeg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型部分已完成；现在让我们通过点击故事板并添加一个标签、一个文本框和一个按钮来创建视图部分，布局类似于这个：![如何操作…](img/00145.jpeg)
- en: 'Now connect the text field with the view controller and call it `databaseNameTextField`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将文本框与视图控制器连接，并命名为 `databaseNameTextField`：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once it is done, you can create an action for the only button; in this case
    we are going to open the database connection, create a table and check whether
    everything was done successfully:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，你就可以为唯一的按钮创建一个动作；在这种情况下，我们将打开数据库连接，创建一个表并检查是否一切操作都成功完成：
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This app is done. Better off saying, this first version is done; now press play
    and write a filename for your database, such as `mydatabase`, and then press the
    button for creating a database.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个应用完成了。更确切地说，这个第一个版本完成了；现在按播放按钮，为你的数据库输入一个文件名，例如 `mydatabase`，然后按创建数据库的按钮。
- en: Now let's check the real application, so open your iFunBox and search for the
    app `Chapter 10 SQLite`; open its `Document` folder, select the only file that
    is in this folder, then press the button **Copy to Mac** and save it in your local
    documents folder:![How to do it…](img/00146.jpeg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检查实际的应用程序，所以打开你的 iFunBox 并搜索应用程序 `第 10 章 SQLite`；打开其 `Document` 文件夹，选择这个文件夹中的唯一文件，然后按
    **复制到 Mac** 按钮并将其保存在你的本地文档文件夹中：![如何操作…](img/00146.jpeg)
- en: Once you have the empty database, let's check whether we are able to open it.
    Open your Sqlite browser (only supports 8.3 and below) and click on the **Open**
    **Database** button:![How to do it…](img/00147.jpeg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了空数据库，让我们检查我们是否能够打开它。打开你的 Sqlite 浏览器（仅支持 8.3 及以下版本）并点击 **打开** **数据库** 按钮：![如何操作…](img/00147.jpeg)
- en: Choose the database file you have downloaded and open it. After that, you should
    see on the main panel and on the database schema a table called `ips`, which means
    that your database was created successfully and it can create a table without
    any errors:![How to do it…](img/00148.jpeg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你下载的数据库文件并打开它。之后，你应该在主面板和数据库模式中看到一个名为 `ips` 的表，这意味着你的数据库已成功创建，并且可以无错误地创建一个表：![如何操作…](img/00148.jpeg)
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: SQLite is not a framework; rather, it is a library that uses the traditional
    C functions instead of Objective-C or Swift objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 不是一个框架；而是一个库，它使用传统的 C 函数而不是 Objective-C 或 Swift 对象。
- en: As you might know, using C functions implies using C types; that's the reason
    we had to use `UnsafeMutablePointer<CChar>` for the error message and `COpaquePointer`
    for the database handle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，使用 C 函数意味着使用 C 类型；这就是我们为什么必须使用 `UnsafeMutablePointer<CChar>` 来表示错误信息，以及
    `COpaquePointer` 来表示数据库句柄的原因。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`COpaquePointer` represents a C pointer such as `UnsafeMutablePointer`, but
    it is used when you can''t represent the pointer type on Swift, such as some structs,
    for example.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`COpaquePointer` 表示一个 C 指针，例如 `UnsafeMutablePointer`，但它在你无法在 Swift 中表示指针类型时使用，例如一些结构体，例如。'
- en: 'In this recipe, we used three SQLite functions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了三个 SQLite 函数：
- en: '`sqlite3_open`: This function opens a database. It creates a new database file
    if one doesn''t exist. This function receives as an argument the file name and
    a handle pointer by reference.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_open`：这个函数打开一个数据库。如果不存在，它将创建一个新的数据库文件。这个函数接收文件名和一个句柄指针作为参数。'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you don't want to create a database file, you can use in-memory databases;
    check it out at [https://www.sqlite.org/inmemorydb.html](https://www.sqlite.org/inmemorydb.html).
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不想创建数据库文件，你可以使用内存数据库；查看 [https://www.sqlite.org/inmemorydb.html](https://www.sqlite.org/inmemorydb.html)。
- en: '`sqlite3_close`: This function closes the connection with the database and
    frees the resources that are being used for this connection. Bear in mind that
    C has no objects, no garbage collector, and no automatic reference counter; therefore,
    if you don''t free the resources, they are going to be there until your application
    finishes or crashes.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_close`：这个函数关闭与数据库的连接并释放用于此连接的资源。请注意，C 没有对象，没有垃圾回收器，也没有自动引用计数器；因此，如果你不释放资源，它们将一直存在，直到你的应用程序结束或崩溃。'
- en: '`sqlite3_exec`: This function executes an SQL statement; in this case it wasn''t
    really necessary because we just want to check whether the file was created or
    not; however sometimes SQLite creates only an empty file if you don''t use the
    database.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_exec`：这个函数执行一个 SQL 语句；在这种情况下，这并不是真的必要，因为我们只是想检查文件是否已创建；然而，有时如果你不使用数据库，SQLite
    只会创建一个空文件。'
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'SQLite has a lot of options and functions; you can check out more about it
    at the official website: [https://www.sqlite.org/cintro.html](https://www.sqlite.org/cintro.html).
    Now that you know how to create a database, let''s work with it, creating registers
    and querying results.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite有很多选项和函数；你可以在官方网站上了解更多信息：[https://www.sqlite.org/cintro.html](https://www.sqlite.org/cintro.html)。现在你知道如何创建数据库了，让我们开始使用它，创建登记和查询结果。
- en: Checking where your IP is from
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查你的IP地址来源
- en: Sometimes you need to query from a remote database, but as you know, SQLite
    works with a local database, meaning that you have to populate it before querying.
    In this recipe, we are going to convert a CSV file into an SQLite database and
    after that we are going to query some results.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要从远程数据库进行查询，但正如你所知，SQLite与本地数据库一起工作，这意味着在查询之前你必须填充它。在这个菜谱中，我们将把CSV文件转换为SQLite数据库，然后查询一些结果。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we are going to need a CSV file with the ranges of IPs of each
    country. There are some websites that give or sell it to you. You can download
    it free from [https://db-ip.com/db/download/country](https://db-ip.com/db/download/country).
    Uncompress it, and add it into your SQLite application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要一个包含每个国家IP地址范围的CSV文件。有一些网站会提供或出售给你。你可以从[https://db-ip.com/db/download/country](https://db-ip.com/db/download/country)免费下载它。解压它，并将其添加到你的SQLite应用程序中。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Right now this file is called `dbip-country-2014-12.csv`, but it changes its
    name every month, so replace the filename where it is mentioned with the one you
    have.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个文件名为`dbip-country-2014-12.csv`，但每个月都会更改其名称，所以将提到的文件名替换为你拥有的那个。
- en: How to do it…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start completing the SQLite class by adding two additional methods,
    one of which is for executing statements that don''t return any result, such as
    insert, delete, and update queries. To do it, click on the file `SQLite.swift`
    and inside the SQLite class add this code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始通过添加两个额外的方法来完善SQLite类，其中一个用于执行不返回任何结果的操作，例如插入、删除和更新查询。要做到这一点，请点击文件`SQLite.swift`，并在SQLite类中添加以下代码：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s add a new file called `Functions.swift` in your project. This file
    will contain some auxiliary functions. The first function that we are going to
    create is the one that reads a CSV file and returns its contents inside a double
    array of string:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在你的项目中添加一个名为`Functions.swift`的新文件。这个文件将包含一些辅助函数。我们将要创建的第一个函数是读取CSV文件并返回其内容的双字符串数组：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we need two additional functions related to the IP string; the first one
    will check whether the input string has an IPv4 format:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要两个与IP字符串相关的额外函数；第一个将检查输入字符串是否具有IPv4格式：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next function will convert the IP from a string to an unsigned integer;
    it will allow us to compare if an IP is in a range:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数将把IP从字符串转换为无符号整数；这将允许我们比较IP是否在某个范围内：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have finished with the auxiliaries functions, now we have to update the storyboard.
    Go to your storyboard and add two more buttons, one with the word **Populate**
    and another one with the word **Search**, something similar to the following screenshot:![How
    to do it…](img/00149.jpeg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了辅助函数，现在我们必须更新故事板。转到你的故事板，并添加两个额外的按钮，一个带有“Populate”这个词，另一个带有“Search”这个词，类似于以下截图：![如何操作…](img/00149.jpeg)
- en: Now we need to set these buttons as hidden by default, because we are not going
    to insert any register before creating the database. To do it, click on one of
    these new buttons, go to the attribute inspector, check the **Hidden** option,
    and then repeat the operation with the other button:![How to do it…](img/00150.jpeg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将这些按钮默认设置为隐藏，因为我们不会在创建数据库之前插入任何登记。要做到这一点，请点击这些新按钮中的一个，转到属性检查器，勾选“隐藏”选项，然后对另一个按钮重复此操作：![如何操作…](img/00150.jpeg)
- en: 'Once the storyboard is done, we have to update the view controller. Let''s
    start by connecting the label and the three buttons with the view controller:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦故事板完成，我们就需要更新视图控制器。让我们先从将标签和三个按钮与视图控制器连接开始：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We still need another attribute that is the database connection, which is inside
    the action of creating a database, so what we are going to do is move the declaration
    with the initialization from inside the method `createDatabase` to outside of
    it:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要另一个属性，即数据库连接，它在创建数据库的动作中，所以我们要做的是将声明和初始化从`createDatabase`方法内部移动到外部：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we are working near the `createDatabase` method, we can take advantage of
    it and update it by hiding some unneeded views and displaying only the **Populate**
    button:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在`createDatabase`方法附近工作，我们可以利用它并更新它，通过隐藏一些不需要的视图，只显示**填充**按钮：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After that we can connect the **Populate** button with a new action. This action
    will be called `populate` and it will call an `insert` statement on our database
    then it will display the **Search** button:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以将**填充**按钮与一个新的动作连接起来。这个动作将被命名为`populate`，它将在我们的数据库上调用一个`insert`语句，然后显示**搜索**按钮：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you might imagine, we need to develop the search action. First, it needs
    to check whether the input is correct and after that it will look for the IP range
    where it belongs. If it is able to find it, it will show the country where the
    IP belongs, otherwise it will show that the country wasn''t found:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所想，我们需要开发搜索动作。首先，它需要检查输入是否正确，然后它将查找它所属的IP范围。如果它能找到，它将显示IP所属的国家，否则它将显示国家未找到：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once again we have completed another app and we need to test it. Press play,
    write on the test field `mydatabase`, and press **Create database**. Now you should
    see only the populate button on screen, tap on it—it will take a while until it
    finishes.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们完成了一个应用程序，我们需要对其进行测试。按播放，在测试字段中写入`mydatabase`，然后按**创建数据库**。现在你应该只看到屏幕上的**填充**按钮，点击它——它需要一段时间才能完成。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you would like to know when the app starts writing to disk when you are
    developing, you can click on the debugger navigator and then on the disk report,
    and you should see some bars with the disk-writing activity, as shown in the following
    image:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想在开发时知道应用程序何时开始写入磁盘，你可以点击调试器导航器，然后点击磁盘报告，你应该会看到一些表示磁盘写入活动的条形图，如下面的图像所示：
- en: '![How to do it…](img/00151.jpeg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/00151.jpeg)'
- en: The last step is looking for the country of a specific IP, so type an IP in
    the text field when it appears, for example `74.125.230.52` and press **Search**.
    You should receive an alert displaying where this IP is from.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是查找特定IP的国家，所以当文本字段出现时，在文本字段中输入一个IP，例如`74.125.230.52`，然后按**搜索**。你应该会收到一个警报，显示这个IP来自哪里。
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'SQL has two kinds of queries:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SQL有两种类型的查询：
- en: There are queries that modify the data structure, such as `CREATE TABLE` and
    `ALTER TABLE`, or modify the data content, such as `INSERT`, `DELETE`, or `UPDATE`,
    which are going to be shown in the next section. These queries usually don't return
    any data. For this kind of query you can use the function `sqlite3_exec`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些查询会修改数据结构，如`CREATE TABLE`和`ALTER TABLE`，或者修改数据内容，如`INSERT`、`DELETE`或`UPDATE`，这些将在下一节中展示。这些查询通常不会返回任何数据。对于这类查询，你可以使用`sqlite3_exec`函数。
- en: Queries that retrieve information such as `SELECT`. Here you have to work in
    a different way; you need to use the function `sqlite3_prepare_v2` for executing
    the query and `sqlite3_step` for retrieving each record.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询信息，如`SELECT`。在这里，你需要以不同的方式工作；你需要使用`sqlite3_prepare_v2`函数来执行查询，并使用`sqlite3_step`来检索每条记录。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you check the SQLite API documentation you will see that `sqlite3_exec` can
    also return a result from a `SELECT` statement; however it needs a pointer to
    a function for each record received (what is called a callback).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查SQLite API文档，你会看到`sqlite3_exec`也可以从`SELECT`语句返回结果；但是它需要一个指向每个接收到的记录的函数的指针（称为回调函数）。
- en: If you have developed your function in C you can have a pointer to it by using
    a variable of type `CFunctionPointer`, but bear in mind that this data type can't
    be used for pointing to Swift functions. Make sure that SQLite has its own constants,
    such as `SQLITE_OK` for indicating that the operation has finished successfully,
    `SQLITE_ROW`, which tells us that it could receive a record from the statement
    result, or `SQLITE_DONE`, which is saying that there are no more records on this
    statement result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用C开发了你的函数，你可以通过使用类型为`CFunctionPointer`的变量来拥有它的指针，但请记住，这种数据类型不能用于指向Swift函数。确保SQLite有自己的常量，例如`SQLITE_OK`用于指示操作已成功完成，`SQLITE_ROW`告诉我们它可以从语句结果中接收记录，或者`SQLITE_DONE`表示该语句结果上没有更多记录。
- en: In this case, we had a common case of converting a text file into database records.
    Check in detail when you need to do a similar task. First we added every record
    in an array; it took approximately 80 megabytes of RAM by the time we finished
    inserting the records. This isn't a problem because even low-end devices such
    as the iPhone 4S has 512 megabytes of RAM, but if you decide to load the cities'
    IP database, it can consume a lot of memory, so you would probably need to split
    the file or store each record directly on the database without using an intermediate
    array.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们遇到了将文本文件转换为数据库记录的常见情况。当你需要执行类似任务时，请详细检查。首先我们在一个数组中添加了每个记录；当我们完成插入记录时，大约需要
    80 兆字节的 RAM。这不是问题，因为即使是低端设备如 iPhone 4S 也拥有 512 兆字节的 RAM，但如果你决定加载城市的 IP 数据库，它可能会消耗大量内存，因此你可能需要分割文件或将每个记录直接存储在数据库中，而不是使用中间数组。
- en: Another detail is that we didn't use transactions, meaning that if for any reason
    we had to stop inserting it halfway, we will need to remove every record previously
    inserted; otherwise we can have duplicated records or errors when trying to reinsert
    everything again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细节是我们没有使用事务，这意味着如果我们有任何原因需要在插入过程中停止，我们需要删除之前插入的每个记录；否则我们可能会出现重复记录或尝试重新插入所有内容时的错误。
- en: 'One good question is: Why did we use IP ranges instead of one record for each
    IP? The reason is very simple: space. If we were going to use one record for each
    IP we would need 4,294,967,296 records; if each record occupies 1 kilobyte of
    disk space it would need 4,398,046,511,104 bytes (~4 terabytes), which we don''t
    have on any Apple mobile device except for Apple computers, but it wouldn''t be
    worth wasting such space for only an IP table.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好问题是：为什么我们使用 IP 范围而不是每个 IP 一个记录？原因很简单：空间。如果我们为每个 IP 使用一个记录，我们需要 4,294,967,296
    个记录；如果每个记录占用 1 千字节磁盘空间，它将需要 4,398,046,511,104 字节（约 4 太字节），这在我们任何苹果移动设备上都没有，除了苹果电脑，但为了仅一个
    IP 表浪费这样的空间是不值得的。
- en: 'Another good question is: Why did we have to convert IP strings into an unsigned
    integer? Even if you see an IP as a sequence of four numbers, actually it is a
    32-bit unsigned integer, which allows us to compare if an IP is inside a range;
    otherwise we would do a string comparison, which is not valid.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好问题是：为什么我们必须将 IP 字符串转换为无符号整数？即使你将 IP 视为一个数字序列，实际上它是一个 32 位无符号整数，这允许我们比较 IP
    是否在某个范围内；否则我们将进行字符串比较，这是不正确的。
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: SQLite has a lot of functions, some of which are used more often than others
    and some of which are more specialized than others; for this reason it's a good
    idea to check the C functions that are available at [https://www.sqlite.org/c3ref/intro.html](https://www.sqlite.org/c3ref/intro.html)
    and the SQL statements at [https://www.sqlite.org/lang.html](https://www.sqlite.org/lang.html).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 有很多函数，其中一些比其他函数使用得更频繁，一些比其他函数更专业；因此，检查 [https://www.sqlite.org/c3ref/intro.html](https://www.sqlite.org/c3ref/intro.html)
    上的可用 C 函数和 [https://www.sqlite.org/lang.html](https://www.sqlite.org/lang.html)
    上的 SQL 语句是个好主意。
- en: Here you learned how to use the SQLite on an application, however it gives us
    some work to do because SQLite is not a framework, it is a C library. In the next
    recipe, we are going to learn how to use an SQLite "precooked" class for saving
    time when developing.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里你学习了如何在应用程序中使用 SQLite，然而这给我们带来了一些工作要做，因为 SQLite 不是一个框架，它是一个 C 库。在下一个菜谱中，我们将学习如何使用
    SQLite 的“预煮”类来节省开发时间。
- en: Tracking your phone activity
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪你的手机活动
- en: Imagine that you would like to track where your phone received (or made) a call
    by recording when a human head was close to the phone, so you want to create an
    app that will register data such as the current time and the phone coordinates
    every time that the proximity sensor detects that something is near the front
    face of the phone.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要通过记录人头顶靠近手机的时间来追踪你的手机接收（或拨打）的电话，因此你想要创建一个应用程序，每次当接近传感器检测到有东西靠近手机的前脸时，都会记录当前时间和手机坐标。
- en: Although we are going to use SQLite again, we are not going to write any SQL
    statement. This time we are going to use a framework that uses only Swift types
    and objects; that way we don't have to worry about converting types from Swift
    to C and from C to Swift.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们还将使用 SQLite，但我们不会编写任何 SQL 语句。这次我们将使用一个仅使用 Swift 类型和对象的框架；这样我们就不必担心将类型从 Swift
    转换为 C，再从 C 转换回 Swift。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe we will need to download an external framework called `SQLite.Swift`.
    To do it, open your favorite browser and go to [https://github.com/stephencelis/SQLite.swift](https://github.com/stephencelis/SQLite.swift).
    Once the website is open, click on the icon Download ZIP. If you have used Safari,
    the downloaded file was probably unzipped. In case of using another web browser,
    unzip it yourself by double-clicking on the file icon on your finder window. Using
    this framework requires Xcode 6.1 or greater, so make sure that you are using
    an updated version of Xcode.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要下载一个名为 `SQLite.Swift` 的外部框架。要做到这一点，打开你喜欢的浏览器，并转到 [https://github.com/stephencelis/SQLite.swift](https://github.com/stephencelis/SQLite.swift)。一旦网站打开，点击下载
    ZIP 图标。如果你使用了 Safari，下载的文件可能已经被解压。如果你使用的是其他网络浏览器，请通过在查找器窗口的文件图标上双击来自动解压它。使用此框架需要
    Xcode 6.1 或更高版本，所以请确保你使用的是 Xcode 的更新版本。
- en: As this recipe will use the proximity sensor, it is necessary to use it with
    a physical phone, otherwise you won't be able create any records.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个菜谱将使用接近传感器，因此必须使用物理手机使用它，否则你将无法创建任何记录。
- en: If you are ready to start, create a new project called `Chapter 10 Activity
    Recording`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经准备好开始，创建一个名为 `Chapter 10 Activity Recording` 的新项目。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: First of all we need to add the `SQLite.Swift` into our project. To do it, just
    drag the `SQLite.Swift` Xcode project file (`SQLite.xcodeproj`) into your project;
    you shall now see two projects on the project navigator:![How to do it…](img/00152.jpeg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `SQLite.Swift` 添加到我们的项目中。要做到这一点，只需将 `SQLite.Swift` Xcode 项目文件（`SQLite.xcodeproj`）拖入你的项目；你现在应该在项目导航器中看到两个项目：![如何做…](img/00152.jpeg)
- en: Now click on your project for adding this framework, so click on the **General**
    tab of your target, scroll down to **Linked Frameworks and Libraries**, and click
    on the plus sign. When the dialog appears you can check that there is a section
    called **Workspace** with two frameworks with the same name; select the one that
    is done for iOS:![How to do it…](img/00153.jpeg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击你的项目以添加此框架，因此点击目标的目标**通用**选项卡，滚动到**链接的框架和库**，然后点击加号。当对话框出现时，你可以检查是否有名为**工作区**的部分，其中包含两个同名框架；选择为
    iOS 准备的那个：![如何做…](img/00153.jpeg)
- en: 'Press the plus sign again and select another framework: the `CoreLocation`
    framework.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按加号，并选择另一个框架：`CoreLocation` 框架。
- en: 'As, in this recipe, we are going to develop only the view controller, we are
    not going to add any new file. So, click directly on the storyboard and add to
    your view a text field and a button. Remove the text of your text field and change
    the button label to **Print records**. Now connect the text field with the view
    controller and call it `textView`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为在这个菜谱中，我们只将开发视图控制器，所以我们不会添加任何新的文件。因此，直接点击故事板，向你的视图中添加一个文本字段和一个按钮。删除你的文本字段中的文本，并将按钮标签更改为**打印记录**。现在将文本字段与视图控制器连接，并命名为
    `textView`：
- en: '[PRE17]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Connect the button with a new action called `printRecords`; we are not going
    to develop it right now, just leave it empty for future use:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮与一个名为 `printRecords` 的新操作连接起来；我们现在不会开发它，只是将其留空以供将来使用：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now click on the view controller file and place the prompt at the beginning
    of this file. Here, we have to import two frameworks beside the UIKit: `SQLite`
    and `CoreLocation`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击视图控制器文件，并将提示放置在此文件的开始处。在这里，我们需要导入 UIKit 之外的 `SQLite` 和 `CoreLocation` 两个框架：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before we start developing the view controller code, we are going to create
    an auxiliary type for our common variables:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始开发视图控制器代码之前，我们将为我们的公共变量创建一个辅助类型：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we will need to use the core location for receiving the current location,
    we will need to implement the view controller as a core location delegate:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将需要使用核心位置来接收当前位置，我们需要将视图控制器实现为核心位置代理：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can add the attributes, we will need one database connection for the
    location manager and another one for keeping the last location received:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加属性，我们需要一个数据库连接用于位置管理器，另一个用于保存接收到的最后位置：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is time to develop the methods, starting with the `viewDidLoad`; here we
    need to set everything up:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候开发方法了，从 `viewDidLoad` 开始；在这里，我们需要设置一切：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see we have a few methods to implement. Let''s start with the `openDatabase`,
    which creates the database and handles the connection:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们有几个方法需要实现。让我们从 `openDatabase` 开始，它创建数据库并处理连接：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is creating the database structure; it will create a table called
    `activity` with its columns:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建数据库结构；它将创建一个名为 `activity` 的表，并包含以下列：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The database initialization is done; we need to start receiving information
    about the device position by setting up the core location:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库初始化已完成；我们需要通过设置核心位置来开始接收设备位置信息：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you know, we need to implement the method that updates the current location:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所知，我们需要实现更新当前位置的方法：
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we need to get notifications from the proximity sensor; to do it we need
    to use the notification center:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要从接近传感器获取通知；为了做到这一点，我们需要使用通知中心：
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, when we receive a proximity sensor change, the method `proximity`
    will be called; that''s the moment when we have to store in the database that
    an activity has started or ended:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，当我们收到接近传感器变化时，`proximity`方法将被调用；那就是我们必须在数据库中存储活动开始或结束的时刻：
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we need to create the method that returns the variables that are related
    to the activity table:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个返回与活动表相关的变量的方法：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last part of the development is the button event, which was empty until
    now. We just need to retrieve data from the activity table and add it to the text
    view:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发的最后一部分是按钮事件，直到现在都是空的。我们只需要从活动表中检索数据并将其添加到文本视图中：
- en: '[PRE31]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is one more step that you might need to do: click on the Info.plist of
    your project and add a new row. In this row, set `NSLocationAlwaysUsageDescription`
    for the key and `This app needs GPS` as the value. The reason for it is that on
    iOS 8 when you request permission to use the GPS (Core Location), it is ignored
    if there is no message. Some people say that it is a bug and it should be fixed
    soon.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还需要执行另一个步骤：点击你的项目的Info.plist文件并添加一个新行。在这个行中，将键设置为`NSLocationAlwaysUsageDescription`，将值设置为`This
    app needs GPS`。这样做的原因是，在iOS 8中，当你请求使用GPS（核心位置）的权限时，如果没有消息，它会被忽略。有些人说这是一个bug，并且它应该很快得到修复。
- en: Once again, the app is done and we need to test it, so press play and put your
    phone next to your head as if you were talking on it. Repeat this a few times,
    and then check the table content by pressing the button. Your result should be
    something similar to this screenshot:![How to do it…](img/00154.jpeg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，应用已经完成，我们需要对其进行测试，所以按播放按钮，并将你的手机放在你的头部旁边，就像你在用它通话一样。重复几次，然后通过按按钮检查表内容。你的结果应该类似于这个截图：![如何做到这一点…](img/00154.jpeg)
- en: How it works…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`SQLite.Swift` is a good layer over the SQLite library. You can create a database
    by creating an object of database type. You can define the table fields with a
    generic class called **Expression**. This class works with integers (`Int`), double
    precision (`Double`), strings, and Boolean types (`Bool`). All of them can be
    declared as optionals, meaning that the database can store null values on it.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLite.Swift`是SQLite库的一个良好封装。你可以通过创建数据库类型的对象来创建数据库。你可以使用一个名为**Expression**的泛型类来定义表字段。这个类与整数（`Int`）、双精度（`Double`）、字符串和布尔类型（`Bool`）一起工作。所有这些都可以声明为可选的，这意味着数据库可以在其中存储null值。'
- en: You can use methods such as insert or update for adding or changing a record;
    both of these receive a type called setter, which is like the relationship between
    a field and its value. To create an object of Setter type you have to use the
    operator `<-`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用如`insert`或`update`这样的方法来添加或更改记录；这两个方法都接收一个名为setter的类型，它类似于字段和其值之间的关系。要创建setter类型的对象，你必须使用操作符`<-`。
- en: For retrieving results, you can iterate over a query object like we did with
    the `for` loop and access its fields with the subscript using the expression fields
    as an index.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检索结果，你可以像使用`for`循环一样遍历一个查询对象，并使用表达式作为索引通过下标访问其字段。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use the filter method for retrieving only the records that complain
    with a criteria, such as the where clause on the SQL language.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用过滤方法来检索符合特定标准的记录，例如SQL语言中的WHERE子句。
- en: There's more…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As you could see with this framework, we didn't have the need of writing SQL
    statements; however `SQLite.Swift` allows you to work with SQL statements if you
    want. To do it you can use methods such as run or prepare.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们不需要编写SQL语句；然而`SQLite.Swift`允许你在需要时使用SQL语句。为此，你可以使用如`run`或`prepare`这样的方法。
- en: Another excellent feature of `SQLite.Swift` is that it is transaction ready.
    The method transaction and how it works for using transactions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLite.Swift`的另一个优秀特性是它支持事务。事务方法及其使用事务的方式。'
- en: Apple has another solution for using a database over its own layer, called **Core
    Data**. In the next recipe, we are going to learn how to use it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司还有一个在其自身层上使用数据库的解决方案，称为**Core Data**。在下一个菜谱中，我们将学习如何使用它。
- en: Controlling your stocks
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制你的库存
- en: The idea of an application connected with a database came from the need to keep
    some data, even if the application finishes. However, SQL is another language
    and you have to repeat some developments twice, such as a new field on a class
    is also a new field on the database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序与数据库相连的想法源于需要保留一些数据，即使应用程序已经结束。然而，SQL是另一种语言，你必须重复一些开发工作，例如，在类中添加一个新字段，在数据库中也是一个新字段。
- en: When Xerox developed the first window system based on Smalltalk, it didn't use
    any kind of database. The argument for it is that if an application doesn't finish,
    the data will always be on the RAM memory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当施乐公司开发基于Smalltalk的第一个窗口系统时，它没有使用任何类型的数据库。它的论点是，如果一个应用程序没有结束，数据总是会留在RAM内存中。
- en: The idea is very intelligent, however we know that the real world doesn't work
    like that. Applications crash and finish and devices need to reboot sometimes.
    Beside these facts, you also need to consider that, until today, RAM memory was
    still more expensive than hard disk. The new iPhone 6, for example, has only 1
    gigabyte of RAM and at least 32 gigabytes of permanent storage.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法非常聪明，然而我们知道现实世界并不总是这样运作。应用程序会崩溃并结束，设备有时需要重启。除了这些事实之外，你还需要考虑，直到今天，RAM内存仍然比硬盘更贵。例如，新的iPhone
    6只有1GB的RAM和至少32GB的永久存储。
- en: Based on the problems just mentioned, Apple recommends using its own ORM called
    **Core Data**. An **ORM** is a framework that allows your objects to be stored
    on a permanent storage system without wasting time writing SQL statements. Actually
    what Core Data does is write the SQL for us.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述提到的问题，苹果推荐使用其自己的ORM（对象关系映射）框架，称为**Core Data**。ORM是一种框架，允许你的对象存储在永久存储系统中，而无需浪费时间编写SQL语句。实际上，Core
    Data为我们编写了SQL。
- en: In this recipe, we are going to develop a small app using Core Data by simulating
    a product control of a warehouse.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过模拟仓库的产品控制来开发一个小应用程序，使用Core Data。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start creating a new app called `Chapter 10 Stock Control`, however make sure
    that the option **Use Core Data** is checked as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 开始创建一个名为`第10章库存控制`的新应用程序，但请确保已选中如下截图所示的**使用Core Data**选项：
- en: '![Getting ready](img/00155.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/00155.jpeg)'
- en: How to do it…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First, we will need to create a database model. Don't think in SQLite when creating
    this model because there will be some different types. So click on the file `Chapter_10_Stock_Control.xcdatamodeld`;
    here you should see a different layout with some empty fields. Let's start by
    pressing the sign that is located over the text **Add Entity**:![How to do it…](img/00156.jpeg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个数据库模型。在创建此模型时，不要考虑SQLite，因为这里会有一些不同类型。所以点击文件`Chapter_10_Stock_Control.xcdatamodeld`；你应该看到一个不同的布局和一些空字段。让我们先按一下位于文本**添加实体**上方的符号：![如何操作…](img/00156.jpeg)
- en: Rename the new entity to `Product`:![How to do it…](img/00157.jpeg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新实体重命名为`Product`：![如何操作…](img/00157.jpeg)
- en: After that, add three attributes for this entity, one called `name`, which should
    be of type string, `price` that is a double, and `units`, which is an integer
    of 32 bits:![How to do it…](img/00158.jpeg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，为这个实体添加三个属性，一个名为`name`，类型为字符串，一个名为`price`，类型为双精度浮点数，还有一个名为`units`，类型为32位整数：![如何操作…](img/00158.jpeg)
- en: That's all for the data part. Now we need to click on the storyboard file. Select
    the only view controller you have by clicking on it and go to the **Editor** menu,
    expand the **Embedded In** option and select **Navigation Controller**:![How to
    do it…](img/00159.jpeg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据部分就到这里。现在我们需要点击故事板文件。通过点击它来选择你拥有的唯一视图控制器，然后转到**编辑**菜单，展开**嵌入在**选项并选择**导航控制器**：![如何操作…](img/00159.jpeg)
- en: As we don't want the navigation bar for this app, you can click on the navigation
    controller just created and uncheck the option **Show Navigation Bar** that is
    on attribute inspector:![How to do it…](img/00160.jpeg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不希望这个应用程序有导航栏，你可以点击刚刚创建的导航控制器，并在属性检查器中取消选中**显示导航栏**选项：![如何操作…](img/00160.jpeg)
- en: Now add a button on the only view controller we have with the text **New product**;
    under it add a table view. You should have a layout similar to the following one:![How
    to do it…](img/00161.jpeg)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在我们拥有的唯一视图控制器上添加一个带有文本**新产品**的按钮；在其下方添加一个表格视图。你应该有一个类似于以下布局：![如何操作…](img/00161.jpeg)
- en: 'Now go to the view controller and import `CoreData`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到视图控制器并导入`CoreData`：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After, you have to add the `UITableViewDataSource` protocol to the view controller;
    that way we display results on the table view:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你必须将`UITableViewDataSource`协议添加到视图控制器中；这样我们就可以在表格视图中显示结果：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now connect the table view with the view controller as a data source and as
    an attribute of it. As we are adding an attribute we can also add a new attribute
    that will contain our records:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将表格视图与视图控制器作为数据源和属性连接起来。因为我们正在添加一个属性，我们也可以添加一个新属性，它将包含我们的记录：
- en: '[PRE34]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once it is done, we have to implement the methods that update the table view
    information. In this case, the number of records is the size of the array but
    their contents are the values of some keys of the `NSManagedObject`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们就必须实现更新表格视图信息的那些方法。在这种情况下，记录的数量是数组的长度，但它们的值是`NSManagedObject`的一些键的值：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Imagine that when we create a new record, it''s necessary to reload the table
    view data. We could create a button for refreshing it, but it wouldn''t be so
    intuitive, so the best way we can do it is, when the view appears again, we can
    refresh the data as well as updating the product array:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，当我们创建一个新记录时，重新加载表格视图数据是必要的。我们可以创建一个刷新按钮，但这样并不直观，所以我们能做的最好的方式是，当视图再次出现时，我们可以刷新数据以及更新产品数组：
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Good, press play and what happens? Nothing! The reason is that we are able to
    list the records but not to insert them, so it is time to add functionality to
    the **New product** button. Return to the storyboard and add a new view controller,
    put it on the right-hand side of the previous one and click on the **New product**
    button with the ** key pressed and drag it to the new view controller.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，按下播放，会发生什么？什么都没有！原因是我们可以列出记录，但不能插入它们，所以是时候给**新产品**按钮添加功能了。返回到故事板，添加一个新的视图控制器，将其放在上一个视图控制器的右侧，并按住**键点击**新产品**按钮，将其拖到新的视图控制器中。
- en: Press play, of course you are not going to see any records, but if you tap on
    the button you can see that a new view is called. At this moment we need to develop
    this view, however, before we continue, it needs a view controller file; in this
    case you have to add a new file of type Cocoa Touch Class and name it `NewProductViewController`.
    Make sure that it inherits from **UIViewController**:![How to do it…](img/00162.jpeg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放，当然你不会看到任何记录，但如果你点击按钮，你可以看到一个新视图被调用。在这个时候，我们需要开发这个视图，然而，在我们继续之前，它需要一个视图控制器文件；在这种情况下，你必须添加一个新文件，类型为Cocoa
    Touch Class，并将其命名为`NewProductViewController`。确保它继承自**UIViewController**：![如何做…](img/00162.jpeg)
- en: Return to your storyboard and change the class of this view controller on the
    identity inspector to the new file created:![How to do it…](img/00163.jpeg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的故事板，并在身份检查器中将此视图控制器的类更改为新创建的文件：![如何做…](img/00163.jpeg)
- en: Now let's create a layout for this view. We have to add three text fields (one
    for each entity field), three labels for explaining what these fields are about,
    one button for saving the records, and one label just for displaying the view
    title (as we don't have the navigation bar):![How to do it…](img/00164.jpeg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为这个视图创建一个布局。我们必须添加三个文本字段（每个实体字段一个），三个标签来解释这些字段的内容，一个用于保存记录的按钮，以及一个仅用于显示视图标题的标签（因为我们没有导航栏）：![如何做…](img/00164.jpeg)
- en: 'Once the layout is done we have to connect the text field to the new product
    view controller:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦布局完成，我们必须将文本字段连接到新的产品视图控制器：
- en: '[PRE37]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last part we need to do is the save button development. As it is going
    to use a few `CoreData` classes, you have to start by importing it:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一部分是保存按钮的开发。因为它将要使用几个`CoreData`类，所以你必须先导入它们：
- en: '[PRE38]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now connect your `save` button with an action called save and develop it by
    retrieving the text fields data and saving it with core data:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将你的`save`按钮连接到一个名为`save`的动作，并通过检索文本字段的数据并使用核心数据保存它来开发它：
- en: '[PRE39]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The last step is testing your app. Press play, and add a few products such as
    computers, potatoes, and cars, and check that they appear on your table view.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是测试你的应用程序。按下播放，添加一些产品，如电脑、土豆和汽车，并检查它们是否出现在你的表格视图中。
- en: How it works…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We have to be very thankful to Apple because old versions of Xcode didn''t
    have the option of creating a `CoreData` application, which meant that the code
    for initialization done on the `AppDelegate` class had to be done manually. What
    it does is create some attributes such as `managedObjectModel` that read the entity
    model and interpret it; the `persistentStoreCoordinator` then converts from core
    data to a persistent system (SQLite by default, but it can be configured to be
    an XML file, for example), and a very important one: `managedObjectContext`; this
    object controls the objects/records that belong to `CoreData`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须非常感谢苹果公司，因为旧版本的 Xcode 没有创建 `CoreData` 应用程序的选项，这意味着在 `AppDelegate` 类上执行的初始化代码必须手动完成。它所做的就是创建一些属性，例如
    `managedObjectModel`，这些属性读取实体模型并对其进行解释；然后 `persistentStoreCoordinator` 将核心数据转换为持久化系统（默认为
    SQLite，但可以配置为 XML 文件等），还有一个非常重要的一点：`managedObjectContext`；这个对象控制属于 `CoreData`
    的对象/记录。
- en: For this reason, every time we had to use something from `CoreData` we had to
    access the `AppDelegate` class a few times. If you prefer, you can create your
    own singleton class and transfer the `CoreData` code over there.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们需要使用 `CoreData` 中的某些东西时，我们都需要几次访问 `AppDelegate` 类。如果你愿意，你可以创建自己的单例类并将
    `CoreData` 代码转移到那里。
- en: When we need a new record, we need an object of type `NSManagedObject`. If it
    is a new record we can ask for the help of the method `insertNewObjectForEntityForName`
    from the `NSEntityDescription` class. Accessing its fields is very easy; we just
    need to use `valueForKey` for retrieving its value or setValue for modifying it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要一个新的记录时，我们需要一个 `NSManagedObject` 类型的对象。如果它是一个新记录，我们可以请求 `NSEntityDescription`
    类的 `insertNewObjectForEntityForName` 方法来帮忙。访问其字段非常简单；我们只需要使用 `valueForKey` 来获取其值或
    `setValue` 来修改它。
- en: If you need to access the objects, you have to use `NSFetchRequest`, which is
    like an SQL statement. The `managedObjectContext` is the one that can execute
    this request and return its data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要访问对象，你必须使用 `NSFetchRequest`，它就像一个 SQL 语句。`managedObjectContext` 是可以执行此请求并返回其数据的对象。
- en: There's more…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you want to filter some data, you can use `NSPredicate`, which is something
    like the where clause of SQL.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要过滤一些数据，你可以使用 `NSPredicate`，它类似于 SQL 的 where 子句。
- en: We've seen some ways of storing data into your local device, but how about a
    network database? In the next recipe we are going to use a centralized database
    for storing our data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些将数据存储到本地设备的方法，但关于网络数据库呢？在下一个菜谱中，我们将使用集中式数据库来存储我们的数据。
- en: Designing a voting device using CouchDB
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CouchDB 设计投票设备
- en: As we learned before, usually on mobile apps we access a local database, but
    sometimes we need to use only one database with a lot of devices connected to
    it. For example, when you do a Google query you don't download the whole Google
    index onto your mobile phone, you just request some information and retrieve the
    result.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所学的，通常在移动应用中，我们访问本地数据库，但有时我们只需要使用一个与许多连接的设备共享的数据库。例如，当你进行 Google 搜索时，你不会将整个
    Google 指数下载到你的手机上，你只是请求一些信息并检索结果。
- en: In this recipe we are going to learn how to use a centralized database, in this
    case we are going to use a database called CouchDB.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用集中式数据库，在这种情况下，我们将使用一个名为 CouchDB 的数据库。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: For this recipe you need to download a CouchDB server. I assume that you are
    developing on a Mac computer, so it will be demonstrated with Mac OS X. In case
    you prefer to use another platform, such as Linux or Windows, feel free to use
    them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要下载一个 CouchDB 服务器。我假设你正在 Mac 计算机上开发，所以它将以 Mac OS X 进行演示。如果你更喜欢使用其他平台，如
    Linux 或 Windows，请随意使用。
- en: 'Download CouchDB from [http://couchdb.apache.org](http://couchdb.apache.org).
    Once it is downloaded and unzipped, right click on its icon and choose the option
    **Show Package Contents** from the menu:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://couchdb.apache.org](http://couchdb.apache.org) 下载 CouchDB。一旦下载并解压，右键单击其图标，从菜单中选择
    **显示包内容** 选项：
- en: '![Getting ready](img/00165.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00165.jpeg)'
- en: Now follow the path `Contents/Resources/couchdbx-core/etc/couchdb`; here you
    should see a file called `default.ini`. Open it and search for the variable `bind_address`.
    Here you have to change from 127.0.0.1 to 0.0.0.0\. Now return to the folder where
    the CouchDB app is located and open the app by double-clicking on it. Your web
    browser should open displaying the CouchDB front-end (called **Futon**); keep
    it open for checking the results later.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照路径`Contents/Resources/couchdbx-core/etc/couchdb`前进；在这里你应该看到一个名为`default.ini`的文件。打开它，搜索变量`bind_address`。这里你必须将`127.0.0.1`更改为`0.0.0.0`。现在返回CouchDB应用所在的文件夹，通过双击打开应用。你的网络浏览器应该会打开，显示CouchDB前端（称为**Futon**）；保持它打开，以便稍后检查结果。
- en: A big detail that you have to bear in mind is that if you are going to use a
    physical device it must use the same Wi-Fi network as your computer; otherwise
    your device won't be able to find your database server.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个你必须牢记的重要细节是，如果你打算使用一个物理设备，它必须使用与你的电脑相同的Wi-Fi网络；否则，你的设备将无法找到你的数据库服务器。
- en: Return to your Xcode and create a new project called `Chapter 10 Voting`. Here
    you won't need `CoreData`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 返回你的Xcode，创建一个名为`Chapter 10 Voting`的新项目。在这里，你不需要`CoreData`。
- en: How to do it…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: The first step is setting the database. Go to your web browser and click on
    the button Create database. If for any reason you closed your browser, just type
    the URL `http://127.0.0.1:5984/_utils/`. When the website asks for a database
    name, write `voting`:![How to do it…](img/00166.jpeg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设置数据库。打开你的网络浏览器，点击创建数据库的按钮。如果你因为任何原因关闭了浏览器，只需输入URL `http://127.0.0.1:5984/_utils/`。当网站要求输入数据库名称时，写下`voting`：![如何做到这一点…](img/00166.jpeg)
- en: Inside this database we need to add a few documents. So press on the button
    that says **New document**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个数据库中，我们需要添加一些文档。所以点击名为**新建文档**的按钮。
- en: Note
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Documents in CouchDB are JSON dictionaries.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CouchDB中的文档是JSON字典。
- en: 'For the first document, click on **Source** and complete it as shown in the
    following code. Do not modify the _id value, leave the one that CouchDB gave you:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个文档，点击**源**并按照以下代码完成。不要修改_id值，保留CouchDB给你的那个：
- en: '[PRE40]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Good, now press save document and let''s repeat the operation with another
    document; this way we can be sure that the questions are being received from the
    database:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在点击保存文档，然后让我们用另一个文档重复这个操作；这样我们可以确保问题是从数据库接收到的：
- en: '[PRE41]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we need to create an update handler, which is like a function that receives
    some data and completes a document for us. Click on new document and this time
    we need to change the document id because it will be called `_design/voting`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个更新处理程序，它就像一个接收一些数据并为我们完成文档的函数。点击新建文档，这次我们需要更改文档ID，因为它将被命名为`_design/voting`：
- en: '[PRE42]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The database part is done; therefore you have to go back to your Xcode project.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库部分已经完成；因此，你必须回到你的Xcode项目中。
- en: Note
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Explaining how CouchDB works is out of the scope of this book; if you would
    like to learn how to use this database, there are good books and tutorials about
    it.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解释CouchDB的工作原理超出了本书的范围；如果你想学习如何使用这个数据库，有关于它的优秀书籍和教程。
- en: Once you've returned to your Xcode project, click on the storyboard and add
    two labels and three buttons to your view. Write `TODAY'S QUESTION` on the first
    label, which should be located at the top of the view. Below it, place the other
    label, which will contain the received question, and under that the three buttons.
    Don't worry about the text of these components, they will be changed programmatically.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你回到了你的Xcode项目，点击故事板，并在视图中添加两个标签和三个按钮。在视图顶部放置第一个标签，上面写着`TODAY'S QUESTION`。在其下方放置另一个标签，它将包含接收到的提问，然后在其下方放置三个按钮。不用担心这些组件的文本，它们将通过编程方式更改。
- en: 'As usual, we have to link some components with the view controller; in this
    case we have to connect the question label and the three buttons:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，我们必须将一些组件与视图控制器链接起来；在这种情况下，我们必须连接问题标签和三个按钮：
- en: '[PRE43]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Besides that, we will also add two attributes, one for the document id and
    another one for the common part of the request''s URL. Remember that if you are
    using a device, you have to change the IP from `127.0.0.1` to the one of your
    computer:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还将添加两个属性，一个用于文档ID，另一个用于请求URL的公共部分。记住，如果你正在使用设备，你必须将IP从`127.0.0.1`更改为你的电脑的IP：
- en: '[PRE44]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Connect the three buttons with the same action called `vote`. Leave this action
    empty for now:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个按钮连接到同一个名为`vote`的动作。现在暂时留这个动作为空：
- en: '[PRE45]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the application starts we need to receive the current questions that our
    database has, so let''s just start calling a function that will do it for us on
    the `viewDidLoad` method:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序启动时，我们需要接收数据库中当前的问题，所以让我们在`viewDidLoad`方法中调用一个函数来帮我们完成这个任务：
- en: '[PRE46]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you might imagine, we have to implement the `chooseQuestion` method. This
    method will call the action `_all_docs`, which returns the ID of every document
    on the database, including the special document `_design/voting`. Once we have
    received the document we can choose one of them and request its data:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所想，我们必须实现`chooseQuestion`方法。这个方法将调用`_all_docs`动作，它返回数据库中每个文档的ID，包括特殊文档`_design/voting`。一旦我们收到文档，我们就可以选择其中一个并请求其数据：
- en: '[PRE47]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once the application has decided which document it wants, we can request its
    data. The mechanism is similar to the previous one, but with the difference that
    when we receive the data we have to update the UI. As you know it must be done
    on the main thread:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序决定它想要哪个文档，我们就可以请求它的数据。机制与之前类似，但不同之处在于当我们收到数据时，我们必须更新UI。正如你所知，这必须在主线程上完成：
- en: '[PRE48]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you press play now you are going to see a screen like the following one.
    It means that you have received a question with its possible answers from the
    database. However, if you choose any answer, nothing happens:![How to do it…](img/00167.jpeg)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在按下播放按钮，你会看到一个像下面的屏幕。这意味着你从数据库中收到了一个问题及其可能的答案。然而，如果你选择任何答案，什么也不会发生：![如何操作…](img/00167.jpeg)
- en: 'Now it''s time to implement the vote action. The idea is to check which button
    was pressed and then send this information with the device id to the database.
    This way our vote will be registered:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候实现投票动作了。想法是检查哪个按钮被按下，然后将这个信息连同设备ID一起发送到数据库。这样我们的投票就会被记录：
- en: '[PRE49]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The application is done, so now we have to check that it communicates with the
    database correctly. Press play again and choose an answer. You should receive
    an alert view thanking you, which is a good sign. After that go to the web browser
    again and open the chosen document; check that your device ID is there on the
    answer that you have selected:![How to do it…](img/00168.jpeg)
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已经完成，所以现在我们必须检查它与数据库的正确通信。再次按下播放按钮并选择一个答案。你应该收到一个感谢你的警报视图，这是一个好兆头。之后，再次打开网页浏览器并打开所选文档；检查你的设备ID是否在所选答案中：![如何操作…](img/00168.jpeg)
- en: How it works…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: If you have worked with remote SQL databases you might know that usually you
    need a driver/connector, which should be compatible with your platform and can
    also be blocked by some firewalls.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经与远程SQL数据库合作过，你可能知道通常你需要一个驱动器/连接器，它应该与你的平台兼容，也可能被某些防火墙阻止。
- en: 'CouchDB is a NoSQL database that works by exchanging JSON messages via http
    protocol, which makes our life easier, because we didn''t have to add any controller,
    just receive and send JSON messages. Due to the way that this database works we
    had to develop a function for updating/inserting a new vote on the client size;
    remember that Swift is not JavaScript: adding a new element into a JSON array
    can give us more work than just developing a simple function.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB是一个通过http协议交换JSON消息工作的NoSQL数据库，这使得我们的生活更加容易，因为我们不需要添加任何控制器，只需接收和发送JSON消息。由于这个数据库的工作方式，我们不得不在客户端开发一个用于更新/插入新投票的函数；记住，Swift不是JavaScript：将新元素添加到JSON数组中可能会给我们带来比开发一个简单的函数更多的工作。
- en: Why did we have to cast to `NSArray` and `NSDictionary` a few times? The reason
    is that the `NSJSONSerialization` was created on the Objective-C era, meaning
    that it is still not 100% prepared for Swift.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不得不几次将`NSArray`和`NSDictionary`转换为类型？原因是`NSJSONSerialization`是在Objective-C时代创建的，这意味着它仍然不是100%为Swift准备的。
- en: It is true that the way we worked could be better organized. The ideal way is
    by creating a layer for CouchDB, such as a framework or a library, however this
    task will be left as homework.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，我们工作的方式可能组织得更好。理想的方式是创建一个CouchDB层，比如一个框架或库，然而这项任务将被留作家庭作业。
- en: There's more…
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this chapter, we learned different ways of using databases on Swift; some
    of them are very straightforward and others require a better analysis.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了在Swift中使用数据库的不同方法；其中一些非常直接，而另一些则需要更好的分析。
- en: In the next chapter, we are going to learn some new tricks, mainly those that
    are related to the new Xcode 6 and the iOS 8.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些新的技巧，主要是与新的Xcode 6和iOS 8相关的新技巧。
