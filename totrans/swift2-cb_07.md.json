["```swift\n    // element must be one of the elements in the set\n    func assert_in<T:Comparable>(element: @autoclosure () -> T, set: [T], message: @autoclosure () -> String){\n        #if DEBUG_MODE\n            if set.count == 0 {\n            println(\"warning: comparing with an empty set\")\n            }\n            assert(set.filter({(currentElement) -> Bool in\n            return currentElement == element()\n            }).count > 0, message)\n        #endif\n    }\n\n    // element must be greater or equal to the other value\n    func assert_ge<T:Comparable>(value:T, otherValue:T, message: @autoclosure () -> String){\n        #if DEBUG_MODE\n            assert(value >= otherValue , message)\n        #endif\n    }\n\n    // element can't be nil\n    func assert_not_nil<T>(element:@autoclosure () -> T?, message: @autoclosure () -> String){\n        if element() == nil {\n            #if DEBUG_MODE\n                assertionFailure(message)\n            #endif\n        }\n    }\n    ```", "```swift\n    class IncomeTaxCalculator: CustomStringConvertable {\n    ```", "```swift\n        var title:String?\n        var name:String?\n        lazy var grossIncome:Double = 0.0\n        lazy var netIncome:Double = 0.0\n        lazy var children:Int = 0\n        lazy var education:Double = 0.0\n    ```", "```swift\n    init(){}\n    ```", "```swift\n        var description: String {\n            assert_not_nil(self.title, \"Title cant be nil\")\n            assert_not_nil(self.name, \"Name cant be nil\")\n            assert_in(self.title!, [\"Mr\", \"Dr\", \"Miss\", \"Mrs\"], \"Wrong title\")\n            return \"\\(self.title!) \\(self.name!) - \\(self.calculate())\"\n        } \n    ```", "```swift\n        func calculate() -> Double {\n            assert_ge(self.grossIncome, 0.0, \"Gross income can't be negative\")\n            assert_ge(self.netIncome, 0.0, \"Net income can't be negative\")\n            assert_ge(self.grossIncome, self.netIncome, \"Net income cant be negative\")\n\n            let totalAlreadyPaid = self.grossIncome - self.netIncome\n            var percentage:Double\n            if self.grossIncome <= 9000.0 {\n                percentage = 0.0\n            } else if self.grossIncome <= 18000.0 {\n                percentage = 0.15\n            } else {\n                percentage = 0.40\n            }\n\n            let childrenBonus = Double(self.children) * 100.0\n\n            // 10 percent of education up to 1000 per child\n            var educationBonus:Double\n            var educationLimit = Double(self.children) * 1000.0\n            if 0.1 * self.education < educationLimit {\n                educationBonus = 0.1 * self.education\n            }else {\n                educationBonus = educationLimit\n            }\n\n            return self.grossIncome * percentage - childrenBonus - educationBonus - totalAlreadyPaid\n        }\n    }\n    ```", "```swift\n        @IBOutlet var titleTextField: UITextField!\n        @IBOutlet var nameTextField: UITextField!\n        @IBOutlet var lastYearIncomeTextField: UITextField!\n        @IBOutlet var numberOfChildrenTextField: UITextField!\n        @IBOutlet var LastYearNetIncome: UITextField!\n        @IBOutlet var educationTextField: UITextField!\n    ```", "```swift\n        @IBAction func calculateAction(sender: UIButton) {\n            assert(countElements(self.nameTextField.text) >= 5, \"Your name looks too short\")\n            var error:NSError?\n            let regex = NSRegularExpression(pattern: \"^[0-9]+[.[0-9]+]?$\", options: .CaseInsensitive, error: &error)!\n            if regex.matchesInString(self.lastYearIncomeTextField.text, options: nil, range: NSMakeRange(0, countElements(self.lastYearIncomeTextField.text))).count == 0{\n                assertionFailure(\"Gross Income tax: wrong format\")\n            }\n            let income = (self.lastYearIncomeTextField.text as NSString).doubleValue\n            let incomeTaxCalculator:IncomeTaxCalculator = IncomeTaxCalculator()\n            incomeTaxCalculator.title = self.titleTextField.text\n            incomeTaxCalculator.name = self.nameTextField.text\n            incomeTaxCalculator.grossIncome = (self.lastYearIncomeTextField.text as NSString).doubleValue\n            incomeTaxCalculator.netIncome = (self.LastYearNetIncome.text as NSString).doubleValue\n            incomeTaxCalculator.education = (self.educationTextField.text as NSString).doubleValue\n            incomeTaxCalculator.children = self.numberOfChildrenTextField.text.toInt()!\n            UIAlertView(title: \"Income Tax\", message: incomeTaxCalculator.description, delegate:nil, cancelButtonTitle:\"Ok\").show()\n        }\n    ```", "```swift\n    import UIKit\n    ```", "```swift\n        override func viewDidLoad() {\n            super.viewDidLoad()\n            var board = CheckersBoard()\n            board.board[2][5] = .WHITE\n            board.board[2][3] = .BLACK\n            board.board[4][3] = .WHITE\n            board.board[2][1] = .BLACK\n            board.board[0][5] = .WHITE\n            board.board[1][0] = .BLACK\n            board.board[7][6] = .WHITE\n            board.board[5][6] = .BLACK\n        }\n    ```", "```swift\n        enum BoardSpace {\n            case FREE,\n            WHITE(Bool),\n            BLACK(Bool)\n        }\n    ```", "```swift\n                    var isKing = false;\n\n                    switch board[row][col] {\n                    case .WHITE(let king):\n                        isKing = king\n                        UIColor.whiteColor().setFill()\n                    case .BLACK(let king):\n                        isKing = king\n                        UIColor.brownColor().setFill()\n                    default:\n                        continue\n                    }\n    ```", "```swift\n    ...\n    bezier.fill()\n    if isKing {\n       (\"K\" as NSString).drawAtPoint(CGPointMake(offsetx + CGFloat( squareSize / 3 ) , offsety + CGFloat(squareSize / 5)), withAttributes: nil)\n    }\n    ```", "```swift\n            let board = CheckersBoard()\n            board.board[2][5] = .WHITE(false)\n            board.board[2][3] = .BLACK(false)\n            board.board[4][3] = .WHITE(true)\n            board.board[2][1] = .BLACK(false)\n            board.board[0][5] = .WHITE(false)\n            board.board[1][0] = .BLACK(false)\n            board.board[7][6] = .WHITE(false)\n            board.board[5][6] = .BLACK(false)\n    ```", "```swift\n        func clone() -> CheckersBoard {\n            let board = CheckersBoard()\n            for i in 0..<8 {\n                for j in 0..<8 {\n                    switch self.board[i][j] {\n                    case .FREE:\n                        continue\n                    default:\n                        board.board[i][j] = self.board[i][j]\n                    }\n                }\n            }\n            return board\n        }\n    ```", "```swift\n        enum Direction {\n            case NORTHWEST,\n            NORTHEAST,\n            SOUTHWEST,\n            SOUTHEAST\n        }\n    ```", "```swift\n        func bestMovementWhite() -> CheckersBoard?{\n            var boardCandidate:CheckersBoard?\n            for i in 0..<8 {\n                for j in 1..<8 {\n                    var result: CheckersBoard?\n                    switch self.board[i][j]{\n\n                    case .WHITE(let king):\n                        if king {\n                            result = bestMovementKingWhite(i, y: j)\n                        }else {\n                          result = bestMovementSinglePieceWhite(i, y: j)\n                        }\n                    default:\n                        continue\n                    }\n\n                    if let boardFound = result {\n                        if let currentBoard = boardCandidate {\n                            if currentBoard.countBlack() > boardFound.countBlack() {\n                                boardCandidate = boardFound\n                            }\n                        }else {\n                            boardCandidate = boardFound\n                        }\n                    }\n                }\n            }\n            return boardCandidate\n        }\n    ```", "```swift\n        private func bestMovementSinglePieceWhite(x:Int, y:Int) -> CheckersBoard {\n            var clonedBoard = self.clone()\n            if clonedBoard.capture(x, y: y, direction: .NORTHWEST) {\n               return clonedBoard.bestMovementSinglePieceWhite(-1, y: -1)\n            }\n\n            if clonedBoard.capture(x, y: y, direction: .NORTHEAST) {\n                return clonedBoard.bestMovementSinglePieceWhite(1, y: -1)\n            }\n\n            if clonedBoard.capture(x, y: y, direction: .SOUTHWEST) {\n                return clonedBoard.bestMovementSinglePieceWhite(-1, y: 1)\n            }\n\n            if clonedBoard.capture(x, y: y, direction: .SOUTHEAST) {\n                return clonedBoard.bestMovementSinglePieceWhite(1, y: 1)\n            }\n            return clonedBoard\n        }\n\n        private func bestMovementKingWhite(x:Int, y:Int) -> CheckersBoard? {\n            // TODO Homework\n            return nil\n        }\n    ```", "```swift\n        func countBlack() -> Int{\n            var total = 0\n            for row in self.board {\n                for element in row {\n                    switch element {\n                    case .BLACK:\n                        total++\n                    default:\n                        continue\n                    }\n                }\n            }\n            return total\n        }\n        private func capture(x: Int, y:Int, direction: Direction) -> Bool {\n            var offset_x:Int\n            var offset_y:Int\n            switch(direction){\n            case .NORTHWEST:\n                offset_x = -1\n                offset_y = -1\n            case .NORTHEAST:\n                offset_x = 1\n                offset_y = -1\n            case .SOUTHWEST:\n                offset_x = -1\n                offset_y = 1\n            case .SOUTHEAST:\n                offset_x = 1\n                offset_y = 1\n            }\n            if x + 2*offset_x >= 0 && y + 2*offset_y >= 0 && x + 2*offset_x < 8 &&  y + 2*offset_y < 8 {\n                // we are inside the board range\n                switch (board[x + 2*offset_x][y+2*offset_y], board[x + offset_x][y+offset_y]) {\n                    case (.FREE, .BLACK):\n                        board[x + offset_x][y+offset_y] = .FREE\n                        board[x + 2 * offset_x ][ y + 2 * offset_y] = board[x][y]\n                        board[x][y] = .FREE\n                    return true\n                    default:\n                    return false\n                }\n            }else {\n                return false\n            }\n        }\n    ```", "```swift\n            let board = CheckersBoard()\n            board.board[0][1] = .WHITE(false)\n            board.board[0][5] = .WHITE(false)\n            board.board[2][7] = .WHITE(false)\n            board.board[3][2] = .WHITE(false)\n            board.board[2][1] = .BLACK(false)\n            board.board[4][3] = .BLACK(false)\n            board.board[4][5] = .BLACK(false)\n            board.board[2][5] = .BLACK(false)\n            board.board[2][3] = .BLACK(false)\n            if let finalBoard = board.bestMovementWhite() {\n                println(finalBoard.debugDescription)\n            }else {\n                println(\"no solution\")\n            }\n    ```", "```swift\n        private func bestMovementSinglePieceWhite(x:Int, y:Int) -> CheckersBoard {\n            var clonedBoard = self.clone()\n            var winner:CheckersBoard = self\n\n            if clonedBoard.capture(x, y: y, direction: .NORTHWEST) {\n                winner = clonedBoard.bestMovementSinglePieceWhite(x-2, y: y-2)\n            }\n\n            clonedBoard = self.clone()\n            if clonedBoard.capture(x, y: y, direction: .NORTHEAST) {\n                clonedBoard = clonedBoard.bestMovementSinglePieceWhite(x+2, y: y-2)\n                if winner.countBlack() > clonedBoard.countBlack() {\n                    winner = clonedBoard\n                }\n            }\n\n            clonedBoard = self.clone()\n            if clonedBoard.capture(x, y: y, direction: .SOUTHWEST) {\n                clonedBoard = clonedBoard.bestMovementSinglePieceWhite(x-2, y: y+2)\n                if winner.countBlack() > clonedBoard.countBlack() {\n                    winner = clonedBoard\n                }\n            }\n\n            clonedBoard = self.clone()\n            if clonedBoard.capture(x, y: y, direction: .SOUTHEAST) {\n                clonedBoard = clonedBoard.bestMovementSinglePieceWhite(x+2, y: y+2)\n                if winner.countBlack() > clonedBoard.countBlack() {\n                    winner = clonedBoard\n                }\n            }\n            return winner\n        }\n    ```", "```swift\n    func num0(myArray:[Int]) -> Int {\n        return myArray.reduce(0, {\n      if $1 == 0 {\n        return $0 + 1\n      }else {\n        return $0\n      }})\n    }\n    ```", "```swift\n    num0([1,3,1,0,0,4,1])\n    ```", "```swift\n        @IBOutlet var label: UILabel!\n        @IBOutlet var map: MKMapView!\n    ```", "```swift\n    import CoreLocation\n    import MapKit\n    ```", "```swift\n        override func viewDidLoad() {\n            super.viewDidLoad()\n            locationManager.delegate = self\n            locationManager.desiredAccuracy = kCLLocationAccuracyBest\n            locationManager.requestWhenInUseAuthorization()\n            locationManager.startUpdatingLocation()\n        }\n    ```", "```swift\n    class ViewController: UIViewController, CLLocationManagerDelegate {\n        var locationManager = CLLocationManager()\n        var geocoder = CLGeocoder()\n    ```", "```swift\n        func locationManager(manager: CLLocationManager!,\n            didChangeAuthorizationStatus status: CLAuthorizationStatus) {\n                var locationStatus:String\n                switch status {\n                case CLAuthorizationStatus.Restricted:\n                    locationStatus = \"Access: Restricted\"\n                    break\n                case CLAuthorizationStatus.Denied:\n                    locationStatus = \"Access: Denied\"\n                    break\n                case CLAuthorizationStatus.NotDetermined:\n                    locationStatus = \"Access: NotDetermined\"\n                    break\n                default:\n                    locationStatus = \"Access: Allowed\"\n                }\n                NSLog(locationStatus)\n        }\n    ```", "```swift\n        func locationManager(manager:CLLocationManager, didUpdateLocations locations:[AnyObject]) {\n            if locations[0] is CLLocation {\n              let location:CLLocation = locations[0] as CLLocation\n              self.map.setRegion(MKCoordinateRegionMakeWithDistance(location.coordinate, 800,800), animated: true)\n\n              geocoder.reverseGeocodeLocation(location, completionHandler: { (addresses, error) -> Void in\n                      let placeMarket:CLPlacemark = addresses[0] as CLPlacemark\n                    let curraddress:String = (placeMarket.addressDictionary[\"FormattedAddressLines\"] as [String]) [0] as String\n                        self.label.text = \"You are at \\(curraddress)\"\n                })\n            }\n        }\n    ```", "```swift\n    func performAnErrorProneTask() {\n\n            var error: NSError?\n            var someString: String = \"string\"\n            var someURL: NSURL = NSURL(string: \"http://www.someurl.com\")!\n\n            let success = someString.writeToURL(someURL, atomically: true, encoding: NSUTF8StringEncoding, error: &error)\n            if !success {\n                print(\"Error writing to URL: \\(error!)\")\n            }\n\n        }\n    ```", "```swift\n    let someString: String = \"string\"\n            let someURL: NSURL = NSURL(string: \"http://www.someurl.com\")!\n\n            do {\n                let success = try someString.writeToURL(someURL, atomically: true, encoding: NSUTF8StringEncoding)\n            }\n            catch let error as NSError {\n                print(error.localizedDescription)\n            }\n    ```", "```swift\n    enum CustomError: ErrorType {\n        case Minimal\n        case Bad\n        case Explosion\n    }\n    ```", "```swift\n    func performTaskWithString(taskString: String) throws -> String {\n        // Do something that will result in a success or error.\n\n        // If a minimal error occurs, throw a minimal error\n        if (taskString.isEmpty) {\n            throw CustomError.Minimal\n        }\n\n        // If a bad error occurs, throw a bad error\n        if (taskString.containsString(\"Oops\")) {\n            throw CustomError.Bad\n        }\n\n        // If an explosixe error occurs, throw an explosion error\n        if (taskString.containsString(\"ABORT ABORT ABORT\")) {\n            throw CustomError.Explosion\n        }\n\n        return \"No errors!!\"\n    }\n    ```", "```swift\n    if #available(iOS 8.0, *) {\n         let types = UIUserNotificationType([UIUserNotificationType.Alert, UIUserNotificationType.Sound, UIUserNotificationType.Badge])\n         let settings = UIUserNotificationSettings(forTypes: types, categories: nil)\n         application.registerUserNotificationSettings(settings)\n      }\n    ```"]