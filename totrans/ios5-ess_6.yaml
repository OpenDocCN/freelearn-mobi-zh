- en: Chapter 6. Xcode Tools - Improvements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Xcode工具 - 改进
- en: Since the release of the iPhone 4 back in 2010, developers were impressed by
    the remarkable `960x640-resolution` retina screen display, and provided a way
    to stay in touch with friends and family, using the FaceTime video-calling feature.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2010年iPhone 4发布以来，开发者们对那块令人印象深刻的`960x640分辨率`视网膜屏幕显示印象深刻，并提供了使用FaceTime视频通话功能与朋友和家人保持联系的方法。
- en: The iPhone 4 camera has been updated and features front and back cameras, as
    well as a standard 5-megapixel camera with a built-in LED flash and HD video editing
    that allows you to record and edit stunning HD video. With the release of the
    iPhone 4S, this has been updated to include the ability to record HD videos at
    1080 pixels, with the added ability to directly edit your videos from within the
    iOS device.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 4的摄像头已更新，具有前置和后置摄像头，以及内置LED闪光灯的标准500万像素摄像头，以及支持录制和编辑令人惊叹的HD视频的高清视频编辑功能。随着iPhone
    4S的发布，这一功能已更新，包括录制1080像素HD视频的能力，并增加了直接在iOS设备内编辑视频的功能。
- en: Starting with Xcode 4, the **Gyroscope** feature was integrated into the Accelerometer,
    which provided developers the flexibility to program this and create some stunning
    games. With the release of iOS 5 SDK, the LLVM compiler has been updated to include
    the new **Automatic Reference Counting** (**ARC**) feature.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从Xcode 4开始，**陀螺仪**功能被整合到加速度计中，这为开发者提供了编程此功能并创建一些令人惊叹的游戏的灵活性。随着iOS 5 SDK的发布，LLVM编译器已更新，包括新的**自动引用计数**（**ARC**）功能。
- en: With the release of Xcode 4.2 and the iOS 5 SDK, Interface Builder has been
    updated to provide a better way of transitioning between your views and view controller,
    by introducing story boarding for your iOS applications, featured directly within
    the Xcode IDE.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Xcode 4.2和iOS 5 SDK的发布，Interface Builder已更新，通过引入iOS应用程序的故事板，为你的视图和视图控制器之间提供更好的过渡方式，这些故事板直接集成在Xcode
    IDE中。
- en: You will also notice that the iOS simulator has also been revamped, and now
    allows you to simulate different locations using the Core Location framework,
    all directly from within the Xcode Development Environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到iOS模拟器也得到了改进，现在可以使用Core Location框架在Xcode开发环境中直接模拟不同的位置。
- en: 'In this chapter, we will:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about the latest improvements to the LLVM Compiler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解LLVM编译器的最新改进
- en: Learn how to create storyboard files using Interface Builder
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用Interface Builder创建故事板文件
- en: Learn about the changes made to the iOS simulator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解iOS模拟器所做的更改
- en: Learn about the improvements made to OpenGL ES
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解OpenGL ES的改进
- en: Understand the application data management and UI automation enhancements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解应用程序数据管理和UI自动化增强
- en: Let's get started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: LLVM compiler
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM编译器
- en: This technology is an open source compiler technology, which is currently being
    led by Apple's compiler team to be used in several high-end performance projects
    around the globe. The LLVM 2.0 compiler has also been substantially updated, and
    now compiles twice as fast as the GCC compiler, producing applications that load
    faster on the iOS device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术是一种开源编译器技术，目前由苹果的编译器团队领导，用于全球多个高端性能项目。LLVM 2.0编译器也得到了大幅更新，现在编译速度是GCC编译器的两倍，产生的应用程序在iOS设备上加载速度更快。
- en: 'It has been rewritten as a set of optimized code libraries, which have been
    designed around today''s modern chip architectures. It has been fully integrated
    into the Xcode 4 development IDE, and provides complete support for the following
    languages: C, Objective-C, and C++.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它已被重写为一组优化后的代码库，这些代码库是围绕当今的现代芯片架构设计的。它已完全集成到Xcode 4开发IDE中，并提供了对以下语言的完整支持：C、Objective-C和C++。
- en: In the next section, we will talk about the Automatic Reference Counting feature
    that has been added as part of the LLVM compiler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论作为LLVM编译器一部分添加的自动引用计数功能。
- en: Automatic Reference Counting (ARC)
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动引用计数（ARC）
- en: '**Automatic Reference Counting** (**ARC**) for Objective-C makes memory management
    the job of the compiler. When you enable ARC using the new Apple LLVM 3.0 compiler,
    this will largely remove the burden of manually releasing memory, and avoid the
    endless chore of tracking down program bugs caused by memory leaks or objects
    that have been released too early.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动引用计数**（**ARC**）使内存管理成为编译器的职责。当你使用新的Apple LLVM 3.0编译器启用ARC时，这将很大程度上减轻手动释放内存的负担，并避免因内存泄漏或过早释放的对象而导致的程序错误的无限循环。'
- en: The ARC compiler has a complete understanding of your objects, and releases
    each object the instant it is no longer used, so applications run as fast as ever,
    with predictable, smooth performances. In a majority of situations, you will never
    need to type retain or release again, and this will dramatically simplify the
    development process, while reducing crashes and memory leaks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ARC编译器完全理解你的对象，并在对象不再使用时立即释放它们，因此应用程序运行速度与以前一样快，具有可预测的、平稳的性能。在大多数情况下，你将不再需要键入retain或release，这将极大地简化开发过程，同时减少崩溃和内存泄漏。
- en: 'Xcode comes with a new **Convert to Objective-C ARC..**. tool, that is located
    within the **Edit | Refactor** menu within the IDE, as shown in the following
    screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode附带了一个新的**转换为Objective-C ARC**工具，该工具位于IDE中的**编辑 | 重构**菜单内，如下截图所示：
- en: '![Automatic Reference Counting (ARC)](img/2267_06_00.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![自动引用计数（ARC）](img/2267_06_00.jpg)'
- en: This tool automates the mechanical parts of the ARC conversion, by removing
    method calls such as `retain` and `release`, and helps you to fix issues the migrator
    can't handle automatically. The ARC migration tool converts all files within a
    project to use ARC; you also have the added option of choosing to use ARC on a
    per-file basis to overcome some of ARC's current restrictions, and use manual
    reference counting for some files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具通过删除`retain`和`release`等方法调用来自动化ARC转换的机械部分，并帮助你修复迁移器无法自动处理的错误。ARC迁移工具将项目中的所有文件转换为使用ARC；你还可以选择按文件使用ARC，以克服ARC的一些当前限制，并对某些文件使用手动引用计数。
- en: The following screenshot implies that writing operative code takes almost as
    long to write as retain/release logic. This will not be true for experienced Objective-C
    developers, but if you are a new and just starting out with Objective-C, this
    is probably a conservative estimate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图表明，编写操作代码所需的时间几乎与retain/release逻辑一样长。对于经验丰富的Objective-C开发者来说，这并不准确，但如果你是新手，刚开始接触Objective-C，这可能是保守的估计。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on Objective-C, please refer to the *Apple Developer Documentation*
    at the following location: [http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Objective-C的更多信息，请参考以下位置的*Apple开发者文档*：[http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163).
- en: You will still need to take some responsibility for how your classes manage
    reference to other objects, rather than relying totally on ARC.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要为你的类如何管理对其他对象的引用承担一些责任，而不是完全依赖ARC。
- en: '![Automatic Reference Counting (ARC)](img/2267_06_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![自动引用计数（ARC）](img/2267_06_01.jpg)'
- en: ARC provides automatic memory management for your objects, without you having
    to remember when to use retain, release, and auto-release. ARC starts by evaluating
    your objects, and automatically inserts the appropriate method calls for you at
    compile time, as well as generating the appropriate `dealloc` method calls for
    you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ARC为你的对象提供自动内存管理，无需你记住何时使用retain、release和auto-release。ARC首先评估你的对象，并在编译时自动为你插入适当的方法调用，同时为你生成适当的`dealloc`方法调用。
- en: 'For example, let''s take a look at an example that shows the older way of doing
    things prior to the use of ARC, as shown in the following code snippet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看在ARC使用之前的老方法的一个示例，如下代码片段所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In between allocating and initializing an object, and then finally releasing
    the object, you can do with it as you wish, and the object will only be released
    and de-allocated when it is not in use.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配和初始化对象之间，以及最终释放对象之前，你可以随意使用它，对象只有在不再使用时才会被释放和解除分配。
- en: Similarly, by adding the object to an auto-release pool, it will stick around
    until it is needed, and will be de-allocated sometime when it is no longer needed.
    This is shown in the following code snippet of how this would have been doing
    prior to ARC.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过将对象添加到自动释放池中，它将一直存在，直到需要它，并在不再需要时被释放。以下代码片段显示了在ARC之前如何进行这一操作。
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are new to iOS programming, you may have trouble getting your head around
    the use of reference counted memory at first, but once you get the hang of it,
    you'll soon see its potential. This is particularly useful when developing applications
    for iOS devices, as it can remove the burden of tracking bugs caused by leaking
    or over-released objects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始学习 iOS 编程，你可能会在最初难以理解引用计数内存的使用，但一旦你掌握了它，你很快就会看到它的潜力。这在为 iOS 设备开发应用程序时尤其有用，因为它可以消除由泄漏或过度释放对象引起的错误追踪负担。
- en: Many developers forget to release the allocation of memory to previously declared
    objects, resulting in sluggish performance issues, or more severe, causing their
    application to hang or crash.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者忘记释放先前声明的对象的内存分配，这会导致性能问题，或者更严重的是，导致他们的应用程序挂起或崩溃。
- en: Under ARC, this gets handled differently, and a pre-compilation step takes place,
    which adds retain, release, and auto-release statements into the code for you.
    This is by no means a form of garbage collection, and the referenced counted memory
    has not disappeared, it has simply been automated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ARC 下，这会有不同的处理方式，并且会进行预编译步骤，这会自动将保留、释放和自动释放语句添加到代码中。这绝对不是垃圾回收的一种形式，引用计数的内存并没有消失，它只是被自动化了。
- en: 'Take a look at the following ARC-enabled code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下启用 ARC 的代码片段：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The ARC pre-compilation step will automatically turn this into:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ARC 预编译步骤会自动将其转换为：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In order for the compiler to generate the correct code, ARC imposes some strict
    restrictions on the methods that you can use, as well as introducing new lifetime
    qualifiers for object references and declared properties.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译器生成正确的代码，ARC 对你可以使用的方法施加了一些严格的限制，并引入了新的生命周期限定符用于对象引用和声明属性。
- en: These new rules are not present when using the other compiler modes, and are
    intended to provide a fully reliable memory management model. They have been set
    up, in some cases, to enforce best practice. In other cases, they simplify your
    code so that you don't have to deal with memory management issues.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新规则在其他编译器模式下并不存在，旨在提供一个完全可靠的内存管理模型。在某些情况下，它们被设置为强制最佳实践。在其他情况下，它们简化了你的代码，这样你就不必处理内存管理问题。
- en: 'Violation of these rules will result in an immediate compile-time error, not
    some program bug that can become apparent at runtime. The following table explains
    the rules you need to abide by, in order to compile with ARC:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 违反这些规则将导致立即的编译时错误，而不仅仅是程序运行时可能出现的某些程序错误。以下表格解释了你需要遵守的规则，以便使用 ARC 进行编译：
- en: '| **ARC rule** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **ARC 规则** | **描述** |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alloc/Init objects | When creating objects, you must not make any calls to
    retain, release, auto-release, and retain `Count` methods, or indirectly call
    their selectors, that is, `@selector(retain)` and `@selector(release).` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 分配/初始化对象 | 在创建对象时，你不能调用保留、释放、自动释放和保留 `Count` 方法，或者间接调用它们的选择器，即 `@selector(retain)`
    和 `@selector(release)`。 |'
- en: '| Dealloc methods | Generally these will be created for you, but you must not
    make a `dealloc` call directly. However, you can still create a custom `dealloc`
    method, if you need to release resources other than the instance variables. When
    creating a custom `dealloc` method, do not call the `[super dealloc]` method,
    as this will be done for you, and is enforced by the compiler. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 释放方法 | 通常这些方法会为你创建，但你不能直接调用 `dealloc`。然而，如果你需要释放除了实例变量之外的其他资源，你仍然可以创建一个自定义的
    `dealloc` 方法。在创建自定义 `dealloc` 方法时，不要调用 `[super dealloc]` 方法，因为这将为你完成，并且由编译器强制执行。
    |'
- en: '| Declared properties | Before ARC, we told the compiler how to memory-manage
    declared `public` properties using the `assign, retain`, and `copy` parameters
    using the `@property` directive.These parameters are no longer used in ARC. Instead,
    we have two new parameters, `weak`, and `strong`, that tell the compiler how we
    want our properties treated. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 声明属性 | 在 ARC 之前，我们通过使用 `@property` 指令的 `assign, retain` 和 `copy` 参数来告诉编译器如何使用这些参数来管理声明的
    `public` 属性的内存。在 ARC 中，这些参数不再使用。相反，我们有两个新的参数，`weak` 和 `strong`，它们告诉编译器我们希望如何处理我们的属性。
    |'
- en: '| Object pointers in C structures | The Apple documentation suggests storing
    them in a class instead of a struct. This makes sense, since they would otherwise
    be unknown to ARC. It might cause some extra migration headaches. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| C结构中的对象指针 | Apple 文档建议将它们存储在类中而不是结构体中。这很有道理，因为否则它们将不为 ARC 所知。这可能会引起一些额外的迁移问题。
    |'
- en: '| Casual casting between `id` and `void*` | Casting between `id` and `void*`
    data types is frequently done when handing objects between Core Foundation''s
    C library functions and Foundation Kit''s Objective-C library methods. This is
    known as **Toll Free Bridging**. With ARC, you must provide hints/qualifiers to
    tell the compiler when CF objects are moving in and out of its control for memory
    management.These qualifiers include `__bridge, __bridge_retain`, and `__bridge_transfer`.
    You still need to call `CFRetain` and `CFRelease` to memory manage Core Foundation
    objects. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `id`和`void*`之间的随意转换 | 当在Core Foundation的C库函数和Foundation Kit的Objective-C库方法之间传递对象时，经常会在`id`和`void*`数据类型之间进行转换。这被称为**Toll
    Free Bridging**。在ARC中，你必须提供提示/限定符来告诉编译器CF对象何时进入和退出其控制范围以进行内存管理。这些限定符包括`__bridge,
    __bridge_retain`, 和 `__bridge_transfer`。你仍然需要调用`CFRetain`和`CFRelease`来管理Core Foundation对象的内存。
    |'
- en: '| `@autoreleasepool` instead of `NSAutoReleasePool` | If you use ARC compliant
    code within your applications, it must not use `NSAutoReleasePool` objects, instead
    it must use the `@autoreleasepool{}` blocks.A good example of this can be found
    within the `main.m` file of any ARC project.int main(int argc, char *argv[]){@autoreleasepool
    {return UIApplicationMain(argc, argv, nil, NSStringFromClass([MyAppDelegate class]));}}
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `@autoreleasepool`代替`NSAutoReleasePool` | 如果你在应用程序中使用ARC兼容的代码，它不能使用`NSAutoReleasePool`对象，而必须使用`@autoreleasepool{}`代码块。一个很好的例子可以在任何ARC项目的`main.m`文件中找到.int
    main(int argc, char *argv[]){@autoreleasepool {return UIApplicationMain(argc,
    argv, nil, NSStringFromClass([MyAppDelegate class]));}} |'
- en: '| Memory zones | You cannot use `NSZone` zone-based memory (This is not part
    of the runtime anymore); you cannot use `NSAllocateObject` or `NSDeallocateObject`.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 内存区域 | 你不能使用基于`NSZone`的内存区域（这不再是运行时的一部分）；你不能使用`NSAllocateObject`或`NSDeallocateObject`。
    |'
- en: As programmers, we find ourselves making decisions like whether to make something
    a variable or a constant, or whether or not it needs to be defined locally or
    globally. This same concept applies when we decide how our properties relate to
    other objects. To do this, we use the strong and/or weak qualifiers to notify
    the compiler of these relationships.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们发现自己需要做出决定，比如是否将某个东西定义为变量或常量，或者是否需要在局部或全局范围内定义。当我们决定我们的属性如何与其他对象相关联时，这个概念同样适用。为了做到这一点，我们使用强和/或弱限定符来通知编译器这些关系。
- en: Strong references
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强引用
- en: 'These provide a reference to an object that stops it from being de-allocated.
    In other words, it creates an owner relationship. Prior to ARC, you would have
    declared your properties as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提供了对对象的引用，阻止它被释放。换句话说，它创建了一个所有者关系。在ARC之前，你会这样声明你的属性：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we take a look at how this same property would be declared under ARC, this
    would be done as follows, to ensure that a class instance takes ownership of a
    referenced object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看在ARC下如何声明相同的属性，这将按照以下方式完成，以确保类实例拥有被引用的对象：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Consider the following code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have declared two objects and have allocated the memory to
    our `obj1` object variable. We then declare a new object variable `obj2`, which
    has a strong reference to `obj1`. If we remove `obj2` from memory, then `obj1`
    also gets removed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们声明了两个对象，并将内存分配给了我们的`obj1`对象变量。然后我们声明一个新的对象变量`obj2`，它对`obj1`有一个强引用。如果我们从内存中移除`obj2`，那么`obj1`也会被移除。
- en: Weak references
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弱引用
- en: 'These provide a reference to an object that does not stop it from being de-allocated.
    In other words, it does not create an owner relationship. Previously you would
    have done this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提供了对对象的引用，但不会阻止它被释放。换句话说，它不会创建所有者关系。在ARC之前，你会这样做：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we take a look at how this same property would be declared under ARC. This
    would be done as follows to ensure that you do not have ownership of the object
    that is being referenced.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看在ARC下如何声明相同的属性。这将按照以下方式完成，以确保你不拥有被引用的对象。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Consider the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We start by declaring a variable called `weakName`, which points at the same
    string object that the `textField.text` property points to - this contains the
    name `Albert Einstein`. If the string contents change, then the string object
    no longer has any owners and is de-allocated. This is shown below in the following
    piece of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个名为`weakName`的变量，它指向与`textField.text`属性指向的相同字符串对象——这包含名字`Albert Einstein`。如果字符串内容发生变化，那么字符串对象就不再有任何所有者，并且会被释放。这在下面的代码片段中显示：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When this happens, the value of `weakName` automatically becomes `nil`, and
    is what is called a zeroing weak pointer. This is extremely convenient, because
    it prevents weak pointers from pointing to de-allocated memory. Previously, this
    sort of thing used to cause a lot of programming bugs; for example, the term dangling
    pointers or zombies.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，`weakName` 的值会自动变为 `nil`，这被称为零引用弱指针。这非常方便，因为它防止了弱指针指向已释放的内存。以前，这类事情经常导致许多编程错误；例如，悬垂指针或僵尸。
- en: '**Weak pointers** are mostly useful when two objects have a parent-child relationship.
    The parent will have a strong pointer to the child and therefore owns the child,
    but in order to prevent ownership cycles, the child only has a weak pointer back
    to the parent. Consider the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**弱指针**主要用于两个对象具有父子关系时。父对象将拥有对子对象的强指针并因此拥有子对象，但为了防止所有权循环，子对象只对父对象有弱指针。考虑以下代码片段：'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since there is no owner for the string object (because `str` is weak), the
    object will be de-allocated immediately after it is created. Xcode will give a
    warning when you try to do this, because it''s probably not what you intended
    to do (Warning: *assigning retained object to weak variable; object will be released
    after assignment)*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串对象没有所有者（因为 `str` 是弱引用），对象将在创建后立即被释放。当你尝试这样做时，Xcode 会给出警告，因为这可能不是你想要做的（警告：*将保留对象赋值给弱变量；对象将在赋值后释放]*)。
- en: ARC qualifiers regular variables
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ARC 限定符常规变量
- en: ARC introduces several new lifetime qualifiers for objects, and zeroing weak
    references. A weak reference does not extend the lifetime of the object that it
    points to. A zeroing weak reference, also known as a weak qualifier, instructs
    the compiler that you do not need to retain the object. If all the references
    to this object go down to zero, then the object is released and set to `nil`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ARC 为对象引入了几个新的生命周期限定符，以及零引用弱引用。弱引用不会延长它所指向的对象的生命周期。零引用弱引用，也称为弱限定符，指示编译器你不需要保留该对象。如果指向此对象的引用都降为零，则对象将被释放并设置为
    `nil`。
- en: This is important, because a message sent to a `nil` object does not cause a
    crash; it simply doesn't do anything. However, you can still use `assign`, but
    it is recommended that you use `weak` instead, because it will set a de-allocated
    object to `nil`. A weak qualifier is especially used in a parent-child object
    relationship, where the parent has a strong reference to a child object, and the
    child object has a weak reference back to the parent, otherwise you will end up
    creating a circular reference.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为向 `nil` 对象发送的消息不会导致崩溃；它只是什么也不做。然而，你仍然可以使用 `assign`，但建议你使用 `weak`，因为它会将已释放的对象设置为
    `nil`。弱限定符特别用于父子对象关系，其中父对象对子对象有强引用，而子对象对父对象有弱引用，否则你将最终创建一个循环引用。
- en: Variable qualifiers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量限定符
- en: 'In the previous code snippets, we illustrated how our declared properties should
    be managed. For regular variables we have:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们说明了如何管理我们声明的属性。对于常规变量，我们有：
- en: '`__strong`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__strong`'
- en: '`__weak`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__weak`'
- en: '`__unsafe_unretained`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__unsafe_unretained`'
- en: '`__autoreleasing`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__autoreleasing`'
- en: Generally speaking, these extra qualifiers need not be used very often. You
    might first encounter these qualifiers, and others, when using the migration tool.
    For new projects, however, you won't need them and will mostly use `strong/weak`
    with your declared properties.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，这些额外的限定符不需要经常使用。你可能会首先在使用迁移工具时遇到这些限定符和其他限定符。然而，对于新项目，你通常不需要它们，并且主要使用 `strong/weak`
    与你声明的属性一起使用。
- en: '| **ARC types** | **Description** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **ARC 类型** | **描述** |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__strong` | This is the default, so you don''t need to type it. This means
    any object created using `alloc/init` is retained for the lifetime of its current
    scope. The **current scope** usually means the braces in which the variable is
    declared (that is, a method, `for` loop, `if` block, and so on). |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `__strong` | 这是默认值，因此你不需要输入它。这意味着使用 `alloc/init` 创建的任何对象都会保留在其当前作用域的生命周期内。**当前作用域**通常是指变量声明的花括号内（即方法、`for`
    循环、`if` 块等）。 |'
- en: '| `__weak` | This means the object can be destroyed at any time. This is only
    useful if the object is somehow strongly referenced somewhere else. When destroyed,
    a variable with `__weak` is set to `nil.` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `__weak` | 这意味着对象可以在任何时候被销毁。这仅在对象在其他地方有强烈的引用时才有用。当对象被销毁时，带有 `__weak` 的变量会被设置为
    `nil`。 |'
- en: '| `__unsafe_unretained` | This is similar to the `__weak` type, but the pointer
    is not set to `nil` when the object is de-allocated. Instead the pointer is left
    pointing to an unsafe area of memory. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `__unsafe_unretained` | 这与 `__weak` 类型相似，但对象被释放时指针不会被设置为 `nil`。相反，指针被留在指向内存中不安全区域的指针上。|'
- en: '| `__autoreleasing` | This is not to be confused with calling `autorelease`
    on an object, before returning it from a method. This is used for passing objects
    by reference, for example, when passing `NSError` objects by reference such as
    `[myObject performOperationWithError:&tmp]`; |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `__autoreleasing` | 这不是在从方法返回对象之前调用 `autorelease`，而是用于通过引用传递对象，例如，在通过引用传递
    `NSError` 对象时，如 `[myObject performOperationWithError:&tmp]`；|'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the *LLVM Clang Objective-C Automatic Reference Counting*
    documentation, you can refer to the following link provided: [http://clang.llvm.org/docs/AutomaticReferenceCounting.html#ownership](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#ownership).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 *LLVM Clang Objective-C 自动引用计数* 文档的更多信息，您可以参考以下提供的链接：[http://clang.llvm.org/docs/AutomaticReferenceCounting.html#ownership](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#ownership)。
- en: Interface builder
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Interface builder
- en: In Xcode 4, the Interface Builder is a user interface design tool where you
    can build your user interface, by dragging and dropping objects from the Object
    Library onto a blank canvas. The resulting user interface would then be saved
    as an XIB file, which is an XML representation of your objects and their instance
    variables.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 4 中，Interface Builder 是一个用户界面设计工具，您可以通过从对象库中将对象拖放到空白画布上来构建用户界面。生成的用户界面将保存为
    XIB 文件，它是您对象及其实例变量的 XML 表示。
- en: In the past, when creating a new view, you would have to create an XIB file
    for each view that your application required, to transition from each view to
    the next. In order to make designing your iOS applications much easier, Apple
    improved the user interface design process and introduced the **Storyboarding**
    feature.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当创建一个新视图时，您必须为应用程序所需的每个视图创建一个 XIB 文件，以便从每个视图转换到下一个视图。为了使设计 iOS 应用程序变得更加容易，苹果改进了用户界面设计过程，并引入了
    **Storyboarding** 功能。
- en: Support for creating storyboard files for iOS applications
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持为 iOS 应用程序创建 storyboard 文件
- en: With the release of Xcode 4.2, Interface builder has been updated to provide
    a better way to design your user interfaces, by graphically arranging all of your
    views within a single canvas so that you can define your applications, logical
    flow as well as assign transitions between them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Xcode 4.2 的发布，Interface Builder 已更新，提供了一种更好的方式来设计用户界面，通过在单个画布中图形化地排列所有视图，以便您可以定义应用程序，逻辑流程以及它们之间的转换。
- en: Using storyboards within your applications, eases the development process by
    managing the view controllers for you. You can specify the transitions and segues
    that are used when switching between views, without having to code them by hand.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用 storyboards 可以通过为您管理视图控制器来简化开发过程。您可以在不手动编码的情况下指定在视图之间切换时使用的转换和 segues。
- en: To refresh your memory, you can refer to [Chapter 4](ch04.html "Chapter 4. Using
    Storyboards"), *Using Storyboards*, under the section *How to go about creating
    Storyboard files*, for more information on how to go about creating storyboard
    files using the Interface Builder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新您的记忆，您可以参考在 *如何创建 Storyboard 文件* 部分下的 [第 4 章](ch04.html "第 4 章。使用 Storyboards")，*使用
    Storyboards*，以获取有关如何使用 Interface Builder 创建 storyboard 文件的信息。
- en: Location simulator
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置模拟器
- en: Starting with the release of Xcode 4.2 and iOS 5, you now have the ability to
    test your location-based features in your application without leaving your desk.
    You can now select from preset locations and routes within the iOS simulator,
    and pick a custom latitude and longitude with accuracy, while you're running your
    simulated application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Xcode 4.2 和 iOS 5 的发布开始，您现在可以在不离开办公桌的情况下测试应用程序中的基于位置的功能。您现在可以在 iOS 模拟器中选择预设的位置和路线，并在运行模拟应用程序的同时选择具有精度的自定义纬度和经度。
- en: Creating a simple geographical application
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的地理应用程序
- en: Before we can proceed, we first need to create our `MapKitExample` project.
    To refresh your memory, you can refer to the section named *Creating the MyEmailApp
    application*, in [Chapter 1](ch01.html "Chapter 1. What's New in iOS5"),*What's
    new in iOS5.*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们首先需要创建我们的 `MapKitExample` 项目。为了刷新您的记忆，您可以参考 [第 1 章](ch01.html "第 1
    章。iOS5 中的新功能") 中名为 *创建 MyEmailApp 应用程序* 的部分，*iOS5 中的新功能*。
- en: Launch Xcode from the `/Xcode4/Applications` folder.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/Xcode4/Applications`文件夹启动Xcode。
- en: Choose **Create a new Xcode project**, or **File | New Project**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建一个新的Xcode项目**，或**文件 | 新建项目**。
- en: Select the **Single View Application** template from the list of available templates.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用模板列表中选择**Single View Application**模板。
- en: Select **iPhone** from under the **Device Family** drop-down.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**设备家族**下拉菜单中选择**iPhone**。
- en: Ensure that you have checked the box for **Use Automatic Reference Counting**
    from under the **iPhone Device Family** drop-down.![Creating a simple geographical
    application](img/2267_06_02.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已从**iPhone设备家族**下拉菜单中勾选了**使用自动引用计数**选项。![创建一个简单的地理应用程序](img/2267_06_02.jpg)
- en: Click on the **Next** button to proceed to the next step in the wizard.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**按钮继续向导的下一步。
- en: Enter in `MapKitExample`, and then click on the **Next** button to proceed to
    the next step of the wizard.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`MapKitExample`，然后点击**下一步**按钮继续向导的下一步。
- en: Specify the location where you would like to save your project.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定你想要保存项目的位置。
- en: Click on the **Save** button to continue and display the Xcode workspace environment.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮继续，并显示Xcode工作区环境。
- en: 'Now that we have created our `MapKitExample` project, we need to add the `MapKit`
    framework to our project, in order for our application to view map information.
    Select the **Project Navigator Group**, and then follow these simple steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`MapKitExample`项目，我们需要将`MapKit`框架添加到我们的项目中，以便我们的应用程序可以查看地图信息。选择**项目导航器组**，然后按照以下简单步骤操作：
- en: Select your project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的项目。
- en: Then select your project target from under the `TARGETS` group.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从`TARGETS`组下选择你的项目目标。
- en: Select the **Build Phases** tab.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**构建阶段**选项卡。
- en: Expand the **Link Library with Libraries** disclosure triangle.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开链接库与库的展开三角形。
- en: Use the **+** to add the library that you want. You can also search, if you
    can't find the framework you are after, from within the list.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+**添加你想要的库。如果你在列表中找不到你想要的框架，也可以进行搜索。
- en: 'If you are still confused as to how to go about adding the frameworks, follow
    this screenshot, which highlights the areas that you need to select (surrounded
    by a red rectangle):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不清楚如何添加框架，请参考以下截图，它突出显示了你需要选择的部分（被红色矩形包围）：
- en: '![Creating a simple geographical application](img/2267_06_03.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的地理应用程序](img/2267_06_03.jpg)'
- en: Now that you have added the `MapKit.framework` into your project, we need to
    import the code into the `ViewController` that will be responsible for displaying
    our map location information.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将`MapKit.framework`添加到你的项目中，我们需要将代码导入到负责显示我们的地图位置信息的`ViewController`中。
- en: 'In order to make our application display the map to our view, we will need
    to import the`<MapKit/MapKit.h>` interface header file, so that we can utilize
    its methods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序在我们的视图中显示地图，我们需要导入`<MapKit/MapKit.h>`接口头文件，以便我们可以利用其方法：
- en: 'Open the `ViewController.h` interface file located within the **Classes** folder,
    and add the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于**Classes**文件夹中的`ViewController.h`接口文件，并添加以下代码：
- en: '[PRE12]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code snippet, we have included a reference to the Cocoa `MapKit.h` header
    file, which will expose its methods, so that we can use these within our `ViewController`
    implementation file, and then we have created an instance variable (`mapView`),
    which is a string pointer to our `MKMapView` object, which is responsible for
    holding our map location information.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们包含了对Cocoa的`MapKit.h`头文件的引用，这将暴露其方法，以便我们可以在`ViewController`实现文件中使用这些方法，然后我们创建了一个实例变量（`mapView`），它是一个指向我们的`MKMapView`对象的字符串指针，该对象负责存储我们的地图位置信息。
- en: We haven't quite finished yet. We now need to modify our `ViewDidLoad` method,
    located within our `ViewController.m` implementation file. So, open the `ViewController.m`
    implementation file.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还没有完全完成。现在我们需要修改位于`ViewController.m`实现文件中的`ViewDidLoad`方法。因此，打开`ViewController.m`实现文件。
- en: 'Locate and uncomment the `ViewDidLoad` method, and add the following code snippet
    to it:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并取消注释`ViewDidLoad`方法，并向其中添加以下代码片段：
- en: '[PRE13]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code snippet, what we have actually done is allocated and initialized
    memory for our `mapView` object that we declared within our `ViewController.h`
    file, and then we added our `mapView` object to our current view, so that we can
    display this to the screen.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们实际上为在`ViewController.h`文件中声明的`mapView`对象分配和初始化了内存，然后我们将`mapView`对象添加到当前视图中，以便我们可以在屏幕上显示它。
- en: The `mapKit` framework has the ability to show you your current location within
    the map. It also allows you to set a variety of `mapTypes`. Next, we will be adding
    some additional code to our `ViewDidLoad` method as highlighted in the following
    code snippet. This is located within our `ViewController.m` implementation file.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mapKit` 框架具有在地图上显示您当前位置的能力。它还允许您设置各种 `mapTypes`。接下来，我们将在 `ViewDidLoad` 方法中添加一些额外的代码，如下面的代码片段所示。此代码位于我们的
    `ViewController.m` 实现文件中。'
- en: '[PRE14]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code snippet, what we have done is added the ability to display our
    map in **Hybrid** view (combination of satellite view and road information) as
    well as directed our map to display our current location that will be indicated
    by an animated blue marker.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们所做的是增加了显示我们的地图在 **混合** 视图（卫星视图和道路信息的组合）中的能力，同时将我们的地图指向显示我们的当前位置，该位置将由一个动画蓝色标记指示。
- en: 'The iOS native maps application allows you to choose from the following three
    possible map types:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 原生地图应用程序允许您从以下三种可能的地图类型中选择：
- en: '| **Map type constant** | **Description** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **地图类型常量** | **描述** |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MKMapTypeStandard` | This is the default type of map to display, if none
    is specified, and this type will show a normal map containing street and road
    names. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `MKMapTypeStandard` | 这是默认的地图类型，如果没有指定，此类型将显示包含街道和道路名称的正常地图。 |'
- en: '| `MKMapTypeSatellite` | Setting this type of map will display satellite view
    information. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `MKMapTypeSatellite` | 设置此类型的地图将显示卫星视图信息。 |'
- en: '| `MKMapTypeHybrid` | This type of map will show a combination of a satellite
    view with road and street information overlaid. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `MKMapTypeHybrid` | 此类型的地图将显示卫星视图与道路和街道信息叠加的组合。 |'
- en: 'If you build and run your application, you should now see a map displayed with
    the animated blue marker flashing. I have rotated the device and zoomed in at
    a random location to show the capabilities of the `MapKit` framework, as is shown
    in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您构建并运行了您的应用程序，现在应该会看到一个带有闪烁的动画蓝色标记的地图显示。我已经旋转了设备并在一个随机位置进行了缩放，以展示 `MapKit`
    框架的功能，如下面的截图所示：
- en: '![Creating a simple geographical application](img/2267_06_04.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的地理应用程序](img/2267_06_04.jpg)'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When running `MapKit` applications using the iOS Simulator, it will always default
    to Apple's headquarters located at 1, Infinite Loop, based out at California.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 iOS 模拟器运行 `MapKit` 应用程序时，它将始终默认显示位于加利福尼亚州 1 Infinite Loop 的苹果公司总部。
- en: In order to get a better location, it is much better to use your iOS device.
    This is because the iOS simulator uses your IP address to work out an approximate
    location of where you are located.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的位置，使用您的 iOS 设备会更好。这是因为 iOS 模拟器使用您的 IP 地址来估算您的位置。
- en: 'You can also choose to navigate to a different location while the iOS simulator
    is running. To do this, follow these simple steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择在 iOS 模拟器运行时导航到不同的位置。为此，请按照以下简单步骤操作：
- en: Click on **Simulate Location** icon as shown in the following screenshot. This
    will display a list of available locations:![Creating a simple geographical application](img/2267_06_05.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如下所示的 **模拟位置** 图标。这将显示可用位置列表：![创建一个简单的地理应用程序](img/2267_06_05.jpg)
- en: Select **Tokyo, Japan**, or a similar option from the list of displayed locations.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从显示的位置列表中选择 **东京，日本** 或类似选项。
- en: 'The iOS simulator will be updated to reflect the chosen location, as shown
    in the following screenshot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: iOS 模拟器将更新以反映所选位置，如下面的截图所示：
- en: '![Creating a simple geographical application](img/2267_06_06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的地理应用程序](img/2267_06_06.jpg)'
- en: In this section, we learned about the `MapKit` framework, and how we can use
    this within our application to simulate to a particular location. We learned how
    to use the **Simulate Location** feature of the Xcode debugger, to navigate to
    various locations within the iOS simulator.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了 `MapKit` 框架，以及我们如何在应用程序中使用它来模拟特定位置。我们学习了如何使用 Xcode 调试器的 **模拟位置**
    功能，在 iOS 模拟器中导航到各种位置。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the `MKMapView` class reference, please refer to the
    *Apple Developer Documentation* at the following link location provided: [http://developer.apple.com/library/ios/#documentation/MapKit/Reference/MKMapView_Class/MKMapView/MKMapView.html#//apple_ref/doc/uid/TP40008205](http://developer.apple.com/library/ios/#documentation/MapKit/Reference/MKMapView_Class/MKMapView/MKMapView.html#//apple_ref/doc/uid/TP40008205).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`MKMapView`类参考的更多信息，请参阅以下链接位置提供的*Apple开发者文档*：[http://developer.apple.com/library/ios/#documentation/MapKit/Reference/MKMapView_Class/MKMapView/MKMapView.html#//apple_ref/doc/uid/TP40008205](http://developer.apple.com/library/ios/#documentation/MapKit/Reference/MKMapView_Class/MKMapView/MKMapView.html#//apple_ref/doc/uid/TP40008205)。
- en: OpenGL ES debugging
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenGL ES调试
- en: The OpenGL ES debugger allows you to track down issues specific to OpenGL ES
    within your application. You can then choose to have this break at a certain point
    within your program. To refresh your memory, you can refer to the section named
    *Detecting errors by setting up breakpoints*, that we covered in [Chapter 3](ch03.html
    "Chapter 3. Debugging with OpenGL ES"), *Debugging with OpenGL ES*, for more information
    on how to go about debugging OpenGL ES projects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES调试器允许你追踪应用程序中特定于OpenGL ES的问题。然后你可以选择在程序中的某个特定点中断。为了刷新你的记忆，你可以参考我们在[第3章](ch03.html
    "第3章。使用OpenGL ES进行调试")，*使用OpenGL ES进行调试*中提到的名为*通过设置断点检测错误*的部分，以获取有关如何调试OpenGL
    ES项目的更多信息。
- en: OpenGL ES frame capture
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenGL ES帧捕获
- en: The OpenGL ES frame capture is part of the Xcode debugger, and allows you to
    take a snapshot of all of the frames that are being drawn within your application
    at the point it was captured. You can then choose to navigate through each of
    the frames and see the associated code, as well as changing between solid or wireframe
    view. To refresh your memory, you can refer to the section named *Breaking on
    frame boundaries*, in [Chapter 3](ch03.html "Chapter 3. Debugging with OpenGL
    ES"), *Debugging with OpenGL ES*, for more information on how to go about capturing
    OpenGL ES frames.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES帧捕获是Xcode调试器的一部分，允许你在捕获点捕捉到应用程序中正在绘制的所有帧的快照。然后你可以选择浏览每个帧，查看相关的代码，以及在不同之间的实体或线框视图之间切换。为了刷新你的记忆，你可以参考名为*在帧边界处中断*的部分，在[第3章](ch03.html
    "第3章。使用OpenGL ES进行调试")，*使用OpenGL ES进行调试*，以获取有关如何捕获OpenGL ES帧的更多信息。
- en: Application data management
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用数据管理
- en: iOS provides powerful connectivity options for sharing your information amongst
    the applications that are installed on an iOS device. Using a URL-based syntax,
    you can have your applications access data from the Web, as well as passing this
    information onto other applications that are installed, such as mail, iTunes,
    and YouTube.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: iOS为在iOS设备上安装的应用程序之间共享信息提供了强大的连接选项。使用基于URL的语法，你可以让你的应用程序访问来自Web的数据，以及将此信息传递给其他已安装的应用程序，如邮件、iTunes和YouTube。
- en: Your own applications can declare a unique URL scheme, allowing any application
    to collaborate and share data with your application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序可以声明一个独特的URL方案，允许任何应用程序与你的应用程序协作并共享数据。
- en: You can also choose to make use of XML files; these provide a lightweight structured
    format that your application can easily read and write. XML files readily fit
    into the iOS file system, and can be used to store your application settings and
    user preferences in the built-in **User Defaults** database. This XML-based data
    store includes a simple API with powerful features, including the ability to serialize
    and restore complex objects on demand.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择使用XML文件；这些文件提供了一种轻量级结构化格式，你的应用程序可以轻松地读取和写入。XML文件可以很好地适应iOS文件系统，并可用于在内置的**用户默认值**数据库中存储你的应用程序设置和用户偏好设置。这个基于XML的数据存储包括一个简单的API，具有强大的功能，包括按需序列化和恢复复杂对象的能力。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the application data management feature, please refer
    to the following *Apple Developer Documentation* at the following location: [DOCUMENTATION/DataManagement/Conceptual/iPhoneCoreData01/Articles/01_StartingOut.html#//apple_ref/doc/uid/TP40008305-CH105-SW2](http://DOCUMENTATION/DataManagement/Conceptual/iPhoneCoreData01/Articles/01_StartingOut.html#//apple_ref/doc/uid/TP40008305-CH105-SW2).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关应用数据管理功能的更多信息，请参阅以下链接位置的*Apple开发者文档*：[DOCUMENTATION/DataManagement/Conceptual/iPhoneCoreData01/Articles/01_StartingOut.html#//apple_ref/doc/uid/TP40008305-CH105-SW2](http://DOCUMENTATION/DataManagement/Conceptual/iPhoneCoreData01/Articles/01_StartingOut.html#//apple_ref/doc/uid/TP40008305-CH105-SW2)。
- en: UI automation enhancements
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI自动化增强
- en: The **Automation** instrument was added to the release of the iOS SDK 4.0\.
    This tool allows you to automate user interface tests of your iOS applications,
    by scripting touch events, allowing you to log these results to be used for your
    analysis, later on. The Automation instrument comes complete with a script editor,
    so that you can choose to either write your test scripts to the UI Automation
    API using JavaScript, or load this into the editor from a file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化**工具是在 iOS SDK 4.0 的版本中添加的。这个工具允许你通过脚本化触摸事件来自动化你的 iOS 应用程序的界面测试，允许你将这些结果记录下来，以便稍后用于分析。自动化工具包含一个脚本编辑器，因此你可以选择使用
    JavaScript 将测试脚本写入 UI 自动化 API，或者从文件中将其加载到编辑器中。'
- en: This is a huge leap forward for testing your applications on the iOS platform
    using test automation, which can reduce your time spent manually testing your
    applications. The Automation feature can be used to simulate many user actions
    on devices that support multitasking and, which are running iOS 4.0 or later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 iOS 平台上使用测试自动化测试你的应用程序的一个巨大的进步，这可以减少你手动测试应用程序所花费的时间。自动化功能可以用于模拟支持多任务处理且运行
    iOS 4.0 或更高版本的设备上的许多用户操作。
- en: You also have the ability to capture and record actions directly into your script
    as you perform them on an iOS device.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有能力直接在你的脚本中捕获和记录在 iOS 设备上执行的动作。
- en: 'Automating UI tests allows you to:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化 UI 测试允许你：
- en: Free critical staff and resources for other work
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其他工作释放关键人员和资源
- en: Perform more comprehensive testing
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行更全面的测试
- en: Develop repeatable regression tests
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发可重复的回归测试
- en: Minimize procedural errors
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化程序错误
- en: Improve development cycle times for product updates
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高产品更新开发周期时间
- en: An important benefit of the Automation instrument is that you can use it with
    other instruments to perform sophisticated tests, such as tracking down memory
    leaks and isolating causes of performance problems.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化工具的一个重要好处是你可以用它与其他工具一起执行复杂的测试，例如追踪内存泄漏和隔离性能问题的原因。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Automation instrument does not allow you to process any application that
    is not code-signed with your provisioning profile, and this will not run within
    the iOS simulator. It needs to be run on an iOS-compatible device running iOS
    4 or later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化工具不允许你处理任何未使用你的配置文件签名应用的应用程序，并且它不会在 iOS 模拟器中运行。它需要在运行 iOS 4 或更高版本的 iOS 兼容设备上运行。
- en: Preparing your application
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备你的应用程序
- en: Before we can start to use the Automation tool, we need to do a little groundwork
    to prepare our application, so that it can work with the automation tool. The
    UI automation library relies on the accessibility information within your UI,
    so we will be adding this piece of information later, which will make testing
    of your application a lot easier.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用自动化工具之前，我们需要做一些前期工作来准备我们的应用程序，以便它可以与自动化工具一起工作。UI 自动化库依赖于你的 UI 中的可访问性信息，因此我们将在稍后添加这一信息，这将使你的应用程序测试变得容易得多。
- en: Creating a simple UIAutomation application
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的 UIAutomation 应用程序
- en: Before we can proceed, we first need to create our `UIAutomation` project. To
    refresh your memory, you can refer to the section named *Creating the MyEmailApp
    application* in [Chapter 1](ch01.html "Chapter 1. What's New in iOS5"),*What's
    New in iOS5.*
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们首先需要创建我们的 `UIAutomation` 项目。为了刷新你的记忆，你可以参考[第 1 章](ch01.html "第 1 章。iOS5
    中的新功能"),*iOS5 中的新功能*中名为 *创建 MyEmailApp 应用程序* 的部分。
- en: Launch Xcode from the `/Xcode4/Applications` folder.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/Xcode4/Applications`文件夹中启动 Xcode。
- en: Choose **Create a new Xcode project**, or **File | New Project**.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建一个新的 Xcode 项目**，或者**文件 | 新项目**。
- en: Select the **Single View Application** template from the list of available templates.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用模板列表中选择**单视图应用程序**模板。
- en: Select **iPhone** from under the **Device Family** drop-down.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**设备家族**下拉菜单中选择**iPhone**。
- en: Ensure that you have checked the box for **Use Automatic Reference Counting**,
    from under the **Device Family** drop-down.![Creating a simple UIAutomation application](img/2267_06_07.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经检查了**设备家族**下拉菜单下的**使用自动引用计数**复选框。![创建一个简单的 UIAutomation 应用程序](img/2267_06_07.jpg)
- en: Click on the **Next** button to proceed to the next step in the wizard.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**按钮，进入向导的下一个步骤。
- en: Enter in `UIAutomation`, and then click on the **Next** button to proceed to
    the next step of the wizard.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`UIAutomation`，然后点击**下一步**按钮，进入向导的下一个步骤。
- en: Specify the location where you would like to save your project.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定你想要保存项目的位置。
- en: Click on the **Save** button to continue and display the Xcode workspace environment.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击** **保存** **按钮**继续并显示 Xcode 工作区环境。
- en: Now that we have created our `UIAutomation` project, we can start to build our
    user interface, and add the required code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的 `UIAutomation` 项目，我们可以开始构建我们的用户界面，并添加所需的代码。
- en: From the **Project Navigator**, select and open the `ViewController.xib` file.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**中选择并打开 `ViewController.xib` 文件。
- en: From the **Object Library**, select and drag a (`UIButton`) round rect button
    control, and add this to our view.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**对象库**中选择并拖动一个（`UIButton`）圆形矩形按钮控件，并将其添加到我们的视图中。
- en: Resize accordingly, then modify the **Object Attributes** section of the round
    rect button, and set its title to `Tap Me`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要调整大小，然后修改圆形矩形按钮的**对象属性**部分，并将其标题设置为 `Tap Me`。
- en: Next, from the **Object Library**, select and drag a (`UIButton`) round rect
    button control, and add this to our view underneath the **Tap Me** button.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从**对象库**中选择并拖动一个（`UIButton`）圆形矩形按钮控件，并将其添加到**Tap Me**按钮下面的视图中。
- en: Resize accordingly, then modify the **Object Attributes** section of the round
    rect button, and set its title to `Press Me`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要调整大小，然后修改圆形矩形按钮的**对象属性**部分，并将其标题设置为 `Press Me`。
- en: If you have followed these steps correctly, your view should look like something
    shown in the following screenshot. If it doesn't look quite the same as mine,
    feel free to adjust yours.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地遵循了这些步骤，您的视图应该看起来像以下截图所示。如果它与我的不完全相同，请随意调整您的。
- en: '![Creating a simple UIAutomation application](img/2267_06_08.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单的 UIAutomation 应用程序](img/2267_06_08.jpg)'
- en: As you can see, our form doesn't do much at this stage, and if you were to run
    this application on the simulator, you would see the controls as placed out on
    your screen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的表单在这个阶段并没有做什么，如果您在模拟器上运行此应用程序，您会看到控件像在屏幕上放置一样。
- en: The following steps will show you how to connect your buttons up to their action
    events, so that can each perform their task. So let's get started.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向您展示如何将按钮连接到它们的事件，以便它们可以执行各自的任务。那么，让我们开始吧。
- en: 'Open the `ViewController.h` interface file, and create the following highlighted
    entries as shown in this code snippet:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewController.h` 接口文件，并创建如下所示的高亮条目：
- en: '[PRE15]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open the **Assistant Editor** window, by selecting the **Open in Assistant Editor**
    option from the **Navigate** menu, or alternatively, by holding down **Option**
    + **Command** +**, (Option key + Command key + Comma key).**
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从**导航**菜单中选择**在辅助编辑器中打开**选项，或通过按住**Option** + **Command** + **,**（选项键 + 命令键
    + 逗号键），打开**辅助编辑器**窗口。
- en: '**We need to create an action event. Select the **Tap Me** button, and hold
    down the control key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple UIAutomation
    application](img/2267_06_09.jpg)**'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们需要创建一个动作事件。选择** **Tap Me** **按钮，并在将此拖动到 `ViewController.m` 实现文件类中时按住控制键，如图所示：![创建简单的
    UIAutomation 应用程序](img/2267_06_09.jpg)**'
- en: '**Specify a name for the action that you want to create. Enter in `btnTapMe`
    as the name of the action.**'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为要创建的动作指定一个名称。输入 `btnTapMe` 作为动作的名称。**'
- en: '**Set the type of event to be **Touch Up Inside:**![Creating a simple UIAutomation
    application](img/2267_06_10.jpg)**'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将事件类型设置为** **触摸内部释放**：![创建简单的 UIAutomation 应用程序](img/2267_06_10.jpg)'
- en: '**Click on the **Connect** button to have Xcode create the event.**'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**点击** **连接** **按钮**，让 Xcode 创建事件。'
- en: '**We need to create an action event. Select the **Press Me** button, and hold
    down the Control key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple UIAutomation
    application](img/2267_06_11.jpg)**'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们需要创建一个动作事件。选择** **按我** **按钮，并在将此拖动到 `ViewController.m` 实现文件类中时按住 Control
    键，如图所示：![创建简单的 UIAutomation 应用程序](img/2267_06_11.jpg)**'
- en: '**Specify a name for the action that you want to create. Enter in `btnPressMe`
    as the name of the action.**'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为要创建的动作指定一个名称。输入 `btnPressMe` 作为动作的名称。**'
- en: '**Set the type of event to be **Touch Up Inside:**![Creating a simple UIAutomation
    application](img/2267_06_12.jpg)**'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将事件类型设置为** **触摸内部释放**：![创建简单的 UIAutomation 应用程序](img/2267_06_12.jpg)'
- en: '**Click on the **Connect** button to have Xcode create the event.**'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**点击** **连接** **按钮**，让 Xcode 创建事件。'
- en: '**Now that we have connected up our action events, we now need to synthesize
    our user-interface controls, so that we can access these within our view controller.**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们已经连接了我们的动作事件，我们现在需要合成我们的用户界面控件，以便我们可以在视控制器中访问它们。**'
- en: '**Open the `ViewController.m` implementation file that is located within the
    `CIFilterEffects` folder, and add the following highlighted statement underneath
    the `@implementation` statement.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开位于`CIFilterEffects`文件夹中的`ViewController.m`实现文件，并在`@implementation`语句下方添加以下突出显示的语句。**'
- en: '[PRE16]**'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE16]**'
- en: '**In this code snippet, we are making our implementation file aware of the
    controls that are located on our user interface form. If these are not declared,
    we will receive warning messages, which could potentially cause your program to
    produce some weird results, or may even crash your application on the iOS device.**'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在这个代码片段中，我们使我们的实现文件知道位于用户界面表单上的控件。如果没有声明这些控件，我们将收到警告消息，这可能会使您的程序产生一些奇怪的结果，甚至可能使iOS设备上的应用程序崩溃。**'
- en: '**Next, we need to add the code into our `btnTapMe` function that will be used
    to display an alert message pop-up when the button has been pressed. Enter in
    the following code snippet for this function:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接下来，我们需要将代码添加到我们的`btnTapMe`函数中，该函数将用于在按钮被按下时显示一个警告消息弹出。为此函数输入以下代码片段：**'
- en: '[PRE17]**'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE17]**'
- en: '**This code snippet creates an instance of the `UIAlertView` class that will
    enable us to display an alert pop-up dialog box when the button has been pressed.
    You will notice that we have not released our alert object variable. This is mainly
    because ARC will be automatically managing the releasing of this object for us.**'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**此代码片段创建了一个`UIAlertView`类的实例，它将使我们能够在按钮被按下时显示一个警告弹出对话框。您会注意到我们没有释放我们的警告对象变量。这主要是因为ARC将自动为我们管理这个对象的释放。**'
- en: '**Next, we need to add the code into our `btnPressMe` function that will be
    used to help determine when the automation instrument has pressed it. Enter in
    the following commented-out code snippet for this function:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接下来，我们需要将代码添加到我们的`btnPressMe`函数中，该函数将帮助我们确定自动化工具何时按下它。为此函数输入以下注释掉的代码片段：**'
- en: '[PRE18]**'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE18]**'
- en: '**This code snippet creates an instance of the `UIAlertView` class that will
    help us determine when this has been pressed by the UI automation instrument,
    when we come to perform our unit testing. This code has been purposely commented
    out, so that we fail an automation test case that we will be setting up later
    on.**'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**此代码片段创建了一个`UIAlertView`类的实例，它将帮助我们确定当我们在进行单元测试时，UI自动化工具何时按下它。这段代码已被故意注释掉，以便我们能够失败我们稍后将要设置的自动化测试用例。**'
- en: '**In the next section, we will look at how to set up our controls, so that
    they can be accessed and communicated by the Automation instrument. The UI Automation
    instrument library relies on accessibility information within your UI and looks
    for the `AccessibilityLabel` property of your controls.**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**在下一节中，我们将探讨如何设置我们的控件，以便它们可以被自动化工具访问和通信。UI自动化工具库依赖于您UI中的可访问性信息，并查找您控件的`AccessibilityLabel`属性。**'
- en: '**From the `UIAutomation` example project navigator window, select the `ViewController.xib`
    file from the `UIAutomation` folder.**'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从`UIAutomation`示例项目导航窗口中，选择`UIAutomation`文件夹中的`ViewController.xib`文件。**'
- en: '**Click on the **Tap Me** button, and select the **Identity Inspector** button.![Creating
    a simple UIAutomation application](img/2267_06_13.jpg)**'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**点击**“Tap Me”**按钮，并选择**“身份检查器”**按钮。![创建一个简单的UIAutomation应用程序](img/2267_06_13.jpg)'
- en: '**Ensure that the **Accessibility** option has been checked and that the **User
    Interaction Enabled** option has also been checked. This makes it easy to access
    only those objects that have these properties set, to be accessed directly from
    within the view. This is mainly due to their properties being exposed, making
    accessing these from within the `UIAutomation` test script easier.**'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确保已勾选**“可访问性”**选项，并且已勾选**“用户交互启用”**选项。这使得仅能访问具有这些属性设置的对象，可以直接从视图中访问。这主要是因为它们的属性被公开，这使得从`UIAutomation`测试脚本中访问它们变得更容易。**'
- en: '**Repeat *steps 2* to *3*, and apply the same to the **Press Me** button.**'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重复**步骤2**到**步骤3**，并将相同的操作应用于**“按我”**按钮。**'
- en: '**Writing the UIAutomation test script**'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**编写UIAutomation测试脚本**'
- en: '**The next step is to write the test script in JavaScript, using any editor
    of your choice. A **Test Script** is basically a set of ordered commands, each
    of which accesses a user interface element within your application to be used
    to perform some sort of user action on it, or to use the information associated
    within it.**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一步是使用您选择的任何编辑器编写JavaScript测试脚本。**测试脚本**基本上是一组有序命令，每个命令都访问您应用程序中的一个用户界面元素，以执行某种用户操作或使用与之关联的信息。**'
- en: '**All of the user interface elements within your application are represented
    to the script through an ordered hierarchical view of objects that are defined
    by the `UIAElements` class and its subclasses.**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**您应用程序中的所有用户界面元素都通过`UIAElements`类及其子类定义的对象的有序层次视图来表示给脚本。**'
- en: '**In order to reach a specified UI element, the script simply calls down the
    element hierarchy, starting from the top-level target object. The following code
    statement shows how to declare this in JavaScript:**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了到达指定的UI元素，脚本只需从顶层目标对象开始调用元素层次结构。以下代码语句展示了如何在JavaScript中声明它：**'
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**The `UIATarget` object is your primary starting point for your application
    running on an iOS device or iOS simulator. This object provides a means for when
    you want to interact with and when you need to perform operations on the iOS device,
    such as user gestures which include as tapping, swiping, and shaking.**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**`UIATarget`对象是您在iOS设备或iOS模拟器上运行应用程序的主要起点。当您想要与iOS设备交互或需要在iOS设备上执行操作时，例如用户手势（包括点击、滑动和摇晃），此对象提供了一种方式。**'
- en: '**The `app` object is an instance of the `UIAApplication` class that gives
    you access to the top-level structure of your application. This provides you with
    access to things such as tab bars, navigation bars, and the main window. The following
    code statement shows how to declare this in JavaScript:**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**`app`对象是`UIAApplication`类的实例，它为您提供了访问应用程序顶级结构的方式。这为您提供了访问诸如标签栏、导航栏和主窗口等元素的方式。以下代码语句展示了如何在JavaScript中声明它：**'
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Now that you have an understanding of the UI elements structures, we can
    start to construct our `UIAutomation` test script. So, fire up your favorite editor,
    and let''s begin.**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在您已经了解了UI元素结构，我们可以开始构建我们的`UIAutomation`测试脚本。所以，打开您最喜欢的编辑器，让我们开始吧。**'
- en: '**Create a new blank document and save this as `UIAutomation.js`.**'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新空白文档，并将其保存为`UIAutomation.js`。**'
- en: '**Next, we need to declare the objects to be used by our application. This
    is shown in the following code snippet:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接下来，我们需要声明应用程序将使用的对象。如下面的代码片段所示：**'
- en: '[PRE21]**'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE21]**'
- en: '**What we are doing in this code snippet is declaring a set of objects that
    we can use and make reference to within our code.**'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在这个代码片段中，我们声明了一组对象，我们可以在代码中使用并引用它们。**'
- en: '**We have declared a target level object, which points to the top-level of
    our hierarchy, an `app` application object, as well as window, view, and buttons
    objects, which can be accessed from the `mainWindow` method.**'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们已声明了一个目标级别对象，它指向我们的层次结构的顶层，一个`app`应用程序对象，以及窗口、视图和按钮对象，这些对象可以通过`mainWindow`方法访问。**'
- en: '**Use of the `var` keyword tells the compiler that you want to declare a new
    variable instance of the object in memory. This is similar to the `Dim` (Dimension)
    keyword in Visual Basic.**'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用`var`关键字告诉编译器您想要在内存中声明一个新变量实例的对象。这类似于Visual Basic中的`Dim`（维度）关键字。**'
- en: '**Next, we want to add some initial header information to the results pane,
    to show which test case we are running this for, as shown within the following
    code snippet:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接下来，我们想在结果面板中添加一些初始标题信息，以显示我们正在为此运行哪个测试用例，如下面的代码片段所示：**'
- en: '[PRE22]**'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE22]**'
- en: '**In this code snippet, we declare a variable `testName` using the `var` keyword,
    and then assign the automation header information. This information will be displayed
    within the results pane. Next, we use the `UIALogger` class method `logStart`.
    This tells the compiler to initiate the specified test.**'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在这个代码片段中，我们使用`var`关键字声明了一个名为`testName`的变量，并将其分配给自动化标题信息。这些信息将在结果面板中显示。接下来，我们使用`UIALogger`类的方法`logStart`。这告诉编译器启动指定的测试。**'
- en: '**In our next step, we need to determine how many buttons we have on our screen.
    This is shown in the following code snippet:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在下一步中，我们需要确定屏幕上有多少个按钮。如下面的代码片段所示：**'
- en: '[PRE23]**'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE23]**'
- en: '**In this code snippet, we use the `logMessage` method to log the message to
    the results window. We then use the buttons object to determine how many buttons
    are visible within our view, and then handle this using the `logFail` and `logPass`
    methods.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在这个代码片段中，我们使用 `logMessage` 方法将消息记录到结果窗口。然后我们使用按钮对象来确定我们视图中有多少个可见的按钮，然后使用
    `logFail` 和 `logPass` 方法来处理这种情况。**'
- en: The `logFail` method logs the message to the results pane, indicating that the
    test completed unsuccessfully. The `logPass` method logs the message to the results
    pane, indicating that the test completed successfully.**
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`logFail` 方法将消息记录到结果面板，指示测试未成功完成。`logPass` 方法将消息记录到结果面板，指示测试已成功完成。**'
- en: '**In the next step, there may be times when you want to check if a specific
    button has been pressed. This is shown in the following code snippet:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在下一步中，可能会有时候你想检查是否按下了特定的按钮。这在上面的代码片段中显示：**'
- en: '[PRE24]**'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE24]**'
- en: '**In this code snippet, we use the `firstWithName` method of the `UIAElementArray`
    class to return the first element in the buttons array with the name of `Press
    Me`. We then compare and check if the button exists, by using the `null` and `UIAElementNil`
    objects, to prevent it from raising an exception error, before finally using the
    `logFail` and `logPass` methods of the `UIALogger` class to output the result
    of the test to the results pane.**'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在这个代码片段中，我们使用 `UIAElementArray` 类的 `firstWithName` 方法返回按钮数组中名为 `Press Me`
    的第一个元素。然后我们使用 `null` 和 `UIAElementNil` 对象比较和检查按钮是否存在，以防止它引发异常错误，最后使用 `UIALogger`
    类的 `logFail` 和 `logPass` 方法将测试结果输出到结果面板。**'
- en: '**In the next step, there may be times when you want to simulate a tap for
    a particular button that is displayed on the screen, and have an alert pop-up
    displayed. This is shown in the following code snippet:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在下一步中，可能会有时候你想模拟屏幕上显示的特定按钮的点击，并显示一个弹窗。这在上面的代码片段中显示：**'
- en: '[PRE25]**'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE25]**'
- en: '**In this code snippet, we use the `firstWithName` method of the `UIAElementArray`
    class to return the first element in the buttons array with the name of `Press
    Me`. We then use the `tap` method of the button to simulate a tap. When this happens,
    the associated code that is connected behind the button is executed, and an alert
    is displayed.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在这个代码片段中，我们使用 `UIAElementArray` 类的 `firstWithName` 方法返回按钮数组中名为 `Press Me`
    的第一个元素。然后我们使用按钮的 `tap` 方法来模拟点击。当发生这种情况时，与按钮关联的代码将被执行，并显示一个警报。**'
- en: We then declare an `alert` variable that takes on the alert `UIAAlert` object,
    returned by the `app` object representing the alert. Next, we compare and check
    if the alert exists by using the `null` and `UIAElementNil` objects to catch the
    error, preventing it from raising an `exception` error. Finally, we output the
    result returned to the results pane, using the `logFail` and `logPass` methods
    of the `UIALogger` class.**
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们声明一个 `alert` 变量，它接受由表示警报的 `app` 对象返回的警报 `UIAAlert` 对象。接下来，我们使用 `null` 和
    `UIAElementNil` 对象比较和检查警报是否存在，以捕获错误，防止它引发 `exception` 错误。最后，我们使用 `UIALogger` 类的
    `logFail` 和 `logPass` 方法将返回的结果输出到结果面板。**
- en: '**In our final part, we want to display to the results pane that our test case
    has completed. This is shown in the following code snippet:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在我们的最后一部分，我们希望向结果面板显示我们的测试用例已完成。这在上面的代码片段中显示：**'
- en: '[PRE26]**'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE26]**'
- en: '**In this code snippet, we use the `logMessage` method to log the message to
    the results window to show that the UI automation test case has completed, or
    a process can be used to click the button on the alert dialog box, after the delay
    has completed.**'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在这个代码片段中，我们使用 `logMessage` 方法将消息记录到结果窗口，以显示 UI 自动化测试用例已完成，或者可以使用一个过程在延迟完成后点击警报对话框中的按钮。**'
- en: '**The following table displays all methods pertaining to the `UIALogger` class.
    It has been broken up into sections to highlight which ones are used for logging
    status, and which ones can be used to specify the type of severity.**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下表格显示了与 `UIALogger` 类相关的所有方法。它已被分成几个部分，以突出显示哪些用于记录状态，哪些可以用于指定严重性类型。**'
- en: '| **Logging with test status** |   |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **使用测试状态进行日志记录** |   |'
- en: '| --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `logStart` | Logs a message, and indicates a test has started |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `logStart` | 记录一条消息，并指示测试已开始 |'
- en: '| `logPass` | Logs a message, and indicates a test has completed successfully
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `logPass` | 记录一条消息，并指示测试已成功完成 |'
- en: '| `logIssue` | Logs a message, and indicates a test has terminated abnormally
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `logIssue` | 记录一条消息，并指示测试异常终止 |'
- en: '| `logFail` | Logs a message, and indicates a test has failed |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `logFail` | 记录一条消息，并指示测试失败 |'
- en: '| Logging with severity levels |   |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 使用严重程度级别进行记录 |   |'
- en: '| `logDebug` | Logs the specified message, and sets the severity level to `debug`
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `logDebug` | 记录指定的消息，并将严重程度级别设置为`debug` |'
- en: '| `logMessage` | Logs the specified message, and sets the severity level to
    `message` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `logMessage` | 记录指定的消息，并将严重程度级别设置为`message` |'
- en: '| `logWarning` | Logs the specified message, and sets the severity level to
    `warning` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `logWarning` | 记录指定的消息，并将严重程度级别设置为`warning` |'
- en: '| `logError` | Logs the specified message, and sets the severity level to `error`
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `logError` | 记录指定的消息，并将严重程度级别设置为`error` |'
- en: '**Note**'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**For more information on the UI automation class reference and the JavaScript
    API, you can refer to *Apple Developer Documentation* at the following link: [http://developer.apple.com/library/ios/#documentation/DeveloperTools/Reference/UIAuto/_index.html](http://developer.apple.com/library/ios/#documentation/DeveloperTools/Reference/UIAuto/_index.html).**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**有关UI自动化类参考和JavaScript API的更多信息，您可以参考以下链接的*Apple开发者文档*：[http://developer.apple.com/library/ios/#documentation/DeveloperTools/Reference/UIAuto/_index.html](http://developer.apple.com/library/ios/#documentation/DeveloperTools/Reference/UIAuto/_index.html).**'
- en: '**Now that we have created our test script, we are ready to tackle the next
    part, where we start to profile our `UIAutomation` example application. This is
    covered in the next section *Running your tests*.**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们已经创建了测试脚本，我们准备开始处理下一部分，即开始对`UIAutomation`示例应用程序进行性能分析。这将在下一节*运行您的测试*中介绍。**'
- en: '**Running your tests**'
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**运行您的测试**'
- en: '**Now that we have created our tests, our next step is to profile our `UIAutomation`
    example application, within the Instruments application environment.**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们已经创建了测试，我们的下一步是在Instruments应用程序环境中对`UIAutomation`示例应用程序进行性能分析。**'
- en: '**Launch Xcode from the `/Xcode4/Applications` folder.**'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从`/Xcode4/Applications`文件夹中启动Xcode。**'
- en: '**Open the `UIAutomation` project, or **File | Open**.**'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开`UIAutomation`项目，或**文件** | 打开**。**'
- en: '**Choose **Profile** from the **Product | Profile** menu, or *Command* + *I*.![Running
    your tests](img/2267_06_14.jpg)**'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从**产品** | **配置**菜单中选择**配置**，或*Command* + *I*。![运行您的测试](img/2267_06_14.jpg)**'
- en: '**This will launch the **Xcode Instruments** application. Choose **Automation**
    from the iOS templates section, as shown in the following screenshot:![Running
    your tests](img/2267_06_15.jpg)**'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这将启动**Xcode Instruments**应用程序。从iOS模板部分选择**自动化**，如图所示：![运行您的测试](img/2267_06_15.jpg)**'
- en: '**Next, click on the **Profile** button to proceed to the next step.**'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接下来，点击**配置**按钮以进入下一步。**'
- en: '**From the **Instruments** window, click on the **Add** button, and choose
    **Import** from the drop-down list, as shown in the following screenshot:![Running
    your tests](img/2267_06_16.jpg)**'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从**Instruments**窗口中，点击**添加**按钮，然后从下拉列表中选择**导入**，如图所示：![运行您的测试](img/2267_06_16.jpg)**'
- en: '**Next, choose the `UIAutomationTest.js` file from the list, and click on the
    **Open** button to load this file into the Instruments application.![Running your
    tests](img/2267_06_17.jpg)**'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接下来，从列表中选择`UIAutomationTest.js`文件，然后点击**打开**按钮将此文件加载到Instruments应用程序中。![运行您的测试](img/2267_06_17.jpg)**'
- en: '**Finally, click on the **Record** button, or *Command* + *R* to begin profiling
    the `UIAutomation` example application. After a few moments, your application
    will launch and then your tests will run. This is shown in the following screenshot:![Running
    your tests](img/2267_06_18.jpg)**'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最后，点击**记录**按钮，或*Command* + *R*以开始对`UIAutomation`示例应用程序进行性能分析。几分钟后，您的应用程序将启动，然后您的测试将运行。这在上面的屏幕截图中显示：![运行您的测试](img/2267_06_18.jpg)**'
- en: '**Once your test completes, the instruments application will continue to run
    your application. To formally end the test being executed, click on the red **Stop**
    button, or press *Command* + *R* again.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一旦测试完成，Instruments应用程序将继续运行您的应用程序。要正式结束正在执行的测试，请点击红色**停止**按钮，或再次按*Command*
    + *R*。'
- en: Test results are listed in the details view section, along with the test name
    in the **Log Messages** column. If you test passes, the **Log Type** column value
    will be **Pass**, shown in green. If your test fails, the **Log Type** value will
    be **Fail**, shown in red.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试结果列在详细视图部分，包括**日志消息**列中的测试名称。如果测试通过，**日志类型**列的值将是**通过**，显示为绿色。如果测试失败，**日志类型**值将是**失败**，显示为红色。
- en: 'You can choose to expand the test results to see the details of what happened.
    The screenshot column is used whenever a test fails. In our case, no alert dialog
    box was displayed, and so, a screenshot was captured to show that it failed. This
    is shown in the following screenshot:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以选择扩展测试结果以查看发生情况的详细信息。截图列在测试失败时使用。在我们的情况下，没有显示警报对话框，因此捕获了截图以显示它失败了。这在上面的截图中显示：
- en: '![Running your tests](img/2267_06_19.jpg)**'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**![运行您的测试](img/2267_06_19.jpg)**'
- en: '**Go back to the `UIAutomation` example project, and uncomment the `alert`
    pop-up dialog code within the `btnPressMe` event, as shown in the following code
    snippet:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回到 `UIAutomation` 示例项目，并在 `btnPressMe` 事件中取消注释 `alert` 弹出对话框代码，如下面的代码片段所示：**'
- en: '[PRE27]**'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**[PRE27]**'
- en: '**Now, compile and re-run the test again. We should now see that within the
    details view section and under the **Log Messages** column, all of our tests should
    now be showing with the value **Pass**, shown in green. This is shown in the following
    screenshot:**'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**现在，编译并重新运行测试。我们应该现在看到在详细视图部分和 **日志消息** 列下，所有测试现在都应该显示为 **通过** 的值，以绿色显示。这在上面的截图中显示：**'
- en: '**![Running your tests](img/2267_06_20.jpg)**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**![运行您的测试](img/2267_06_20.jpg)**'
- en: '**As you can see, by including the `UIAutomation` instrument as part of your
    testing, you can halve your testing time and concentrate more on fixing up those
    annoying program bugs, prior to your application being released.**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**如您所见，通过将 `UIAutomation` 工具作为测试的一部分，您可以减半测试时间，并更多地专注于修复在应用程序发布之前那些令人烦恼的程序错误。**'
- en: '**# Summary'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 摘要**'
- en: In this chapter, we learned about the improvements that have been made to the
    Xcode development tools. We gained an understanding of what the **Automatic Reference
    Counting** (**ARC**) is, and some of the coding differences that need to be applied.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了针对 Xcode 开发工具所进行的改进。我们了解了**自动引用计数（ARC**）是什么，以及需要应用的一些编码差异。
- en: We also looked at the improvements made to Interface Builder, the iOS location
    simulator, and the set of debugging tools for OpenGL ES. To end the chapter, we
    looked at how we can use the automation instrument to help perform unit testing
    on an application, using a test script written using JavaScript to the UI automation
    API.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了对 Interface Builder、iOS 位置模拟器和 OpenGL ES 调试工具集的改进。为了结束本章，我们探讨了如何使用自动化工具来帮助对应用程序进行单元测试，使用
    JavaScript 编写的测试脚本调用 UI 自动化 API。
- en: In our final chapter, we will be taking a look into how to go about making your
    applications run smoothly, at the new features that come with Instruments, and
    how to use these to track improve your applications performance.**
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一章中，我们将探讨如何使您的应用程序运行顺畅，Instruments 的新功能，以及如何使用这些功能来跟踪和改进应用程序的性能。**
