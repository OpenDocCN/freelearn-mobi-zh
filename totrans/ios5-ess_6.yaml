- en: Chapter 6. Xcode Tools - Improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the release of the iPhone 4 back in 2010, developers were impressed by
    the remarkable `960x640-resolution` retina screen display, and provided a way
    to stay in touch with friends and family, using the FaceTime video-calling feature.
  prefs: []
  type: TYPE_NORMAL
- en: The iPhone 4 camera has been updated and features front and back cameras, as
    well as a standard 5-megapixel camera with a built-in LED flash and HD video editing
    that allows you to record and edit stunning HD video. With the release of the
    iPhone 4S, this has been updated to include the ability to record HD videos at
    1080 pixels, with the added ability to directly edit your videos from within the
    iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Xcode 4, the **Gyroscope** feature was integrated into the Accelerometer,
    which provided developers the flexibility to program this and create some stunning
    games. With the release of iOS 5 SDK, the LLVM compiler has been updated to include
    the new **Automatic Reference Counting** (**ARC**) feature.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of Xcode 4.2 and the iOS 5 SDK, Interface Builder has been
    updated to provide a better way of transitioning between your views and view controller,
    by introducing story boarding for your iOS applications, featured directly within
    the Xcode IDE.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that the iOS simulator has also been revamped, and now
    allows you to simulate different locations using the Core Location framework,
    all directly from within the Xcode Development Environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the latest improvements to the LLVM Compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to create storyboard files using Interface Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the changes made to the iOS simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the improvements made to OpenGL ES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the application data management and UI automation enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This technology is an open source compiler technology, which is currently being
    led by Apple's compiler team to be used in several high-end performance projects
    around the globe. The LLVM 2.0 compiler has also been substantially updated, and
    now compiles twice as fast as the GCC compiler, producing applications that load
    faster on the iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has been rewritten as a set of optimized code libraries, which have been
    designed around today''s modern chip architectures. It has been fully integrated
    into the Xcode 4 development IDE, and provides complete support for the following
    languages: C, Objective-C, and C++.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about the Automatic Reference Counting feature
    that has been added as part of the LLVM compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Reference Counting (ARC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Automatic Reference Counting** (**ARC**) for Objective-C makes memory management
    the job of the compiler. When you enable ARC using the new Apple LLVM 3.0 compiler,
    this will largely remove the burden of manually releasing memory, and avoid the
    endless chore of tracking down program bugs caused by memory leaks or objects
    that have been released too early.'
  prefs: []
  type: TYPE_NORMAL
- en: The ARC compiler has a complete understanding of your objects, and releases
    each object the instant it is no longer used, so applications run as fast as ever,
    with predictable, smooth performances. In a majority of situations, you will never
    need to type retain or release again, and this will dramatically simplify the
    development process, while reducing crashes and memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xcode comes with a new **Convert to Objective-C ARC..**. tool, that is located
    within the **Edit | Refactor** menu within the IDE, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automatic Reference Counting (ARC)](img/2267_06_00.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This tool automates the mechanical parts of the ARC conversion, by removing
    method calls such as `retain` and `release`, and helps you to fix issues the migrator
    can't handle automatically. The ARC migration tool converts all files within a
    project to use ARC; you also have the added option of choosing to use ARC on a
    per-file basis to overcome some of ARC's current restrictions, and use manual
    reference counting for some files.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot implies that writing operative code takes almost as
    long to write as retain/release logic. This will not be true for experienced Objective-C
    developers, but if you are a new and just starting out with Objective-C, this
    is probably a conservative estimate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on Objective-C, please refer to the *Apple Developer Documentation*
    at the following location: [http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163).'
  prefs: []
  type: TYPE_NORMAL
- en: You will still need to take some responsibility for how your classes manage
    reference to other objects, rather than relying totally on ARC.
  prefs: []
  type: TYPE_NORMAL
- en: '![Automatic Reference Counting (ARC)](img/2267_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ARC provides automatic memory management for your objects, without you having
    to remember when to use retain, release, and auto-release. ARC starts by evaluating
    your objects, and automatically inserts the appropriate method calls for you at
    compile time, as well as generating the appropriate `dealloc` method calls for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s take a look at an example that shows the older way of doing
    things prior to the use of ARC, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In between allocating and initializing an object, and then finally releasing
    the object, you can do with it as you wish, and the object will only be released
    and de-allocated when it is not in use.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, by adding the object to an auto-release pool, it will stick around
    until it is needed, and will be de-allocated sometime when it is no longer needed.
    This is shown in the following code snippet of how this would have been doing
    prior to ARC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are new to iOS programming, you may have trouble getting your head around
    the use of reference counted memory at first, but once you get the hang of it,
    you'll soon see its potential. This is particularly useful when developing applications
    for iOS devices, as it can remove the burden of tracking bugs caused by leaking
    or over-released objects.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers forget to release the allocation of memory to previously declared
    objects, resulting in sluggish performance issues, or more severe, causing their
    application to hang or crash.
  prefs: []
  type: TYPE_NORMAL
- en: Under ARC, this gets handled differently, and a pre-compilation step takes place,
    which adds retain, release, and auto-release statements into the code for you.
    This is by no means a form of garbage collection, and the referenced counted memory
    has not disappeared, it has simply been automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following ARC-enabled code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The ARC pre-compilation step will automatically turn this into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order for the compiler to generate the correct code, ARC imposes some strict
    restrictions on the methods that you can use, as well as introducing new lifetime
    qualifiers for object references and declared properties.
  prefs: []
  type: TYPE_NORMAL
- en: These new rules are not present when using the other compiler modes, and are
    intended to provide a fully reliable memory management model. They have been set
    up, in some cases, to enforce best practice. In other cases, they simplify your
    code so that you don't have to deal with memory management issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Violation of these rules will result in an immediate compile-time error, not
    some program bug that can become apparent at runtime. The following table explains
    the rules you need to abide by, in order to compile with ARC:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ARC rule** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Alloc/Init objects | When creating objects, you must not make any calls to
    retain, release, auto-release, and retain `Count` methods, or indirectly call
    their selectors, that is, `@selector(retain)` and `@selector(release).` |'
  prefs: []
  type: TYPE_TB
- en: '| Dealloc methods | Generally these will be created for you, but you must not
    make a `dealloc` call directly. However, you can still create a custom `dealloc`
    method, if you need to release resources other than the instance variables. When
    creating a custom `dealloc` method, do not call the `[super dealloc]` method,
    as this will be done for you, and is enforced by the compiler. |'
  prefs: []
  type: TYPE_TB
- en: '| Declared properties | Before ARC, we told the compiler how to memory-manage
    declared `public` properties using the `assign, retain`, and `copy` parameters
    using the `@property` directive.These parameters are no longer used in ARC. Instead,
    we have two new parameters, `weak`, and `strong`, that tell the compiler how we
    want our properties treated. |'
  prefs: []
  type: TYPE_TB
- en: '| Object pointers in C structures | The Apple documentation suggests storing
    them in a class instead of a struct. This makes sense, since they would otherwise
    be unknown to ARC. It might cause some extra migration headaches. |'
  prefs: []
  type: TYPE_TB
- en: '| Casual casting between `id` and `void*` | Casting between `id` and `void*`
    data types is frequently done when handing objects between Core Foundation''s
    C library functions and Foundation Kit''s Objective-C library methods. This is
    known as **Toll Free Bridging**. With ARC, you must provide hints/qualifiers to
    tell the compiler when CF objects are moving in and out of its control for memory
    management.These qualifiers include `__bridge, __bridge_retain`, and `__bridge_transfer`.
    You still need to call `CFRetain` and `CFRelease` to memory manage Core Foundation
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `@autoreleasepool` instead of `NSAutoReleasePool` | If you use ARC compliant
    code within your applications, it must not use `NSAutoReleasePool` objects, instead
    it must use the `@autoreleasepool{}` blocks.A good example of this can be found
    within the `main.m` file of any ARC project.int main(int argc, char *argv[]){@autoreleasepool
    {return UIApplicationMain(argc, argv, nil, NSStringFromClass([MyAppDelegate class]));}}
    |'
  prefs: []
  type: TYPE_TB
- en: '| Memory zones | You cannot use `NSZone` zone-based memory (This is not part
    of the runtime anymore); you cannot use `NSAllocateObject` or `NSDeallocateObject`.
    |'
  prefs: []
  type: TYPE_TB
- en: As programmers, we find ourselves making decisions like whether to make something
    a variable or a constant, or whether or not it needs to be defined locally or
    globally. This same concept applies when we decide how our properties relate to
    other objects. To do this, we use the strong and/or weak qualifiers to notify
    the compiler of these relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Strong references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These provide a reference to an object that stops it from being de-allocated.
    In other words, it creates an owner relationship. Prior to ARC, you would have
    declared your properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at how this same property would be declared under ARC, this
    would be done as follows, to ensure that a class instance takes ownership of a
    referenced object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have declared two objects and have allocated the memory to
    our `obj1` object variable. We then declare a new object variable `obj2`, which
    has a strong reference to `obj1`. If we remove `obj2` from memory, then `obj1`
    also gets removed.
  prefs: []
  type: TYPE_NORMAL
- en: Weak references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These provide a reference to an object that does not stop it from being de-allocated.
    In other words, it does not create an owner relationship. Previously you would
    have done this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we take a look at how this same property would be declared under ARC. This
    would be done as follows to ensure that you do not have ownership of the object
    that is being referenced.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by declaring a variable called `weakName`, which points at the same
    string object that the `textField.text` property points to - this contains the
    name `Albert Einstein`. If the string contents change, then the string object
    no longer has any owners and is de-allocated. This is shown below in the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When this happens, the value of `weakName` automatically becomes `nil`, and
    is what is called a zeroing weak pointer. This is extremely convenient, because
    it prevents weak pointers from pointing to de-allocated memory. Previously, this
    sort of thing used to cause a lot of programming bugs; for example, the term dangling
    pointers or zombies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Weak pointers** are mostly useful when two objects have a parent-child relationship.
    The parent will have a strong pointer to the child and therefore owns the child,
    but in order to prevent ownership cycles, the child only has a weak pointer back
    to the parent. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there is no owner for the string object (because `str` is weak), the
    object will be de-allocated immediately after it is created. Xcode will give a
    warning when you try to do this, because it''s probably not what you intended
    to do (Warning: *assigning retained object to weak variable; object will be released
    after assignment)*.'
  prefs: []
  type: TYPE_NORMAL
- en: ARC qualifiers regular variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ARC introduces several new lifetime qualifiers for objects, and zeroing weak
    references. A weak reference does not extend the lifetime of the object that it
    points to. A zeroing weak reference, also known as a weak qualifier, instructs
    the compiler that you do not need to retain the object. If all the references
    to this object go down to zero, then the object is released and set to `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: This is important, because a message sent to a `nil` object does not cause a
    crash; it simply doesn't do anything. However, you can still use `assign`, but
    it is recommended that you use `weak` instead, because it will set a de-allocated
    object to `nil`. A weak qualifier is especially used in a parent-child object
    relationship, where the parent has a strong reference to a child object, and the
    child object has a weak reference back to the parent, otherwise you will end up
    creating a circular reference.
  prefs: []
  type: TYPE_NORMAL
- en: Variable qualifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous code snippets, we illustrated how our declared properties should
    be managed. For regular variables we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__strong`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__weak`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__unsafe_unretained`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__autoreleasing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally speaking, these extra qualifiers need not be used very often. You
    might first encounter these qualifiers, and others, when using the migration tool.
    For new projects, however, you won't need them and will mostly use `strong/weak`
    with your declared properties.
  prefs: []
  type: TYPE_NORMAL
- en: '| **ARC types** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `__strong` | This is the default, so you don''t need to type it. This means
    any object created using `alloc/init` is retained for the lifetime of its current
    scope. The **current scope** usually means the braces in which the variable is
    declared (that is, a method, `for` loop, `if` block, and so on). |'
  prefs: []
  type: TYPE_TB
- en: '| `__weak` | This means the object can be destroyed at any time. This is only
    useful if the object is somehow strongly referenced somewhere else. When destroyed,
    a variable with `__weak` is set to `nil.` |'
  prefs: []
  type: TYPE_TB
- en: '| `__unsafe_unretained` | This is similar to the `__weak` type, but the pointer
    is not set to `nil` when the object is de-allocated. Instead the pointer is left
    pointing to an unsafe area of memory. |'
  prefs: []
  type: TYPE_TB
- en: '| `__autoreleasing` | This is not to be confused with calling `autorelease`
    on an object, before returning it from a method. This is used for passing objects
    by reference, for example, when passing `NSError` objects by reference such as
    `[myObject performOperationWithError:&tmp]`; |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the *LLVM Clang Objective-C Automatic Reference Counting*
    documentation, you can refer to the following link provided: [http://clang.llvm.org/docs/AutomaticReferenceCounting.html#ownership](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#ownership).'
  prefs: []
  type: TYPE_NORMAL
- en: Interface builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Xcode 4, the Interface Builder is a user interface design tool where you
    can build your user interface, by dragging and dropping objects from the Object
    Library onto a blank canvas. The resulting user interface would then be saved
    as an XIB file, which is an XML representation of your objects and their instance
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, when creating a new view, you would have to create an XIB file
    for each view that your application required, to transition from each view to
    the next. In order to make designing your iOS applications much easier, Apple
    improved the user interface design process and introduced the **Storyboarding**
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Support for creating storyboard files for iOS applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the release of Xcode 4.2, Interface builder has been updated to provide
    a better way to design your user interfaces, by graphically arranging all of your
    views within a single canvas so that you can define your applications, logical
    flow as well as assign transitions between them.
  prefs: []
  type: TYPE_NORMAL
- en: Using storyboards within your applications, eases the development process by
    managing the view controllers for you. You can specify the transitions and segues
    that are used when switching between views, without having to code them by hand.
  prefs: []
  type: TYPE_NORMAL
- en: To refresh your memory, you can refer to [Chapter 4](ch04.html "Chapter 4. Using
    Storyboards"), *Using Storyboards*, under the section *How to go about creating
    Storyboard files*, for more information on how to go about creating storyboard
    files using the Interface Builder.
  prefs: []
  type: TYPE_NORMAL
- en: Location simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with the release of Xcode 4.2 and iOS 5, you now have the ability to
    test your location-based features in your application without leaving your desk.
    You can now select from preset locations and routes within the iOS simulator,
    and pick a custom latitude and longitude with accuracy, while you're running your
    simulated application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple geographical application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can proceed, we first need to create our `MapKitExample` project.
    To refresh your memory, you can refer to the section named *Creating the MyEmailApp
    application*, in [Chapter 1](ch01.html "Chapter 1. What's New in iOS5"),*What's
    new in iOS5.*
  prefs: []
  type: TYPE_NORMAL
- en: Launch Xcode from the `/Xcode4/Applications` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Create a new Xcode project**, or **File | New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Single View Application** template from the list of available templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **iPhone** from under the **Device Family** drop-down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you have checked the box for **Use Automatic Reference Counting**
    from under the **iPhone Device Family** drop-down.![Creating a simple geographical
    application](img/2267_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter in `MapKitExample`, and then click on the **Next** button to proceed to
    the next step of the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the location where you would like to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button to continue and display the Xcode workspace environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have created our `MapKitExample` project, we need to add the `MapKit`
    framework to our project, in order for our application to view map information.
    Select the **Project Navigator Group**, and then follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select your project target from under the `TARGETS` group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Build Phases** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Link Library with Libraries** disclosure triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **+** to add the library that you want. You can also search, if you
    can't find the framework you are after, from within the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are still confused as to how to go about adding the frameworks, follow
    this screenshot, which highlights the areas that you need to select (surrounded
    by a red rectangle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple geographical application](img/2267_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have added the `MapKit.framework` into your project, we need to
    import the code into the `ViewController` that will be responsible for displaying
    our map location information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make our application display the map to our view, we will need
    to import the`<MapKit/MapKit.h>` interface header file, so that we can utilize
    its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.h` interface file located within the **Classes** folder,
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we have included a reference to the Cocoa `MapKit.h` header
    file, which will expose its methods, so that we can use these within our `ViewController`
    implementation file, and then we have created an instance variable (`mapView`),
    which is a string pointer to our `MKMapView` object, which is responsible for
    holding our map location information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We haven't quite finished yet. We now need to modify our `ViewDidLoad` method,
    located within our `ViewController.m` implementation file. So, open the `ViewController.m`
    implementation file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate and uncomment the `ViewDidLoad` method, and add the following code snippet
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, what we have actually done is allocated and initialized
    memory for our `mapView` object that we declared within our `ViewController.h`
    file, and then we added our `mapView` object to our current view, so that we can
    display this to the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `mapKit` framework has the ability to show you your current location within
    the map. It also allows you to set a variety of `mapTypes`. Next, we will be adding
    some additional code to our `ViewDidLoad` method as highlighted in the following
    code snippet. This is located within our `ViewController.m` implementation file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, what we have done is added the ability to display our
    map in **Hybrid** view (combination of satellite view and road information) as
    well as directed our map to display our current location that will be indicated
    by an animated blue marker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The iOS native maps application allows you to choose from the following three
    possible map types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Map type constant** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MKMapTypeStandard` | This is the default type of map to display, if none
    is specified, and this type will show a normal map containing street and road
    names. |'
  prefs: []
  type: TYPE_TB
- en: '| `MKMapTypeSatellite` | Setting this type of map will display satellite view
    information. |'
  prefs: []
  type: TYPE_TB
- en: '| `MKMapTypeHybrid` | This type of map will show a combination of a satellite
    view with road and street information overlaid. |'
  prefs: []
  type: TYPE_TB
- en: 'If you build and run your application, you should now see a map displayed with
    the animated blue marker flashing. I have rotated the device and zoomed in at
    a random location to show the capabilities of the `MapKit` framework, as is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple geographical application](img/2267_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When running `MapKit` applications using the iOS Simulator, it will always default
    to Apple's headquarters located at 1, Infinite Loop, based out at California.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get a better location, it is much better to use your iOS device.
    This is because the iOS simulator uses your IP address to work out an approximate
    location of where you are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also choose to navigate to a different location while the iOS simulator
    is running. To do this, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Simulate Location** icon as shown in the following screenshot. This
    will display a list of available locations:![Creating a simple geographical application](img/2267_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Tokyo, Japan**, or a similar option from the list of displayed locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The iOS simulator will be updated to reflect the chosen location, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Creating a simple geographical application](img/2267_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we learned about the `MapKit` framework, and how we can use
    this within our application to simulate to a particular location. We learned how
    to use the **Simulate Location** feature of the Xcode debugger, to navigate to
    various locations within the iOS simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the `MKMapView` class reference, please refer to the
    *Apple Developer Documentation* at the following link location provided: [http://developer.apple.com/library/ios/#documentation/MapKit/Reference/MKMapView_Class/MKMapView/MKMapView.html#//apple_ref/doc/uid/TP40008205](http://developer.apple.com/library/ios/#documentation/MapKit/Reference/MKMapView_Class/MKMapView/MKMapView.html#//apple_ref/doc/uid/TP40008205).'
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenGL ES debugger allows you to track down issues specific to OpenGL ES
    within your application. You can then choose to have this break at a certain point
    within your program. To refresh your memory, you can refer to the section named
    *Detecting errors by setting up breakpoints*, that we covered in [Chapter 3](ch03.html
    "Chapter 3. Debugging with OpenGL ES"), *Debugging with OpenGL ES*, for more information
    on how to go about debugging OpenGL ES projects.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES frame capture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenGL ES frame capture is part of the Xcode debugger, and allows you to
    take a snapshot of all of the frames that are being drawn within your application
    at the point it was captured. You can then choose to navigate through each of
    the frames and see the associated code, as well as changing between solid or wireframe
    view. To refresh your memory, you can refer to the section named *Breaking on
    frame boundaries*, in [Chapter 3](ch03.html "Chapter 3. Debugging with OpenGL
    ES"), *Debugging with OpenGL ES*, for more information on how to go about capturing
    OpenGL ES frames.
  prefs: []
  type: TYPE_NORMAL
- en: Application data management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: iOS provides powerful connectivity options for sharing your information amongst
    the applications that are installed on an iOS device. Using a URL-based syntax,
    you can have your applications access data from the Web, as well as passing this
    information onto other applications that are installed, such as mail, iTunes,
    and YouTube.
  prefs: []
  type: TYPE_NORMAL
- en: Your own applications can declare a unique URL scheme, allowing any application
    to collaborate and share data with your application.
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose to make use of XML files; these provide a lightweight structured
    format that your application can easily read and write. XML files readily fit
    into the iOS file system, and can be used to store your application settings and
    user preferences in the built-in **User Defaults** database. This XML-based data
    store includes a simple API with powerful features, including the ability to serialize
    and restore complex objects on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the application data management feature, please refer
    to the following *Apple Developer Documentation* at the following location: [DOCUMENTATION/DataManagement/Conceptual/iPhoneCoreData01/Articles/01_StartingOut.html#//apple_ref/doc/uid/TP40008305-CH105-SW2](http://DOCUMENTATION/DataManagement/Conceptual/iPhoneCoreData01/Articles/01_StartingOut.html#//apple_ref/doc/uid/TP40008305-CH105-SW2).'
  prefs: []
  type: TYPE_NORMAL
- en: UI automation enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Automation** instrument was added to the release of the iOS SDK 4.0\.
    This tool allows you to automate user interface tests of your iOS applications,
    by scripting touch events, allowing you to log these results to be used for your
    analysis, later on. The Automation instrument comes complete with a script editor,
    so that you can choose to either write your test scripts to the UI Automation
    API using JavaScript, or load this into the editor from a file.
  prefs: []
  type: TYPE_NORMAL
- en: This is a huge leap forward for testing your applications on the iOS platform
    using test automation, which can reduce your time spent manually testing your
    applications. The Automation feature can be used to simulate many user actions
    on devices that support multitasking and, which are running iOS 4.0 or later.
  prefs: []
  type: TYPE_NORMAL
- en: You also have the ability to capture and record actions directly into your script
    as you perform them on an iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automating UI tests allows you to:'
  prefs: []
  type: TYPE_NORMAL
- en: Free critical staff and resources for other work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform more comprehensive testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop repeatable regression tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize procedural errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve development cycle times for product updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important benefit of the Automation instrument is that you can use it with
    other instruments to perform sophisticated tests, such as tracking down memory
    leaks and isolating causes of performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Automation instrument does not allow you to process any application that
    is not code-signed with your provisioning profile, and this will not run within
    the iOS simulator. It needs to be run on an iOS-compatible device running iOS
    4 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can start to use the Automation tool, we need to do a little groundwork
    to prepare our application, so that it can work with the automation tool. The
    UI automation library relies on the accessibility information within your UI,
    so we will be adding this piece of information later, which will make testing
    of your application a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple UIAutomation application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can proceed, we first need to create our `UIAutomation` project. To
    refresh your memory, you can refer to the section named *Creating the MyEmailApp
    application* in [Chapter 1](ch01.html "Chapter 1. What's New in iOS5"),*What's
    New in iOS5.*
  prefs: []
  type: TYPE_NORMAL
- en: Launch Xcode from the `/Xcode4/Applications` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Create a new Xcode project**, or **File | New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Single View Application** template from the list of available templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **iPhone** from under the **Device Family** drop-down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you have checked the box for **Use Automatic Reference Counting**,
    from under the **Device Family** drop-down.![Creating a simple UIAutomation application](img/2267_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter in `UIAutomation`, and then click on the **Next** button to proceed to
    the next step of the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the location where you would like to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button to continue and display the Xcode workspace environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have created our `UIAutomation` project, we can start to build our
    user interface, and add the required code.
  prefs: []
  type: TYPE_NORMAL
- en: From the **Project Navigator**, select and open the `ViewController.xib` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Object Library**, select and drag a (`UIButton`) round rect button
    control, and add this to our view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize accordingly, then modify the **Object Attributes** section of the round
    rect button, and set its title to `Tap Me`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, from the **Object Library**, select and drag a (`UIButton`) round rect
    button control, and add this to our view underneath the **Tap Me** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize accordingly, then modify the **Object Attributes** section of the round
    rect button, and set its title to `Press Me`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have followed these steps correctly, your view should look like something
    shown in the following screenshot. If it doesn't look quite the same as mine,
    feel free to adjust yours.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple UIAutomation application](img/2267_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our form doesn't do much at this stage, and if you were to run
    this application on the simulator, you would see the controls as placed out on
    your screen.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps will show you how to connect your buttons up to their action
    events, so that can each perform their task. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.h` interface file, and create the following highlighted
    entries as shown in this code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **Assistant Editor** window, by selecting the **Open in Assistant Editor**
    option from the **Navigate** menu, or alternatively, by holding down **Option**
    + **Command** +**, (Option key + Command key + Comma key).**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We need to create an action event. Select the **Tap Me** button, and hold
    down the control key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple UIAutomation
    application](img/2267_06_09.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Specify a name for the action that you want to create. Enter in `btnTapMe`
    as the name of the action.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set the type of event to be **Touch Up Inside:**![Creating a simple UIAutomation
    application](img/2267_06_10.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Click on the **Connect** button to have Xcode create the event.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We need to create an action event. Select the **Press Me** button, and hold
    down the Control key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple UIAutomation
    application](img/2267_06_11.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Specify a name for the action that you want to create. Enter in `btnPressMe`
    as the name of the action.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set the type of event to be **Touch Up Inside:**![Creating a simple UIAutomation
    application](img/2267_06_12.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Click on the **Connect** button to have Xcode create the event.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Now that we have connected up our action events, we now need to synthesize
    our user-interface controls, so that we can access these within our view controller.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open the `ViewController.m` implementation file that is located within the
    `CIFilterEffects` folder, and add the following highlighted statement underneath
    the `@implementation` statement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In this code snippet, we are making our implementation file aware of the
    controls that are located on our user interface form. If these are not declared,
    we will receive warning messages, which could potentially cause your program to
    produce some weird results, or may even crash your application on the iOS device.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Next, we need to add the code into our `btnTapMe` function that will be used
    to display an alert message pop-up when the button has been pressed. Enter in
    the following code snippet for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**This code snippet creates an instance of the `UIAlertView` class that will
    enable us to display an alert pop-up dialog box when the button has been pressed.
    You will notice that we have not released our alert object variable. This is mainly
    because ARC will be automatically managing the releasing of this object for us.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Next, we need to add the code into our `btnPressMe` function that will be
    used to help determine when the automation instrument has pressed it. Enter in
    the following commented-out code snippet for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**This code snippet creates an instance of the `UIAlertView` class that will
    help us determine when this has been pressed by the UI automation instrument,
    when we come to perform our unit testing. This code has been purposely commented
    out, so that we fail an automation test case that we will be setting up later
    on.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**In the next section, we will look at how to set up our controls, so that
    they can be accessed and communicated by the Automation instrument. The UI Automation
    instrument library relies on accessibility information within your UI and looks
    for the `AccessibilityLabel` property of your controls.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From the `UIAutomation` example project navigator window, select the `ViewController.xib`
    file from the `UIAutomation` folder.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Click on the **Tap Me** button, and select the **Identity Inspector** button.![Creating
    a simple UIAutomation application](img/2267_06_13.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ensure that the **Accessibility** option has been checked and that the **User
    Interaction Enabled** option has also been checked. This makes it easy to access
    only those objects that have these properties set, to be accessed directly from
    within the view. This is mainly due to their properties being exposed, making
    accessing these from within the `UIAutomation` test script easier.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Repeat *steps 2* to *3*, and apply the same to the **Press Me** button.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing the UIAutomation test script**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The next step is to write the test script in JavaScript, using any editor
    of your choice. A **Test Script** is basically a set of ordered commands, each
    of which accesses a user interface element within your application to be used
    to perform some sort of user action on it, or to use the information associated
    within it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**All of the user interface elements within your application are represented
    to the script through an ordered hierarchical view of objects that are defined
    by the `UIAElements` class and its subclasses.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**In order to reach a specified UI element, the script simply calls down the
    element hierarchy, starting from the top-level target object. The following code
    statement shows how to declare this in JavaScript:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**The `UIATarget` object is your primary starting point for your application
    running on an iOS device or iOS simulator. This object provides a means for when
    you want to interact with and when you need to perform operations on the iOS device,
    such as user gestures which include as tapping, swiping, and shaking.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The `app` object is an instance of the `UIAApplication` class that gives
    you access to the top-level structure of your application. This provides you with
    access to things such as tab bars, navigation bars, and the main window. The following
    code statement shows how to declare this in JavaScript:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Now that you have an understanding of the UI elements structures, we can
    start to construct our `UIAutomation` test script. So, fire up your favorite editor,
    and let''s begin.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a new blank document and save this as `UIAutomation.js`.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Next, we need to declare the objects to be used by our application. This
    is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**What we are doing in this code snippet is declaring a set of objects that
    we can use and make reference to within our code.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**We have declared a target level object, which points to the top-level of
    our hierarchy, an `app` application object, as well as window, view, and buttons
    objects, which can be accessed from the `mainWindow` method.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use of the `var` keyword tells the compiler that you want to declare a new
    variable instance of the object in memory. This is similar to the `Dim` (Dimension)
    keyword in Visual Basic.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Next, we want to add some initial header information to the results pane,
    to show which test case we are running this for, as shown within the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In this code snippet, we declare a variable `testName` using the `var` keyword,
    and then assign the automation header information. This information will be displayed
    within the results pane. Next, we use the `UIALogger` class method `logStart`.
    This tells the compiler to initiate the specified test.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**In our next step, we need to determine how many buttons we have on our screen.
    This is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In this code snippet, we use the `logMessage` method to log the message to
    the results window. We then use the buttons object to determine how many buttons
    are visible within our view, and then handle this using the `logFail` and `logPass`
    methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `logFail` method logs the message to the results pane, indicating that the
    test completed unsuccessfully. The `logPass` method logs the message to the results
    pane, indicating that the test completed successfully.**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In the next step, there may be times when you want to check if a specific
    button has been pressed. This is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In this code snippet, we use the `firstWithName` method of the `UIAElementArray`
    class to return the first element in the buttons array with the name of `Press
    Me`. We then compare and check if the button exists, by using the `null` and `UIAElementNil`
    objects, to prevent it from raising an exception error, before finally using the
    `logFail` and `logPass` methods of the `UIALogger` class to output the result
    of the test to the results pane.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**In the next step, there may be times when you want to simulate a tap for
    a particular button that is displayed on the screen, and have an alert pop-up
    displayed. This is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In this code snippet, we use the `firstWithName` method of the `UIAElementArray`
    class to return the first element in the buttons array with the name of `Press
    Me`. We then use the `tap` method of the button to simulate a tap. When this happens,
    the associated code that is connected behind the button is executed, and an alert
    is displayed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then declare an `alert` variable that takes on the alert `UIAAlert` object,
    returned by the `app` object representing the alert. Next, we compare and check
    if the alert exists by using the `null` and `UIAElementNil` objects to catch the
    error, preventing it from raising an `exception` error. Finally, we output the
    result returned to the results pane, using the `logFail` and `logPass` methods
    of the `UIALogger` class.**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In our final part, we want to display to the results pane that our test case
    has completed. This is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In this code snippet, we use the `logMessage` method to log the message to
    the results window to show that the UI automation test case has completed, or
    a process can be used to click the button on the alert dialog box, after the delay
    has completed.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The following table displays all methods pertaining to the `UIALogger` class.
    It has been broken up into sections to highlight which ones are used for logging
    status, and which ones can be used to specify the type of severity.**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logging with test status** |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `logStart` | Logs a message, and indicates a test has started |'
  prefs: []
  type: TYPE_TB
- en: '| `logPass` | Logs a message, and indicates a test has completed successfully
    |'
  prefs: []
  type: TYPE_TB
- en: '| `logIssue` | Logs a message, and indicates a test has terminated abnormally
    |'
  prefs: []
  type: TYPE_TB
- en: '| `logFail` | Logs a message, and indicates a test has failed |'
  prefs: []
  type: TYPE_TB
- en: '| Logging with severity levels |   |'
  prefs: []
  type: TYPE_TB
- en: '| `logDebug` | Logs the specified message, and sets the severity level to `debug`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `logMessage` | Logs the specified message, and sets the severity level to
    `message` |'
  prefs: []
  type: TYPE_TB
- en: '| `logWarning` | Logs the specified message, and sets the severity level to
    `warning` |'
  prefs: []
  type: TYPE_TB
- en: '| `logError` | Logs the specified message, and sets the severity level to `error`
    |'
  prefs: []
  type: TYPE_TB
- en: '**Note**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**For more information on the UI automation class reference and the JavaScript
    API, you can refer to *Apple Developer Documentation* at the following link: [http://developer.apple.com/library/ios/#documentation/DeveloperTools/Reference/UIAuto/_index.html](http://developer.apple.com/library/ios/#documentation/DeveloperTools/Reference/UIAuto/_index.html).**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Now that we have created our test script, we are ready to tackle the next
    part, where we start to profile our `UIAutomation` example application. This is
    covered in the next section *Running your tests*.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running your tests**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Now that we have created our tests, our next step is to profile our `UIAutomation`
    example application, within the Instruments application environment.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Launch Xcode from the `/Xcode4/Applications` folder.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Open the `UIAutomation` project, or **File | Open**.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Choose **Profile** from the **Product | Profile** menu, or *Command* + *I*.![Running
    your tests](img/2267_06_14.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**This will launch the **Xcode Instruments** application. Choose **Automation**
    from the iOS templates section, as shown in the following screenshot:![Running
    your tests](img/2267_06_15.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Next, click on the **Profile** button to proceed to the next step.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**From the **Instruments** window, click on the **Add** button, and choose
    **Import** from the drop-down list, as shown in the following screenshot:![Running
    your tests](img/2267_06_16.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Next, choose the `UIAutomationTest.js` file from the list, and click on the
    **Open** button to load this file into the Instruments application.![Running your
    tests](img/2267_06_17.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Finally, click on the **Record** button, or *Command* + *R* to begin profiling
    the `UIAutomation` example application. After a few moments, your application
    will launch and then your tests will run. This is shown in the following screenshot:![Running
    your tests](img/2267_06_18.jpg)**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Once your test completes, the instruments application will continue to run
    your application. To formally end the test being executed, click on the red **Stop**
    button, or press *Command* + *R* again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test results are listed in the details view section, along with the test name
    in the **Log Messages** column. If you test passes, the **Log Type** column value
    will be **Pass**, shown in green. If your test fails, the **Log Type** value will
    be **Fail**, shown in red.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can choose to expand the test results to see the details of what happened.
    The screenshot column is used whenever a test fails. In our case, no alert dialog
    box was displayed, and so, a screenshot was captured to show that it failed. This
    is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Running your tests](img/2267_06_19.jpg)**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Go back to the `UIAutomation` example project, and uncomment the `alert`
    pop-up dialog code within the `btnPressMe` event, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Now, compile and re-run the test again. We should now see that within the
    details view section and under the **Log Messages** column, all of our tests should
    now be showing with the value **Pass**, shown in green. This is shown in the following
    screenshot:**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![Running your tests](img/2267_06_20.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**As you can see, by including the `UIAutomation` instrument as part of your
    testing, you can halve your testing time and concentrate more on fixing up those
    annoying program bugs, prior to your application being released.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**# Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned about the improvements that have been made to the
    Xcode development tools. We gained an understanding of what the **Automatic Reference
    Counting** (**ARC**) is, and some of the coding differences that need to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the improvements made to Interface Builder, the iOS location
    simulator, and the set of debugging tools for OpenGL ES. To end the chapter, we
    looked at how we can use the automation instrument to help perform unit testing
    on an application, using a test script written using JavaScript to the UI automation
    API.
  prefs: []
  type: TYPE_NORMAL
- en: In our final chapter, we will be taking a look into how to go about making your
    applications run smoothly, at the new features that come with Instruments, and
    how to use these to track improve your applications performance.**
  prefs: []
  type: TYPE_NORMAL
