- en: Swift Building Blocks
  prefs: []
  type: TYPE_NORMAL
- en: Since Apple announced the Swift programming language at WWDC 2014, it has gone
    on to become one of the fastest-growing programming languages. TIOBE is a company
    that measures software quality and publishes a ranking index of programming language
    usage. At the time of writing, Swift ranks as the 11^(th) most popular language
    on this index. This is two places higher than when the first edition of this book
    was written (visit [http://www.tiobe.com/tiobe_index](http://www.tiobe.com/tiobe_index)).
  prefs: []
  type: TYPE_NORMAL
- en: Swift is a modern, general-purpose programming language that focuses on type
    safety and expressive and concise syntax. Positioned as a modern replacement for
    Objective-C, it has taken over from that older language as the future of development
    on Apple's platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Occupying this niche alone would ensure Swift's place as a useful and important
    programming language. However, Apple's decision to open-source Swift has allowed
    its influence to extend beyond Apple's ecosystem, giving it the potential to be
    used across all platforms and for any scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Since open-sourcing Swift, Apple has provided support for running your Swift
    code on Linux. In the later chapters, we will investigate using a Swift server
    to execute your code. In addition, the Swift Playgrounds iPad app turns your tablet
    into a lightweight **Integrated Development Environment** (**IDE**). Despite these
    alternative ways to use and write Swift code, the simplest is still on a Mac and
    with Apple's Xcode IDE. At the beginning of this book, we will walk through setting
    that up and will then assume that the reader uses this development environment
    unless otherwise stated. Xcode also provides a perfect way to explore the structure
    and syntax of the Swift standard library, foundation, and any other framework
    available for iOS or Mac development in the form of its Playgrounds feature.
  prefs: []
  type: TYPE_NORMAL
- en: A **Swift Playground** is a simplified environment for executing Swift code.
    For our purposes, playgrounds provide an ideal way to create, run, and understand
    the recipes contained in this book. As such, it will also be assumed that the
    reader is using an Xcode Playground to implement the recipes contained in this
    book, unless otherwise stated.
  prefs: []
  type: TYPE_NORMAL
- en: Swift 5.3 is an important release, adding many language features that are crucial
    for Apple's SwiftUI framework, which we will cover in [Chapter 10](30f08984-5b97-43e0-ad44-ca47f16ca183.xhtml),
    *SwiftUI and Combine Framework*. Swift 5.3 will also be more compatible with future
    versions of Swift, which means that code written now with Swift 5.3 can run alongside
    code written with Swift 6 and beyond. This book will assume that the reader is
    using Swift 5.3; all code will work with this version.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the building blocks of the Swift language,
    examining the syntax and functionality of the basic Swift components that everything
    else is based on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Swift program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Strings, Ints, Floats, and Bools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwrapping optionals, and force unwrapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing code in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating functionality in object classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling values into structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating values with enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing around functionality with closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using protocols to define interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in the book's GitHub repository at
    [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter01)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3rp0DnJ](https://bit.ly/3rp0DnJ)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Swift program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first recipe, we will set up our development environment and use Swift
    Playgrounds to create our first piece of Swift code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must download and install Apple''s IDE, Xcode, from the Mac App Store:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Mac App Store, either from the Dock or via Spotlight:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d80b47c-9db3-480b-98f5-014ec97e3d5d.png)![](img/0597e1d6-d989-4eb4-a1ec-02aa79c0b850.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – App Store
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for `xcode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c8c9824-ff65-4884-a7dd-e5a764ee7932.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Searching for xcode
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on GET, followed by Install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df8c3b4e-8945-42c1-be4a-4df05e1a7676.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Xcode in the App Store
  prefs: []
  type: TYPE_NORMAL
- en: Xcode is a large download (nearly 8 GB), so this may take a while, depending
    on your internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once downloaded, open Xcode from the App Store or the Dock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/668cbb84-bcd0-4ce7-83d7-c4052866c727.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Opening Xcode
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Xcode downloaded, let''s create our first Swift playground:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Xcode from the icon in your Dock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose Get started with a playground from the welcome screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/013a1e9b-cc2a-4754-86ee-2311d18f97b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Xcode, new project
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Blank from the iOS tab of the template and then press Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/073f1ea6-8648-44d9-beeb-b67572a73feb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Xcode, selecting the project type
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a name and location for your playground and then press Create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4df9f9f8-162a-4bec-89ff-2098939bc3ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Xcode, saving the project
  prefs: []
  type: TYPE_NORMAL
- en: 'Xcode playgrounds can be based on one of the three different Apple platforms:
    **iOS**, **tvOS**, and **macOS**. Playgrounds provide full access to the frameworks
    available to either iOS, tvOS, or macOS, depending on which you choose. An iOS
    playground will be assumed for the entirety of this book, chiefly because this
    is the platform of choice of the author. Where code does have UI components, the
    iOS platform will be used, unless stated otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now presented with a view that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0578c3d9-1e83-42d8-b3b5-35c4c58fa758.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Playground – code template
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s replace the word `playground` with `Swift!`. Click on the play icon
    in the bottom left-hand corner of the window to execute the code in the playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/53d0ad8a-3abc-4685-9324-0facbb297948.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Playground run/code execution
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just run your first piece of Swift code.
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side of the window, you will see the output of each line of
    code in the playground. We can see that our line of code has the output `Hello
    Swift!`
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7d4f51f-2ede-40d2-9d9c-61b76bf34bf4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – The "Hello, Swift!" playground
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you put your cursor over the output on the right-hand side, you will see
    two buttons, one that looks like an eye and another that is a rounded square:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4194d53e-3526-4d9f-a460-a4bc94ef9ed0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Playground, output
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the eye button to get a **Quick Look** box of the output. This isn''t
    particularly useful for a text string, but can be useful for more visual output,
    such as colors and views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1ee1904-18b8-4bb4-b298-44dcf5fdcfba.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Playground output quick look
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the square button, and a box will be added inline, under your code,
    showing the output of the code. This can be really useful if you want to see how
    the output changes as you change the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b63b493b-e71b-4d61-a75b-b42710ea2c61.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – Playground, inline output
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will learn more about playgrounds and how we can take them further in [Chapter
    7](f87c71fa-d2b0-44c4-9d33-65f438d69a15.xhtml), *Swift Playgrounds*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Strings, Ints, Floats, and Bools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the core operations in any programming language involve manipulating
    text, numbers, and determining true and false statements. Let's learn how to accomplish
    these operations in Swift by taking a look at its basic types and learning how
    to assign constants and variables. In doing so, we will touch on Swift's static
    typing and mutability system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open a new Swift Playground in Xcode. The previous recipe explains how to do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s run some Swift code that explores the basic types, and then we can walk
    through it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following into the new playground file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Press the play button at the bottom of the window to run the playground and
    verify that Xcode doesn''t show any errors. Your playground should look like the
    following screenshot, with an output for each line in the timeline on the right-hand
    side and printed values in the console at the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a28e0de3-63b5-4543-886d-07cfa874b168.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – Playground console output
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's step through the preceding code line by line to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this line of code, we are assigning some text to a constant value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We define a new constant value by using the `let` keyword, and we give that
    constant a name, `phrase`. The colon `:` shows that we want to define what type
    of information we want to store in the constant, and that type is defined after
    the colon. In this case, we want to assign a string (`String` is how most programming
    languages refer to text). The `=` sign indicates that we are assigning a value
    to the constant we have defined, and `"The quick brown fox jumps over the lazy
    dog"` is a `String` literal, which means that it's an easy way to construct a
    string. Any text contained within `""` marks is treated as a `String` literal
    by Swift.
  prefs: []
  type: TYPE_NORMAL
- en: We are assigning the `String` literal on the right-hand side of the `=` sign
    to the constant on the left-hand side of the `=` sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are assigning two more constants, but this time they are of the `Int`
    type, or integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than assigning a value directly, we can assign the outcome from a mathematical
    expression to the constant. This constant is a `Float`, or floating-point number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In other words, it can store fractions rather than integers. Notice that in
    the timeline on the right of this line, the value is displayed as `3.88889`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print` function allows us to see the output from any expression printed
    to the console or displayed in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will cover functions in a later recipe, but for now, all you need to know
    is that in order to use a function, you type its name (in this case `print`) and
    then enclose any required input to the function within brackets, `()`.
  prefs: []
  type: TYPE_NORMAL
- en: When our code calls this function, the timeline to the right of the code displays
    the output of the statement as `3.88888`, which differs from the line above it.
    The actual value of the mathematical expression we performed is `3.88888888...`
    with an infinite number of 8s. However, the `print` function has rounded this
    up to just five decimal places and rounded it in a different way than the timeline
    for the line above. This potential difference between the true value of a floating-point
    number and how it's represented by the Swift language is important to remember
    when dealing with floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll see some lines colored gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The playground doesn't produce an output for these lines because they are comments.
    The `/*` syntax before the line of code and the `*/` syntax after the line of
    code denote that this is a comment block, and therefore Swift should ignore anything
    typed in this block.
  prefs: []
  type: TYPE_NORMAL
- en: Remove `/*` and `*/` and you'll see that `// Doesn't compile` is still colored
    gray. This is because `//` also denotes a comment. Anything after this, on the
    same line, is also ignored.
  prefs: []
  type: TYPE_NORMAL
- en: If you now try and run this code, Xcode will tell you that there is a problem
    with this line, so let's look at the line to determine the issue.
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side of the `=` sign, we have `phrase`, which we declared earlier,
    and now we are trying to assign a new value to it. We can't do this because we
    defined `phrase` as a constant using the `let` keyword. We should only use `let`
    for things we know will not change. This ability to define something as unchanging,
    or **immutable**, is an important concept in Swift, and we will revisit it in
    later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to define something that can change, we declare it as a variable
    using the `var` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `anotherPhrase` is a variable, we can assign a new value to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings in Swift are fully *Unicode-compliant*, so we can have some fun and
    use emojis instead of words. Now, let''s print out the values of our strings to
    see what values they hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding lines, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defined a string called `phrase`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined a string called `anotherPhrase` as having the same value as `phrase`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the value of `anotherPhrase`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printed the value of `phrase` and `anotherPhrase`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we do this, we see that only `anotherPhrase` prints the new value that
    was assigned, even though the values of `phrase` and `anotherPhrase` were initially
    the same. Although `phrase` and `anotherPhrase` had the same value, they do not
    have an intrinsic connection; so, when `anotherPhrase` is assigned a new value,
    this does not affect `phrase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings can be easily combined using the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This gives the result you would expect; the strings are concatenated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will often want to create strings by including values derived from other
    expressions. We can do this with `String` interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The values inserted after `\(` and before `)` can be anything that can be represented
    as a string, including other strings, ints, floats, or expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use expressions with string interpolation, such as displaying the
    number of characters in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Strings in Swift are collections, which are containers of elements; in this
    case, a string is a collection of characters. We will cover collections in more
    depth in the next chapter, but for now, it's enough to know that your collections
    can tell you how many elements they contain through their count property. We use
    this to output the number of characters in the phrase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline string literals can be defined using `"""` at the beginning and end
    of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The contents of the Multiline string must be on a separate line from the start
    and end signifiers. Within a Multiline string literal, you can use single quote
    characters `"` without needing to use an additional escape character, as you would
    with a single-line string literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean, or `Bool`, values represent either true or false. In the next line,
    we evaluate the value of a Boolean expression and assign the result to the `phrasesAreEqual`
    constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the equality operator, `==`, compares the values on its left and right
    and evaluates to `true` if the two values are equal, and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, although we assigned `anotherPhrase` the value of `phrase`
    initially, we then assigned a new, different value to `anotherPhrase`; therefore,
    `phrase` and `anotherPhrase` are not equal and the expression assigns the value
    of `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each side of the `==` operator can be any expression that evaluates to match
    the type of the other side, as we do with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the character count of `phrase` equals 43\. Since `40 + 3` also
    equals 43, the constant is assigned the value of `true`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During this recipe, we defined a number of constants and variables, and when
    we did this, we also explicitly defined their type. For example, consider the
    following line of Swift code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Swift is a statically typed language. This means any constant or variable that
    we define has to have a specific type, and once defined it cannot be changed to
    a different type. However, in the preceding line of code, the `clearlyAString`
    constant is clearly a string! The right-hand side of the expression is a string
    literal, and therefore we know that the left-hand side will be a string. More
    importantly, the Swift compiler also knows this (a compiler is the program that
    turns Swift code into machine code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift is all about being concise, so since the type can be inferred by the
    compiler, we do not need to explicitly state it. Instead of the preceding code,
    we can use the following code and it will still run, even though we didn''t specify
    the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In fact, all the type declarations that we have made so far can be removed!
    So, go back through the code we have already written and remove all type declarations
    (`:String`, `:Int`, `:Float`, and `:Bool`), as they can all be inferred. Run the
    playground to confirm that this is still valid Swift code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Further information regarding these base types in Swift can be found in Apple''s
    documentation of the Swift language:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ints, Floats, and Bools**: [http://swiftbook.link/docs/the-basics](http://swiftbook.link/docs/the-basics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strings and Characters**: [http://swiftbook.link/docs/strings](http://swiftbook.link/docs/strings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwrapping optionals, and force unwrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world, we don't always know the answer to a question, and problems
    can occur if we assume that we will always know the answer. The same is true in
    programming languages, especially when dealing with external systems that we may
    not control. In many languages, there is no way to call out that we might not
    know a value at any given time. This can lead to either fragile code or lots of
    checks to ensure a value exists before it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: The term `nil` or `null` is used by programming languages to denote the absence
    of a value. Note that this is not the same as the number 0 or the empty (zero
    length) string `""`. Swift uses `nil` to indicate the absence of a value. Therefore,
    assigning `nil` to a value will remove any value that is currently assigned.
  prefs: []
  type: TYPE_NORMAL
- en: With a focus on Swift being type-safe and making it easier to write safe code,
    this ambiguity had to be addressed, and the Swift language does this with something
    called optionals. In this recipe, we will look at what optionals are in Swift,
    and how to handle and use them safely.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the following into a new playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When you try to run the code, you will see that the compiler has raised an error
    and will not let you assign `nil` to the `dayOfTheWeek` variable. Quite right
    too! The day of the week might change, but there will never not be a current day
    of the week.
  prefs: []
  type: TYPE_NORMAL
- en: As we declared the type to be `String`, that is what the compiler expects, and
    `nil` is not a string, so it can't be assigned to this variable.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true even if you remove the type declaration and have the compiler
    infer it, as we did in the preceding recipe. This is because the type is inferred
    at the point the variable is declared, and since it is being assigned a string
    value, the type of `String` is inferred. All other uses of this variable are checked
    against this inferred type of `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the last line, as the compiler issue will prevent us from running further
    code in the playground.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will look at a different scenario where it is appropriate to have an optional
    variable. Nick and Finn are playing a game. In each round, Finn will hold his
    hand behind his back and choose a number of fingers to hold up, Nick will guess
    how many fingers it is, and Finn will then show him how many fingers he had chosen
    to hold up.
  prefs: []
  type: TYPE_NORMAL
- en: To help keep track of the game, Nick stores how many fingers Finn has held up
    in a variable. When Finn shows his hand, Nick can enter a value for the number
    of fingers, but when Finn's hands are behind his back, Nick doesn't know how many
    fingers Finn is holding up, and so can't store a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the days of the week example, this code compiles without issues, despite
    the fact that we assign `nil` to the variable. Let's look into why we were able
    to do that.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that there will be times during the game when we don''t know how many
    fingers are being held up, so the variable is optional; it may be an `Int`, or
    it may be `nil`. You will remember from earlier that `nil` does not mean `0`.
    It is entirely possible that Finn may be holding up zero fingers (that is, a clenched
    fist) and this is a valid answer. In this scenario, `nil` represents a lack of
    knowledge regarding the number of fingers. To declare this variable as optional,
    we define the expected type, but with an additional `?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, this is referred to as an optionally wrapped `Int`. We have wrapped
    the `Int` type in the concept of being optional. I am emphasizing this term **wrapping**
    because we will need to **unwrap** this optional type later on. At the start of
    the game, we don''t know how many fingers are being held up, so we assign `nil`
    to this variable, which is allowable for optional variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Finn''s hand is shown and we know how many fingers he has held up, we
    can assign that `Int` value to the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the variable type is an optional `Int`, the valid values are either `Int`
    or `nil`; if we try something of another type, we will get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed earlier, Swift has a static type system, so the type of variable
    can''t be changed once it is declared. Therefore, although we have assigned a
    value of the `Int` type to the variable, this hasn''t changed the variable type
    to the non-optional `Int`; its type remains `Int?`. Since the type is still optional,
    we can assign it a `nil` value when Finn puts his hands behind his back again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we print an optional variable, the output tells us that it is optional,
    for example, `Optional(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the compiler highlights an issue that says Expression
    implicitly coerced from ''Int?'' to ''Any'' on the print line. We see this because
    we are passing an option value to the print comment, which is expecting a non-optional
    value. To solve this issue, we can provide a value to use if our optional value
    happens to be `nil`, and there is a really concise way to do this. The `??` operator
    can be applied after an optional value, and the value to the right of the operator
    will be used if the optional value is `nil`. This is called the **nil coalescing
    operator**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the game, we want to store the number of fingers that Finn held
    up during the last round of the game. Since we know that we will play at least
    one round of the game, we know that there must be a value for the last number
    of fingers that were held up. Therefore, we declare the `lastNumberOfFingersHeldUpByFinn`
    variable as a non-optional `Int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, our `numberOfFingersHeldUpByFinn` variable is an optional `Int`, and
    assigning a optional value to a non-optional variable causes a problem for the
    compiler since it can't be sure that it will be assigning a non-nil value. To
    get around this issue, we need to declare that this variable is now non-optional,
    even though we declared it as optional. We do this by adding `!` to the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remove `!` from the preceding statement, the compiler will complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In Swift terminology, by adding `!`, we are unwrapping the optional variable.
    Once it is unwrapped, and therefore non-optional, we can assign it to the `lastNumberOfFingersHeldUpByFinn`
    variable, which is also non-optional.
  prefs: []
  type: TYPE_NORMAL
- en: Beware! Use of this forced unwrapping can be risky. When you forcibly unwrap
    an optional, you are declaring that you are sure that there will be a value in
    that variable at that point in the execution of the code. However, if the variable
    is `nil`, you will get an error while your code is running and the execution will
    terminate. If this code is running in an app, then the app will crash. We will
    see safer ways to unwrap an optional value in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we forcibly unwrap a variable that is set to `nil`.
    Imagine that we ended the game before playing the first round:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This code will compile and run, but will crash at runtime because at the point
    that `numberOfFingersHeldUpByFinn` is assigned to `lastNumberOfFingersHeldUpByFinn`,
    the value of `numberOfFingersHeldUpByFinn` is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen non-optional variables, where a value of the correct type
    must be provided, and optional variables, where the value can either be the underlying
    type or `nil`. In a perfect world, this would be all we need. However, we may
    need to declare a variable that should be treated as non-optional, even if we
    don't know the value at the time it is declared. For these situations, we can
    declare a variable as an **implicitly unwrapped optional** (**IUO**) in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have declared a person's legal name, which is used
    at many points during their life, such as when registering for educational institutions.
    It can be changed, either by legal request or through marriage, and yet you would
    never expect someone's legal name to not exist. However, that is exactly what
    happens when someone is born! When a person is born, they don't have a legal name
    until their birth is registered. So, if we were trying to model this in code,
    a person's legal name could be represented as an **IUO**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, we declare a variable to be an IUO by placing a `!` sign after the
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: IUOs present the same risk as forced unwrapping. You are promising that the
    variable has a value, even though it is possible that it could be `nil`. Although
    it's possible for the variable to be `nil`, when something tries to access it,
    a value will be there. If the variable is accessed, but doesn't contain a value,
    the execution will terminate and your app will crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some subtlety to how IUOs behave when they are assigned to other variables
    and the type is inferred. It''s easiest to illustrate this with code, so enter
    the following into a playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When an IUO is assigned to a new variable, the compiler can't be sure that there
    is a non-nil value assigned. So, if an IUO is assigned to a new variable, as is
    the case with `output1` here, the compiler plays it safe and infers that the type
    of this new variable is an optional. If, however, the value of the IUO has been
    unwrapped, then the compiler knows that it has a non-nil value, and will infer
    a non-optional type. When assigning `output2`, the value of the input is unwrapped
    in order to add `1` to it. Therefore, the type of `output2` is inferred to be
    the non-optional `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information regarding optionals can be found at [http://swiftbook.link/docs/the-basics](http://swiftbook.link/docs/the-basics).
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functions** are a building block of almost all programming languages, allowing
    functionality to be defined and reused. Swift''s syntax provides an expressive
    way to define your functions, creating concise and readable code. In this recipe,
    we will run through the different types of functions we can create, and understand
    how to define and use them.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at how functions are defined in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at this in more detail to see how a function is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func`: This indicates that you are declaring a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nameOfFunction`: This will be the name of your function and, by convention,
    is written in camel case (this means that each word, apart from the first, is
    capitalized and all spaces are removed). This should describe what the function
    does, and should provide some context to the value returned by the function, if
    one is returned. This will be how you will invoke the method from elsewhere in
    your code, so bear that in mind when naming it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameterLabel1 parameter1: ParameterType1`: This is the first input, or parameter,
    into the function. You can specify as many parameters as you like, separated by
    commas. Each parameter has a parameter name (`parameter1`) and type (`ParameterType1`).
    The parameter name is how the value of the parameter will be made available to
    your function''s implementation. You can optionally provide a parameter label
    in front of the parameter name (`parameterLabel1` ) that will be used to label
    the parameter when your function is used (at the call site).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> OutputType`: This indicates that the function returns a value and indicates
    the type of that value. If no value is returned, this can be omitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ }`: The curly brackets indicate the start and end of the function''s implementation;
    anything within them will be executed when the function is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return output`: If the function returns a value, you type `return` and then
    the value to return. This ends the execution of the function; any code written
    after the return statement is not executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's put this into action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we are building a contacts app to hold the details of your family
    and friends, and we want to create a string of a contact''s full name. Let''s
    explore some of the ways in which functions can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function takes three string parameters and outputs a string that
    puts all these together with spaces in between. The only thing this function does
    is take inputs and produce an output without causing any side effects; this type
    of function is often called a **pure function**. To call this function, we enter
    the name of the function followed by the input parameters within `()` brackets,
    where each parameter value is preceded by its label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Functions with multiple parameters can get quite long, so to help with readability,
    the parameters can be placed on separate lines, as in the preceding example. This
    is true for both the definition of a function and when it is called. The convention
    is to align the start of the parameter name with the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Since the function returns a value, we can assign the output of this function
    to a constant or a variable, just like any other expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function takes the same input parameters, but its purpose is not to
    return a value. Instead, it prints out the parameters as one string separated
    by spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this function in the same way as the preceding function, although
    it can''t be assigned to anything since it doesn''t have a return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function takes no parameters as everything it needs to perform
    its task is contained within it, although it does output a string. This function
    calls the `fullName` function we defined earlier, taking advantage of its ability
    to produce a full name when given the component names. Reusing functionality is
    the most useful feature that functions provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `authorsFullName` takes no parameters, we can execute it by entering
    the function name followed by empty brackets, `()`, and since it returns a value,
    we can assign the outcome of `authorsFullName` to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final example takes no parameters and returns no value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call this function in the same way as the previous functions with no
    parameters, and there is no return value to assign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, having input parameters and providing
    an output value are not required when defining a function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's look at a couple of ways of making your use of functions more expressive
    and concise.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameter values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One convenience in Swift is the ability to specify default values for parameters.
    These allow you to omit the parameter when calling, as the default value will
    be provided instead. Let's use the same example as earlier in this recipe, where
    we are creating a contact app to hold information about our family and friends.
    Many of your family members are likely to have the same family name as you, so
    we can set the family name as the default value for that parameter. Therefore,
    the family name only needs to be provided if it is different from the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into a playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining a default value looks similar to assigning a value to the `familyName:
    String = "Moon"` parameter. When calling the function, the parameter with the
    default value does not have to be given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Parameter overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift supports parameter overloading, which allows for functions to have the
    same name and only be differentiated by the parameters that they take.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn more about parameter overloading by entering the following code
    into a playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Both the preceding functions have the name `combine`, but one takes two strings
    as parameters, and the other takes two Ints. Therefore, when we call the function,
    Swift knows which implementation we intended by the values we pass as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve introduced something new in the preceding function declarations, anonymous
    parameter labels: `_ givenName: String`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we declare the parameters, we use an underscore, `_`, for the parameter
    label. This indicates that we don't want a parameter name shown when calling the
    function. This should only be used if the purpose of the parameters is clear without
    the labels.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about functions can be found at [http://swiftbook.link/docs/functions](http://swiftbook.link/docs/functions).
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating functionality in object classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** is a common and powerful programming paradigm.
    At its core is the *object class*. Objects allow us to encapsulate data and functionality,
    which can then be stored and passed around.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build some class objects, break down their components,
    and understand how they are defined and used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write some code to create and use class objects, and then we will walk
    through what the code is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `Person` class object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the curly brackets, `{` and `}`, add three constants representing the
    person''s name, and one variable representing their country of residence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the properties, but still within the curly brackets, add an initialization
    method for our `Person` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a variable as a property of the class, with a computed value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function within the `Person` object that returns the person''s full name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `Friend` object that extends the functionality of the `Person`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `Friend` class object, add a variable property to hold details of
    where the user met the friend, and override the display string property to customize
    its behavior for `Friend` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the `Friend` object, create a `Family` object that extends the
    functionality of the `Person` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a relationship property to our `Family` object and create an initializer
    method to populate it in addition to the other properties from `Person`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the `Family` object a custom `displayString` method that includes the
    value of the `relationship` property by adding this code within the `Family` object
    definition (within the curly brackets):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, create instances of our new objects and print the display string to
    see how its value differs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes are defined with the `class` keyword. Class names start with a capital
    letter by convention, and the implementation of the class is contained, or "scoped",
    within curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'An object can have property values, which are contained within the object.
    These properties can have initial values, as `countryOfResidence` does in the
    following code, although bear in mind that constants (defined with `let`) cannot
    be changed once the initial value has been set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If your class were to just have the preceding property definitions, the compiler
    would raise a warning, as `givenName`, `middleName`, and `familyName` are defined
    as non-optional strings, but we have not provided any way to populate those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler needs to know how the object will be initialized so that we can
    be sure that all the non-optional properties will indeed have values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`init` is a special method (functions defined within objects are called methods)
    that''s called when the object is initialized. In the `Person` object of the preceding
    code, `givenName`, `middleName`, and `familyName` must be passed in when the object
    is initialized, and we assign those provided values to the object''s properties.
    The `self.` prefix is used to differentiate between the property and the value
    passed in, as they have the same name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not need to pass in a value for `countryOfResidence` as this has an initial
    value. This isn''t ideal, though, as when we create a `Person` object, it will
    always have the `countryOfResidence` variable set to `"UK"`, and we will then
    have to change that value, if different, after initialization. Another way to
    do this would be to use a default parameter value, as seen in the previous recipe.
    Amend the `Person` object initialization to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can provide a country of residence in the initialization or omit it
    to use the default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `displayString` property of our `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This property declaration is different from the others. Rather than having a
    value assigned to it, it is followed by an expression contained within curly braces.
    This is a computed property; its value is not static but is determined by the
    given expression every time the property is accessed. Any valid expressions can
    be used to compute the property, but must return a value that matches the declared
    type of the property. The compiler will enforce this, and you can't omit the variable
    type for computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In constructing the return value above, we use `self.fullName()` and `self.countryOfResidence`.
    As we did in the preceding `init` method, we use `self.` to show that we are accessing
    the method and property of the current instance of the `Person` object. However,
    since `displayString` is already a property on the current instance, the Swift
    compiler is aware of this context and so those self references can be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects can do work based on the information they contain, and this work can
    be defined in methods. Methods are just functions that are contained within classes
    and have access to all the object''s properties. The `Person` object''s `fullName`
    method is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: All the abilities of a function are available, which we explored in the last
    recipe, including optional inputs and outputs, default parameter values, and parameter
    overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having defined a `Person` object, we want to extend the concept of `Person`
    to define a friend. A friend is also a person, so it stands to reason that anything
    a `Person` object can do, a `Friend` object can also do. We model this inherited
    behavior by defining `Friend` as a subclass of `Person`. We define the class that
    our `Friend` class inherits from (called the "superclass"), after the class name,
    separated by `:`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: By inheriting from `Person`, our `Friend` object inherits all the properties
    and methods from its superclass. We can then add any extra functionality we require.
    In this case, we add a property for details of where we met this friend.
  prefs: []
  type: TYPE_NORMAL
- en: The `final` prefix tells the compiler that we don't intend for this class to
    be subclassed; it is the final class in the inheritance hierarchy. This allows
    the compiler to make some optimizations as it knows it won't be extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to implementing new functionalities, we can override functionalities
    from the superclass using the `override` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we override the `displayString` computed property from
    `Person` as we want to add the "where we met" information. Within the computed
    property, we can access the superclass's implementation by calling `super.`, and
    then referencing the property or method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at how we can customize how our subclasses are initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Our `Family` class also inherits from `Person`, but we want to add a `relationship`
    property, which should form part of the initialization, so we can declare a new
    `init` that also takes a relationship string value. That passed-in value is then
    assigned to the `relationship` property because the superclass's initializer is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses must have all their non-optional properties assigned a value before
    the superclass's `init` method is called. If we had forgotten to assign a value
    to `relationship`, or we had assigned it after calling `super.init`, then our
    code would not compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all our class objects defined, we can create instances of these objects
    and call methods and access properties of these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: To create an instance of an object, we use the name of the object like a function,
    passing in any required parameters. This returns an object instance that we can
    then assign to a constant or variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating an instance, we are actually calling the object''s `init` method,
    and you can do this explicitly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: However, to be concise, this is usually omitted.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Class objects are **reference types**, which is a term that refers to the way
    they are stored and referenced internally. To see how these reference type semantics
    work, let''s look at how an object behaves when it is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We defined a `MovieReview` class object, created an instance of that `MovieReview`
    object, and then assigned that review to two separate constants. As a class object
    is a reference type, it is a reference to the object that is stored in the constant,
    rather than a new copy of the object. Therefore, when we reconsider our review
    to give *The Shawshank Redemption* five stars (and rightly so!), we are changing
    the underlying object. All references that access that underlying object will
    receive the updated value when the `starRating` property is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about classes can be found at [http://swiftbook.link/docs/classes-and-structures](http://swiftbook.link/docs/classes-and-structures).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 9](f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml), *Performance and
    Responsiveness in Swift*, we will examine reference semantics in more detail,
    and see how this affects performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling values into structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class objects are great for encapsulating data and functionality within a unifying
    concept, such as a person, as they allow individual instances to be referenced.
    However, not everything is an object. We may need to represent data that is logically
    grouped together, but there isn't much more than that. It's **not** more than
    the sum of its parts; it is the sum of its parts.
  prefs: []
  type: TYPE_NORMAL
- en: For this, there are **structs**. Short for structures, structs can be found
    in many programming languages. Structs are **value types**, as opposed to classes,
    which are reference types, and, as such, behave differently when passed around.
    In this recipe, we will learn how structs work in Swift, and when and how to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will build on top of the previous recipe, so open the playground
    you have used for the previous recipe. Don't worry if you didn't work through
    the previous recipe, as this one will contain all the code you need.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already defined a `Person` object as having three separate string properties
    relating to the person''s name. However, these three separate strings don''t exist
    in isolation from each other, as together they define a person''s name. Currently,
    if you wanted to retrieve a person''s name, you have to access three separate
    properties and combine them. Let''s tidy this up by defining a person''s name
    as its own struct:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a struct called `PersonName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Add three properties to `PersonName`, for `givenName`, `middleName` and `familyName`.
    Make the first two constants, and the last one a variable, as a family name can
    change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a method to combine the three properties into a `fullName` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a method to change the family name property and prefix this method
    with the `mutating` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a person name, passing in the property values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining a struct is very similar to defining an object class, and that is intentional.
    Much of the functionality available to a class is also available to a struct.
    Therefore, you will notice that aside from using the `struct` keyword instead
    of `class`, the definition of a class and a struct are almost identical.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `PersonName` struct, we have properties for the three components
    of the name and the `fullName` method we saw earlier to combine the three name
    components into a full name string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we created to change the family name property has a new keyword
    that we haven''t seen before, `mutating`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This keyword must be added to any method in a struct that changes a property
    of the struct. This keyword is to inform anyone using the method that it will
    change, or "mutate", the struct. Unlike class objects, when you mutate a struct,
    you create a copy of the struct with the changed properties. This behavior is
    known as **value-type semantics**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let''s first create a struct and then check that it
    behaves as we expect when we assign it to different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. We have created a `PersonName` struct, assigned it to a constant
    called `alissasBirthName`, and then assigned that constant to a variable called
    `alissasCurrentName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see what happens when we mutate `alissasCurrentName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: When we call the mutating method on the `alissasCurrentName` variable, only
    that variable is changed. This change is not reflected in `alissasBirthName`,
    even though these structs were once the same. This behavior would be different
    if `PersonName` was an object class, and we explored that behavior in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use how this value-type behavior interacts with constants and variables
    to restrict unintended changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, first, let''s amend our `Person` class to our new `PersonName`
    struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We've added the `birthName` and `currentName` properties of our new `PersonName`
    struct type, and we initiate them with the same value when the `Person` object
    is created. Since a person's birth name won't change, we define it as a constant,
    but their current name can change, so it's defined as a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new `Person` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Since our `PersonName` struct has value semantics, we can use this to enforce
    the behavior that we expect our model to have. We would expect to not be able
    to change a person's birth name, and if you try, you will find that the compiler
    won't let you.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed earlier, changing the family name mutates the struct, and so
    a new copy is made. However, we defined `birthName` as a constant, which can''t
    be changed, so the only way we would be able to change the family name would be
    to change our definition of `birthName` from `let` to `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When we change `currentName` to have a new family name, which we can do since
    we defined it as a `var`, it changes the `currentName` property, but not the `birthName`
    property, even though these were assigned with the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We have used a combination of objects and structs to create a model that enforces
    our expected behavior. This technique can help to reduce potential bugs in our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about structs can be found at [http://swiftbook.link/docs/classes-and-structures](http://swiftbook.link/docs/classes-and-structures).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 9](f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml), *Performance and
    Responsiveness in Swift*, we will examine value semantics in more detail, and
    see how it affects performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating values with enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enumerations** are a programming construct that lets you define a value type
    with a finite set of options. Most programming languages have enumerations (usually
    abbreviated to **enums**), although the Swift language takes the concept further
    than most.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an enum from the iOS/macOS SDK is `ComparisonResult`, which you
    would use when sorting items. When comparing for the purposes of sorting, there
    are only three possible results from a comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ascending`: The items are ordered in ascending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`descending`: The items are ordered in descending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`same`: The items are the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a finite number of possible options for a comparison result; therefore,
    it''s a perfect candidate for being represented by an enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Swift takes the enum concept and elevates it to a first-class type. As we will
    see, this makes enums a very powerful tool for modeling your information.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will examine how and when to use enums in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will build on top of the earlier recipes, so open the playground
    you have used for the previous recipes. Don't worry if you haven't tried out the
    previous recipes, as this one will contain all the code you need.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Encapsulating functionality in object classes* recipe, we created a
    `Person` object to represent people in our model and, in the *Bundling values
    into structs* recipe, we made a `PersonName` struct to hold information about
    a person's name. Now, let's turn our attention to a person's title (for example,
    Mr, Mrs), which precedes someone's full name. There are a small and finite number
    of common titles that a person may have; therefore an enum is a great way to model
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an enum to represent a person''s title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We define our enumeration with the `enum` keyword and provide a name for the
    enum. As with classes and structs, the convention is that this starts with a capital
    letter, and the implementation is defined within curly brackets. We define each
    enum option with the `case` keyword, and, by convention, these start with a lowercase
    character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the `mr` case of our `Title` enum to a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Enums can be assigned by specifying the enum type, then a dot, and then the
    case. However, if the compiler can infer the enum type, we can omit the type and
    just provide the case, preceded by a dot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a constant value, of the `Title` type, and then assign a case to it
    with the type inferred:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many programming languages, including C and Objective-C, enums are defined
    as a type definition on top of an integer, with each case being given a defined
    integer value. In Swift, enums do not need to represent integers under the hood.
    In fact, they do not need to be backed by any type and can exist as their own
    abstract concepts. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't make sense to map the compass points as integers, and in Swift we
    don't have to.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can define multiple cases on the same line by separating them with
    commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Title` also, an integer-based enum doesn''t seem appropriate; however,
    a string-based one may be. So, let''s declare our enum to be string-based:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The enum''s raw underlying type is declared after its name and a `:` separator.
    The raw types that can be used to back the enum are limited to types that can
    be represented as a literal. This includes the following Swift base types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types can be used to back an enum because they conform to a protocol,
    called `RawRepresentable`. We will cover protocols later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cases can be assigned a value of the raw type; however, certain types can be
    inferred, and so do not need to be explicitly declared. For int-backed enums,
    the inferred values are sequentially assigned starting at `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: For string-based enums, the inferred value is the name of the case, so the `other`
    case in our `Title` enum is inferred to be `other`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the underlying value of the enum in its raw type by accessing its
    `rawValue` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the introduction to this recipe, Swift treats enums as a first-class
    type, and therefore they can have functionality that is not available to enums
    in most programming languages. This includes having computed variables and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Methods and computed variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s imagine that it is important for us to know whether a person''s title
    relates to a professional qualification that the person holds. Let''s add a method
    to our enum to provide that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: For the list of titles that we have defined, `Dr` and `Prof` relate to professional
    qualifications, so we have our method return `true` if `self` (the instance of
    the enum type this method is called on) is equal to the `dr` case, or equal to
    the `prof` case.
  prefs: []
  type: TYPE_NORMAL
- en: In defining this method, we used `||`, which is the OR logical operator. Using
    this operator returns a `true` Bool value if the expression on the left-hand side
    evaluates to `true` OR the expression on the right-hand side evaluates to `true`.
    Another useful common operator to know is the AND operator, `&&`, but this is
    not appropriate for this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality feels more appropriate as a computed property since whether
    it `isProfessional` or not is intrinsic to the enum itself, and we don''t need
    to do much work to determine the answer. So, let''s change this into a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can determine whether a title is a professional title by accessing
    the computed property on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We can't store any additional information on an enum, over and above the enum
    value itself, but being able to define methods and computed properties that provide
    extra information about the enum is a really powerful option.
  prefs: []
  type: TYPE_NORMAL
- en: Associated values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our string-based enum seems perfect for our title information, except that we
    have a case called `other`. If the person has a title that we hadn't considered
    when defining the enum, we can choose `other`, but that doesn't capture what the
    other title is. In our model, we would need to define another property to hold
    the value given for `other`, but that splits our definition of title over two
    separate properties, which could cause an unintended combination of values.
  prefs: []
  type: TYPE_NORMAL
- en: Swift enums have a solution for this situation, **associated values**. We can
    choose to associate a value with each enum case, allowing us to bind a non-optional
    string to our `other` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our `Title` enum to use an associated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the `other` case to have an associated value by putting the
    value's type in brackets after the case declaration. We do not need to add associated
    values for every case. Each case declaration can have associated values of different
    types or none at all.
  prefs: []
  type: TYPE_NORMAL
- en: Enums containing associated values cannot have a raw type as they are now too
    complex to be represented by one of these base types, so our `Title` enum is no
    longer string-based.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at how we assign an enum case with an associated type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The associated value is declared in brackets after the case, and the compiler
    enforces that the type matches the type declared in our enum definition. As we
    declared the `other` case to have a non-optional string, we are ensuring that
    a title of `other` cannot be chosen without providing details of what the other
    title is, and we don't need another property to fully represent `Title` in our
    model.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about enums can be found at [http://swiftbook.link/docs/enums](http://swiftbook.link/docs/enums).
  prefs: []
  type: TYPE_NORMAL
- en: Passing around functionality with closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Closures** are also referred to as **anonymous functions**, and this is the
    best way to explain them. Closures are functions without a name and, like other
    functions, they can take a set of input parameters and can return an output. Closures
    behave like other primary types. They can be assigned, stored, passed around,
    and used as input and output to functions and other closures.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how and when to use closures in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to build on our contacts app example from earlier in this chapter,
    so you should use the same playground as in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, you are implementing this in a new playground, first add the relevant
    code from the previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: For explanations of how this code works, please refer to the previous recipes
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s define a number of types of closures, which we will then work through
    step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a closure to print this author''s details that takes no input and returns
    no output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a closure that creates a `Person` object. The closure takes no input,
    but returns a `Person` object as the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a closure that prints a person''s details, taking the three components
    of their name as `String` inputs, but returning no output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, define a closure to create a person, taking the three name components
    as string inputs and returning a `Person` object as the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the different types of closures we just implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: As a first-class type in Swift, closures can be assigned to constants or variables,
    and constants and variables need a type. To define a closure's type, we need to
    specify the input parameter types and the output type, and for the closure in
    the preceding code, the type is `() -> Void`. The `Void` type is another way of
    saying "nothing", so this closure takes no inputs and returns nothing, and the
    closure's functionality is defined within the curly brackets, as with other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this closure defined and assigned to the `printAuthorsDetails`
    constant, we can execute it like other functions, but with the variable name,
    instead of the function''s name. With this closure, that will cause this author''s
    details to be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The next closure type takes no input parameters, but returns a `Person` object,
    as you can see with the `() -> Person` type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it has an output, the execution of the closure returns a value that can
    be assigned to a variable or constant. In the preceding code, we execute the `createAuthor`
    closure and assign the output to the `author` constant. Since we defined the closure
    type as `() -> Person`, the compiler knows that the output type is a `Person`,
    and so the type of constant can be inferred. Since we don''t need to declare it
    explicitly, let''s remove the type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s take a look at a closure that takes input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'You will remember, from the recipe on functions, that we can define parameter
    labels, which determine how the parameters are referenced when the function is
    used, and parameter names, which define how the parameter is referenced from within
    the function. In closures, these are defined a bit differently:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter labels cannot be defined for closures, so, when calling a closure,
    the order and parameter type have to be used to determine what values should be
    provided as parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameter names are defined inside the curly brackets, followed by the `in`
    keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting it all together, we can define and execute a closure with inputs and
    an output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen how we can store closures, but we can also use them as method parameters.
    This pattern can be really useful when we want to be notified when a long-running
    task is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we want to save the details of our `Person` object to a remote
    database, maybe for backup or use on other devices. We may want to be notified
    when this process has completed, so we execute some additional code, perhaps printing
    a completion message, or update some UI. While the actual saving implementation
    is outside the scope of this recipe, we can amend our `Person` class to allow
    this save functionality to be called, passing a closure to execute on completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method to save to a remote database, taking in a completion "handler",
    and store it for subsequent execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We define an optional variable to hold on to the save handler during the long-running
    save operation. Our closure will take a `Bool` to indicate whether the save was
    a success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now define a method to save our `Person` object, which takes a closure
    as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Our function stores the given closure in the variable and then starts the process
    to save to the remote database (the actual implementation of this is outside the
    scope of this recipe). This save process will call the `saveComplete` method when
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: We added a modifier, `@escaping`, just before the closure type definition. This
    tells the compiler that, rather than using the closure within this method, we
    intend to store the closure and use it later. The closure will be *escaping* the
    scope of this method. This modifier is needed to prevent the compiler from doing
    certain optimizations that would be possible if the closure was *nonescaping*.
    It also helps users of this method understand whether the closure they provide
    will be executed immediately, or at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the save operation complete, we can execute the `saveHandler` variable,
    passing in the `success` Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Since we stored the closure as an optional, we need to unwrap it by adding a
    `?` after the variable name. If `saveHandler` has a value, the closure will be
    executed; if it is `nil`, the expression is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a function that takes a closure, let''s see how we call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift provides a more concise way to provide closures to functions. When a
    closure is the last (or only) parameter, Swift allows it to be provided as a **trailing
    closure**. This means the parameter name can be dropped and the closure can be
    specified after the parameter brackets. So, we can rewrite the preceding with
    the following, neater, syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about closures can be found at [http://swiftbook.link/docs/closures](http://swiftbook.link/docs/closures).
  prefs: []
  type: TYPE_NORMAL
- en: Using protocols to define interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Protocols** are a way to describe the interface that a type provides. They
    can be thought of as a contract, defining how you can interact with instances
    of that type. Protocols are a great way to abstract the "what" something does
    from "how" it does it. As we will see in subsequent chapters, Swift adds functionalities
    to protocols, that make them even more useful and powerful than in many other
    programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to build on examples from the previous recipes, but don't worry
    if you haven't followed these recipes yet as all the code you need is listed in
    the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the last recipe, we added a method to our `Person` class that (given the
    full implementation) would save it to a remote database. This is a very useful
    functionality, and as we add more features to our app, there will likely be more
    types that we also want to save to a remote database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a protocol to define how we will interface with anything that can be
    saved in this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Update our `Person` class so that it conforms to the `Saveable` protocol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protocols are defined with the `protocol` keyword, and the implementation is
    contained within curly brackets. As we have seen with other type definitions,
    it is conventional to begin a protocol name with a capital letter. It is also
    convention to name a protocol as either something that the type **is** or something
    that it **does.** In this protocol, we are declaring that any type of implementation
    is **saveable.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Types conforming to this protocol have two parts of the interface to implement.
    Let''s look at the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The `Saveable` protocol declares that anything implementing it needs to have
    a variable called `saveNeeded`, which is a `Bool`. This property will indicate
    that the information held in the remote database is out of date and a save is
    needed. In addition to the usual property declaration, a protocol requires us
    to define whether the property can be accessed (`get`) and changed (`set`), which
    is added in curly brackets after the type declaration. Removing the set keywords
    makes it a read-only variable.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a protocol property as read-only doesn't prevent an implementing type
    from allowing the property to be set, just that the setting of that property isn't
    defined in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of our protocol definition is to describe the method we can
    call to save the information to the remote database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This `func` declaration is exactly the same as other function declarations we
    have seen. However, the implementation of this function, which would have been
    contained in curly brackets, is omitted. Any type conforming to this protocol
    must provide this function and its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our protocol, we need to implement the `Saveable`
    protocol on our `Person` class that we have been using throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Conforming to a protocol looks similar to how a class inherits from another
    class, as we saw earlier in this chapter. The protocol name is added after the
    type name, separated by `:`. By adding this conformance, the compiler will complain
    that our `Person` object doesn''t implement part of the protocol, as we haven''t
    declared a `saveNeeded` property. So let''s add that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: We'll add a default value of `true` since when an instance of this object is
    created, it won't be in the remote database, and so it will need to be saved.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Protocol conformance** can be applied to classes, structs, enums, and even
    other protocols. The benefit of a protocol is that it allows an instance to be
    stored and passed without needing to know how it''s implemented under the hood.
    This provides many benefits, including testing using mock objects and changing
    implementations without changing how and where the implementations are used.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a feature to our app that lets us set a reminder for a contact's birthday,
    which we will also want to save to our remote database.
  prefs: []
  type: TYPE_NORMAL
- en: We can use protocol conformance to give our reminder the same, consistent, save
    functionality interface, even though a reminder may have a very different implementation
    for saving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `Reminder` object and have it conform to the `Saveable` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Our `Reminder` object conforms to `Saveable` and implements all the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We now have two objects that represent very different things and have different
    functionalities, but they both implement `Saveable`, and therefore we can treat
    them in a common way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let''s create an object that will manage the saving
    of information in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `SaveManager` doesn't know the underlying type that
    it is being passed, but it doesn't need to. It receives instances that conform
    to the `Saveable` protocol and therefore can use that interface to save each instance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about protocols can be found at [http://swiftbook.link/docs/protocols](http://swiftbook.link/docs/protocols).
  prefs: []
  type: TYPE_NORMAL
