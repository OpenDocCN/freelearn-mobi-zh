- en: Swift Building Blocks
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Since Apple announced the Swift programming language at WWDC 2014, it has gone
    on to become one of the fastest-growing programming languages. TIOBE is a company
    that measures software quality and publishes a ranking index of programming language
    usage. At the time of writing, Swift ranks as the 11^(th) most popular language
    on this index. This is two places higher than when the first edition of this book
    was written (visit [http://www.tiobe.com/tiobe_index](http://www.tiobe.com/tiobe_index)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Swift is a modern, general-purpose programming language that focuses on type
    safety and expressive and concise syntax. Positioned as a modern replacement for
    Objective-C, it has taken over from that older language as the future of development
    on Apple's platforms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Occupying this niche alone would ensure Swift's place as a useful and important
    programming language. However, Apple's decision to open-source Swift has allowed
    its influence to extend beyond Apple's ecosystem, giving it the potential to be
    used across all platforms and for any scenario.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Since open-sourcing Swift, Apple has provided support for running your Swift
    code on Linux. In the later chapters, we will investigate using a Swift server
    to execute your code. In addition, the Swift Playgrounds iPad app turns your tablet
    into a lightweight **Integrated Development Environment** (**IDE**). Despite these
    alternative ways to use and write Swift code, the simplest is still on a Mac and
    with Apple's Xcode IDE. At the beginning of this book, we will walk through setting
    that up and will then assume that the reader uses this development environment
    unless otherwise stated. Xcode also provides a perfect way to explore the structure
    and syntax of the Swift standard library, foundation, and any other framework
    available for iOS or Mac development in the form of its Playgrounds feature.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: A **Swift Playground** is a simplified environment for executing Swift code.
    For our purposes, playgrounds provide an ideal way to create, run, and understand
    the recipes contained in this book. As such, it will also be assumed that the
    reader is using an Xcode Playground to implement the recipes contained in this
    book, unless otherwise stated.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Swift 5.3 is an important release, adding many language features that are crucial
    for Apple's SwiftUI framework, which we will cover in [Chapter 10](30f08984-5b97-43e0-ad44-ca47f16ca183.xhtml),
    *SwiftUI and Combine Framework*. Swift 5.3 will also be more compatible with future
    versions of Swift, which means that code written now with Swift 5.3 can run alongside
    code written with Swift 6 and beyond. This book will assume that the reader is
    using Swift 5.3; all code will work with this version.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the building blocks of the Swift language,
    examining the syntax and functionality of the basic Swift components that everything
    else is based on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Swift program
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Strings, Ints, Floats, and Bools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwrapping optionals, and force unwrapping
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing code in functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating functionality in object classes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling values into structs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating values with enums
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing around functionality with closures
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using protocols to define interfaces
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this chapter can be found in the book's GitHub repository at
    [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter01)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3rp0DnJ](https://bit.ly/3rp0DnJ)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Swift program
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first recipe, we will set up our development environment and use Swift
    Playgrounds to create our first piece of Swift code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must download and install Apple''s IDE, Xcode, from the Mac App Store:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Mac App Store, either from the Dock or via Spotlight:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d80b47c-9db3-480b-98f5-014ec97e3d5d.png)![](img/0597e1d6-d989-4eb4-a1ec-02aa79c0b850.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – App Store
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for `xcode`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c8c9824-ff65-4884-a7dd-e5a764ee7932.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Searching for xcode
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on GET, followed by Install:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df8c3b4e-8945-42c1-be4a-4df05e1a7676.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Xcode in the App Store
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Xcode is a large download (nearly 8 GB), so this may take a while, depending
    on your internet connection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Once downloaded, open Xcode from the App Store or the Dock:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/668cbb84-bcd0-4ce7-83d7-c4052866c727.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Opening Xcode
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Xcode downloaded, let''s create our first Swift playground:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Launch Xcode from the icon in your Dock.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose Get started with a playground from the welcome screen:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/013a1e9b-cc2a-4754-86ee-2311d18f97b1.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Xcode, new project
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Blank from the iOS tab of the template and then press Next:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/073f1ea6-8648-44d9-beeb-b67572a73feb.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Xcode, selecting the project type
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a name and location for your playground and then press Create:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4df9f9f8-162a-4bec-89ff-2098939bc3ac.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Xcode, saving the project
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Xcode playgrounds can be based on one of the three different Apple platforms:
    **iOS**, **tvOS**, and **macOS**. Playgrounds provide full access to the frameworks
    available to either iOS, tvOS, or macOS, depending on which you choose. An iOS
    playground will be assumed for the entirety of this book, chiefly because this
    is the platform of choice of the author. Where code does have UI components, the
    iOS platform will be used, unless stated otherwise.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now presented with a view that looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0578c3d9-1e83-42d8-b3b5-35c4c58fa758.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Playground – code template
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s replace the word `playground` with `Swift!`. Click on the play icon
    in the bottom left-hand corner of the window to execute the code in the playground:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/53d0ad8a-3abc-4685-9324-0facbb297948.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Playground run/code execution
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just run your first piece of Swift code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side of the window, you will see the output of each line of
    code in the playground. We can see that our line of code has the output `Hello
    Swift!`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7d4f51f-2ede-40d2-9d9c-61b76bf34bf4.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – The "Hello, Swift!" playground
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you put your cursor over the output on the right-hand side, you will see
    two buttons, one that looks like an eye and another that is a rounded square:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4194d53e-3526-4d9f-a460-a4bc94ef9ed0.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Playground, output
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the eye button to get a **Quick Look** box of the output. This isn''t
    particularly useful for a text string, but can be useful for more visual output,
    such as colors and views:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1ee1904-18b8-4bb4-b298-44dcf5fdcfba.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Playground output quick look
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the square button, and a box will be added inline, under your code,
    showing the output of the code. This can be really useful if you want to see how
    the output changes as you change the code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b63b493b-e71b-4d61-a75b-b42710ea2c61.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – Playground, inline output
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will learn more about playgrounds and how we can take them further in [Chapter
    7](f87c71fa-d2b0-44c4-9d33-65f438d69a15.xhtml), *Swift Playgrounds*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Using Strings, Ints, Floats, and Bools
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the core operations in any programming language involve manipulating
    text, numbers, and determining true and false statements. Let's learn how to accomplish
    these operations in Swift by taking a look at its basic types and learning how
    to assign constants and variables. In doing so, we will touch on Swift's static
    typing and mutability system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open a new Swift Playground in Xcode. The previous recipe explains how to do
    this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s run some Swift code that explores the basic types, and then we can walk
    through it step by step:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following into the new playground file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Press the play button at the bottom of the window to run the playground and
    verify that Xcode doesn''t show any errors. Your playground should look like the
    following screenshot, with an output for each line in the timeline on the right-hand
    side and printed values in the console at the bottom:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a28e0de3-63b5-4543-886d-07cfa874b168.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – Playground console output
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's step through the preceding code line by line to understand it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'In this line of code, we are assigning some text to a constant value:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We define a new constant value by using the `let` keyword, and we give that
    constant a name, `phrase`. The colon `:` shows that we want to define what type
    of information we want to store in the constant, and that type is defined after
    the colon. In this case, we want to assign a string (`String` is how most programming
    languages refer to text). The `=` sign indicates that we are assigning a value
    to the constant we have defined, and `"The quick brown fox jumps over the lazy
    dog"` is a `String` literal, which means that it's an easy way to construct a
    string. Any text contained within `""` marks is treated as a `String` literal
    by Swift.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`let`关键字定义一个新的常量值，并给这个常量起一个名字，`phrase`。冒号`:`表示我们想要定义要存储在常量中的信息类型，并且类型定义在冒号之后。在这种情况下，我们想要分配一个字符串（`String`是大多数编程语言对文本的称呼）。等号`=`表示我们正在将值赋给已定义的常量，而`"The
    quick brown fox jumps over the lazy dog"`是一个`String`字面量，这意味着它是一种构建字符串的简单方法。Swift将任何包含在`""`标记内的文本视为`String`字面量。
- en: We are assigning the `String` literal on the right-hand side of the `=` sign
    to the constant on the left-hand side of the `=` sign.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将等号右侧的`String`字面量赋值给等号左侧的常量。
- en: 'Next, we are assigning two more constants, but this time they are of the `Int`
    type, or integers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再赋值两个常量，但这次它们是`Int`类型，即整数：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Rather than assigning a value directly, we can assign the outcome from a mathematical
    expression to the constant. This constant is a `Float`, or floating-point number:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接赋值，我们可以将数学表达式的结果赋给常量。这个常量是一个`Float`，即浮点数：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In other words, it can store fractions rather than integers. Notice that in
    the timeline on the right of this line, the value is displayed as `3.88889`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它可以存储分数而不是整数。注意，在这个行的右侧时序中，值显示为`3.88889`。
- en: 'The `print` function allows us to see the output from any expression printed
    to the console or displayed in the playground:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`函数允许我们查看打印到控制台或显示在游乐场中的任何表达式的输出：'
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will cover functions in a later recipe, but for now, all you need to know
    is that in order to use a function, you type its name (in this case `print`) and
    then enclose any required input to the function within brackets, `()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的菜谱中介绍函数，但到目前为止，你需要知道的是，为了使用一个函数，你输入它的名字（在这个例子中是`print`），然后在括号`()`内包含任何函数所需的输入。
- en: When our code calls this function, the timeline to the right of the code displays
    the output of the statement as `3.88888`, which differs from the line above it.
    The actual value of the mathematical expression we performed is `3.88888888...`
    with an infinite number of 8s. However, the `print` function has rounded this
    up to just five decimal places and rounded it in a different way than the timeline
    for the line above. This potential difference between the true value of a floating-point
    number and how it's represented by the Swift language is important to remember
    when dealing with floats.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码调用这个函数时，代码右侧的时间线显示了该语句的输出为`3.88888`，这与它上面的行不同。我们执行的这个数学表达式的实际值是`3.88888888...`，有无限多个8。然而，`print`函数将其四舍五入到只有五位小数，并且与上面行的时序不同。在处理浮点数时，记住这个真实值与Swift语言表示方式之间的潜在差异是很重要的。
- en: 'Next, you''ll see some lines colored gray:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会看到一些行被涂成灰色：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The playground doesn't produce an output for these lines because they are comments.
    The `/*` syntax before the line of code and the `*/` syntax after the line of
    code denote that this is a comment block, and therefore Swift should ignore anything
    typed in this block.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 游乐场不会为这些行生成输出，因为它们是注释。代码行前的`/*`语法和代码行后的`*/`语法表示这是一个注释块，因此Swift应该忽略这个块中输入的任何内容。
- en: Remove `/*` and `*/` and you'll see that `// Doesn't compile` is still colored
    gray. This is because `//` also denotes a comment. Anything after this, on the
    same line, is also ignored.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`/*`和`*/`，你会看到`// 不编译`仍然是灰色。这是因为`//`也代表注释。同一行上此注释之后的内容也将被忽略。
- en: If you now try and run this code, Xcode will tell you that there is a problem
    with this line, so let's look at the line to determine the issue.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试运行这段代码，Xcode会告诉你这一行存在问题，所以让我们看看这一行以确定问题所在。
- en: On the left-hand side of the `=` sign, we have `phrase`, which we declared earlier,
    and now we are trying to assign a new value to it. We can't do this because we
    defined `phrase` as a constant using the `let` keyword. We should only use `let`
    for things we know will not change. This ability to define something as unchanging,
    or **immutable**, is an important concept in Swift, and we will revisit it in
    later chapters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to define something that can change, we declare it as a variable
    using the `var` keyword:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since `anotherPhrase` is a variable, we can assign a new value to it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Strings in Swift are fully *Unicode-compliant*, so we can have some fun and
    use emojis instead of words. Now, let''s print out the values of our strings to
    see what values they hold:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding lines, we have done the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Defined a string called `phrase`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined a string called `anotherPhrase` as having the same value as `phrase`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the value of `anotherPhrase`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printed the value of `phrase` and `anotherPhrase`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we do this, we see that only `anotherPhrase` prints the new value that
    was assigned, even though the values of `phrase` and `anotherPhrase` were initially
    the same. Although `phrase` and `anotherPhrase` had the same value, they do not
    have an intrinsic connection; so, when `anotherPhrase` is assigned a new value,
    this does not affect `phrase`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings can be easily combined using the `+` operator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This gives the result you would expect; the strings are concatenated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'You will often want to create strings by including values derived from other
    expressions. We can do this with `String` interpolation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The values inserted after `\(` and before `)` can be anything that can be represented
    as a string, including other strings, ints, floats, or expressions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use expressions with string interpolation, such as displaying the
    number of characters in a string:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Strings in Swift are collections, which are containers of elements; in this
    case, a string is a collection of characters. We will cover collections in more
    depth in the next chapter, but for now, it's enough to know that your collections
    can tell you how many elements they contain through their count property. We use
    this to output the number of characters in the phrase.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline string literals can be defined using `"""` at the beginning and end
    of the string:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The contents of the Multiline string must be on a separate line from the start
    and end signifiers. Within a Multiline string literal, you can use single quote
    characters `"` without needing to use an additional escape character, as you would
    with a single-line string literal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean, or `Bool`, values represent either true or false. In the next line,
    we evaluate the value of a Boolean expression and assign the result to the `phrasesAreEqual`
    constant:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the equality operator, `==`, compares the values on its left and right
    and evaluates to `true` if the two values are equal, and `false` otherwise.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, although we assigned `anotherPhrase` the value of `phrase`
    initially, we then assigned a new, different value to `anotherPhrase`; therefore,
    `phrase` and `anotherPhrase` are not equal and the expression assigns the value
    of `false`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Each side of the `==` operator can be any expression that evaluates to match
    the type of the other side, as we do with the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, the character count of `phrase` equals 43\. Since `40 + 3` also
    equals 43, the constant is assigned the value of `true`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During this recipe, we defined a number of constants and variables, and when
    we did this, we also explicitly defined their type. For example, consider the
    following line of Swift code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Swift is a statically typed language. This means any constant or variable that
    we define has to have a specific type, and once defined it cannot be changed to
    a different type. However, in the preceding line of code, the `clearlyAString`
    constant is clearly a string! The right-hand side of the expression is a string
    literal, and therefore we know that the left-hand side will be a string. More
    importantly, the Swift compiler also knows this (a compiler is the program that
    turns Swift code into machine code).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift is all about being concise, so since the type can be inferred by the
    compiler, we do not need to explicitly state it. Instead of the preceding code,
    we can use the following code and it will still run, even though we didn''t specify
    the type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In fact, all the type declarations that we have made so far can be removed!
    So, go back through the code we have already written and remove all type declarations
    (`:String`, `:Int`, `:Float`, and `:Bool`), as they can all be inferred. Run the
    playground to confirm that this is still valid Swift code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Further information regarding these base types in Swift can be found in Apple''s
    documentation of the Swift language:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**Ints, Floats, and Bools**: [http://swiftbook.link/docs/the-basics](http://swiftbook.link/docs/the-basics)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strings and Characters**: [http://swiftbook.link/docs/strings](http://swiftbook.link/docs/strings)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwrapping optionals, and force unwrapping
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world, we don't always know the answer to a question, and problems
    can occur if we assume that we will always know the answer. The same is true in
    programming languages, especially when dealing with external systems that we may
    not control. In many languages, there is no way to call out that we might not
    know a value at any given time. This can lead to either fragile code or lots of
    checks to ensure a value exists before it can be used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The term `nil` or `null` is used by programming languages to denote the absence
    of a value. Note that this is not the same as the number 0 or the empty (zero
    length) string `""`. Swift uses `nil` to indicate the absence of a value. Therefore,
    assigning `nil` to a value will remove any value that is currently assigned.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: With a focus on Swift being type-safe and making it easier to write safe code,
    this ambiguity had to be addressed, and the Swift language does this with something
    called optionals. In this recipe, we will look at what optionals are in Swift,
    and how to handle and use them safely.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the following into a new playground:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you try to run the code, you will see that the compiler has raised an error
    and will not let you assign `nil` to the `dayOfTheWeek` variable. Quite right
    too! The day of the week might change, but there will never not be a current day
    of the week.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: As we declared the type to be `String`, that is what the compiler expects, and
    `nil` is not a string, so it can't be assigned to this variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The same is true even if you remove the type declaration and have the compiler
    infer it, as we did in the preceding recipe. This is because the type is inferred
    at the point the variable is declared, and since it is being assigned a string
    value, the type of `String` is inferred. All other uses of this variable are checked
    against this inferred type of `String`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Delete the last line, as the compiler issue will prevent us from running further
    code in the playground.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will look at a different scenario where it is appropriate to have an optional
    variable. Nick and Finn are playing a game. In each round, Finn will hold his
    hand behind his back and choose a number of fingers to hold up, Nick will guess
    how many fingers it is, and Finn will then show him how many fingers he had chosen
    to hold up.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: To help keep track of the game, Nick stores how many fingers Finn has held up
    in a variable. When Finn shows his hand, Nick can enter a value for the number
    of fingers, but when Finn's hands are behind his back, Nick doesn't know how many
    fingers Finn is holding up, and so can't store a value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enter the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unlike the days of the week example, this code compiles without issues, despite
    the fact that we assign `nil` to the variable. Let's look into why we were able
    to do that.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that there will be times during the game when we don''t know how many
    fingers are being held up, so the variable is optional; it may be an `Int`, or
    it may be `nil`. You will remember from earlier that `nil` does not mean `0`.
    It is entirely possible that Finn may be holding up zero fingers (that is, a clenched
    fist) and this is a valid answer. In this scenario, `nil` represents a lack of
    knowledge regarding the number of fingers. To declare this variable as optional,
    we define the expected type, but with an additional `?`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In Swift, this is referred to as an optionally wrapped `Int`. We have wrapped
    the `Int` type in the concept of being optional. I am emphasizing this term **wrapping**
    because we will need to **unwrap** this optional type later on. At the start of
    the game, we don''t know how many fingers are being held up, so we assign `nil`
    to this variable, which is allowable for optional variables:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once Finn''s hand is shown and we know how many fingers he has held up, we
    can assign that `Int` value to the variable:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦芬恩的手被展示出来，我们知道他举起了多少根手指，我们就可以将那个`Int`值赋给变量：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since the variable type is an optional `Int`, the valid values are either `Int`
    or `nil`; if we try something of another type, we will get a compiler error:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变量类型是可选的`Int`，有效的值要么是`Int`，要么是`nil`；如果我们尝试其他类型的值，我们将得到编译器错误：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we discussed earlier, Swift has a static type system, so the type of variable
    can''t be changed once it is declared. Therefore, although we have assigned a
    value of the `Int` type to the variable, this hasn''t changed the variable type
    to the non-optional `Int`; its type remains `Int?`. Since the type is still optional,
    we can assign it a `nil` value when Finn puts his hands behind his back again:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，Swift有一个静态类型系统，因此一旦声明了变量类型，就不能更改。因此，尽管我们已经将`Int`类型的值赋给了变量，但这并没有改变变量的类型为非可选的`Int`；它的类型仍然是`Int?`。由于类型仍然是可选的，当芬恩再次将手放在背后时，我们可以将其赋值为`nil`：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we print an optional variable, the output tells us that it is optional,
    for example, `Optional(1)`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印一个可选变量时，输出会告诉我们它是可选的，例如，`Optional(1)`：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will notice that the compiler highlights an issue that says Expression
    implicitly coerced from ''Int?'' to ''Any'' on the print line. We see this because
    we are passing an option value to the print comment, which is expecting a non-optional
    value. To solve this issue, we can provide a value to use if our optional value
    happens to be `nil`, and there is a really concise way to do this. The `??` operator
    can be applied after an optional value, and the value to the right of the operator
    will be used if the optional value is `nil`. This is called the **nil coalescing
    operator**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到编译器在打印行上高亮显示了一个问题，说表达式隐式转换为`Int?`到`Any`。我们之所以看到这一点，是因为我们向打印注释传递了一个可选值，而该注释期望一个非可选值。为了解决这个问题，我们可以提供一个值，如果我们的可选值恰好是`nil`，就会使用这个值。这被称为**空值合并运算符**：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At the end of the game, we want to store the number of fingers that Finn held
    up during the last round of the game. Since we know that we will play at least
    one round of the game, we know that there must be a value for the last number
    of fingers that were held up. Therefore, we declare the `lastNumberOfFingersHeldUpByFinn`
    variable as a non-optional `Int`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏结束时，我们希望存储芬恩在游戏最后一轮举起的指数字数。由于我们知道我们将至少玩一局游戏，我们知道必须有一个值代表最后举起的指数字数。因此，我们将`lastNumberOfFingersHeldUpByFinn`变量声明为非可选的`Int`：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, our `numberOfFingersHeldUpByFinn` variable is an optional `Int`, and
    assigning a optional value to a non-optional variable causes a problem for the
    compiler since it can't be sure that it will be assigning a non-nil value. To
    get around this issue, we need to declare that this variable is now non-optional,
    even though we declared it as optional. We do this by adding `!` to the value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的`numberOfFingersHeldUpByFinn`变量是一个可选的`Int`，将可选值赋给非可选变量会导致编译器出现问题，因为它不能确定它将分配一个非空值。为了解决这个问题，我们需要声明这个变量现在是非可选的，尽管我们将其声明为可选的。我们通过在值后添加`!`来实现这一点。
- en: 'If you remove `!` from the preceding statement, the compiler will complain:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从前面的语句中移除`!`，编译器将抱怨：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In Swift terminology, by adding `!`, we are unwrapping the optional variable.
    Once it is unwrapped, and therefore non-optional, we can assign it to the `lastNumberOfFingersHeldUpByFinn`
    variable, which is also non-optional.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift术语中，通过添加`!`，我们正在解包可选变量。一旦它被解包，因此不再是可选的，我们就可以将其赋给`lastNumberOfFingersHeldUpByFinn`变量，这个变量也不是可选的。
- en: Beware! Use of this forced unwrapping can be risky. When you forcibly unwrap
    an optional, you are declaring that you are sure that there will be a value in
    that variable at that point in the execution of the code. However, if the variable
    is `nil`, you will get an error while your code is running and the execution will
    terminate. If this code is running in an app, then the app will crash. We will
    see safer ways to unwrap an optional value in the later chapters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！使用这种强制解包可能很危险。当你强制解包一个可选变量时，你是在声明你确信在该代码执行的该点变量中有一个值。然而，如果变量是`nil`，你的代码运行时将出现错误，并且执行将终止。如果这段代码在一个应用程序中运行，那么应用程序将崩溃。我们将在后面的章节中看到更安全地解包可选值的方法。
- en: 'Let''s see what happens when we forcibly unwrap a variable that is set to `nil`.
    Imagine that we ended the game before playing the first round:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code will compile and run, but will crash at runtime because at the point
    that `numberOfFingersHeldUpByFinn` is assigned to `lastNumberOfFingersHeldUpByFinn`,
    the value of `numberOfFingersHeldUpByFinn` is `nil`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen non-optional variables, where a value of the correct type
    must be provided, and optional variables, where the value can either be the underlying
    type or `nil`. In a perfect world, this would be all we need. However, we may
    need to declare a variable that should be treated as non-optional, even if we
    don't know the value at the time it is declared. For these situations, we can
    declare a variable as an **implicitly unwrapped optional** (**IUO**) in Swift.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code in the playground:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, we have declared a person's legal name, which is used
    at many points during their life, such as when registering for educational institutions.
    It can be changed, either by legal request or through marriage, and yet you would
    never expect someone's legal name to not exist. However, that is exactly what
    happens when someone is born! When a person is born, they don't have a legal name
    until their birth is registered. So, if we were trying to model this in code,
    a person's legal name could be represented as an **IUO**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, we declare a variable to be an IUO by placing a `!` sign after the
    type:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: IUOs present the same risk as forced unwrapping. You are promising that the
    variable has a value, even though it is possible that it could be `nil`. Although
    it's possible for the variable to be `nil`, when something tries to access it,
    a value will be there. If the variable is accessed, but doesn't contain a value,
    the execution will terminate and your app will crash.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some subtlety to how IUOs behave when they are assigned to other variables
    and the type is inferred. It''s easiest to illustrate this with code, so enter
    the following into a playground:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When an IUO is assigned to a new variable, the compiler can't be sure that there
    is a non-nil value assigned. So, if an IUO is assigned to a new variable, as is
    the case with `output1` here, the compiler plays it safe and infers that the type
    of this new variable is an optional. If, however, the value of the IUO has been
    unwrapped, then the compiler knows that it has a non-nil value, and will infer
    a non-optional type. When assigning `output2`, the value of the input is unwrapped
    in order to add `1` to it. Therefore, the type of `output2` is inferred to be
    the non-optional `Int`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information regarding optionals can be found at [http://swiftbook.link/docs/the-basics](http://swiftbook.link/docs/the-basics).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code in functions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functions** are a building block of almost all programming languages, allowing
    functionality to be defined and reused. Swift''s syntax provides an expressive
    way to define your functions, creating concise and readable code. In this recipe,
    we will run through the different types of functions we can create, and understand
    how to define and use them.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**是几乎所有编程语言的基础构建块，允许定义和重用功能。Swift的语法提供了一种表达性强的方式来定义你的函数，创建简洁且易于阅读的代码。在本食谱中，我们将遍历我们可以创建的不同类型的函数，并了解如何定义和使用它们。'
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s look at how functions are defined in Swift:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Swift中定义函数：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s look at this in more detail to see how a function is defined:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看函数是如何定义的：
- en: '`func`: This indicates that you are declaring a function.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`: 这表示你正在声明一个函数。'
- en: '`nameOfFunction`: This will be the name of your function and, by convention,
    is written in camel case (this means that each word, apart from the first, is
    capitalized and all spaces are removed). This should describe what the function
    does, and should provide some context to the value returned by the function, if
    one is returned. This will be how you will invoke the method from elsewhere in
    your code, so bear that in mind when naming it.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameOfFunction`: 这将是你的函数名称，并且按照惯例，使用驼峰式命名法（这意味着除了第一个单词外，每个单词的首字母都大写，并且所有空格都被删除）。这应该描述函数的功能，并提供一些上下文，以说明函数返回的值（如果有的话）。这将是你从代码的其他部分调用方法的方式，因此在命名时请记住这一点。'
- en: '`parameterLabel1 parameter1: ParameterType1`: This is the first input, or parameter,
    into the function. You can specify as many parameters as you like, separated by
    commas. Each parameter has a parameter name (`parameter1`) and type (`ParameterType1`).
    The parameter name is how the value of the parameter will be made available to
    your function''s implementation. You can optionally provide a parameter label
    in front of the parameter name (`parameterLabel1` ) that will be used to label
    the parameter when your function is used (at the call site).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameterLabel1 parameter1: ParameterType1`: 这是函数的第一个输入，或参数。你可以指定任意多的参数，用逗号分隔。每个参数都有一个参数名（`parameter1`）和类型（`ParameterType1`）。参数名是参数值将如何提供给函数实现的方式。你可以选择性地在参数名前提供参数标签（`parameterLabel1`），当你的函数被使用时（在调用点），它将用于标记参数。'
- en: '`-> OutputType`: This indicates that the function returns a value and indicates
    the type of that value. If no value is returned, this can be omitted.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-> OutputType`: 这表示该函数返回一个值，并指示该值的类型。如果没有返回值，则可以省略。'
- en: '`{ }`: The curly brackets indicate the start and end of the function''s implementation;
    anything within them will be executed when the function is called.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ }`: 大括号表示函数实现的开始和结束；当函数被调用时，其中的任何内容都将被执行。'
- en: '`return output`: If the function returns a value, you type `return` and then
    the value to return. This ends the execution of the function; any code written
    after the return statement is not executed.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return output`: 如果函数返回一个值，你输入`return`然后是返回的值。这结束了函数的执行；任何在返回语句之后编写的代码都不会被执行。'
- en: Now, let's put this into action.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其付诸实践。
- en: 'Imagine that we are building a contacts app to hold the details of your family
    and friends, and we want to create a string of a contact''s full name. Let''s
    explore some of the ways in which functions can be used:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在构建一个联系人应用程序来保存你家人和朋友的详细信息，我们想要创建一个联系人的全名字符串。让我们探索一些函数可以使用的不同方式：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding function takes three string parameters and outputs a string that
    puts all these together with spaces in between. The only thing this function does
    is take inputs and produce an output without causing any side effects; this type
    of function is often called a **pure function**. To call this function, we enter
    the name of the function followed by the input parameters within `()` brackets,
    where each parameter value is preceded by its label:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数接受三个字符串参数，并输出一个字符串，将这些参数组合在一起，并在它们之间添加空格。这个函数唯一做的事情就是接受输入并产生输出，而不产生任何副作用；这种类型的函数通常被称为**纯函数**。要调用此函数，我们输入函数名称，然后在括号`()`内输入输入参数，其中每个参数值前面都跟着它的标签：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Functions with multiple parameters can get quite long, so to help with readability,
    the parameters can be placed on separate lines, as in the preceding example. This
    is true for both the definition of a function and when it is called. The convention
    is to align the start of the parameter name with the first parameter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Since the function returns a value, we can assign the output of this function
    to a constant or a variable, just like any other expression.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function takes the same input parameters, but its purpose is not to
    return a value. Instead, it prints out the parameters as one string separated
    by spaces:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can call this function in the same way as the preceding function, although
    it can''t be assigned to anything since it doesn''t have a return value:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following function takes no parameters as everything it needs to perform
    its task is contained within it, although it does output a string. This function
    calls the `fullName` function we defined earlier, taking advantage of its ability
    to produce a full name when given the component names. Reusing functionality is
    the most useful feature that functions provide:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since `authorsFullName` takes no parameters, we can execute it by entering
    the function name followed by empty brackets, `()`, and since it returns a value,
    we can assign the outcome of `authorsFullName` to a variable:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our final example takes no parameters and returns no value:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can call this function in the same way as the previous functions with no
    parameters, and there is no return value to assign:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see from the preceding example, having input parameters and providing
    an output value are not required when defining a function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's look at a couple of ways of making your use of functions more expressive
    and concise.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Default parameter values
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One convenience in Swift is the ability to specify default values for parameters.
    These allow you to omit the parameter when calling, as the default value will
    be provided instead. Let's use the same example as earlier in this recipe, where
    we are creating a contact app to hold information about our family and friends.
    Many of your family members are likely to have the same family name as you, so
    we can set the family name as the default value for that parameter. Therefore,
    the family name only needs to be provided if it is different from the default.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into a playground:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Defining a default value looks similar to assigning a value to the `familyName:
    String = "Moon"` parameter. When calling the function, the parameter with the
    default value does not have to be given:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Parameter overloading
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift supports parameter overloading, which allows for functions to have the
    same name and only be differentiated by the parameters that they take.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn more about parameter overloading by entering the following code
    into a playground:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Both the preceding functions have the name `combine`, but one takes two strings
    as parameters, and the other takes two Ints. Therefore, when we call the function,
    Swift knows which implementation we intended by the values we pass as parameters.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个函数都名为 `combine`，但一个接受两个字符串作为参数，另一个接受两个 Int。因此，当我们调用函数时，Swift 通过我们传递的参数值知道我们想要哪个实现。
- en: 'We''ve introduced something new in the preceding function declarations, anonymous
    parameter labels: `_ givenName: String`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的函数声明中，我们引入了新的内容，匿名参数标签：`_ givenName: String`。'
- en: When we declare the parameters, we use an underscore, `_`, for the parameter
    label. This indicates that we don't want a parameter name shown when calling the
    function. This should only be used if the purpose of the parameters is clear without
    the labels.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明参数时，我们使用下划线 `_` 作为参数标签。这表示我们不想在调用函数时显示参数名称。这应该只在参数的目的无需标签即可清楚时使用。
- en: See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about functions can be found at [http://swiftbook.link/docs/functions](http://swiftbook.link/docs/functions).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数的更多信息可以在 [http://swiftbook.link/docs/functions](http://swiftbook.link/docs/functions)
    找到。
- en: Encapsulating functionality in object classes
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对象类中封装功能
- en: '**Object-oriented programming** is a common and powerful programming paradigm.
    At its core is the *object class*. Objects allow us to encapsulate data and functionality,
    which can then be stored and passed around.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**是一种常见且强大的编程范式。其核心是*对象类*。对象允许我们封装数据和功能，然后可以存储和传递。'
- en: In this recipe, we will build some class objects, break down their components,
    and understand how they are defined and used.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一些类对象，分解它们的组件，并了解它们是如何定义和使用的。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s write some code to create and use class objects, and then we will walk
    through what the code is doing:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来创建和使用类对象，然后我们将逐步分析代码在做什么：
- en: 'First, create a `Person` class object:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 `Person` 类对象：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Within the curly brackets, `{` and `}`, add three constants representing the
    person''s name, and one variable representing their country of residence:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在花括号 `{` 和 `}` 内，添加三个代表人名的常量，以及一个代表他们居住国的变量：
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Below the properties, but still within the curly brackets, add an initialization
    method for our `Person` object:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性下方，但仍在花括号内，为我们的 `Person` 对象添加一个初始化方法：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, add a variable as a property of the class, with a computed value:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个变量作为类的属性，具有计算值：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a function within the `Person` object that returns the person''s full name:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person` 对象内添加一个函数，该函数返回人的全名：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, create a `Friend` object that extends the functionality of the `Person`
    object:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个扩展 `Person` 对象功能的 `Friend` 对象：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Within the `Friend` class object, add a variable property to hold details of
    where the user met the friend, and override the display string property to customize
    its behavior for `Friend` objects:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Friend` 类对象内部，添加一个变量属性来保存用户遇见朋友的位置详情，并重写显示字符串属性以自定义 `Friend` 对象的行为：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In addition to the `Friend` object, create a `Family` object that extends the
    functionality of the `Person` object:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了 `Friend` 对象外，创建一个扩展 `Person` 对象功能的 `Family` 对象：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a relationship property to our `Family` object and create an initializer
    method to populate it in addition to the other properties from `Person`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的 `Family` 对象添加一个关系属性，并创建一个初始化方法来填充它，除了来自 `Person` 的其他属性：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Give the `Family` object a custom `displayString` method that includes the
    value of the `relationship` property by adding this code within the `Family` object
    definition (within the curly brackets):'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给 `Family` 对象一个自定义的 `displayString` 方法，通过在 `Family` 对象定义内（在花括号内）添加此代码来包含 `relationship`
    属性的值：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Lastly, create instances of our new objects and print the display string to
    see how its value differs:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建我们新对象的实例，并打印显示字符串以查看其值如何不同：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Classes are defined with the `class` keyword. Class names start with a capital
    letter by convention, and the implementation of the class is contained, or "scoped",
    within curly brackets:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用 `class` 关键字定义。按照惯例，类名以大写字母开头，类的实现包含在或“范围”在花括号内：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'An object can have property values, which are contained within the object.
    These properties can have initial values, as `countryOfResidence` does in the
    following code, although bear in mind that constants (defined with `let`) cannot
    be changed once the initial value has been set:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以具有属性值，这些值包含在对象内部。这些属性可以有初始值，就像以下代码中的 `countryOfResidence` 一样，尽管请注意，一旦设置了初始值，常量（使用
    `let` 定义）就不能更改：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If your class were to just have the preceding property definitions, the compiler
    would raise a warning, as `givenName`, `middleName`, and `familyName` are defined
    as non-optional strings, but we have not provided any way to populate those values.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的类只包含前面的属性定义，编译器会发出警告，因为 `givenName`、`middleName` 和 `familyName` 被定义为非可选字符串，但我们没有提供任何填充这些值的方法。
- en: 'The compiler needs to know how the object will be initialized so that we can
    be sure that all the non-optional properties will indeed have values:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器需要知道对象如何初始化，这样我们就可以确保所有非可选属性确实有值：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`init` is a special method (functions defined within objects are called methods)
    that''s called when the object is initialized. In the `Person` object of the preceding
    code, `givenName`, `middleName`, and `familyName` must be passed in when the object
    is initialized, and we assign those provided values to the object''s properties.
    The `self.` prefix is used to differentiate between the property and the value
    passed in, as they have the same name.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 是一个特殊的方法（在对象内部定义的函数称为方法），当对象被初始化时会被调用。在前面的 `Person` 对象中，初始化对象时必须传入 `givenName`、`middleName`
    和 `familyName`，我们将这些提供的值赋给对象的属性。使用 `self.` 前缀来区分属性和传入的值，因为它们具有相同的名称。'
- en: 'We do not need to pass in a value for `countryOfResidence` as this has an initial
    value. This isn''t ideal, though, as when we create a `Person` object, it will
    always have the `countryOfResidence` variable set to `"UK"`, and we will then
    have to change that value, if different, after initialization. Another way to
    do this would be to use a default parameter value, as seen in the previous recipe.
    Amend the `Person` object initialization to the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `countryOfResidence` 有一个初始值，我们不需要为它传入一个值。但这并不是最佳做法，因为当我们创建一个 `Person` 对象时，它总是会将
    `countryOfResidence` 变量设置为 `"UK"`，然后我们可能需要在初始化后更改该值。另一种方法是使用默认参数值，如前一个食谱中所示。将
    `Person` 对象的初始化修改如下：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, you can provide a country of residence in the initialization or omit it
    to use the default value.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在初始化时提供一个居住国家，或者省略它以使用默认值。
- en: 'Next, let''s look at the `displayString` property of our `Person` class:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `Person` 类的 `displayString` 属性：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This property declaration is different from the others. Rather than having a
    value assigned to it, it is followed by an expression contained within curly braces.
    This is a computed property; its value is not static but is determined by the
    given expression every time the property is accessed. Any valid expressions can
    be used to compute the property, but must return a value that matches the declared
    type of the property. The compiler will enforce this, and you can't omit the variable
    type for computed properties.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性声明与其他的不同。它不是直接分配一个值，而是后面跟着一个包含在大括号内的表达式。这是一个计算属性；它的值不是静态的，而是在每次访问属性时由给定的表达式确定。任何有效的表达式都可以用来计算属性，但必须返回一个与属性声明的类型匹配的值。编译器将强制执行这一点，你不能省略计算属性的变量类型。
- en: 'In constructing the return value above, we use `self.fullName()` and `self.countryOfResidence`.
    As we did in the preceding `init` method, we use `self.` to show that we are accessing
    the method and property of the current instance of the `Person` object. However,
    since `displayString` is already a property on the current instance, the Swift
    compiler is aware of this context and so those self references can be removed:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建上面的返回值时，我们使用了 `self.fullName()` 和 `self.countryOfResidence`。正如我们在前面的 `init`
    方法中所做的那样，我们使用 `self.` 来表明我们正在访问 `Person` 对象当前实例的方法和属性。然而，由于 `displayString` 已经是当前实例上的一个属性，Swift
    编译器已经知道这个上下文，因此可以省略这些 self 引用：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Objects can do work based on the information they contain, and this work can
    be defined in methods. Methods are just functions that are contained within classes
    and have access to all the object''s properties. The `Person` object''s `fullName`
    method is an example of this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以根据它们包含的信息执行工作，并且这项工作可以在方法中定义。方法只是包含在类中的函数，并且可以访问对象的所有属性。`Person` 对象的 `fullName`
    方法就是这样一个例子：
- en: '[PRE61]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: All the abilities of a function are available, which we explored in the last
    recipe, including optional inputs and outputs, default parameter values, and parameter
    overloading.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Having defined a `Person` object, we want to extend the concept of `Person`
    to define a friend. A friend is also a person, so it stands to reason that anything
    a `Person` object can do, a `Friend` object can also do. We model this inherited
    behavior by defining `Friend` as a subclass of `Person`. We define the class that
    our `Friend` class inherits from (called the "superclass"), after the class name,
    separated by `:`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: By inheriting from `Person`, our `Friend` object inherits all the properties
    and methods from its superclass. We can then add any extra functionality we require.
    In this case, we add a property for details of where we met this friend.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The `final` prefix tells the compiler that we don't intend for this class to
    be subclassed; it is the final class in the inheritance hierarchy. This allows
    the compiler to make some optimizations as it knows it won't be extended.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to implementing new functionalities, we can override functionalities
    from the superclass using the `override` keyword:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding code, we override the `displayString` computed property from
    `Person` as we want to add the "where we met" information. Within the computed
    property, we can access the superclass's implementation by calling `super.`, and
    then referencing the property or method.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at how we can customize how our subclasses are initialized:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Our `Family` class also inherits from `Person`, but we want to add a `relationship`
    property, which should form part of the initialization, so we can declare a new
    `init` that also takes a relationship string value. That passed-in value is then
    assigned to the `relationship` property because the superclass's initializer is
    called.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses must have all their non-optional properties assigned a value before
    the superclass's `init` method is called. If we had forgotten to assign a value
    to `relationship`, or we had assigned it after calling `super.init`, then our
    code would not compile.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'With all our class objects defined, we can create instances of these objects
    and call methods and access properties of these objects:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To create an instance of an object, we use the name of the object like a function,
    passing in any required parameters. This returns an object instance that we can
    then assign to a constant or variable.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating an instance, we are actually calling the object''s `init` method,
    and you can do this explicitly, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: However, to be concise, this is usually omitted.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Class objects are **reference types**, which is a term that refers to the way
    they are stored and referenced internally. To see how these reference type semantics
    work, let''s look at how an object behaves when it is modified:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We defined a `MovieReview` class object, created an instance of that `MovieReview`
    object, and then assigned that review to two separate constants. As a class object
    is a reference type, it is a reference to the object that is stored in the constant,
    rather than a new copy of the object. Therefore, when we reconsider our review
    to give *The Shawshank Redemption* five stars (and rightly so!), we are changing
    the underlying object. All references that access that underlying object will
    receive the updated value when the `starRating` property is accessed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`MovieReview`类对象，创建了这个`MovieReview`对象的实例，然后将这个评论分配给了两个不同的常量。由于类对象是引用类型，它是对存储在常量中的对象的引用，而不是对象的新副本。因此，当我们重新考虑我们的评论，给《肖申克的救赎》五星（并且理应如此！）时，我们是在更改底层对象。当访问`starRating`属性时，所有访问该底层对象的引用都将接收到更新后的值。
- en: See also
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Further information about classes can be found at [http://swiftbook.link/docs/classes-and-structures](http://swiftbook.link/docs/classes-and-structures).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于类和结构体的信息可以在[http://swiftbook.link/docs/classes-and-structures](http://swiftbook.link/docs/classes-and-structures)找到。
- en: In [Chapter 9](f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml), *Performance and
    Responsiveness in Swift*, we will examine reference semantics in more detail,
    and see how this affects performance.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml)，“Swift中的性能和响应性”，我们将更详细地探讨引用语义，并看看它如何影响性能。
- en: Bundling values into structs
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将值捆绑到结构体中
- en: Class objects are great for encapsulating data and functionality within a unifying
    concept, such as a person, as they allow individual instances to be referenced.
    However, not everything is an object. We may need to represent data that is logically
    grouped together, but there isn't much more than that. It's **not** more than
    the sum of its parts; it is the sum of its parts.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 类对象非常适合封装与统一概念（如人）相关的数据和功能，因为它们允许引用单个实例。然而，并非所有事物都是对象。我们可能需要表示逻辑上分组在一起的数据，但除此之外没有更多。它**不是**其部分的简单总和；它是其部分的总和。
- en: For this, there are **structs**. Short for structures, structs can be found
    in many programming languages. Structs are **value types**, as opposed to classes,
    which are reference types, and, as such, behave differently when passed around.
    In this recipe, we will learn how structs work in Swift, and when and how to use
    them.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，有**结构体**。简称为结构体，结构体可以在许多编程语言中找到。与类（引用类型）相对，结构体是**值类型**，当传递时行为不同。在这个食谱中，我们将学习Swift中的结构体是如何工作的，以及何时以及如何使用它们。
- en: Getting ready
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will build on top of the previous recipe, so open the playground
    you have used for the previous recipe. Don't worry if you didn't work through
    the previous recipe, as this one will contain all the code you need.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将在上一个食谱的基础上构建，所以请打开你之前用于上一个食谱的游乐场。如果你没有完成上一个食谱，不要担心，因为这个食谱将包含你需要的所有代码。
- en: How to do it...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have already defined a `Person` object as having three separate string properties
    relating to the person''s name. However, these three separate strings don''t exist
    in isolation from each other, as together they define a person''s name. Currently,
    if you wanted to retrieve a person''s name, you have to access three separate
    properties and combine them. Let''s tidy this up by defining a person''s name
    as its own struct:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个`Person`对象，它有三个与人的名字相关的独立字符串属性。然而，这三个独立的字符串并不是孤立存在的，因为它们共同定义了一个人的名字。目前，如果你想检索一个人的名字，你必须访问三个独立的属性并将它们组合起来。让我们通过定义一个人的名字为其自己的结构体来整理一下：
- en: 'Create a struct called `PersonName`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PersonName`的结构体：
- en: '[PRE68]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add three properties to `PersonName`, for `givenName`, `middleName` and `familyName`.
    Make the first two constants, and the last one a variable, as a family name can
    change:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`PersonName`添加三个属性：`givenName`、`middleName`和`familyName`。将前两个设置为常量，最后一个设置为变量，因为姓氏可能会改变：
- en: '[PRE69]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add a method to combine the three properties into a `fullName` string:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法将三个属性组合成一个`fullName`字符串：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Provide a method to change the family name property and prefix this method
    with the `mutating` keyword:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个方法来更改姓氏属性，并在该方法前加上`mutating`关键字：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create a person name, passing in the property values:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含属性值的个人名称：
- en: '[PRE72]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Defining a struct is very similar to defining an object class, and that is intentional.
    Much of the functionality available to a class is also available to a struct.
    Therefore, you will notice that aside from using the `struct` keyword instead
    of `class`, the definition of a class and a struct are almost identical.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Within the `PersonName` struct, we have properties for the three components
    of the name and the `fullName` method we saw earlier to combine the three name
    components into a full name string.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'The method we created to change the family name property has a new keyword
    that we haven''t seen before, `mutating`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This keyword must be added to any method in a struct that changes a property
    of the struct. This keyword is to inform anyone using the method that it will
    change, or "mutate", the struct. Unlike class objects, when you mutate a struct,
    you create a copy of the struct with the changed properties. This behavior is
    known as **value-type semantics**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let''s first create a struct and then check that it
    behaves as we expect when we assign it to different values:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: So far, so good. We have created a `PersonName` struct, assigned it to a constant
    called `alissasBirthName`, and then assigned that constant to a variable called
    `alissasCurrentName`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see what happens when we mutate `alissasCurrentName`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When we call the mutating method on the `alissasCurrentName` variable, only
    that variable is changed. This change is not reflected in `alissasBirthName`,
    even though these structs were once the same. This behavior would be different
    if `PersonName` was an object class, and we explored that behavior in the previous
    recipe.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use how this value-type behavior interacts with constants and variables
    to restrict unintended changes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, first, let''s amend our `Person` class to our new `PersonName`
    struct:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We've added the `birthName` and `currentName` properties of our new `PersonName`
    struct type, and we initiate them with the same value when the `Person` object
    is created. Since a person's birth name won't change, we define it as a constant,
    but their current name can change, so it's defined as a variable.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new `Person` object:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Since our `PersonName` struct has value semantics, we can use this to enforce
    the behavior that we expect our model to have. We would expect to not be able
    to change a person's birth name, and if you try, you will find that the compiler
    won't let you.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed earlier, changing the family name mutates the struct, and so
    a new copy is made. However, we defined `birthName` as a constant, which can''t
    be changed, so the only way we would be able to change the family name would be
    to change our definition of `birthName` from `let` to `var`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When we change `currentName` to have a new family name, which we can do since
    we defined it as a `var`, it changes the `currentName` property, but not the `birthName`
    property, even though these were assigned with the same value:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We have used a combination of objects and structs to create a model that enforces
    our expected behavior. This technique can help to reduce potential bugs in our
    code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about structs can be found at [http://swiftbook.link/docs/classes-and-structures](http://swiftbook.link/docs/classes-and-structures).
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 9](f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml), *Performance and
    Responsiveness in Swift*, we will examine value semantics in more detail, and
    see how it affects performance.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating values with enums
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enumerations** are a programming construct that lets you define a value type
    with a finite set of options. Most programming languages have enumerations (usually
    abbreviated to **enums**), although the Swift language takes the concept further
    than most.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an enum from the iOS/macOS SDK is `ComparisonResult`, which you
    would use when sorting items. When comparing for the purposes of sorting, there
    are only three possible results from a comparison:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '`ascending`: The items are ordered in ascending order.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`descending`: The items are ordered in descending order.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`same`: The items are the same.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a finite number of possible options for a comparison result; therefore,
    it''s a perfect candidate for being represented by an enum:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Swift takes the enum concept and elevates it to a first-class type. As we will
    see, this makes enums a very powerful tool for modeling your information.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will examine how and when to use enums in Swift.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will build on top of the earlier recipes, so open the playground
    you have used for the previous recipes. Don't worry if you haven't tried out the
    previous recipes, as this one will contain all the code you need.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Encapsulating functionality in object classes* recipe, we created a
    `Person` object to represent people in our model and, in the *Bundling values
    into structs* recipe, we made a `PersonName` struct to hold information about
    a person's name. Now, let's turn our attention to a person's title (for example,
    Mr, Mrs), which precedes someone's full name. There are a small and finite number
    of common titles that a person may have; therefore an enum is a great way to model
    this information.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an enum to represent a person''s title:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We define our enumeration with the `enum` keyword and provide a name for the
    enum. As with classes and structs, the convention is that this starts with a capital
    letter, and the implementation is defined within curly brackets. We define each
    enum option with the `case` keyword, and, by convention, these start with a lowercase
    character.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the `mr` case of our `Title` enum to a value:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Enums can be assigned by specifying the enum type, then a dot, and then the
    case. However, if the compiler can infer the enum type, we can omit the type and
    just provide the case, preceded by a dot.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a constant value, of the `Title` type, and then assign a case to it
    with the type inferred:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many programming languages, including C and Objective-C, enums are defined
    as a type definition on top of an integer, with each case being given a defined
    integer value. In Swift, enums do not need to represent integers under the hood.
    In fact, they do not need to be backed by any type and can exist as their own
    abstract concepts. Consider the following example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: It doesn't make sense to map the compass points as integers, and in Swift we
    don't have to.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can define multiple cases on the same line by separating them with
    commas.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Title` also, an integer-based enum doesn''t seem appropriate; however,
    a string-based one may be. So, let''s declare our enum to be string-based:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The enum''s raw underlying type is declared after its name and a `:` separator.
    The raw types that can be used to back the enum are limited to types that can
    be represented as a literal. This includes the following Swift base types:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '`String`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float`'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bool`'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types can be used to back an enum because they conform to a protocol,
    called `RawRepresentable`. We will cover protocols later in the chapter.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Cases can be assigned a value of the raw type; however, certain types can be
    inferred, and so do not need to be explicitly declared. For int-backed enums,
    the inferred values are sequentially assigned starting at `0`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: For string-based enums, the inferred value is the name of the case, so the `other`
    case in our `Title` enum is inferred to be `other`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the underlying value of the enum in its raw type by accessing its
    `rawValue` property:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: There's more...
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the introduction to this recipe, Swift treats enums as a first-class
    type, and therefore they can have functionality that is not available to enums
    in most programming languages. This includes having computed variables and methods.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Methods and computed variables
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s imagine that it is important for us to know whether a person''s title
    relates to a professional qualification that the person holds. Let''s add a method
    to our enum to provide that information:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: For the list of titles that we have defined, `Dr` and `Prof` relate to professional
    qualifications, so we have our method return `true` if `self` (the instance of
    the enum type this method is called on) is equal to the `dr` case, or equal to
    the `prof` case.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: In defining this method, we used `||`, which is the OR logical operator. Using
    this operator returns a `true` Bool value if the expression on the left-hand side
    evaluates to `true` OR the expression on the right-hand side evaluates to `true`.
    Another useful common operator to know is the AND operator, `&&`, but this is
    not appropriate for this method.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality feels more appropriate as a computed property since whether
    it `isProfessional` or not is intrinsic to the enum itself, and we don''t need
    to do much work to determine the answer. So, let''s change this into a property:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, we can determine whether a title is a professional title by accessing
    the computed property on it:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We can't store any additional information on an enum, over and above the enum
    value itself, but being able to define methods and computed properties that provide
    extra information about the enum is a really powerful option.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Associated values
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our string-based enum seems perfect for our title information, except that we
    have a case called `other`. If the person has a title that we hadn't considered
    when defining the enum, we can choose `other`, but that doesn't capture what the
    other title is. In our model, we would need to define another property to hold
    the value given for `other`, but that splits our definition of title over two
    separate properties, which could cause an unintended combination of values.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Swift enums have a solution for this situation, **associated values**. We can
    choose to associate a value with each enum case, allowing us to bind a non-optional
    string to our `other` case.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our `Title` enum to use an associated value:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We have defined the `other` case to have an associated value by putting the
    value's type in brackets after the case declaration. We do not need to add associated
    values for every case. Each case declaration can have associated values of different
    types or none at all.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Enums containing associated values cannot have a raw type as they are now too
    complex to be represented by one of these base types, so our `Title` enum is no
    longer string-based.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at how we assign an enum case with an associated type:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The associated value is declared in brackets after the case, and the compiler
    enforces that the type matches the type declared in our enum definition. As we
    declared the `other` case to have a non-optional string, we are ensuring that
    a title of `other` cannot be chosen without providing details of what the other
    title is, and we don't need another property to fully represent `Title` in our
    model.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about enums can be found at [http://swiftbook.link/docs/enums](http://swiftbook.link/docs/enums).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Passing around functionality with closures
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Closures** are also referred to as **anonymous functions**, and this is the
    best way to explain them. Closures are functions without a name and, like other
    functions, they can take a set of input parameters and can return an output. Closures
    behave like other primary types. They can be assigned, stored, passed around,
    and used as input and output to functions and other closures.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how and when to use closures in our code.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue to build on our contacts app example from earlier in this chapter,
    so you should use the same playground as in the previous recipes.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, you are implementing this in a new playground, first add the relevant
    code from the previous recipes:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: For explanations of how this code works, please refer to the previous recipes
    in this chapter.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s define a number of types of closures, which we will then work through
    step by step:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a closure to print this author''s details that takes no input and returns
    no output:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Define a closure that creates a `Person` object. The closure takes no input,
    but returns a `Person` object as the output:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Define a closure that prints a person''s details, taking the three components
    of their name as `String` inputs, but returning no output:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Lastly, define a closure to create a person, taking the three name components
    as string inputs and returning a `Person` object as the output:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works...
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the different types of closures we just implemented:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As a first-class type in Swift, closures can be assigned to constants or variables,
    and constants and variables need a type. To define a closure's type, we need to
    specify the input parameter types and the output type, and for the closure in
    the preceding code, the type is `() -> Void`. The `Void` type is another way of
    saying "nothing", so this closure takes no inputs and returns nothing, and the
    closure's functionality is defined within the curly brackets, as with other functions.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this closure defined and assigned to the `printAuthorsDetails`
    constant, we can execute it like other functions, but with the variable name,
    instead of the function''s name. With this closure, that will cause this author''s
    details to be printed:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The next closure type takes no input parameters, but returns a `Person` object,
    as you can see with the `() -> Person` type definition:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Since it has an output, the execution of the closure returns a value that can
    be assigned to a variable or constant. In the preceding code, we execute the `createAuthor`
    closure and assign the output to the `author` constant. Since we defined the closure
    type as `() -> Person`, the compiler knows that the output type is a `Person`,
    and so the type of constant can be inferred. Since we don''t need to declare it
    explicitly, let''s remove the type declaration:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, let''s take a look at a closure that takes input parameters:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You will remember, from the recipe on functions, that we can define parameter
    labels, which determine how the parameters are referenced when the function is
    used, and parameter names, which define how the parameter is referenced from within
    the function. In closures, these are defined a bit differently:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter labels cannot be defined for closures, so, when calling a closure,
    the order and parameter type have to be used to determine what values should be
    provided as parameters:'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Parameter names are defined inside the curly brackets, followed by the `in`
    keyword:'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Putting it all together, we can define and execute a closure with inputs and
    an output, as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: There's more...
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen how we can store closures, but we can also use them as method parameters.
    This pattern can be really useful when we want to be notified when a long-running
    task is completed.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we want to save the details of our `Person` object to a remote
    database, maybe for backup or use on other devices. We may want to be notified
    when this process has completed, so we execute some additional code, perhaps printing
    a completion message, or update some UI. While the actual saving implementation
    is outside the scope of this recipe, we can amend our `Person` class to allow
    this save functionality to be called, passing a closure to execute on completion.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method to save to a remote database, taking in a completion "handler",
    and store it for subsequent execution:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We define an optional variable to hold on to the save handler during the long-running
    save operation. Our closure will take a `Bool` to indicate whether the save was
    a success:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Let''s now define a method to save our `Person` object, which takes a closure
    as a parameter:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Our function stores the given closure in the variable and then starts the process
    to save to the remote database (the actual implementation of this is outside the
    scope of this recipe). This save process will call the `saveComplete` method when
    completed.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: We added a modifier, `@escaping`, just before the closure type definition. This
    tells the compiler that, rather than using the closure within this method, we
    intend to store the closure and use it later. The closure will be *escaping* the
    scope of this method. This modifier is needed to prevent the compiler from doing
    certain optimizations that would be possible if the closure was *nonescaping*.
    It also helps users of this method understand whether the closure they provide
    will be executed immediately, or at a later time.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'With the save operation complete, we can execute the `saveHandler` variable,
    passing in the `success` Boolean:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Since we stored the closure as an optional, we need to unwrap it by adding a
    `?` after the variable name. If `saveHandler` has a value, the closure will be
    executed; if it is `nil`, the expression is ignored.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a function that takes a closure, let''s see how we call it:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Swift provides a more concise way to provide closures to functions. When a
    closure is the last (or only) parameter, Swift allows it to be provided as a **trailing
    closure**. This means the parameter name can be dropped and the closure can be
    specified after the parameter brackets. So, we can rewrite the preceding with
    the following, neater, syntax:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: See also
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about closures can be found at [http://swiftbook.link/docs/closures](http://swiftbook.link/docs/closures).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Using protocols to define interfaces
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Protocols** are a way to describe the interface that a type provides. They
    can be thought of as a contract, defining how you can interact with instances
    of that type. Protocols are a great way to abstract the "what" something does
    from "how" it does it. As we will see in subsequent chapters, Swift adds functionalities
    to protocols, that make them even more useful and powerful than in many other
    programming languages.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**是描述类型提供的接口的一种方式。它们可以被视为一份合同，定义了你可以如何与该类型的实例交互。协议是抽象“做什么”与“如何做”的一个很好的方式。正如我们将在后续章节中看到的，Swift向协议添加了功能，使它们比许多其他编程语言中的协议更有用和强大。'
- en: Getting ready
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue to build on examples from the previous recipes, but don't worry
    if you haven't followed these recipes yet as all the code you need is listed in
    the upcoming sections.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续构建前一个菜谱中的示例，但如果你还没有遵循这些菜谱，不要担心，因为所有需要的代码都列在即将到来的部分中。
- en: How to do it...
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the last recipe, we added a method to our `Person` class that (given the
    full implementation) would save it to a remote database. This is a very useful
    functionality, and as we add more features to our app, there will likely be more
    types that we also want to save to a remote database:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们向我们的`Person`类添加了一个方法，该方法（给定完整的实现）可以将它保存到远程数据库中。这是一个非常有用的功能，随着我们向我们的应用程序添加更多功能，我们可能还需要将更多类型保存到远程数据库中：
- en: 'Create a protocol to define how we will interface with anything that can be
    saved in this way:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个协议来定义我们将如何与可以通过这种方式保存的任何东西进行接口：
- en: '[PRE112]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Update our `Person` class so that it conforms to the `Saveable` protocol:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的`Person`类，使其符合`Saveable`协议：
- en: '[PRE113]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: How it works...
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Protocols are defined with the `protocol` keyword, and the implementation is
    contained within curly brackets. As we have seen with other type definitions,
    it is conventional to begin a protocol name with a capital letter. It is also
    convention to name a protocol as either something that the type **is** or something
    that it **does.** In this protocol, we are declaring that any type of implementation
    is **saveable.**
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 协议是用`protocol`关键字定义的，实现包含在大括号内。正如我们看到的其他类型定义一样，通常以大写字母开始协议名称。将协议命名为类型**是**或**做**的事情也是惯例。在这个协议中，我们声明任何类型的实现都是**可保存的**。
- en: 'Types conforming to this protocol have two parts of the interface to implement.
    Let''s look at the first:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 符合此协议的类型需要实现接口的两个部分。让我们看看第一个：
- en: '[PRE114]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `Saveable` protocol declares that anything implementing it needs to have
    a variable called `saveNeeded`, which is a `Bool`. This property will indicate
    that the information held in the remote database is out of date and a save is
    needed. In addition to the usual property declaration, a protocol requires us
    to define whether the property can be accessed (`get`) and changed (`set`), which
    is added in curly brackets after the type declaration. Removing the set keywords
    makes it a read-only variable.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`Saveable`协议声明，任何实现它的类型都需要一个名为`saveNeeded`的变量，它是一个`Bool`。这个属性将指示远程数据库中保存的信息已过时，需要保存。除了通常的属性声明外，协议还要求我们定义属性是否可以访问（`get`）和更改（`set`），这是在类型声明之后的大括号中添加的。移除`set`关键字使其成为只读变量。'
- en: Defining a protocol property as read-only doesn't prevent an implementing type
    from allowing the property to be set, just that the setting of that property isn't
    defined in the interface.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 将协议属性定义为只读并不能阻止实现类型允许设置该属性，只是该属性的设置没有在接口中定义。
- en: 'The second part of our protocol definition is to describe the method we can
    call to save the information to the remote database:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们协议定义的第二部分是描述我们可以调用的方法，将信息保存到远程数据库中：
- en: '[PRE115]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This `func` declaration is exactly the same as other function declarations we
    have seen. However, the implementation of this function, which would have been
    contained in curly brackets, is omitted. Any type conforming to this protocol
    must provide this function and its implementation.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`func`声明与我们见过的其他函数声明完全相同。然而，这个函数的实现，本应包含在大括号内，被省略了。任何符合此协议的类型都必须提供这个函数及其实现。
- en: 'Now that we have defined our protocol, we need to implement the `Saveable`
    protocol on our `Person` class that we have been using throughout this chapter:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的协议，我们需要在我们的`Person`类上实现`Saveable`协议，这是我们在这个章节中一直在使用的：
- en: '[PRE116]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Conforming to a protocol looks similar to how a class inherits from another
    class, as we saw earlier in this chapter. The protocol name is added after the
    type name, separated by `:`. By adding this conformance, the compiler will complain
    that our `Person` object doesn''t implement part of the protocol, as we haven''t
    declared a `saveNeeded` property. So let''s add that:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We'll add a default value of `true` since when an instance of this object is
    created, it won't be in the remote database, and so it will need to be saved.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Protocol conformance** can be applied to classes, structs, enums, and even
    other protocols. The benefit of a protocol is that it allows an instance to be
    stored and passed without needing to know how it''s implemented under the hood.
    This provides many benefits, including testing using mock objects and changing
    implementations without changing how and where the implementations are used.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a feature to our app that lets us set a reminder for a contact's birthday,
    which we will also want to save to our remote database.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: We can use protocol conformance to give our reminder the same, consistent, save
    functionality interface, even though a reminder may have a very different implementation
    for saving.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `Reminder` object and have it conform to the `Saveable` protocol:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Our `Reminder` object conforms to `Saveable` and implements all the requirements.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: We now have two objects that represent very different things and have different
    functionalities, but they both implement `Saveable`, and therefore we can treat
    them in a common way.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let''s create an object that will manage the saving
    of information in our app:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In the preceding example, `SaveManager` doesn't know the underlying type that
    it is being passed, but it doesn't need to. It receives instances that conform
    to the `Saveable` protocol and therefore can use that interface to save each instance.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further information about protocols can be found at [http://swiftbook.link/docs/protocols](http://swiftbook.link/docs/protocols).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
