<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Plugin Management</h1></div></div></div><p>In the last chapter, we discussed Gradle task, which is the atomic unit of execution in Gradle. In most cases, a task provides only a single unit of work in modules. We can choose to bundle tasks together and execute them in a certain order to provide the complete functionality. This grouping of tasks along with properties and configuration is called a plugin. A plugin is the logical grouping of tasks, which may have a life cycle. You can configure plugins to alter the behavior based on the requirements. You can extend it to provide additional features. At a broader level, Gradle provides two types of plugins; script plugin and binary plugin. Gradle treats a build script as a script plugin and you can use other build scripts in a project by importing build scripts into the current project.</p><p>Binary plugins are plugins, that we create using programming languages such as Java or Groovy. Gradle provides in-built binary plugins for different build functionalities. There are different approaches to creating a binary plugin in Gradle, which we will discuss in the Custom Plugin section. First, we will explore the script plugin.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>The script plugin</h1></div></div></div><p>A script plugin is <a id="id179" class="indexterm"/>nothing but a Gradle file, which we import into other build files. It is the same as modularizing your code across different classes. When a build file size exceeds to a certain limit or diverse functionalities are clubbed to a single file, it might be a better option to divide the cohesive tasks into different build files. Then, you can import these files to the main build file to use the new functionalities.</p><p>To import the build file you can use the following code:</p><div><pre class="programlisting">apply from: &lt;Path of otherfile.gradle&gt;</pre></div><p>Here, the path could be a local file or a location relative to the project directory or a valid URL. However, if you mention the URL, the downside is that the file will be downloaded each time. Once the build file is imported, you can use the tasks defined in the build file without any additional configuration.</p><p>If you are adding multiple build files in the main build file, make sure you do not have tasks with the same name in the imported build files. During import, if Gradle finds two tasks with the <a id="id180" class="indexterm"/>same name, it will throw the following exception:</p><div><pre class="programlisting">
<strong>* What went wrong:</strong>
<strong>A problem occurred evaluating script.</strong>
<strong>&gt; Cannot add task ':&lt;TASK_NAME&gt;' as a task with that name already exists.</strong>
<strong>* Try:</strong>
<strong>Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</strong>
</pre></div><p>Consider the following directory structure:</p><p>
<code class="literal">/Chapter4/scriptplugin.gradle</code>
</p><div><pre class="programlisting">task scriptPluginTask1 &lt;&lt; {
  println "this is scplugin1"
}</pre></div><p>
<code class="literal">/Chapter4/build.gradle</code>
</p><div><pre class="programlisting">apply from: 'scriptplugin.gradle'

task mainTask &lt;&lt; {
  println "This is main task"
}</pre></div><p>Execute the following command:</p><div><pre class="programlisting">
<strong>$ gradle mainTask scriptPluginTask1</strong>
<strong>:mainTask</strong>
<strong>This is main task</strong>
<strong>:scriptPluginTask1</strong>
<strong>this is scplugin1</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>Here, we have defined the <code class="literal">scriptPluginTask1</code> in the <code class="literal">scriptplugin.gradle</code> file and have imported this build file in the main script <code class="literal">build.gradle</code>. Thus, importing the <code class="literal">scriptplugin.gradle</code> file into <code class="literal">build.gradle</code> will make <code class="literal">scriptPluginTask1</code> available in the main build file and you can call it directly without mentioning any build filename.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>The binary plugin</h1></div></div></div><p>Binary plugins are classes<a id="id181" class="indexterm"/> that implement the <strong>Plugin</strong> interface, which you can embed into the build script. Alternatively, you can create a separate project, package it into a jar file and add that jar file as a classpath entry to a project. The second approach makes it more reusable. Each binary plugin has one ID to uniquely identify it. To use a binary plugin, you need to include it using the <code class="literal">apply plugin</code> statement:</p><div><pre class="programlisting">
<code class="literal">apply plugin: '&lt;pluginid&gt;'</code>
</pre></div><p>For example, to use the Java plugin, you can write the following code:</p><div><pre class="programlisting">
<code class="literal">apply plugin: 'java'</code>
</pre></div><p>You can also use the class type to add plugins. For example, if you are creating a custom class, <code class="literal">DisplayPlugin</code>, as a plugin, you can apply the following code:</p><div><pre class="programlisting">
<code class="literal">apply plugin: DisplayPlugin</code>
</pre></div><p>Before using this approach make sure you import this class in the build file using the import statement. All the Gradle core plugins are available to you by default. You do not need any additional configuration to use them. For third-party or community plugins, you need to make sure they are available in the classpath before you use them. You can do this by adding the plugin in the classpath using the <code class="literal">buildscript{}</code> closure. When you apply any plugin to a build file, all the tasks that are part of the plugin are automatically added. You can directly<a id="id182" class="indexterm"/> use the task with the default configurations or you can customize the task configuration, if needed.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Gradle's in-built plugins</h1></div></div></div><p>Gradle provides <a id="id183" class="indexterm"/>different in-built plugins to automate the build process. Gradle not only provides different plugins to build a project, but also provides plugins to test the project, for code analysis, for IDE support, for web container support, and so on.</p><p>The following are some of the frequently used plugins in different categories. You will find more details on core plugins in the <a id="id184" class="indexterm"/>Gradle documentation at <a class="ulink" href="https://docs.gradle.org/current/userguide/userguide">https://docs.gradle.org/current/userguide/userguide</a>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Build and Test plugins</h2></div></div></div><p>These plugins also support the<a id="id185" class="indexterm"/> testing features to execute Junit and TestNG tests:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Java plugin</li><li class="listitem" style="list-style-type: disc">The Groovy plugin</li><li class="listitem" style="list-style-type: disc">The Scala plugin</li><li class="listitem" style="list-style-type: disc">The War plugin</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Code analysis plugins</h2></div></div></div><p>The following are the <a id="id186" class="indexterm"/>code analysis plugins:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Checkstyle plugin</li><li class="listitem" style="list-style-type: disc">The FindBugs plugin</li><li class="listitem" style="list-style-type: disc">The Sonar plugin</li><li class="listitem" style="list-style-type: disc">The Sonar Runner plugin</li><li class="listitem" style="list-style-type: disc">The PMD plugin</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>IDE plugins</h2></div></div></div><p>The following are<a id="id187" class="indexterm"/> IDE plugins:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Eclipse plugin</li><li class="listitem" style="list-style-type: disc">The IDEA plugin</li></ul></div><p>These are some of the frequently used plugins. Apart from the core plugins, you can also find third-party plugins at<a id="id188" class="indexterm"/> <a class="ulink" href="https://plugins.gradle.org/">https://plugins.gradle.org/</a>. It allows the publication of binary plugins with the support <a id="id189" class="indexterm"/>of the Gradle <code class="literal">Plugin Publishing</code> plugin. Consider spending some time learning how to publish a plugin and how to use the <code class="literal">Plugin Publishing</code> plugin. In the following chapters, we will learn a few core plugins. In the next section, we will explore the Java plugin.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>The Java plugin</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Gradle">Chapter 1</a>, <em>Getting Started with Gradle</em>, we already created a Java project called <code class="literal">FirstGradleProject</code>. However, the discussion was only limited to the Eclipse plugin tasks. We did not discuss anything about the Java plugin. The Java plugin is part of the Gradle core API, which <a id="id190" class="indexterm"/>enables us to build a Java project with supporting tasks such as compiling the Java code, testing the code, assembling binaries to create libraries, and more. It supports conventions over configuration. This means, if we use this plugin, some default configuration is already available to the developer, such as the location of the source code, the location of the compiled class file, and the jar naming convention. Unless we want to override these configurations, we do not need to write a lot of code to work with the default tasks and properties.</p><p>To apply the Java plugin, we add a single statement to the build file:</p><div><pre class="programlisting">apply plugin: 'java'</pre></div><p>Internally, the apply method of the Java plugin is invoked with the <strong>project</strong> object as the argument and the build script is enabled in order to use all the tasks and properties provided by the Java plugin. To understand the Java plugin, we will create a new Java application (project name <code class="literal">Ch04-Java1</code>) similar to the Java project <code class="literal">FirstGradleProject</code>, which we developed in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Gradle">Chapter 1</a>, <em>Getting Started with Gradle</em>. We will add two new classes, Customer and Order; we will also add a new JUnit or TestNG library dependency to support unit testing functionality for the project.</p><p>With the help of this example, we will explore different Java plugin conventions. To be precise, we will try<a id="id191" class="indexterm"/> to understand how different tasks work and which default conventions are supported by the Java plugin. Then, in the next section, we will learn how to customize different properties, so that we can create our own configuration in the build file.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Conventions</h2></div></div></div><p>To understand conventions, let us start with the Java plugin tasks. Once we have applied the Java plugin to display <a id="id192" class="indexterm"/>all the available tasks in the project (project name <code class="literal">Ch04-Java1</code>), we can use the tasks command:</p><div><pre class="programlisting">
<strong>$ gradle tasks --all</strong>
<strong>...</strong>

<strong>Build tasks</strong>
<strong>-----------</strong>
<strong>assemble - Assembles the outputs of this project. [jar]</strong>
<strong>build - Assembles and tests this project. [assemble, check]</strong>
<strong>buildDependents - Assembles and tests this project and all projects that depend on it. [build]</strong>
<strong>buildNeeded - Assembles and tests this project and all projects it depends on. [build]</strong>
<strong>classes - Assembles classes 'main'.</strong>
<strong>  compileJava - Compiles Java source 'main:java'.</strong>
<strong>  processResources - Processes JVM resources 'main:resources'.</strong>
<strong>clean - Deletes the build directory.</strong>
<strong>jar - Assembles a jar archive containing the main classes. [classes]</strong>
<strong>testClasses - Assembles classes 'test'. [classes]</strong>
<strong>  compileTestJava - Compiles Java source 'test:java'.</strong>
<strong>  processTestResources - Processes JVM resources 'test:resources'.</strong>

<strong>...</strong>

<strong>Documentation tasks</strong>
<strong>-------------------</strong>
<strong>javadoc - Generates Javadoc API documentation for the main source code.[classes]</strong>

<strong>...</strong>

<strong>Verification tasks</strong>
<strong>------------------</strong>
<strong>check - Runs all checks.</strong>
<strong>test - Runs the unit tests.</strong>

<strong>Rules</strong>
<strong>-----</strong>
<strong>Pattern: clean&lt;TaskName&gt;: Cleans the output files of a task.</strong>
<strong>Pattern: build&lt;ConfigurationName&gt;: Assembles the artifacts of a configuration.</strong>
<strong>Pattern: upload&lt;ConfigurationName&gt;: Assembles and uploads the artifacts belonging to a configuration.</strong>

<strong>To see all tasks and more detail, run with --all.</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>The preceding output <a id="id193" class="indexterm"/>displays different build tasks, test tasks, documentation tasks, and other available tasks in the Java plugin. The output also shows the task dependencies between different tasks. For example, task classes internally depend on the <code class="literal">compileJava</code> and <code class="literal">processResources</code> tasks, which compile and process the source code and resources from <code class="literal">src/main/java</code> and <code class="literal">src/main/resources</code>, respectively. Similarly, the <code class="literal">compileTestJava</code> task and <code class="literal">processTestResources</code> task compile and process resources from <code class="literal">src/test/java</code> and <code class="literal">src/test/resources</code>, respectively. The output of all these tasks is compiled classes and resources, which will be created under the <code class="literal">build</code> directory by convention and will be added to the <code class="literal">classspath</code> during the execution of the program. Now, let us explore, with an example, what these tasks mean and which conventions are available by default.</p><p>To compile classes only under <code class="literal">src/main</code>, we should use the task classes. The compiled classes will be created under <code class="literal">build/classes/</code> directory.</p><div><pre class="programlisting">
<strong>$ gradle classes</strong>
<strong>:compileJava</strong>
<strong>:processResources UP-TO-DATE</strong>
<strong>:classes</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>The <code class="literal">testClasses</code> task compiles and processes test classes and resources, and additionally, executes the classes task. In the following output, you can see that the <code class="literal">compileJava</code>, <code class="literal">processResources</code>, and <code class="literal">classes</code> tasks were executed again but the tasks were marked as <code class="literal">UP-TO-DATE</code>. This is because there was no change in the input and output of those tasks, as we have already executed the <code class="literal">classes</code> task in the last command. After successful<a id="id194" class="indexterm"/> execution, you will find a test directory created under the <code class="literal">build/classes</code> folder:</p><div><pre class="programlisting">
<strong>$ gradle testClasses</strong>
<strong>:compileJava UP-TO-DATE</strong>
<strong>:processResources UP-TO-DATE</strong>
<strong>:classes UP-TO-DATE</strong>
<strong>:compileTestJava</strong>
<strong>:processTestResources UP-TO-DATE</strong>
<strong>:testClasses</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>The other important task is the <code class="literal">test</code> task. This task helps to execute unit test code written under the <code class="literal">src/test</code> directory. After successful execution, you will find the test results created under the <code class="literal">build/test-results</code> directory:</p><div><pre class="programlisting">
<strong>$ gradle test</strong>
<strong>:compileJava UP-TO-DATE</strong>
<strong>:processResources UP-TO-DATE</strong>
<strong>:classes UP-TO-DATE</strong>
<strong>:compileTestJava UP-TO-DATE</strong>
<strong>:processTestResources UP-TO-DATE</strong>
<strong>:testClasses UP-TO-DATE</strong>
<strong>:test</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>You have the <code class="literal">assemble</code> task or the <code class="literal">jar</code> task to package classes and resources into a jar file. The <code class="literal">jar</code> task will only create jar files, whereas, the assemble task helps you to produce other artifacts, including jar. For example, when you apply the war plugin, the <code class="literal">jar</code> task is disabled and is replaced with the war task. By default, the JAR file is named <code class="literal">&lt;project-name&gt;.jar</code> and is created under <code class="literal">build/libs</code>. If you have not set the <code class="literal">&lt;project-name&gt;</code> in the build file, you will get the jar name <code class="literal">&lt;project-folder-name&gt;.jar</code>. This is not good practice if the jar file does not contain any version. You can add the version to the jar file by adding the version property to your project in the build file, which will generate <code class="literal">&lt;name&gt;-&lt;version&gt;.jar</code>. In our example, the project name is <code class="literal">Ch04-Java1</code> and the version property is set to <code class="literal">1.0</code> in the build file. Therefore, the jar file will be named <code class="literal">Ch04-Java1-1.0.jar</code>. Execute the following command and you will find the jar file under <code class="literal">build/libs</code>:</p><div><pre class="programlisting">
<strong>$ gradle assemble</strong>
<strong>:compileJava UP-TO-DATE</strong>
<strong>:processResources UP-TO-DATE</strong>
<strong>:classes UP-TO-DATE</strong>
<strong>:jar</strong>
<strong>:assemble</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>No test classes will be packaged in the JAR file.</p></div></div><p>Another task is the <code class="literal">build</code> task, which executes the <code class="literal">check</code> and <code class="literal">assemble</code> tasks together. The <code class="literal">clean</code> task deletes all the artifacts created by another task. It actually deletes the complete <code class="literal">build/</code> folder. This<a id="id195" class="indexterm"/> means, the <code class="literal">clean</code> task deletes the output generated by all the tasks, that is, <code class="literal">check</code> and <code class="literal">assemble</code>. To delete a task-specific output, we can apply the <code class="literal">clean&lt;TaskName&gt;</code> rule. For example, to delete only the jar file created by the <code class="literal">build</code> task, we can execute the <code class="literal">gradle cleanJar</code> command.</p><p>All the tasks in the Java plugin execute based on conventions such as source directory location, build folder name, test result folder, and so on. To understand this in a better way, the following example shows some of the conventions supported by Gradle:</p><div><pre class="programlisting">task displayJavaPluginConvention &lt;&lt; {

  println "Lib Directory: $libsDir"
  println "Lib Directory Name: $libsDirName"
  println "Reports Directory: $reportsDir"
  println "Test Result Directory: $testResultsDir"
  
  println "Source Code in two sourcesets: $sourceSets"
  println "Production Code: ${sourceSets.main.java.srcDirs}"
  println "Test Code: ${sourceSets.test.java.srcDirs}"
println "Production code output: ${sourceSets.main.output.classesDir} &amp; ${sourceSets.main.output.resourcesDir}"
println "Test code output: ${sourceSets.test.output.classesDir} &amp; ${sourceSets.test.output.resourcesDir}"
}</pre></div><p>The output displays various conventions supported by the Java plugin. You can find the complete list in the official<a id="id196" class="indexterm"/> Gradle documentation at <a class="ulink" href="https://docs.gradle.org/current/userguide/java_plugin.html">https://docs.gradle.org/current/userguide/java_plugin.html</a>.</p><div><pre class="programlisting">
<strong>$ gradle displayJavaPluginConvention</strong>
<strong>:displayJavaPluginConvention</strong>
<strong>Lib Directory: &lt;path&gt;/build/libs</strong>
<strong>Lib Directory Name: libs</strong>
<strong>Reports Directory: &lt;path&gt;/build/reports</strong>
<strong>Test Result Directory: &lt;path&gt;/build/test-results</strong>
<strong>Source Code in two sourcesets: [source set 'main', source set 'test']</strong>
<strong>Production Code: [&lt;path&gt;/src/main/java]</strong>
<strong>Test Code: [&lt;path&gt;/src/test/java]</strong>
<strong>Production code output: &lt;path&gt;/build/classes/main &amp; &lt;path&gt;/build/resources/main</strong>
<strong>Test code output: &lt;path&gt;/build/classes/test &amp; &lt;path&gt;/build/resources/test</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>Sometimes, these default configurations might not suffice. We might need to configure some default<a id="id197" class="indexterm"/> properties to support our requirements. In the next section, we will explore<a id="id198" class="indexterm"/> how to configure some of the default configurations.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Configuration</h2></div></div></div><p>In the previous example, we<a id="id199" class="indexterm"/> learned about the default properties or conventions available in the Java plugin. Now, we will configure some of these properties. This is important when we want to change the build directory name, the libs folder name, or the source file location of the project.</p><p>The source- related configuration changes can be set in the <code class="literal">sourceSets</code> closure. The upcoming code snippet (project name <code class="literal">Ch04-Java2</code>) shows that the source code location has been modified from <code class="literal">src/main/java</code> to <code class="literal">src/productioncode</code> for the source code location and <code class="literal">src/test/java</code> to <code class="literal">src/testcode</code> for the test code location, respectively. As a result, compiled classes will now be stored in <code class="literal">classes/productioncode</code> and <code class="literal">classes/testcode</code> locations for the source and test code, respectively. This will not replace the source directory from <code class="literal">main</code> to <code class="literal">productioncode</code>, but Gradle will now look for source code in both <code class="literal">main</code> and <code class="literal">productioncode</code> directories and for test code in both <code class="literal">test</code> and <code class="literal">testcode</code> directories. If you want Gradle to look for the source code only in the <code class="literal">productioncode</code> directory, you can set the <code class="literal">java.srcDirs</code> property.</p><p>These Java plugin conventions are written in the <code class="literal">JavaPluginConvention</code> and<em> </em>
<code class="literal">BasePluginConvention</code> classes. One such property, <code class="literal">testResultsDirName</code>, can also be set in the <code class="literal">build</code> file:</p><div><pre class="programlisting">buildDir = 'buildfolder'
libsDirName = 'libfolder'

sourceSets {
  main {
    java {
      srcDir 'src/productioncode/java'
    }
    resources {
      srcDir 'src/productioncode/resources'
    }
  }
  test{
  
    java {
      srcDir 'src/testcode/java'
    }
    resources {
      srcDir 'src/testcode/resources'
    }
  }
}

testResultsDirName = "$buildDir/new-test-result"
sourceSets.main.output.classesDir "${buildDir}/classes/productioncode/java"
sourceSets.main.output.resourcesDir "${buildDir}/classes/productioncode/resources"
sourceSets.test.output.classesDir "${buildDir}/classes/testcode/java"
sourceSets.test.output.resourcesDir "${buildDir}/classes/testcode/resources"</pre></div><p>These changes will make sure that <code class="literal">buildfolder</code>, <code class="literal">libfolder</code>, and <code class="literal">test-result</code> folders have been replaced <a id="id200" class="indexterm"/>with <code class="literal">buildfolder</code>, <code class="literal">libfolder</code>, and <code class="literal">new-test-result</code> folders.</p><p>Figure 4.1 shows the directory structure of the <code class="literal">src</code> folder and new the <code class="literal">buildfolder</code>:</p><div><img src="img/B02000_04_01.jpg" alt="Configuration"/><div><p>Figure 4.1</p></div></div><p>All these new changes can be verified by executing the previously created <code class="literal">displayJavaPluginConvention</code> task. After executing the task, you will find the output updated with <a id="id201" class="indexterm"/>new configurations:</p><div><pre class="programlisting">
<strong>$ gradle displayJavaPluginConvention</strong>
<strong>:displayJavaPluginConvention</strong>
<strong>Lib Directory: &lt;path&gt;/buildfolder/libfolder</strong>
<strong>Lib Directory Name: libfolder</strong>
<strong>Reports Directory: &lt;path&gt;/buildfolder/reports</strong>
<strong>Test Result Directory: %path%/buildfolder/new-test-result</strong>
<strong>Source Code in two sourcesets: [source set 'main', source set 'test']</strong>
<strong>Production Code: [&lt;path&gt;/src/main/java, &lt;path&gt;/src/productioncode/java]</strong>
<strong>Test Code: [&lt;path&gt;/src/test/java, &lt;path&gt;/src/testcode/java]</strong>
<strong>Production code output: &lt;path&gt;/buildfolder/classes/productioncode/java &amp; &lt;path&gt;/buildfolder/classes/productioncode/resources</strong>
<strong>Test code output: &lt;path&gt;/buildfolder/classes/testcode/java &amp; &lt;path&gt;/buildfolder/classes/testcode/resources</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>The custom plugin</h1></div></div></div><p>In this section, we will <a id="id202" class="indexterm"/>discuss how to create a custom plugin. A plugin can be created by implementing the <code class="literal">org.gradle.api.Plugin&lt;T&gt;</code> interface. This interface has one method named <code class="literal">apply(T target)</code>, which must be implemented in the plugin class. Typically, we write a plugin for the Gradle projects. In that situation, T becomes the Project. However, T can be any type of object.</p><p>The class that implements the plugin interface can be placed in various locations, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The same build file</li><li class="listitem" style="list-style-type: disc">The <code class="literal">buildSrc</code> directory</li><li class="listitem" style="list-style-type: disc">A standalone project</li></ul></div><p>This is similar to creating a custom task that we discussed in the last chapter. When we define a plugin in the same build file, the scope is limited to the defining project only. This means, this plugin cannot be reused in any other projects. This is not a good idea, if we want to distribute our plugin for other projects. For a multiproject Gradle build, the plugin code can be placed in the <code class="literal">buildSrc</code> folder of the root project or build file of the root project. All the subprojects will have access to this custom plugin. The most elegant way to create a plugin is to create a standalone Groovy project, create a jar file from it and share the plugin across projects and teams. Now, we will explore how to create a custom plugin with examples.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>The build file</h2></div></div></div><p>In the following example, we have added a <code class="literal">FilePlugin</code> class, which implements a Plugin interface in the build file. In<a id="id203" class="indexterm"/> the apply method, we have added two tasks, <code class="literal">copy</code> and <code class="literal">move</code>. These tasks are simple tasks, which print a line in the console. Now, we need to add this plugin to the build file if we want to execute the <code class="literal">copy</code> or <code class="literal">move</code> tasks. In this example, the plugin name is <code class="literal">FilePlugin</code>. We add this plugin using the <code class="literal">apply plugin</code> statement. Without adding the plugin, you will find <code class="literal">Could not find property 'copy' on root project 'PROJECT_NAME'.</code> if you try to execute the copy task:</p><div><pre class="programlisting">apply plugin: FilePlugin

class FilePlugin implements Plugin&lt;Project&gt; {
  void apply(Project project) {
    project.task('copy') &lt;&lt; {
      println "Task copy is running"
        //....
      }
    project.task('move') &lt;&lt; {
      println "Task move is running"
      //...
    }
  }
}
copy.doLast { println "Copy Task ending .." }</pre></div><p>On executing the copy task (for the <code class="literal">Ch04_CustomPlugin1</code> project) from the command-line, we find the following<a id="id204" class="indexterm"/> two lines printed in the console as expected:</p><div><pre class="programlisting">
<strong>$ gradle copy</strong>
<strong>:copy</strong>
<strong>Task copy is running</strong>
<strong>Copy Task ending ..</strong>
<strong>BUILD SUCCESSFUL</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>The buildSrc directory</h2></div></div></div><p>Similar to Task, to keep the plugin code separate from the build file, we can create a <code class="literal">buildSrc</code> folder inside the project root directory and any common code, task or plugin can be placed in this folder. In the<a id="id205" class="indexterm"/> following example, the Plugin is created in the <code class="literal">buildSrc</code> folder, which can be reused in the root build file and in all the subprojects. We have created a <code class="literal">FilePlugin.groovy</code> class under <code class="literal">buildSrc/src/main/groovy</code>. This class implements the plugin interface and adds two tasks: the <code class="literal">copy</code> task and the <code class="literal">move</code> task in the apply method. This <code class="literal">FilePlugin.groovy</code> class is similar to what we have done in the previous example. For this example, we will create a project <code class="literal">Ch04_CustomPlugin2</code>. Additionally, in the <code class="literal">FilePlugin.groovy</code> class, we need to add the package declaration and import statements (<code class="literal">import org.gradle.api.*</code>).</p><p>During build execution, this plugin class will be compiled automatically by Gradle and added to the classpath of the project. As the plugin definition is not in the build file, we need a mechanism to declare plugin information in the build file. This is done by importing the <code class="literal">Plugin</code> class and adding the plugin with the <code class="literal">apply plugin</code> statement. The following snippet shows the content of the main build file. In the file, additionally, we have added a <code class="literal">doLast</code> method in the <code class="literal">copy</code> task just for logging purposes:</p><div><pre class="programlisting">import ch4.FilePlugin
apply plugin: FilePlugin

copy.doLast {   
println "This is main project copy dolast"
}</pre></div><p>Next, we create two subprojects: <code class="literal">project1</code> and <code class="literal">project2</code>. Each project has a simple build file. This build<a id="id206" class="indexterm"/> file is similar to the main build file. The build file imports and applies the <code class="literal">FilePlugin</code> and adds a <code class="literal">doLast</code> method to the <code class="literal">copy</code> task for logging. The content of <code class="literal">build.gradle</code> of <code class="literal">project1</code> is shown in the following code. The build file of <code class="literal">project2</code> is also similar to this:</p><div><pre class="programlisting">import ch4.FilePlugin
apply plugin: FilePlugin

copy.doLast {
  println "Additional doLast for project1"
}</pre></div><p>We need another <code class="literal">settings.gradle</code> file, which includes the subprojects in the main project:</p><div><pre class="programlisting">include 'project1', 'project2'</pre></div><p>Do not get confused with the <code class="literal">settings.gradle</code> file. We will discuss multiproject builds in detail in <a class="link" href="ch06.html" title="Chapter 6. Working with Gradle">Chapter 6</a>, <em>Working with Gradle</em>.</p><p>For convenience, the directory structure of the <code class="literal">Ch04_CustomPlugin2</code> project is displayed in Figure 4.2:</p><div><img src="img/B02000_04_02.jpg" alt="The buildSrc directory"/><div><p>Figure 4.2</p></div></div><p>When we execute the <code class="literal">copy</code> task, we find three copy tasks being executed: one from the main project and two other copy tasks from subprojects <code class="literal">project 1</code> and <code class="literal">project 2</code>.</p><div><pre class="programlisting">
<strong>$ gradle copy</strong>
<strong>:buildSrc:compileJava UP-TO-DATE</strong>
<strong>:buildSrc:compileGroovy</strong>
<strong>:buildSrc:processResources UP-TO-DATE</strong>
<strong>:buildSrc:classes</strong>
<strong>:buildSrc:jar</strong>
<strong>:buildSrc:assemble</strong>
<strong>:buildSrc:compileTestJava UP-TO-DATE</strong>
<strong>:buildSrc:compileTestGroovy UP-TO-DATE</strong>
<strong>:buildSrc:processTestResources UP-TO-DATE</strong>
<strong>:buildSrc:testClasses UP-TO-DATE</strong>
<strong>:buildSrc:test UP-TO-DATE</strong>
<strong>:buildSrc:check UP-TO-DATE</strong>
<strong>:buildSrc:build</strong>
<strong>:copy</strong>
<strong>Task copy is running</strong>
<strong>This is main project copy dolast</strong>
<strong>:project1:copy</strong>
<strong>Task copy is running</strong>
<strong>Additional doLast for project1</strong>
<strong>:project2:copy</strong>
<strong>Task copy is running</strong>
<strong>Additional doLast for project2</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>The Standalone project</h2></div></div></div><p>In the last section, we placed the plugin code in the <code class="literal">buildSrc</code> directory and we used the plugin in the root build file and all the subprojects build files. It was just one step towards modularizing the plugin code from the build logic. However, this plugin is not reusable in other projects. Ideally, a plugin should be created in a standalone Groovy project. Then we create a JAR file<a id="id207" class="indexterm"/> and include that JAR file in the classpath of other build files. In this section, we will explore how to create a standalone plugin project.</p><p>We will start by creating a simple Groovy project. We will add a plugin class <code class="literal">FilePlugin.groovy</code> and two tasks <code class="literal">CopyTask</code> and <code class="literal">MoveTask</code> in the <code class="literal">src/main/groovy</code>. We will also add a properties file in the resource folder. The snapshot of the project (<code class="literal">Ch04_CustomPlugin3</code>) is displayed in Figure 4.3:</p><div><img src="img/B02000_04_03.jpg" alt="The Standalone project"/><div><p>Figure 4.3</p></div></div><p>The <code class="literal">FilePlugin.groovy</code> class creates two tasks named <code class="literal">copy</code> and <code class="literal">move</code> by referring to the <code class="literal">CopyTask</code> and <code class="literal">MoveTask</code> classes. These tasks are created by calling the <code class="literal">create(...)</code> method on the <code class="literal">TaskContainer</code> object with the <code class="literal">taskname</code> and <code class="literal">task</code> classes as method parameters. Both tasks extend <code class="literal">DefaultTask</code> and define their own implementation. This is just an example of creating a custom task that we learned about in the last chapter. We have created one more additional task <code class="literal">customTask</code>, which will print the <code class="literal">sourceFile</code> property <a id="id208" class="indexterm"/>value. The <code class="literal">sourceFile</code> property is defined using the extension object. Plugin extensions are plain old Groovy objects used to add properties to plugins. You can provide properties/configuration information to <code class="literal">Plugins</code> using <code class="literal">extension</code> objects. You can create more than one extension object in the plugin to group the related properties together. Gradle adds a configuration closure block for each extension object.</p><p>The code snippet of the <code class="literal">FilePlugin.groovy</code> class is as follows:</p><div><pre class="programlisting">package ch4.custom.plugin

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import ch4.custom.tasks.CopyTask
import ch4.custom.tasks.MoveTask

class FilePlugin implements Plugin&lt;Project&gt; {

  @Override
  public void apply(Project project) {

    def extension = project.extensions.create("simpleExt", FilePluginRootExtension)

    project.tasks.create("copy", CopyTask.class)
    project.tasks.create("move", MoveTask.class)
    project.task('customTask') &lt;&lt; {
    println "Source file is "+project.filePluginExtension.sourceFile
    }
  }
}</pre></div><p>The following is the<a id="id209" class="indexterm"/> source code for the <code class="literal">AbstractTask</code>, <code class="literal">CopyTask</code>, <code class="literal">MoveTask</code>, and <code class="literal">extension</code> classes.</p><p>File: <code class="literal">AbstractTask.groovy</code>
</p><div><pre class="programlisting">package ch4.custom.tasks

import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction

class AbstractTask extends DefaultTask {

}</pre></div><p>File: <code class="literal">CopyTask.groovy</code>
</p><div><pre class="programlisting">package ch4.custom.tasks

import org.gradle.api.tasks.TaskAction

class CopyTask extends AbstractTask {
  
  @TaskAction
  def action1() {
    println "Copy Task Running"
  }
}</pre></div><p>File: <code class="literal">MoveTask.groovy</code>
</p><div><pre class="programlisting">package ch4.custom.tasks

import org.gradle.api.tasks.TaskAction

class MoveTask extends AbstractTask {

  @TaskAction
  def action1() {
    println "Move Task Running"
  }

}</pre></div><p>File: <code class="literal">FilePluginRootExtension.groovy</code>
</p><div><pre class="programlisting">package ch4.custom.plugin

class FilePluginRootExtension {

  def sourceFile = "/home/tmp"
  def destinationFile

}</pre></div><p>Now, we need a plugin ID so that Gradle can find this plugin information. This is done by creating a<a id="id210" class="indexterm"/> properties file under <code class="literal">src/main/resources/META-INF/gradle-plugins</code>. The name of the file becomes the plugin ID. In our example, we have named the file <code class="literal">fileplugin.properties</code>. So, the plugin ID is <code class="literal">fileplugin</code>. In any other build file, we can now apply the plugin as:</p><div><pre class="programlisting">apply plugin: 'fileplugin'</pre></div><p>In the <code class="literal">fileplugin.properties</code> file, we need to add the <code class="literal">implementation-class</code> property, which maps to the main plug in the implementing class:</p><div><pre class="programlisting">implementation-class=ch4.custom.plugin.FilePlugin</pre></div><p>That's all you need. Now, we can build this project to create a jar file and then we can use this jar in any other project. In our example, the jar file is named <code class="literal">Ch04_CustomPlugin3-1.0.jar</code>. If you wish to publish a plugin in <a class="ulink" href="https://plugins.gradle.org/">https://plugins.gradle.org/</a>, you need to make sure the plugin ID is unique. In such cases, you might want to rename <code class="literal">fileplugin.properties</code> to something like <code class="literal">mastering.gradle.ch4.properties</code> to ensure uniqueness of the plugin ID.</p><p>Once the jar file is created, the <a id="id211" class="indexterm"/>plugin can be used in any other build file. The code snippet shows how the <code class="literal">buildscript</code> closure can define a local directory as the repository. The plugin jar file can be included in the classpath by the dependencies closure. In the example, we are using the plugin from the local directory. Ideally, we should publish the plugin jar<a id="id212" class="indexterm"/> to a private or public repository and reference it via the Maven or Ivy URL:</p><div><pre class="programlisting">buildscript {
  repositories {
    flatDir {dirs "../Ch04_CustomPlugin3/build/libs/"}
  }
dependencies {
  classpath group: 'ch4.custom.plugin', name: 'Ch04_CustomPlugin3',version: '1.0'
}
}
apply plugin: 'fileplugin'

copy.doLast {
  println "This is from project $project.name"
}</pre></div><p>We have added a <code class="literal">dolast</code> in the copy task, which prints the project name. Try to execute the following command:</p><div><pre class="programlisting">
<strong>$ gradle copy cT</strong>
<strong>:copy</strong>
<strong>Copy Task Running</strong>
<strong>This is from project UsingPlugin</strong>
<strong>:customTask</strong>
<strong>Source file is /home/tmp</strong>

<strong>BUILD SUCCESSFUL</strong>

<strong>Total time: 3.59 secs</strong>
</pre></div><p>From the output, you can understand that the copy task has two statements. One we mentioned in plugin definition and the other we added in the <code class="literal">build.gradle</code> file. The output of the <code class="literal">customTask</code> prints the default value of the source file, which is <code class="literal">/home/tmp</code>. This value was set in the <code class="literal">FilePluginRootExtension.groovy</code>
<strong> </strong>class. If you want to update the property to some other value, add the following configuration closure in the build file:</p><div><pre class="programlisting">filePluginExtension {
  sourceFile = "/home/user1"
}</pre></div><p>After adding the preceding closure, try to execute the following command:</p><div><pre class="programlisting">
<strong>$ gradle cT</strong>
<strong>:customTask</strong>
<strong>Source file is /home/user1</strong>

<strong>BUILD SUCCESSFUL</strong>

<strong>Total time: 3.437 secs</strong>
</pre></div><p>Now, the output is changed to<a id="id213" class="indexterm"/> the new value mentioned in the <code class="literal">filePluginExtension</code> closure.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Summary</h1></div></div></div><p>In this chapter, we have mainly discussed two topics: the Java plugin and the custom plugin. In the Java plugin, we learned about the default convention and properties supported by Gradle. Then we discussed how to customize and configure these properties. In the custom plugin, we showed different ways to create a plugin. However, there are so many plugins to discuss in Gradle. We will be discussing a few important plugins in <a class="link" href="ch06.html" title="Chapter 6. Working with Gradle">Chapter 6</a>, <em>Working with Gradle</em> and <a class="link" href="ch07.html" title="Chapter 7. Continuous Integration">Chapter 7</a>, <em>Continuous Integration</em>. However, we will not be able to cover all the plugins in this book. We request readers to refer to the Gradle documentation for more details.</p><p>In the next chapter, we will cover another important topic in Gradle, which is dependency management. We will learn about various repository configurations in the build file, different dependency resolution strategies, publishing artifacts in the repositories, and more.</p></div></body></html>