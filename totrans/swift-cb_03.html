<html><head></head><body><div id="sbo-rt-content"><section>&#13;
&#13;
                            <header class="header-title chapter-title">&#13;
                    Data Wrangling with Swift Control Flow&#13;
                </header>&#13;
            &#13;
            <article>&#13;
                &#13;
<p>Programming is all about making decisions. The purpose of most code involves taking information, inspecting it, making decisions, and producing an output. So far, we have seen a lot of ways to represent information, but in this chapter, we will explore how to make decisions based on that information using a number of Swift's control flow statements. We will find out how they differ and the situations where each is appropriate. </p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Making decisions with <kbd>if</kbd>/<kbd>else</kbd></li>&#13;
<li>Handling all the cases with <kbd>switch</kbd></li>&#13;
<li>Looping with <kbd>for</kbd> loops</li>&#13;
<li>Looping with <kbd>while</kbd> loops</li>&#13;
<li>Handling errors with <kbd>try</kbd>, <kbd>throw</kbd>, <kbd>do</kbd>, and <kbd>catch</kbd></li>&#13;
<li>Checking upfront with <kbd>guard</kbd></li>&#13;
<li>Doing it later with <kbd>defer</kbd></li>&#13;
<li>Bailing out with <kbd>fatalError</kbd> and <kbd>precondition</kbd></li>&#13;
</ul>&#13;
<h1 id="uuid-a67a3b96-b836-480d-90cc-abf81158f97d">Technical requirements</h1>&#13;
<p>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03" target="_blank">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter03</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3aq66Us" target="_blank">https://bit.ly/3aq66Us</a></p>&#13;
<h1 id="uuid-f6de1ed0-ff05-4be9-a1fd-76f921d2a47d">Making decisions with if/else</h1>&#13;
<p>The if/else statement is a cornerstone of almost every programming language. It enables code to be executed conditionally, based on the outcome of a Boolean statement. In this recipe, we will see how if/else can be used, including some ways that are unique to Swift.</p>&#13;
<h2 id="uuid-6c5c7218-c32b-42e5-bd7c-721134669198">Getting ready</h2>&#13;
<p>If you have ever played pool, you'll know that the aim of the game (when playing standard 8-ball pool) is to pot all the balls of one type and then to pot the black ball. When using American pool balls, they are numbered 1-15, and have a different pattern depending on their type. Balls 1-7 have a solid color, balls 9-15 are white with a colored stripe around them, and ball 8 is black:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/e68de254-2938-478c-bf86-aaa825b2a4ca.png" style="" width="1062" height="725"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 3.1 â€“ American pool balls</span></div>&#13;
<p>In this recipe, we will write a function that will take the number on a pool ball and return the type of ball it is.</p>&#13;
<h2 id="uuid-3a16dbd9-ff4e-418d-95dd-e7685be4b31f">How to do it...</h2>&#13;
<p>Let's use an if/else control flow statement to write a function to return the right pool ball type:</p>&#13;
<ol>&#13;
<li>Create an <kbd>enum</kbd> to describe the possible ball types:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum PoolBallType { <br/>    case solid <br/>    case stripe <br/>    case black <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Create the method that will take an <kbd>Int</kbd> and return <kbd>PoolBallType</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func poolBallType(forNumber number: Int) -&gt; PoolBallType { <br/>    if number &lt; 8 { <br/>        return .solid <br/>    } else if number &gt; 8 { <br/>        return .stripe <br/>    } else { <br/>        return .black <br/>    } <br/>}</pre>&#13;
<ol start="3">&#13;
<li>Use this function and test that we get the expected results:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let two = poolBallType(forNumber: 2) // .solid <br/>let eight = poolBallType(forNumber: 8) // .black <br/>let twelve = poolBallType(forNumber: 12) // .stripe </pre>&#13;
<h2 id="uuid-0aaa842d-6780-4d44-a3e8-ae0d2a6c5e5f"><span class="Heading2Char">How it works...</span></h2>&#13;
<p>Within the function, we define three code paths: <kbd>if</kbd>, <kbd>else if</kbd>, and <kbd>else</kbd>:</p>&#13;
<pre>if &lt;#a boolean expression#&gt; { <br/>    &lt;#executed if boolean expression above is true#&gt; <br/>} else if &lt;#other boolean expression#&gt; { <br/>    &lt;#executed if other boolean expression above is true#&gt; <br/>} else { <br/>    &lt;#executed if neither boolean expressions are true#&gt; <br/>} </pre>&#13;
<p>First, we want to determine whether the ball is solid. Since we know that the balls numbered 1-7 are solid, we can test whether the ball number is less than 8, with <kbd>number &lt; 8</kbd>. If this is <kbd>true</kbd>, we return the <kbd>.solid</kbd> case of our <kbd>enum</kbd>.</p>&#13;
<p>If it is <kbd>false</kbd>, the <kbd>else if</kbd> Boolean expression is evaluated. As balls 9-15 are striped, we can test whether the ball number is more than 8, with <kbd>number &gt; 8</kbd>. If this is <kbd>true</kbd>, we return the <kbd>.stripe</kbd> case of our <kbd>enum</kbd>.</p>&#13;
<p>Lastly, if both the preceding Boolean expressions are <kbd>false</kbd>, we return the <kbd>.black</kbd> case of our <kbd>enum</kbd>, since that can only happen if the number is exactly 8. </p>&#13;
<p>The <kbd>else if</kbd> and <kbd>else</kbd> blocks are optional, and you can declare multiple <kbd>else if</kbd> to cover additional conditions. Let's expand our preceding example with an extra <kbd>else if</kbd> to better decide the pool ball type.</p>&#13;
<p>As we stated previously, pool balls are numbered between 1 and 15, but we don't take into account those upper and lower bounds in our implementation. So if we were to provide the function with ball number 0, it would return <kbd>.solid</kbd>, and if we were to provide ball number 16, it would return <kbd>.stripe</kbd>, which doesn't accurately reflect our intention:</p>&#13;
<pre>let zero = poolBallType(forNumber: 0) // .solid <br/>let sixteen = poolBallType(forNumber: 16) // .stripe</pre>&#13;
<p>Let's modify our function to only return a pool ball type if the number is between 1 and 15, and return <kbd>nil</kbd> otherwise:</p>&#13;
<pre>func poolBallType(forNumber number: Int) -&gt; PoolBallType? {<br/>    if number &gt; 0 &amp;&amp; number &lt; 8 {<br/>        return .solid<br/>    } else if number &gt; 8 &amp;&amp; number &lt; 16 {<br/>        return .stripe<br/>    } else if number == 8 {<br/>        return .black<br/>    } else {<br/>        return nil<br/>    }<br/>}</pre>&#13;
<p>Now we have four code branches in our <kbd>if</kbd> statement, and we can use the AND operator, <kbd>&amp;&amp;</kbd>, to combine Boolean statements (the OR operator, <kbd>||</kbd>, is also available).</p>&#13;
<p>We can now call our function for both numbers within the expected 1-15 range and outside it:</p>&#13;
<pre>let two = poolBallType(forNumber: 2) // .solid <br/>let eight = poolBallType(forNumber: 8) // .black <br/>let twelve = poolBallType(forNumber: 12) // .stripe <br/>let zero = poolBallType(forNumber: 0) // nil <br/>let sixteen = poolBallType(forNumber: 16) // nil </pre>&#13;
<p><span>Our improved function will produce <kbd>nil</kbd> for numbers outsid</span>e of the expected range.</p>&#13;
<h2 id="uuid-387786a6-b3c3-4370-b8fa-c17ef32bd53c">There's more...</h2>&#13;
<p>There are some other ways we can use if/else statements.</p>&#13;
<h3 id="uuid-59ac6a67-69e4-4832-8f68-cfdce8261048">Understanding conditional unwrapping</h3>&#13;
<p>The function we created earlier returns an optional value, so if we want to do anything useful with the resulting value, we need to <kbd>unwrap</kbd> the optional. So far, the only way we have seen how to do this is by force unwrapping, which will cause a crash if the value is <kbd>nil</kbd>.</p>&#13;
<p>Instead, we can use an <kbd>if</kbd> statement to <em>conditionally unwrap</em> the optional, turning it into a more useful, non-optional value.</p>&#13;
<p>Let's create a function that will print information about a pool ball of a given number. If the provided number is valid for a pool ball, it will print the ball's number and type; otherwise, it will print a message explaining that it is not a valid number.</p>&#13;
<p>Since we will want to print the value of the <kbd>PoolBallType</kbd> enum, let's make it <kbd>String</kbd> backed, which will make printing its value easier:</p>&#13;
<pre class="p1"><span class="s1">enum</span> PoolBallType: <span class="s2">String</span> {<br/><span class="Apple-converted-space">    </span><span class="s1">case</span> solid<br/><span class="Apple-converted-space">    </span><span class="s1">case</span> stripe<br/><span class="Apple-converted-space">    </span><span class="s1">case</span> black<br/>}</pre>&#13;
<p>Now, let's write the function to print the pool ball details:</p>&#13;
<pre>func printBallDetails(ofNumber number: Int) { <br/>    let possibleBallType = poolBallType(forNumber: number) <br/>    if let ballType = possibleBallType { <br/>        print("\(number) - \(ballType.rawValue)") <br/>    } else { <br/>        print("\(number) is not a valid pool ball number") <br/>    } <br/>} </pre>&#13;
<p>The first thing we do in our <kbd>printBallDetails</kbd> function is to get the ball type for the given number:</p>&#13;
<pre>let possibleBallType = poolBallType(forNumber: number) </pre>&#13;
<p>In our improved version of this function, this returns an optional version of the <kbd>PoolBallType</kbd> enum. We want to include the <kbd>rawValue</kbd> of the returned <kbd>enum</kbd> as part of printing the ball details. Since the returned value is optional, we need to unwrap it first:</p>&#13;
<pre>if let ballType = possibleBallType { <br/>    print("\(number) - \(ballType.rawValue))") <br/>} </pre>&#13;
<p>In this <kbd>if</kbd> statement, instead of defining a Boolean expression, we are assigning our optional value to a constant; the <kbd>if</kbd> statement uses this to <em>conditionally unwrap</em> the optional. The optional value is checked to see whether it is <kbd>nil</kbd>; if it is not <kbd>nil</kbd>, then the value is unwrapped and assigned to the constant as a non-optional value. That constant becomes available within the scope of the curly brackets following the <kbd>if</kbd> statement. We use that <kbd>ballType</kbd> non-optional value to obtain the raw value for the <kbd>print</kbd> statement.</p>&#13;
<p>Since the <kbd>if</kbd> branch of the <kbd>if-else</kbd> statement is followed when the optional value has a value, then the <kbd>else</kbd> branch is followed when the optional value is <kbd>nil</kbd>.</p>&#13;
<p><span>As this means that the given number is not valid for a pool ball, we print a relevant message:</span></p>&#13;
<pre>else { <br/>    print("\(number) is not a valid pool ball number") <br/>}</pre>&#13;
<p class="mce-root">We can now call our new function with the same values as before to print out the pool ball type:</p>&#13;
<pre class="p1">printBallDetails<span class="s1">(ofNumber: </span><span class="s2">2</span><span class="s1">)  </span><span class="s3">// 2 - solid<br/></span>printBallDetails<span class="s1">(ofNumber: </span><span class="s2">8</span><span class="s1">)  </span><span class="s3">// 8 - black<br/></span>printBallDetails<span class="s1">(ofNumber: </span><span class="s2">12</span><span class="s1">) </span><span class="s3">// 12 - stripe<br/></span><span class="s4">printBallDetails</span><span class="s1">(ofNumber: </span><span class="s2">0</span><span class="s1">)  </span>// 0 is not a valid pool ball number<br/><span class="s4">printBallDetails</span><span class="s1">(ofNumber: </span><span class="s2">16</span><span class="s1">) </span>// 16 is not a valid pool ball number</pre>&#13;
<p>We've used conditional unwrapping to print the pool ball type, if valid, or explain it's not valid.</p>&#13;
<h3 id="uuid-e9800095-1217-4d78-81aa-9d2f0ee8dc66">Chaining optional unwrapping</h3>&#13;
<p>The ability of <kbd>if</kbd> statements to conditionally unwrap optionals can be chained together to produce some useful and concise code. The following example is a bit contrived, but it illustrates how we can use a single <kbd>if</kbd> statement to unwrap a chain of optional values.</p>&#13;
<p>When you play a game of pool, called a <em>frame</em>, the type of the first ball you pot becomes the type you need to pot for the rest of the frame, and your opponent has to pot the opposite type.</p>&#13;
<p>Let's define a frame of pool and say that we want to track what type of ball each player will be potting:</p>&#13;
<pre>class PoolFrame { <br/>    var player1BallType: PoolBallType? <br/>    var player2BallType: PoolBallType? <br/>} </pre>&#13;
<p>We will also create a <kbd>PoolTable</kbd> object that has an optional <kbd>currentFrame</kbd> property, which will contain information about the current frame if one is in progress:</p>&#13;
<pre>class PoolTable { <br/>    var currentFrame: PoolFrame? <br/>} </pre>&#13;
<p>We now have a pool table that has an optional frame and a frame that has an optional ball type for each player.</p>&#13;
<p>Now, let's write a function that prints the ball type for player 1 in the current frame. It is possible that the current frame is <kbd>nil</kbd> because there is no frame currently being played, or that player 1's ball type is <kbd>nil</kbd> because a ball hasn't yet been potted. Therefore, we need to account for either of those being <kbd>nil</kbd>:</p>&#13;
<pre>func printBallTypeOfPlayer1(forTable table: PoolTable) { <br/>    if let frame = table.currentFrame, let ballType = <br/>      frame.player1BallType { <br/>        print(ballType.rawValue) <br/>    } else { <br/>        print("Player 1 has no ball type or there is no current frame") <br/>    } <br/>} </pre>&#13;
<p>Our function is given a <kbd>PoolTable</kbd>, and to print player 1's ball type, we first need to check and unwrap the <kbd>currentFrame</kbd> property, and then we need to check and unwrap the current frame's <kbd>player1BallType</kbd> property.</p>&#13;
<p>We could do this by nesting our <kbd>if</kbd> statements:</p>&#13;
<pre>func printBallTypeOfPlayer1(forTable table: PoolTable) { <br/>    if let frame = table.currentFrame { <br/>        if let ballType = frame.player1BallType { <br/>            print(ballType.rawValue) <br/>        } //... handle else <br/>    } //... handle else <br/>} </pre>&#13;
<p>Instead, we can handle this chained unwrapping in one <kbd>if</kbd> statement by performing the unwrapping statement sequentially, separated by commas, and each statement can access the unwrapped values from the previous statements:</p>&#13;
<pre>func printBallTypeOfPlayer1(forTable table: PoolTable) { <br/>    if let frame = table.currentFrame, let ballType = <br/>      frame.player1BallType { <br/>        print("\(ballType)") <br/>    } //... handle else  <br/>} </pre>&#13;
<p>The first statement unwraps the <kbd>currentFrame</kbd> property, and the second statement uses that unwrapped frame to unwrap player 1's ball type.</p>&#13;
<p>Let's use the function we've just created:</p>&#13;
<ol>&#13;
<li>First, we'll create a table, and without a current frame print player 1's ball type, which won't be available:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">//<br/>// Table with no frame in play<br/>//<br/><span class="s1">let</span> table = <span class="s2">PoolTable</span>()<br/>table<span class="s3">.</span>currentFrame<span class="s3"> = </span><span class="s1">nil<br/></span>printBallTypeOfPlayer1<span class="s3">(forTable: </span><span class="s2">table</span><span class="s3">)<br/></span>// Player 1 has no ball type or there is no current frame</pre>&#13;
<ol start="2">&#13;
<li>Next, we can create a current frame, but as player 1's ball type is still <kbd>nil</kbd>, the function prints the same output:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">//<br/>// Table with frame in play, but no balls potted<br/>//<br/><span class="s1">let</span> frame = <span class="s2">PoolFrame</span>()<br/>frame<span class="s3">.</span>player1BallType<span class="s3"> = </span><span class="s1">nil<br/></span>frame<span class="s3">.</span>player2BallType<span class="s3"> = </span><span class="s1">nil<br/></span>table<span class="s3">.</span>currentFrame<span class="s3"> = </span>frame<br/>printBallTypeOfPlayer1<span class="s3">(forTable: </span><span class="s2">table</span><span class="s3">)<br/></span>// Player 1 has no ball type or there is no current frame<br/><br/></pre>&#13;
<ol start="3">&#13;
<li>If we set player 1's ball type, now our function prints the type:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">//<br/>// Table with frame in play, and a ball potted<br/>//<br/>frame<span class="s3">.</span>player1BallType<span class="s3"> = .</span><span class="s4">solid<br/></span>frame<span class="s3">.</span>player2BallType<span class="s3"> = .</span><span class="s4">stripe<br/></span>printBallTypeOfPlayer1<span class="s3">(forTable: </span><span class="s2">table</span><span class="s3">)<br/></span>// solid</pre>&#13;
<p>We've created a method that can chain conditional unwrappings, only printing a value when all the values in the chain are non-nil. </p>&#13;
<h3 id="uuid-7ceb1c7a-a479-4aec-bdaf-704eced82447">Using enums with associated values</h3>&#13;
<p>As we saw in the <em>Enumerating values with enums </em>recipe from <a href="f9d48715-ffca-464f-95bf-722958f02e72.xhtml">C<span class="ChapterrefPACKT">hapter 1</span></a>, <em>Swift Building Blocks</em>, enums can have associated values, and we can use an <kbd>if</kbd> statement to both check an enum's case and extract the associated value in one expression.</p>&#13;
<p>Let's create an enum to represent the result of the pool game, with each case having an associated message:</p>&#13;
<pre>enum FrameResult { <br/>    case win(congratulations: String) <br/>    case lose(commiserations: String) <br/>}</pre>&#13;
<p>Next, we'll create a function that takes a <kbd>Result</kbd> and prints either the congratulatory message or the commiseration message:</p>&#13;
<pre>func printMessage(forResult result: FrameResult) { <br/>    if case Result.win(congratulations: let winMessage) = result { <br/>        print("You won! \(winMessage)") <br/>    } else if case Result.lose(commiserations: let loseMessage) = <br/>        result { <br/>        print("You lost :( \(loseMessage)") <br/>    } <br/>} </pre>&#13;
<p>Calling this function will print the result, followed by the relevant message:</p>&#13;
<pre>let result = Result.win(congratulations: "You're simply the best!") <br/>printMessage(forResult: result) // You won! You're simply the best! </pre>&#13;
<p>The <kbd>if case</kbd> block will be executed if the value on the right-hand side of the <kbd>=</kbd> matches the case on the left-hand side. In addition, you can specify a local constant for the associated value (<kbd>winMessage</kbd> in the following example), which is then available within the subsequent block:</p>&#13;
<pre>if case Result.win(congratulationsMessage: let winMessage) = result { <br/>    print("You won! \(winMessage)") <br/>} </pre>&#13;
<p>We've used the <kbd>if case</kbd> statement to both check the case of an enum value and access its associated value in one go.</p>&#13;
<h2 id="uuid-b333c3ec-0018-45fd-9f32-85bbcb5201ac">See also</h2>&#13;
<p>Further information about if/else can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/statements">http://swiftbook.link/docs/statements.</a></p>&#13;
<h1 id="uuid-df319e75-8dcd-4cb2-a72d-8555dbcf1ef0">Handling all cases with switch</h1>&#13;
<p><kbd>switch</kbd> statements allow you to control the flow of execution by testing one specific value in multiple ways. In Objective-C and other languages, <kbd>switch</kbd> statements can only be used on values that can be represented by an integer, and are most commonly used to make decisions based on enumeration cases.</p>&#13;
<p>As we have seen, <strong>enumerations</strong> have become a lot more powerful in Swift, as they can be based on more than just integers, and so too can <kbd>switch</kbd> statements.</p>&#13;
<p><kbd>switch</kbd> statements in Swift can be used on any type and have advanced pattern-matching functionality.</p>&#13;
<p>In this recipe, we will explore both simple and advanced usage of <kbd>switch</kbd> control flow statements to control logic.</p>&#13;
<h2 id="uuid-3758d0ea-6701-4726-82e0-7beffe2ad6a3">Getting ready</h2>&#13;
<p>If you are old enough to remember the early days of the home computer, you may also remember text-based adventures. These were simple games that usually described a scene and then let you move around by typing a command to move north, south, east, or west. You would find and pick up items, and could often combine them to solve puzzles.</p>&#13;
<p>We can use <kbd>switch</kbd> statements to control the logic of a simple text adventure. </p>&#13;
<h2 id="uuid-2b269551-9854-4f1b-ab67-26e5f48b499d">How to do it...</h2>&#13;
<p>Let's create parts of a text-based adventure, and use <kbd>switch</kbd> statements to make the decisions:</p>&#13;
<ol>&#13;
<li>Define an <kbd>enum</kbd> to represent the directions we can travel in:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum CompassPoint { <br/>    case north <br/>    case south <br/>    case east <br/>    case west <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Create a function that describes what the player of the text adventure will see when they look in that direction:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func lookTowards(_ direction: CompassPoint) { <br/> <br/>    switch direction { <br/>    case .north: <br/>        print("To the north lies a winding road") <br/>    case .south: <br/>        print("To the south is the Prancing Pony tavern") <br/>    case .east: <br/>        print("To the east is a blacksmith") <br/>    case .west: <br/>        print("The the west is the town square") <br/>    } <br/>} <br/><br/>lookTowards(.south) // To the south is the Prancing Pony tavern</pre>&#13;
<p style="padding-left: 60px">In our text adventure, users can pick up items and attempt to combine them to produce new items and solve problems.</p>&#13;
<ol start="3">&#13;
<li>Define our available items as an <kbd>enum</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum Item { <br/>    case key <br/>    case lockedDoor <br/>    case openDoor <br/>    case bluntKnife <br/>    case sharpeningStone <br/>    case sharpKnife <br/>} </pre>&#13;
<ol start="4">&#13;
<li>Write a function that takes two items and tries to combine them into a new item. If the items cannot be combined, it will return <kbd>nil:</kbd></li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func combine(_ firstItem: Item, with secondItem: Item) -&gt; Item? { <br/> <br/>    switch (firstItem, secondItem) { <br/>    case (.key, .lockedDoor): <br/>        print("You have unlocked the door!") <br/>        return .openDoor <br/>    case (.bluntKnife, .sharpeningStone): <br/>        print("Your knife is now sharp") <br/>        return .sharpKnife <br/>    default: <br/>        print("\(firstItem) and \(secondItem) cannot be combined") <br/>        return nil <br/>    } <br/>} <br/>let door = combine(.key, with: .lockedDoor) // openDoor <br/>let oilAndWater = combine(.bluntKnife, with: .lockedDoor) // nil</pre>&#13;
<ol start="5">&#13;
<li>In our text adventure, the player will meet different characters and can interact with them. Define the characters that the player can meet:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum Character: String { <br/>    case wizard <br/>    case bartender <br/>    case dragon <br/>}</pre>&#13;
<ol start="6">&#13;
<li>Write a function that allows the player to say something, and optionally provide a character to whom it will be said. The interaction that will occur will depend on what is said and the character it is said to:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func say(_ textToSay: String, to character: Character? = nil) { <br/> <br/>    switch (textToSay, character) { <br/>    case ("abracadabra", .wizard?): <br/>        print("The wizard says, \"Hey, that's my line!\"") <br/>    case ("Pour me a drink", .bartender?): <br/>        print("The bartender pours you a drink") <br/>    case ("Can I have some of your gold?", .dragon?): <br/>        print("The dragon burns you to death with his fiery breath") <br/>    case (let textSaid, nil): <br/>        print("You say \"\(textSaid)\", to no-one.") <br/>    case (_, let anyCharacter?): <br/>        print("The \(anyCharacter) looks at you, blankly") <br/>    } <br/>} <br/>say("Is anybody there?") <br/>  // You say "Is anybody there?", to no-one. <br/>say("Pour me a drink", to: .bartender) <br/>  // The bartender pours you a drink <br/>say("Can I open a tab?", to: .bartender) <br/>  // The bartender looks at you, blankly </pre>&#13;
<h2 id="uuid-765ebbd1-a4ff-47a6-8cfe-899693aad091">How it works...</h2>&#13;
<p>Within the <kbd>lookTowards</kbd> function, we want to print a different message for each possible <kbd>CompassPoint</kbd> case; to do this, we use a <kbd>switch</kbd> statement:</p>&#13;
<pre>func lookTowards(_ direction: CompassPoint) { <br/>     <br/>    switch direction { <br/>    case .north: <br/>        print("To the north lies a winding road") <br/>    case .south: <br/>        print("To the south is the Prancing Pony tavern") <br/>    case .east: <br/>        print("To the east is a blacksmith") <br/>    case .west: <br/>        print("The the west is the town square") <br/>    }<br/>}</pre>&#13;
<p>At the top of the <kbd>switch</kbd> statement, we define the value that we want to switch on; then we define what we want to be done when that value matches each of the defined cases using the <kbd>case</kbd> keyword and then the matching pattern:</p>&#13;
<pre>switch &lt;#value#&gt; { <br/>case &lt;#pattern#&gt;: <br/>    &lt;#code#&gt; <br/>case &lt;#pattern#&gt;: <br/>    &lt;#code#&gt; <br/>//... <br/>} </pre>&#13;
<p>Each <kbd>case</kbd> statement is evaluated in turn, and if the pattern matches the value, the subsequent code is executed.</p>&#13;
<div class="packt_infobox">If you are familiar with <kbd>switch</kbd> statements from Objective-C, you may remember that you needed to add <kbd>break;</kbd> at the end of each <kbd>case</kbd> statement to stop the execution from falling through to the next <kbd>case</kbd> statement. This is not needed in Swift; the break in execution is implied by the beginning of the next <kbd>case</kbd> statement. The only time this isn't the case, it is because your <kbd>case</kbd> statement is intentionally empty; in these cases, you need to add <kbd>break</kbd> to tell the compiler that it is intentionally blank for this case. If you do want execution to fall through to the next <kbd>case</kbd> statement, you can add <kbd>fallthrough</kbd> at the end of the <kbd>case</kbd> statement.</div>&#13;
<p>In our <kbd>combine</kbd> function, we have two values that we want to switch based on their values. We can provide multiple values to the <kbd>switch</kbd> statement in the form of a tuple:</p>&#13;
<pre>func combine(_ firstItem: Item, with secondItem: Item) -&gt; Item? { <br/>     <br/>    switch (firstItem, secondItem) { <br/>    //.... <br/>    } <br/>} </pre>&#13;
<p>For each <kbd>case</kbd> statement, we define the valid value for each part of the tuple:</p>&#13;
<pre>case (.key, .lockedDoor): <br/>    print("You have unlocked the door!") <br/>    return .openDoor</pre>&#13;
<p>A <kbd>switch</kbd> statement in Swift requires that every possible case is covered; however, you can cover all the remaining possibilities in one go using the <kbd>default</kbd> case:</p>&#13;
<pre>switch (firstItem, secondItem) { <br/>//... <br/>default: <br/>    print("\(firstItem) and \(secondItem) cannot be combined") <br/>    return nil <br/>} </pre>&#13;
<p>For our preceding <kbd>combine</kbd> function, you will notice that the player will only be able to combine the items if they provide them in the right order:</p>&#13;
<pre>let door1 = combine(.key, with: .lockedDoor) // openDoor <br/>let door2 = combine(.lockedDoor, with: .key) // nil </pre>&#13;
<p>This is not the desired behavior, as there is no way for the player to know the correct order. To solve this, we can add multiple patterns to each <kbd>case</kbd> statement. So, when the player provides the <kbd>key</kbd> and <kbd>lockedDoor</kbd> items, we can handle the order <kbd>key</kbd>, <kbd>lockedDoor</kbd>, and the order <kbd>lockedDoor</kbd>, <kbd>key</kbd> with the same <kbd>case</kbd> statement, using the following format:</p>&#13;
<pre>switch &lt;#value#&gt; { <br/>case &lt;#pattern#&gt;, &lt;#pattern#&gt;: <br/>    &lt;#code#&gt; <br/>default: <br/>    &lt;#code#&gt; <br/>} </pre>&#13;
<p>So, we can add the opposite item order as another pattern to each case:</p>&#13;
<pre>func combine(_ firstItem: Item, with secondItem: Item) -&gt; Item? { <br/>     <br/>    switch (firstItem, secondItem) { <br/>    case (.key, .lockedDoor), (.lockedDoor, .key): <br/>        print("You have unlocked the door!") <br/>        return .openDoor <br/>    case (.bluntKnife, .sharpeningStone), (.sharpeningStone, <br/>      .bluntKnife): <br/>        print("Your knife is now sharp") <br/>        return .sharpKnife <br/>    default: <br/>        print("\(firstItem) and \(secondItem) cannot be combined") <br/>        return nil <br/>    } <br/>} <br/> </pre>&#13;
<p>Now the items can be combined in any order:</p>&#13;
<pre>let door1 = combine(.key, with: .lockedDoor) // openDoor <br/>let door2 = combine(.lockedDoor, with: .key) // openDoor</pre>&#13;
<p>For our <kbd>say</kbd> method, we again have two values that we want to switch on: the text that the player says, and the character to whom it is said. Since the <kbd>character</kbd> value is optional, we will need to unwrap the value to compare it with non-optional values:</p>&#13;
<pre>func say(_ textToSay: String, to character: Character? = nil) { <br/>     <br/>    switch (textToSay, character) { <br/>    case ("abracadabra", .wizard?): <br/>        print("The wizard says, "Hey, that's my line!"") <br/>        //... <br/>    } <br/>} </pre>&#13;
<p>In a <kbd>switch</kbd> statement, when the value is optional, you can compare it to a non-optional value by adding a <kbd>?</kbd> to wrap it as an optional, making the comparison valid. In the preceding instance, we are comparing the optional <kbd>character</kbd> value to <kbd>.wizard?</kbd>.</p>&#13;
<p>Where we have two values for a certain set of options, we may only care about one of the values, and the other value could be anything and the case would still be valid. In our example, once all the specific <kbd>textToSay</kbd> and character pairings have been handled, and the case where there is no character is handled, we want to unwrap and retrieve the character, but we don't care about the <kbd>textToSay</kbd> value, so we can use <kbd>_</kbd> to indicate that any value is acceptable:</p>&#13;
<pre>func say(_ textToSay: String, to character: Character? = nil) { <br/>     <br/>    switch (textToSay, character) { <br/>    //... <br/>    case (_, let anyCharacter?): <br/>        print("The \(anyCharacter) looks at you, blankly)") <br/>    } <br/>} </pre>&#13;
<p>To retrieve the value of the character entered as part of this <kbd>case</kbd> statement rather than declaring a value to be matched, we define a constant that will receive the value, and since the value we are switching on is optional, we also add <kbd>?</kbd>, which will unwrap the value if not <kbd>nil</kbd>, and assign it to the constant.</p>&#13;
<h2 id="uuid-4e31b2f6-ccd2-429b-9e53-83155c5ea3e5">See also</h2>&#13;
<p>Further information about <kbd>switch</kbd> can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/switch">http://swiftbook.link/docs/switch</a>.</p>&#13;
<h1 id="uuid-d2f162c0-cdb4-48ea-8274-441f578e963f">Looping with for loops</h1>&#13;
<p><kbd>for</kbd> loops allow you to execute code for each element in a collection or range. In this recipe, we will explore how to use <kbd>for</kbd> loops to perform actions on every element in a collection.</p>&#13;
<h2 id="uuid-81b2065d-f5c4-4065-93df-6b22373d88a4">How to do it...</h2>&#13;
<p>Let's create some collections and then use <kbd>for</kbd> loops to act on each element in the collection:</p>&#13;
<ol>&#13;
<li>Create an array of elements, so we can do something with every item in the array:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let theBeatles = ["John", "Paul", "George", "Ringo"]</pre>&#13;
<ol start="2">&#13;
<li>Create a loop to go through our <kbd>theBeatles</kbd> array and print each string element that the <kbd>for</kbd> loop provides:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">for musician in theBeatles { <br/>    print(musician) <br/>} </pre>&#13;
<ol start="3">&#13;
<li>Create a <kbd>for</kbd> loop that executes some code a set number of times, instead of looping through an array. We can do this by providing a range instead of a collection:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// 5 times table <br/>for value in 1...12 { <br/>    print("5 x \(value) = \(value*5)") <br/>}</pre>&#13;
<ol start="4">&#13;
<li>Create a <kbd>for</kbd> loop to print the keys and values of a dictionary. Dictionaries contain pairings between a key and a value, so when looping through a dictionary, we will be provided with both the key and the value in the form of a tuple:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let beatlesByInstrument = ["rhythm guitar": "John", <br/>                           "bass guitar": "Paul", <br/>                           "lead guitar": "George", <br/>                           "drums": "Ringo"] <br/>for (key, value) in beatlesByInstrument { <br/>    print("\(value) plays \(key)") <br/>}</pre>&#13;
<h2 id="uuid-c3969d9a-5011-48ac-a838-7109d82c5453">How it works...</h2>&#13;
<p>Let's look at how we looped through our <kbd>theBeatles</kbd> array:</p>&#13;
<pre>for musician in theBeatles { <br/>    print(musician) <br/>} </pre>&#13;
<p>We specify the <kbd>for</kbd> keyword and then we provide a name for the local variable that will be used for each element in the collection or range. Then, the <kbd>in</kbd> keyword is provided, followed by the collection or range that will be looped through:</p>&#13;
<pre>for &lt;#each element#&gt; in &lt;#collection or range#&gt; { <br/>    &lt;#code to execute#&gt; <br/>} </pre>&#13;
<p>For range-based loops, the value provided for each loop is the next integer in the range:</p>&#13;
<pre>for value in 1...12 { <br/>    print("5 x \(value) = \(value*5)") <br/>} <br/> </pre>&#13;
<p>A range can be a <em>closed range,</em> where the range includes the start value and the end value, like the one specified above. Or it can be a <em>half-open range</em>, which goes up to, but doesn't include, the last value, like the following code:</p>&#13;
<pre>for value in 1..&lt;13 { <br/>    print("5 x \(value) = \(value*5)") <br/>} </pre>&#13;
<p>When looping through a dictionary, we need to be provided with both the key and value; to do this, we provide a tuple that will receive each key and value in the dictionary:</p>&#13;
<pre>for (key, value) in beatlesByInstrument { <br/>    print("\(value) plays \(key)") <br/>} </pre>&#13;
<p>We can define the tuple and name each of the values. This name can then be used in an execution block. Let's change the tuple labels to better describe the values:</p>&#13;
<pre>for (instrument, musician) in beatlesByInstrument { <br/>    print("\(musician) plays \(instrument)") <br/>} </pre>&#13;
<p>Giving the tuple meaningful names in the preceding example makes the code easier to read. </p>&#13;
<h2 id="uuid-edc93053-6141-44f7-9554-a275c9822ad1">See also</h2>&#13;
<p>Further information about <kbd>for-in</kbd> loops can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/for-in">http://swiftbook.link/docs/for-in</a>.</p>&#13;
<h1 id="uuid-2f0b3dd2-7031-4de8-8419-447ed1d7b4c5">Looping with while loops</h1>&#13;
<p><kbd>for</kbd> loops are great when you know how many times you intend to loop, but if you want to loop until a certain condition is met, you need a <kbd>while</kbd> loop.</p>&#13;
<p>A <kbd>while</kbd> loop has the following syntax:</p>&#13;
<pre>while &lt;#boolean expression#&gt; { <br/>    &lt;#code to execute#&gt; <br/>} </pre>&#13;
<p>The code block will execute over and over until the Boolean expression returns <kbd>false</kbd>. Therefore, it's a common pattern to change some value in the code block that may cause the Boolean expression to change to <kbd>false</kbd>.</p>&#13;
<div class="packt_infobox">If there is no chance of the Boolean expression becoming <kbd>true</kbd>, the code will loop forever, which can lock up your app.</div>&#13;
<p>In this recipe, we will look at situations where a <kbd>while</kbd> loop can be useful for repeating actions.</p>&#13;
<h2 id="uuid-fc9b9972-faff-4b28-ac9e-e9e981cfce0d">Getting ready</h2>&#13;
<p>This recipe will involve simulating the random flip of a coin. To flip our coin, we will need to randomly pick either heads or tails, so we will need to use a random number generator from the Foundation framework. We will discuss Foundation further in <a href="a632f18a-5826-4757-90bc-7701c78edaaf.xhtml">Chapter 5</a>, <em>Beyond the Standard Library</em>, but for now, we just need to import the Foundation framework at the top of our playground:</p>&#13;
<pre>import Foundation</pre>&#13;
<p>This will give us the ability to generate a random number, which we will use now.</p>&#13;
<h2 id="uuid-aa6812a6-1ed2-4eca-bf65-dac38b53ab41">How to do it...</h2>&#13;
<p><span>Let's work out how many times in a row we can flip a coin and get heads:</span></p>&#13;
<ol>&#13;
<li>Create an <kbd>enum</kbd> to represent a coin flip, and use the random number generator to randomly choose heads or tails:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum CoinFlip: Int { <br/>    case heads <br/>    case tails <br/> <br/>    static func flipCoin() -&gt; CoinFlip { <br/>        return CoinFlip(rawValue: Int(arc4random_uniform(2)))! <br/>    } <br/>} </pre>&#13;
<ol start="2">&#13;
<li>Create a function that will return the number of heads in a row from coin flips. The function will flip the coin within a <kbd>while</kbd> loop and continue to loop while the coin flip results in heads:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func howManyHeadsInARow() -&gt; Int { <br/> <br/>    var numberOfHeadsInARow = 0 <br/>    var currentCoinFlip = CoinFlip.flipCoin() <br/> <br/>    while currentCoinFlip == .heads { <br/>        numberOfHeadsInARow = numberOfHeadsInARow + 1 <br/>        currentCoinFlip = CoinFlip.flipCoin() <br/>    } <br/>    return numberOfHeadsInARow <br/>} <br/> <br/>let noOfHeads = howManyHeadsInARow()</pre>&#13;
<h2 id="uuid-5fc659c6-1e62-4759-b50c-7fb4bd148757">How it works...</h2>&#13;
<p>In our function, we start by keeping track of how many coin flips in a row are heads and keep a reference to the current coin flip, which will form the condition for the <kbd>while</kbd> loop:</p>&#13;
<pre>func howManyHeadsInARow() -&gt; Int { <br/>     <br/>    var numberOfHeadsInARow = 0 <br/>    var currentCoinFlip = CoinFlip.flipCoin() <br/>    //... <br/>}</pre>&#13;
<p>In our <kbd>while</kbd> loop, we will continue to loop and execute the code in the following block while the current coin flip is heads:</p>&#13;
<pre>while currentCoinFlip == .heads { <br/>    numberOfHeadsInARow = numberOfHeadsInARow + 1 <br/>    currentCoinFlip = CoinFlip.flipCoin() <br/>} </pre>&#13;
<p>Within the code block, we add one to our running total and we re-flip the coin. We are flipping the coin and assigning it to <kbd>currentCoinFlip</kbd>, which will get rechecked on the next loop and if it is still heads, the next loop will be executed. Since we are changing something that affects the <kbd>while</kbd> condition, such that it could eventually be <kbd>false</kbd>, we can be sure that we won't be stuck in the loop forever.</p>&#13;
<p>As soon as the coin flip is tails, the <kbd>while</kbd> loop condition will be <kbd>false</kbd>, and so the execution will move on and return the running total we have been keeping:</p>&#13;
<pre>return numberOfHeadsInARow </pre>&#13;
<p>Now, every time you call the function, the coin will be randomly flipped and the number of heads in a row will be returned, so each time it's called, you may get a different value returned. Try it out a few times:</p>&#13;
<pre>let noOfHeads = howManyHeadsInARow() </pre>&#13;
<h2 id="uuid-d3f60315-e913-498f-90c3-e5f9598eefee">There's more...</h2>&#13;
<p>We can actually simplify our <kbd>while</kbd> loop by doing the coin flip as part of the loop continuation checking:</p>&#13;
<pre class="p1"><span class="s1">func</span> howManyHeadsInARow() -&gt; <span class="s2">Int</span> {<br/><span class="Apple-converted-space">    <br/></span><span class="Apple-converted-space">    </span><span class="s1">var</span> numberOfHeadsInARow = <span class="s3">0<br/></span><span class="Apple-converted-space">    <br/></span><span class="Apple-converted-space">    </span><span class="s1">while</span> <span class="s4">CoinFlip</span>.<span class="s5">flipCoin</span>() == .<span class="s5">heads</span> {<br/><span class="Apple-converted-space">        </span>numberOfHeadsInARow = numberOfHeadsInARow + <span class="s3">1<br/></span><span class="Apple-converted-space">    </span>}<br/><span class="Apple-converted-space">    </span><span class="s1">return</span> numberOfHeadsInARow<br/>}</pre>&#13;
<p>Each time through the loop, the <kbd>while</kbd> condition is evaluated, which involves re-flipping the coin and checking the outcome.</p>&#13;
<p>This is more concise and removes the need to track <kbd>currentCoinFlip</kbd>.</p>&#13;
<h2 id="uuid-136a0797-9d7d-49ed-ae6f-88baf90617f5">See also</h2>&#13;
<p>Further information about <kbd>while</kbd> loops can be found in Apple's documentation of the Swift language at <a href="http://swiftbook.link/docs/while">http://swiftbook.link/docs/while</a>.</p>&#13;
<h1 id="uuid-4159ef2b-a684-47be-812b-30a45ef165f0">Handling errors with try, throw, do, and catch</h1>&#13;
<p>Errors happen during programming. These errors may be due to your own code behaving in unexpected ways, or due to unexpected information or behavior from external systems. When these errors happen, it's important to handle them appropriately. Good error handling can separate a good app from a great app.</p>&#13;
<p>Swift provides a deliberate and flexible pattern for handling errors, allowing specific errors to be cascaded through a complex system.</p>&#13;
<p>In this recipe, we will discover how to define errors, and throw them when necessary.</p>&#13;
<h2 id="uuid-55dd1fcb-6d57-4bdb-9a77-1f9171458a40">How to do it...</h2>&#13;
<p>To examine error handling, we will model a process that can go wrong, and for me, that is cooking a meal:</p>&#13;
<ol>&#13;
<li>First, let's define the steps involved in cooking a meal as states that the meal will transition through:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum MealState { <br/>    case initial <br/>    case buyIngredients <br/>    case prepareIngredients <br/>    case cook <br/>    case plateUp <br/>    case serve <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Create an object to represent the meal we will be cooking. This object will hold the state of the meal as it moves through the process:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Meal {<br/>    var state: MealState = .initial<br/>}</pre>&#13;
<p style="padding-left: 60px">We want to allow the meal to transition between states, but not all state transitions should be possible. For instance, you can't move from buying ingredients to serving the meal. The meal should move sequentially from one state to the next. We can provide these restrictions by only allowing the state to be set from within the object itself, using access controls that we explored in the previous chapter.</p>&#13;
<ol start="3">&#13;
<li>Define the <kbd>state</kbd> property as only being privately settable:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Meal {<br/>    private(set) var state: MealState = .initial<br/>}</pre>&#13;
<ol start="4">&#13;
<li>To allow the state to be changed from outside the object, create a function that will throw an error if the state transition isn't possible:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Meal {<br/> <br/>    private(set) var state: MealState = .initial<br/> <br/>    func change(to newState: MealState) throws {<br/> <br/>        switch (state, newState) {<br/><br/>        case (.initial, .buyIngredients),<br/>             (.buyIngredients, .prepareIngredients),<br/>             (.prepareIngredients, .cook),<br/>             (.cook, .plateUp),<br/>             (.plateUp, .serve):<br/>            <br/>            state = newState<br/> <br/>        default:<br/>            throw MealError.canOnlyMoveToAppropriateState<br/>        }<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px">In keeping with Swift's protocol-orientated approach, errors in Swift are defined as a protocol, <kbd>Error</kbd>. This approach allows you to construct your own type to represent errors within your code, and just have it conform to the <kbd>Error</kbd> protocol.</p>&#13;
<p style="padding-left: 60px">A common approach is to define errors as enums, with the enum cases representing the different types of errors that can occur.</p>&#13;
<ol start="5">&#13;
<li>Define the error thrown in the preceding <kbd>Meal</kbd> class:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum MealError: Error { <br/>    case canOnlyMoveToAppropriateState <br/>}</pre>&#13;
<ol start="6">&#13;
<li>Try to execute our error throwing method within a <kbd>do</kbd> block and catch any errors that may occur:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let dinner = Meal() <br/>do { <br/>    try dinner.change(to: .buyIngredients) <br/>    try dinner.change(to: .prepareIngredients) <br/>    try dinner.change(to: .cook) <br/>    try dinner.change(to: .plateUp) <br/>    try dinner.change(to: .serve) <br/>    print("Dinner is served!") <br/>} catch let error { <br/>    print(error) <br/>}</pre>&#13;
<h2 id="uuid-db51a954-32aa-47b8-aaf9-6984636b2343">How it works...</h2>&#13;
<p>The metaphor used in Swift error handling (as well as other languages) is <em>throwing</em> and <em>catching</em>. A method can <em>throw</em> an error if a problem occurs during its execution, at which point nothing further in the method will be executed, and the error is passed back to where the method was called from.</p>&#13;
<p>In order to receive this error (perhaps to provide the details of the error to the user), you must <em>catch</em> the error at the place the method is called.</p>&#13;
<p>To throw an error, you have to declare that the method has the potential to throw an error. Declaring that a method <kbd>throws</kbd> allows the compiler to expect potential errors from the method and ensure that you don't forget to catch these errors.</p>&#13;
<p>Methods can be declared as potentially throwing an error using the <kbd>throws</kbd> keyword:</p>&#13;
<pre>func change(to newState: MealState) throws { <br/>    //... <br/>} </pre>&#13;
<p>Within our change state method, we only change the state if we are moving to the next sequential state. Anything else isn't allowed and should throw an error. We can do this using the <kbd>throw</kbd> keyword, followed by a value that conforms to the <kbd>Error</kbd> protocol:</p>&#13;
<pre>func change(to newState: MealState) throws {<br/>    //...<br/>    default:<br/>         throw MealError.canOnlyMoveToAppropriateState<br/>    }<br/>}</pre>&#13;
<p>When we create the <kbd>Meal</kbd> object and move through the states of preparing the meal, each change of state can throw an error. When we call a method that is marked as possibly throwing an error, we have to do it a certain way. We define a <kbd>do</kbd> block, within which we may call methods that can throw, and we then define a <kbd>catch</kbd> block that will be executed if any of these methods do throw an error. Each call to a throwing method must be prefixed with the <kbd>try</kbd> keyword:</p>&#13;
<pre>let dinner = Meal() <br/>do { <br/>    try dinner.change(to: .buyIngredients) <br/>    try dinner.change(to: .prepareIngredients) <br/>    try dinner.change(to: .cook) <br/>    try dinner.change(to: .plateUp) <br/>    try dinner.change(to: .serve) <br/>    print("Dinner is served!") <br/>} catch let error { <br/>    print(error) <br/>} </pre>&#13;
<p>If any of these methods does throw an error, execution will immediately move to the <kbd>catch</kbd> block. Therefore, by placing code after the <kbd>try</kbd> methods are called, we are guaranteeing that it will only be executed if the methods do not throw an error. By printing <kbd>Dinner is served!</kbd> after all the state transitions are called, we know this will only print if we have successfully moved through all the states. Try changing the order of these state change calls, and you'll see that the error is printed, and <kbd>Dinner is served!</kbd> is not.</p>&#13;
<p>In our <kbd>catch</kbd> block, after the <kbd>catch</kbd> keyword, we can define the local constant that we want the caught error to be assigned to. However, if we don't specify a local constant here, Swift will implicitly create one for us called <kbd>error</kbd>, so we can actually omit the constant declaration in the <kbd>catch</kbd> block and still print the value of the error:</p>&#13;
<pre>do { <br/>    //... <br/>} catch { <br/>    print(error) <br/>} </pre>&#13;
<p>Swift has defined the error for us, so we can still print the value.</p>&#13;
<h2 id="uuid-5bb2e6d2-d2e5-41a9-9705-cabfe255d145">There's more...</h2>&#13;
<p>We have seen how we can throw and catch errors, but we mentioned in the introduction that we can cascade errors through a system, so let's look at how we can do this.</p>&#13;
<p>In our meal preparation example, we allow the meal state to be changed externally through a <kbd>change</kbd> method that can throw an error. Instead, let's change it to a private method, so we can only call it from within the class: </p>&#13;
<pre>class Meal { <br/>     <br/>    private(set) var state: MealState = .initial <br/>     <br/>    private func change(to newState: MealState) throws { <br/>         <br/>        switch (state, newState) { <br/>        case (.initial, .buyIngredients), <br/>             (.buyIngredients, .prepareIngredients),  <br/>             (.prepareIngredients, .cook),  <br/>             (.cook, .plateUp),  <br/>             (.plateUp, .serve): <br/>            state = newState <br/>             <br/>        default: <br/>            throw MealError.canOnlyMoveToAppropriateState <br/>        } <br/>    } <br/>} </pre>&#13;
<p><span>Next, let's create some specific methods for moving to each state:</span></p>&#13;
<pre>class Meal { <br/>     <br/>    //...<br/>     <br/>    func buyIngredients() throws { <br/>        try change(to: .buyIngredients) <br/>    } <br/>     <br/>    func prepareIngredients() throws { <br/>        try change(to: .prepareIngredients) <br/>    } <br/>     <br/>    func cook() throws { <br/>        try change(to: .cook) <br/>    } <br/>     <br/>    func plateUp() throws { <br/>        try change(to: .plateUp) <br/>    } <br/>     <br/>    func serve() throws { <br/>        try change(to: .serve) <br/>    } <br/>} </pre>&#13;
<p>You'll notice that when we call the <kbd>change</kbd> method from within each of the new methods, we don't need to use a <kbd>do</kbd> and <kbd>catch</kbd> block to catch the error; this is because we have defined each of the new methods as potentially throwing an error, so if the call to the <kbd>change</kbd> method throws an error, this error will be passed to the caller of our new method as though it were throwing an error.</p>&#13;
<p>This mechanism allows errors that may occur many levels deep in your code to surface and be handled appropriately.</p>&#13;
<p>We now need to amend our meal preparation code to use these new methods:</p>&#13;
<pre>let dinner = Meal() <br/>do { <br/>    try dinner.buyIngredients() <br/>    try dinner.prepareIngredients() <br/>    try dinner.cook() <br/>    try dinner.plateUp() <br/>    try dinner.serve() <br/>    print("Dinner is served!") <br/>} catch let error { <br/>    print(error) <br/>} </pre>&#13;
<p>Let's add the ability to actually affect our meal. We'll add a method to add salt to the meal and a property to allow us to track how much salt is added. Add these to the end of the <kbd>Meal</kbd> class:</p>&#13;
<pre>class Meal { <br/>    //... <br/>    private(set) var saltAdded = 0 <br/>     <br/>    func addSalt() throws { <br/>        if saltAdded &gt;= 5 { <br/>            throw MealError.tooMuchSalt <br/>        } else if case .initial = state, case .buyIngredients = state { <br/>            throw MealError.wrongStateToAddSalt <br/>        } else { <br/>            saltAdded = saltAdded + 1 <br/>        } <br/>    } <br/>} </pre>&#13;
<p>There are two ways in which adding salt can throw an error, either because we are in the wrong state to add salt (we can't add salt until after we have bought the ingredients), or because we have added too much salt. Let's add these two new errors to our <kbd>MealError</kbd> enum:</p>&#13;
<pre>enum MealError: Error { <br/>    case canOnlyMoveToAppropriateState <br/>    case tooMuchSalt <br/>    case wrongStateToAddSalt <br/>}</pre>&#13;
<p>We now have three possible errors that can occur during the preparation of a meal, and we may want to handle those errors differently. We can use multiple <kbd>catch</kbd> blocks to filter just specific errors that we want to catch, allowing us to handle each error separately:</p>&#13;
<pre>let dinner = Meal() <br/>do { <br/>    try dinner.buyIngredients() <br/>    try dinner.prepareIngredients() <br/>    try dinner.cook() <br/>    try dinner.plateUp() <br/>    try dinner.serve() <br/>    print("Dinner is served!") <br/>} catch MealError.canOnlyMoveToAppropriateState { <br/>    print("It's not possible to move to this state") <br/>} catch MealError.tooMuchSalt { <br/>    print("Too much salt!") <br/>} catch MealError.wrongStateToAddSalt { <br/>    print("Can't add salt at this stage") <br/>} catch { <br/>    print("Some other error: \(error)") <br/>} </pre>&#13;
<div class="packt_infobox">It is important to ensure that all possible errors are handled by the <kbd>catch</kbd> blocks, as an unhandled error will result in a crash. It is, therefore, safest to add an unfiltered <kbd>catch</kbd> block at the end to catch any errors not caught by the previous blocks.</div>&#13;
<p>Since functions can throw an error, and closures are a type of function that can be passed as a parameter, we can have a function that takes a throwing closure where it can also throw an error. It may be that the only errors our function will throw are errors produced by the throwing closure that was passed as a parameter.</p>&#13;
<p>When that is true, a function can be defined as re-throwing, using the <kbd>rethrows</kbd> keyword.</p>&#13;
<p>This situation is quite confusing, so let's look at an example:</p>&#13;
<pre>func makeMeal(using preparation: (Meal) throws -&gt; ()) rethrows -&gt; Meal { <br/>    let newMeal = Meal() <br/>    try preparation(newMeal) <br/>    return newMeal <br/>}  </pre>&#13;
<p>This <kbd>makeMeal</kbd> function takes a closure as a parameter; that closure takes a <kbd>Meal</kbd> object as a parameter and doesn't return anything, but may throw an error.</p>&#13;
<p>The purpose of this function is to handle the creation of the <kbd>meal</kbd> object for you, just leaving you to do any meal preparation within the block; it then returns the meal that was created and prepared. Let's see it in use:</p>&#13;
<pre>do { <br/>    let dinner = try makeMeal { meal in <br/>        try meal.buyIngredients() <br/>        try meal.prepareIngredients() <br/>        try meal.cook() <br/>        try meal.addSalt() <br/>        try meal.plateUp() <br/>        try meal.serve() <br/>    } <br/>    if dinner.state == .serve { <br/>        print("Dinner is served!") <br/>    } <br/>} catch MealError.canOnlyMoveToAppropriateState { <br/>    print("It's not possible to move to this state") <br/>} catch MealError.tooMuchSalt { <br/>    print("Too much salt!") <br/>} catch MealError.wrongStateToAddSalt { <br/>    print("Can't add salt at this stage") <br/>} </pre>&#13;
<p>The <kbd>makeMeal</kbd> function only throws errors thrown by the closure parameter, so it can be declared as re-throwing. Declaring a function of this type with the <kbd>rethrows</kbd> keyword isn't required, it can be declared with <kbd>throws</kbd> instead. However, the compiler can make additional optimizations for a re-throwing function.</p>&#13;
<h2 id="uuid-0d97aefb-01a9-4042-a413-cc809a0eb5c0">See also</h2>&#13;
<p>Further information about error handling can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/error-handling">http://swiftbook.link/docs/error-handling</a>.</p>&#13;
<h1 id="uuid-4174e4c9-64d5-4132-870c-e8b39af6f7db">Checking upfront with guard</h1>&#13;
<p>We have seen in previous recipes how we can use <kbd>if</kbd> statements to check Boolean expressions and unwrap optional values. It's a common use case to want to do some checks and conditional unwrapping at the beginning of a block of code, and then only execute the subsequent code if everything is as expected. This usually results in wrapping the whole block of code in an <kbd>if</kbd> statement:</p>&#13;
<pre>if &lt;#boolean check and unwrapping#&gt; { <br/>    &lt;#a block of code#&gt; <br/>    &lt;#that could be quite long#&gt; <br/>}</pre>&#13;
<p>Swift has a better solution expressly for this purpose; the <kbd>guard</kbd> statement.</p>&#13;
<p>In this recipe, we will learn how to use the <kbd>guard</kbd> statement to return early from a method.</p>&#13;
<h2 id="uuid-b2da937e-a6a4-4e0a-aba7-142237b16d2a">Getting ready</h2>&#13;
<p>Let's imagine that we have some data that came from an external source, and we want to turn it into model objects that our code can understand, with the intention of displaying it to the user. We can use <kbd>guard</kbd> statements to ensure the data is correctly formatted, bailing early if it isn't. </p>&#13;
<h2 id="uuid-805677b4-8393-463b-b871-c2242ef11adf">How to do it...</h2>&#13;
<p>We will take some information about the planets of the solar system, which could have come from an external source, and turn it into a model we can understand:</p>&#13;
<ol>&#13;
<li>Create the planet data in the form of an array of dictionaries:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// From https://en.wikipedia.org/wiki/Solar_System <br/>let inputData: [[String: Any]] = [ <br/>    ["name": "Mercury", <br/>     "positionFromSun": 1, <br/>     "fractionOfEarthMass": <span>0.055</span>,<br/>     "distanceFromSunInAUs": 0.4, <br/>     "hasRings": false], <br/>    ["name": "Venus", <br/>     "positionFromSun": 2, <br/>     "fractionOfEarthMass": 0.815, <br/>     "distanceFromSunInAUs": 0.7, <br/>     "hasRings": false], <br/>    ["name": "Earth", <br/>     "positionFromSun": 3, <br/>     "fractionOfEarthMass": 1.0, <br/>     "distanceFromSunInAUs": 1.0, <br/>     "hasRings": false], <br/>    ["name": "Mars", <br/>     "positionFromSun": 4, <br/>     "fractionOfEarthMass": 0.107, <br/>     "distanceFromSunInAUs": 1.5, <br/>     "hasRings": false], <br/>    ["name": "Jupiter", <br/>     "positionFromSun": 5, <br/>     "fractionOfEarthMass": 318.0,<br/>     "distanceFromSunInAUs": 5.2, <br/>     "hasRings": false], <br/>    ["name": "Saturn", <br/>     "positionFromSun": 6, <br/>     "fractionOfEarthMass": 95.0, <br/>     "distanceFromSunInAUs": 9.5, <br/>     "hasRings": true], <br/>    ["name": "Uranus", <br/>     "positionFromSun": 7, <br/>     "fractionOfEarthMass": 14.0, <br/>     "distanceFromSunInAUs": 19.2, <br/>     "hasRings": false], <br/>    ["name": "Neptune", <br/>     "positionFromSun": 8, <br/>     "fractionOfEarthMass": 17.0, <br/>     "distanceFromSunInAUs": 30.1, <br/>     "hasRings": false] <br/>] </pre>&#13;
<ol start="2">&#13;
<li>Define a <kbd>Planet</kbd> struct that will be created from the data:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct Planet { <br/>    let name: String <br/>    let positionFromSun: Int <br/>    let fractionOfEarthMass: Double <br/>    let distanceFromSunInAUs: Double <br/>    let hasRings: Bool <br/>}</pre>&#13;
<ol start="3">&#13;
<li>Taking this one step at a time, create a function that will take one-planet dictionaries and make a <kbd>Planet</kbd> struct, if it can. We'll use a <kbd>guard</kbd> statement to ensure that the dictionary has all the values we expect:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func makePlanet(fromInput input: [String: Any]) -&gt; Planet? { <br/> <br/>    guard <br/>        let name = input["name"] as? String, <br/>        let positionFromSun = input["positionFromSun"] as? Int, <br/>        let fractionOfEarthMass = input["fractionOfEarthMass"] as? <br/>          Double, <br/>        let distanceFromSunInAUs = input["distanceFromSunInAUs"] as? <br/>          Double, <br/>        let hasRings = input["hasRings"] as? Bool <br/>        else { <br/>            return nil <br/>        } <br/> <br/>    return Planet(name: name, <br/>                  positionFromSun: positionFromSun, <br/>                  fractionOfEarthMass: fractionOfEarthMass, <br/>                  distanceFromSunInAUs: distanceFromSunInAUs, <br/>                  hasRings: hasRings)<br/>}</pre>&#13;
<ol start="4">&#13;
<li>Now that we can handle individual planet data, create a function that will take an array of planet dictionaries and make an array of <kbd>Planet</kbd> structs, using a <kbd>guard</kbd> statement to ensure that we successfully create a <kbd>Planet</kbd> struct:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func makePlanets(fromInput input: [[String: Any]]) -&gt; [Planet] { <br/> <br/>    var planets = [Planet]() <br/>    for inputItem in input { <br/>        guard let planet = makePlanet(fromInput: inputItem) else { <br/>          continue } <br/>        planets.append(planet) <br/>    } <br/> <br/>    return planets <br/>}</pre>&#13;
<h2 id="uuid-09b9b3ff-045b-44e5-ab11-91f569a16a9a">How it works...</h2>&#13;
<p>The <kbd>guard</kbd> statement works in a very similar way to an <kbd>if</kbd> statement, as optional values can be unwrapped and chained together in the same way. Since our planet data contains strings, ints, floats, and Booleans, the dictionary is of the <kbd>[String: Any]</kbd> type. So, to create our <kbd>Planet</kbd> struct, we will need to check if the expected values exist for given keys and cast them to the correct type.</p>&#13;
<p>In our <kbd>makePlanet</kbd> function, we use the <kbd>guard</kbd> keyword and then access and conditionally cast all the values we require from the planet data dictionary. If any of these conditional casts fail, the <kbd>else</kbd> block, which is defined after the <kbd>guard</kbd> statement, is executed. We have defined our function to return an optional <kbd>Planet</kbd>, so if we don't have the information expected, the <kbd>guard</kbd> will fail, and return <kbd>nil</kbd>:</p>&#13;
<pre>func makePlanet(fromInput input: [String: Any]) -&gt; Planet? { <br/>     <br/>    guard  <br/>        let name = input["name"] as? String,  <br/>        let positionFromSun = input["positionFromSun"] as? Int,  <br/>        let fractionOfEarthMass = input["fractionOfEarthMass"] as? <br/>          Double,  <br/>        let distanceFromSunInAUs = input["distanceFromSunInAUs"] as? <br/>          Double,  <br/>        let hasRings = input["hasRings"] as? Bool  <br/>        else { <br/>            return nil <br/>    } <br/>     return Planet(name: name,  <br/>                  positionFromSun: positionFromSun,  <br/>                  fractionOfEarthMass: fractionOfEarthMass,  <br/>                  distanceFromSunInAUs: distanceFromSunInAUs,  <br/>                  hasRings: hasRings) <br/>} </pre>&#13;
<p>Any value unwrapped by the <kbd>guard</kbd> statement is made available to any code below the <kbd>guard</kbd> statement in the same scope; this makes the <kbd>guard</kbd> statement perfect for ensuring that input values are as expected before continuing. This removes the need to nest our code within an <kbd>if</kbd> block. The unwrapped values are then used to initialize the <kbd>Planet</kbd> struct.</p>&#13;
<p>As we have seen, a <kbd>guard</kbd> statement is for breaking execution when the <kbd>guard</kbd> condition fails, and therefore, the compiler ensures that an execution breaking statement is placed in the <kbd>else</kbd> block; this could be, for example, <kbd>return</kbd>, <kbd>break</kbd>, or <kbd>continue</kbd>.</p>&#13;
<p>In the <kbd>makePlanets</kbd> function, we use a <kbd>for</kbd> loop to iterate through the dictionaries and try to create a <kbd>Planet</kbd> struct from each one. If our <kbd>makePlanet</kbd> call returns <kbd>nil</kbd>, we call <kbd>continue</kbd> to skip this iteration of the <kbd>for</kbd> loop and jump to the next iteration:</p>&#13;
<pre>func makePlanets(fromInput input: [[String: Any]]) -&gt; [Planet] { <br/>    //... <br/>    for inputItem in input { <br/>        guard let planet = makePlanet(fromInput: inputItem) else { <br/>          continue } <br/>        planets.append(planet) <br/>    } <br/>    //... <br/>} </pre>&#13;
<h2 id="uuid-53986141-7cbd-465a-b4a1-2d9465624387">There's more...</h2>&#13;
<p>The<span> </span><kbd>makePlanets</kbd><span> </span>function accepts an array of planet data dictionaries and returns an array of<span> </span><kbd>Planet</kbd><span> </span>structs. If the array provided is empty, we may decide that this is not a valid input to our function and we want to throw an error; <kbd>guard</kbd> can help with this too.</p>&#13;
<p>We can check that any conditional statement is true with <kbd>guard</kbd> and if it isn't, we can throw an error:</p>&#13;
<pre>enum CreationError: Error {<br/>    case noData<br/>}<br/><br/>func makePlanets(fromInput input: [[String: Any]]) throws -&gt; [Planet] { <br/>     <br/>    guard input.count &gt; 0 else { throw CreationError.noData } <br/>    //... <br/>} </pre>&#13;
<h2 id="uuid-25d4b2df-cc14-4748-b9c7-cb05e7e950a3">See also</h2>&#13;
<p>Further information about <kbd>guard</kbd> statements can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/guard">http://swiftbook.link/docs/guard</a>.</p>&#13;
<h1 id="uuid-f890415f-7636-4ea2-a946-b6253f934777">Doing it later with defer</h1>&#13;
<p>Typically, when we call a function, control passes from the call site to the function, then the statements within the function are executed sequentially until either the end of the function or until a <kbd>return</kbd> statement. Control then returns to the call site. In the following diagram, the <kbd>print</kbd> statements are executed in the order 1, 2, then 3:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/53322170-0383-4db5-8c1b-b5714aba0dd4.png" style="" width="1175" height="209"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 3.2 â€“ print statement</div>&#13;
<p>Sometimes, it can be useful to execute some code after the function has returned, but before control has been returned to the call site. T<span>his is the purpose of Swift's <kbd>defer</kbd> statement</span>. In the following example, step 3 is executed after step 2, even though it is defined above it:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/54fba059-3c39-42fb-b646-f9114dbeaee3.png" style="" width="1180" height="367"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 3.3 â€“ defer statement</span></div>&#13;
<p>In this recipe, we will explore how to use <kbd>defer</kbd>, and when it can be helpful.</p>&#13;
<h2 id="uuid-acff8297-1a58-4f1f-8ff0-f7b983e35e49" class="packt_figure">Getting ready</h2>&#13;
<p>A <kbd>defer</kbd> statement can be useful to change the state once a function's execution is complete or to clean up values that are no longer needed. Let's look at an example of updating the state with a <kbd>defer</kbd> statement.</p>&#13;
<h2 id="uuid-5d15732d-237f-4f28-9aab-e1102eb03dd9">How to do it...</h2>&#13;
<p><span>Imagine that we have movie reviews with star ratings, and we want to classify them based on their star rating:</span></p>&#13;
<ol>&#13;
<li>Define the options that a movie review may be classified into:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum MovieReviewClass { <br/>    case bad <br/>    case average <br/>    case good <br/>    case brilliant <br/>} </pre>&#13;
<ol start="2">&#13;
<li>Create an object to do the classification:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class MovieReviewClassifier { <br/> <br/>    func classify(forStarsOutOf10 stars: Int) -&gt; MovieReviewClass { <br/>        if stars &gt; 8 { <br/>            return .brilliant // 9 or 10 <br/>        } else if stars &gt; 6 { <br/>            return .good // 7 or 8 <br/>        } else if stars &gt; 3 { <br/>            return .average // 4, 5 or 6 <br/>        } else { <br/>            return .bad // 1, 2 or 3 <br/>        } <br/>    } <br/>} </pre>&#13;
<ol start="3">&#13;
<li>Use the classifier to classify the review:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let classifier = MovieReviewClassifier() <br/>let review1 = classifier.classify(forStarsOutOf10: 9) <br/>print(review1) // brilliant</pre>&#13;
<p style="padding-left: 60px">This works great, but for the purpose of this example, let's imagine that this classification was a long-running process, and we wanted to keep track of the state of the classifier, so we can externally check if the classifier was in the middle of classifying or was completed.</p>&#13;
<ol start="4">&#13;
<li>Define the possible classification states:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum ClassificationState { <br/>    case initial <br/>    case classifying <br/>    case complete <br/>}</pre>&#13;
<ol start="5">&#13;
<li>Update our classifier class to hold and update the state, using a <kbd>defer</kbd> statement to move to the complete state:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class MovieReviewClassifier { <br/> <br/>    var state: ClassificationState = .initial <br/> <br/>    func classify(forStarsOutOf10 stars: Int) -&gt; MovieReviewClass { <br/> <br/>        state = .classifying <br/> <br/>        defer { <br/>            state = .complete <br/>        } <br/> <br/>        if stars &gt; 8 { <br/>            return .brilliant // 9 or 10 <br/>        } else if stars &gt; 6 { <br/>            return .good // 7 or 8 <br/>        } else if stars &gt; 3 { <br/>            return .average // 4, 5 or 6 <br/>        } else { <br/>            return .bad // 1, 2 or 3 <br/>        } <br/>    } <br/>} </pre>&#13;
<ol start="6">&#13;
<li>Use the classifier to classify the review and check the state:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let classifier = MovieReviewClassifier() <br/>let review1 = classifier.classify(forStarsOutOf10: 9) <br/>print(review1) // brilliant <br/>print(classifier.state) // complete </pre>&#13;
<h2 id="uuid-0a2e367f-732d-47ec-935a-ce97a779f4bf">How it works...</h2>&#13;
<p>The <kbd>classify</kbd> method we defined above takes an input rating and then returns <kbd>MovieReviewClass</kbd> based on this rating:</p>&#13;
<pre>func classify(forStarsOutOf10 stars: Int) -&gt; MovieReviewClass { <br/> <br/>    //... <br/> <br/>    if stars &gt; 8 { <br/>        return .brilliant // 9 or 10 <br/>    } else if stars &gt; 6 { <br/>        return .good // 7 or 8 <br/>    } else if stars &gt; 3 { <br/>        return .average // 4, 5 or 6 <br/>    } else { <br/>        return .bad // 1, 2 or 3 <br/>    }<br/>} </pre>&#13;
<p>While doing that, it also updates a <kbd>state</kbd> value to indicate where the method is in the classification process:</p>&#13;
<pre>state = .classifying <br/> <br/>defer { <br/>    state = .complete <br/>}</pre>&#13;
<p>The <kbd>defer</kbd> statement allows the state to be updated once the method has returned.</p>&#13;
<p>If we were to write this method without the <kbd>defer</kbd> statement, we would have to transition to the <kbd>complete</kbd> state within each branch of the <kbd>if</kbd> statement before returning a value, as nothing after this will be executed. The end of that method will look as follows:</p>&#13;
<pre>if stars &gt; 8 { <br/>    state = .complete <br/>    return .brilliant // 9 or 10 <br/>} else if stars &gt; 6 { <br/>    state = .complete <br/>    return .good // 7 or 8 <br/>} else if stars &gt; 3 { <br/>    state = .complete <br/>    return .average // 4, 5 or 6 <br/>} else { <br/>    state = .complete <br/>    return .bad // 1, 2 or 3 <br/>} </pre>&#13;
<p>This repetition of updating the state can be avoided when we use the <kbd>defer</kbd> statement:</p>&#13;
<pre>defer { <br/>    state = .complete <br/>} </pre>&#13;
<p>To defer code, simply use the <kbd>defer</kbd> keyword, with the code to be deferred defined in curly brackets; this code will be run after the method has returned, but before the control flow is returned to the caller.</p>&#13;
<h2 id="uuid-d951d6f2-7f47-4542-84d3-74552c944846">There's more...</h2>&#13;
<p>You can define multiple <kbd>defer</kbd> statements within a method, and they are executed in the reverse order that they were defined, so the last <kbd>defer</kbd> statement defined is the first one executed after the method returns.</p>&#13;
<p>To demonstrate, add a new state that we'll switch to when completing classifications subsequent to the first:</p>&#13;
<pre>enum ClassificationState { <br/>    case initial <br/>    case classifying <br/>    case complete <br/>    case completeAgain <br/>} </pre>&#13;
<p>Now, let's amend our classifier to keep track of the number of classifications it makes and changes to the <kbd>completeAgain</kbd> state if more than one classification has been completed:</p>&#13;
<pre>class MovieReviewClassifier { <br/>     <br/>    var state: ClassificationState = .initial <br/>    var numberOfClassifications = 0 <br/>     <br/>    func classify(forStarsOutOf10 stars: Int) -&gt; MovieReviewClass { <br/>         <br/>        state = .classifying <br/>         <br/>        defer { <br/>            numberOfClassifications += 1 <br/>        } <br/>        defer { <br/>            if numberOfClassifications &gt; 0 { <br/>                state = .completeAgain <br/>            } else { <br/>                state = .complete <br/>            } <br/>        } <br/>         <br/>        if stars &gt; 8 { <br/>            return .brilliant // 9 or 10 <br/>        } else if stars &gt; 6 { <br/>            return .good // 7 or 8 <br/>        } else if stars &gt; 3 { <br/>            return .average // 4, 5 or 6 <br/>        } else { <br/>            return .bad // 1, 2 or 3 <br/>        } <br/>    } <br/>} </pre>&#13;
<p>Now change how we use the classifier; the second time we use it, it will complete with a different state:</p>&#13;
<pre>let classifier = MovieReviewClassifier() <br/>let review1 = classifier.classify(forStarsOutOf10: 9) <br/>print(review1) // brilliant <br/>print(classifier.state) // complete <br/>print(classifier.numberOfClassifications) // 1 <br/> <br/>let review2 = classifier.classify(forStarsOutOf10: 2) <br/>print(review2) // bad <br/>print(classifier.state) // completeAgain <br/>print(classifier.numberOfClassifications) // 2 </pre>&#13;
<p>Since we have now defined two <kbd>defer</kbd> statements, let's take another look to understand the order in which they are executed:</p>&#13;
<pre>defer { <br/>    numberOfClassifications += 1 <br/>} <br/>defer { <br/>    if numberOfClassifications &gt; 0 { <br/>        state = .completeAgain <br/>    } else { <br/>        state = .complete <br/>    } <br/>} </pre>&#13;
<p>As discussed earlier, the last defined <kbd>defer</kbd> statement is executed first. So on the first classification, once the method returns, the last <kbd>defer</kbd> statement is executed and the state is changed to <kbd>complete</kbd>, because <kbd>numberOfClassifications</kbd> will be <kbd>0</kbd>. Next, the first <kbd>defer</kbd> statement is executed, which adds <kbd>1</kbd> to the <kbd>numberOfClassifications</kbd> variable, which will now be <kbd>1</kbd>.</p>&#13;
<p>On the second classification, once the method returns, the last <kbd>defer</kbd> statement will execute and change the state to <kbd>completeAgain</kbd> since <kbd>numberOfClassifications</kbd> is greater than <kbd>0</kbd>. Finally, the first <kbd>defer</kbd> statement will execute, incrementing <kbd>numberOfClassifications</kbd> and making it <kbd>2</kbd>.</p>&#13;
<p>If the <kbd>defer</kbd> statements had been the other way around, the state would always change to <kbd>completeAgain</kbd>, as <kbd>numberOfClassifications</kbd> would have incremented to <kbd>1</kbd> before the check was made.</p>&#13;
<h2 id="uuid-5b79648a-4941-48b1-a80b-5c4439ff1551">See also</h2>&#13;
<p>Further information about <kbd>defer</kbd> statements can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/defer">http://swiftbook.link/docs/defer</a>.</p>&#13;
<h1 id="uuid-a5501213-5394-42a8-a1fa-059443d6f05d">Bailing out with fatalError and precondition</h1>&#13;
<p>It's comforting to think that in the code you write, everything will always happen as expected, and your program can handle any eventuality. However, sometimes things can go wrong â€“ really wrong. A situation could arise that you know is possible but don't expect to ever happen, and the program should terminate if it does. In this recipe, we will look at two issues like this: <kbd>fatalError</kbd> and <kbd>precondition</kbd>.</p>&#13;
<h2 id="uuid-6556d24e-d2de-4314-a07d-8b86724d1ce9">Getting ready</h2>&#13;
<p>Let's reuse our example from the previous recipe; we have an object that can be used to classify movie reviews based on how many stars out of 10 the review gave the movie. However, let's simplify its use, and say that we only intend for a classifier object to classify one, and only one, movie review.</p>&#13;
<h2 id="uuid-95ea1aa0-a405-4690-aecb-63e8d0838876">How to do it...</h2>&#13;
<p>Let's set up our movie classifier to only be used once, and only accept ratings out of 10:</p>&#13;
<ol>&#13;
<li>Define the classification state and the movie review class:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum ClassificationState { <br/>    case initial <br/>    case classifying <br/>    case complete <br/>} <br/> <br/>enum MovieReviewClass { <br/>    case bad <br/>    case average <br/>    case good <br/>    case brilliant <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Redefine our classifier object, using <kbd>precondition</kbd> and <kbd>fatalError</kbd> to indicate situations that are not expected to occur and would cause a problem:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class MovieReviewClassifier { <br/>     <br/>    var state: ClassificationState = .initial <br/>     <br/>    func classify(forStarsOutOf10 stars: Int) -&gt; MovieReviewClass { <br/>         <br/>        precondition(state == .initial, "Classifier state must be <br/>          initial") <br/>         <br/>        state = .classifying <br/>         <br/>        defer { <br/>            state = .complete <br/>        } <br/>         <br/>        if stars &gt; 8 &amp;&amp; stars &lt;= 10 { <br/>            return .brilliant // 9 or 10 <br/>        } else if stars &gt; 6 { <br/>            return .good // 7 or 8 <br/>        } else if stars &gt; 3 { <br/>            return .average // 4, 5 or 6 <br/>        } else if stars &gt; 0 { <br/>            return .bad // 1, 2 or 3 <br/>        } else { <br/>            fatalError("Star rating must be between 1 and 10") <br/>        } <br/>    } <br/>} <br/> <br/>let classifier = MovieReviewClassifier() <br/>let review1 = classifier.classify(forStarsOutOf10: 9) <br/>print(review1) // brilliant <br/>print(classifier.state) // complete </pre>&#13;
<h2 id="uuid-10dc41f5-a8eb-449b-8a14-64157d854662">How it works...</h2>&#13;
<p>We only want to use the classifier once; therefore, when we begin to classify a movie review, the current state should be <kbd>initial</kbd> as this object has never classified before and shouldn't be in the middle of classifying. If that is not the case, the classifier is being used incorrectly, and we should terminate the execution of the code:</p>&#13;
<pre>func classify(forStarsOutOf10 stars: Int) -&gt; MovieReviewClass { <br/>     <br/>    precondition(state == .initial, "Classifier state must be initial") <br/>    //... <br/>} </pre>&#13;
<p>We state a precondition using the <kbd>precondition</kbd> keyword, provide a Boolean statement that we expect to be true, and an optional message. If this Boolean statement is not true, the execution of the code will terminate and the message will be displayed in the console.</p>&#13;
<p>In our example, we are making it a precondition that the state must be <kbd>initial</kbd> when calling this method.</p>&#13;
<p>When our classifier performs the classification, it expects a number of stars between 1 and 10. However, the method accepts an <kbd>Int</kbd> as a parameter; so, any integer value can be provided, positive or negative. If the value provided is not between 1 and 10 and the classifier cannot provide a valid <kbd>MovieReviewClass</kbd>, then the classifier is being used incorrectly, and we should terminate the execution of the code:</p>&#13;
<pre>func classify(forStarsOutOf10 stars: Int) -&gt; MovieReviewClass { <br/>    //... <br/>    if stars &gt; 8 &amp;&amp; stars &lt;= 10 { <br/>        return .brilliant // 9 or 10 <br/>    } else if stars &gt; 6 { <br/>        return .good // 7 or 8 <br/>    } else if stars &gt; 3 { <br/>        return .average // 4, 5 or 6 <br/>    } else if stars &gt; 0 { <br/>        return .bad // 1, 2 or 3 <br/>    } else { <br/>        fatalError("Star rating must be between 1 and 10") <br/>    } <br/>}</pre>&#13;
<p>The if-else statement covers all the valid <kbd>MovieReviewClass</kbd> options for the provided stars, so if none of these are triggered, we use a fatal error to indicate incorrect usage. This is done using the <kbd>fatalError</kbd> keyword, providing an optional message.</p>&#13;
<h2 id="uuid-fde43f2f-0042-4ca8-b11e-98aa5195df0c">See also</h2>&#13;
<p>Further information about <kbd>fatalError</kbd> can be found in Apple's documentation on the Swift language at <a href="http://swiftbook.link/docs/fatalerror">http://swiftbook.link/docs/fatalerror</a>.</p>&#13;
&#13;
&#13;
            </article>&#13;
&#13;
            &#13;
        </section>&#13;
    </div></body></html>