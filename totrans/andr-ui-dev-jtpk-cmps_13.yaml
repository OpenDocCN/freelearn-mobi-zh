- en: 'Chapter 10: Testing and Debugging Compose Apps'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：测试和调试 Compose 应用
- en: Programming is a very creative process. Implementing great-looking **user interfaces**
    (**UIs**) with slick animations is pure fun with Jetpack Compose. However, making
    an outstanding app involves more than just writing code. Testing and debugging
    are equally as important because no matter how carefully you design and implement
    your app, bugs and glitches are inevitable, at least in non-trivial programs.
    Yet there is nothing to fear, as there are powerful tools you can wield to check
    if your code is acting as intended.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是一个非常富有创造性的过程。使用 Jetpack Compose 实现看起来很棒的 **用户界面**（**UI**）和流畅的动画是纯粹的乐趣。然而，打造一个出色的应用不仅仅需要编写代码。测试和调试同样重要，因为无论您如何精心设计和实现您的应用，错误和故障都是不可避免的，至少在非平凡程序中是这样。但无需害怕，因为您可以使用强大的工具来检查您的代码是否按预期运行。
- en: 'This chapter introduces you to these tools. Its main sections are listed here:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍这些工具。其主要部分如下所示：
- en: Setting up and writing tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和编写测试
- en: Understanding semantics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解语义
- en: Debugging Compose apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 Compose 应用
- en: In the first main section, I will walk you through important terms and techniques
    regarding testing. We will set up the infrastructure, write a simple unit test,
    and then turn to Compose specifics—for example, `createComposeRule()` and `createAndroidComposeRule()`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分主要章节中，我将向您介绍有关测试的重要术语和技术。我们将设置基础设施，编写一个简单的单元测试，然后转向 Compose 特定内容——例如，`createComposeRule()`
    和 `createAndroidComposeRule()`。
- en: The *Understanding semantics* section builds on these foundations. We look at
    how composable functions are selected—or found—in a test, and why making your
    app accessible also helps to write better tests. You will also learn about actions
    and assertions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*理解语义* 部分建立在这些基础之上。我们将探讨如何在测试中选择或找到可组合函数，以及为什么使您的应用可访问也有助于编写更好的测试。您还将了解操作和断言。'
- en: Failing tests often hint at bugs unless, of course, the failure is intentional.
    If you suspect the code being checked by a test is buggy, a debugging session
    is due. The final main section, *Debugging Compose apps*, explains how to examine
    your Compose code. We will be revisiting the semantics tree, discussed in the
    *Understanding semantics* section. Finally, I will show you how to take advantage
    of `InspectorInfo` and `InspectorValueInfo`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的测试通常表明存在错误，除非当然，失败是故意的。如果您怀疑测试正在检查的代码有错误，那么就需要进行调试会话。最后一部分主要章节，*调试 Compose
    应用*，解释了如何检查您的 Compose 代码。我们将回顾在 *理解语义* 部分中讨论的语义树。最后，我将向您展示如何利用 `InspectorInfo`
    和 `InspectorValueInfo`。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is based on the `TestingAndDebuggingDemo` sample. Please refer
    to *Technical requirements* section of [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*, for information about how to install and set
    up Android Studio and how to get the repository accompanying this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于 `TestingAndDebuggingDemo` 示例。请参考 [*第1章*](B17505_01_ePub.xhtml#_idTextAnchor014)
    的 *技术要求* 部分，了解如何安装和设置 Android Studio 以及如何获取本书配套的代码库。
- en: All the code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_10](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_10](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_10)。
- en: Setting up and writing tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和编写测试
- en: 'As a software developer, you probably enjoy writing code. Seeing an app gain
    functionality feels very rewarding, probably more than writing tests—or worse,
    finding bugs—yet testing and debugging are essential. Eventually, your code will
    contain bugs, because all non-trivial programs do. To make your developer life
    easier, you need to familiarize yourself with writing tests and with debugging
    your own and others'' code. Testing an app has various facets that correspond
    to different types of tests, as outlined here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件开发人员，您可能喜欢编写代码。看到应用增加功能会感到非常满足，可能比编写测试——或者更糟糕的是，发现错误——更有成就感。然而，测试和调试是必不可少的。最终，您的代码将包含错误，因为所有非平凡程序都会这样。为了使您作为开发者的生活更轻松，您需要熟悉编写测试以及调试您自己的和别人的代码。测试一个应用有多个方面，对应着不同类型的测试，如下所述：
- en: '**Unit test**: You need to make sure that the business logic works as expected.
    This, for example, means that formulae and calculations always produce correct
    results.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：你需要确保业务逻辑按预期工作。例如，这意味着公式和计算总是产生正确的结果。'
- en: '**Integration tests**: Are all building blocks of the app properly integrated?
    Depending on what the app does, this may include accessing remote services, talking
    to a database, or reading and writing files on the device.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：应用的所有构建块是否正确集成？根据应用的功能，这可能包括访问远程服务、与数据库通信或在设备上读取和写入文件。'
- en: '**UI tests**: Is the UI accurate? Are all UI elements visible on all supported
    screen sizes? Do they always show the right values? Do interactions such as button
    clicks or slider movements trigger the intended function? And something very important:
    are all parts of the app accessible?'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI测试**：UI是否准确？所有UI元素是否在所有支持的屏幕尺寸上都可见？它们是否总是显示正确的值？按钮点击或滑块移动等交互是否触发了预期的功能？还有非常重要的一点：应用的所有部分是否都易于访问？'
- en: The number of tests varies among types. It has long been claimed that, ideally,
    most of your tests should be unit tests, followed by integration tests. This leads
    to the perception of a **test pyramid**, with unit tests being its foundation
    and UI tests the tip. As with all metaphors, the test pyramid has seen both support
    and harsh criticism. If you want to learn more about it, and testing strategies
    in general, please refer to the *Further reading* section at the end of this chapter.
    Jetpack Compose tests are UI tests. So, while you likely write many corresponding
    test cases, testing the underlying business logic using unit tests may well be
    even more important.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的数量因类型而异。长期以来，人们一直声称，理想情况下，你大部分的测试应该是单元测试，其次是集成测试。这导致了一种**测试金字塔**的概念，其中单元测试是其基础，UI测试是顶端。就像所有的隐喻一样，测试金字塔也经历了支持和严厉的批评。如果你想了解更多关于它以及一般测试策略的信息，请参阅本章末尾的*进一步阅读*部分。Jetpack
    Compose测试是UI测试。因此，虽然你可能编写了许多相应的测试用例，但使用单元测试测试底层业务逻辑可能更为重要。
- en: To make testing reliable, comprehensible, and reproducible, automation is used.
    In the next section, I will show you how to write unit tests using the *JUnit
    4* testing framework.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试可靠、易懂和可重复，使用了自动化。在下一节中，我将向你展示如何使用*JUnit 4*测试框架编写单元测试。
- en: Implementing unit tests
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现单元测试
- en: 'Units are small, isolated pieces of code—usually a function, method, subroutine,
    or property, depending on the programming language. Let''s look at a simple Kotlin
    function in the following code snippet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单位是小的、独立的代码片段——通常是函数、方法、子程序或属性，具体取决于编程语言。让我们看看以下代码片段中的简单Kotlin函数：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`isEven()` determines if the passed `Int` value is even. If this is the case,
    the function returns `true`; otherwise, it returns `false`. The algorithm is based
    on the fact that only even `Int` values can be divided by `2` without a remainder.
    Assuming we use the function often, we certainly want to make sure that the result
    is always correct. But how do we do that (how do we test that)? To verify `isEven()`
    exhaustively, we would need to check every possible input value, ranging from
    `Int.MIN_VALUE` to `Int.MAX_VALUE`. Even on fast computers, this may take some
    time. Part of the art of writing good unit tests is to identify all the important
    boundaries and transitions. Regarding `isEven()`, these might be the following
    ones:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEven()`确定传递的`Int`值是否为偶数。如果是这样，函数返回`true`；否则，返回`false`。该算法基于这样一个事实：只有偶数`Int`值才能被`2`整除而没有余数。假设我们经常使用这个函数，我们当然想确保结果总是正确的。但我们如何做到这一点（如何测试这一点）？为了彻底验证`isEven()`，我们需要检查从`Int.MIN_VALUE`到`Int.MAX_VALUE`的所有可能的输入值。即使在快速的计算机上，这也可能需要一些时间。编写良好单元测试的艺术部分在于识别所有重要的边界和转换。关于`isEven()`，以下可能是一些：'
- en: '`Int.MIN_VALUE` and `Int.MAX_VALUE`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int.MIN_VALUE`和`Int.MAX_VALUE`'
- en: One negative even and one negative odd `Int` value
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个负偶数和一个负奇数`Int`值
- en: One positive even and one positive odd `Int` value
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正偶数和一个正奇数`Int`值
- en: 'To write and execute unit tests, you should add the following dependencies
    to your module-level `build.gradle` properties file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写和执行单元测试，你应该将以下依赖项添加到你的模块级`build.gradle`属性文件中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Depending on which types of tests you will be adding to your app project, some
    of the preceding dependencies will be optional. For example, `androidx.test.espresso`
    is needed only if your app also contains old-fashioned Views you wish to test
    (such as in interoperability scenarios).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests are executed on your development machine. Test classes are placed
    inside the `app/src/test/java` directory and are available through the `SimpleUnitTest`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Unit tests in the Android Studio Project tool window'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17075_10_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Unit tests in the Android Studio Project tool window
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the class in the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A test class contains one or more tests. A `@Test`. It checks certain well-defined
    situations, conditions, or criteria. Tests should be isolated, which means they
    should not rely on previous ones. My example tests if `isEven()` returns correct
    results for six input values. Such checks are based on **assertions**. An assertion
    formulates expected behavior. If an assertion is not met, the test fails.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If you need something to be done before or after each test, you can implement
    functions and annotate them with `@Before` or `@After`. You can achieve something
    similar using `@Rule`. We will be looking at this in the following section. To
    run code before all tests, you need to implement a companion object with a function
    annotated with `@BeforeClass` and `@JvmStatic`. `@AfterClass` is useful for cleanup
    purposes after all tests have been run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run a unit test by right-clicking on the test class in the **Project**
    tool window and choosing **Run ''…''**. Once a launch configuration for the test
    class has been created, you can also run the tests using the menu bar and the
    toolbar. Test results are presented in the **Run** tool window, as illustrated
    in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Test results in the Android Studio Run tool window'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17075_10_2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Test results in the Android Studio Run tool window
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the test passes, my implementation of `isEven()` may still not be
    flawless. While the test checks the upper and lower bounds, it leaves the transition
    between negative and positive numbers untested. Let''s correct this and add another
    test, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Fortunately, this test passes, too.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Pay close attention to the parameters a unit receives and the result it produces.
    Always test boundaries and transitions. Make sure to cover all code paths (if
    possible) and watch for pitfalls such as exceptions due to invalid arguments (for
    example, division by zero or wrong number formats).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Please remember that composable functions are top-level Kotlin functions, so
    they are prime candidates for unit tests. Let's see how this works. In the next
    section, you will learn to test a simple Compose UI.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Testing composable functions
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SimpleButtonDemo()` composable (which belongs to the `TestingAndDebuggingDemo`
    sample) shows a box with a button centered inside. Clicking the button for the
    first time changes its text from **A** to **B**. Subsequent clicks toggle between
    **B** and **A**. The code is illustrated in the following snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The text is stored as a mutable `String` state. It is changed inside the `onClick`
    block and used as a parameter for the `Text()` composable. If we want to test
    `SimpleButtonDemo()`, some aspects we likely need to check are these:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial state of the UI**: Is the initial button text **A**?'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior**: Does the first button click change the text to **B**?'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do subsequent clicks toggle between **B** and **A**?
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here''s what a simple test class looks like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unlike the `SimpleUnitTest` class from the *Implementing unit tests* section,
    its source code is stored inside the `app/src/androidTest/java` directory (contrary
    to `…/test/…` for ordinary unit tests). `SimpleInstrumentedTest` is an **instrumented
    test**. Contrary to plain unit tests, they are not executed locally on the development
    machine, but on the Android Emulator or a real device, because they need Android-specific
    functionality to run. Instrumented tests are available through the **Project**
    tool window, as illustrated in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Instrumented tests in the Android Studio Project tool window'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17075_10_3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Instrumented tests in the Android Studio Project tool window
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run an instrumented test by right-clicking on the test class in the
    **Project** tool window and choosing **Run ''…''**. Once a launch configuration
    for the test class has been created, you can also run the tests using the menu
    bar and the toolbar. Test results are presented in the **Run** tool window, as
    illustrated in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Instrumented test results in the Android Studio Run tool window'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17075_10_4.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Instrumented test results in the Android Studio Run tool window
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit `@Before` and `@After` annotations in your test class. There are several
    predefined rules—for example, the `TestName` rule can provide the current test
    name inside a test method, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the `testPrintMethodName()` function runs, it prints its name. You can
    see the output in `@Rule` annotation to the property getter by adding `get:`.
    Failing to do so will result in a `ValidationError` (`The @Rule '…' must be public`)
    message during execution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Compose tests are based on rules. `createComposeRule()` returns an implementation
    of the `ComposeContentTestRule` interface, which extends `ComposeTestRule`. This
    interface in turn extends `org.junit.rules.TestRule`. Each `TestRule` instance
    implements `apply()`. This method receives `Statement` and returns the same, a
    modified, or completely new `Statement`. However, writing your own test rules
    is beyond the scope of this book. To learn more, please refer to the *Further
    reading* section at the end of this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 测试基于规则。`createComposeRule()` 返回 `ComposeContentTestRule` 接口的一个实现，它扩展了
    `ComposeTestRule`。此接口反过来又扩展了 `org.junit.rules.TestRule`。每个 `TestRule` 实例实现 `apply()`
    方法。此方法接收 `Statement` 并返回相同的、修改后的或完全新的 `Statement`。然而，编写自己的测试规则超出了本书的范围。要了解更多信息，请参阅本章末尾的“进一步阅读”部分。
- en: Which implementation of the `ComposeContentTestRule` interface `createComposeRule()`
    returns depends on the platform. It is `AndroidComposeTestRule<ComponentActivity>`
    on Android. That is why you should add a dependency to `androidx.compose.ui:ui-test-manifest`
    in the module-level `build.gradle` file. Otherwise, you may need to manually add
    a reference to `ComponentActivity` in the manifest file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`createComposeRule()` 返回的 `ComposeContentTestRule` 接口实现取决于平台。在 Android 上，它是
    `AndroidComposeTestRule<ComponentActivity>`。这就是为什么你应该在模块级别的 `build.gradle` 文件中添加对
    `androidx.compose.ui:ui-test-manifest` 的依赖。否则，你可能需要在清单文件中手动添加对 `ComponentActivity`
    的引用。'
- en: '`createAndroidComposeRule()` allows you to create `AndroidComposeTestRule`
    for activity classes other than `ComponentActivity`. This is useful if you require
    the functionality of this activity in a test. On Compose for Desktop or Web, `createComposeRule()`
    may return different implementations of `ComposeContentTestRule`, depending on
    where the Compose UI is hosted. To help make your tests platform-independent,
    use `createComposeRule()` whenever possible.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`createAndroidComposeRule()` 允许你为除了 `ComponentActivity` 之外的活动类创建 `AndroidComposeTestRule`。如果你需要在测试中使用此活动的功能，这很有用。在桌面或
    Web 的 Compose 中，`createComposeRule()` 可能会返回 `ComposeContentTestRule` 的不同实现，具体取决于
    Compose UI 的托管位置。为了使你的测试平台无关，尽可能使用 `createComposeRule()`。'
- en: Your test cases use (among others) methods provided by `ComposeContentTestRule`
    implementations. For example, `setContent()` sets the composable function to act
    as the content of the current screen—that is, the UI to be tested. `setContent()`
    should be called exactly once per test. To achieve this, just invoke it in a function
    annotated with `@Before`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试用例使用（包括其他）由 `ComposeContentTestRule` 实现提供的方法。例如，`setContent()` 将可组合函数设置为当前屏幕的内容——即要测试的
    UI。`setContent()` 应该在每个测试中恰好调用一次。为了实现这一点，只需在带有 `@Before` 注解的函数中调用它。
- en: Important Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you want to reuse your tests among platforms, try to rely only on methods
    defined in the `ComposeContentTestRule`, `ComposeContentTestRule`, and `TestRule`
    interfaces. Avoid calling functions from the implementation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在多个平台上重用你的测试，尽量只依赖 `ComposeContentTestRule`、`ComposeContentTestRule` 和 `TestRule`
    接口中定义的方法。避免调用实现中的函数。
- en: 'Next, let''s look at `testInitialLetterIsA()`. This test case checks if the
    initial button text is `"A"`. This comparison is done with an `assertExists()`
    `onNodeWithText()` is called a **finder**. Finders work on **semantics nodes**,
    and you will learn more about these in the *Understanding semantics* section.
    But first: why do we need to *find* the composable to be tested anyway?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `testInitialLetterIsA()`。这个测试用例检查初始按钮文本是否为 `"A"`。这个比较是通过调用 `assertExists()`
    和 `onNodeWithText()` 来完成的，后者被称为 **finder**。Finder 在 **semantics nodes** 上工作，你将在“理解语义”部分了解更多关于这些内容。但首先：为什么我们还需要
    *找到* 要测试的可组合元素呢？
- en: Unlike the traditional View system, Jetpack Compose does not use references
    to identify individual UI elements. Please remember that such references are needed
    in an imperative approach to modify the component tree during runtime. But this
    is not how Compose works—instead, we declare how the UI should look based on state.
    Yet, to test if a particular composable looks and behaves as expected, we need
    to find it among all other children of a Compose hierarchy.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的视图系统不同，Jetpack Compose 不使用引用来识别单个 UI 元素。请记住，在命令式方法中，在运行时修改组件树需要这样的引用。但 Compose
    并不是这样工作的——相反，我们根据状态声明 UI 应该是什么样子。然而，为了测试某个可组合元素是否看起来和表现如预期，我们需要在 Compose 层级的所有其他子元素中找到它。
- en: This is where the `Role`, `Text`, and `Actions`. It is used for accessibility
    and testing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `Role`、`Text` 和 `Actions` 的作用。它用于可访问性和测试。
- en: 'Before we move on, let''s briefly recap: `onNodeWithText()` tries to find a
    composable (to be, more precisely, a semantics node) with a given text. `assertExists()`
    checks if a matching node is present in the current UI. If so, the test passes.
    Otherwise, it fails.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们简要回顾一下：`onNodeWithText()` 尝试查找具有给定文本的复合元素（更准确地说，是一个语义节点）。`assertExists()`
    检查当前 UI 中是否存在匹配的节点。如果是，则测试通过。否则，测试失败。
- en: Understanding semantics
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解语义
- en: 'In the previous section, I showed you a simple test case that checks if a button
    text matches a given string. Here is another test case. It performs a click on
    the button to see if the button text changes as expected:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我向您展示了一个简单的测试用例，用于检查按钮文本是否与给定的字符串匹配。这里还有一个测试用例。它点击按钮以查看按钮文本是否按预期更改：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, we start by finding the button. `performClick()` (this is called an `Assert(hasText("B"))`
    checks if the button text is **B** afterward. Assertions determine if a test passes
    or fails.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先查找按钮。`performClick()`（这被称为 `Assert(hasText("B"))`）检查按钮文本是否为 **B**。断言确定测试是否通过或失败。
- en: '`onNodeWithText()` (an extension function of `SemanticsNodeInteractions Provider`)
    returns a `SemanticsNodeInteraction` semantics node. The `SemanticsNodeInteractionsProvider`
    interface is the main entry point into testing and is typically implemented by
    a test rule. It defines two methods, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`onNodeWithText()`（`SemanticsNodeInteractions Provider` 的扩展函数）返回一个 `SemanticsNodeInteraction`
    语义节点。`SemanticsNodeInteractionsProvider` 接口是测试的主要入口点，通常由测试规则实现。它定义了两个方法，如下所示：'
- en: '`onNode()` finds and returns a semantics node (`SemanticsNodeInteraction`)
    that matches the given condition.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNode()` 查找并返回一个与给定条件匹配的语义节点（`SemanticsNodeInteraction`）。'
- en: '`onAllNodes()` finds all semantics nodes that match the given condition. It
    returns     a `SemanticsNodeInteractionCollection` instance.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAllNodes()` 查找所有与给定条件匹配的语义节点。它返回一个 `SemanticsNodeInteractionCollection`
    实例。'
- en: Both are called **finders** because they return (*find*) semantics nodes matching
    certain conditions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都被称为 **查找器**，因为它们返回匹配特定条件的语义节点。
- en: Working with semantics nodes
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与语义节点一起工作
- en: 'To see what the semantics node we tested with `testLetterAfterButtonClickIsB()`
    from the previous section looks like, you can add the following expression after
    `.assert(…)`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看上一节中用 `testLetterAfterButtonClickIsB()` 测试的语义节点的外观，您可以在 `.assert(…)` 之后添加以下表达式：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result is visible in **Logcat**, as illustrated in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在 **Logcat** 中可见，如下截图所示：
- en: '![Figure 10.5 – A semantics node in Logcat'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – Logcat 中的语义节点'
- en: '](img/B17075_10_5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17075_10_5.jpg)'
- en: Figure 10.5 – A semantics node in Logcat
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – Logcat 中的语义节点
- en: '`SemanticsNodeInteraction` represents a semantics node. You can interact with
    a node by performing actions such as `performClick()` or assertions such as `assertHasClickAction()`,
    or you can navigate to other nodes such as `onChildren()`. Such functions are
    extension functions of `SemanticsNodeInteraction`. `SemanticsNodeInteractionCollection`
    is a collection of semantics nodes.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SemanticsNodeInteraction` 代表一个语义节点。您可以通过执行 `performClick()` 或断言 `assertHasClickAction()`
    等操作与节点交互，或者导航到其他节点，如 `onChildren()`。这些函数是 `SemanticsNodeInteraction` 的扩展函数。`SemanticsNodeInteractionCollection`
    是语义节点的一个集合。'
- en: 'Let''s look at another finder function, `onNodeWithContentDescription()`. We
    will be using it to test if `Image()` is part of the current UI. The code is illustrated
    in the following snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个查找函数，`onNodeWithContentDescription()`。我们将使用它来测试 `Image()` 是否是当前 UI 的一部分。代码如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the UI of your app contains images, you should add content descriptions
    for them in most cases. Content descriptions are used, for example, by accessibility
    software to describe to visually impaired people what is currently presented on
    screen. So, by adding them, you greatly enhance the usability. Additionally, content
    descriptions help in finding composables. You can see these being used in the
    following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用 UI 包含图像，您通常应该为它们添加内容描述。内容描述用于，例如，由辅助软件向视觉障碍人士描述当前屏幕上显示的内容。因此，通过添加它们，您可以大大提高可用性。此外，内容描述有助于查找复合元素。您可以在以下代码片段中看到这些用法：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`testImage()` first sets the content (`ImageDemo()`). It then finds a semantics
    node with the given content description. Finally, `assertWidthIsEqualTo()` checks
    if the width of the UI element represented by this node is 128 density-independent
    pixels wide.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`testImage()` 首先设置内容（`ImageDemo()`）。然后查找具有给定内容描述的语义节点。最后，`assertWidthIsEqualTo()`
    检查由该节点表示的 UI 元素的宽度是否为 128 密度无关像素宽。'
- en: Tip
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Have you noticed that I used `stringResource()` to obtain the content description?
    Hardcoded values can lead to subtle bugs in tests (for example, spelling errors
    or typos). To avoid them, try to write your tests in a way that they access the
    same values as the code being tested. But please keep in mind that under the hood,
    `stringResource()` relies on Android resources. So, the test case is platform-specific.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到我使用了 `stringResource()` 来获取内容描述？硬编码的值可能导致测试中产生微妙的错误（例如，拼写错误或打字错误）。为了避免这些错误，请尝试以编写测试的方式，让它们访问与被测试代码相同的值。但请记住，在底层，`stringResource()`
    依赖于 Android 资源。因此，测试用例是平台特定的。
- en: 'Using `onNodeWithText()` and `onNodeWithContentDescription()` makes it easy
    to find composable functions that contain texts and images. But what if you need
    to find the semantics node for something else—for example, a `Box()`? The following
    example, `BoxButtonDemo()`, shows a `Box()` with a `Button()` centered inside.
    Clicking the button toggles the background color of the box from white to light
    gray and back:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `onNodeWithText()` 和 `onNodeWithContentDescription()` 可以轻松找到包含文本和图像的可组合函数。但如果你需要找到其他内容的语义节点——例如，一个
    `Box()`？以下示例 `BoxButtonDemo()` 展示了一个在内部居中的 `Button()` 的 `Box()`。点击按钮会切换框的背景颜色，从白色变为浅灰色，然后再变回白色：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Testing `BoxButtonDemo()` means finding the box, checking its initial background
    color, clicking the button, and checking the color again. To be able to find the
    box, we tag it using the `testTag()` modifier, as illustrated in the following
    code snippet. Applying a tag allows us to find the modified element in tests:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `BoxButtonDemo()` 意味着找到框，检查其初始背景颜色，点击按钮，然后再次检查颜色。为了能够找到框，我们使用 `testTag()`
    修饰符对其进行标记，如下面的代码片段所示。应用标签允许我们在测试中找到修改后的元素：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can check if the box is present, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查框是否存在，如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `onNode()` finder receives a `hasTestTag()` `hasTestTag()` finds a node
    with the given test tag. There are several predefined matchers. For example, `isEnabled()`
    returns whether the node is enabled, and `isToggleable()` returns `true` if the
    node can be toggled.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`onNode()` 查找器接收一个 `hasTestTag()` 参数。`hasTestTag()` 查找具有给定测试标签的节点。有几个预定义的匹配器。例如，`isEnabled()`
    返回节点是否启用，而 `isToggleable()` 如果节点可以被切换则返回 `true`。'
- en: Tip
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Google provides a testing cheat sheet at [https://developer.android.com/jetpack/compose/testing-cheatsheet](https://developer.android.com/jetpack/compose/testing-cheatsheet).
    It nicely groups finders, matchers, actions, and assertions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Google 在 [https://developer.android.com/jetpack/compose/testing-cheatsheet](https://developer.android.com/jetpack/compose/testing-cheatsheet)
    提供了一份测试速查表。它很好地将查找器、匹配器、操作和断言分组。
- en: To complete the code for the test, we need to check the background color of
    the box. But how do we do that? Following previous examples, you may expect a
    `hasBackgroundColor()` matcher. Unfortunately, there currently is none. Tests
    can rely only on what is available through the semantics tree, yet if it does
    not contain the information we need, we can easily add it. I will show you how
    in the following section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成测试代码，我们需要检查框的背景颜色。但我们该如何做呢？根据之前的示例，你可能期望有一个 `hasBackgroundColor()` 匹配器。不幸的是，目前还没有。测试只能依赖于语义树中可用的内容，但如果它不包含我们所需的信息，我们可以轻松地添加它。我将在下一节中向你展示如何操作。
- en: Adding custom semantics properties
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义语义属性
- en: 'If you want to expose additional information to tests, you can create custom
    semantics properties. This requires the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要向测试暴露更多信息，你可以创建自定义语义属性。这需要以下步骤：
- en: Defining `SemanticsPropertyKey`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 `SemanticsPropertyKey`
- en: Making it available using `SemanticsPropertyReceiver`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `SemanticsPropertyReceiver` 使其可用
- en: 'You can see these in use in the following code snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下代码片段中看到这些用法：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With `SemanticsPropertyKey`, you can set key-value pairs in semantics blocks
    in a type-safe way. Each key has one statically defined value type—in my example,
    this is `Color`. `SemanticsPropertyReceiver` is the scope provided by `semantics
    {}` blocks. It is intended for setting key-value pairs via extension functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SemanticsPropertyKey`，你可以以类型安全的方式在语义块中设置键值对。每个键都有一个静态定义的值类型——在我的例子中，这是 `Color`。`SemanticsPropertyReceiver`
    是由 `semantics {}` 块提供的范围。它旨在通过扩展函数设置键值对。
- en: 'Here''s how to access the custom semantic property in a test case:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在测试用例中访问自定义语义属性的方法：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`expectValue()` checks whether the value of the given key is equal to the expected
    value.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`expectValue()` 检查给定键的值是否等于预期值。'
- en: Adding custom values to the semantics tree can be of great help when writing
    tests. However, please carefully consider if you really need to rely on `SemanticsPropertyKey`.
    The semantics tree is also used by the accessibility framework and tools, so it
    is vital to not pollute the semantics tree with irrelevant information. A solution
    is to rethink the testing strategy. Instead of testing *if the initial background
    color of the box is white*, we may just test if the value we pass to the `background()`
    function represents white.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，向语义树添加自定义值可能会有很大帮助。然而，请仔细考虑你是否真的需要依赖 `SemanticsPropertyKey`。语义树还由辅助功能框架和工具使用，因此，避免将无关信息污染语义树至关重要。一种解决方案是重新思考测试策略。我们可能不是测试“盒子的初始背景颜色是否为白色”，而是测试我们传递给
    `background()` 函数的值是否代表白色。
- en: This concludes the sections on testing composable functions. In the following
    section, we look at debugging Compose apps.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容结束了关于测试可组合函数的章节。在下一节中，我们将探讨调试 Compose 应用。
- en: Debugging Compose apps
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Compose 应用
- en: The title of this section, *Debugging Compose apps*, may indicate major differences
    to debugging traditional View-based apps. Fortunately, this is not the case. On
    Android, all composable hierarchies are wrapped inside `androidx.compose.ui.platform.ComposeView`.
    This happens indirectly if you invoke the `setContent {}` extension function of
    `ComponentActivity`, or if you deliberately include a composable hierarchy inside
    a layout (see [*Chapter 9*](B17505_09_ePub.xhtml#_idTextAnchor148), *Exploring
    Interoperability APIs*). Either way, in the end, `ComposeView` is displayed on
    screen—for example, inside an Activity or a Fragment. Therefore, all aspects regarding
    the basic building blocks of an Android app (Activities, Fragments, Services,
    Broadcast Receiver, Intents, and Content Provider) remain the same.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的标题 *调试 Compose 应用* 可能表明与调试传统的基于视图的应用存在重大差异。幸运的是，情况并非如此。在 Android 上，所有可组合层次结构都封装在
    `androidx.compose.ui.platform.ComposeView` 中。如果你调用了 `ComponentActivity` 的 `setContent
    {}` 扩展函数，或者你故意在一个布局中包含可组合层次结构（参见 [*第 9 章*](B17505_09_ePub.xhtml#_idTextAnchor148)，*探索互操作性
    API*），这会间接发生。无论如何，最终 `ComposeView` 都会在屏幕上显示——例如，在 Activity 或 Fragment 中。因此，关于
    Android 应用基本构建块（活动、片段、服务、广播接收器、意图和内容提供者）的所有方面都保持不变。
- en: Of course, any UI framework advocates specific debugging habits. For example,
    the View system requires watching for `null` references. Also, you need to make
    sure that changes in state reliably trigger updates of the component tree. Fortunately,
    neither is relevant for Jetpack Compose. As composables are Kotlin functions,
    you can follow the creation of the composable hierarchy by stepping through the
    code and examining `State` when needed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何 UI 框架都提倡特定的调试习惯。例如，视图系统需要关注 `null` 引用。此外，你还需要确保状态的变化能够可靠地触发组件树的更新。幸运的是，这些都不适用于
    Jetpack Compose。由于可组合项是 Kotlin 函数，你可以在需要时通过逐步执行代码来跟踪可组合层次结构的创建，并检查 `State`。
- en: 'To closely examine the visual representation of your composable functions during
    runtime, you can use the **Layout Inspector** of Android Studio, as illustrated
    in the following screenshot. Once you have deployed your app on the Emulator or
    a real device, open the tool with **Layout Inspector** in the **Tools** menu:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行时仔细检查你的可组合函数的视觉表示，你可以使用 Android Studio 的 **布局检查器**，如下面的截图所示。一旦你在模拟器或真实设备上部署了你的应用，请使用
    **工具** 菜单中的 **布局检查器** 打开此工具：
- en: '![Figure 10.6 – The Layout Inspector in Android Studio'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – Android Studio 中的布局检查器'
- en: '](img/B17075_10_6.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17075_10_6.jpg)'
- en: Figure 10.6 – The Layout Inspector in Android Studio
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – Android Studio 中的布局检查器
- en: You can select the composable to inspect using the tree on the left-hand side
    of the Android Studio main window. Important attributes are presented on the right.
    The center of the tool window contains a configurable, zoomable preview. You can
    also enable a **three-dimensional** (**3D**) mode. This allows you to visually
    inspect the hierarchy by clicking and dragging to rotate the layout.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Android Studio 主窗口左侧的树来选择要检查的可组合项。重要属性显示在右侧。工具窗口的中心包含一个可配置、可缩放的预览。你还可以启用
    **三维** （**3D**）模式。这允许你通过点击和拖动来旋转布局，从而通过视觉检查层次结构。
- en: If you want to log important values of a composable for debugging purposes,
    you can easily achieve this with modifiers. The following section shows you how
    to do this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为了调试目的记录可组合项的重要值，你可以通过修饰符轻松实现这一点。下一节将展示如何进行操作。
- en: Using custom modifiers for logging and debugging
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义修饰符进行日志记录和调试
- en: 'As I explained in the *Modifying behavior* section of [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*, a modifier is an ordered, immutable
    collection of modifier elements. Modifiers can change the look and behavior of
    Compose UI elements. You create custom modifiers by implementing an extension
    function of `Modifier`. The following code snippet uses the `DrawScope` interface
    to print the size of a composable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在 [*第 3 章*](B17505_03_ePub.xhtml#_idTextAnchor054) 的“修改行为”部分中解释的，*探索 Compose
    的关键原则*，修饰符是一个有序的不可变修饰符元素集合。修饰符可以改变 Compose UI 元素的看起来和行为。您通过实现 `Modifier` 的扩展函数来创建自定义修饰符。以下代码片段使用
    `DrawScope` 接口打印可组合的大小：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Depending on which interface you choose, you can log different aspects. Using
    `LayoutModifier` you could, for example, access layout-related information.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择哪个接口，您可以记录不同的方面。例如，使用 `LayoutModifier`，您可以访问与布局相关的信息。
- en: Important Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While this may be a clever trick, it is certainly not the primary use case for
    modifiers. Therefore, if you implement a custom modifier merely for debugging
    purposes, you should add it to the modifier chain only when debugging.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能是一个巧妙的技巧，但它绝对不是修饰符的主要用途。因此，如果您仅为了调试目的实现自定义修饰符，您应该仅在调试时将其添加到修饰符链中。
- en: 'There is also a built-in feature to provide additional information for debugging
    purposes. Several modifiers can receive an `inspectorInfo` parameter, which is
    an extension function of `InspectorInfo`. This class is a builder for an `InspectableValue`
    interface (this interface defines a value that is inspectable by tools, giving
    access to private parts of a value). `InspectorInfo` has three properties, as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个内置功能可以提供用于调试目的的附加信息。几个修饰符可以接收一个 `inspectorInfo` 参数，这是 `InspectorInfo`
    的扩展函数。这个类是 `InspectableValue` 接口的构建器（该接口定义了一个可由工具检查的值，从而可以访问值的私有部分）。`InspectorInfo`
    有三个属性，如下所示：
- en: '`name` (provides `nameFallback` for `InspectableValue`)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`（为 `InspectableValue` 提供 `nameFallback`）'
- en: '`value` (provides `valueOverride` for `InspectableValue`)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`（为 `InspectableValue` 提供 `valueOverride`）'
- en: '`properties` (provides `inspectableElements` for `InspectableValue`)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`properties`（为 `InspectableValue` 提供 `inspectableElements`）'
- en: 'To understand how `inspectorInfo` is used, let''s look in the following screenshot
    at the implementation of the `semantics {}` modifier, which adds semantics key-value
    pairs for testing and accessibility. Please refer to the *Adding custom semantics
    properties* section for details:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `inspectorInfo` 的使用方法，请查看以下截图中的 `semantics {}` 修饰符的实现，该修饰符为测试和可访问性添加了语义键值对。请参阅“添加自定义语义属性”部分以获取详细信息：
- en: '![Figure 10.7 – Source code of the semantics {} modifier'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – `semantics {}` 修饰符的源代码](img/B17075_10_7.jpg)'
- en: '](img/B17075_10_7.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17075_10_7.jpg](img/B17075_10_7.jpg)'
- en: Figure 10.7 – Source code of the semantics {} modifier
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – `semantics {}` 修饰符的源代码
- en: '`semantics {}` invokes the `composed {}` modifier, which receives two parameters,
    `inspectorInfo` and `factory` (the modifier to be composed). The `inspectorInfo`
    parameter gets the result of the `debugInspectorInfo {}` factory method (which
    receives a `name` instance and two elements for `properties` as parameters).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`semantics {}` 调用 `composed {}` 修饰符，该修饰符接收两个参数，`inspectorInfo` 和 `factory`（要组合的修饰符）。`inspectorInfo`
    参数获取 `debugInspectorInfo {}` 工厂方法的结果（该方法接收一个 `name` 实例和两个用于 `properties` 的元素作为参数）。'
- en: '`composed {}` adds a `ComposedModifier` class to the modifier chain. This private
    class implements the `Modifier.Element` interface and extends `InspectorValueInfo`,
    which in turn implements `InspectorValueInfo`. The `inspectableElements` property
    keeps `Sequence` of `ValueElements`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`composed {}` 将 `ComposedModifier` 类添加到修饰符链中。这个私有类实现了 `Modifier.Element` 接口，并扩展了
    `InspectorValueInfo`，后者反过来实现了 `InspectorValueInfo`。`inspectableElements` 属性保持
    `Sequence` 的 `ValueElements`。'
- en: 'To turn on debug inspector information, you must set the `isDebugInspectorInfoEnabled`
    global top-level variable in the `androidx.compose.ui.platform` package to `true`.
    Then, you can access and print debug inspector information using reflection. Here''s
    the code you''ll need:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用调试检查器信息，您必须将 `androidx.compose.ui.platform` 包中的全局顶级变量 `isDebugInspectorInfoEnabled`
    设置为 `true`。然后，您可以使用反射访问和打印调试检查器信息。以下是您需要的代码：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The modifier returned by `semantics {}` is of type `CombinedModifier` because
    `composed {}` invokes `then()`, which uses `CombinedModifier` under the hood.
    Instead of just printing the raw inspectable element, you can customize the output
    to your needs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at important terms and techniques regarding testing.
    In the first main section, we set up the infrastructure, wrote and ran a simple
    unit test locally on the development machine, and then turned to Compose specifics.
    I introduced you to `createComposeRule()` and `createAndroidComposeRule()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at how composable functions are found in a Compose hierarchy,
    and why making your app accessible also helps in writing better tests. You also
    learned about actions and assertions. Finally, we added custom entries to the
    semantics tree.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The final main section explained how to debug a Compose app. We revisited the
    semantics tree, and I showed you how to take advantage of `InspectorInfo` and
    `InspectorValueInfo` to debug custom modifiers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B17505_11_ePub.xhtml#_idTextAnchor174), *Conclusion and Next
    Steps,* concludes this book. We look in the crystal ball to see what future versions
    of Jetpack Compose may add. For example, we preview Material 3 for Compose, which
    brings *Material You* design concepts to Compose apps. And we look beyond Android
    and examine Compose on other platforms.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book assumes a basic understanding of how to test Android apps. To learn
    more, please refer to *Test apps on Android* at [https://developer.android.com/training/testing](https://developer.android.com/training/testing).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JUnit in Action* by *Catalin Tudose* (*Manning Publications*, *2020*, *ISBN
    978-1617297045*) is a thorough introduction to the latest version of the JUnit
    testing framework.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to learn more about test automation, you may want to look at *Complete
    Guide to Test Automation: Techniques, Practices, and Patterns for Building and
    Maintaining Effective Software Projects* by *Arnon Axelrod* (*Apress*, *2018*,
    *ISBN 978-1484238318*).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get an insight into the test pyramid metaphor, you may want to refer to *The
    Practical Test Pyramid* by *Ham Vocke*, available at [https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
