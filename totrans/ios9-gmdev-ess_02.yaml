- en: 2D arrays / matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common collection type used in physics calculations, graphics, and game design,
    particularly grid-based puzzle games, is two-dimensional arrays / matrices. 2D
    arrays are simply arrays that have arrays as their members. These arrays can be
    expressed in a rectangular fashion in rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the 4x4 (4 rows, 4 columns) tile board in the 15-puzzle game can
    be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the 15 puzzle game, your goal is to shift the tiles using the one empty spot
    (represented with the blank string `""`), to all end up in the 1-15 order as we
    saw. The game would start with the numbers arranged in a random and solvable order,
    and the player would then have to swap the numbers and the blank space.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To better perform various actions on and/or store information about each tile
    in the 15 game (and other games), it'd be better to create a tile object as opposed
    to using raw values seen here. For the sake of understanding what a matrix or
    2D array is, simply make a note of how the array is surrounded by doubly encapsulated
    brackets `[[]]`. We will later use one of our example games, `SwiftSweeper`, to
    better understand how puzzle games use 2D arrays of objects to create a full game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are ways to declare blank 2D arrays with strict types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The variable `twoDTileArray` uses the double brackets `[[Tiles]]` to declare
    it as a blank 2D array/matrix for the made-up type, tiles. The variable `anotherArray`
    is a rather oddly declared array that uses angle bracket characters `<>` for enclosures.
    It utilizes what's known as **Generics**. Generics is a rather advanced topic
    that we will touch more on later. They allow very flexible functionality among
    a wide array of data types and classes. For the moment, we can think of them as
    a catch-all way of working with objects.
  prefs: []
  type: TYPE_NORMAL
- en: To fill in the data for either version of this array, we would then use for-loops.
    More on loops and iterations will be explained later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is how we would make a set of various game items in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This set `keyItems` has various objects and a character `A`. Unlike an array,
    a set is not ordered and contains unique items. So, unlike `stageNames`, attempting
    to get `keyItems[1]` would return an error and `items[1]` might not necessarily
    be the `Holy_Armor` object, as the placement of objects is internally random in
    a set. The advantage sets have over arrays is that sets are great at checking
    for duplicated objects and specific content searching in the collection overall.
    Sets make use of hashing to pinpoint the item in the collections, so checking
    for items in a set's content can be much faster than in an array. In game development,
    a game's key items, which the player may only get once and should never have duplicates
    of, could work great as a set. Using the function `keyItems.contains(Boss_Key)`
    returns the Boolean value of `true` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets were added in Swift 1.2 and Xcode 6.3\. Their class is represented by the
    generic type `Set<T>`, where `T` is the class type of the collection. In other
    words, the set, `Set([45, 66, 1233, 234])`. would be of the type `Set<Int>`, and
    our example here would be a `Set<NSObject>` instance due to it having a collection
    of various data types.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss more on Generics and class hierarchy later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A dictionary can be represented this way in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries use a `key : value` association, so `playerInventory[22]` returns
    the value `StrengthBooster` based on the key `22`. Both the key and value could
    be initialized to almost any class type***. In addition to the inventory example
    given, we can have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***The values of a dictionary, though rather flexible in Swift, do have limitations.
    The key must conform to what''s known as the hashable protocol. Basic data types,
    such as `Int` and `String`, already have this functionality. So, if you are to
    make your own classes / data structures that are to be used in dictionaries, say
    mapping a player actions with player input, this protocol must be utilized first.
    We will discuss more about protocols later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are like sets in that they are unordered but with the additional
    layer of having a key and a value associated with their content instead of just
    the hash key. Like sets, dictionaries are great for quick insertion and retrieval
    of specific data. In iOS apps and in web applications, dictionaries are used to
    parse and select items from JavaScript Object Notation (JSON) data.
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of game development, dictionaries using JSON or via Apple's internal
    data class, `NSUserDefaults`, can be used to save and load game data, set up game
    configurations, or access specific members of a game's API.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s one way to save a player''s high score in an iOS game
    using Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code comes directly from a published Swift-developed game named PikiPop,
    which we will use from time to time to show code used in actual game applications.
  prefs: []
  type: TYPE_NORMAL
- en: Again, note that dictionaries are unordered, but Swift has ways to iterate or
    search through an entire dictionary. We will go more in depth in the next section
    and later on when we move on to loops and control flow.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable/immutable collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One rather important discussion that we've left out is how to subtract, edit,
    or add to arrays, sets, and dictionaries. However, before we do this, you should
    understand the concept of mutable and immutable data/collections.
  prefs: []
  type: TYPE_NORMAL
- en: A mutable collection is simple data that can be changed, added to, or subtracted
    from, whereas an immutable collection cannot be changed, added to, or subtracted
    from.
  prefs: []
  type: TYPE_NORMAL
- en: To work with mutable and immutable collections efficiently in Objective-C, we
    had to explicitly state the mutability of the collection beforehand. For example,
    an array of the type `NSArray` in Objective-C is always immutable. There are methods
    we can call on `NSArray` that would edit the collection, but behind the scenes,
    this would be creating brand new `NSArray` objects, thus would be rather inefficient
    to do this often in the life of our game. Objective-C has solved this issue with
    the class type, `NSMutableArray`.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the flexibility of Swift's type inference, we already know how to
    make a collection mutable or immutable! The concept of constants and variables
    has us covered when it comes to data mutability in Swift. Using the keyword `let`
    when creating a collection will make that collection immutable, while using `var`
    will initialize it as a mutable collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The array of integers, `unlockedLevels`, can be edited simply because it's a
    variable. The immutable dictionary `playersForThisRound` can't be changed since
    it's already been declared as a constant. There is no additional layer of ambiguity
    concerning additional class types.
  prefs: []
  type: TYPE_NORMAL
- en: Editing/accessing collection data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As long as a collection type is a variable, using the `var` keyword, we can
    do various edits to the data. Let''s go back to our `unlockedLevels` array. Many
    games have the functionality of unlocking levels as the player progresses. Let''s
    say that the player has reached the high score needed to unlock the previously
    locked level 3 (as `3` isn''t a member of the array). We can add `3` to the array
    using the `append` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another neat attribute of Swift is that we can add data to an array using the
    `+=` assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing it this way however will simply add `3` to the end of the array. So,
    our previous array `[1, 2, 5, 8]` is now `[1, 2, 5, 8, 3]`. This probably isn''t
    a desirable order, so to insert the number `3` in the third spot, `unlockedLevels[2]`,
    we can use the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, our array of unlocked levels is ordered to `[1, 2, 3, 5, 8]`.
  prefs: []
  type: TYPE_NORMAL
- en: This is assuming though that we know a member of the array prior to `3` is sorted
    already. There are various sorting functionalities provided by Swift that could
    help keeping an array sorted. We will leave the details of sorting to our discussions
    of loops and control flow later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing items from an array is just simple. Let''s again use our `unlockedLevels`
    array. Imagine that our game has an overworld for the player to travel to and
    from and the player has just unlocked a secret that triggered an event that blocked
    off access to level 1\. Level 1 would now have to be removed from the unlocked
    levels. We can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Alternately, imagine that the player has lost all of their lives and got a **Game
    Over** message. A penalty for this could be to lock the furthest level. Though
    probably a rather infuriating method and us knowing that level 8 is the furthest
    level in our array, we can remove it using the `.removeLast()` function of array
    types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is assuming that we know the exact order of the collection. Sets or dictionaries
    might be better at controlling certain aspects of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some ways to edit a set or a dictionary as a quick guide.
  prefs: []
  type: TYPE_NORMAL
- en: '**Set**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Dictionary**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Iterating through collection types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can't discuss collection types without mentioning how to iterate through
    them en masse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some way we''d iterate though an array, a set, or a dictionary in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As stated previously, this is done with what's known as a for-loop; with these
    examples, we show how Swift utilizes the for-in variation using the `in` keyword.
    The code will repeat until it reaches the end of the collection in all of these
    examples. In example `(c)`, we also see the use of the Swift function, `enumerate()`.
    This function returns a compound value, `(index,value)`, for each item. This compound
    value is known as a tuple, and Swift's use of tuples makes for a wide variety
    of functionalities for functions, loops, as well as code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: We will delve more into tuples, loops, and blocks later on.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C and Swift comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's a quick review of our Swift code with a comparison to the Objective-C
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a sample code in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the equivalent code in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used some examples of variables, constants, arrays,
    sets, and dictionaries. First, we see their Objective-C syntax and then the equivalent
    declarations using Swift's syntax. From this example, we can see how compact Swift
    is compared with Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Characters and strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For some time in this chapter, we''ve been mentioning strings. Strings are
    also a collection of data types, but a specially dealt collection of characters,
    of the class type, string. Swift is Unicode-compliant, so we can have strings
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have strings with emoji characters like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What we did in the preceding code was create what's known as a string literal.
    A string literal is when we explicitly define a string around two quotes "".
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create empty string variables for later use in our games such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both are valid ways to create an empty string "".
  prefs: []
  type: TYPE_NORMAL
- en: String Interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also create a string from a mixture of other data types, known as **String
    Interpolation**. String Interpolation is rather common in game development, debugging,
    and string use in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most notable of examples are displaying the player''s score and lives.
    This is how one of our example games, PikiPop, uses String Interpolation to display
    the current player stats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the `\(variable_name)` formatting. We've actually seen this before
    in our past code snippets. In the various `print()` outputs, we used this to display
    the variable, collection, and so on we wanted to get information on. In Swift,
    the way to output the value of a data type in a string is by using this formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those of us who came from Objective-C, it''s the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note how Swift makes String Interpolation much cleaner and easier to read than
    its Objective-C predecessor.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are various ways to change strings, such as adding characters to a string
    as we did to collection objects. Here are some basic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since strings are essentially arrays of characters, like arrays, we can use
    the `+=` assignment operator to add to the previous string.
  prefs: []
  type: TYPE_NORMAL
- en: Also, akin to arrays, we can use the `append()` function to add a character
    to the end of a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we iterate through the characters in a string, in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note how again we use the for-in loop and even have the flexibility of using
    a string literal if we'd so like to be what's iterated through by the loop.
  prefs: []
  type: TYPE_NORMAL
- en: String indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another similarity between arrays and strings is the fact that a string's individual
    characters can be located via indices. Unlike arrays, however, since a character
    can be a varying size of data, broken in 21-bit numbers known as Unicode scalars,
    they can not be located in Swift with `Int` type index values.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use the `.startIndex` and `.endIndex` properties of a string
    and move one place ahead or one place behind the index with the `.successor()`
    and `.predecessor()` functions, respectively, to retrieve the needed character
    or characters of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples that use these properties and functions using our previous
    `gameText` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to manipulate, mix, remove, and retrieve various aspects
    of strings and characters. For more information, be sure to check out the official
    Swift documentation on characters and strings at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html).
  prefs: []
  type: TYPE_NORMAL
- en: Commenting in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our code snippets thus far, one might note notations with double forward
    slashes `//` or with forward slashes and asterisks `/* */`. These are how we can
    comment or make notations in our Swift code. Anyone who's coded in C++, Java,
    Objective-C, JavaScript, or other languages will see that Swift works practically
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Single-line comments are started with the double forward slashes, `//`, while
    multiline comments or a comment block begins with `/*` and ends with `*/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Commenting is used to help navigate your code, understand what it might do,
    and comment out lines of code we might not want to execute, but at the same time
    want to keep for later (that is, `print()` log calls or alternative starting property
    values).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From Xcode 6 Beta 4 onward, we can also utilize the following comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// MARK`:, `// TODO:`, and `// FIXME`. `//MARK` is equivalent to Objective-C''s
    `#pragma` mark, which allows the programmer to label a *section* of your code
    that is accessible in Xcode''s top breadcrumb dropdown list. `// TODO:` and `//
    FIXME` give us the ability to section off parts of code that we wish to maybe
    add features to in the future or debug. Even games with well-organized class structuring
    can be daunting to sift through. The addition of these additional mark-up tools
    makes planning and searching through our games'' code that much easier to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An integral part of all programming, game, or otherwise is the use of **Boolean**
    values. Boolean values typically return either `true` or `false` values, `yes`
    or `no`, or `0` or `1`. In Swift, this is the job of the `Bool` class of objects.
    The use of the function `.isEmpty()` in our past collection data type examples
    returns a Boolean value of `true` or `false` based on whether that collection
    is empty or not.
  prefs: []
  type: TYPE_NORMAL
- en: In game development, one way we could use Boolean values is to have a global
    variable (a variable accessible in scope throughout our game/app) that checks
    if the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This variable, taken from the PikiPop game, starts the game off with a variable
    of type `bool` named `isGameOver` with a starting value of `false`. If the events
    of the game cause this value to change to `true`, then this triggers the events
    associated with the game over state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike Boolean values in Objective-C, Swift uses only `true` or `false` values
    to represent Boolean variables. *Swift strict type safety* does not allow the
    use of `YES` and `NO` or `0` and `1`, as we have seen in Objective-C and other
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: However, reading and controlling this type of information about our game, known
    as the game's state, is best controlled with more than just a single Boolean value.
    This is because your game and the characters in your game could have various states,
    such as *game over*, *paused*, *spawn*, *idle*, *running*, *falling*, and more.
    A special object known as a *state machine* best manages this type of information.
    State machines shall be covered in more detail when we discuss the **GameplayKit**
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Ints, UInts, floats, and doubles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to Boolean values, another basic data type we have up to this point
    briefly mentioned is the various numeric objects, such as integers (Ints), unsigned
    integers (UInts), floating point numbers / decimals (floats), and double precision
    floating point numbers / decimals (doubles).
  prefs: []
  type: TYPE_NORMAL
- en: Integers and unsigned integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integers represent negative and positive whole numbers, while unsigned integers
    represent positive whole numbers. Like with C and other programming languages,
    Swift lets us create various types of integers and unsigned integers from 8, 16,
    32, and 64 bits. For example, an Int32 type is a 32-bit integer, while a UInt8
    type is an 8-bit unsigned integer. The size of the bits for Ints and UInts represents
    how much space is being allocated to store the values. Using our UInt8 example,
    a number made from this type of unsigned Int can only store the values 0-255 (or
    11111111 in a base-2 system). This is also known as 1 byte (8 bits). If we need
    to store numbers larger than 255 or negative numbers, then maybe an Int16 type
    would suffice as that can store numbers between –32767 and 32767\. Usually, we
    don't have to worry too much about the size allocated by our integer variables
    and constants. So, using just the class name of `Int` will work fine in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The size of `Int` will differ depending on the type of system we are working
    on. If we are compiling our code on a 32-bit system, an integer will be equal
    to Int32, while the same integer would be an Int64 on a 64-bit system.
  prefs: []
  type: TYPE_NORMAL
- en: Swift can let us see what our minimum and maximum values are for an `Int` variable
    with the `.min` or `.max` class variables (that is, `Int16.max = 32767` and `UInt.min
    = 0`).
  prefs: []
  type: TYPE_NORMAL
- en: Floats and doubles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Floats are 32bit floating point numbers / fractions, such as pi (3.14), or the
    golden ratio, phi (1.61803).
  prefs: []
  type: TYPE_NORMAL
- en: In game designing, we work with floating point values and ranges rather often,
    be it to determine the CGPoint in *x* and *y* of a 2D sprite, using linear interpolation
    for smoothing a game's camera movement in 3D space, or applying various physics
    forces on an object or 2D/3D vector. The precision needed for each situation will
    determine if a float is needed or if the 64-bit floating point value, the double
    is needed. Doubles can be as precise as 15 decimal places, while a float is six
    decimal places precise.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's actually best practice to use doubles in situations that would work for
    either floats or doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Objects in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core aspect of **object-oriented programming** (**OOP**) is of course the
    concept of objects. C++ began this paradigm in programming, while Java, C#, Apple's
    Objective-C, and other languages were all essentially built from this foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Swift is an OOP language with the same dynamic object model as Objective-C,
    but presented in a cleaner, type-safe, and compact way.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of an object exactly as it sounds, an abstract *thing* or *container*.
    An object can be something as simple as a string, or something as complex as the
    player object in the latest video game. Technically speaking, an object in a program
    is a *reference* to a set of various data in an allocated chunk of memory, but
    it's sufficient to just understand that an object can be a variable or a reference
    to an instance of a class, Struct, or block of code.
  prefs: []
  type: TYPE_NORMAL
- en: An object can have various data fields/aspects associated with it, such as properties,
    functions, parent objects, child objects, and protocols. In languages such as
    C for example, an integer variable is usually represented as just raw data, but
    the integer type in Swift is actually an object. Thus, we can access extra information
    and perform functions on `Int` objects in our code. We previously saw this with
    the `Int.max` variable, which returns the highest number that can be represented
    by the `Int` class. Again, depending on the machine you are working on, this could
    be the same value as `Int32.max` or `Int64.max`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Access to functions and properties of an object uses dot notation, as we saw
    with the previous example. `Int.max` and `Int.min` are actually special properties
    known as **class variables**, which represent all instances of an `Int` type object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how Swift deals with obtaining properties and functions of an
    instance of an object using a made-up `Player` type object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We'll get back to the second half of line `(a)`, but just understand that it
    creates an instance of an object of the type `Player` named `currentPlayer`. Line
    `(c)` creates a variable named `playerHealth` that's set by the `health` property
    of `currentPlayer`; here with the *dot notation*. Lines `(b)` and `(d)` use the
    dot notation to call the functions `getName()` and `attackEnemy()`. The `getName()`
    function in this case is a function that returns a string that's assigned to the
    constant, `playerName`. Line `(c)` creates a variable named `playerHealth` that
    is created by referencing the health property of `currentPlayer`, also using dot
    notation. Line `(d)` is a direct call to the `Player` class' `attackEnemy()` function,
    which you can imagine for now just performs what would make `currentPlayer` do
    her attack. This function doesn't return a value and thus is what's known as a
    `void` type function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for line `(a)`, one might note that it doesn''t use the dot notation. This
    is how Swift does what''s known as a class initializer; designated by the parenthesis
    `()` after the class name and with the parameter called `name`: that sends a string,
    `Fumi`, to the object''s class initializer.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be diving deeper in to the use of *objects* momentarily as we move on
    to functions and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety and type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects and, as we'll see, functions on these objects in Swift are type-safe.
    What this means is that if we perform a function on a string object when the code
    was expecting an integer, then the compiler will warn us early on in the process.
    In the vein of game design, if we were to have the player perform an action only
    an enemy supposed to do, then Swift will know through its inherently type-safe
    nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift''s type inference is something we''ve mentioned before. Unlike other
    languages where you have to declare the object''s type every time it''s initialized,
    Swift will infer what type you mean. For example, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we stated before, Swift is a type-safe language. Apple also created Swift
    with the intention of keeping as many potential errors and bugs in the compilation
    state of development as opposed to runtime. Though Xcode has some great debugging
    tools, from the use of breaks, logging, and the LLDB debugger, runtime errors,
    particularly in games can be tough to spot, thus bringing the development process
    to a halt. To keep everything type-safe and as bug-free as possible during compilation,
    Swift deals with the concept of **optionals**.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals, in short, are objects that potentially can be or start as nil. Nil,
    of course, is an object that has no reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C, we could declare the following string variable for a game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, we would write this in the same way, but we''d find out very quickly
    that Xcode would give us a compiler error in doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Even more confusing for anyone new to Swift, we''d also get an error if we
    did something as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Creating empty/undeclared objects in our games makes sense and is something
    we'd often want to do at the start of our classes. We want that flexibility to
    assign a value later on based on the events of our game. Swift seems to be making
    such a basic concept impossible to do! No worries; Xcode will inform you in most
    cases to suffix a question mark, `?,` at the end of these `nil` objects. This
    is how you declare an object as an optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we want to plan our game''s properties and objects in Swift, we can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Unwrapping optionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine that we want to display what caused a player to lose in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Because the string `causedGameOver` is optional, Xcode will give us a compile
    error because we didn't unwrap the optional. To unwrap the value in an optional,
    we suffix an exclamation point `!` at the end of the optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `Game Over` message code, now fixed using the unwrapped optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can also force unwrap optionals early at declaration to allow any potential
    errors to be taken care of at runtime instead of when compiling. This happens
    often with `@IBOutlets` and `@IBActions` (objects and functions linked to various
    storyboards and other tools that are based on menu/view tools).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If possible, though it's recommended to use the basic wrapped optional `?` as
    much as possible to allow the compiler to find any potential errors. Using what's
    known as optional binding and chaining, we can do some great early logic checks
    on optionals that in prior languages would have involved various `if` statements
    / control flow statements to simply check for nil objects.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping code clean, safe, and easy to read is what Swift aims to do and why
    Swift goes out of its way sometimes to force many of these rules with optionals.
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding and chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optional binding is checking whether an optional has a value or not. This is
    done using the very handy if-let or if-var statements. Let''s look back at our
    earlier code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The code block, `if let gotCauseOfDeath = causedGameOver{…}`, does two things.
    First, using the key words, `if let`, it automatically creates a constant named
    `gotCauseOfDeath` and then binds it to the optional `causedGameOver`. This simultaneously
    checks whether `causedGameOver` is `nil` or has a value. If it's not nil, then
    the `if` statement's code block will run; in this case, creating the constant
    `gameOverMessage` that combines the `text` constant with `gotCauseOfDeath`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use if-var to simplify this even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The if-var statement creates a temporary variable using our previously used
    optional `causedGameOver` and does a Boolean logic check based on the result of
    `whatKilledPlayer(enemy.recentAttack)`. The statement is true if there's a non-nil
    value returned. Note how we don't have to use either wrapped (`?`) or forced unwrapping
    (`!`) of the optional in such a case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional chaining is when we query down into the properties of an object using
    the dot operator while also doing a nil/value check as we did with optional binding.
    For example, let''s say that we have a game where certain Enemy types can cause
    a player to lose instantly via an Enemy instance named `currentEnemy`. In this
    example, `currentEnemy.type` would be a string that returns the name of the kind
    of enemy that hit the player. Optional chaining uses the custom dot modifier `?.`
    while accessing a potentially nil check on a property. Here''s the code to get
    a better idea of how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Chances are that we'd probably not make an enemy without a designated type,
    but for the sake of understanding optional chaining, observe how this checks for
    the possible nil object that'd be returned by `currentEnemy.type` using `currentEnemy?.type`.
    Like how the dot operator functions where you can drill down the properties and
    properties of properties, the same can be done with the recurring `?.per` property
    that is drilled down. In this code, we do a Boolean comparison with `==` to see
    if `enemyType` is the string `OneHitKill`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if the syntax of the `if` statement syntax is a bit of a mystery;
    next, we discuss how Swift uses `if` statements, loops, and other ways we can
    control various object data and their functions.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow in Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Control flow in any program is simply the order of instructions and logic in
    your code. Swift, like any other programming language, uses various statements
    and blocks of code to loop, change, and/or iterate through your objects and data.
    This includes blocks of code such as `if` statements, for-loops, do-while loops
    and Switch statements. These are contained within functions, which make up larger
    structures like classes.
  prefs: []
  type: TYPE_NORMAL
- en: If statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we move on to how Swift handles one of the main topics of OOP, functions
    and classes, let''s quickly run through if-else statements. An `if` statement
    checks whether a Boolean statement is `true` or `false`. We have the example as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This checks whether or not the player''s health is less than or equal to `0`,
    designated by the `<=` operator. Note that Swift is OK with there not being parenthesis,
    but we can use this if we wish or if the statement gets more complicated, as in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check not just whether the player has lost all of their health, but
    also if all of their lives are gone with the and (`&&`) operator. In Swift, like
    in other languages, we separate out the individual Boolean checks with parentheses,
    and like other languages, we do a logic-or check with two bar keys (`||`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more ways to write `if` statements in Swift with the added key
    words, else-if and else, as well as how Swift can check if-not a certain statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what we put in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a)`: This checks the not / reverse of a statement with the exclamation point,
    `!`, via `!statement`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(b)`: This checks whether the player has won or not. Otherwise, the `stageLost()`
    function is called, using the key word `else`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(c)`: This checks if an enemy is an angel and sets its aura effect accordingly.
    If this is not, then it will check if it''s a demon using else-if, and if that''s
    not the case, then we catch all other instances with the `else` statement. We
    could have a number of else-if statements one after another, but if we start to
    stack too many, then using for-loops and Switch statements would be a better approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(d)`: Using optional chaining, we create an `onlineID` constant based on `if`;
    we are able to get a non-nil `playerID` property using if-let.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(e)`: This uses if-let, where optional binding became a feature in Swift 1.2\.
    Instead of having nested if-lets and other logic checks, akin to how SQL queries
    are done in backend web development, we can create very compact, powerful early
    logic checking. In the case of example `(e)`, we have an enemy receive an attack
    based on what type of attack it is and the power of the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(f)`: This is an example of combining the creation of a constant with the
    keyword `let` and doing a shorthand version of an `if` statement. We shorthen
    an `if` statement in Swift with the question mark `?` and colon `:`. Here is the
    format for short handing an `if` statement: `bool ? trueResult : falseResult`.
    If `isPoweredUp` is `true`, then `playerPower` will equal `basepower + 250`; if
    `false`, then it''s `basepower + 50`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We touched on for-in loops before dealing with collections. Here again is a
    for-in loop in Swift that will iterate through a collection object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For some of us programmers who are used to the older way of using for-loops,
    don''t worry, Swift lets us write for-loops in the C-style, which many of us are
    probably used to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another way of using a for-loop without using an index variable, noted
    with the underscore character `_` but of course using a `Range<Int>` object type
    to determine how many times the for-loop iterates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note the `…` between the `1` and `limit`. This means that this for-in loop will
    iterate from 1-10\. If we wanted it to iterate from `0` to `limit-1` (similar
    to iterating between the bounds of an array's index), we could have instead typed
    `0..<limit` where `limit` is equal to the array's `.count` property.
  prefs: []
  type: TYPE_NORMAL
- en: Do-while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another very common iteration loop in programming is the do-while loop. Many
    times we can just utilize the while portion of this logic, so let''s look into
    how and why we might use a while loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In game development, one use of the while loop (though executed differently
    in a game app, this accommodates iterating once per frame) is for displaying the
    counting up of a player's score from 0 to the score the player reached—a common
    esthetic of many games at the end of a stage. This while loop will iterate until
    it reaches the player's score, displaying on HUD object showing the intermediate
    values up until that score.
  prefs: []
  type: TYPE_NORMAL
- en: 'A do-while loop is practically the same as the while-loop with the extra caveat
    of iterating through the code block at least once. The end-stage score count example
    can also illustrate why we would need such a loop. For example, let''s imagine
    that the player did really bad and got no score when the stage ended. In the while
    loop given, a score of zero won''t let us enter the block of code in the while
    loop since it doesn''t fulfill the logic check of `scoreCountNum < score`. In
    the while loop, we also have code that displays the score text. Though maybe embarrassing
    to the player, we would want to count up to the score and more importantly, still
    display a score. Here''s the same code done with a do-while loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement here takes the variable used to count how many times the
    player hit a 6X combo, `comboX6_counter`, and performs different tasks based on
    the value of `comboX6_counter`. For example, when the player has done a 6X Combo
    twice, the Piki_ComboX6 achievement gets 25% fulfilled. The player gets the achievement
    (when at 100%) when the counter hits 10\. The purpose of the keyword `break` is
    to tell the loop to exit at that point; otherwise, the next case block will iterate.
    Sometimes, this might be desired by your game's logic, but keep in mind that Swift,
    like many other languages, will continue through the switch statement without
    `break`. The keyword `default` is the catch-all block and is called when the value
    of the item checked by the switch statement is anything but the various cases.
    It can be thought of as an equivalent to the `else{}` block, while all of the
    cases are similar to `else if(){}`. The difference though is that Swift requires
    all cases of the switch be handled. So, though we can suffice with an `if` without
    an `else`, we have to have a default case for a switch statement. Again, this
    is done to keep Swift code safe and clean earlier in the coding process.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until this point, we have kept from discussing probably the most important
    aspects of Swift or any OOP languages for that matter—how the language handles
    functions on objects and how it organizes these objects, object properties, and
    functions and performs various object-oriented design concepts, such as polymorphism
    and inheritance with classes, Structs, enums, protocols, and other data structures.
    There is much more to discuss about how Swift utilizes these concepts, more than
    we can fit in this chapter but throughout the course of this book, especially
    as we get into how to use Apple's game-centric SpriteKit and SceneKit frameworks,
    we will flesh out more on these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Objective-C, functions are written the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple function that returns the player's health as an integer—the
    `Int` equivalent in Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the function/method is as follows in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the same function in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how a function is structured in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note how we use the keyword `func` to create a function and how the argument/parameter
    names are first with the types second, separated by the colon (`:`) and within
    parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: Here's what a typical void function looks like in Swift. A void-type function
    is a function that doesn't return a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In a void function, there's no need to write `->returnType`, but even if there
    are no parameters, we do have to put in the `()` parenthesis at the end of the
    function name.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A rather powerful aspect of Swift is that function return types (and constants/variables)
    can include a combination of values into a single value. These combinations are
    called **tuples**. Here''s an example of an unnamed tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a tuple used as a return type in a function direct from Apple''s Swift
    documentation. Observe how it uses much of what we''ve learned thus far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OOP, classes make up the basic frame of an object, its functionality and
    interactions with other classes, objects, and various data structures, such as
    protocols, Structs, extensions, generics, and enumerations. In the following chapters,
    as we begin to structure our games, we will dive deeper into all of these concepts,
    but for now, let's understand the basics of classes and how they differ in Swift
    from Objective-C and other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the basic structure of a class in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The Swift class structure works somewhat similar to what we see in C# and Java,
    as opposed to Objective-C''s two files'' (`.h`/`header`, `.m`/`.mm`/ implementation)
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a)`: We can have properties (like variables, constants, Structs, and enums)
    outside of the class declaration, which would make them global in scope, aka accessible
    throughout the entire project/game/app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(b)`: This is the actual class represented by what we named our `.swift` file.
    Again, this is different from Objective-C''s `classname.h - classname.m/.mm` dual
    file setup for a single class. A class can be a child class of another class.
    We don''t have to declare a parent/base class in Swift. Classes we make can be
    their own base classes. We can make classes as Objective-C classes by subclassing
    them from NSObject. The benefit of that is getting Objective-C runtime metadata
    and capabilities, but we take a hit in performance from the extra *baggage*. Either
    in the same place as the `parentClass` or after the colon `:` of `parentClass`,
    we can declare which protocols this class will adhere to. We''ll discuss more
    on protocols later in the book, but just think of them as making sure your class
    utilizes the same functions as the protocol dictates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(c)`: These are where we''d place variables, constants, Structs, enums, and
    objects that are relevant for use in the scope of the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(d)`: Initializers are special functions we use to set up the properties in
    section `(c)` when other classes and data structures use instances of the class
    via `className(initializer parameters)`. We will discuss more on initializers
    more in the next chapter as we structure our games. They don''t have to be at
    the top of the class, but it''s a good practice to do so.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(e)`: These are where your class functions will be declared and developed.
    We can have functions that are known as class functions. These are designated
    with the keywords `class func`. In short, class functions are part of the class
    as a whole as opposed to an instance of the class. It''s best practice to place
    these above the next, more common type of function, the public functions, that
    can be accessed by other classes and properties via the dot operator (that is,
    `className.function(parameters)`). Using the `private func` keywords, as in C#
    and Java, we can create private functions that are only accessible to the class''s
    own functions and properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(f)`: The `deinit()` function is a special optional function that deals with
    how we clean up the data allocated by our class with memory management and eliminating
    what''s known as memory leaks. Apple''s **ARC** (**Automated Reference Counting**)
    handles most of this, but there are key words, such as weak and unowned, that
    we will at times have to put before various properties to make sure that they
    don''t hang around after use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a rather involved topic, but worth looking into to avoid memory leaks
    in your game. ARC does take care of most of this, but there might be objects in
    your game that could potentially hang around. It's highly recommended to read
    Apple's own documentation on this topic, as memory management in iOS is always
    in the evolving stage. You can view the full documentation on ARC and memory management
    in Swift at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(g)`: If we wish, we can have global properties also at the bottom of our
    `.swift` files, after the end of the class declaration. Apple''s own game example,
    Adventure ([https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html)),
    places global properties in this spot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's much more about the Swift programming language than we could fit here.
    Throughout the course of this book, we will throw in a few extra tidbits and nuances
    about Swift as it becomes relevant to our upcoming gaming programming needs.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to become more versed in the Swift programming language, Apple actually
    provides a wonderful tool in what's known as a **Playground**.
  prefs: []
  type: TYPE_NORMAL
- en: Playgrounds were introduced with the Swift programming language at *WWDC14*
    in June of 2014 and allow us to test various code outputs and syntaxes without
    having to create a project, build it, and run it and repeat again, when in many
    cases we simply needed to tweak a few variables and function loop iterations.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of resources to check out on the official Swift developer
    page ([https://developer.apple.com/swift/resources/](https://developer.apple.com/swift/resources/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Two highly recommended Playgrounds to check out are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Guided Tour Playground** ([https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip)):
    This Playground covers many of the topics we mentioned in this chapter and more,
    from **Hello World** all the way to **Generics**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Balloons Playground** ([https://developer.apple.com/swift/blog/downloads/Balloons.zip](https://developer.apple.com/swift/blog/downloads/Balloons.zip)):
    The Balloons Playground was the keynote Playgrounds demonstration from *WWDC14*
    and shows off many of the features Playgrounds have to offer, particularly to
    make and test games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, the best way to learn a programming language is to test live code,
    and that's exactly what Playgrounds allow us to do.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to testing snippets of code in our games, iOS 9 also allows us to
    plan and structure our games, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
