<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-70"><a id="_idTextAnchor073"/>5</h1>
<h1 id="_idParaDest-71"><a id="_idTextAnchor074"/>Animating Colorful Kaleidoscope Effects </h1>
<p>In this chapter, we will look at how we can animate colors with a modifier called <code>hueRotation</code>, where “<a id="_idTextAnchor075"/>hue” refers to the colors of the object, and “rotation” refers to the colors being rotated or animated. We will create a simple project that displays various images and then, using <code>hueRotation</code>, we can change or shift the colors of the images so that they will resemble somewhat of a kaleidoscope effect.</p>
<p>Along with <code>hueRotation</code>, there are some other important concepts we will explore in this project. </p>
<p>We will work with a Picker view for the first time, which is exactly what the name suggests; it lets the user pick from a variety of options, which can then be displayed on the screen. </p>
<p>Also, we will look at how to pass data bidirectionally to another view. If you remember the moving circle project in <a href="B18674_03.xhtml#_idTextAnchor048"><em class="italic">Chapter 3</em></a>, it was built inside one file and then within one view, the <code>ContentView</code>. In <a href="B18674_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, we built the record player using several files and then put those files together inside the <code>ContentView</code>. In both of those projects, we didn’t pass any data from file to file or view to view; the views contained blocks of code that just needed to be called in the main <code>ContentView</code>. But in this project, we will see how to pass data from different views using a special property wrapper called <code>@Binding</code>.</p>
<p>So, let’s lay out the objectives before we dive in:</p>
<ul>
<li>Adding the Binding variable and images</li>
<li>Adding a Picker control and using a <code>ForEach</code> view</li>
<li>Adding the variables and background color</li>
<li>Adding the Image view and using the <code>hueRotation</code> modifier</li>
</ul>
<h1 id="_idParaDest-72"><a id="_idTextAnchor076"/>Technical requirements </h1>
<p>You can find the completed project and the images we will use in the <code>Chapter 5</code> folder over on GitHub at <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor077"/>Adding the Binding variable and images</h1>
<p>Okay, let’s get started. So, create a new<a id="_idIndexMarker280"/> Xcode project, give it a name, and we will get underway.</p>
<p>We will start by adding a new SwiftUI file to the project, which I’ll call <code>selectedImage</code>, and make it of the <code>String</code> type. We will prefix this variable with the <strong class="bold">@Binding</strong> wrapper, as shown<a id="_idIndexMarker282"/> here: </p>
<pre class="source-code">
struct ImagePickerView: View { 
    @Binding var selectedImage: String 
    var body: some View { 
        Text("Hello World") 
    } 
} </pre>
<p>The <code>@Binding</code> property wrapper is used to create a two-way binding between a source of truth (for example, a state property in a parent view) and a view that depends on that state. This <code>ImagePickerView</code> is the source of truth as it’s the parent view here. The <code>@Binding</code> wrapper allows a view to read and write to a value, but also makes sure that any changes made to the value are propagated back to the original source of truth. This is how views can be updated and re-rendered automatically whenever the source of truth changes, without having to manually pass down new values and refresh the view.</p>
<p>Let’s now add some images that we need to the project. You can find them in the GitHub repository – just download the resources for this chapter. There are five images: <code>ornament</code>, <code>landscape</code>, <code>dog</code>, <code>dice</code>, and <code>cat</code>. Open the Assets catalog and drop the five images into the catalog (just like we did when creating the record player).</p>
<p>With the images in place, let’s <a id="_idIndexMarker283"/>create an array of strings that can hold the<a id="_idIndexMarker284"/> names of the images. Here is the code, which gets placed under the <code>@Binding</code> property: </p>
<pre class="source-code">
struct ImagePickerView: View { 
    @Binding var selectedImage: String 
    let images: [String] = ["ornament", "landscape", "dog", 
      "dice", "cat"] 
     
    var body: some View { 
        Text("Hello World") 
    } 
} </pre>
<p>To create the array, we first give it a name, <code>images</code>, then use the <code>String</code> keyword within square brackets, then another pair of square brackets in which we fill the <code>images</code> array with five <code>String</code> elements, which are the names of the images we want to use. Each string is separated by a comma.</p>
<p>Now the <code>images</code> array is ready to use. Let’s add a Picker control and see how we can loop through this array using a <code>ForEach</code> view to store each string name in the picker.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>Adding a Picker control and using a ForEach view </h1>
<p>SwiftUI offers us a <a id="_idIndexMarker285"/>sufficient number of pre-built controls to help put together a user interface that is both nice to look at and very<a id="_idIndexMarker286"/> functional. One control that is useful for providing your user <a id="_idIndexMarker287"/>with a list of options is the <strong class="bold">Picker view</strong>, which can provide as few or as many values as you<a id="_idIndexMarker288"/> need to display for your app. A Picker view is a view that lets the user select an item from a list of options and is usually used together with a Binding variable, which will store the currently selected value. </p>
<p>We will be using a <code>forEach</code> view to<a id="_idIndexMarker289"/> iterate through the <code>images</code> array and populate the picker. Working<a id="_idIndexMarker290"/> in the <code>body</code> property, let’s add the <code>PickerView</code> first, and a <code>ForEach</code> view inside the picker:</p>
<pre class="source-code">
struct ImagePickerView: View { 
    @Binding var selectedImage: String 
    let images: [String] = ["ornament", "landscape", "dog", 
      "dice", "cat"]
    var body: some View { 
        Picker("", selection: $selectedImage) { 
            ForEach(images, id: \.self) { value in 
                Text(value) 
                    .foregroundColor(.white) 
            } 
        }</pre>
<p>Okay, there’s a lot going on here, so let’s break it down. Quick note though: don’t worry about the preview struct below the <code>ImagePickerView</code> just yet; that’s going to show an error, but we’ll fix <a id="_idIndexMarker291"/>that in a moment.</p>
<p>For the Picker’s first parameter, you’ll notice there’s an empty <code>String</code> value. The string will allow you to give the Picker a label if you think it needs one; however, we do not need it here so we’re leaving the <code>String</code> parameter empty. Inside the next parameter, called <code>selection</code>, is where the <code>selectedImage</code> binding property will go, and this property will bind to a <code>State</code> property in the <code>ContentView</code> later. We haven’t added any State properties in the <code>ContentView</code> yet, but we will soon. </p>
<p>Now the <code>selectedImage</code> property in this <code>ImagePickerView</code> file will be bidirectionally connected to a State property in the <code>ContentView</code>. That connection allows for the instant refreshing of views between those two structs when the value changes in either struct. </p>
<p>The syntax does require that we put the dollar sign (<code>$</code>) before the property in order to tell SwiftUI that this property is a binding property and can connect to the <code>ContentView</code> (the source of truth) and update the views. </p>
<p>The next line of code is the <code>ForEach</code> view. What we want to do is loop through the <code>images</code> array and display all those String labels of that array in the <code>Picker</code> view. In order to loop through the array <a id="_idIndexMarker292"/>of strings, they need to have some sort of ID that identifies each element<a id="_idIndexMarker293"/> in this array uniquely. And since they all have different names, why not use the names of each element, which already constitute unique IDs? To use each image’s name as an ID for the loop, we used the <code>\.self</code> syntax, placed after the <code>images</code> array. </p>
<p>The <code>value</code> keyword in this code is the looping variable; it will store each element from the <code>images</code> array as the <code>ForEach</code> view loops through them. This looping variable can be named anything you<a id="_idIndexMarker294"/> like, but I called it <code>value</code> in this example as that makes the most sense (it temporarily holds the value of each element in the array, one at a time).</p>
<p>Now looking at the code in the <code>ForEach</code> view’s body, we only need to add one <code>Text</code> view with the <code>value</code> variable inside it. That will display everything that is in the <code>images</code> array in the <code>PickerView</code>. Next, we change the color of the text to white using the <code>foregroundColor</code> modifier. We do this because when we go into the <code>ContentView</code> file, we will make the screen’s background black; that way, we’ll see the white letters over the black background. </p>
<p>That completes the <code>Picker</code> view functionality; let’s now style the appearance of the <code>Picker</code> view by adding some modifiers to it after the view’s closing bracket:</p>
<pre class="source-code">
        }.pickerStyle(WheelPickerStyle())         
        .frame(width: 300, height: 150)
        .background(Color.red.colorMultiply(.blue))
        .cornerRadius(20)
        .shadow(color: .white, radius: 5, x: 0, y: 0 )</pre>
<p>Let’s look at each of the modifiers used:</p>
<ul>
<li>The first modifier I’ve added is <code>pickerStyle()</code>, which is used to change the appearance of the <code>Picker</code> view. There are four built-in styles we can select from to style the Picker using the <code>pickerStyle()</code> modifier. The following are the ones available:<ul><li><code>DefaultPickerStyle()</code>: The default style that is chosen automatically by the system based <a id="_idIndexMarker295"/>on the platform and current context. This presents the choices to the<a id="_idIndexMarker296"/> user in a menu style.</li><li><code>PopUpButtonPickerStyle()</code>: This is a pop-up button-style picker, often used on macOS. This presents the choices in a button style to the user.</li><li><code>WheelPickerStyle()</code>: A wheel-style picker, often used on iOS. This presents the choices in a wheel style to the user.</li><li><code>SegmentedPickerStyle()</code>: A segmented control-style picker, commonly used on iOS, watchOS, and tvOS. This presents the choices in the style of a segmented button to the user.</li></ul></li>
</ul>
<p>We chose the <code>WheelPickerStyle</code> for this project.</p>
<ul>
<li>The second<a id="_idIndexMarker297"/> modifier is the <code>frame</code> modifier, which sets the dimensions of the picker control. Here, we set the dimensions as <code>300</code> points wide and <code>150</code> points tall. </li>
<li>Next is the <code>background</code> modifier, which sets the background color of the picker to red. <code>colorMultiply</code> then modifies the red color instance by multiplying its RGB values with those of another color, blue in this case. The result is a dark shade of purple.</li>
<li>After that, we used the <code>cornerRadius</code> modifier to round the corners of the picker by 20 points. </li>
<li>We finish styling the picker using the <code>shadow</code> modifier. This will add a white shadow with a radius of 5 points and will be visible when we change the background to black.</li>
</ul>
<p>Now, let’s return to the error that our code is experiencing and see how we can make sure the app builds cleanly. The error<a id="_idIndexMarker298"/> says that we are missing an argument from the <code>ImagePickerView</code>’s call. And that’s true, because we added a <code>Binding</code> property into the <code>ImagePickerView</code> struct called <code>selectedImage</code>, and since the <code>Preview</code> struct is referencing the <code>ImagePickerView</code>, it needs to use that <code>Binding</code> variable in itself too in order to build cleanly.</p>
<p>To fix this problem, we need to<a id="_idIndexMarker299"/> go into the <code>Previews</code> struct at the bottom of the file and change the first line of code to this:</p>
<pre class="source-code">
ImagePickerView(selectedImage: .constant("ornament")) </pre>
<p>By using the <code>constant</code> function, the error goes away. The <code>constant</code> function will accept any value we want as<a id="_idIndexMarker300"/> long as it’s of the String type, because that’s the data type of the <code>selectedImage</code> property. I’m using the <code>"ornament"</code> string from the <code>images</code> array, and that string will be shown in the picker. </p>
<p>Now that the code builds cleanly, the result should look like this:</p>
<div><div><img alt="Figure 5.1: Picker View  " src="img/B18674_05_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: Picker View </p>
<p>Spin the wheel picker and you can see all of the string names from the <code>images</code> array.</p>
<p>Now that we are done with the <code>ImagePickerView</code> file, let’s continue by setting up the <code>ContentView</code> file. </p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor079"/>Adding the variables and background color</h1>
<p>Moving into the <code>ContentView</code> file now, our first task here will be to add a couple of variables and a constant. Let’s start <a id="_idIndexMarker301"/>with adding a variable that will <a id="_idIndexMarker302"/>bind to the <code>selectedImage</code> binding property in the <code>ImagePickerView</code> file.</p>
<p>To do that, we need to create a <code>State</code> variable, which needs to be the same data type as the <code>selectedImage</code> variable, a <code>String</code> type. We can give it the same name as the variable too, <code>selectedImage</code>, so that you know this variable is bidirectionally linked to the variable in the <code>ImagePickerView</code> file.</p>
<p>Add this code inside the <code>ContentView</code> struct, at the top: </p>
<pre class="source-code">
    @State private var selectedImage: String = "ornament" 
    @State private var shiftColors = false 
    let backgroundColor = Color(.black) </pre>
<p>The <code>selectedImage</code> variable gets set to a String value called <code>ornament</code>. Next is a variable to track the animation called <code>shiftColors</code>, which is set to <code>false</code>. Finally, we have a constant to hold the background color, which will be black.</p>
<p>Moving into the <code>body</code> property, let’s add a <code>VStack</code>, which will take care of vertically organizing three views that the user interface needs: a background, which will be black; an <code>Image</code> view, to display the image selected by the user; and a call to the <code>ImagePickerView</code> that we created in the <code>ImagePickerView</code> file, which allows the user to select an image.</p>
<p>To do all of this, first add a <code>VStack</code> into the <code>body</code> property of the <code>ContentView</code>:</p>
<pre class="source-code">
var body: some View {
VStack {
       }
}</pre>
<p>Next, add the <code>ImagePickerView</code> into the <code>VStack</code> with the <code>frame</code> modifier on it, as shown here:</p>
<pre class="source-code">
var body: some View {
    VStack {
          ImagePickerView(selectedImage: $selectedImage)
          .frame(width: 350, height: 200)
        }</pre>
<p>To color the background, we <a id="_idIndexMarker303"/>need a <code>ZStack</code> so it can overlay the color onto the whole screen. Add this code inside the <code>VStack</code>:</p>
<pre class="source-code">
  ZStack {
        backgroundColor
           .scaleEffect(1.4)
       }
}</pre>
<p>As we have seen before, this code will color the background black, and by using the <code>scaleEffect</code> modifier and passing in the value of <code>1.4</code>, the black background will stretch out so it covers the<a id="_idIndexMarker304"/> entire screen.</p>
<p>Now that the background is set, let’s add an <code>Image</code> view to display the images, and then start animating some colors.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor080"/>Adding the Image view and using the hueRotation modifier</h1>
<p>With the<a id="_idIndexMarker305"/> background set up and all of<a id="_idIndexMarker306"/> the variables in<a id="_idIndexMarker307"/> place, let’s <a id="_idIndexMarker308"/>add an <code>ImageView</code> to display the images, and add the <code>hueRotation</code> modifier to it.</p>
<p>Add the following code right<a id="_idIndexMarker309"/> after the <code>scaleEffect</code> modifier:</p>
<pre class="source-code">
Image(selectedImage).resizable().padding(20).frame(width: 
  400, height: 400) 
    .hueRotation(.degrees(shiftColors ? 360 : 0)) 
    .animation(Animation.easeInOut(duration: 
      2).delay(0.3).repeatForever(autoreverses: true), 
      value: shiftColors)
    .onAppear() {
        shiftColors.toggle()
                }
            } 
            ImagePickerView(selectedImage: $selectedImage) 
                .frame(width: 350, height: 200) 
        }.background(backgroundColor) 
        .edgesIgnoringSafeArea(.bottom) 
    } 
} </pre>
<p>Here we are using the Image view to display the images on the screen, resizing it and adding a little padding to it. Then<a id="_idIndexMarker310"/> we set the frame of the image view to a size of <code>400</code> by <code>400</code>. </p>
<p>Next comes the <code>hueRotation</code> modifier. Hue rotation is an image-processing effect that adjusts the hue of <a id="_idIndexMarker311"/>an image by rotating the colors in the hue color wheel by a specified angle. It changes the overall color tone of an image by shifting the hue of each pixel.</p>
<p>The speed at which it does<a id="_idIndexMarker312"/> this is determined by the values that get passed into its parameter. And if you have an image with many different colors, then <code>hueRotation</code> will cycle through and rotate all of them, creating a sort of kaleidoscope color effect.</p>
<p>Looking at the <code>hueRotation</code> parameter, it needs a value to represent degrees, which is for the amount of rotation to apply to the colors in this view, and that is handled by the <code>degrees</code> function. Inside the <code>degrees</code> function is a ternary operator, which will select from two choices: either a value of <code>360</code> when the <code>shiftColors</code> variable is <code>true</code>, or <code>0</code> when it is <code>false</code>.</p>
<p>Next, the <code>animation</code> modifier is added<a id="_idIndexMarker313"/> to animate to the color-changing effect. It uses an <code>easeInOut</code> timing curve with a duration of 2 seconds to complete the animation and a delay of 0.3 seconds between <a id="_idIndexMarker314"/>animations.</p>
<p>Then we use the <code>onAppear</code> modifier, which runs the code within its body as soon as the view appears. This is a perfect place to trigger the animation by toggling the <code>shiftColors</code> variable to<a id="_idIndexMarker315"/> its opposite value.</p>
<p>After that, we set a frame<a id="_idIndexMarker316"/> width and height of <code>350</code> by <code>200</code> for the <code>ImagePickerView</code> and colored the background of the <code>VStack</code> by using our <code>background</code> variable. We also used <code>edgesIgnoringSafeArea</code> for the bottom edges, so the background color will go below the screen. We want the whole screen black with our views on top of it, and this code does just that.  </p>
<p>Guess what? With all that finished, the project is done! Here’s what it should look like: </p>
<div><div><img alt="Figure 5.2: Finished project " src="img/B18674_05_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: Finished project</p>
<p>Go ahead and<a id="_idIndexMarker317"/> run the project – you’ll <a id="_idIndexMarker318"/>see that the<a id="_idIndexMarker319"/> colors from<a id="_idIndexMarker320"/> your selected image will all shift and rotate over the span of 2 seconds.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor081"/>Summary</h1>
<p>Good work on completing the project! As you worked through it, you got to see how to use a <code>Binding</code> property so data can be bound between views, the <code>Picker</code> view, a view with different styles that allows users to select an image or other data, and finally the <code>hueRotation</code> modifier, which rotates colors.</p>
<p>In the next chapter, we will explore the process of cutting up an image into different parts, then rotating those separate parts using the <code>rotationEffect</code> modifier, to create an animation of a girl on a swing.</p>
</div>
<div><div></div>
</div>
</body></html>