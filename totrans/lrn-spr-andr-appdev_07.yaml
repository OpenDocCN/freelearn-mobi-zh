- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Concurrency** is the ability of a program or algorithm to be divided into
    parts that can be executed out of order without affecting the results. This approach
    allows for parallel execution in a multi-core environment, which can significantly
    improve the performance. It''s important to understand the difference between
    *concurrency* and *parallelism*. Parallelism assumes that a program is implemented
    in a concurrent way, but concurrency doesn''t mean that the program is executed
    in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback hell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the code in this chapter, you will need to integrate the `coroutines-core`
    library. To do this, you should add the following line to the `repositories` block
    of the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also add the following line to the `dependencies` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to integrate the `kotlinx-coroutines-android` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a Kotlin version lower than 1.3, you should also add the following
    lines to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate Spring for the Android library, you should add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also add the `repositories` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This chapter will also work with the [JSON to Kotlin Class](https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-)
    plugin. To install this plugin, open the Preferences window and select the Plugins
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Press the Install button and restart Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter, with examples, is available on GitHub, at
    the following link: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A** coroutine** is a powerful feature of the Kotlin programming language. Its
    main objective is to allow for suspending a function while it waits for the result
    of another function that invokes a long-term operation. This feature allows us
    to write asynchronous code without callbacks in a sequential way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutine basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutine testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutine scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutine basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with the concept of threads, you will know that each thread
    has its own call stack. We will cover the thread's call stack topic in the next
    section. The creation of a new thread is a complex operation that takes about
    two megabytes of memory. Coroutines use a thread pool under the hood, and only require
    the creation of several additional methods and classes. That is why you can consider
    coroutines as lightweight threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we have a long-term operation, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadImage` function takes three seconds and returns an instance of the
    `Image` class. We also have the `showImages` function that takes three instances
    of the `Image` class, and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have three independent tasks that can be executed in parallel. We can
    create three coroutines here, each of which will execute the `loadImage` function.
    To create a new coroutine, we can use one of the functions called a **coroutine
    builder**, such as `async` or `launch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `async` function returns an instance of `Deferred`. This class encapsulates
    a task that will return the result in the future. A `caller` function suspends
    when it invokes the `await` function of an instance of the `Deferred` class. This
    means that a thread that has a call stack with this function is not blocked, but
    is just suspended. The following snippet shows how this may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we call the `await` function, we suspend invoking the current function.
    In addition, the `showImages` function will be called when all of the subtasks
    return the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how these functions can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1ced344-a7f6-459e-8c71-1b78d8e748a0.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram shows that three tasks can be executed almost in parallel, depending
    on whether the distribution of the load between cores and the `showImages` function
    is invoked when all three of the images are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Call stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each coroutine and thread has its own call stack. This means that a coroutine
    or a thread is created along with its call stack. A **call stack** contains something
    like blocks for each function that is invoked using a context of this thread or
    coroutine. This block represents a memory space that contains metadata, primitive
    local variables, and local references to objects in the heap. You can consider
    a call stack a part of the memory that is allocated for a thread or coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how a **Call stack** looks when a thread or coroutine
    is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/773c3374-c203-4743-b6ec-0c93eae00e7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the `main()` function invokes another function, a new block is added to
    the call stack. This looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69a8993c-a7d7-4d62-a1ff-f1c0c4f4b654.png)'
  prefs: []
  type: TYPE_IMG
- en: When the `loadImage` function returns a value to the `main` function, the block
    of the `loadImage` function is removed from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutine testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `runBlocking` coroutine builder can be used for testing. This creates a
    coroutine that uses a current thread. The test within the JUnit framework may
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet loads an image using the `async` coroutine builder, and checks
    that the `image` is not null. The source code of the `runBlocking` function looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `runBlocking` coroutine builder uses the `currentThread`
    function to obtain an instance of the `Thread` class. When you run this test,
    you will see the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d9cb3cd-6dd4-4904-a018-691dcfe118e8.png)'
  prefs: []
  type: TYPE_IMG
- en: This window shows that the test has passed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutine scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the release of version 0.26.0 of coroutines, a new, important feature was
    introduced—coroutine scope. All of the coroutine builders from the `coroutines-core`
    library are extension functions of the `CoroutineScope` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CoroutineScope` interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We need the coroutine scope to provide a proper cancellation mechanism for the
    coroutines that we launch in our application. Modern frameworks, such as Android
    SDK or React Native, are built in such a way that all components, and the application
    itself, have a life cycle. In Android SDK, this can be an activity or a fragment,
    and in React Native, it can be a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coroutine scope represents a scope of an object that has a life cycle,
    such as an activity or a component. The `coroutines-core` library provides a scope
    for an entire application, and we can use it if we want to launch a coroutine
    that works as long as an application runs. The scope of the entire application
    is represented by the `GlobalScope` object, and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new activity with its own coroutine scope. The easiest way
    to do this is to call the context menu of a package and choose the New section,
    which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d113bb9-4172-43f7-bfcb-4d51ded36812.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, choose the Empty Activity option in the Activity subsection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecbe43be-f3ac-4252-9288-2ffb8221f3f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Android Studio will open the Configure Activity window, where you can change
    a configuration of Activity and press the Finish button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2b48a4f-65d3-424e-9985-5b29100b93db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A newly created `XKCDActivity` class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to launch a life cycle aware coroutine from this class, we should
    implement the `CoroutineScope` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CoroutineScope` interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `XKCDActivity` class implements the `CoroutineScope` interface and overrides
    the `coroutineContext` property. The overridden `coroutineContext` property contains
    a getter that returns `Dispatchers.Main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dispatchers` is an object from the `coroutines-core` library, which contains
    the following dispatchers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Default` is used by all standard coroutine builders, such as `launch` or `async`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Main` is used to run a coroutine on the main thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unconfident` invokes a coroutine immediately, on the first available thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IO` is used to run coroutines that perform input/output operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since a getter of the overridden `coroutineContext` property returns the `Main`
    dispatcher, all coroutine builders from this class will launch coroutines that
    work on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `XKCDActivity` has its own coroutine scope, but it is not life cycle aware.
    This means that a coroutine launched in a scope of this activity will not be destroyed
    if the activity is destroyed. We can fix this in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lifecycleAwareJob` will be used as a parent for all coroutines, and will
    cancel all child coroutines when an activity is destroyed. The following example
    code shows how to use this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The launch coroutine builder creates a coroutine that works on the main thread,
    and the async coroutine builder creates a coroutine that works on the input/output
    thread. When the `image` is ready, it will be shown on the main thread of the
    application. If we press the back button, the coroutines will be destroyed, along
    with `XKCDActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `async` function returns an instance of the `Deferred` class that allows
    us to compute a single value. If we need to transfer a sequence of values between
    coroutines, we can use channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'A channel is an interface that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SendChannel` interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `SendChannel` interface contains the `send` method that takes a parameter
    and adds it to this channel. The `isFull` property is `true` if this channel already
    contains a value. In this case, the `send` function suspends the caller until
    the contained value is not consumed.
  prefs: []
  type: TYPE_NORMAL
- en: A channel can be closed by invoking the `close` method. In this case, the `isClosedForSend`
    property is `true`, and the `send` method throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `SendChannel` interface allows us to put a value into a channel,
    the `ReceiveChannel` interface allows us to get the value from the channel. The
    `ReceiveChannel` interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `receiveOrNull()` method returns and removes an element from this channel,
    or returns null if the `isClosedForReceive` property is `true`. The `ReceiveChannel`
    contains the `iterator` method, and can be used in the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we sent two values by a channel and received those
    values. We also used the `delay` function to show that an operation takes some
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This output shows that the `send` function suspends a coroutine until a value
    is consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `for` loop to receive values from a channel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The producer function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `producer` function is called a **channel builder**, and it returns an
    instance of the `ReceiveChannel` class. This function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding snippet, the `produce` function contains a
    receiver parameter of the `ProducerScope` type. The `ProducerScope` interface
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `ProducerScope` interface extends the `SendChannel` interface.
    This means that we can use the `send` method inside a lambda that we pass to the
    `producer` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using the  `producer` function may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `numbersProduce` function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The actor function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `actor` function contains a receiver parameter of the `ActorScope` type.
    The source code of the `actor` function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ActorScope` interface looks similar to the `ProducerScope` interface,
    but implements the `ReceiveChannel` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you probably know, it is not a good idea to access mutable data from different
    coroutines. To deal with this, we can use channels and the `actor` function, in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet contains a mutable variable named `counter`. We change
    the value of the `counter` variable when a channel receives a new value. Since
    a channel suspends the caller until a consumer finishes processing the current
    value, we can be sure that the `counter` variable will be modified in the right
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `numbersCounter` function can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet launches ten coroutines that send a value to an actor
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the `counter` variable is modified in the right way.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important benefits of the coroutines approach is a guarantee
    that functions are invoked in the same order in which they are written. The order
    of the operations is a very important nuance when we execute concurrent code in
    a multithreaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine that we have to load a user''s details, using the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadUserDetails` function invokes the `delay` function from the `coroutines-core`
    library and returns an instance of the `User` class. The `delay` function suspends
    the invocation of the current coroutine. When a user is ready, we have to pass
    a value of the `avatar` property to the `loadImage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `loadImage` function also invokes the `delay` function, and returns an instance
    of the `Image` class. We should then pass the received instance of the `Image`
    class to the `showImage` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to execute these functions sequentially, using
    coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet invokes all three functions that use different coroutines,
    sequentially. The following diagram shows a sequence of functions invoking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59bdd6ea-201a-4037-b020-8cd4eb7b0f1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Callback hell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main reasons that you should use coroutines is to avoid callback
    hell.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a callback?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a callback?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **callback** is a pattern that is used to retrieve the results of an asynchronous
    task. This approach assumes that we pass a reference to a function that should
    be invoked when an asynchronous operation is done.
  prefs: []
  type: TYPE_NORMAL
- en: By *synchronous operations*, we mean that the tasks are executed one after another.
    The asynchronous approach assumes that several tasks can be performed in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadImage` function in the following example code uses a callback to return
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet shows the simplest example of how to create an asynchronous
    function that returns the results using the callback. In our case, the callback
    is a lambda that takes an instance of the `Image` class and returns `Unit`. The
    following diagram shows how this sequence works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acb5e395-a5e2-4e4d-9d5b-8870aa6d5e9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This function can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows that it is easy to use a callback to deal with asynchronous
    code. We just implement and pass a lambda that is invoked when an image is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how to implement this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/038b56be-f66c-423a-b5e8-b1382b5b4889.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s imagine that we are requesting a list of users from the server. After
    that, we send another request to get detailed information about a user, and then,
    we load an avatar. In code, this may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadListOfFriends` function takes a lambda that takes a list of instances
    of the `ShortUser` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadUserDetails` function takes a lambda and an identifier of a user,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadImage` function takes a path to the avatar and lambda. The following
    example code demonstrates the most common problem that occurs when we use an approach
    with callbacks. We encounter the problem of code complexity and readability when
    concurrent tasks have to pass data to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet demonstrates what callback hell is. We have a lot of nested
    functions, and it is hard to maintain this code.
  prefs: []
  type: TYPE_NORMAL
- en: Thread pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The creation of a new thread is a complex operation that takes up a lot of resources.
    In the *Call stacks* section, we covered how memory is allocated for a new thread.
    When the lower block of a function is removed from a stack, the thread is destroyed.
    To avoid constantly creating new threads, we can use thread pools. There is no
    logic in creating a new thread for invoking each short-term operation, because
    this operation and switching the program flow to a created context can take more
    time than executing the task itself. The thread-pool pattern assumes a class that
    contains a set of threads that are waiting for a new task, and a queue that holds
    the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db9a7a3b-2431-4f93-800b-8fa72ef48a5c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows that a pool contains a queue that holds tasks submitted
    by producers. The threads from the pool take tasks from the queue and execute
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coroutines use thread pools under the hood. The `java.util.concurrent` package
    provides the functionality to create your own thread pools. The `Executers` class
    contains a lot of static factory functions to create a pool, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/effab500-87c7-40bb-a20d-81aadad70026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example code demonstrates how to create and use a single-threaded
    executor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we instantiated the `executor` variable and used the
    `submit` method to add a task to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at concurrency and the problems that can arise in
    a multithreaded environment. We introduced and looked at the most common examples
    of coroutine usage. We also familiarized ourselves with patterns, such as thread
    pools and callbacks, and how to use them. Furthermore, we covered synchronous
    and asynchronous programming, and the problems related to these topics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at an overview of reactive programming, which
    is useful when we want to process asynchronous actions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a call stack?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a thread pool?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a callback?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are coroutines called lightweight threads?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering High Performance with Kotlin* ([https://www.packtpub.com/application-development/mastering-high-performance-kotlin](https://www.packtpub.com/application-development/mastering-high-performance-kotlin))
    by Igor Kucherenko, published by Packt Publishing.'
  prefs: []
  type: TYPE_NORMAL
