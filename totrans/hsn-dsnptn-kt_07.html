<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Staying Reactive</h1>
                
            
            
                
<p class="calibre2">Once we're familiar with functional programming and its building blocks, we can start discussing reactive programming concepts. While it's not coupled with functional programming (you can be reactive while writing object-oriented or procedural code, too), it's still better to discuss after learning about functional programming and its foundation.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Reactive principles</li>
<li class="calibre12">Reactive extension</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reactive principles</h1>
                
            
            
                
<p class="calibre2">So, what is reactive programming? </p>
<p class="calibre2">It's summarized nicely by the reactive manifesto: <a href="https://www.reactivemanifesto.org" class="calibre10">https://www.reactivemanifesto.org</a>.</p>
<p class="calibre2">To cite it, reactive programs are:</p>
<ul class="calibre11">
<li class="calibre12">Responsive</li>
<li class="calibre12">Resilient</li>
<li class="calibre12">Elastic</li>
<li class="calibre12">Message-driven</li>
</ul>
<p class="calibre2">To understand these four topics, let's imagine 10 people standing in a line for a cashier. Each one of them can see only the person in front, but not how many people are in the line ahead of that person or what the cashier is doing. Do you have this picture in your mind? Let's start then.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Responsiveness</h1>
                
            
            
                
<p class="calibre2">Would you stand in that line for the cashier?</p>
<p class="calibre2">That depends on the urgency and how much time you have. If you're in a hurry, you'll probably leave empty-handed before reaching the cash register. </p>
<p class="calibre2">That's a system being unresponsive to you. You're often in the same situation when reaching a call center of one of the service providers by phone. You're asked to wait on the line, and you wait. But, more often than not, a nice automatic voice tells you how many people are waiting on the same line ahead of you or even how much time you'll have to wait. </p>
<p class="calibre2">In both cases, the result is the same. You've wasted your time waiting in line or on the line. But the second system was responsive to your needs, and you could make decisions based on that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Resiliency</h1>
                
            
            
                
<p class="calibre2">Let's continue to resiliency. You're waiting on the line for 10 minutes, then the line drops. Or, you reached one of the customer care representatives, but they hang up on you by mistake. How often does that happen? That's the system not being resilient to failures. Or, you've waited in line for half an hour to see a doctor, when they suddenly leave the office and go to a golf club, asking you to come back tomorrow. That's a system that wasn't responsive in the face of failure. </p>
<p class="calibre2">The reactive manifesto discusses various ways to achieve resiliency:</p>
<ul class="calibre11">
<li class="calibre12">Delegation</li>
<li class="calibre12">Replication</li>
<li class="calibre12">Containment</li>
<li class="calibre12">Isolation</li>
</ul>
<p class="calibre2">Delegation is when the doctor comes out of their office and tells you, <em class="calibre14">I can't see you</em> <em class="calibre14">today, but knock on the other door; they'll see to you soon</em>.</p>
<p class="calibre2">Replication is for a clinic to always have two doctors available, just in the event that one of them miss their favorite team playing this evening. It relates to elasticity, which we'll discuss in the next section.</p>
<p class="calibre2">Containment and isolation are usually discussed together. What if you actually don't need to see the doctor? Maybe you only need a prescription from them. Then, you could leave them a message (we'll discuss message-passing soon, as it's also an important part of reactiveness) and they'll send you a recipe when they're between games. You decoupled yourself from seeing a doctor. It also provided you with isolation from the doctors' failures or problems. What you didn't know is that, while printing your recipe, their computer crashed twice and they were really stressed about that. But because you weren't in front of them, they kept that to themselves.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Elasticity</h1>
                
            
            
                
<p class="calibre2">So, in the previous section, we discussed replication. To prevent failures, our clinic always has two doctors available. Maybe the second doctor served some patients, or maybe they were just patiently waiting for the first doctor to leave for their football game to start working.</p>
<p class="calibre2">But, what would happen to that resilient system if suddenly there is a flu epidemic or a band of rabid squirrels starts attacking citizens in the nearby park? Two doctors won't be able to handle all of the patients and then, again, we have a problem with resiliency. </p>
<p class="calibre2">But what if we had a supply of retired doctors sitting in their homes playing mahjong? Certainly, we could call them to come and help bandage all of those squirrel victims. And after they were all properly treated, the doctors could return to their mahjong.</p>
<p class="calibre2">That's a system being elastic depending on the workload. </p>
<p class="calibre2">Elasticity builds on scalability. We could treat all of those patients because each doctor could work independently. But what if all of the bandages were stored in a single box? Then it would create a bottleneck, with all of those doctors standing around waiting for the next pack of bandages. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Message-driven</h1>
                
            
            
                
<p class="calibre2">This is also referred to as <em class="calibre14">asynchronous message passing</em>. So, we saw in the <em class="calibre14">Resiliency</em> section that if you could leave a message for the doctor, it may make the system more resilient.</p>
<p class="calibre2">What if all of the patients would only leave messages? Then each doctor could prioritize them or batch-process those messages. For example, printing all recipes together, instead of switching between different tasks.</p>
<p class="calibre2">In addition to loose coupling and isolation, there's also <em class="calibre14">location transparency</em>. You didn't know tha your doctor sent you this prescription while driving home (they snuck out of the window while you left your message). But you don't care since you got what you wanted.</p>
<p class="calibre2">Using messages also allows an interesting option of <em class="calibre14">backpressure</em>. If your doctor receives too many messages, they may collapse from stress. To avoid that, they may text you to say that you'll have to wait a bit longer to receive your prescription. Or, if they have a secretary, we may even ask them to do that anyway. Again, we're talking about delegation here, as all of those principles are correlated. </p>
<p class="calibre2">Messages are also non-blocking. After you leave the message, you don't sit there waiting for the doctor's response. You usually go back home, to your regular tasks. The ability to perform other tasks while you wait is one of the cornerstones of concurrency.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reactive extension</h1>
                
            
            
                
<p class="calibre2">The rest of this chapter will be dedicated to the specific implementation of reactive principles in Kotlin. The predominant library in this field is RxJava. Since Kotlin is fully interoperable with Java libraries, RxKotlin is only a thin wrapper over the original RxJava. Hence, we'll discuss it as if these are one and the same library, and highlight the differences, if any.</p>
<p class="calibre2">As soon as we start talking about RxJava, you'll recognize it's built upon the <strong class="calibre5">Observer</strong> design pattern we discussed in <a href="part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 4</a>, <em class="calibre14">Getting Familiar with Behavioral Patterns</em>. </p>
<p class="calibre2">We'll start by adding the following dependency to our Gradle project:</p>
<pre class="calibre18">compile "io.reactivex.rxjava2:rxjava:2.1.14"</pre>
<p class="calibre2">Currently, this is the latest version of RxJava2, but when you read this chapter, there will probably ba a more recent version already. Feel free to use it.</p>
<p class="calibre2">You may remember that the pattern consists of two objects:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">publisher</kbd>: Produces data</li>
<li class="calibre12"><kbd class="calibre13">subscriber</kbd>: Consumes data</li>
</ul>
<p class="calibre2">In RxJava, publishers are called <kbd class="calibre13">Observable</kbd>.</p>
<p class="calibre2">The following code will create our first publisher:</p>
<pre class="calibre18">val publisher = Observable.fromArray(5, 6, 7)</pre>
<p class="calibre2">To start consuming those numbers, we can supply a lambda to the <kbd class="calibre13">subscribe()</kbd> function:</p>
<pre class="calibre18">publisher.subscribe {<br class="title-page-name"/>    println(it)<br class="title-page-name"/>} // Prints 1, 2, 3</pre>
<p class="calibre2">There are other functions available on <kbd class="calibre13">Observable</kbd> that you'll immediately recognize: <kbd class="calibre13">map()</kbd> and <kbd class="calibre13">filter()</kbd>, for example. Those are the same functions that are available on regular arrays in Kotlin:</p>
<pre class="calibre18">publisher.filter {<br class="title-page-name"/>    it &gt; 5<br class="title-page-name"/>}.map {<br class="title-page-name"/>    it + it<br class="title-page-name"/>}.subscribe {<br class="title-page-name"/>    println(it)<br class="title-page-name"/>}</pre>
<p class="calibre2">OK, this is nice, but we've already discussed collections and streams in sequences in the previous chapter. Why do it again? </p>
<p class="calibre2">Let's look at the following example:</p>
<pre class="calibre18">val publisher = Observable.interval(1, TimeUnit.SECONDS)<br class="title-page-name"/><br class="title-page-name"/>publisher.subscribe {<br class="title-page-name"/>    println("P1 $it")<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>publisher.subscribe {<br class="title-page-name"/>    println("P2 $it")<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(TimeUnit.SECONDS.toMillis(5))</pre>
<p class="calibre2">This code will wait for five milliseconds before terminating and it will print the following:</p>
<pre class="calibre18"><strong class="calibre1">Sleeping &lt;= This was the last line in our code, actually</strong><br class="title-page-name"/><strong class="calibre1">P2 0     &lt;= P2 came after P1 in code, but it comes before now</strong><br class="title-page-name"/><strong class="calibre1">P1 0</strong><br class="title-page-name"/><strong class="calibre1">P2 1</strong><br class="title-page-name"/><strong class="calibre1">P1 1</strong><br class="title-page-name"/><strong class="calibre1">P2 2</strong><br class="title-page-name"/><strong class="calibre1">P1 2</strong></pre>
<p class="calibre2">This is unexpected. <kbd class="calibre13">Sleeping</kbd> was the last line in the code, but it's printed first. Then notice that <kbd class="calibre13">P2</kbd> is printed before <kbd class="calibre13">P1</kbd> sometimes if you run this example more than once. And sometimes, it's <kbd class="calibre13">P1</kbd> before <kbd class="calibre13">P2</kbd>, much like in the code. What's going on here?</p>
<p class="calibre2">That's asynchronicity in action. We need <kbd class="calibre13">Thread.sleep()</kbd> here to allow our listeners to run for some time, otherwise, our program would terminate. And when they're called, it doesn't matter where in the actual code they were placed. </p>
<p>In this chapter, we'll use <kbd class="calibre20">Thread.sleep()</kbd> and <kbd class="calibre20">CountDownLatch</kbd> a lot to demonstrate how asynchronism works. In a real-life application, you should never use <kbd class="calibre20">Thread.sleep</kbd>. If you're still not familiar with <kbd class="calibre20">CountDownLatch,</kbd> don't worry, we'll explain how it works the first time we stumble upon it, in the <em class="calibre22">Flowables</em> section.</p>
<p class="calibre2">Well, that's how the Observer design pattern behaves, naturally. But with Observer, there's also an option to unsubscribe. How do we achieve it here?</p>
<p class="calibre2">Let's replace the second listener with the following code:</p>
<pre class="calibre18">...<br class="title-page-name"/>val subscription = publisher.subscribe {<br class="title-page-name"/>    println("P2 $it")<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>println("Sleeping")<br class="title-page-name"/>Thread.sleep(TimeUnit.SECONDS.toMillis(2))<br class="title-page-name"/>subscription.dispose()<br class="title-page-name"/>...</pre>
<p class="calibre2">A call to <kbd class="calibre13">subscribe()</kbd> returns a <kbd class="calibre13">Disposable</kbd>. When you no longer want to receive updates, you can call <kbd class="calibre13">dispose()</kbd> on it, which is synonymous with <em class="calibre14">unsubscribe</em>.</p>
<p class="calibre2">Your output may look like this:</p>
<pre class="calibre18"><strong class="calibre1">Sleeping</strong><br class="title-page-name"/><strong class="calibre1">P1 0        &lt;= Notice that P1 is the first one now</strong><br class="title-page-name"/><strong class="calibre1">P2 0</strong><br class="title-page-name"/><strong class="calibre1">P1 1</strong><br class="title-page-name"/><strong class="calibre1">Sleeping    &lt;= This is after dispose/unsubscribe</strong><br class="title-page-name"/><strong class="calibre1">P2 1        &lt;= But it may still take some time, so P2 prints again</strong><br class="title-page-name"/><strong class="calibre1">P1 2       </strong><br class="title-page-name"/><strong class="calibre1">P1 3</strong><br class="title-page-name"/><strong class="calibre1">P1 4        &lt;= No more prints from P2, it unsubscribed</strong></pre>
<p class="calibre2">What if we were to create our own <kbd class="calibre13">Observable</kbd>, with its own specific logic? There's a <kbd class="calibre13">create()</kbd> method for that:</p>
<pre class="calibre18">val o = Observable.create&lt;Int&gt; {<br class="title-page-name"/>    for (i in 1..10_000) {<br class="title-page-name"/>        it.<strong class="calibre1">onNext</strong>(i)<br class="title-page-name"/>    }<br class="title-page-name"/>    it.<strong class="calibre1">onComplete</strong>()<br class="title-page-name"/>}</pre>
<p class="calibre2">We create an <kbd class="calibre13">Observable</kbd> that publishes numbers. To push a new value to all listeners, we use the <kbd class="calibre13">onNext()</kbd> method. We notify the listeners that there's no more data with <kbd class="calibre13">onComplete()</kbd>. Finally, if an error occurrs, we can call <kbd class="calibre13">onError()</kbd>, supplying the exception as an argument. </p>
<p class="calibre2">You'll notice that if we try to actually call <kbd class="calibre13">onError()</kbd>, we'll get an exception:</p>
<pre class="calibre18">val o = Observable.create&lt;Int&gt; {<br class="title-page-name"/>    it.onError(RuntimeException())<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>o.subscribe {<br class="title-page-name"/>    println("All went good: $it")<br class="title-page-name"/>} // OnErrorNotImplementedException</pre>
<p class="calibre2">That's because we use the shorthand form with the lambda listener. </p>
<p class="calibre2">If we want to handle errors correctly, we also need to supply <em class="calibre14">error handler</em> as a second argument:</p>
<pre class="calibre18">o.subscribe({<br class="title-page-name"/>    println("All went good: $it")<br class="title-page-name"/>}, {<br class="title-page-name"/>    <strong class="calibre1">println("The</strong><strong class="calibre1">re</strong><strong class="calibre1"> was</strong><strong class="calibre1"> an</strong><strong class="calibre1"> error</strong><strong class="calibre1"> $</strong><strong class="calibre1">it")</strong><br class="title-page-name"/>})</pre>
<p class="calibre2">There's also a third parameter, which is the <kbd class="calibre13">onComplete</kbd> handler:</p>
<pre class="calibre18">o.subscribe({<br class="title-page-name"/>    println("All went good: $it")<br class="title-page-name"/>}, {<br class="title-page-name"/>    println("There was an error $it")<br class="title-page-name"/>}, {<br class="title-page-name"/>    <strong class="calibre1">println("Publisher closed the stream"</strong><strong class="calibre1">)</strong><br class="title-page-name"/>})</pre>
<p>In our examples, we'll rarely use error handlers since our code is very basic. But you should always provide them in real applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Hot Observable</h1>
                
            
            
                
<p class="calibre2">Hot <kbd class="calibre13">Observable</kbd> is a term we'll use a lot in this chapter, as opposed to cold <kbd class="calibre13">Observable</kbd>. All Observable we discussed before was cold. That meant they knew everything that happened from the beginning of time, and each time somebody asked them politely, they could repeat the whole history. Hot <kbd class="calibre13">Observable</kbd> only know what happens now. Think of the weather forecast and weather history, for example. The weather forecast is hot—you'll get the current weather, let's say every minute. The weather history is cold–you can get the whole history of weather changes, if you care about it. If you still don't get this concept, don't worry too much. We have half of the chapter ahead of us to cover it.</p>
<p class="calibre2">As you've probably noticed, up until now, all of our subscribers always got all the data, no matter when they subscribed:</p>
<pre class="calibre18">publisher.subscribe {<br class="title-page-name"/>    println("S1 $it")<br class="title-page-name"/>} // Prints 10K times<br class="title-page-name"/><br class="title-page-name"/>publisher.subscribe {<br class="title-page-name"/>    println("S2 $it")<br class="title-page-name"/>} // Also prints 10K times</pre>
<p class="calibre2">But that's not always the case. More often, we have the data source coming from outside and not created each time by the <kbd class="calibre13">publisher</kbd>:</p>
<pre class="calibre18">val iterator = (1..10).iterator()<br class="title-page-name"/><br class="title-page-name"/>val publisher = Observable.create&lt;Int&gt; {<br class="title-page-name"/>    while (iterator.hasNext()) {<br class="title-page-name"/>        val nextNumber = iterator.next()<br class="title-page-name"/>        it.onNext(nextNumber)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Here, instead of creating the list inside, we have a reference to its iterator.</p>
<p class="calibre2">Let's see how the following code behaves now:</p>
<pre class="calibre18">publisher.subscribeOn(Schedulers.newThread()).subscribe {<br class="title-page-name"/>    println("S1: $it")<br class="title-page-name"/>    Thread.sleep(10)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(50)<br class="title-page-name"/><br class="title-page-name"/>publisher.subscribeOn(Schedulers.newThread()).subscribe {<br class="title-page-name"/>    println("S2: $it")<br class="title-page-name"/>    Thread.sleep(10)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(50)</pre>
<p class="calibre2">We have two subscribers, as before. Up until now, all subscribers executed on the same thread we were running. For this example, we assigned them a separate thread each. That would allow us to simulate operations that are running for some time: 10 ms, in this case. To specify on which thread subscriber should run, we use <kbd class="calibre13">subscribeOn()</kbd>. <kbd class="calibre13">Schedulers</kbd> is an utility class, much like <kbd class="calibre13">Executors</kbd> from Java 5. In this case, it will assign a new thread for each listener.</p>
<p class="calibre2">The output may look something like this:</p>
<pre class="calibre18"><strong class="calibre1">S1: 1</strong><br class="title-page-name"/><strong class="calibre1">S1: 2</strong><br class="title-page-name"/><strong class="calibre1">S1: 3</strong><br class="title-page-name"/><strong class="calibre1">S1: 4</strong><br class="title-page-name"/><strong class="calibre1">S1: 5</strong><br class="title-page-name"/><strong class="calibre1">S2: 6 &lt;= That's where "Subscriber 2" begins listening</strong><br class="title-page-name"/><strong class="calibre1">S1: 7</strong><br class="title-page-name"/><strong class="calibre1">S2: 8</strong><br class="title-page-name"/><strong class="calibre1">S1: 9</strong><br class="title-page-name"/><strong class="calibre1">S2: 10</strong></pre>
<p class="calibre2">Notice that if every consumer received all the data previously, now the second subscriber will never receive numbers 1-5.</p>
<p class="calibre2">After the second subscriber is connected, only one of them will receive the data each time. </p>
<p class="calibre2">What if we want to publish data to all of the subscribers simultaneously?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Multicast</h1>
                
            
            
                
<p class="calibre2">There's a <kbd class="calibre13">publish()</kbd> method for that:</p>
<pre class="calibre18">val iterator = (1..5).iterator()<br class="title-page-name"/>val subject = Observable.create&lt;Int&gt; {<br class="title-page-name"/>    while (iterator.hasNext()) {<br class="title-page-name"/>        val number = iterator.nextInt()<br class="title-page-name"/>        println("P: $number")<br class="title-page-name"/>        it.onNext(number)<br class="title-page-name"/>        Thread.sleep(10)<br class="title-page-name"/>    }<br class="title-page-name"/>}.observeOn(Schedulers.newThread()).publish()</pre>
<p class="calibre2">We again create a somewhat <em class="calibre14">hot</em> <kbd class="calibre13">Observable</kbd>, but this time we specify that it will run on a separate thread with <kbd class="calibre13">observeOn()</kbd>. We also use the <kbd class="calibre13">publish()</kbd> method, which turns our <kbd class="calibre13">Observable</kbd> into <kbd class="calibre13">ConnectableObservable</kbd>. </p>
<p class="calibre2">If we simply subscribe to this type of <kbd class="calibre13">Observable</kbd>, nothing will happen. We need to tell it when to start running. We use that with the <kbd class="calibre13">connect()</kbd> method. Since the <kbd class="calibre13">connect()</kbd> method is blocking, we'll execute it from a separate thread for this example:</p>
<pre class="calibre18">thread { // Connect is blocking, so we run in on another thread<br class="title-page-name"/>    subject.connect() // Tells observer when to start<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we'll let publisher work for a few milliseconds, then connect our first listener:</p>
<pre class="calibre18">Thread.sleep(10)<br class="title-page-name"/>println("S1 Subscribes")<br class="title-page-name"/>subject.subscribeOn(Schedulers.newThread()).subscribe {<br class="title-page-name"/>    println("S1: $it")<br class="title-page-name"/>    Thread.sleep(100)<br class="title-page-name"/>}<br class="title-page-name"/></pre>
<p class="calibre2">After some more time, we connect a second listener, and allow them to finish:</p>
<pre class="calibre18">Thread.sleep(20)<br class="title-page-name"/><br class="title-page-name"/>println("S2 Subscribes")<br class="title-page-name"/>subject.subscribeOn(Schedulers.newThread()).subscribe {<br class="title-page-name"/>    println("S2: $it")<br class="title-page-name"/>    Thread.sleep(100)<br class="title-page-name"/>}<br class="title-page-name"/>Thread.sleep(2000)</pre>
<p class="calibre2">Let's see the output now, as it's quite interesting:</p>
<pre class="calibre18"><strong class="calibre1">P: 1 <em class="calibre25">&lt;= Publisher starts publishing even before someone subscribes</em></strong><br class="title-page-name"/><strong class="calibre1"><em class="calibre25">S1 Subscribes</em></strong><br class="title-page-name"/><strong class="calibre1">P: 2</strong><br class="title-page-name"/><strong class="calibre1">P: 3</strong><br class="title-page-name"/><strong class="calibre1">S1: 3 <em class="calibre25">&lt;= Subscriber actually missed some values</em></strong><br class="title-page-name"/><strong class="calibre1"><em class="calibre25">S2 Subscribes</em></strong><br class="title-page-name"/><strong class="calibre1">P: 4</strong><br class="title-page-name"/><strong class="calibre1">P: 5</strong><br class="title-page-name"/><strong class="calibre1">P: 6 <em class="calibre25">&lt;= Publisher completes here</em></strong><br class="title-page-name"/><strong class="calibre1">S1: 4</strong><br class="title-page-name"/><strong class="calibre1">S2: 4 </strong><br class="title-page-name"/><strong class="calibre1">S1: 5</strong><br class="title-page-name"/><strong class="calibre1">S2: 5 <em class="calibre25">&lt;= Both subscribers receive same values</em></strong></pre>
<p class="calibre2">Of course, having this <kbd class="calibre13">connect()</kbd> is not always comfortable.</p>
<p class="calibre2">For that reason, we have a method called <kbd class="calibre13">refCount()</kbd>, which turns our <kbd class="calibre13">ConnectableObservable</kbd> back into a regular <kbd class="calibre13">Observable</kbd>. It will keep a reference count of the subscribers, and dispose of the subscriptions only after all subscribers have done so, too:</p>
<pre class="calibre18">// This is a connectable Observable<br class="title-page-name"/>val connectableSource = Observable.fromIterable((1..3)).publish()<br class="title-page-name"/><br class="title-page-name"/>// Should call connect() on it<br class="title-page-name"/>dataSource.connect()<br class="title-page-name"/><br class="title-page-name"/>// This is regular Observable which wraps ConnectableObservable<br class="title-page-name"/>val regularSource = connectableSource.refCount()<br class="title-page-name"/><br class="title-page-name"/>regularSource.connect() // Doesn't compile</pre>
<p class="calibre2">And if calling <kbd class="calibre13">publish().refCount()</kbd> is too cumbersome, there's also the <kbd class="calibre13">share()</kbd> method that does exactly that:</p>
<pre class="calibre18">val regularSource = Observable.fromIterable((1..3)).publish().refCount()<br class="title-page-name"/><br class="title-page-name"/>val stillRegular = Observable.fromIterable((1..3))<strong class="calibre1">.share()</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Subject</h1>
                
            
            
                
<p class="calibre2">The easiest way to understand <kbd class="calibre13">Subject</kbd> is that <kbd class="calibre13">Subject = Observable + Observer</kbd>.</p>
<p class="calibre2">On the one hand, it allows others to <kbd class="calibre13">subscribe()</kbd> to it. On the other, it can <kbd class="calibre13">subscribe</kbd> to other <kbd class="calibre13">Observable</kbd>:</p>
<pre class="calibre18">val dataSource = Observable.fromIterable((1..3))<br class="title-page-name"/><br class="title-page-name"/>val multicast = PublishSubject.create&lt;Int&gt;()<br class="title-page-name"/><br class="title-page-name"/>multicast.subscribe {<br class="title-page-name"/>    println("S1 $it")<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>multicast.subscribe {<br class="title-page-name"/>    println("S2 $it")<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>dataSource.subscribe(multicast)<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(1000)</pre>
<p class="calibre2">The following code prints six lines, three for each subscriber:</p>
<pre class="calibre18"><strong class="calibre1">S1 1</strong><br class="title-page-name"/><strong class="calibre1">S2 1</strong><br class="title-page-name"/><strong class="calibre1">S1 2</strong><br class="title-page-name"/><strong class="calibre1">S2 2</strong><br class="title-page-name"/><strong class="calibre1">S1 3</strong><br class="title-page-name"/><strong class="calibre1">S2 3</strong></pre>
<p class="calibre2">Note that we didn't use <kbd class="calibre13">publish()</kbd> on our <kbd class="calibre13">dataSource</kbd>, so it's cold. Cold means that each time somebody subscribes to this source, it will begin sending data anew. The hot <kbd class="calibre13">Observable</kbd>, on the other hand, doesn't have all the data, and will only send what it has from this moment on.</p>
<p class="calibre2">For that reason, we need to first connect all the listeners, and only then begin to listen to the <kbd class="calibre13">dataSource</kbd>.</p>
<p class="calibre2">If we're using a hot <kbd class="calibre13">dataSource</kbd>, we can switch the calls:</p>
<pre class="calibre18">val dataSource = Observable.fromIterable((1..3))<strong class="calibre1">.publish()</strong><br class="title-page-name"/><br class="title-page-name"/>val multicast = PublishSubject.create&lt;Int&gt;()<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">dataSource.subscribe(multicast)</strong><br class="title-page-name"/><br class="title-page-name"/>multicast.subscribe {<br class="title-page-name"/>    println("S1 $it")<br class="title-page-name"/>}<br class="title-page-name"/>println("S1 subscribed")<br class="title-page-name"/><br class="title-page-name"/>multicast.subscribe {<br class="title-page-name"/>    println("S2 $it")<br class="title-page-name"/>}<br class="title-page-name"/>println("S2 subscribed")<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">dataSource.connect()</strong><br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(1000)</pre>
<p class="calibre2">As in the previous section, we use <kbd class="calibre13">connect()</kbd> to tell <kbd class="calibre13">dataSource</kbd> when to start emitting data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">ReplaySubject</h1>
                
            
            
                
<p class="calibre2">In addition to <kbd class="calibre13">PublishSubject</kbd>, which we discussed in the previous section, there are other subjects available. To understand how <kbd class="calibre13">ReplaySubject</kbd> works, let's see first the following example with <kbd class="calibre13">PublishSubject</kbd>:</p>
<pre class="calibre18">val list = (8..23).toList() // Some non trivial numbers<br class="title-page-name"/>val iterator = list.iterator()<br class="title-page-name"/>val o = Observable.intervalRange(0, list.size.toLong(), 0, 10, TimeUnit.MILLISECONDS).map {<br class="title-page-name"/>    iterator.next()<br class="title-page-name"/>}.publish()<br class="title-page-name"/><br class="title-page-name"/>val subject = PublishSubject.create&lt;Int&gt;()<br class="title-page-name"/><br class="title-page-name"/>o.subscribe(subject)<br class="title-page-name"/><br class="title-page-name"/>o.connect() // Start publishing<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(20)<br class="title-page-name"/><br class="title-page-name"/>println("S1 subscribes")<br class="title-page-name"/>    subject.subscribe {<br class="title-page-name"/>        println("S1 $it")<br class="title-page-name"/>    }<br class="title-page-name"/>    println("S1 subscribed")<br class="title-page-name"/><br class="title-page-name"/>    Thread.sleep(10)<br class="title-page-name"/><br class="title-page-name"/>    println("S2 subscribes")<br class="title-page-name"/>    subject.subscribe {<br class="title-page-name"/>        println("S2 $it")<br class="title-page-name"/>    }<br class="title-page-name"/>    println("S2 subscribed")<br class="title-page-name"/><br class="title-page-name"/>    Thread.sleep(1000)</pre>
<p class="calibre2">This prints the following:</p>
<pre class="calibre18"><strong class="calibre1">S1 11 &lt;= Lost 8, 9, 10</strong><br class="title-page-name"/><strong class="calibre1">S1 12</strong><br class="title-page-name"/><strong class="calibre1">S2 12 &lt;= Lost also 11</strong><br class="title-page-name"/><strong class="calibre1">S1 13</strong><br class="title-page-name"/><strong class="calibre1">S2 13</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">Clearly, some events are lost for good.</p>
<p class="calibre2">Now, let's replace <kbd class="calibre13">PublishSubject</kbd> with <kbd class="calibre13">ReplaySubject</kbd> and examine the output:</p>
<pre class="calibre18">val subject = ReplaySubject.create&lt;Int&gt;()</pre>
<p class="calibre2">The following output will be printed:</p>
<pre class="calibre18"><strong class="calibre1">S1 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S1 8</strong><br class="title-page-name"/><strong class="calibre1">S1 9</strong><br class="title-page-name"/><strong class="calibre1">S1 10 &lt;= S1 catchup </strong><br class="title-page-name"/><strong class="calibre1">S1 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 11</strong><br class="title-page-name"/><strong class="calibre1">S1 12</strong><br class="title-page-name"/><strong class="calibre1">S2 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S2 8</strong><br class="title-page-name"/><strong class="calibre1">S2 9</strong><br class="title-page-name"/><strong class="calibre1">S2 10</strong><br class="title-page-name"/><strong class="calibre1">S2 11</strong><br class="title-page-name"/><strong class="calibre1">S2 12 &lt;= S2 catchup </strong><br class="title-page-name"/><strong class="calibre1">S2 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 13 &lt;= Regular multicast from here</strong><br class="title-page-name"/><strong class="calibre1">S2 13</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">With <kbd class="calibre13">ReplaySubject</kbd>, no events are lost. You can see from the output, though, that until some point, events aren't multicast, even when there is more than one <kbd class="calibre13">subscriber</kbd>. Instead, for each <kbd class="calibre13">subscriber</kbd>, <kbd class="calibre13">ReplaySubject</kbd> performs a kind of catch-up of what it missed until now.</p>
<p class="calibre2">The benefits of this approach are clear. We converted what seems to be a <em class="calibre14">hot</em> <kbd class="calibre13">Observable</kbd> into something quite <em class="calibre14">cold</em>. But there are also limitations. By using <kbd class="calibre13">ReplaySubject.create</kbd>, we produce an unbounded subject. If it tries to record too many events, we will simply run out of memory. To avoid that, we can use the <kbd class="calibre13">createWithSize()</kbd> method:</p>
<pre class="calibre18">val subject = ReplaySubject.createWithSize&lt;Int&gt;(2)</pre>
<p class="calibre2">It creates the following output:</p>
<pre class="calibre18"><strong class="calibre1">S1 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S1 9 &lt;= lost 8</strong><br class="title-page-name"/><strong class="calibre1">S1 10</strong><br class="title-page-name"/><strong class="calibre1">S1 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 11</strong><br class="title-page-name"/><strong class="calibre1">S2 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S1 12</strong><br class="title-page-name"/><strong class="calibre1">S2 11 &lt;= lost 8, 9, 10</strong><br class="title-page-name"/><strong class="calibre1">S2 12</strong><br class="title-page-name"/><strong class="calibre1">S2 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 13</strong><br class="title-page-name"/><strong class="calibre1">S2 13</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">As you can see, now our subject remembers fewer items, so the earliest events are lost.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">BehaviorSubject</h1>
                
            
            
                
<p class="calibre2">Imagine a situation when you have a stream of updates every minute. You want to display the latest value you received, then keep updating it when new data comes in. You can use <kbd class="calibre13">ReplaySubject</kbd> with a size of one. But there's also <kbd class="calibre13">BehaviorSubject</kbd> exactly for this case:</p>
<pre class="calibre18">val subject = BehaviorSubject.create&lt;Int&gt;()</pre>
<p class="calibre2">The output will be as follows:</p>
<pre class="calibre18"><strong class="calibre1">S1 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S1 10 &lt;= This was the most recent value, 8 and 9 are lost</strong><br class="title-page-name"/><strong class="calibre1">S1 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 11 &lt;= First update </strong><br class="title-page-name"/><strong class="calibre1">S2 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S2 11 &lt;= This was most recent value, 8, 9 and 10 lost</strong><br class="title-page-name"/><strong class="calibre1">S2 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 12 &lt;= As usual from here</strong><br class="title-page-name"/><strong class="calibre1">S2 12</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">AsyncSubject</h1>
                
            
            
                
<p class="calibre2">This is a strange <kbd class="calibre13">subject</kbd> since, unlike the others, it doesn't update its subscribers. So, what is it good for?</p>
<p class="calibre2">What if you wanted to have a very basic functionality, simply updating a screen with the latest value and never refreshing it again until the screen is closed:</p>
<pre class="calibre18">val subject = AsyncSubject.create&lt;Int&gt;()</pre>
<p class="calibre2">Here is the output:</p>
<pre class="calibre18"><strong class="calibre1">S1 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S1 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S2 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S2 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 23 &lt;= This is the final value</strong><br class="title-page-name"/><strong class="calibre1">S2 23</strong></pre>
<p class="calibre2">Be careful, though. Since <kbd class="calibre13">AsyncSubject</kbd> waits for the sequence to complete, if the sequence is infinite, it will never call its subscribers:</p>
<pre class="calibre18">// Infinite sequence of 1<br class="title-page-name"/>val o = Observable.generate&lt;Int&gt; { 1 }.publish()<br class="title-page-name"/>...<br class="title-page-name"/>o.connect() // Hangs here forever</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">SerializedSubject</h1>
                
            
            
                
<p class="calibre2">It's important not to call the <kbd class="calibre13">onNext()</kbd>/<kbd class="calibre13">onComplete()</kbd>/<kbd class="calibre13">onError()</kbd> methods from different threads, as it will make the calls non-serializable.</p>
<p class="calibre2">This is a <strong class="calibre5">Proxy</strong> of sorts around any regular <kbd class="calibre13">subject</kbd>, which synchronizes calls to the unsafe methods. You can wrap any <kbd class="calibre13">subject</kbd> with <kbd class="calibre13">SerializedSubject</kbd> using the <kbd class="calibre13">toSerialized()</kbd> method:</p>
<pre class="calibre18">val subject = ReplaySubject.createWithSize&lt;Int&gt;(2).toSerialized()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Flowables</h1>
                
            
            
                
<p class="calibre2">In all previous examples, we emitted data using <kbd class="calibre13">Observable</kbd> or <kbd class="calibre13">subject</kbd>, which also extends <kbd class="calibre13">Observable</kbd>, and it worked out pretty well. </p>
<p class="calibre2">But our listeners weren't doing much. What if they were to do something more substantial?</p>
<p class="calibre2">Let's see the following example. We'll produce a lot of unique strings:</p>
<pre class="calibre18">val source = Observable.create&lt;String&gt; {<br class="title-page-name"/>    var startProducing = System.currentTimeMillis()<br class="title-page-name"/>    for (i in 1..10_000_000) {<br class="title-page-name"/>        it.onNext(UUID.randomUUID().toString())<br class="title-page-name"/><br class="title-page-name"/>        if (i % 100_000 == 0) {<br class="title-page-name"/>            println("Produced $i events in ${System.currentTimeMillis() - startProducing}ms")<br class="title-page-name"/>            startProducing = System.currentTimeMillis()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    latch.countDown()<br class="title-page-name"/>}</pre>
<p class="calibre2">We're using <kbd class="calibre13">CountDownLatch</kbd> so the main thread will be able to wait until we finish. In addition, we're also printing how much time it took to emit 100,000 events. This will be useful later.</p>
<p class="calibre2">In the <kbd class="calibre13">subscribe()</kbd> method, we would repeat those strings 1,000 times:</p>
<pre class="calibre18">val counter = AtomicInteger(0)<br class="title-page-name"/>source.observeOn(Schedulers.newThread())<br class="title-page-name"/>        .subscribe( {<br class="title-page-name"/>            it.repeat(500)<br class="title-page-name"/>            if (counter.incrementAndGet() % 100_000 == 0) {<br class="title-page-name"/>                println("Consumed ${counter.get()} events")<br class="title-page-name"/>            }<br class="title-page-name"/>        }, {<br class="title-page-name"/>            println(it)<br class="title-page-name"/>        })</pre>
<p class="calibre2"><kbd class="calibre13">AtomicInteger</kbd> is used to count the number of processed events in a thread-safe way.</p>
<p class="calibre2">We're obviously consuming more slowly than we're producing:</p>
<pre class="calibre18"><strong class="calibre1">Produced 100000 events in 1116ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 200000 events in 595ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 300000 events in 734ms</strong><br class="title-page-name"/><strong class="calibre1">Consumed 100000 events</strong><br class="title-page-name"/><strong class="calibre1">Produced 400000 events in 815ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 500000 events in 705ms</strong><br class="title-page-name"/><strong class="calibre1">Consumed 200000 events</strong><br class="title-page-name"/><strong class="calibre1">Produced 600000 events in 537ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 700000 events in 390ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 800000 events in 529ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 900000 events in 387ms</strong><br class="title-page-name"/><strong class="calibre1">Consumed 300000 events</strong><br class="title-page-name"/><strong class="calibre1">Produced 1000000 events in 531ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 1100000 events in 537ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 1200000 events in 11241ms &lt;= What happens here?</strong><br class="title-page-name"/><strong class="calibre1">Consumed 400000 events</strong><br class="title-page-name"/><strong class="calibre1">Produced 1300000 events in 19472ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 1400000 events in 31993ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 1500000 events in 52650ms</strong></pre>
<p class="calibre2">But the interesting point is that, after some period, the producing time will increase dramatically. </p>
<p class="calibre2">That's the point when we start to run out of memory. Let's now replace our <kbd class="calibre13">Observable</kbd> with <kbd class="calibre13">Flowable</kbd>:</p>
<pre class="calibre18">val source = Flowable.create&lt;String&gt; ({<br class="title-page-name"/>    var startProducing = System.currentTimeMillis()<br class="title-page-name"/>    for (i in 1..10_000_000) {<br class="title-page-name"/>        it.onNext(UUID.randomUUID().toString())<br class="title-page-name"/><br class="title-page-name"/>        if (i % 100_000 == 0) {<br class="title-page-name"/>            println("Produced $i events in ${System.currentTimeMillis() - startProducing}ms")<br class="title-page-name"/>            startProducing = System.currentTimeMillis()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    it.onComplete()<br class="title-page-name"/>    latch.countDown()<br class="title-page-name"/>}, BackpressureStrategy.DROP)</pre>
<p class="calibre2">As you can see, instead of passing only a lambda, we also pass a second argument, which is <kbd class="calibre13">BackpressureStrategy</kbd>. What happens is that, behind the scenes, <kbd class="calibre13">Flowable</kbd> has a bounded buffer. This is very similar to how we could make <kbd class="calibre13">ReplaySubject</kbd> bounded. The second argument is telling <kbd class="calibre13">Flowable</kbd> what should happen if this buffer limit is reached. In this case, we're asking it to throw away those events.</p>
<p class="calibre2">Now, we should check the final part of our output:</p>
<pre class="calibre18"><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">Produced 9500000 events in 375ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 9600000 events in 344ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 9700000 events in 344ms</strong><br class="title-page-name"/><strong class="calibre1">Consumed 2800000 events</strong><br class="title-page-name"/><strong class="calibre1">Produced 9800000 events in 351ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 9900000 events in 333ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 10000000 events in 340ms</strong></pre>
<p class="calibre2">First, note that we didn't get stuck at any point. Actually, the pace of our production is constant.</p>
<p class="calibre2">Second, you should note that although we <em class="calibre14">produced</em> 10,000,000 events, we <em class="calibre14">consumed</em> only 2.8 million. All other events were dropped. </p>
<p class="calibre2">But we didn't run out of memory, which is the great benefit of <kbd class="calibre13">Flowable</kbd>. </p>
<p class="calibre2">If you do want <kbd class="calibre13">Flowable</kbd> to behave like <kbd class="calibre13">Observable</kbd>, you can specify <kbd class="calibre13">BackpressureStrategy.BUFFER</kbd>, and see that it begins to stutter around the same lines.</p>
<p class="calibre2">As a general guideline, use <kbd class="calibre13">Flowable</kbd> when as follows:</p>
<ul class="calibre11">
<li class="calibre12">You plan to emit more than 1,000 items (some may say 10,000)</li>
<li class="calibre12">You're reading a file</li>
<li class="calibre12">You're querying a database</li>
<li class="calibre12">You have some network streaming to do</li>
</ul>
<p class="calibre2">Use <kbd class="calibre13">Observable</kbd> as follows:</p>
<ul class="calibre11">
<li class="calibre12">You have a limited amount of data you plan to emit.</li>
<li class="calibre12">You deal with user input. Humans aren't as quick as they think they are and don't produce many events.</li>
<li class="calibre12">You care about the performance of the flow: <kbd class="calibre13">Observable</kbd> are simpler, thus faster.</li>
</ul>
<p class="calibre2">When we used the lambda expression, we didn't notice much difference between <kbd class="calibre13">Flowable</kbd> and <kbd class="calibre13">Observable</kbd>. </p>
<p class="calibre2">Instead, now we'll replace it with an anonymous class and see what benefits this approach provides:</p>
<pre class="calibre18">source.observeOn(Schedulers.newThread())<br class="title-page-name"/>        .subscribe(object : Subscriber&lt;String&gt; {<br class="title-page-name"/>    lateinit var subscription: Subscription<br class="title-page-name"/><br class="title-page-name"/>    override fun onSubscribe(s: Subscription?) {<br class="title-page-name"/>        s?.let {<br class="title-page-name"/>            this.subscription = it<br class="title-page-name"/>        } ?: throw RuntimeException()<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun onNext(t: String?) {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun onError(t: Throwable?) {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    override fun onComplete() {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/>})</pre>
<p class="calibre2">That's obviously a lot more code. We need to implement four methods now. </p>
<p class="calibre2">What interests us the most is the <kbd class="calibre13">onSubscribe()</kbd> method. Here, we receive a new object called <kbd class="calibre13">Subscription</kbd> and store it in a property.</p>
<p class="calibre2">For now, we'll drop the fancy code that we were using in our listener before, and simply print every new string we receive:</p>
<pre class="calibre18">override fun onNext(t: String?) {<br class="title-page-name"/>    println(t)<br class="title-page-name"/>}</pre>
<p class="calibre2">Huh? That's strange. Our listener doesn't print anything.</p>
<p class="calibre2">Let's go to our <kbd class="calibre13">onSubscribe</kbd> and modify it a bit:</p>
<pre class="calibre18">override fun onSubscribe(s: Subscription) {<br class="title-page-name"/>    this.subscription = s<br class="title-page-name"/>    <strong class="calibre1">this.subscription.request(100)</strong><br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre13">Subscription</kbd> has a method called <kbd class="calibre13">request()</kbd>, which receives the number of items we're willing to take.</p>
<p class="calibre2">You can run the code again to see that now our subscriber prints the first 100 strings, then goes silent again. </p>
<p class="calibre2">We've already discussed the <kbd class="calibre13">BackpressureStrategy.DROP</kbd> and <kbd class="calibre13">BackpressureStrategy.BUFFER</kbd> strategies. Let's now focus on the <kbd class="calibre13">BackpressureStrategy.MISSING</kbd> strategy. The name is a bit confusing; <em class="calibre14">custom</em> would be better. We'll see why in a moment:</p>
<pre class="calibre18">val source = Flowable.create&lt;String&gt; ({<br class="title-page-name"/>    ...<br class="title-page-name"/>}, BackpressureStrategy.MISSING)</pre>
<p class="calibre2">And we'll go back to <kbd class="calibre13">onNext()</kbd>, which actually does something:</p>
<pre class="calibre18">override fun onNext(t: String) {<br class="title-page-name"/>    t.repeat(500) // Do something<br class="title-page-name"/><br class="title-page-name"/>    println(counter.get()) // Print index of this item<br class="title-page-name"/>    this.subscription.request(1) // Request next<br class="title-page-name"/><br class="title-page-name"/>    if (counter.incrementAndGet() % 100_000 == 0) {<br class="title-page-name"/>        println("Consumed ${counter.get()} events")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">So, we're back to repeating strings. And after we finish with each, we ask our <kbd class="calibre13">Flowable</kbd> to provide the next one with <kbd class="calibre13">subscription.request(1)</kbd>.</p>
<p class="calibre2">Quickly enough, though, we receive <kbd class="calibre13">MissingBackpressureException</kbd>.</p>
<p class="calibre2">That's because we specified the <kbd class="calibre13">BackpressureStrategy.MISSING</kbd> strategy, and didn't specify the size of the buffer. </p>
<p class="calibre2">To fix that, we'll use the <kbd class="calibre13">onBackpressureBuffer()</kbd> method:</p>
<pre class="calibre18">val source = Flowable.create&lt;String&gt; ({<br class="title-page-name"/>    ...<br class="title-page-name"/>}, BackpressureStrategy.MISSING)<strong class="calibre1">.onBackpressureBuffer(10_000)</strong></pre>
<p class="calibre2">That postponed the problem, but we still crash with <kbd class="calibre13">MissingBackpressureException</kbd>.</p>
<p class="calibre2">What we need in this case is not to <em class="calibre14">create</em> a <kbd class="calibre13">Flowable</kbd>, but to <em class="calibre14">generate</em> it:</p>
<pre class="calibre18">val count = AtomicInteger(0)<br class="title-page-name"/>// This is not entirely correct, but simplifies our code<br class="title-page-name"/>val startTime = System.currentTimeMillis()<br class="title-page-name"/>val source = Flowable.generate&lt;String&gt; {<br class="title-page-name"/>        it.onNext(UUID.randomUUID().toString())<br class="title-page-name"/><br class="title-page-name"/>        if (count.incrementAndGet() == 10_000_000) {<br class="title-page-name"/>            it.onComplete()<br class="title-page-name"/>            latch.countDown()<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        if (count.get() % 100_000 == 0) {<br class="title-page-name"/>            println("Produced ${count.get()} events in ${System.currentTimeMillis() - startTime}ms")<br class="title-page-name"/>            startTime = System.currentTimeMillis()<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<p class="calibre2">Note that, unlike <kbd class="calibre13">create()</kbd>, <kbd class="calibre13">generate()</kbd> receives a lambda that represents <em class="calibre14">a single action</em>. For that reason, we cannot have loops inside it. Instead, we store our state, if any, outside.</p>
<p class="calibre2">The output looks as follows:</p>
<pre class="calibre18"><strong class="calibre1">Produced 100000 events in 3650ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 200000 events in 1942ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 300000 events in 1583ms</strong><br class="title-page-name"/><strong class="calibre1">Produced 400000 events in 1630ms</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">Take note of how much slower the production is now. That's because we wait for our consumer to process the event before supplying the next batch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Holding state</h1>
                
            
            
                
<p class="calibre2">Having those values captured in a closure may seem a bit ugly. There's a more functional alternative, but it's quite hard to grasp. Generate can receive two functions instead of one: </p>
<pre class="calibre18">&lt;T, S&gt; Flowable&lt;T&gt; generate(Callable&lt;S&gt; initialState, BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; generator)</pre>
<p class="calibre2">Well, that's a mouthful. Let's try to understand what's going on there.</p>
<p class="calibre2">The first initial state is <kbd class="calibre13">() -&gt; State</kbd>. In our case, the state can be represented as follows:</p>
<pre class="calibre18">data class State(val count: Int, val startTime: Long)</pre>
<p class="calibre2">We don't pass an instance of <kbd class="calibre13">CountDownLatch</kbd> to our function for the sake of simplicity. You'll soon understand why.</p>
<p class="calibre2">So, our first argument is the <kbd class="calibre13">() -&gt; State</kbd> function, which has no parameters and returns a <kbd class="calibre13">State</kbd>. Now, the second argument should be a function, that is, <kbd class="calibre13">(State, Emitter&lt;T&gt;) -&gt; State</kbd>. In our case, we emit strings, so our function is <kbd class="calibre13">(State, Emitter&lt;String&gt;) -&gt; State</kbd>.</p>
<p class="calibre2">Since this is all a bit confusing not only to us but also to the Kotlin compiler, we specify exactly what types of functions those are, <kbd class="calibre13">Callable&lt;State&gt;</kbd> and <kbd class="calibre13">BiFunction&lt;State, Emitter&lt;String&gt;, State&gt;</kbd>:</p>
<pre class="calibre18">val source = Flowable.generate&lt;String, State&gt;(<br class="title-page-name"/>    Callable&lt;State&gt; { State(0, System.currentTimeMillis()) },<br class="title-page-name"/>    BiFunction&lt;State, Emitter&lt;String&gt;, State&gt; { state, emitter -&gt;<br class="title-page-name"/>        emitter.onNext(UUID.randomUUID().toString())<br class="title-page-name"/><br class="title-page-name"/>        // In other cases you could use destructuring<br class="title-page-name"/>        val count = state.count + 1<br class="title-page-name"/>        var startTime = state.startTime<br class="title-page-name"/>        if (count == 10_000_000) {<br class="title-page-name"/>            emitter.onComplete()<br class="title-page-name"/>            latch.countDown()<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        if (count % 100_000 == 0) {<br class="title-page-name"/>            println("Produced ${count} events in ${System.currentTimeMillis() - startTime}ms")<br class="title-page-name"/>            startTime = System.currentTimeMillis()<br class="title-page-name"/>        }<br class="title-page-name"/>        <br class="title-page-name"/>        // Return next state<br class="title-page-name"/>        State(count, startTime)<br class="title-page-name"/>    }<br class="title-page-name"/>)</pre>
<p class="calibre2">As you can see, sometimes purely functional code is much more complex. Luckily for us, Kotlin allows us to chose different approaches for different situations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">FlowableProcessor</h1>
                
            
            
                
<p class="calibre2">Much like any <kbd class="calibre13">Subject</kbd> is an <kbd class="calibre13">Observer</kbd> and <kbd class="calibre13">Observable</kbd> at the same time, any <kbd class="calibre13">FlowableProcessor</kbd> is a <kbd class="calibre13">Flowable</kbd> that is both a <kbd class="calibre13">Publisher</kbd> and <kbd class="calibre13">Subscriber</kbd>.</p>
<p class="calibre2">To understand this statement, let's take the example of <kbd class="calibre13">ReplaySubject</kbd> and rewrite it using <kbd class="calibre13">ReplayProcessor</kbd>:</p>
<pre class="calibre18">val list = (8..23).toList() // Some non trivial numbers<br class="title-page-name"/>val iterator = list.iterator()<br class="title-page-name"/>val o = Observable.intervalRange(0, list.size.toLong(), 0, 10, TimeUnit.MILLISECONDS).map {<br class="title-page-name"/>    iterator.next()<br class="title-page-name"/>}.<strong class="calibre1">toFlowable(BackpressureStrategy.DROP)</strong>.publish()</pre>
<p class="calibre2">Any <kbd class="calibre13">Observable</kbd> can be converted to <kbd class="calibre13">Flowable</kbd> using the <kbd class="calibre13">toFlowable()</kbd> method. As with any <kbd class="calibre13">Flowable</kbd>, we need to specify which strategy to use. In our case, we use <kbd class="calibre13">BackpressureStrategy.DROP</kbd>.</p>
<p class="calibre2">As you can see, <kbd class="calibre13">Flowable</kbd> supports the <kbd class="calibre13">publish()</kbd> method, the same as <kbd class="calibre13">Observable</kbd>:</p>
<pre class="calibre18">val processor = ReplayProcessor.createWithSize&lt;Int&gt;(2)</pre>
<p class="calibre2">Instead of creating <kbd class="calibre13">ReplaySubject</kbd>, we create <kbd class="calibre13">ReplayProcessor</kbd>, which also supports size limiting:</p>
<pre class="calibre18">o.subscribe(processor)<br class="title-page-name"/><br class="title-page-name"/>o.connect() // Start publishing<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(20)<br class="title-page-name"/><br class="title-page-name"/>println("S1 subscribes")<br class="title-page-name"/>processor.subscribe {<br class="title-page-name"/>    println("S1 $it")<br class="title-page-name"/>}<br class="title-page-name"/>println("S1 subscribed")<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(10)<br class="title-page-name"/><br class="title-page-name"/>println("S2 subscribes")<br class="title-page-name"/>processor.subscribe {<br class="title-page-name"/>    println("S2 $it")<br class="title-page-name"/>}<br class="title-page-name"/>println("S2 subscribed")<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(1000)</pre>
<p class="calibre2">The output is practically the same:</p>
<pre class="calibre18"><strong class="calibre1">S1 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S1 9</strong><br class="title-page-name"/><strong class="calibre1">S1 10</strong><br class="title-page-name"/><strong class="calibre1">S1 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 11</strong><br class="title-page-name"/><strong class="calibre1">S2 subscribes</strong><br class="title-page-name"/><strong class="calibre1">S2 10</strong><br class="title-page-name"/><strong class="calibre1">S2 11</strong><br class="title-page-name"/><strong class="calibre1">S2 subscribed</strong><br class="title-page-name"/><strong class="calibre1">S1 12</strong><br class="title-page-name"/><strong class="calibre1">S2 12</strong></pre>
<p class="calibre2">But in case of big input, we now have backpressure to protect us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Batching</h1>
                
            
            
                
<p class="calibre2">Sometimes, slowing the producer is not possible. So, are we back to the original problem, of either dropping some events or running out of memory? Luckily, Rx still has a few tricks up its sleeve. It is often more efficient to process data in batches. We've already discussed such a case in the previous chapter. For that, we can specify <kbd class="calibre13">buffer()</kbd> for our <kbd class="calibre13">subseriber</kbd>.</p>
<p class="calibre2">Buffer has three flavors. The first one is batch-per-size:</p>
<pre class="calibre18">val latch = CountDownLatch(1)<br class="title-page-name"/>val o = Observable.intervalRange(8L, 15L, 0L, 100L, TimeUnit.MILLISECONDS)<br class="title-page-name"/><br class="title-page-name"/>o.buffer(3).subscribe({<br class="title-page-name"/>    println(it)<br class="title-page-name"/>}, {}, { latch.countDown()})<br class="title-page-name"/><br class="title-page-name"/>latch.await()</pre>
<p class="calibre2">It outputs the following:</p>
<pre class="calibre18"><strong class="calibre1">[8, 9, 10]</strong><br class="title-page-name"/><strong class="calibre1">[11, 12, 13]</strong><br class="title-page-name"/><strong class="calibre1">[14, 15, 16]</strong><br class="title-page-name"/><strong class="calibre1">[17, 18, 19]</strong><br class="title-page-name"/><strong class="calibre1">[20, 21, 22]</strong></pre>
<p class="calibre2">The second is the batch-per-time interval. Imagine we have a screen with a screen that displays the latest news, and new updates arrive every few seconds. But for us, it's fine to refresh the view only once every five seconds:</p>
<pre class="calibre18">val latch = CountDownLatch(1)<br class="title-page-name"/>val o = Observable.intervalRange(8L, 15L, 0L, 100L, TimeUnit.MILLISECONDS)<br class="title-page-name"/><br class="title-page-name"/>o.buffer(300L, TimeUnit.MILLISECONDS).subscribe ({<br class="title-page-name"/>    println(it)<br class="title-page-name"/>}, {}, { latch.countDown() })<br class="title-page-name"/><br class="title-page-name"/>latch.await()</pre>
<p class="calibre2">It outputs the following:</p>
<pre class="calibre18"><strong class="calibre1">[8, 9, 10, 11]</strong><br class="title-page-name"/><strong class="calibre1">[12, 13, 14]</strong><br class="title-page-name"/><strong class="calibre1">[15, 16, 17]</strong><br class="title-page-name"/><strong class="calibre1">[18, 19, 20]</strong><br class="title-page-name"/><strong class="calibre1">[21, 22]</strong></pre>
<p class="calibre2">The third flavor allows us to become dependent on another <kbd class="calibre13">Observable</kbd>. We'll batch until it asks us to flush the data:</p>
<pre class="calibre18">val latch = CountDownLatch(1)<br class="title-page-name"/>val o = Observable.intervalRange(8L, 15L, 0L, 100L, TimeUnit.MILLISECONDS)<br class="title-page-name"/><br class="title-page-name"/>o.buffer(Observable.interval(200L, TimeUnit.MILLISECONDS)).subscribe ({<br class="title-page-name"/>    println(it)<br class="title-page-name"/>}, {}, { latch.countDown() })<br class="title-page-name"/><br class="title-page-name"/>latch.await()</pre>
<p class="calibre2">It outputs the following:</p>
<pre class="calibre18"><strong class="calibre1">[8, 9, 10]</strong><br class="title-page-name"/><strong class="calibre1">[11, 12]</strong><br class="title-page-name"/><strong class="calibre1">[13, 14]</strong><br class="title-page-name"/><strong class="calibre1">[15, 16]</strong><br class="title-page-name"/><strong class="calibre1">[17, 18]</strong><br class="title-page-name"/><strong class="calibre1">[19, 20]</strong><br class="title-page-name"/><strong class="calibre1">[21, 22]</strong><br class="title-page-name"/><strong class="calibre1">[]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Throttling</h1>
                
            
            
                
<p class="calibre2">Throttling on the consumer side is similar to dropping on the producer side. But it can be applied not only to <kbd class="calibre13">Flowable</kbd>, but also to <kbd class="calibre13">Observable</kbd>.<br class="calibre6"/>
<br class="calibre6"/>
You specify the time interval, and each time get only one element, either the first or last one, in that interval:</p>
<pre class="calibre18">val o = PublishSubject.intervalRange(8L, 15L, 0L, 100L, TimeUnit.MILLISECONDS).publish()<br class="title-page-name"/><br class="title-page-name"/>o.<strong class="calibre1">throttleFirst(280L, TimeUnit.MILLISECONDS)</strong>.subscribe {<br class="title-page-name"/>    println(it)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>o.buffer(280L,  TimeUnit.MILLISECONDS).subscribe {<br class="title-page-name"/>    println(it)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>o.connect()<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(100 * 15)</pre>
<p class="calibre2">Execute this example a few times and you will see that you get different results. Throttling is highly sensitive to timing.</p>
<p class="calibre2"><kbd class="calibre13">throttleFirst()</kbd> outputs <kbd class="calibre13">[8, 11, 15, 17, 21]</kbd> because it received the following windows:</p>
<pre class="calibre18"><strong class="calibre1">8</strong><br class="title-page-name"/><strong class="calibre1">[8, 9, 10]</strong><br class="title-page-name"/><strong class="calibre1">11</strong><br class="title-page-name"/><strong class="calibre1">[11, 12, 13]</strong><br class="title-page-name"/><strong class="calibre1">14</strong><br class="title-page-name"/><strong class="calibre1">[14, 15, 16]</strong><br class="title-page-name"/><strong class="calibre1">17</strong><br class="title-page-name"/><strong class="calibre1">[17, 18, 19]</strong><br class="title-page-name"/><strong class="calibre1">20</strong><br class="title-page-name"/><strong class="calibre1">[20, 21]</strong><br class="title-page-name"/><strong class="calibre1">[22]</strong></pre>
<p class="calibre2">Notice that <kbd class="calibre13">[22]</kbd> is throttled and never printed.</p>
<p class="calibre2">Now, let's see what happens when we use <kbd class="calibre13">throttleLast()</kbd>, instead:</p>
<pre class="calibre18">val o = Observable.intervalRange(8L, 15L, 5L, 100L, TimeUnit.MILLISECONDS)<br class="title-page-name"/><br class="title-page-name"/>o.<strong class="calibre1">throttleLast(280L, TimeUnit.MILLISECONDS)</strong>.subscribe {<br class="title-page-name"/>    println(it)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>o.buffer(280L,  TimeUnit.MILLISECONDS).subscribe {<br class="title-page-name"/>    println(it)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>Thread.sleep(100 * 30)</pre>
<p class="calibre2"><kbd class="calibre13">throttleLast()</kbd> outputs <kbd class="calibre13">[10, 13, 16, 19, 22]</kbd> because it received the following windows:</p>
<pre class="calibre18"><strong class="calibre1">10</strong><br class="title-page-name"/><strong class="calibre1">[8, 9, 10]</strong><br class="title-page-name"/><strong class="calibre1">13</strong><br class="title-page-name"/><strong class="calibre1">[11, 12, 13]</strong><br class="title-page-name"/><strong class="calibre1">16</strong><br class="title-page-name"/><strong class="calibre1">[14, 15, 16]</strong><br class="title-page-name"/><strong class="calibre1">19</strong><br class="title-page-name"/><strong class="calibre1">[17, 18, 19]</strong><br class="title-page-name"/><strong class="calibre1">21</strong><br class="title-page-name"/><strong class="calibre1">[20, 21]</strong><br class="title-page-name"/><strong class="calibre1">[22]</strong></pre>
<p class="calibre2">Again, <kbd class="calibre13">[22]</kbd> is throttled and never printed.</p>
<p class="calibre2">Throttling is the last resiliency tool we'll discuss in this chapter, but it's probably one of the most useful ones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we learned about the main benefits of reactive systems. Such systems should be responsive, resilient, elastic, and driven by messaging.</p>
<p class="calibre2">We also discussed the Java 9 Reactive Streams API and its most popular implementation, which is Rx.</p>
<p class="calibre2">Now you should better understand the difference between cold and hot <kbd class="calibre13">Observable</kbd>. A cold <kbd class="calibre13">Observable</kbd> starts working only when someone subscribes to it. A hot <kbd class="calibre13">Observable</kbd>, on the other hand, always emits events, even if nobody is listening.</p>
<p class="calibre2">We also discussed the concept of backpressure, implemented with <kbd class="calibre13">Flowable</kbd>. It allows for a feedback mechanism between the producer and consumer.</p>
<p class="calibre2">In addition, you should be familiar with the notion of multicasting using subjects. It allows us to send the same message to multiple listeners.</p>
<p class="calibre2">Finally, we discussed some resilience mechanisms, such as buffering and throttling, that allow us to accumulate or drop messages, in case we're unable to process them in time.</p>
<p class="calibre2">In the next chapter, we'll start discussing threads, a concept that should be familiar to you if you come from a Java background, and coroutines, which are lightweight threads introduced in Kotlin 1.1.</p>


            

            
        
    </body></html>