- en: Chapter 4. Menus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。菜单
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating an Options menu
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建选项菜单
- en: Modifying menus and menu items during runtime
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时修改菜单和菜单项
- en: Enabling Contextual Action Mode for a view
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为视图启用上下文操作模式
- en: Using Contextual Batch Mode with a ListView
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ListView 的上下文批量模式
- en: Creating a pop-up menu
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建弹出菜单
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'The Android OS is an ever-changing environment. The earliest Android devices
    (prior to Android 3.0), were required to have a hardware menu button. Though a
    hardware button is no longer required, menus are no less important. In fact, the
    **Menu** API has expanded to now support three different types of menus:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Android 操作系统是一个不断变化的环境。最早的 Android 设备（在 Android 3.0 之前），需要有一个硬件菜单按钮。尽管硬件按钮不再需要，但菜单同样重要。事实上，**菜单**
    API 已扩展到现在支持三种不同类型的菜单：
- en: '**Options Menu and Action Bar**: This is the standard menu, which is used for
    global options of your application. Use this for additional features such as search,
    settings, and so on.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项菜单和操作栏**：这是标准菜单，用于应用程序的全局选项。用于搜索、设置等附加功能。'
- en: '**Contextual** **Mode** (**Contextual Action Mode**): This is generally activated
    by long press. (Think of this as similar to a right-click on the desktop.) This
    is used to take an action on the pressed item, such as replying to an e-mail or
    deleting a file.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文** **模式**（**上下文操作模式**）：通常通过长按激活。（将其视为类似于桌面上的右键点击。）这用于对按下的项目执行操作，例如回复电子邮件或删除文件。'
- en: '**Pop-up** **Menu**: This provides a pop-up selection (like a spinner) for
    an additional action. The menu options are not meant to affect the item pressed,
    instead use Contextual Mode as described previously. An example would be hitting
    the share button and getting an additional list of share options.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹出** **菜单**：这为附加操作提供了一个弹出选择（类似于旋转选择器）。菜单选项不旨在影响按下的项目，而是使用前面描述的上下文模式。一个例子是点击分享按钮并获取额外的分享选项列表。'
- en: Menu resources are similar to other Android UI components; they are generally
    created in XML, but can be created in code as well. Our first recipe, as shown
    in the following section, will show the XML menu format and how to inflate it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单资源类似于其他 Android UI 组件；它们通常在 XML 中创建，但也可以在代码中创建。我们将在以下部分中展示的第一个菜谱，将展示 XML 菜单格式以及如何填充它。
- en: Creating an Options menu
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建选项菜单
- en: 'Before we actually create and display a menu, let''s look at a menu to see
    the end result. The following is a screenshot showing the menu section of Chrome:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际创建和显示菜单之前，让我们看看一个菜单以查看最终结果。以下是一个显示 Chrome 菜单部分的屏幕截图：
- en: '![Creating an Options menu](img/B05057_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![创建选项菜单](img/B05057_04_01.jpg)'
- en: The most obvious feature to note is that the menu will look different based
    on the screen size. By default, menu items will be added to the Overflow menu—that's
    the menu you see when you press the three dots at the far right edge.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的特点是菜单的外观会根据屏幕大小而有所不同。默认情况下，菜单项将被添加到溢出菜单中——即你按下最右侧边缘的三个点时看到的菜单。
- en: 'Menus are typically created in resource files using `XML` (like many other
    Android resources) but they are stored in the `res/menu` directory though they
    can also be created in code. To create a menu resource, use the `<menu>` element
    as shown:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单通常使用 `XML`（如许多其他 Android 资源）在资源文件中创建，但它们存储在 `res/menu` 目录中，尽管也可以在代码中创建。要创建菜单资源，请使用如下所示的
    `<menu>` 元素：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `<item>` element defines each individual menu item and is enclosed in the
    `<menu>` element. A basic menu item looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`<item>` 元素定义每个单独的菜单项，并包含在 `<menu>` 元素中。一个基本的菜单项看起来如下：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The most common `<item>` attributes are the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 `<item>` 属性如下：
- en: '`id`: This is the standard resource identifier'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是一个标准的资源标识符'
- en: '`title`: This indicates the text to display'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这表示要显示的文本'
- en: '`icon`: This is a draw-able resource'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图标`：这是一个可绘制的资源'
- en: '`showAsAction`: This has been explained as follows (*see the following paragraph*)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showAsAction`：如下所述（*见下一段*）'
- en: '`enabled`: This is enabled by default'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`：默认启用'
- en: Let's look at `showAsAction` in more detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `showAsAction`。
- en: 'The `showAsAction` attribute controls how the menu item is shown. The options
    include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`showAsAction` 属性控制菜单项的显示方式。选项包括以下内容：'
- en: '`ifRoom`: This menu item should be included in the Action Bar if there''s enough
    space'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifRoom`：如果空间足够，则应将此菜单项包含在操作栏中'
- en: '`withText`: This indicates that both the title and the icon should be shown'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withText`：这表示标题和图标都应该显示'
- en: '`never`: This indicates that the menu item should never be included in the
    Action Bar; always show in the overflow menu'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never`：这表示菜单项永远不会包含在操作栏中；始终显示在溢出菜单中'
- en: '`always`: This indicates that the menu item should be always included in the
    Action Bar (use sparingly as space is limited)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`：这表示菜单项应该始终包含在操作栏中（谨慎使用，因为空间有限）'
- en: Note
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Multiple options can be combined using the pipe (|) separator, such as `showAsAction="ifRoom|withText"`.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用管道（|）分隔符组合多个选项，例如`showAsAction="ifRoom|withText"`。
- en: With the fundamentals of the menu resource covered, we are now ready to create
    a standard Options menu and inflate it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了菜单资源的根本之后，我们现在可以创建一个标准的选项菜单并将其填充。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use Android Studio to create a new project called `OptionsMenu`. Use the default
    **Phone & Tablet** option and select the **Empty Activity** option when prompted
    for the Activity Type. Since the wizard does not create the `res/menu` folder
    by default, navigate to **File** | **New | Directory** to create it before continuing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Android Studio创建一个名为`OptionsMenu`的新项目。使用默认的**手机和平板**选项，并在提示活动类型时选择**空活动**选项。由于向导默认不会创建`res/menu`文件夹，请在继续之前导航到**文件**
    | **新建** | **目录**来创建它。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'With the new project created as described in the preceding section, you are
    ready to create a menu. However, first, we will add a string resource to the `strings.xml`
    file for the menu title. We will use the new string for the menu title when we
    create the XML for the menu. Here are the steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前述章节中创建的新项目，你现在可以创建一个菜单。然而，首先，我们将向`strings.xml`文件添加一个字符串资源作为菜单标题。当创建菜单的XML时，我们将使用这个新字符串作为菜单标题。以下是步骤：
- en: 'Start by opening the `strings.xml` file and add the following `<string>` element
    to the `<resources>` element:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`strings.xml`文件，并在`<resources>`元素中添加以下`<string>`元素：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a new file in the `res/menu` directory and call it `menu_main.xml`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/menu`目录中创建一个新文件，并将其命名为`menu_main.xml`。
- en: 'Open the `menu_main.xml` file and add the following XML to define the menu:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`menu_main.xml`文件，并添加以下XML以定义菜单：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the menu now created, we just have to override the `onCreateOptionsMenu()`
    method in `ActivityMain.java` to inflate the menu:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单现在已创建，我们只需在`ActivityMain.java`中重写`onCreateOptionsMenu()`方法以填充菜单：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the program on a device or emulator to see the menu in the Action Bar.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序，以查看操作栏中的菜单。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are two basic steps here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个基本步骤：
- en: Define the menu in XML.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XML中定义菜单。
- en: Inflate the menu when the activity is created.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动创建时填充菜单。
- en: As a good programming habit, we define the string in the `strings.xml` file
    rather than hardcoding it in the `XML`. We then use the standard Android string
    identifier to set the title for the menu in Step 3\. Since this is a "Settings"
    menu item, we don't want this to be shown in the Action Bar. To make sure it is
    never shown, use `showAsAction="never"`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的编程习惯，我们在`strings.xml`文件中定义字符串，而不是在`XML`中硬编码它。然后我们使用标准的Android字符串标识符在第3步中设置菜单的标题。由于这是一个“设置”菜单项，我们不希望它在操作栏中显示。为了确保它永远不会显示，使用`showAsAction="never"`。
- en: With the menu defined, we will use the menu inflater in Step 4 to load the menu
    during the Activity creation. Notice the `R.menu.menu_main` menu resource syntax?
    This is why we create the XML in the `res/menu` directory — so the system will
    know this is a menu resource.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单定义完成后，我们将在第4步中使用菜单填充器在活动创建期间加载菜单。注意`R.menu.menu_main`菜单资源语法？这就是为什么我们在`res/menu`目录中创建XML的原因——这样系统就会知道这是一个菜单资源。
- en: 'In Step 4, we used `app:showAsAction` rather than Android: `android:showAsAction`.
    This is because we are using the `AppCompat` library (also referred to as the
    Android Support Library). By default, the Android Studio new project wizard includes
    the support library in the project.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们使用了`app:showAsAction`而不是Android的`android:showAsAction`。这是因为我们正在使用`AppCompat`库（也称为Android支持库）。默认情况下，Android
    Studio的新项目向导会将支持库包含在项目中。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you ran the program in Step 5, then you must have seen the **Settings** menu
    item when you pressed the menu overflow button. But that was it. Nothing else
    happened. Obviously, menu items aren't very useful if the application doesn't
    respond to them. Responding to the **Options** menu is done through the `onOptionsItemSelected()`
    callback.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了第5步的程序，那么当你按下菜单溢出按钮时，你必须已经看到了**设置**菜单项。但仅此而已。没有其他发生。显然，如果应用程序不响应用户的菜单项，菜单项就没什么用了。响应用户的**选项**菜单是通过`onOptionsItemSelected()`回调完成的。
- en: 'Add the following method to the application to see a Toast when the Settings
    menu is selected:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到应用程序中，以便在选择设置菜单时显示Toast：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it. You now have a working menu!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。你现在有一个可以工作的菜单了！
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As shown in the preceding example, return `true` when you've handled the callback;
    otherwise, call the super class as shown in the `else` statement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，当处理回调时返回`true`；否则，如`else`语句所示调用超类。
- en: Using a menu item to launch an activity
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用菜单项启动活动
- en: In this example, we show a Toast so we can see a working example; however, we
    could just as easily launch a new activity if needed. As you did in the *Starting
    a new activity with an Intent object* recipe of [Chapter 1](ch01.html "Chapter 1. Activities"),
    *Activities*, create an Intent and call it with `startActivity()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们显示了一个Toast，以便我们可以看到工作示例；然而，如果需要，我们也可以轻松地启动一个新的活动。正如你在[第1章](ch01.html
    "第1章。活动")的“使用Intent对象启动新活动”食谱中所做的那样，创建一个Intent并使用`startActivity()`调用它。
- en: Creating sub menus
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建子菜单
- en: '**Sub menus** are created and accessed in almost exactly the same manner as
    other menu elements and can be placed in any of the provided menus, although they
    cannot be placed within other sub menus. To define a sub menu, include a `<menu>`
    element within an `<item>` element. Here is the XML form this recipe with two
    sub menu items added:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**子菜单**的创建和访问几乎与其他菜单元素完全相同，可以放置在任何提供的菜单中，尽管它们不能放置在其他子菜单中。要定义子菜单，请在`<item>`元素内包含一个`<menu>`元素。以下是本食谱中添加了两个子菜单项的XML形式：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Grouping menu items
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组菜单项
- en: 'Another menu feature that Android supports is grouping menu items. Android
    provides several methods for groups, including the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持的其他菜单功能之一是分组菜单项。Android提供了几个用于分组的函数，包括以下内容：
- en: '`setGroupVisible()`: Show or hide all items'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGroupVisible()`: 显示或隐藏所有项目'
- en: '`setGroupEnabled()`: Enable or disable all items'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGroupEnabled()`: 启用或禁用所有项目'
- en: '`setGroupCheckable()`: Set the checkable behavior'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGroupCheckable()`: 设置可勾选行为'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Android will keep all grouped items with `showAsAction="ifRoom"` together. This
    means all items in the group with `showAsAction="ifRoom"` will be in the Action
    Bar or all items will be in the overflow.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Android会将所有带有`showAsAction="ifRoom"`的分组项一起保留。这意味着组中所有带有`showAsAction="ifRoom"`的项都将显示在操作栏中，或者所有项都将显示在溢出菜单中。
- en: 'To create a group, add the `<item>` menu elements to a `<group>` element. Here
    is an example using the menu XML from this recipe with two additional items in
    a group:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个组，将`<item>`菜单元素添加到`<group>`元素中。以下是一个使用本食谱中菜单XML的示例，其中包含了一个组中的两个附加项：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For complete details on the menu, visit the Android Developer Menu Resources
    site at [http://developer.android.com/guide/topics/resources/menu-resource.html](http://developer.android.com/guide/topics/resources/menu-resource.html)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取有关菜单的完整详细信息，请访问Android开发者菜单资源网站[http://developer.android.com/guide/topics/resources/menu-resource.html](http://developer.android.com/guide/topics/resources/menu-resource.html)
- en: Modifying menus and menu items during runtime
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时修改菜单和菜单项
- en: Though it's been stated many times, it's considered the "best" programming practice
    to create UI in XML rather than in Java. There are still times when you may need
    to do it in code. This is especially true if you wanted a menu item to be visible
    (or enabled) based on some external criteria. Menus can also be included in resource
    folders, but there are times when you need code to perform the logic. One example
    might be if you wanted to offer an upload menu item only if the user is logged
    in to your app.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然已经多次提到，但被认为的“最佳”编程实践是在XML中而不是在Java中创建UI。仍然有需要通过代码执行的时候。这尤其适用于你想要根据某些外部标准使菜单项可见（或启用）的情况。菜单也可以包含在资源文件夹中，但有时你需要代码来执行逻辑。一个例子可能是，如果你想只在用户登录你的应用时提供上传菜单项。
- en: In this recipe, we will create and modify the menu only through code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将仅通过代码创建和修改菜单。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `RuntimeMenu` using the default
    **Phone & Tablet** option. Select the **Empty Activity** option when prompted
    to add an Activity. Since we will create and modify the menu completely in code,
    we will not need to create a `res/menu` directory.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`RuntimeMenu`，使用默认的**手机和平板**选项。当被提示添加活动时，选择**空活动**选项。由于我们将在代码中完全创建和修改菜单，因此我们不需要创建`res/menu`目录。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To start, we will add string resources for our menu items and a button to toggle
    the menu visibility. Open the `res/strings.xml` file and follow these steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加用于我们的菜单项和切换菜单可见性的按钮的字符串资源。打开`res/strings.xml`文件并按照以下步骤操作：
- en: 'Add the following two strings to the existing `<resources>` element:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下两个字符串添加到现有的`<resources>`元素中：
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a button to `activity_main.xml` with `onClick()` set to `toggleMenu` as
    shown here:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`中添加一个按钮，并将其`onClick()`设置为`toggleMenu`，如下所示：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open `ActivityMain.java` and add the following three lines of code just below
    the class declaration:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ActivityMain.java`并在类声明下方添加以下三行代码：
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following method for the button to call:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加以下方法以供调用：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the activity is first created, Android calls `onCreateOptionsMenu()` to
    create the menu. Here is the code to dynamically build the menu:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当活动首次创建时，Android会调用`onCreateOptionsMenu()`来创建菜单。以下是动态构建菜单的代码：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For best programming practice, don''t use `onCreateOptionsMenu()` to update
    or change your menu; instead, use `onPrepareOptionsMenu()`. Here is the code to
    change the visibility of the **Download** menu item based on our flag:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最佳编程实践，不要使用`onCreateOptionsMenu()`来更新或更改你的菜单；相反，使用`onPrepareOptionsMenu()`。以下是根据我们的标志更改**下载**菜单项可见性的代码：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Though not technically required for this recipe, this `onOptionsItemSelected()`
    code shows how to respond to each menu item:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然这个菜谱技术上不是必需的，但这个`onOptionsItemSelected()`代码展示了如何响应每个菜单项：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program on a device or emulator to see the menu changes.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序以查看菜单更改。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created an override for `onCreateOptionsMenu()`, just like we did in the
    previous recipe, *Creating an Options Menu*. But instead of inflating an existing
    menu resource, we created the menu using the `Menu.add()` method. Since we want
    to modify the menu items later as well as respond to the menu item events, we
    have defined our own menu IDs and passed them to the `add()` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`onCreateOptionsMenu()`创建了一个覆盖，就像我们在之前的菜谱中做的那样，*创建一个选项菜单*。但是，我们不是填充现有的菜单资源，而是使用`Menu.add()`方法创建菜单。由于我们希望在以后也修改菜单项以及响应菜单项事件，我们定义了自己的菜单ID并将它们传递给`add()`方法。
- en: '`onOptionsItemSelected()` is called for all the menu items, so we get the menu
    ID and use a `switch` statement based on the IDs we created. We return `true`
    if we are handling the menu event, otherwise we pass the event to the super class.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`onOptionsItemSelected()`会为所有菜单项调用，因此我们获取菜单ID并使用基于我们创建的ID的`switch`语句。如果我们正在处理菜单事件，我们返回`true`，否则我们将事件传递给父类。'
- en: Changing the menu occurs in the `onPrepareOptionsMenu()` method. To simulate
    an external event, we created a button to toggle a Boolean flag. The visibility
    of the **Download** menu is determined by the flag. This is where you would want
    to create your custom code based on whatever criteria you set. Your flag could
    be set using the current player level or maybe when a new level is ready for release;
    you send a Push message, which enables the menu item.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onPrepareOptionsMenu()`方法中发生菜单更改。为了模拟外部事件，我们创建了一个按钮来切换一个布尔标志。**下载**菜单的可见性由这个标志决定。这就是你根据设定的任何标准创建自定义代码的地方。你可以使用当前播放器级别或者当新级别准备发布时设置这个标志；你发送一个推送消息，以启用菜单项。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What if we wanted this **Download** option to be easily noticed to indicate
    whether it''s available? We could tell Android we want the menu in the Action
    Bar by adding the following code to `onPrepareOptionsMenu()` (before the return
    statement):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让这个**下载**选项容易被注意到，以指示它是否可用？我们可以通过在`onPrepareOptionsMenu()`中添加以下代码来告诉Android我们想在操作栏中显示菜单（在返回语句之前）：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now if you run the code, you will see the **Download** menu item in the Action
    Bar, but the behavior isn't correct.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行代码，你将在操作栏中看到**下载**菜单项，但行为是不正确的。
- en: 'Earlier, when we didn''t have a menu item in the Action Bar, Android called
    `onPrepareOptionsMenu()` each time we opened the overflow menu so the visibility
    was always updated. To correct this behavior, add the following line of code to
    the `toggleMenu()` method called by the button:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前我们没有在操作栏中添加菜单项时，每次打开溢出菜单，Android 都会调用 `onPrepareOptionsMenu()` 方法来确保可见性始终更新。为了纠正这种行为，请将以下代码行添加到按钮调用的
    `toggleMenu()` 方法中：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `invalidateOptionsMenu()` call tells Android that our option menu is no
    longer valid, which then forces a call to `onPrepareOptionsMenu()` giving us the
    behavior we expect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `invalidateOptionsMenu()` 方法告诉 Android 我们的操作菜单已不再有效，这会强制调用 `onPrepareOptionsMenu()`
    方法，从而得到我们期望的行为。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android considers the menu as always open if a menu item is displayed in the
    Action Bar.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在操作栏中显示菜单项，Android 会认为菜单始终处于打开状态。
- en: Enabling Contextual Action Mode for a view
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为视图启用上下文操作模式
- en: 'A Context Menu provides additional options related to a specific view—the same
    concept as a right-click on the desktop. Android currently supports two different
    approaches: the floating Context Menu and Contextual Mode. Contextual Action Mode
    was introduced in Android 3.0\. The older floating Context Menu could lead to
    confusion since there was no indication of the currently selected item and it
    didn''t support actions on multiple items—such as selecting multiple emails to
    delete in one action.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文菜单提供与特定视图相关的附加选项——这与桌面上的右键点击概念相同。Android 目前支持两种不同的方法：浮动上下文菜单和上下文模式。上下文操作模式是在
    Android 3.0 中引入的。较老的浮动上下文菜单可能会导致混淆，因为没有指示当前选中的项，并且它不支持对多个项执行操作——例如，在一次操作中删除多个电子邮件。
- en: Creating a Floating Context Menu
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建浮动上下文菜单
- en: If you need to use the old style Context Menu, for example, to support preAndroid
    3.0 devices, it's very similar to the Option Menu API, just different method names.
    To create the menu, use `onCreateContextMenu()` instead of `onCreateOptionsMenu()`.
    To handle the menu item selection, use `onContextItemSelected()` instead of `onOptionsItemSelected()`.
    Finally, call `registerForContextMenu()` to let the system know you want Context
    Menu events for the view.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用旧式的上下文菜单，例如，为了支持 Android 3.0 之前的设备，它与选项菜单 API 非常相似，只是方法名不同。要创建菜单，请使用
    `onCreateContextMenu()` 而不是 `onCreateOptionsMenu()`。要处理菜单项选择，请使用 `onContextItemSelected()`
    而不是 `onOptionsItemSelected()`。最后，调用 `registerForContextMenu()` 来让系统知道你想要为视图获取上下文菜单事件。
- en: Since Contextual Mode is considered the preferred way to display context options,
    this recipe will focus on the newer API. Contextual Mode offers the same features
    as the floating Context Menu, but also adds additional functionality by allowing
    multiple item selection when using batch mode.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上下文模式被认为是显示上下文选项的首选方式，本食谱将侧重于较新的 API。上下文模式提供了与浮动上下文菜单相同的特性，但通过允许在批量模式下进行多项选择，还增加了额外的功能。
- en: This recipe will demonstrate the setup of Contextual Mode for a single view.
    Once activated, with a long press, a **Contextual Action Bar** (**CAB**) will
    replace the Action Bar until Contextual Mode is finished.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将演示为单个视图设置上下文模式。一旦激活，通过长按，一个 **上下文操作栏**（**CAB**）将替换操作栏，直到上下文模式完成。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Contextual Action Bar is not the same as the Action Bar and your activity
    does not need to include an Action Bar.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文操作栏与操作栏不同，你的活动不需要包含操作栏。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use Android Studio to create a new project and call it `ContextualMode`. Use
    the default **Phone & Tablet** option and select **Empty Activity** when prompted
    to add an Activity. Create a menu directory (`res/menu`) as we did in the first
    recipe, *Creating an Options menu*, to store the XML for the contextual menu.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Android Studio 创建一个新的项目，并将其命名为 `ContextualMode`。使用默认的 **Phone & Tablet**
    选项，并在被提示添加活动时选择 **Empty Activity**。创建一个菜单目录 (`res/menu`)，就像我们在第一个食谱中做的那样，用于存储上下文菜单的
    XML。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will create an **ImageView** to serve as the host view to initialize Contextual
    Mode. Since Contextual Mode is usually triggered with a long press, we will set
    up a long click listener in `onCreate()` for the `ImageView`. When called, we
    will start Contextual Mode and pass an `ActionMode` callback to handle the Contextual
    Mode events. Here are the steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 **ImageView** 作为宿主视图以初始化上下文模式。由于上下文模式通常通过长按触发，我们将在 `onCreate()` 方法中为
    `ImageView` 设置一个长按监听器。当被调用时，我们将启动上下文模式，并传递一个 `ActionMode` 回调来处理上下文模式事件。以下是步骤：
- en: 'We will start by adding two new string resources. Open the `strings.xml` file
    and add the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先添加两个新的字符串资源。打开`strings.xml`文件并添加以下内容：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the strings created, we can now create the menu by creating a new file
    in `res/menu` called `context_menu.xml` using the following XML:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串创建完成后，我们现在可以创建菜单，通过在`res/menu`中创建一个名为`context_menu.xml`的新文件，使用以下XML：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now add an `ImageView` to `activity_main.xml` to serve as the source for initiating
    Contextual Mode. Here is the XML for the ImageView:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将一个`ImageView`添加到`activity_main.xml`中，作为启动Contextual Mode的源。以下是ImageView的XML：
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the UI now set up, we can add the code for Contextual Mode. First, we
    need a global variable to store the `ActionMode` instance returned when we call
    `startActionMode()`. Add the following line of code to `MainActivity.java` below
    the class constructor:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在UI已经设置好了，我们可以添加Contextual Mode的代码。首先，我们需要一个全局变量来存储在调用`startActionMode()`时返回的`ActionMode`实例。在`MainActivity.java`中的类构造函数下方添加以下代码行：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, create an `ActionMode` callback to pass to `startActionMode().` Add the
    following code to the `MainActivity` class below the code in the previous step:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`ActionMode`回调并将其传递给`startActionMode()`。在上一步骤中的代码下方添加以下代码到`MainActivity`类中：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the `ActionMode` callback created, we just need to call `startActionMode()`
    to begin Contextual Mode. Add the following code to the `onCreate()` method to
    set up the long click listener:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了`ActionMode`回调后，我们只需要调用`startActionMode()`来开始Contextual Mode。将以下代码添加到`onCreate()`方法中以设置长按监听器：
- en: '[PRE22]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the program on a device or emulator to see the CAB in action.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序，以查看CAB的实际效果。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you saw in Step 2, we have used the same menu XML to define the contextual
    menu as the other menus.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第二步中看到的，我们使用了相同的菜单XML来定义上下文菜单，就像其他菜单一样。
- en: 'The main piece of code to understand is the `ActionMode` callback. This is
    where we handle the Contextual Mode events: initializing the menu, handling menu
    item selections, and cleaning up. We start Contextual Mode in the long press event
    with a call to `startActionMode()` by passing in the `ActionMode` callback created
    in Step 5.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的主要代码是`ActionMode`回调。这是我们处理Contextual Mode事件的地点：初始化菜单、处理菜单项选择和清理。我们在长按事件中通过调用`startActionMode()`并传递在第五步中创建的`ActionMode`回调来启动Contextual
    Mode。
- en: When action mode is triggered, the system calls the `onCreateActionMode()` callback,
    which inflates the menu and displays it in the Contextual Action Bar. The user
    can dismiss the Contextual Action Bar by pressing the back arrow or the back key.
    The CAB is also dismissed when the user makes a menu selection. We show a Toast
    to give a visual feedback for this recipe but this is where you would implement
    your functionality.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发操作模式时，系统会调用`onCreateActionMode()`回调，它会展开菜单并在Contextual Action Bar中显示它。用户可以通过按返回箭头或返回键来关闭Contextual
    Action Bar。当用户进行菜单选择时，CAB也会关闭。我们显示一个Toast来为这个菜谱提供视觉反馈，但这是你实现功能的地方。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In this example, we store the `ActionMode` returned from the `startActionMode()`
    call. We use it to prevent a new instance from being created when the Action Mode
    is already active. We could also use this instance to make changes to the Contextual
    Action Bar itself, such as changing the title with the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们存储了从`startActionMode()`调用返回的`ActionMode`。我们使用它来防止在Action Mode已经激活时创建新的实例。我们也可以使用这个实例来对Contextual
    Action Bar本身进行更改，例如使用以下方式更改标题：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is particularly useful when working with multiple item selections as we'll
    see in the next recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将在下一道菜谱中看到的多项选择一起工作时，这尤其有用。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the next recipe, *Using Contextual Batch Mode with a ListView*, to work
    with multiple items selection
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见下一道菜谱，*使用ListView与Contextual Batch Mode*，以处理多项选择
- en: Using Contextual Batch Mode with a ListView
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ListView与Contextual Batch Mode
- en: 'As discussed in the previous recipe, Contextual Mode supports two forms of
    use: single View mode (as demonstrated) and multiple selection (or batch) mode.
    Batch mode is where Contextual Mode outperforms the old style Context Menu as
    multiple selections were not supported.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一道菜谱中讨论的，Contextual Mode支持两种使用形式：单视图模式（如演示所示）和多项选择（或批量）模式。批量模式是Contextual
    Mode优于旧式上下文菜单的地方，因为批量选择不受支持。
- en: 'If you''ve ever used an e-mail app such as Gmail or a file browser, you''ve
    probably seen Contextual Mode when selecting multiple items. Here is a screenshot
    from Solid Explorer, which shows an excellent implementation of Material Theme
    and Contextual Mode:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过像Gmail或文件浏览器这样的电子邮件应用，你可能在选择多个项时见过上下文模式。以下是从Solid Explorer的截图，它展示了出色的Material主题和上下文模式的实现：
- en: '![Using Contextual Batch Mode with a ListView](img/B05057_04_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![使用ListView的上下文批量模式](img/B05057_04_02.jpg)'
- en: In this recipe, we will create a `ListView` populated with multiple country
    names to demonstrate multiple selections or batch mode. This example will use
    the normal long press event and also the item click event to start Contextual
    Mode.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个填充多个国家名称的`ListView`来演示多选或批量模式。此示例将使用正常的长按事件以及项点击事件来启动上下文模式。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `ContextualBatchMode`. Use
    the default **Phone & Tablet** option and select **Empty Activity** when prompted
    to add an Activity. Create a menu directory (`res/menu`) for the contextual menu.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`ContextualBatchMode`。使用默认的**手机和平板电脑**选项，并在被提示添加活动时选择**空活动**。为上下文菜单创建一个菜单目录（`res/menu`）。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Similar to the previous recipe, we start by creating a menu in XML to inflate
    when Contextual Mode begins. We need to define `MultiChoiceModeListener` to handle
    batch mode with the `ListView`. We then set up the `ListView` to allow multiple
    selections and pass in the `MultiChoiceModeListener`. Here are the steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个菜谱类似，我们首先创建一个在上下文模式开始时展开的XML菜单。我们需要定义`MultiChoiceModeListener`来处理与`ListView`的批量模式。然后我们设置`ListView`以允许多选，并传入`MultiChoiceModeListener`。以下是步骤：
- en: 'Open the `strings.xml` file and add two new string resources for the menu items
    as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`strings.xml`文件，并添加两个新的字符串资源用于菜单项，如下所示：
- en: '[PRE24]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new file called `contextual_menu.xml` in the `res/menu` folder with
    the following XML:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/menu`文件夹中创建一个名为`contextual_menu.xml`的新文件，内容如下所示：
- en: '[PRE25]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we need a `ListView`, we will change `MainActivity` to extend from `ListActivity`
    as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要`ListView`，我们将`MainActivity`更改为从`ListActivity`扩展，如下所示：
- en: '[PRE26]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a `MultiChoiceModeListener` to handle the Contextual Action Bar events.
    Add the following code to `MainActivity.java` below the class constructor:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MultiChoiceModeListener`来处理上下文操作栏事件。在`MainActivity.java`中的类构造函数下方添加以下代码：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will change the `onCreate()` to set up the `ListView` and populate
    a `ListAdapter` using a string array of country names, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更改`onCreate()`以设置`ListView`并使用国家名称的字符串数组填充`ListAdapter`，如下所示：
- en: '[PRE28]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the program on a device or emulator to see the CAB in action.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序，以查看上下文操作栏的实际效果。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The three key elements to make Action Mode work in batch mode are:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使批量模式中的操作模式工作有三个关键元素：
- en: Creating a Contextual Menu to inflate
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建上下文菜单以展开
- en: Defining `MultiChoiceModeListener` to pass to `setMultiChoiceModeListener()`
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`MultiChoiceModeListener`以传递给`setMultiChoiceModeListener()`
- en: Set `ChoiceMode` of the `ListView` to `CHOICE_MODE_MULTIPLE_MODAL`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ListView`的`ChoiceMode`设置为`CHOICE_MODE_MULTIPLE_MODAL`。
- en: '`MultiChoiceModeListener` serves the same purpose as the `ActionMode` callback
    used in single-view Contextual Mode, and in fact, implements `ActionMode.Callback`.
    As with `ActionMode.Callback`, the menu is inflated when `MultiChoiceModeListener`
    calls `onCreateActionMode()`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiChoiceModeListener`的作用与在单视图上下文模式中使用的`ActionMode`回调相同，并且实际上实现了`ActionMode.Callback`。与`ActionMode.Callback`一样，当`MultiChoiceModeListener`调用`onCreateActionMode()`时，菜单会被展开。'
- en: By default, Context Mode is initiated with a long press on an item in the `ListView`.
    We will go a step further by starting Contextual Mode when the item is checked
    using the `onItemClick()` event. If we don't do this, the only way to initiate
    the Contextual Mode would be with a long click, which may leave many users unaware
    of the additional functionality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，上下文模式是通过在`ListView`中的项上长按来启动的。我们将更进一步，通过使用`onItemClick()`事件来检查项时启动上下文模式。如果我们不这样做，启动上下文模式的唯一方法将是长按，这可能会让许多用户不了解额外的功能。
- en: There's more...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: As mentioned in the introduction to this chapter, your activity does not need
    to include an Action Bar to use a Contextual Action Bar. If you do have an Action
    Bar and it's visible, it will be overlaid with the CAB. If you do not have an
    Action Bar as the default with this recipe, the layout will be redrawn to include
    the CAB (and redrawn again when the CAB is dismissed). If you want the Action
    Bar to be visible, either change the theme for the Activity or change the base
    class and set up the `ListView` manually.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，您的活动不需要包含操作栏即可使用上下文操作栏。如果您确实有操作栏并且它是可见的，它将被上下文操作栏覆盖。如果您没有操作栏作为此菜谱的默认设置，布局将被重新绘制以包含上下文操作栏（当上下文操作栏关闭时再次重新绘制）。如果您希望操作栏可见，则可以更改活动的主题或更改基本类并手动设置`ListView`。
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: For more information on the `ListView`, refer to [Chapter 2](ch02.html "Chapter 2. Layouts"),
    *Layouts*
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`ListView`的更多信息，请参阅[第2章](ch02.html "第2章。布局")，*布局*
- en: Creating a pop-up menu
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建弹出菜单
- en: 'A pop-up menu is attached to a view similar to the dropdown on a spinner. The
    idea of a pop-up menu is to provide additional options to complete an action.
    A common example might be a **Reply** button in an e-mail app. When pressed, several
    reply options are shown, such as: **Reply**, **Reply All**, and **Forward**.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出菜单类似于选择器下拉的视图。弹出菜单的目的是提供额外的选项以完成操作。一个常见的例子可能是电子邮件应用中的**回复**按钮。按下时，会显示几个回复选项，例如：**回复**、**全部回复**和**转发**。
- en: 'Here is an example of the pop-up menu from the recipe:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是菜谱中弹出菜单的示例：
- en: '![Creating a pop-up menu](img/B05057_04_03.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![创建弹出菜单](img/B05057_04_03.jpg)'
- en: Android will show the menu options below the anchor view if there is room; otherwise,
    it will show them above the view.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有空间，Android将在锚点视图下方显示菜单选项；否则，它将在视图上方显示。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A pop-up menu is *not* meant to affect the view itself. That is the purpose
    of a Context Menu. Instead refer to the Floating Menu/Context Mode described in
    the *Enabling Contextual Action Mode for a view* recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出菜单**不是**用来影响视图本身的。这是上下文菜单的目的。相反，请参阅*启用视图的上下文操作模式*菜谱中描述的浮动菜单/上下文模式。
- en: In this recipe, we will create the pop-up menu shown previously, using an `ImageButton`
    as the anchor view.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，我们将使用`ImageButton`作为锚点视图创建之前显示的弹出菜单。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `PopupMenu`. Use the default
    **Phone & Tablet** option and select **Empty Activity** when prompted to add an
    Activity. As before, create a menu directory (`res/menu`) to store the menu XML.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目并将其命名为`PopupMenu`。在提示添加活动时，使用默认的**手机和平板电脑**选项并选择**空活动**。像之前一样，创建一个菜单目录（`res/menu`）以存储菜单XML。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We start by creating the XML menu to inflate on the button press. After inflating
    the pop-up menu, we call `setOnMenuItemClickListener()` by passing in the callback
    to handle the menu item selection. Here are the steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个XML菜单，以便在按钮按下时展开。在展开弹出菜单后，我们通过传递回调来调用`setOnMenuItemClickListener()`以处理菜单项选择。以下是步骤：
- en: 'Add the following strings to `strings.xml`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字符串添加到`strings.xml`中：
- en: '[PRE29]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a new file in the `res/menu` directory called `menu_popup.xml` using
    the following XML:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/menu`目录中创建一个名为`menu_popup.xml`的新文件，使用以下XML：
- en: '[PRE30]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create an `ImageButton` in `activity_main.xml` to provide the anchor view for
    the pop-up menu. Create it as shown in the following XML code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`中创建一个`ImageButton`以提供弹出菜单的锚点视图。按照以下XML代码创建它：
- en: '[PRE31]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open `MainActivity.java` and add the following `OnMenuItemClickListener` below
    the class constructor:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并在类构造函数下方添加以下`OnMenuItemClickListener`：
- en: '[PRE32]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The final code is to handle the button `onClick()` event, as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的代码是处理按钮`onClick()`事件，如下所示：
- en: '[PRE33]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run the program on a device or emulator to see the pop-up menu.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序以查看弹出菜单。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you have read the previous menu recipes, this will probably look very familiar.
    Basically, we just inflate a pop-up menu when the `ImageButton` is pressed. We
    set up a menu item listener to respond to the menu selection.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读了之前的菜单菜谱，这可能会看起来非常熟悉。基本上，我们只是在`ImageButton`被按下时展开一个弹出菜单。我们设置一个菜单项监听器以响应菜单选择。
- en: The key is to understand each of the menu options available in Android so you
    can use the correct menu type for a given scenario. This will help your application
    by providing a consistent user experience and reducing the learning curve.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于理解Android中可用的每个菜单选项，这样你就可以为特定场景选择正确的菜单类型。这将通过提供一致的用户体验和降低学习曲线来帮助你的应用程序。
