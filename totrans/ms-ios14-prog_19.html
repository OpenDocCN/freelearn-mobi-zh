<html><head></head><body>
		<div id="_idContainer223">
			<p><a id="_idTextAnchor569"/></p>
			<h1 id="_idParaDest-274"><em class="italic"><a id="_idTextAnchor570"/>Chapter 19</em>: Ensuring App Quality with Tests</h1>
			<p>In all of the chapters so far, the main focus has been code that ran as part of an app. The apps you have worked on are small and can easily be tested manually. However, this approach doesn't scale well if your apps become larger. This approach also doesn't scale if you want to verify lots of different user input, lots of screens, convoluted logic, or even if you're going to run tests on many different devices.</p>
			<p>Xcode comes with built-in testing tools. These tools allow you to write tests so you can make sure that all of the business logic for your app works as expected. More importantly, you can test that your user interface functions and behaves as intended in many different automated scenarios.</p>
			<p>Many developers tend to shy away from testing and postpone it until the end of the project, or don't do it at all. The reason for this is that it's often pretty hard to figure out how to write proper tests. This is especially true if you're just starting out with testing. Lots of developers feel like large parts of the logic their tests validate are so obvious that writing tests for that logic just feels silly. When testing is not approached correctly, it can be more of a burden than a relief by being high-maintenance and not testing the essential areas of code.</p>
			<p>This chapter serves as an introduction to writing both logic and user interface tests using Xcode and its built-in tools. By the end of this chapter, you should be able to set up a robust suite of tests and understand how you can make use of the tools provided by Xcode to write better code that is testable and reliable. This chapter covers the following topics: </p>
			<ul>
				<li>Testing logic with XCTest</li>
				<li>Optimizing code for testability</li>
				<li>Testing the user interface with XCUITest</li>
			</ul>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor571"/><a id="_idTextAnchor572"/><a id="_idTextAnchor573"/>Testing logic with XCTest</h1>
			<p>This section is going to help you to discover the testing capabilities on iOS with <strong class="source-inline">XCTest</strong>. Even if you haven't written any tests before, you might have thoughts or ideas about it. To start testing code, you don't need to have a computer science degree or spend days studying the <a id="_idIndexMarker980"/>absolute best way to test your code. In fact, the chances <a id="_idIndexMarker981"/>are that you're already testing your code and you don't even know it.</p>
			<p>So, what does it mean to test your code? That's what this section aims to make clear. First, you will read about the different types of tests you can write. Then, you'll learn what <strong class="source-inline">XCTest</strong> is and how you can set up a test suite for an app. Finally, you'll learn how to optimally test some actual code and how code can be refactored to make <a id="_idTextAnchor574"/>it more testable<a id="_idTextAnchor575"/>.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor576"/>Understanding what it means to test code</h2>
			<p>When you test your code, you're essentially making sure that certain input produces the desired output. A very basic example of a test would be to make sure that calling a method that <a id="_idIndexMarker982"/>increments its input by a given value produces the output you expect.</p>
			<p>Any time you launch your application and perform any action within your app, you are testing some part of your code. Any time you print something to the console to verify that the expected value is printed, you are also testing your code. Once you think about testing this way, a concept that might have sounded hard before actually does not seem as complicated as you may have thought. So, if just by using your app, you are indeed testing it already, then, what should you write te<a id="_idTextAnchor577"/>sts for? Let's see how to determine when to write a test for your cod<a id="_idTextAnchor578"/>e.</p>
			<h3>Determining which tests to write</h3>
			<p>When you start testing, it's often hard to decide what logic you want to test and what logic you <a id="_idIndexMarker983"/>don't want to test. Reasons for this could include certain logic being too trivial, too hard, or just not important enough to test. This statement implies that you do not have to test absolutely every line of code in your app, and that is intentional. Sometimes it's simply not reasonable to write tests for a certain part <a id="_idIndexMarker984"/>of your code. For instance, you don't have to test that <strong class="source-inline">UIKit</strong> behaves as it should; it's Apple's job to make sure that the frameworks they ship are bug-f<a id="_idTextAnchor579"/>ree.</p>
			<p>Determining what to test is important, and the longer you defer deciding whether you will add tests for a particular piece of logic, the harder it will be to write tests for it. A simple rule of thumb is that you don't need to test Apple's frameworks. It's safe to assume that Apple makes sure that any code they ship is tested and if it contains bugs, there's not much you can do to fix it anyway. Moreover, you don't want your tests to fail where Apple's tests should have failed.</p>
			<p>What you should at least test is<a id="_idTextAnchor580"/><a id="_idTextAnchor581"/> the <em class="italic">call site</em> of your methods, structs, and classes. You can think of the call site as the methods that other objects use to perform tasks. It's a good practice to make anything that's not used by the call site of your objects private, meaning that outside code can't access that part of the code. We'll cover more on this later when you learn <a id="_idIndexMarker985"/>more about refactoring code to make it more testable.</p>
			<p>You should also test code that you might consider too trivial to write tests for. These parts of your code are likely to receive the <em class="italic">too trivial</em> treatment in other parts of the development process too. This usually causes you and your coworkers to pay less and less attention to this trivial piece of code, and before you know it, a bug gets introduced that might not be spotted until the app is in the App Store. Writing trivial tests for trivial code takes very little time and saves you from minor oversights that could lead to massive complications.</p>
			<p>A few simple guidelines <a id="_idIndexMarker986"/>that you should follow when you write tests are the following: </p>
			<ul>
				<li><strong class="bold">Test trivial code</strong>: This usually requires minimal effort.</li>
				<li><strong class="bold">Test the call site of your objects</strong>: These tests will ensure that your public APIs are consistent and work as expected.</li>
				<li><strong class="bold">Don't test Apple's frameworks or any other dependencies</strong>: Doing this is the responsibility of the framework vendor.</li>
			</ul>
			<p>Once you've determined what you should test, it's time to start writing the actual tests. However, if you've heard about testing before, you might have heard of terms such as integration tests, unit tests, sanity tests, and a couple of others. T<a id="_idTextAnchor582"/>he next segment explains a couple of the most important and well-known types of te<a id="_idTextAnchor583"/>sting.</p>
			<h3>Choosing the correct test type</h3>
			<p>When you write tests, it's often a good idea to ask yourself what kind of test you're writing. The kind of test you want to write will typically guide you toward the way your test should <a id="_idIndexMarker987"/>be structured and scoped. Having tests that are well-scoped, structured, and focused will ensure that you're building a stable test suite that properly tests your code without unintended side-effects that influence the quality of your test. Now let's dive into the following types of tests: unit tests and integration<a id="_idTextAnchor584"/><a id="_idTextAnchor585"/><a id="_idTextAnchor586"/> tests.</p>
			<h4>Unit tests</h4>
			<p>Probably the most well-known type of test is the unit test. A lot of people call any other test they write a <strong class="bold">unit test</strong>, which is <a id="_idIndexMarker988"/>probably why this is such a well-known term for testing. Another reason for unit tests being so popular is that it's a very sensible test type.</p>
			<p>A unit test is intended to make sure that an isolated object works as expected. This isolated object will usually be a class or struct, but it could just as well be a standalone method. It's important that unit tests do not rely on any other test or object. It's perfectly fine to set up an environment that has all the preconditions you need for your unit test, but none of this setup should be accidental. For instance, you shouldn't accidentally test other objects or depend on the order in which your tests are executed.</p>
			<p>When you write a unit test, it's not uncommon to create instances of models that are stored in an array to represent a dummy database or fake REST APIs. Creating such a list of dummy data is done to ensure that a unit test does not fail due to external factors such as a network error. If your test should depend on certain external<a id="_idTextAnchor587"/> factors, you are probably writing an <strong class="bold">integrati<a id="_idTextAnchor588"/>on test</strong>.</p>
			<h4>Integration tests</h4>
			<p>An integration test ensures that a certain part of your code can integrate with other components of <a id="_idIndexMarker989"/>the system. Similar to unit tests, an integration test should never rely on other tests. This is important for any test you write. Whenever a test depends on certain preconditions, they must be set up within the test itself. If your test does depend on other tests, this dependency might not be obvious at first, but it can make your tests fail in weird and unexpected ways.</p>
			<p>Because no test can depend on another test, integration tests require a little more setup than unit tests. For example, you might want to set up an API helper, fetch some data from the API, and feed it into a database. A test such as this verifies that the API helper can cooperate with the database layer. Both layers should have their separate unit tests to ensure they <a id="_idIndexMarker990"/>work in isolation while the integration test ensures that the database and API can work together. There are many other types of tests that you can write or learn about, but for now, integration tests and unit tests provide an excellent start<a id="_idTextAnchor589"/><a id="_idTextAnchor590"/><a id="_idTextAnchor591"/>ing point.</p>
			<h3>Isolating tests</h3>
			<p>Assumptions are a considerable risk when you're testing. Any time you assume anything about the <a id="_idIndexMarker991"/>environment you're testing in, your test is not reliable. If you're just getting into writing tests, it's tempting to make assumptions such as <em class="italic">I'm testing on the simulator and my test user is always logged in so my tests can be written under the assumption that a logged-in user exists</em>. This assumption makes a lot of sense to a lot of people, but what if one of your tests logs the current user out?</p>
			<p>When this happens, a lot of your tests will fail due to assumptions that you made about the test environment. More importantly, these tests might fail even if the code they're testing works flawlessly.</p>
			<p>As mentioned before, tests should test a single thing in your app. They should rely on as little outside code as possible, and they should be properly focused. A typical pattern that people use to structure their tests and improve reliability is the 3-As or AAA approach. The name of this pattern is short for Arrange, Act, and<a id="_idTextAnchor592"/> Assert. The following is an explanation<a id="_idTextAnchor593"/> of each <em class="italic">A</em>.</p>
			<h4>Arrange</h4>
			<p>The arrange step is all about preparation. Make sure a logged-in user exists, populate the (in-memory) database, and create instances of your fake API or other helpers. You essentially arrange <a id="_idIndexMarker992"/>everything to be in place for your testing environment. Note that this step should not involve too much setup. If you find yourself writing a lot of code in the arrange step, your test might be too broad. Or the code you're testing relies on too many other pieces of code. You can't always avoid this, but if it happens, make sure you consider refactoring your code and test to keep the quality on <a id="_idTextAnchor594"/>par with what you're trying<a id="_idTextAnchor595"/> to achieve.</p>
			<h4>Act</h4>
			<p>In the act step, you set <a id="_idIndexMarker993"/>everything for your test in motion. You call methods on the object you're testing, you feed it data, and you manipulate it. This is where you take your code for a proverbial spin. Don't perform too many actions in succession though; too many actions will lead to problems during the next s<a id="_idTextAnchor596"/><a id="_idTextAnchor597"/><a id="_idTextAnchor598"/>tep, assert.</p>
			<h4>Assert</h4>
			<p>The final A in the 3-As approach is assert. During the assert step, you make sure that the state of the <a id="_idIndexMarker994"/>object you're testing is as you'd expect. Act and assert can be used multiple times in a single test. For instance, you might want to assert that doing something once places the object in a particular state and that doing it again places the object in another state. Or possibly that the state stays the same. Just as with the other two steps, if you're asserting a lot of things, or if you're acting and asserting over and over again in a test, the chances are that your test is too broad. This can't always be avoided, but long tests with a lot of acting and asserting are often an indication of testing too much at once.</p>
			<p>Reading about testing can be quite dull, and it tends to get abstract quickly, so let's leave the theory for now. You will set up a test suite for an existing project in Xcode and start writing some tests, so all of the information you've taken in s<a id="_idTextAnchor599"/>o far becomes a bit <a id="_idTextAnchor600"/>more tangible.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor601"/>Setting up a test suite with XCTest</h2>
			<p>In this section, you'll work on a test <a id="_idIndexMarker995"/>suite for a new app: <strong class="bold">MovieTrivia</strong>. You'll find <a id="_idIndexMarker996"/>the basic setup for this project in this book's code bundle. If you open the project, there are some view controllers, an <strong class="source-inline">Info.plist</strong> file, and all the other files you would normally expect to find in a project. There's <a id="_idIndexMarker997"/>also a JSON file in the project named <strong class="source-inline">TriviaQuestions.json</strong>. This file contains a couple of dummy questions that you can load by uncommenting a bit of code in <strong class="source-inline">LoadTriviaViewController.swift</strong>.</p>
			<p>By default, <strong class="source-inline">LoadTriviaViewController.swift</strong> attempts to load questions from a non-existing web server. This is intentional, to demonstrate how one would normally set up a project like this. Since you don't have a web server at your disposal right now, you can swap out the dummy networking code for the JSON file to test this app.</p>
			<p>Before you write tests or perform any optimization, you must add a test target to the project. You add a test target in the same way you added extensions before. The only difference is that you select a different type of target. When adding a test target, you should pick the <strong class="bold">iOS Unit Testing Bundle</strong> template. The following screenshot shows the correct template you should select:</p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/Figure_19.01_B14717.jpg" alt="Figure 19.1 – Adding a unit testing target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.1 – Adding a unit testing target</p>
			<p>After adding the target, Xcode adds a new folder to your project. If you choose the default <a id="_idIndexMarker998"/>name for the test target, it's called <strong class="source-inline">MovieTriviaTests</strong>. You should add all the tests you write for this project to the test target.</p>
			<p>If you think <a id="_idIndexMarker999"/>about when you used files in multiple targets with extensions, you might expect that you would need to add all of the files you want to write tests for to both of the targets. Fortunately, this isn't the case. When you write tests, you can import the entire app as a testable target, enabling you to write tests for all of the code in the app target.</p>
			<p>If you look inside the <strong class="source-inline">MovieTriviaTests</strong> folder that Xcode created when you added the unit test target, you'll find a single file called <strong class="source-inline">MovieTriviaTests.swift</strong>. This file contains a couple of hints about what tests should look like for your test suite. First of all, note that the test class inherits from <strong class="source-inline">XCTestCase</strong>. All of your test classes should inherit from this <strong class="source-inline">XCTestCase</strong> so they can be iden<a id="_idTextAnchor602"/>tified as a test.</p>
			<p>One of the methods you'll find in the test template is the <strong class="source-inline">setUp()</strong> method. This method is executed before every test in the file and helps you to fulfill the first stage of the AAA pattern in testing: Arrange. You use this method to ensure that all of the preconditions for your test are met. You could make sure that your user is logged in or that your database is populated with test data. Of course, the depth of your setup in this method depends on the unit of code for which you're writing a test.</p>
			<p>Also, note that there are two methods prefixed with <strong class="source-inline">test</strong> in the <strong class="source-inline">test</strong> class. These methods are executed as tests, and they are expected to perform the act and assert steps. The majority <a id="_idIndexMarker1000"/>of the work should be performed in <a id="_idIndexMarker1001"/>these test methods. Do note that it's often better to have multiple short test methods rather than a single test method that tests everything. The larger the methods, the harder it will be to maintain and debug your tests.</p>
			<p>Finally, you'll find a <strong class="source-inline">tearDown()</strong> method. This method is intended to give you an opportunity to clean up after yourself. When you have inserted dummy data into your database, it's often desirable to remove this data when your tests have been completed. This will ensure a clean slate for the next test that runs, and it minimizes the chances of your first test accidentally influencing the second test that runs. As mentioned before, tests should never depend on other tests. This means that you also don't want to pollute other tests by leaving traces of previous tests.</p>
			<p>Note that <strong class="source-inline">setUp()</strong> and <strong class="source-inline">tearDown()</strong> should be specific to the unit you're testing. This means that you can't put all of your tests in a single class. Separating tests into several classes is a good thing. You should create a test class for every unit of code that you're testing. One test class should typically not test more than a single class or struct in your app. If you're writing an integration test, there might be more than one class involved in the test, but you should still make sure that you're only testing a single thing, which is the integration between the classes involved in the integration you're testing.</p>
			<p>Now that you have a test suite in place, let's see how you can write tests for the existing code in the <strong class="bold">MovieTrivia</strong> app and how the app can be re<a id="_idTextAnchor603"/>factored to be t<a id="_idTextAnchor604"/>ested appropriately.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor605"/>Optimizing code for testability</h1>
			<p>Now that <a id="_idIndexMarker1002"/>the project has a test target, it's time to start adding some tests to it. Before you add tests, you should determine what to test. Take some time to look at the app and the code and try to think of things to test. Assume <a id="_idIndexMarker1003"/>that the app is finished and that the trivia questions are loaded from a server.</p>
			<p>Some of the things you might have thought of to test are the following:</p>
			<ul>
				<li>Making sure that we can display the data we load from the network </li>
				<li>Testing that selecting the correct answer triggers the expected code </li>
				<li>Testing that choosing a wrong answer triggers the expected code </li>
				<li>Ensuring that the first question is displayed after we show the last one </li>
				<li>Testing that the question index increments</li>
			</ul>
			<p>If you came up with most of the tests on this list, good job. You've successfully identified a lot of good test cases. But how do you test these cases? The project has been made hard to test intentionally, but let's see what tests can be written without refactoring the app right away.</p>
			<p>Remove the <a id="_idIndexMarker1004"/>test class that Xcode has generated for you and create a new one called <strong class="source-inline">LoadQuestionsTest</strong>. Use the following bit of boilerplate code in this file's implementation as a starting point for the tests:</p>
			<p class="source-code">import XCTest</p>
			<p class="source-code">@testable import MovieTrivia</p>
			<p class="source-code">typealias JSON = [String: Any]</p>
			<p class="source-code">class LoadQuestionsTest: XCTestCase {</p>
			<p class="source-code">  override func setUp() {</p>
			<p class="source-code">    super.setUp()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  func testLoadQuestions() {</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Note the <strong class="source-inline">@testable</strong> import <strong class="source-inline">MovieTrivia</strong> line at the top of the file. This line imports the entire app target so you can access it in your tests. Before you implement the test body for <strong class="source-inline">testLoadQuestions</strong>, it's wise to think about what this method should test. If you look at the code in the app target, the trivia questions are loaded in the <strong class="source-inline">viewDidAppear(_:)</strong> method of <strong class="source-inline">LoadTriviaViewController</strong>. Once the questions are loaded, the app moves on to the next screen. An important detail is that the <strong class="source-inline">triviaJSON</strong> property on <strong class="source-inline">LoadTriviaViewController</strong> is set once the<a id="_idTextAnchor606"/> questions are loaded. </p>
			<p>Based on this information, you could write a test that creates an instance of <strong class="source-inline">LoadTriviaViewController</strong>, makes it appear, so the questions will load, and then waits until <strong class="source-inline">triviaJSON</strong> has a value to verify that the questions were successfully loaded. Writing a test <a id="_idIndexMarker1005"/>that fits this description would involve many moving parts, way more than you should be comfortable with. <strong class="source-inline">MovieTrivia</strong> uses storyboards, so to obtain an instance of <strong class="source-inline">LoadTriviaViewController</strong>, the storyboard would have to be involved. This means that any changes or mistakes in the user interface would cause the logic test that checks whether data is loaded to fail. This is not desirable because this test should only verify whether it's possible to load data, not whether the user interface updates once the load completes.</p>
			<p>This is a great moment to start refactoring some code and make it more testable. The first piece of code that should be revamped for testabilit<a id="_idTextAnchor607"/>y is th<a id="_idTextAnchor608"/>e question-loading code.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor609"/>Introducing the question loader</h2>
			<p>To make <strong class="source-inline">MovieTrivia</strong> more testable, you should create a special helper that can load questions. The helper <a id="_idIndexMarker1006"/>will go to the network and fetch the questions. Once the data is loaded, a callback is called to notify the object that initiated the request about the loaded questions. Because you already know that you're going to write tests for the new helper, you should think of a way to make sure that the helper works with both an offline and an online implementation, so the tests don't have to depend on an internet connection to work.</p>
			<p>Because tests should rely on as few outside factors as possible, removing the networking layer from this test would be great. This means that the helper needs to be split into two parts. One part is the helper itself. The other part would be a data fetcher. The data fetcher should conform to a protocol that defines the interface that a data fetcher must have, so you can choose to inject either an online or offline fetcher into the helper.</p>
			<p>If the preceding explanation seems a little bit abstract and confusing to you, that's OK. The following <a id="_idIndexMarker1007"/>code samples will show you the process of separating the different helpers step by step. Add a new Swift file to the application target and call it <strong class="source-inline">QuestionsLoader.swift</strong>. Then add the following implementation to it:</p>
			<p class="source-code">typealias JSON = [String: Any]</p>
			<p class="source-code">typealias QuestionsLoadedCallback = (JSON) -&gt; Void</p>
			<p class="source-code">struct QuestionsLoader {</p>
			<p class="source-code">  func loadQuestions(callback: @escaping </p>
			<p class="source-code">   QuestionsLoadedCallback) {</p>
			<p class="source-code">    guard let url = URL(string: </p>
			<p class="source-code">      "http://questions.movietrivia.json")</p>
			<p class="source-code">      else { return }</p>
			<p class="source-code">    URLSession.shared.dataTask(with: url) { data, response,</p>
			<p class="source-code">     error in guard let data = data, let jsonObject = try? </p>
			<p class="source-code">      JSONSerialization.jsonObject(with: data, options: </p>
			<p class="source-code">       []), let json = jsonObject as? JSON</p>
			<p class="source-code">    else { return }</p>
			<p class="source-code">    callback(json)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This struct defines a method to load questions with a callback. This is already nice and a lot more testable than before. You can now isolate the question loader and test it separated from the rest of the app. A test for the helper in its current state would look like the test shown in the following code snippet:</p>
			<p class="source-code">func testLoadQuestions() {</p>
			<p class="source-code">  let questionsLoader = QuestionsLoader()</p>
			<p class="source-code">  let questionsLoadedExpectation = expectation(description: </p>
			<p class="source-code">    "Expected the questions to be loaded")</p>
			<p class="source-code">  questionsLoader.loadQuestions { _ in</p>
			<p class="source-code">    questionsLoadedExpectation.fulfill()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  waitForExpectations(timeout: 5, handler: nil)</p>
			<p class="source-code">}</p>
			<p>The preceding test creates an instance of <strong class="source-inline">QuestionLoader</strong> and sets up an expectation. An expectation is used when you expect something to happen in your test eventually. Since <strong class="source-inline">QuestionLoader</strong> loads its questions asynchronously, you can't expect the questions to be loaded by the time this test method is done executing. The callback that's called when the questions are loaded is used to fulfill the expectation in this test. To make sure that the test waits for the expectation to be fulfilled, <strong class="source-inline">waitForExpectations(timeout:handler:)</strong> is called after <strong class="source-inline">loadQuestions(callback:)</strong>. If the expectation isn't fulfilled within the 5-second timeout that is specified, the test fails.</p>
			<p>Examine this <a id="_idIndexMarker1008"/>test closely; you should be able to see all of the As (Arrange, Act, Assert) that you read about earlier. The first A, arrange, is where the loader and expectation are created. The second A, act, is when <strong class="source-inline">loadQuestions(callback:)</strong> is called. The final A, assert, is inside the callback. This test doesn't validate whether the data passed to the callback is valid, bu<a id="_idTextAnchor610"/>t you'll get to that later.</p>
			<p>Separating the loader into its own object is great but it still has one problem. There is no way to configure whether it loads data from a local file or the network. In a production environment, the question loader would load data from the network, which would make the test for the question loader depend on the network as well.</p>
			<p>This isn't ideal because a test that depends on the network might fail for reasons you can't control.</p>
			<p>This can be improved by utilizing some protocol-oriented programming and the dependency-injection pattern. This means that you should define a protocol that defines the public API for a networking layer. Then you should implement a networking object in the app target <a id="_idIndexMarker1009"/>that conforms to the protocol. <strong class="source-inline">QuestionsLoader</strong> should have a property that holds anything that conforms to the networking protocol. The test target should have its own object that conforms to the networking protocol so you can use that object to provide <strong class="source-inline">QuestionsLoader</strong> with mock data.</p>
			<p>By setting the test up like this, you can take the entire networking logic out of the equation and arrange tests in such a way that the networking doesn't matter. The mock networking layer will respond with valid, reliable <a id="_idTextAnchor611"/>responses tha<a id="_idTextAnchor612"/>t can be used as test input.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor613"/>Mocking API responses</h2>
			<p>It's common <a id="_idIndexMarker1010"/>practice to mock API responses when you're testing. In this segment, you will implement the mock API that was described before to improve the quality and reliability of the <strong class="source-inline">MovieTrivia</strong> test suite. Follow these steps to create a mock response to test your API:</p>
			<ol>
				<li>First, let's define the networking protocol. Create a new file in the app target and name it <strong class="source-inline">TriviaAPIProviding</strong>:<p class="source-code">typealias QuestionsFetchedCallback = (JSON) -&gt; Void</p><p class="source-code">protocol TriviaAPIProviding {</p><p class="source-code">  func loadTriviaQuestions(callback: @escaping </p><p class="source-code">    QuestionsFetchedCallback)</p><p class="source-code">}</p><p>The protocol only requires a single method. If you want to expand this app later, everything related to the Trivia API must be added to the protocol to make sure that you can create both an online version of your app and an offline version for your tests. </p></li>
				<li>Next, create <a id="_idIndexMarker1011"/>a file named <strong class="source-inline">TriviaAPI</strong> and add the following implementation to it:<p class="source-code">struct TriviaAPI: TriviaAPIProviding {</p><p class="source-code">  func loadTriviaQuestions(callback: @escaping </p><p class="source-code">    QuestionsFetchedCallback) {</p><p class="source-code">    guard let url = URL(string: </p><p class="source-code">      "http://questions.movietrivia.json")</p><p class="source-code">      else { return }</p><p class="source-code">    URLSession.shared.dataTask(with: url) { data, </p><p class="source-code">     response, error in guard let data = data, let </p><p class="source-code">       jsonObject = try? JSONSerialization.jsonObject(</p><p class="source-code">        with: data, options: []), let json = </p><p class="source-code">         jsonObject as? JSON</p><p class="source-code">      else { return }</p><p class="source-code">      callback(json)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Lastly, update the <strong class="source-inline">QuestionsLoader</strong> struct with the following implementation:<p class="source-code">struct QuestionsLoader {</p><p class="source-code">  let apiProvider: TriviaAPIProviding</p><p class="source-code">  func loadQuestions(callback: @escaping </p><p class="source-code">    QuestionsLoadedCallback) {</p><p class="source-code">    apiProvider.loadTriviaQuestions(callback: </p><p class="source-code">      callback)</p><p class="source-code">  }</p><p class="source-code">}</p><p>The question <a id="_idIndexMarker1012"/>loader now has an <strong class="source-inline">apiProvider</strong> that it uses to load questions. Currently, it delegates any load call over to its API provider, but you'll update this code soon to make sure that it converts the raw JSON data that the API returns to question models.</p></li>
				<li>Update the <strong class="source-inline">viewDidAppear(_:)</strong> method of <strong class="source-inline">LoadTriviaViewController</strong> as shown in the following code snippet. This implementation uses the loader struct instead of directly loading the d<a id="_idTextAnchor614"/>ata inside the view controller:<p class="source-code">override func viewDidAppear(_ animated: Bool) {</p><p class="source-code">  super.viewDidAppear(animated)</p><p class="source-code">  let apiProvider = TriviaAPI()</p><p class="source-code">  let questionsLoader = QuestionsLoader(apiProvider: </p><p class="source-code">    apiProvider)</p><p class="source-code">  questionsLoader.loadQuestions { [weak self] json in</p><p class="source-code">    self?.triviaJSON = json</p><p class="source-code">    self?.performSegue(withIdentifier: </p><p class="source-code">      "TriviaLoadedSegue", sender: self)</p><p class="source-code">  }</p><p class="source-code">}</p><p>The preceding code is not only more testable but also a lot cleaner. The next step is to create the mock API in the test target so you can use it to provide the question loader with data.</p><p>The JSON file in the app target should be removed from the app target and added to the test target. You can leave it in the app folder but make sure to update the <strong class="source-inline">Target Membership</strong> so the JSON file is only available in the test target. </p></li>
				<li>Now add a <a id="_idIndexMarker1013"/>new Swift file named <strong class="source-inline">MockTriviaAPI</strong> to the test target and add the following code to it:<p class="source-code">@testable import MovieTrivia</p><p class="source-code">struct MockTriviaAPI: TriviaAPIProviding {</p><p class="source-code">  func loadTriviaQuestions(callback: @escaping </p><p class="source-code">   QuestionsFetchedCallback) {</p><p class="source-code">    guard let filename = Bundle(for: </p><p class="source-code">     LoadQuestionsTest.self).path(forResource: </p><p class="source-code">      "TriviaQuestions", ofType: "json"), let </p><p class="source-code">       triviaString = try? String(contentsOfFile: </p><p class="source-code">       filename), let triviaData = triviaString.data(</p><p class="source-code">       using: .utf8), let jsonObject = try? </p><p class="source-code">       JSONSerialization.jsonObject(with: triviaData,</p><p class="source-code">        options: []), let triviaJSON = jsonObject </p><p class="source-code">         as? JSON</p><p class="source-code">    else { return }</p><p class="source-code">    callback(triviaJSON)</p><p class="source-code">  }</p><p class="source-code">}</p><p>This code fetches the locally stored JSON file from the test bundle. To determine the location of the JSON file, one of the test classes is used to retrieve the current bundle. This is not the absolute best way to retrieve a bundle because it relies on an external factor to exist in the test target. However, structs can't be used to look up the current bundle. Luckily, the compiler will throw an error if the class that is used to determine the bundle is removed so the compiler would quickly error and the mistake can be fixed. After loading the file, the callback is called, and the request has been successfully handled. </p></li>
				<li>Now update <a id="_idIndexMarker1014"/>the test in <strong class="source-inline">LoadQuestionsTest</strong> so it uses the mock API as follows:<p class="source-code">func testLoadQuestions() {</p><p class="source-code">  let mockApi = MockTriviaAPI()</p><p class="source-code">  let questionsLoader = QuestionsLoader(apiProvider: </p><p class="source-code">    mockApi)</p><p class="source-code">  let questionsLoadedExpectation = </p><p class="source-code">   expectation(description: "Expected the questions</p><p class="source-code">     to be loaded")</p><p class="source-code">  questionsLoader.loadQuestions { _ in</p><p class="source-code">    questionsLoadedExpectation.fulfill()</p><p class="source-code">  }</p><p class="source-code">  waitForExpectations(timeout: 5, handler: nil)</p><p class="source-code">}</p></li>
			</ol>
			<p>Let's summarize what we have done here: We have defined our API as a protocol. By doing that and with dependency injection, we are now capable of creating a mock class to test the API. As long as our mock class conforms to that protocol, we can inject it anywhere we need the API.</p>
			<p>A lot of apps have way more complex interactions than the one you're testing now. When you get to implementing more complex scenarios, the main ideas about how to architect your app and tests remain the same, regardless of application complexity.</p>
			<p>Protocols can be used to define a common interface for certain objects. Combining this with dependency-injection as you did for <strong class="source-inline">QuestionsLoader</strong> helps to isolate the pieces of your code that you're testing, and it enables you to swap out pieces of code to make sure that you don't rely on external factors if you don't have to.</p>
			<p>So far, the test suite <a id="_idIndexMarker1015"/>is not particularly useful. The only thing that's tested at this point is whether <strong class="source-inline">QuestionsLoader</strong> passes requests on to the <strong class="source-inline">TriviaAPIProviding</strong> object and whether the callbacks are called as expected. Even though this technically qualifies as a test, it's much better also to test whether the loader object can convert the loaded data into question objects that the app can display.</p>
			<p>Testing whether <strong class="source-inline">QuestionsLoader</strong> can convert JSON into a <strong class="source-inline">Question</strong> model is a test that's a lot more interesting than just testing whether the callback is called. A refactor such as this might make you wonder whether you should add a new test or modify the existing test.</p>
			<p>If you choose to add a new test, your test suite will cover a simple case where you only test that the callback is called and a more complex case that ensures the loader can convert JSON data to models. When you update the existing test, you end up with a test that validates two things. It will make sure that the callback is called but also that the data is converted to models.</p>
			<p>While the implications for both choices are similar, the second-choice sort of assumes that the callback will be called. You always want to limit your assumptions when writing tests and there's no harm in adding more tests when you add more features. However, if the callback does not get called, none of the tests will work. So, in this case, you can work with a single test that makes sure the callback is called and that the loader returns the expected models.</p>
			<p>The test you should end up with will have a single expectation and multiple assertions. Writing the test like this makes sure that the expectation of the callback is fulfilled when the callback is called, and at the same time you can use assertions to ensure that the data that's passed to the callback is valid and correct.</p>
			<p>By making <strong class="source-inline">QuestionsLoader</strong> create instances of a <strong class="source-inline">Question</strong> model rather than using it to return a dictionary of JSON data, it not only makes the test more interesting but also improves the <a id="_idIndexMarker1016"/><a id="_idTextAnchor615"/>app code by making it a lot cleaner. Right now, the app uses a dictionary of JSON data to display questions. If the JSON changes, you would have to update the view controller's code. If the app grows, you might be using the JSON data in multiple places, making the process of updating quite painful and error-prone. This is why it's a much better idea to use the <strong class="source-inline">Codable</strong> protocol to convert raw API responses to <strong class="source-inline">Question</strong> models. Using <strong class="source-inline">Codable</strong> objects means you can get rid of the JSON dictionaries in t<a id="_idTextAnchor616"/>he view contro<a id="_idTextAnchor617"/>llers, which is a vast improvement.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor618"/>Using models for consistency</h2>
			<p>Adding a question model to <strong class="source-inline">MovieTrivia</strong> involves quite a bit of refactoring. First, you must <a id="_idIndexMarker1017"/>define the <strong class="source-inline">Question</strong> model. Let's create and make use of our models instead of using JSON structs around the code. Follow these steps:</p>
			<ol>
				<li value="1">Create a new Swift file named <strong class="source-inline">Question</strong> and add the following implementation to it:<p class="source-code">struct Question: Codable {</p><p class="source-code">  let title: String</p><p class="source-code">  let answerA: String</p><p class="source-code">  let answerB: String</p><p class="source-code">  let answerC: String</p><p class="source-code">  let correctAnswer: Int</p><p class="source-code">}</p><p>The <strong class="source-inline">Question</strong> struct conforms to the <strong class="source-inline">Codable</strong> protocol. </p></li>
				<li>Since the dummy JSON data contains a list of questions, you'll want to define a <strong class="source-inline">Codable</strong> object that contains the response as well:<p class="source-code">struct QuestionsFetchResponse: Codable {</p><p class="source-code">  let questions: [Question]</p><p class="source-code">}</p><p>Now that the <strong class="source-inline">Question</strong> model and the response container are in place, a couple of changes must be made to the existing code. </p></li>
				<li>Modify the <strong class="source-inline">typealias</strong> in the <strong class="source-inline">TriviaAPIProviding</strong> protocol as follows:<p class="source-code">typealias QuestionsFetchedCallback = (Data) -&gt; Void</p></li>
				<li>Next, update <a id="_idIndexMarker1018"/>the implementation of the <strong class="source-inline">TriviaAPI</strong> for the <strong class="source-inline">URLSession</strong> callback in <strong class="source-inline">loadTriviaQuestions(callback:)</strong> as follows:<p class="source-code">URLSession.shared.dataTask(with: url) { data, </p><p class="source-code">  response, error in guard let data = data</p><p class="source-code">  else { return }</p><p class="source-code">  callback(data)</p><p class="source-code">}</p></li>
				<li>Also, update <strong class="source-inline">MockTriviaApi</strong> so it executes its callback with data instead of a JSON dictionary:<p class="source-code">func loadTriviaQuestions(callback: @escaping QuestionsFetchedCallback) {</p><p class="source-code">  guard let filename = Bundle(for: </p><p class="source-code">   LoadQuestionsTest.self).path(forResource: </p><p class="source-code">   "TriviaQuestions", ofType: "json"), let </p><p class="source-code">    triviaString = try? String(contentsOfFile: </p><p class="source-code">    filename), let triviaData = triviaString.data(</p><p class="source-code">      using: .utf8)</p><p class="source-code">  else { return }</p><p class="source-code">  callback(triviaData)</p><p class="source-code">}</p></li>
				<li>Update the <strong class="source-inline">QuestionsLoadedCallback</strong>  <strong class="source-inline">typealias</strong> in <strong class="source-inline">QuestionsLoader</strong> to the following definition:<p class="source-code">typealias QuestionsLoadedCallback = ([Question]) -&gt; Void</p></li>
				<li>And lastly, update <a id="_idIndexMarker1019"/>the implementation for <strong class="source-inline">loadQuestions(callback:)</strong> as follows:<p class="source-code">func loadQuestions(callback: @escaping </p><p class="source-code">  QuestionsLoadedCallback) { </p><p class="source-code">   apiProvider.loadTriviaQuestions { data in</p><p class="source-code">  let decoder = JSONDecoder() </p><p class="source-code">   decoder.keyDecodingStrategy = .convertFromSnakeCase</p><p class="source-code">  guard let questionsResponse = try?</p><p class="source-code">  decoder.decode(QuestionsFetchResponse.self,</p><p class="source-code">    from: data)</p><p class="source-code">    else { return }</p><p class="source-code">  callback(questionsResponse.questions)</p><p class="source-code">  }</p><p class="source-code">}</p><p>This wraps up the changes for the API. However, there still is some refactoring to be done in the view controllers. </p></li>
				<li>Rename the <strong class="source-inline">triviaJSON</strong> property on <strong class="source-inline">LoadTriviaViewController</strong> to the<a id="_idTextAnchor619"/> following:<p class="source-code">var questions: [Question]?</p><p>Make sure you replace all occurrences of <strong class="source-inline">triviaJSON</strong> with the new <strong class="source-inline">questions</strong> array. Also, make sure you change the following line in <strong class="source-inline">prepare(for:sender:)</strong>:</p><p class="source-code">questionViewController.triviaJSON = triviaJSON</p></li>
				<li>Change the preceding line to this:<p class="source-code">questionViewController.questions = questions</p></li>
				<li>In <strong class="source-inline">QuestionViewController</strong>, change the type of <strong class="source-inline">questions</strong> to <strong class="source-inline">[Question]</strong> and remove the <strong class="source-inline">triviaJSON</strong> property. </li>
			</ol>
			<p>At this point, you can clear all of the JSON-related code from the guards in this class. You should be <a id="_idIndexMarker1020"/>able to do this on your own since the compiler should guide you with errors. If you get stuck, look at the finished project in the code bundle.</p>
			<p>By now, you should be able to run the tests, and they should pass. To run your tests, click the <strong class="bold">Product</strong> menu item and select <strong class="bold">Test</strong>. Alternatively, press <em class="italic">Cmd</em> + <em class="italic">U</em> to run your tests. The tests run fine, but currently, the test doesn't test whether all of the questions in the JSON data got converted to <strong class="source-inline">Question</strong> models. To make sure this conversion worked, you can load the JSON file in the test, count the number of questions in the JSON file, and assert that it matches the number of questions in the callback.</p>
			<p>Update the <strong class="source-inline">testLoadQuestions()</strong> method as shown in the following code snippet:</p>
			<p class="source-code">func testLoadQuestions() {</p>
			<p class="source-code">  let apiProvider = MockTriviaAPI()</p>
			<p class="source-code">  let questionsLoader = QuestionsLoader(apiProvider: </p>
			<p class="source-code">    apiProvider)</p>
			<p class="source-code">  let questionsLoadedExpectation = expectation(</p>
			<p class="source-code">    description: "Expected the questions to be loaded")</p>
			<p class="source-code">  questionsLoader.loadQuestions { questions in</p>
			<p class="source-code">    guard let filename = Bundle(for: LoadQuestionsTest.self).</p>
			<p class="source-code">  path(forResource: "TriviaQuestions", ofType: "json"),</p>
			<p class="source-code">      let triviaString = try? String(contentsOfFile: </p>
			<p class="source-code">        filename),</p>
			<p class="source-code">      let triviaData = triviaString.data(using: .utf8),</p>
			<p class="source-code">      let jsonObject = try? </p>
			<p class="source-code">        JSONSerialization.jsonObject(with: triviaData, </p>
			<p class="source-code">          options: []),</p>
			<p class="source-code">      let triviaJSON = jsonObject as? JSON,</p>
			<p class="source-code">      let jsonQuestions = triviaJSON["questions"] </p>
			<p class="source-code">       as? [JSON]</p>
			<p class="source-code">    else { return }</p>
			<p class="source-code">    XCTAssert(questions.count &gt; 0, "More than 0 questions</p>
			<p class="source-code">      should be passed to the callback")</p>
			<p class="source-code">    XCTAssert(jsonQuestions.count == questions.count, </p>
			<p class="source-code">     "Number of questions in json must match the number</p>
			<p class="source-code">       of questions in the callback.")</p>
			<p class="source-code">    questionsLoadedExpectation.fulfill()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  waitForExpectations(timeout: 5, handler: nil)</p>
			<p class="source-code">}</p>
			<p>This test <a id="_idIndexMarker1021"/>loads the dummy JSON file and uses <strong class="source-inline">XCTAssert</strong> to make sure that more than zero questions were passed to the callback and that the number of questions in the JSON file matches the number of questions that were loaded.</p>
			<p><strong class="source-inline">XCTAssert</strong> takes a Boolean expression and a description. If the assertion fails, the description is shown. Adding good descriptions will help you to quickly figure out which assertion in your test has made your test fail.</p>
			<p>This new version of the load-questions test is a small addition to the test suite but has vast consequences. By improving the test suite, you have improved the quality of the app because <a id="_idIndexMarker1022"/>you can now prove that the question loader correctly transforms JSON into model objects. By adding model objects, you have improved the code in the view controllers as well. Instead of reading raw JSON, you are now reading properties from a model. And lastly, these changes have made your view controllers a lot cleaner.</p>
			<p>In this section, you have learned how to create and use your own data models through your code. By doing so, your code is more consistent and easier to test (and maintain).</p>
			<p>One more metric that has improved by refactoring your code is the amount of code that is covered by the test suite. You can measure the percentage of code your test suite covers with Xcode's built-in code cover<a id="_idTextAnchor620"/>age tracking<a id="_idTextAnchor621"/>. You'll learn how to use this tool next.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor622"/>Gaining insights through code coverage</h1>
			<p>Code coverage is a tool in Xcode that is used to gain insights into how much of your code you are <a id="_idIndexMarker1023"/>testing with your test suite. It tells you exactly which parts of your code were executed during a test and which parts of your code were not. This is extremely useful because you can take focused action based on the information provided by code coverage. </p>
			<p>Follow these steps <a id="_idTextAnchor623"/>to enable the code coverage functionality:</p>
			<ol>
				<li value="1">To enable <strong class="bold">Code Coverage</strong>, open the scheme editor through the (<strong class="bold">Product</strong> | <strong class="bold">Scheme</strong>) menu:<div id="_idContainer214" class="IMG---Figure"><img src="image/Figure_19.02_B14717.jpg" alt="Figure 19.2 – Editing scheme&#13;&#10;"/></div><p class="figure-caption">Figure 19.2 – Editing scheme</p></li>
				<li>Select <strong class="bold">Test action</strong> and make <a id="_idIndexMarker1024"/>sure the <strong class="bold">Gather coverage</strong> checkbox on the <strong class="bold">Options</strong> tab is checked:<p class="figure-caption"> </p><div id="_idContainer215" class="IMG---Figure"><img src="image/Figure_19.03_B14717.jpg" alt="Figure 19.3 – Gather coverage option&#13;&#10;"/></div><p class="figure-caption">Figure 19.3 – Gather coverage option</p><p class="callout-heading">Tip</p><p class="callout">You can also press <em class="italic">Command + &lt;</em> to open the scheme editor quickly.</p></li>
				<li>After doing this, close the scheme editor and run your tests. <p>This time, Xcode will monitor which parts of your code were executed during this test, and which parts weren't. This information can give you some good insights into which parts of your code could use some more testing. </p></li>
				<li>To see the <a id="_idIndexMarker1025"/>coverage data, open the <strong class="bold">Report navigator</strong> in the left sidebar in Xcode. The rightmost icon in this sidebar represents the report navigator:</li>
			</ol>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/Figure_19.04_B14717.jpg" alt="Figure 19.4 – Coverage option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.4 – Coverage option</p>
			<p>There are several reports listed under your app name. If you select the <strong class="bold">Coverage </strong>report, the coverage report will open in the editor area in Xcode. You can see all the files in your app and the percentage of code in the file that's covered by your tests. The following screenshot shows coverage for the <strong class="bold">MovieTrivia</strong> app:</p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/Figure_19.05_B14717.jpg" alt="Figure 19.5 – Coverage details&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.5 – Coverage details</p>
			<p>The more a bar is filled, the more lines of code in that file or method were executed during your test. You'll notice that the <strong class="source-inline">AppDelegate.swift</strong> file is covered under the tests even though you haven't written any tests for it. The reason this happens is that the app must launch during the test to act as a host for the test suite. This means that parts of the code in <strong class="source-inline">AppDelegate.swift</strong> are actually executed during the test, and therefore Xcode considers it covered in the tests.</p>
			<p>You can see <a id="_idIndexMarker1026"/>which methods for a specific file were executed by clicking on the triangle next to the class name. This enables you to see exactly which parts of a file are tested and which parts aren't.</p>
			<p>One last feature of code coverage that's worth mentioning is inline code coverage. Inline code coverage will show you how often a specific block of code has been executed during testing. This will give you code coverage insights right next to your code, without having to navigate to the report navigator. To enable this feature, open up your Xcode preferences and navigate to the <strong class="bold">Text Editing</strong> tab. Check the <strong class="bold">Show iteration counts</strong> checkbox at the bottom of the tab. If you open a file now, you'll see the iteration count for your code on the right side of the editor window. </p>
			<p>The following screenshot shows the iteration count for the <strong class="source-inline">loadQuestions(callback:)</strong> metho<a id="_idTextAnchor624"/>d:</p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/Figure_19.06_B14717.jpg" alt="Figure 19.6 – Show iteration counts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.6 – Show iteration counts</p>
			<p>Even though code coverage is a great tool for gaining insights into your tests, you shouldn't let it influence you too much. Regularly check the code coverage for your app and look for methods that are untested and are either easy to write tests for or should be tested because they contain important logic. Code coverage is also great for discovering parts of your code that should be tested but are hard to test because they're nested deep inside a view controller or are otherwise hard to reach.</p>
			<p>You should always aim for as much code coverage as possible, but don't push yourself to reach 100%. Doing this will make you jump through all kinds of hoops, and you'll invest way more time in testing than you should. Not all paths in your code have to be tested. However, don't shy away from doing some refactoring. Proper testing helps you to avoid bugs and to structure your code better. Code coverage is just one extra tool in your tool belt to help identify which parts of your code could benefit from some tests.</p>
			<p>If you look <a id="_idIndexMarker1027"/>at the current state of the coverage in the <strong class="bold">MovieTrivia</strong> app, we're doing quite well. Most of the logic in the app is tested. The only parts that are not tested thoroughly are the view controllers. Testing view controllers and navigation flows with <strong class="source-inline">XCTest</strong> can be quite hard and tedious. Luckily, there is one last testing tool that<a id="_idTextAnchor625"/><a id="_idTextAnchor626"/> we'll discuss in this chapter: <strong class="source-inline">XCUITest</strong>.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor627"/>Testing the user interface with XCUITest</h1>
			<p>We have learned how to test your code and the logic behind it. In this section, we are going to learn <a id="_idIndexMarker1028"/>how to test the UI of your app with <strong class="bold">XCUITest</strong>. </p>
			<p>Knowing that <a id="_idIndexMarker1029"/>most of your app logic is covered with tests is great. What's not so great, however, is adding your view controllers <a id="_idIndexMarker1030"/>to your logic test. Luckily, you can use <strong class="source-inline">XCUITest</strong> to easily record and write tests that focus on the user interface of an app. <strong class="source-inline">XCUITest</strong> uses the accessibility features in iOS to gain access to the user interface of your app. This means that implementing user interface tests forces you to put at least a little bit of effort into accessibility for your applications. The better your app's accessibility is, the easier it will be to write UI Tests for.</p>
			<p><strong class="source-inline">XCUITest</strong> has two great features that we'll look at in greater detail. First of all, UI tests help you to enhance the accessibility of your apps. Secondly, it's easy to get started with UI testing because Xcode can record your tests while you navigate through your app. This can significantly benefit the amount of code that is covered by your test suite since code coverage also takes UI tests into account.</p>
			<p>Before we start recording our first UI test<a id="_idTextAnchor628"/><a id="_idTextAnchor629"/><a id="_idTextAnchor630"/>, let's have a quick look at accessibility. </p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor631"/>Making your app accessible to your tests</h2>
			<p>One of the lesser thoughts about features in iOS is accessibility. The design teams at Apple work <a id="_idIndexMarker1031"/>hard to ensure that iOS is accessible for everybody. This includes blind people and people with other disabilities that could somehow affect the user's ability to operate their iOS device.</p>
			<p>Just looking at the accessibility settings in the iOS Settings app makes it evident that this is a subject that Apple invests a lot of time in. If you're working on an app, Apple expects you to put in the same kind of effort. Doing this will be rewarded by more app downloads and if you're lucky, even a couple of great reviews. In their talk on iOS accessibility from WWDC 2015, Apple even mentioned that implementing accessibility features can be helpful if you ever want to be featured in the <em class="italic">App Store</em>. Only the best apps get featured by Apple, and if your app is accessible to all people, that significantly boosts your app's quality.</p>
			<p>A common myth surrounding accessibility is that it's hard to implement or that it takes a lot of time. Some people even go so far as to say that it looks ugly or gets in the way of beautiful design. None of this is entirely correct. Sure, making your app accessible requires some effort, but the UIKit framework is very helpful when it comes to accessibility. Using standard components and keeping your users in mind while you design your app will make sure that your app is both accessible and looks good.</p>
			<p>So, how does accessibility work on iOS? And how can we make sure our app is accessible? A fun way to experiment with this is to turn on <strong class="bold">VoiceOver</strong> on your device. Follow these steps to enable it:</p>
			<ol>
				<li value="1">To enable <strong class="bold">VoiceOver</strong>, go to the <strong class="bold">Accessibility</strong> menu. You'll find several vision-related accessibility settings. <strong class="bold">VoiceOver</strong> should be the topmost one. </li>
				<li>To quickly enable and disable <strong class="bold">VoiceOver</strong>, scroll all the way to the bottom of the settings page and select <strong class="bold">VoiceOver</strong> as your accessibility shortcut:<p class="figure-caption"><a id="_idTextAnchor632"/></p><div id="_idContainer219" class="IMG---Figure"><img src="image/Figure_19.07_B14717.jpg" alt="Figure 19.7 – Device Accessibility options&#13;&#10;"/></div><p class="figure-caption">Figure 19.7 – Device Accessibility options</p><p>This will allow you to toggle <strong class="bold">VoiceOver</strong> off and on by triple-clicking the home button or side button, depending on your device.</p></li>
				<li>After <a id="_idIndexMarker1032"/>enabling this, run the <strong class="bold">MovieTrivia</strong> app on your device and triple-click your home button or the side button to enable <strong class="bold">VoiceOver</strong>. </li>
				<li>Swipe around and try to use the app. </li>
			</ol>
			<p>This is how a person with a visual handicap would use your app. You won't get past the loading screen because the dummy questions aren't loaded, but you should find the splash screen to be pretty accessible, especially considering no special work had to be done to achieve this. UIKit uses great default settings to make sure your app will be accessible by default.</p>
			<p>You can <a id="_idIndexMarker1033"/>set your own accessibility information through the <strong class="bold">Identity Inspector</strong> in Interface Builder. You can add custom labels, hints, identifiers, and traits <a id="_idIndexMarker1034"/>to your interface to aid accessibility and, coincidentally, your UI tests. The following screenshot shows the <strong class="bold">Accessibility</strong> panel:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/Figure_19.08_B14717.jpg" alt="Figure 19.8 – Accessibility options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.8 – Accessibility options</p>
			<p>For most UIKit interface elements, you won't have to touch these settings yourself. UIKit will make sure that your objects have sensible defaults that automatically make your app accessible. Now that you have a little bit of background information about accessibility, let's have<a id="_idTextAnchor633"/><a id="_idTextAnchor634"/><a id="_idTextAnchor635"/> a look at testing the app's (accessible) UI. </p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor636"/>Recording UI tests</h2>
			<p>Before you can record UI tests, you must add a UI testing target to the project. Follow the same steps as before to add a new testing target but pick the iOS UI Testing Bundle this time around. If you look inside the newly created group in your project, the structure of your <a id="_idIndexMarker1035"/>UI tests looks very similar to the structure of unit tests.</p>
			<p>One significant difference between UI test targets and unit test targets is that your UI tests do not have access to any code that's inside your app. A UI test can only test the interface of your app and make assertions based on that.</p>
			<p>If you open the <strong class="source-inline">MovieTriviaUITest.swift</strong> file, you'll notice the <strong class="source-inline">setUpWithError ()</strong> and <strong class="source-inline">tearDown()</strong> methods. Also, all of the tests that must be executed are methods with the <strong class="source-inline">test</strong> prefix. This is all similar to what you've already seen for <strong class="source-inline">XCUITest</strong>.</p>
			<p>One big difference is that the app is launched explicitly in the setup stage. This is because the UI test target is essentially just a different app that can interact with your main app's interface. This limitation is very interesting, and it's also the reason why it's important to make your app accessible.</p>
			<p>To start recording a UI test in Xcode, you must start a recording session. If you're editing code in a UI test target, a new interface element is visible in the bottom-left corner of your code editor area:</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/Figure_19.09_B14717.jpg" alt="Figure 19.9 – Recording interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.9 – Recording interface</p>
			<p>Place your typing cursor inside the <strong class="source-inline">testExample()</strong> method and click the red dot. Your app is launched and anything you do is recorded as a UI test and played back when you run your tests. If you tap on the label and the activity indicator on the loading screen, Xcode produces t<a id="_idTextAnchor637"/>he following Swift code in the testing method:</p>
			<p class="source-code">let app = XCUIApplication()</p>
			<p class="source-code">app.staticTexts["Loading trivia questions..."].tap()</p>
			<p class="source-code">app.activityIndicators["In progress"].tap()</p>
			<p>The UI test you recorded is a set of instructions that are sent to the app. In this sample, the test looks for a certain element in the app's UI and calls <strong class="source-inline">tap()</strong> on it. This test doesn't do a lot, so it's not particularly useful. To make the test more useful, we should let the app know <a id="_idIndexMarker1036"/>that it should run in a special test mode so it can load questions from the JSON file instead of trying to load it from the network. To do this, you can send launch arguments to the app. Launch arguments can be used by the app to enable or disable certain functionalit<a id="_idTextAnchor638"/>ies. You can think of them as varia<a id="_idTextAnchor639"/>bles that are sent to the app when it launches.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor640"/>Passing launch arguments to your app</h2>
			<p>To switch the loading of questions from the network to a local file for testing, you can pass your <a id="_idIndexMarker1037"/>app a launch argument. This launch argument is then read by the app to make sure it loads questions from the JSON file, as you did before in the unit tests, rather than attempting to load trivia questions from the server.</p>
			<p>To prepare for the launch argument and loading the JSON file, make sure you add it to the test target, the app target, and the UI test target. You won't need it in the UI test target just yet, but you will later, so you might as well add it to the UI test target while you're at it.</p>
			<p>In order to pass launch arguments to the app, the <strong class="source-inline">setUpWithError()</strong> method in the UI test class should be modified:</p>
			<p class="source-code">override func setupWithError() {</p>
			<p class="source-code">  continueAfterFailure = false</p>
			<p class="source-code">  let app = XCUIApplication()</p>
			<p class="source-code">  app.launchArguments.append("isUITesting")</p>
			<p class="source-code">  app.launch()</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">XCUIApplication</strong> instance that represents the app has a <strong class="source-inline">launchArguments</strong> property, which is an array of strings. You can add strings to this array before launching the app. These strings can then be extracting inside of the app. Modify the <strong class="source-inline">loadTriviaQuestions(callback:)</strong> method in <strong class="source-inline">TriviaAPI.swift</strong> as shown in the following code snippet:</p>
			<p class="source-code">func loadTriviaQuestions(callback: @escaping </p>
			<p class="source-code">  QuestionsFetchedCallback) {</p>
			<p class="source-code">  if ProcessInfo.processInfo.arguments.contains(</p>
			<p class="source-code">    "isUITesting") {</p>
			<p class="source-code">    loadQuestionsFromFile(callback: callback)</p>
			<p class="source-code">    return</p>
			<p class="source-code">  }</p>
			<p class="source-code">  // existing implementation...</p>
			<p class="source-code">}</p>
			<p>The preceding code should be inserted above the existing implementation of this method. The snippet checks whether we're UI testing by reading the app's launch arguments. If the UI testing argument is present, we call the <strong class="source-inline">loadQuestionsFromFile(callback:)</strong> method to load the questions from the JSON file instead of loading it from the network.</p>
			<p>Note that it's <a id="_idIndexMarker1038"/>not ideal to perform checks such as the preceding one in your production code. It's often better to wrap a configuration such as this in a struct that can be modified easily. You can then use this struct throughout your app instead of directly accessing process info throughout your app. An example of such a configuration could look like this:</p>
			<p class="source-code">struct AppConfig {</p>
			<p class="source-code">  var isUITesting: Bool { </p>
			<p class="source-code">   ProcessInfo.processInfo.arguments.contains(</p>
			<p class="source-code">    "isUITesting")}</p>
			<p class="source-code">}</p>
			<p>We won't use this configuration class in this app since it's not needed for an app this small. But for your own apps, you might want to implement a configuration object regardless of app size since it leads to more maintainable code in the long run.</p>
			<p>If you build <a id="_idIndexMarker1039"/>the app right now, you should get a compiler error because <strong class="source-inline">loadQuestionsFromFile(callback:)</strong> is not implemented in the API class yet.<a id="_idTextAnchor641"/> Add the following implementation for this method:</p>
			<p class="source-code">func loadQuestionsFromFile(callback: @escaping </p>
			<p class="source-code">  QuestionsFetchedCallback) {</p>
			<p class="source-code">  guard let filename = Bundle.main.path(forResource: </p>
			<p class="source-code">   "TriviaQuestions", ofType: "json"), let triviaString = </p>
			<p class="source-code">    try? String(contentsOfFile: filename), let triviaData =</p>
			<p class="source-code">     triviaString.data(using: .utf8)</p>
			<p class="source-code">  else { return }</p>
			<p class="source-code">  callback(triviaData)</p>
			<p class="source-code">}</p>
			<p>It's very similar to the question-loading method in the unit tests; the only difference is that it uses a different way to obtain the bundle from which the questions are loaded.</p>
			<p>If you run your UI tests now, they will fail. The reason for this is that when the test framework starts looking for the elements it tapped before, they don't exist. This results in a test failure because the test can't tap elements that don't exist.</p>
			<p>The test should be adjusted a bit because tapping a loader isn't very useful anyway. It's a lot more useful to make sure that buttons can be tapped and whether the UI updates accordingly. To do this, you can write a UI test that waits for the question and buttons to appear, taps them, and checks whether the UI has updated accordingly. The dummy data wil<a id="_idTextAnchor642"/>l be loaded in this test as well to verify that the correct questi<a id="_idTextAnchor643"/>on is shown and the buttons behave as they should.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor644"/>Making sure the UI updates as expected</h2>
			<p>You're going <a id="_idIndexMarker1040"/>to write two tests to make sure that the trivia game works as expected. The first test will test that the question and the answer buttons appear and that they have the correct labels. The second test will make sure that the answers can be tapped and that the UI updates accordingly.</p>
			<p>Instead of recording the tests, you'll write them manually. Writing tests manually gives you a bit more control and allows you to do much more than just tapping on elements. Before you do this, you should open the <strong class="source-inline">Main.storyboard</strong> file and give accessibility identifiers <a id="_idIndexMarker1041"/>to the UI elements. Follow these steps to create a UI test manually:</p>
			<ol>
				<li value="1">Select the question title and give <strong class="source-inline">UILabel</strong> an identifier of <strong class="source-inline">QuestionTitle</strong>.</li>
				<li>Select each of the answers and give them the <strong class="source-inline">AnswerA</strong>, <strong class="source-inline">AnswerB</strong>, and <strong class="source-inline">AnswerC</strong> identifiers, respectively. </li>
				<li>Also, give the next button an accessibility identifier of <strong class="source-inline">NextQuestion</strong>. The following screenshot shows what the question title should look like:<p class="figure-caption"> </p><div id="_idContainer222" class="IMG---Figure"><img src="image/Figure_19.10_B14717.jpg" alt="Figure 19.10 – Accessibility identifiers&#13;&#10;"/></div><p class="figure-caption">Figure 19.10 – Accessibility identifiers</p></li>
				<li>Remove the existing UI test, called <strong class="source-inline">testExample()</strong>, from the <strong class="source-inline">MovieTriviaUITests</strong> class and add the one shown in the following code snippet:<p class="source-code">func testQuestionAppears() {</p><p class="source-code">  let app = XCUIApplication()</p><p class="source-code">  // 1</p><p class="source-code">  let buttonIdentifiers = ["AnswerA", "AnswerB", </p><p class="source-code">   "AnswerC"]</p><p class="source-code">  for identifier in buttonIdentifiers {</p><p class="source-code">    let button = app.buttons.matching(identifier: </p><p class="source-code">     identifier).element</p><p class="source-code">    // 2</p><p class="source-code">    let predicate = NSPredicate(format: "exists == </p><p class="source-code">      true")</p><p class="source-code">    _ = expectation(for: predicate, evaluatedWith: </p><p class="source-code">      button, handler: nil)</p><p class="source-code">  }</p><p class="source-code">  let questionTitle = app.staticTexts.matching(</p><p class="source-code">    identifier: "QuestionTitle").element</p><p class="source-code">  let predicate = NSPredicate(format: "exists == </p><p class="source-code">    true")</p><p class="source-code">  _ = expectation(for: predicate, evaluatedWith: </p><p class="source-code">     questionTitle, handler: nil)</p><p class="source-code">  // 3</p><p class="source-code">  waitForExpectations(timeout: 5, handler: nil)</p><p class="source-code">}</p><ul><li>Each element <a id="_idIndexMarker1042"/>is selected through its accessibility identifier. You can do this because the <strong class="source-inline">XCUIApplication</strong> instance we create provides easy access to the UI elements. </li><li>Next, a predicate is created that is used to check whether each element exists, and an expectation is created. This expectation will continuously evaluate whether the predicate is true and once it is, the predicate will be fulfilled automatically. </li><li>Lastly, the UI test will wait for all expectations to be fulfilled.<p>To make sure the questions are loaded correctly, you should load the JSON file as you did before. </p></li></ul></li>
				<li>Add the following property to the test so you have a place to store the trivia questions:<p class="source-code">typealias JSON = [String: Any] </p><p class="source-code">var questions: [JSON]?</p></li>
				<li>Next, add the <a id="_idIndexMarker1043"/>following code to the top of the <strong class="source-inline">setUp()</strong> method before launching the app:<p class="source-code">guard let filename = Bundle(for: </p><p class="source-code">  MovieTriviaUITests.self).path(forResource: </p><p class="source-code">   "TriviaQuestions", ofType: "json"),</p><p class="source-code">let triviaString = try? String(contentsOfFile: </p><p class="source-code">  filename), let triviaData = triviaString.data(</p><p class="source-code">    using: .utf8),</p><p class="source-code">let jsonObject = try? JSONSerialization.jsonObject(</p><p class="source-code">  with: triviaData, options: []),</p><p class="source-code">let triviaJSON = jsonObject as? JSON,</p><p class="source-code">let jsonQuestions = triviaJSON["questions"] as? [JSON]</p><p class="source-code">  else { return }</p><p class="source-code">questions = jsonQuestions</p><p>This code should look familiar to you because it's similar to the code you already used to load JSON. To make sure that the correct question is displayed, update the test method as shown here:</p><p class="source-code">func testQuestionAppears() {</p><p class="source-code">  // existing implementation... waitForExpectations(timeout: 5, handler: nil)</p><p class="source-code">  guard let question = questions?.first else { </p><p class="source-code">    fatalError("Can't continue testing without </p><p class="source-code">     question data...") </p><p class="source-code">  }</p><p class="source-code">  validateQuestionIsDisplayed(question)</p><p class="source-code">}</p><p>The preceding code calls <strong class="source-inline">validateQuestionIsDisplayed(_:)</strong>, but this method is not implemented yet. </p></li>
				<li>Add <a id="_idIndexMarker1044"/>the following implementation:<p class="source-code">func validateQuestionIsDisplayed(_ question: JSON) {</p><p class="source-code">  let app = XCUIApplication()</p><p class="source-code">  let questionTitle = app.staticTexts.matching(</p><p class="source-code">   identifier: "QuestionTitle").element</p><p class="source-code">  guard let title = question["title"] as? String, let</p><p class="source-code">   answerA = question["answer_a"] as? String, let </p><p class="source-code">    answerB = question["answer_b"] as? String, let </p><p class="source-code">     answerC = question["answer_c"] as? String</p><p class="source-code">    else { fatalError("Can't continue testing without </p><p class="source-code">     question data...") }</p><p class="source-code">  XCTAssert(questionTitle.label == title, "Expected </p><p class="source-code">    question title to match json data")</p><p class="source-code">  let buttonA = app.buttons.matching(identifier: </p><p class="source-code">    "AnswerA").element</p><p class="source-code">  XCTAssert(buttonA.label == answerA, "Expected </p><p class="source-code">    AnswerA title to match json data")</p><p class="source-code">  let buttonB = app.buttons.matching(identifier: </p><p class="source-code">    "AnswerB").element</p><p class="source-code">  XCTAssert(buttonB.label == answerB, "Expected </p><p class="source-code">    AnswerB title to match json data")</p><p class="source-code">  let buttonC = app.buttons.matching(identifier: </p><p class="source-code">    "AnswerC").element</p><p class="source-code">  XCTAssert(buttonC.label == answerC, "Expected </p><p class="source-code">   AnswerC title to match json data")</p><p class="source-code">}</p><p>This code <a id="_idIndexMarker1045"/>is run after checking that the UI elements exist because it's run after waiting for the expectations we created. The first question is extracted from the JSON data, and all of the relevant labels are then compared to the question data using a reusable method that validates whether a specific question is currently shown.</p></li>
			</ol>
			<p>The second test you should add is intended to check whether the game UI responds as expected. After loading a question, the test will tap on the wrong answers and then makes sure the UI doesn't show the button to go to the next question. Then, the correct answer <a id="_idIndexMarker1046"/>will be selected, and the test will attempt to navigate to the next question. And of course, the test will then validate that the next question is shown:</p>
			<p class="source-code">func testAnswerValidation() {</p>
			<p class="source-code">  let app = XCUIApplication()</p>
			<p class="source-code">  let button = app.buttons.matching(identifier: </p>
			<p class="source-code">     "AnswerA").element</p>
			<p class="source-code">  let predicate = NSPredicate(format: "exists == true")</p>
			<p class="source-code">  _ = expectation(for: predicate, evaluatedWith: button, </p>
			<p class="source-code">    handler: nil)</p>
			<p class="source-code">  waitForExpectations(timeout: 5, handler: nil)</p>
			<p class="source-code">  let nextQuestionButton = app.buttons.matching(identifier:</p>
			<p class="source-code">    "NextQuestion").element</p>
			<p class="source-code">  guard let question = questions?.first, let correctAnswer </p>
			<p class="source-code">    = question["correct_answer"] as? Int else {</p>
			<p class="source-code">    fatalError("Can't continue testing without question </p>
			<p class="source-code">      data...")</p>
			<p class="source-code">  }</p>
			<p class="source-code">  let buttonIdentifiers = ["AnswerA", "AnswerB", "AnswerC"]</p>
			<p class="source-code">  for (i, identifier) in buttonIdentifiers.enumerated() {</p>
			<p class="source-code">    guard i != correctAnswer else { continue }</p>
			<p class="source-code">    app.buttons.matching(identifier:identifier)</p>
			<p class="source-code">     .element.tap()</p>
			<p class="source-code">    XCTAssert(nextQuestionButton.exists == false, "Next</p>
			<p class="source-code">      question button should be hidden")</p>
			<p class="source-code">  }</p>
			<p class="source-code">  app.buttons.matching(identifier: buttonIdentifiers[</p>
			<p class="source-code">    correctAnswer]).element.tap()</p>
			<p class="source-code">  XCTAssert(nextQuestionButton.exists == true, "Next </p>
			<p class="source-code">    question button should be visible")</p>
			<p class="source-code">  nextQuestionButton.tap()</p>
			<p class="source-code">  guard let nextQuestion = questions?[1] else { </p>
			<p class="source-code">   fatalError("Can't continue testing without question </p>
			<p class="source-code">    data...") }</p>
			<p class="source-code">  validateQuestionIsDisplayed(nextQuestion)</p>
			<p class="source-code">  XCTAssert(nextQuestionButton.exists == false, "Next </p>
			<p class="source-code">    question button should be hidden")</p>
			<p class="source-code">}</p>
			<p>The preceding code shows the entire test that validates that the UI responds appropriately <a id="_idIndexMarker1047"/>to correct and incorrect answers. Tests such as these are quite verbose, but they save you a lot of manual testing.</p>
			<p>When you test your UI like this, you can rest assured that your app will at least be somewhat accessible. The beauty in this is that both UI testing and accessibility can significantly improve your app quality and each actively aids the other.</p>
			<p>Testing your UI is mostly a matter of looking for elements in the UI, checking their state or availability, and making assertions based on that. In the two tests you have written for <strong class="bold">MovieTrivia</strong>, we've combined expectations and assertions to test both existing UI elements and elements that might not be on screen yet. Note that your UI tests will always attempt to wait for any animations to complete before the next command is executed. This will make sure that you don't have to write asynchronous expectations for <a id="_idTextAnchor645"/>any <a id="_idIndexMarker1048"/>new UI that is added to the screen with an animation.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor646"/>Summary</h1>
			<p>Congratulations! You've made it to the end of this lengthy, information-packed chapter. You should know enough about testing and accessibility right now to begin exploring testing in greater depth than we have in this chapter. </p>
			<p>No matter how small or big your app, writing automated tests will ensure that your app is of a high quality. More importantly, instead of assuming that something works because it worked before, your automated tests will guarantee that it works because your tests won't pass if you've broken your code.</p>
			<p>In this chapter, you have learned the fundamentals about <strong class="source-inline">XCTest</strong>: when to write tests, which type of tests to write (unit and integration), and how to isolate tests following the Arrange-Act-Assert pattern. You also learned about code coverage and how to m easure how much of your code is being tested. Finally, you learned about <strong class="source-inline">XCUITest</strong> and how it can help you to test parts of your UI.</p>
			<p>You also learned that writing testable code sometimes requires you to refactor large portions of code. More often than not, these refactoring sessions leave your code in a much better state than before. Code that is easy to test is often cleaner and more robust than code that is hard to test. </p>
			<p>Now that you know how to cover your app with tests, in the next chapter, we'll look at how you can submit your app to the App Store.</p>
		</div>
	</body></html>