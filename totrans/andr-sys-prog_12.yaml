- en: Introducing Recovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍恢复
- en: In this book, we have completed two projects so far. With the first x86emu project,
    we learnt how to extend an existing device to support additional features. After
    that, we learnt how to create a new device using the second project, x86vbox.
    There is another important topic at the system-level programming of Android, which
    is how to patch or update a released system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们到目前为止已经完成了两个项目。通过第一个x86emu项目，我们学习了如何扩展现有设备以支持附加功能。之后，我们通过第二个项目x86vbox学习了如何创建新设备。在Android的系统级编程中，还有一个重要的话题，那就是如何修补或更新已发布的系统。
- en: 'In Android systems, the way to patch or update a released system is using a
    tool called **recovery**. In the next three chapters, we will learn how to build
    recovery on an x86vbox device. Since x86vbox is a built for VirtualBox, we will
    use VirtualBox as virtual hardware for this chapter to [Chapter 14](32a9d777-755e-4758-a38a-f4e11d8ca2e9.xhtml),
    *Creating OTA Update Packages*. We will also prepare and test a few update packages
    using the recovery that we build. In this chapter, we will cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android系统中，修补或更新已发布系统的方法是使用一个名为**恢复**的工具。在接下来的三个章节中，我们将学习如何在x86vbox设备上构建恢复。由于x86vbox是为VirtualBox构建的，我们将使用VirtualBox作为本章的虚拟硬件，[第14章](32a9d777-755e-4758-a38a-f4e11d8ca2e9.xhtml)，*创建OTA更新包*。我们还将使用我们构建的恢复准备和测试几个更新包。在本章中，我们将涵盖以下主题：
- en: Recovery introduction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复介绍
- en: Analyzing recovery source code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析恢复源代码
- en: Building recovery for x86vbox
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为x86vbox构建恢复
- en: Recovery introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复介绍
- en: In Android, recovery is a minimal Linux environment including a kernel and a
    dedicated ramdisk. When this minimal Linux environment boots up, it runs a binary
    tool, recovery, to enter the so-called recovery mode. The Linux kernel and ramdisk
    of recovery mode are usually stored in a dedicated bootable partition. In recovery
    mode, both the kernel and the root filesystem are in memory so it can manage other
    partitions without any dependencies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，恢复是一个包含内核和专用ramdisk的最小Linux环境。当这个最小Linux环境启动时，它会运行一个二进制工具，即恢复，以进入所谓的恢复模式。恢复模式的Linux内核和ramdisk通常存储在一个专用的可启动分区中。在恢复模式下，内核和根文件系统都在内存中，因此它可以管理其他分区而无需任何依赖。
- en: There are two ways to update devices in the field. The first method is to use
    fastboot protocol through bootloader. The devices can be reflashed using bootloader.
    In this case, you can boot your device in fastboot mode and flash your device
    using the fastboot tool from Android SDK. The second way to flash a device is
    to use the recovery mode. If you boot the devices into recovery mode, you can
    flash the device using an image file on the storage or providing an image through
    USB in sideload mode.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在现场更新设备有两种方法。第一种方法是使用引导加载程序中的fastboot协议。设备可以通过引导加载程序进行重写。在这种情况下，您可以在fastboot模式下启动您的设备，并使用Android
    SDK中的fastboot工具来重写您的设备。第二种方法是通过恢复模式来重写设备。如果您将设备启动到恢复模式，您可以使用存储上的映像文件或通过USB在sideload模式下提供映像来重写设备。
- en: The image files that can be used by bootloader and recovery are different. The
    image files from the AOSP build output can be used by bootloader directly. We
    can flash image files `system.img`, `userdata.img`, `boot.img` or `recovery.img`
    directly using the `fastboot` tool in bootloader. We cannot use these image files
    for recovery. We have to build image files for recovery specially using tools
    provided in AOSP. We will cover this topic in the next chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序和恢复可以使用的映像文件不同。来自AOSP构建输出的映像文件可以直接由引导加载程序使用。我们可以直接使用`fastboot`工具在引导加载程序中重写`system.img`、`userdata.img`、`boot.img`或`recovery.img`映像文件。我们不能使用这些映像文件进行恢复。我们必须使用AOSP中提供的工具专门构建恢复映像文件。我们将在下一章中介绍这个主题。
- en: The key advantage of recovery mode over the fastboot protocol is the **over-the-air**
    (**OTA**) update support. If an update is available from the OTA servers, the
    users will receive a notification. The users can download the update to a cache
    or data partition. After the update package is verified using its signature, the
    users can respond to the update notification. After that, the device will reboot
    into recovery mode. In recovery mode, the recovery binary is started and it will
    use the command-line arguments stored in the `/cache/recovery/command` file to
    find the update package to update the system image.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与快启协议相比，恢复模式的关键优势在于支持**空中**（**OTA**）更新。如果OTA服务器上有可用的更新，用户将收到通知。用户可以将更新下载到缓存或数据分区。在更新包使用其签名进行验证后，用户可以响应更新通知。之后，设备将重启进入恢复模式。在恢复模式下，将启动恢复二进制文件，并使用存储在`/cache/recovery/command`文件中的命令行参数来查找更新包以更新系统镜像。
- en: Android device partitions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android设备分区
- en: 'To enable recovery on a device, we need to look at the device partitions again.
    In Android SDK, we have the following image files that can be used by the emulator:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在设备上启用恢复，我们需要再次查看设备分区。在Android SDK中，我们有以下可用于模拟器的镜像文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After we boot up the emulator, we can see that the following partitions are
    mounted:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 启动模拟器后，我们可以看到以下分区已挂载：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can see that `system`, `data`, and `cache` partitions are mounted as virtio
    block devices. Since virtio is a virtualization standard for network and disk
    device drivers, the performance should be better than physical device drivers.
    With only these partitions, we won''t be able to create a system that can use
    the recovery tool. In the following figure, these are the minimum partitions that
    we need to have on the storage device to support both fastboot and recovery:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`system`、`data`和`cache`分区已挂载为virtio块设备。由于virtio是网络和磁盘设备驱动程序的虚拟化标准，性能应该优于物理设备驱动程序。仅使用这些分区，我们无法创建一个可以使用恢复工具的系统。在下图中，这些是我们需要在存储设备上拥有的最小分区，以支持快启和恢复：
- en: '![](img/image_12_001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_001.png)'
- en: Android device partitions
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备分区
- en: '**boot**: This is the partition that contains the kernel and ramdisk image.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导**：这是包含内核和ramdisk镜像的分区。'
- en: '**system**: This is the partition that contains the Android system. It is usually
    mounted as read-only and can only be changed during an OTA update.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：这是包含Android系统的分区。它通常作为只读挂载，只能在OTA更新期间进行更改。'
- en: '**vendor**: This is the partition that contains the private system files from
    the vendor. It is similar to the system partition, which is mounted as read-only
    and can only be changed during an OTA update.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**厂商**：这是包含厂商私有系统文件的分区。它与系统分区类似，作为只读挂载，只能在OTA更新期间进行更改。'
- en: '**userdata**: This partition contains the data saved by applications installed
    by the user. This partition is usually not touched by the OTA update process.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户数据**：此分区包含用户安装的应用程序保存的数据。此分区通常不会在OTA更新过程中被触及。'
- en: '**cache**: This partition holds temporary data. The OTA package installations
    can use it as a workspace.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：此分区持有临时数据。OTA包安装可以使用它作为工作空间。'
- en: '**recovery**: This partition contains a Linux kernel and a ramdisk for recovery.
    It is similar to the boot partition except the ramdisk image is the one used by
    recovery mode only.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复**：此分区包含用于恢复的Linux内核和ramdisk。它与引导分区类似，只是ramdisk镜像仅用于恢复模式。'
- en: '**misc**: This partition is used by recovery to store information across different
    boot sessions.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**杂项**：此分区由恢复用于在不同引导会话之间存储信息。'
- en: In this chapter, we will build recovery for the x86vbox device. As we learnt
    from [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml), *Creating Your Own
    Device on VirtualBox*, to [Chapter 11](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml),
    *Enabling VirtualBox-Specific Hardware Interfaces*, we use only one partition
    to store everything for the x86vbox device. We will extend the x86vbox device
    to use multiple partitions according to the preceding explanation in this chapter
    later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为x86vbox设备构建恢复。正如我们从[第8章](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml)“在VirtualBox上创建自己的设备”到[第11章](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml)“启用VirtualBox特定硬件接口”所学的，我们只为x86vbox设备使用一个分区来存储所有内容。我们将在本章前面的解释基础上，稍后扩展x86vbox设备以使用多个分区。
- en: Analyzing recovery
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析恢复
- en: Before we start to build recovery for our x86vbox device, we will analyze the
    code flow of recovery to understand how it works. There are two ways to enter
    recovery mode from the end user perspective. When users want to perform a factory
    reset or an OTA update is available, the main system can write a recovery command
    to the **bootloader control block** (**BCB**) and cache partition before resetting
    the system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为我们的x86vbox设备构建恢复之前，我们将分析恢复的代码流程以了解其工作原理。从最终用户的角度来看，有两种进入恢复模式的方法。当用户想要执行出厂重置或可用OTA更新时，主系统可以在重置系统之前将恢复命令写入**引导加载程序控制块**（**BCB**）和缓存分区。
- en: The second way to enter recovery mode is to use a key combination manually.
    After turning off the phone, press a key combination at the same time to enter
    the recovery mode manually. The key combination is defined by the device manufacturing,
    for example, it can be a combination of volume down and power buttons.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 进入恢复模式的第二种方法是手动使用键组合。在关闭手机后，同时按下一个键组合以手动进入恢复模式。键组合由设备制造商定义，例如，它可以是音量下键和电源按钮的组合。
- en: 'In both cases, entering the recovery mode is closely related to the implementation
    of bootloader. The Android system, recovery, and bootloader communicate with each
    other using two interfaces: the partitions `/cache` and `/misc`. We can depict
    the communication interfaces using the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，进入恢复模式与引导加载程序的实现密切相关。Android系统、恢复和引导加载程序通过两个接口相互通信：分区`/cache`和`/misc`。我们可以使用以下图表来描述通信接口：
- en: '![](img/image_12_002.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_002.png)'
- en: Interfaces of the Android system, recovery, and bootloader
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统、恢复和引导加载程序的接口
- en: In the preceding diagram, bootloader uses **BCB** in the **/misc** partition
    to communicate with the Android system and recovery. The Android system and recovery
    use the information in the **/cache** partition to talk to each other. Let's look
    into the details of these two communication channels.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，引导加载程序使用`/misc`分区中的**BCB**与Android系统和恢复进行通信。Android系统和恢复使用`/cache`分区中的信息相互通信。让我们深入了解这两个通信通道的细节。
- en: BCB
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BCB
- en: BCB is the communication interface of bootloader to the main system and recovery.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: BCB是引导加载程序与主系统和恢复之间的通信接口。
- en: The Android system is also referred to as the main system in the recovery source
    code. We use the term main system as equivalent to Android system in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统在恢复源代码中也被称为主系统。在本章中，我们将主系统一词与Android系统视为同义词。
- en: BCB is stored in the `/misc` partition in a raw partition format, which means
    this partition is used just like a binary file without any filesystem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: BCB以原始分区格式存储在`/misc`分区中，这意味着这个分区就像一个没有文件系统的二进制文件一样被使用。
- en: 'Recovery uses a `recovery.fstab` file to mount all partitions in the system.
    If we look at the filesystem type of the `/misc` partition in `recovery.fstab`,
    it is `emmc` that is one of the raw filesystems used in recovery:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复使用`recovery.fstab`文件挂载系统中的所有分区。如果我们查看`recovery.fstab`中`/misc`分区的文件系统类型，它是`emmc`，这是恢复中使用的原始文件系统之一：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are five supported filesystem types in recovery including two raw filesystems
    and three normal filesystems.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复支持五种文件系统类型，包括两种原始文件系统和三种正常文件系统。
- en: 'The two supported raw filesystems are:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的两个原始文件系统是：
- en: '`mtd`: This is the partition used in old Android devices. These devices use
    NAND flash and MTD partitions.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mtd`：这是旧版Android设备中使用的分区。这些设备使用NAND闪存和MTD分区。'
- en: '`emmc`: This is a raw eMMC block device used in the recent Android devices.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emmc`：这是最近Android设备中使用的原始eMMC块设备。'
- en: The partitions for `boot`, `recovery`, and `misc` can be the `mtd` or `emmc`
    filesystem types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`boot`、`recovery`和`misc`分区可以是`mtd`或`emmc`文件系统类型。'
- en: 'The supported normal filesystem types are:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的正常文件系统类型包括：
- en: '`yaffs2`: A `yaffs2` filesystem is usually used for MTD devices for `system`,
    `userdata`, or `cache` partitions. This is usually used in older Android devices.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yaffs2`：`yaffs2`文件系统通常用于MTD设备的`system`、`userdata`或`cache`分区。这通常用于较老的Android设备。'
- en: '`ext4`: In the latest Android devices, the eMMC block devices are used. The
    standard Linux `ext4` filesystem is usually used on top of eMMC block devices.
    The same as the `yaffs2` filesystem type, `system`, `userdata`, or `cache` partitions
    can use the `ext4` format.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ext4`：在最新的Android设备中，使用eMMC块设备。通常在eMMC块设备上使用标准的Linux `ext4`文件系统。与`yaffs2`文件系统类型一样，`system`、`userdata`或`cache`分区可以使用`ext4`格式。'
- en: '`vfat` : This is the filesystem type used for external storage such as SD card
    or USB.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vfat`：这是用于外部存储（如SD卡或USB）的文件系统类型。'
- en: 'Let''s come back to the topic of BCB. BCB is defined as a data structure as
    follows in the `$AOSP/bootable/recovery/bootloader.h` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到BCB的话题。在`$AOSP/bootable/recovery/bootloader.h`文件中，BCB被定义为以下数据结构：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `command` field is used by the main system when it wants to reboot the device
    into recovery. This can be the case when users select factory reset from the settings
    or an OTA update is available. This field can be used by bootloader as well, when
    the bootloader completes the firmware update it may want to boot to recovery for
    any final clean up.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当主系统想要将设备重启到恢复模式时，会使用`command`字段。这可能是用户从设置中选择出厂重置或可用OTA更新时的情况。引导加载程序也可以使用此字段，当引导加载程序完成固件更新时，它可能想要进入恢复模式进行最后的清理。
- en: The `status` field is updated by the bootloader after it completes the firmware
    update.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 系统引导加载程序在完成固件更新后更新`status`字段。
- en: The `recovery` field is used by the main system to send a message to recovery
    or the recovery may use this field to send a message to the main system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`recovery`字段由主系统用于向恢复发送消息，或者恢复可能使用此字段向主系统发送消息。'
- en: 'The `stage` field is used to indicate the stage of an update. In some cases,
    the installation of an update package may require restarting multiple times. The
    recovery UI can use this field to show the current stage of the installation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`stage`字段用于指示更新的阶段。在某些情况下，安装更新包可能需要多次重启。恢复用户界面可以使用此字段来显示安装的当前阶段：'
- en: '![](img/image_12_003.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_003.png)'
- en: In the preceding diagram, the bootloader logic related to the checking of key
    combination and BCB is shown. The implementation can be vendor specific as long
    as the bootloader processes BCB according to the AOSP recovery definition. Usually,
    the bootloader checks the key combination first to decide whether the users want
    to enter the recovery mode. If there is no key combination pressed, it checks
    the BCB to decide the boot path.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，显示与检查键组合和BCB相关的引导加载程序逻辑。只要引导加载程序根据AOSP恢复定义处理BCB，实现可以是供应商特定的。通常，引导加载程序首先检查键组合，以决定用户是否想要进入恢复模式。如果没有按下键组合，它将检查BCB以决定引导路径。
- en: Cache partition
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存分区
- en: 'There are three files in the cache partition, which can be used as the communication
    channels between the main system and recovery tool. These three files are:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存分区中有三个文件，可以作为主系统和恢复工具之间的通信通道。这三个文件是：
- en: '`/cache/recovery/command`: This is a file for input parameters from the recovery
    point of view. There is one command per line in this file. The arguments that
    may be supplied in the file are:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cache/recovery/command`：这是一个从恢复点输入参数的文件。此文件中每行有一个命令。可能在此文件中提供的参数是：'
- en: '`-send_intent=anystring`: The main system may use this command to send a message
    back to itself after recovery exit'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-send_intent=anystring`：主系统可能使用此命令在恢复退出后向自身发送消息'
- en: '`-update_package=path` : This command specifies a path to install an OTA package
    file'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-update_package=path`：此命令指定安装OTA包文件的路径'
- en: '`-wipe_data`: This command tells recovery to erase user data (and cache), and
    then reboot'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-wipe_data`：此命令指示恢复擦除用户数据（和缓存），然后重启'
- en: '`-wipe_cache`: This command tells recovery to wipe cache (but not user data),
    then reboot'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-wipe_cache`：此命令指示恢复擦除缓存（但不擦除用户数据），然后重启'
- en: '`-set_encrypted_filesystem=on|off`: Enables/disables encrypted filesystems'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-set_encrypted_filesystem=on|off`：启用/禁用加密文件系统'
- en: '`-just_exit`: Does nothing; exits and reboots'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-just_exit`：不执行任何操作；退出并重启'
- en: '`/cache/recovery/log`: The runtime log file of recovery is at `/tmp/recovery.log`.
    Before recovery exits, it will back up the old log file and move the current log
    file to `/cache/recovery/log`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cache/recovery/log`：恢复的运行时日志文件位于`/tmp/recovery.log`。在恢复退出之前，它将备份旧日志文件并将当前日志文件移动到`/cache/recovery/log`。'
- en: '`/cache/recovery/intent`: Before recovery exits, it will check if there is
    any intent that needs to be sent to the main system using this file. The intent
    can be the message that the main system sends to recovery using the `-send_intent`
    command in the `/cache/recovery/command` file.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cache/recovery/intent`：在恢复退出之前，它将检查是否有任何需要通过此文件发送到主系统的意图。意图可以是主系统通过`/cache/recovery/command`文件中的`-send_intent`命令发送给恢复的消息。'
- en: Main flow of recovery
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复的主流程
- en: 'After we have all the background knowledge about recovery and the components
    related to recovery, let''s have a look at the main workflow of recovery. We will
    use the following diagram to explore the workflow of recovery:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解了关于恢复以及与恢复相关的所有背景知识后，让我们看看恢复的主要工作流程。我们将使用以下流程图来探索恢复的工作流程：
- en: When recovery is started, it will set the log file to `/tmp/recovery.log` first.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当开始恢复时，它首先将日志文件设置为 `/tmp/recovery.log`。
- en: After that, it checks the `--adbd` option. If this option is specified, it will
    run a daemon for the sideloading using `adb`. You can refer to the source code
    at `$AOSP/bootable/recovery/adb_install.cpp` about how to launch recovery as `adb`
    daemon.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它检查 `--adbd` 选项。如果指定了此选项，它将运行用于侧载的 `adb` 守护程序。您可以参考 `$AOSP/bootable/recovery/adb_install.cpp`
    中的源代码，了解如何以 `adb` 守护程序启动恢复。
- en: It retrieves and processes the arguments from cache partition and BCB by calling
    the `get_args` function.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过调用 `get_args` 函数从缓存分区和 BCB 中检索和处理参数。
- en: Based on the commands retrieved from `get_args`, it may call the `install_package`
    function to install an update, or call the `wipe_data` or `wipe_cache` functions
    to erase user data or cache partition.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 `get_args` 从中检索到的命令，它可能会调用 `install_package` 函数来安装更新，或者调用 `wipe_data` 或 `wipe_cache`
    函数来擦除用户数据或缓存分区。
- en: If there is no command for either updating a package or erasing data, it will
    call the `prompt_and_wait` function to enter the recovery user interface. Based
    on the user input, it may call `apply_from_adb` or `apply_from_sdcard` to update
    packages from USB or SD card. It may call the `wipe_data` or `wipe_cache` functions
    to erase user data or cache partition, and so on.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有更新包或擦除数据的命令，它将调用 `prompt_and_wait` 函数进入恢复用户界面。根据用户输入，它可能会调用 `apply_from_adb`
    或 `apply_from_sdcard` 从 USB 或 SD 卡更新包。它可能会调用 `wipe_data` 或 `wipe_cache` 函数来擦除用户数据或缓存分区等。
- en: 'After all the tasks are completed or the users select entries to exit from
    recovery, it will call the cleanup function, `finish_recovery`, to do the final
    clean up. After that, it will reboot or shut down the system:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有任务完成或用户选择退出恢复后，它将调用清理函数 `finish_recovery` 来进行最后的清理。之后，它将重新启动或关闭系统：
- en: '![](img/image_12_004.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_004.png)'
- en: Recovery workflow
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复工作流程
- en: 'Based on the preceding flow analysis, we can look at the code snippet of the
    `main` function at `$AOSP/bootable/recovery/recovery.cpp` as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的流程分析，我们可以查看 `$AOSP/bootable/recovery/recovery.cpp` 中的 `main` 函数的代码片段如下：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After we have an overview of the recovery workflow, we will look at how recovery
    retrieves arguments from either BCB or cache files in the `get_args` function.
    After that, we will look at the two important workflows, factory reset and OTA
    update, from the user's perspective.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解了恢复工作流程的概述后，我们将看看恢复如何在 `get_args` 函数中从 BCB 或缓存文件中检索参数。之后，我们将从用户的角度查看两个重要的工作流程：工厂重置和
    OTA 更新。
- en: Retrieving arguments from BCB and cache files
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 BCB 和缓存文件中检索参数
- en: As we can see in the main function of recovery, it calls to the `get_args` function
    to retrieve arguments from the main system or bootloader. The following is the
    flow diagram of `get_args`. It is in the same `$AOSP/bootable/recovery/recovery.cpp`
    file as the `main` function of recovery.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在恢复的主要函数中看到的那样，它调用了 `get_args` 函数从主系统或引导加载程序中检索参数。以下是为 `get_args` 的流程图。它与恢复的
    `main` 函数位于同一 `$AOSP/bootable/recovery/recovery.cpp` 文件中。
- en: '![](img/image_12_005.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_005.png)'
- en: Flow diagram of get_args
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: get_args 流程图
- en: 'From the following code snippet, we can see that it calls to the `get_bootloader_message`
    function to get the BCB data structure, `boot`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下代码片段中，我们可以看到它调用了 `get_bootloader_message` 函数来获取 BCB 数据结构 `boot`：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If there are no arguments, the value of `argc` will be less or equal to 1\.
    It will try to get the arguments from BCB, as in the following code snippet. In
    the `recovery` field of BCB, the command will start with `recovery\n`. The content
    after `recovery\n` is the same format as the cache command file, `/cache/recovery/command`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有参数，`argc` 的值将小于或等于 1。它将尝试从 BCB 中获取参数，如下面的代码片段所示。在 BCB 的 `recovery` 字段中，命令将以
    `recovery\n` 开始。`recovery\n` 之后的内容与缓存命令文件格式相同，即 `/cache/recovery/command`：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the arguments can be retrieved from BCB, it will skip the cache command
    file. Otherwise, it will try to read arguments from the cache command file as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以从 BCB 中检索到参数，它将跳过缓存命令文件。否则，它将尝试按照以下方式从缓存命令文件中读取参数：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After processing both BCB and the cache command file, it will write the BCB
    block to the `/misc` partition so that if there is any error during the process
    of update or erase, the same process will continue after the reboot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完BCB和缓存命令文件后，它将BCB块写入`/misc`分区，以便在更新或擦除过程中出现任何错误时，重启后相同的进程将继续：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the preceding code analysis, we can see that the cache command file is
    just a normal text file. It can be accessed by just using the standard C functions.
    To access the `/misc` partition for BCB data structure, the `get_bootloader_message`
    function is used to read BCB and the `set_bootloader_message` function is used
    to write BCB. The BCB data structure `bootloader_message` is defined in the `bootloader.h`
    file and related functions are implemented in the `bootloader.cpp` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码分析中，我们可以看到缓存命令文件只是一个普通的文本文件。它可以通过使用标准的C函数来访问。要访问BCB数据结构的`/misc`分区，使用`get_bootloader_message`函数读取BCB，并使用`set_bootloader_message`函数写入BCB。BCB数据结构`bootloader_message`在`bootloader.h`文件中定义，相关函数在`bootloader.cpp`文件中实现。
- en: The `/misc` partition is a raw partition and it is used by the code in `bootloader.cpp`
    as a normal file instead of a filesystem volume.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`/misc`分区是一个原始分区，它被`bootloader.cpp`中的代码作为一个普通文件而不是文件系统卷来使用。'
- en: 'We can have a quick look at the `get_bootloader_message` function and its support
    function, `get_bootloader_message_block`, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速查看`get_bootloader_message`函数及其支持函数`get_bootloader_message_block`，如下所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `get_bootloader_message` function, it will call another function according
    to the type of partition, `/misc`. As we can see, the supported raw filesystem
    types are `mtd` and `emmc`. We can look at the `emmc` version, `get_bootloader_message_block`,
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_bootloader_message`函数中，它将根据分区类型调用另一个函数，`/misc`。正如我们所见，支持的原始文件系统类型是`mtd`和`emmc`。我们可以查看`emmc`版本的`get_bootloader_message_block`，如下所示：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, in the `get_bootloader_message_block` function, it accesses the
    `/misc` partition as a normal file using C functions `fopen`, `fread`, and `fclose`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在`get_bootloader_message_block`函数中，它使用C函数`fopen`、`fread`和`fclose`将`/misc`分区作为普通文件访问。
- en: 'Now we have done the analysis of BCB and cache file processing. We will look
    at the following two most important workflows of recovery in the next two sections:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了BCB和缓存文件处理的分析。在接下来的两节中，我们将探讨恢复过程中最重要的两个工作流程：
- en: Factory data reset
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂数据重置
- en: OTA update
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OTA更新
- en: Factory data reset
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂数据重置
- en: 'One of the major functions of recovery is to support factory data reset. The
    factory data reset can usually be selected by users from Settings on the device,
    as shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复的主要功能之一是支持工厂数据重置。通常，用户可以从设备上的设置中选择工厂数据重置，如下面的截图所示：
- en: '![](img/image_12_006.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_006.png)'
- en: Factory data reset
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂数据重置
- en: 'The entire process can be divided into the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以分为以下步骤：
- en: The user selects Factory data reset from Settings.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从设置中选择工厂数据重置。
- en: Main system writes `--wipe_data` to `/cache/recovery/command`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主系统将`--wipe_data`写入`/cache/recovery/command`。
- en: Main system reboots the device into recovery. We have done the analysis about
    this when we talked about BCB in the previous section.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主系统重新启动设备进入恢复模式。我们已经在上一节讨论BCB时对此进行了分析。
- en: Recovery retrieves arguments from BCB or `/cache/recovery/command` in `get_args()`.
    After read arguments, recovery will write BCB with `boot-recovery` and `--wipe_data`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复从BCB或`/cache/recovery/command`中的`get_args()`检索参数。在读取参数后，恢复将使用`boot-recovery`和`--wipe_data`写入BCB。
- en: Recovery erases both `/data` and `/cache` partitions. After this point, any
    following reboots will continue this step until the erase can be completed or
    the user takes other actions from recovery user interfaces to exit from recovery.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复擦除`/data`和`/cache`分区。在此之后，任何后续的重启将继续此步骤，直到擦除完成或用户从恢复用户界面采取其他操作退出恢复。
- en: After erasing `/data` and `/cache` partitions, recovery calls to the `finish_recovery`
    function to erase BCB.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在擦除`/data`和`/cache`分区后，恢复调用`finish_recovery`函数来擦除BCB。
- en: Recovery reboots the device to the main system.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复将设备重新启动到主系统。
- en: 'We have analyzed most of the preceding steps except `finish_recovery`. Let''s
    look at the `finish_recovery` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分析了前面的大多数步骤，除了`finish_recovery`。让我们看看`finish_recovery`函数：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `finish_recovery` function, it writes the intent to `/cache/recovery/intent`.
    Then, it processes the local file and creates the log file backup. Finally, it
    erases BCB by calling `set_bootloader_message` and removes `/cache/recovery/command`
    to restore the normal boot process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`finish_recovery`函数中，它将意图写入`/cache/recovery/intent`。然后，它处理本地文件并创建日志文件备份。最后，通过调用`set_bootloader_message`擦除BCB，并删除`/cache/recovery/command`以恢复正常的启动过程。
- en: OTA update
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OTA更新
- en: 'OTA update is another major function of recovery. OTA packages can be updated
    using the recovery user interface after entering the recovery mode manually. It
    can also be updated automatically after an update notification is received. In
    both cases, the path of the update package may be different, but the installation
    process is the same. In this section, we will look at the flow after the device
    received an OTA update notification. Then, we will look into the details of the
    installation process:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: OTA更新是恢复的另一个主要功能。在手动进入恢复模式后，可以使用恢复用户界面更新OTA包。在接收到更新通知后也可以自动更新。在这两种情况下，更新包的路径可能不同，但安装过程是相同的。在本节中，我们将查看设备接收到OTA更新通知后的流程。然后，我们将探讨安装过程的细节：
- en: After an OTA update notification is received by the device, main system downloads
    the OTA package to `/cache/update.zip`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备接收到OTA更新通知后，主系统将OTA包下载到`/cache/update.zip`。
- en: Main system writes a `--update_package=/cache/update.zip` command to `/cache/recovery/command`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主系统将`--update_package=/cache/update.zip`命令写入`/cache/recovery/command`。
- en: Main system reboots the device into recovery.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主系统将设备重新启动到恢复模式。
- en: Recovery retrieves arguments from BCB or `/cache/recovery/command` in `get_args()`.
    After read arguments, recovery will write BCB with `boot-recovery` and `update_package=...`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复过程在`get_args()`中从BCB或`/cache/recovery/command`检索参数。读取参数后，恢复过程将使用`boot-recovery`和`update_package=...`写入BCB。
- en: Recovery calls `install_package` to install the update. At this step, any following
    reboots will continue this step until the installation can be completed.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复过程调用`install_package`来安装更新。在此步骤中，任何后续的重启将继续此步骤，直到安装完成。
- en: If the installation is failed, the `prompt_and_wait` function is called to show
    an error and wait for user action. If the installation completes successfully,
    it will move to the next step.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果安装失败，将调用`prompt_and_wait`函数来显示错误并等待用户操作。如果安装成功完成，它将进入下一步。
- en: Recovery calls to the `finish_recovery` function to erase BCB and remove the
    `/cache/recovery/command` file.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复过程调用`finish_recovery`函数来擦除BCB并删除`/cache/recovery/command`文件。
- en: Recovery reboots the device to the main system.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复过程将设备重新启动到主系统。
- en: 'Once the update package is downloaded, the installation is done by the `install_package`
    function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新包下载完成，安装将由`install_package`函数完成：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `install_package` function, it sets the installation log file first.
    The log file path is `/tmp/last_install`. Then, it calls to `setup_install_mounts`
    to mount the relevant partitions. The actual installation is done in the `really_install_package`
    function, as shown in the following code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`install_package`函数中，它首先设置安装日志文件。日志文件路径是`/tmp/last_install`。然后，它调用`setup_install_mounts`来挂载相关分区。实际的安装是在`really_install_package`函数中完成的，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `really_install_package` function, it initializes the user interface
    and shows the package location on the screen. Then, it creates a memory map for
    the update package. This is needed by the `zip` functions. After that, it verifies
    the update package using its signature. Finally, it calls to another function,
    `try_update_binary,` to do the installation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`really_install_package`函数中，它初始化用户界面并在屏幕上显示包位置。然后，它为更新包创建内存映射，这是`zip`函数所需的。之后，它使用其签名验证更新包。最后，它调用另一个函数`try_update_binary,`来完成安装。
- en: 'The `try_update_binary` function performs three tasks:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_update_binary`函数执行三个任务：'
- en: Extracts `update_binary` from the update package.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从更新包中提取`update_binary`。
- en: Prepares the environment to execute `update_binary`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备环境以执行`update_binary`。
- en: Monitors the progress of installation.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控安装进度。
- en: 'Let''s look into the details of these three tasks:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解这三个任务：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It tries to extract `update_binary` from the update package. The path of `update_binary`
    in the update package is predefined at `META-INF/com/google/android/update-binary`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它尝试从更新包中提取`update_binary`。`update_binary`在更新包中的路径在`META-INF/com/google/android/update-binary`中预定义。
- en: 'If `update_binary` can be extracted successfully, it will be copied to `/tmp/update_binary`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`update_binary`可以成功提取，它将被复制到`/tmp/update_binary`：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see from the preceding code snippet, after extracting `update_binary`,
    it will prepare the environment to execute `update_binary`. The installation of
    the update package is actually done by `update_binary` using a script. The following
    parameters are passed to `update_binary` for the execution:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，在提取`update_binary`之后，它将准备环境以执行`update_binary`。更新包的安装实际上是通过脚本由`update_binary`完成的。以下参数被传递给`update_binary`以执行：
- en: The path of `update_binary`
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_binary`的路径'
- en: Recovery version
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复版本
- en: A pipe for the communication between the parent and child processes
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父进程和子进程之间的管道用于通信
- en: The path of the update package
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新包的路径
- en: 'After the environment is ready, it will fork a child process to run `update_binary`.
    The parent process will monitor the installation progress by talking to the child
    process through a pipe:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在环境准备就绪后，它将派生一个子进程来运行`update_binary`。父进程将通过管道与子进程通信来监控安装进度：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see from the preceding code snippet, the parent process will receive
    commands from the child process to show the progress, print out information to
    the screen, or set the clean up configuration after the installation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，父进程将从子进程接收命令以显示进度，打印信息到屏幕，或在安装后设置清理配置。
- en: Building recovery for x86vbox
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为x86vbox构建恢复
- en: After analyzing the workflow and key elements in the recovery source code, we
    can now start to build it for our x86vbox device.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析恢复源代码的工作流程和关键元素后，我们现在可以开始为我们的x86vbox设备构建它。
- en: The changes to support the recovery build include the changes to x86vbox devices
    and the changes to `recovery` and `newinstaller`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 支持恢复构建的更改包括对x86vbox设备的更改以及对`recovery`和`newinstaller`的更改。
- en: Building configuration
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建配置
- en: 'Before we look at the changes for this chapter, let''s look at the configuration
    files first. As usual, we have a manifest file for each chapter. We make changes
    for this chapter based on the source code of [Chapter 11](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml),
    *Enabling VirtualBox-Specific Hardware Interfaces*. The following are the projects
    that we are going to change:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看本章的更改之前，让我们先看看配置文件。像往常一样，我们为每个章节都有一个清单文件。我们根据[第11章](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml)的源代码，*启用VirtualBox特定的硬件接口*进行本章的更改。以下是我们将要更改的项目：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see that we need to change four projects: `recovery`, `newinstaller`,
    `common`, and `x86vbox`. We use an `android-7.1.1_r4_x86vbox_ch12_r1` tag to baseline
    the source code in this chapter.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们需要更改四个项目：`recovery`、`newinstaller`、`common`和`x86vbox`。我们使用`android-7.1.1_r4_x86vbox_ch12_r1`标签作为本章源代码的基线。
- en: 'We can get the source code from GitHub and AOSP using the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从GitHub和AOSP获取源代码：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After we get the source code for this chapter, we can set the environment and
    build the system as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取本章的源代码后，我们可以设置环境并按如下方式构建系统：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To build `initrd.img`, you can run the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建`initrd.img`，您可以运行以下命令：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Changes to x86vbox
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86vbox的更改
- en: 'For the x86vbox device, we need to change the Makefiles device first. Since
    we inherited x86vbox from the common Android-x86 device, we have only the following
    Makefiles:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于x86vbox设备，我们首先需要更改Makefiles设备。由于我们从通用的Android-x86设备继承了x86vbox，所以我们只有以下Makefiles：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`AndroidProducts.mk` is the entry of the Android build system, which includes
    our `x86vbox.mk` Makefile. In `x86vbox.mk`, we add the following recovery related
    files:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`AndroidProducts.mk`是Android构建系统的入口，它包括我们的`x86vbox.mk` Makefile。在`x86vbox.mk`中，我们添加以下与恢复相关的文件：'
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These changes include two parts. The first part is related to the environment
    setup specific for VirtualBox, since we run recovery on the virtual hardware of
    VirtualBox. The x86vbox specific init script, `init.recovery.x86vbox.rc`, will
    be executed by the init process during the system startup.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改包括两部分。第一部分与针对VirtualBox的特定环境设置相关，因为我们是在VirtualBox的虚拟硬件上运行恢复。x86vbox特定的初始化脚本`init.recovery.x86vbox.rc`将在系统启动时由init进程执行。
- en: 'The second part is related to the partitions of the storage device. As we discussed
    in previous chapters, we won''t be able to use recovery with a single partition
    as we did in [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml), *Creating
    Your Own Device on VirtualBox*, to [Chapter 11](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml),
    *Enabling VirtualBox-Specific Hardware Interfaces*. The partition table is defined
    in the `recovery.fstab` file. Let''s look at the startup script, `init.recovery.x86vbox.rc`,
    first:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分与存储设备的分区有关。正如我们在前面的章节中讨论的，我们不能像在[第8章](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml)，*在VirtualBox上创建自己的设备*，到[第11章](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml)，*启用VirtualBox特定的硬件接口*中那样，使用单个分区进行恢复。分区表定义在
    `recovery.fstab` 文件中。让我们首先看看启动脚本，`init.recovery.x86vbox.rc`：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As the init script of Android, recovery also has a device specific init script,
    `init.recovery.${ro.hardware}.rc`. In our case, it is `init.recovery.x86vbox.rc`.
    Inside `init.recovery.x86vbox.rc`, it calls to the Android-x86 HAL initialization
    script, `/system/etc/init.sh`. In the HAL initialization during the Android start
    up section of [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml), *Creating
    Your Own Device on VirtualBox*, we had a detailed explanation about the `/system/etc/init.sh`
    script.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Android的init脚本，恢复也有一个针对特定设备的init脚本，`init.recovery.${ro.hardware}.rc`。在我们的例子中，它是
    `init.recovery.x86vbox.rc`。在 `init.recovery.x86vbox.rc` 中，它调用Android-x86 HAL初始化脚本，`/system/etc/init.sh`。在[第8章](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml)，*在VirtualBox上创建自己的设备*中的Android启动部分的HAL初始化过程中，我们详细解释了
    `/system/etc/init.sh` 脚本。
- en: We added two services, `network_start` and `console`, in `init.recovery.x86vbox.rc`.
    With these two services, we are able to enable VirtualBox-specific network interfaces
    and we can also have a console after boot up. With this debug console, we are
    able to debug recovery much easier later in this book.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `init.recovery.x86vbox.rc` 中添加了两个服务，`network_start` 和 `console`。有了这两个服务，我们能够启用VirtualBox特定的网络接口，并且在启动后也可以拥有一个控制台。有了这个调试控制台，我们可以在本书的后续部分更容易地调试恢复过程。
- en: 'Another important part in `x86vbox.mk` is we add a `recovery.fstab` partition
    table for recovery as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`x86vbox.mk` 中的另一个重要部分是我们为恢复添加了一个 `recovery.fstab` 分区表，如下所示：'
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, we have six partitions now. We don't really have a bootloader
    that can support fastboot protocol and recovery BCB now, so we don't really use
    `/boot` and `/recovery` partitions. However, we do have a two stage boot process
    from Android-x86 and we can have a workaround without bootloader support. We will
    see this in a moment when we look at the changes to `newinstaller` later in this
    chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们现在有六个分区。我们实际上并没有一个支持fastboot协议和恢复BCB的引导加载程序，所以我们实际上并不使用 `/boot` 和 `/recovery`
    分区。然而，我们确实有一个来自Android-x86的两阶段引导过程，并且我们可以有一个无需引导加载程序支持的解决方案。我们将在本章稍后查看对 `newinstaller`
    的更改时看到这一点。
- en: The `recovery.fstab` partition table is used by recovery and we need to change
    the related partition table for the Android main system as well, which is the
    file at `device/generic/common/fstab.x86`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`recovery.fstab` 分区表由恢复使用，我们需要更改Android主系统的相关分区表，即 `device/generic/common/fstab.x86`
    中的文件。'
- en: 'We need to add two entries in `device/generic/common/fstab.x86`, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `device/generic/common/fstab.x86` 中添加两个条目，如下所示：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This `fstab.x86` file will be copied to the system image as `fstab.x86vbox`
    during the build process. The init process will process it to mount partitions.
    You may be wondering why we don't have `/system` and `/data` in the partition
    table. We use two stage boots and they are mounted in the first stage boot before
    Android starts. The source of both `/system` and `/data` can be configured through
    kernel parameters, as we discussed in previous chapters when we explained the
    two-stage boot process.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `fstab.x86` 文件将在构建过程中被复制到系统镜像中，作为 `fstab.x86vbox`。init进程将处理它以挂载分区。你可能想知道为什么分区表中没有
    `/system` 和 `/data`。我们使用两阶段引导，它们在Android启动之前的第一阶段引导中挂载。`/system` 和 `/data` 的来源可以通过内核参数进行配置，正如我们在前面章节中解释两阶段引导过程时讨论的那样。
- en: Be aware that both recovery and main system should mount the same block device
    partitions. For example, if recovery and main system mount different partitions
    for `/cache`, they won't be able to communicate with each other using the command
    file at `/cache/recovery/command`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，恢复和主系统应该挂载相同的块设备分区。例如，如果恢复和主系统为 `/cache` 挂载不同的分区，它们将无法通过 `/cache/recovery/command`
    中的命令文件相互通信。
- en: 'That''s all about the changes to `x86vbox.mk`, so now let''s look at another
    Makefile, `BoardConfig.mk`. To enable the build of recovery, we need to add the
    following two macros in `BoardConfig.mk`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`x86vbox.mk`更改的全部内容，现在让我们看看另一个Makefile，`BoardConfig.mk`。为了启用恢复的构建，我们需要在`BoardConfig.mk`中添加以下两个宏：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The default values for both macros are set to true, which means both kernel
    and recovery are not built in the default configuration.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏的默认值都设置为true，这意味着内核和恢复在默认配置中都没有内置。
- en: 'We added another macro that is related to the changes of recovery source code
    and we will look at the source code changes later:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了另一个与恢复源代码更改相关的宏，我们将在稍后查看源代码更改：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `RECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER` macro is borrowed from the latest
    code of **Team Win Recovery Project** (**TWRP**). With the changes to x86vbox
    Makefiles, we can actually build TWRP as well. This is a third-party recovery
    commonly used by many third-party ROMs, such as LineageOS/CyanogenMod, Omnirom,
    and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`RECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER`宏是从**Team Win Recovery Project**（**TWRP**）的最新代码中借用的。随着x86vbox
    Makefiles的更改，我们实际上可以构建TWRP。这是一个许多第三方ROM（如LineageOS/CyanogenMod、Omnirom等）常用的第三方恢复工具。'
- en: Changes to recovery
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复更改
- en: The AOSP recovery code can work quite well on VirtualBox. There is only an issue
    related to the display. To fix the display issue, we need to change two files
    in the recovery source code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP恢复代码在VirtualBox上可以很好地工作。只有一个与显示相关的问题。为了修复显示问题，我们需要更改恢复源代码中的两个文件。
- en: 'We use the `RECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER` macro as we mentioned earlier
    to configure the frame buffer changes. We need to add it to the recovery Makefile
    `minui/Android.mk` first as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面提到的`RECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER`宏来配置帧缓冲区更改。我们首先需要将其添加到恢复Makefile
    `minui/Android.mk`中，如下所示：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since double buffer cannot work well on VirtualBox for the time being, we have
    to disable it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于双缓冲在VirtualBox上目前无法很好地工作，我们必须将其禁用如下：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With a similar change to TWRP, TWRP can be built for x86vbox as well. The branch
    for building TWRP is included in the source code at GitHub and you can try it
    yourself.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对TWRP的类似更改，TWRP也可以为x86vbox构建。构建TWRP的分支包含在GitHub的源代码中，您可以自己尝试。
- en: Changes to newinstaller
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新安装器更改
- en: 'As we discussed in the BCB section, bootloader decides the boot path according
    to the arguments stored in BCB. The recovery command stored in BCB is the same
    as the one in the `/cache` partition at `/cache/recovery/command`. We can actually
    move the same logic to the first stage boot in `initrd.img`. In this case, we
    can achieve the same result with the help of the first stage boot. The logic for
    factory data reset and OTA update will become the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在BCB部分所讨论的，引导加载程序根据BCB中存储的参数来决定引导路径。BCB中存储的恢复命令与`/cache`分区中的`/cache/recovery/command`相同。实际上，我们可以将相同的逻辑移动到`initrd.img`的第一阶段引导中。在这种情况下，我们可以借助第一阶段引导实现相同的结果。工厂数据重置和OTA更新的逻辑将变为以下步骤：
- en: The user chooses factory data reset or an OTA update available.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以选择工厂数据重置或可用的OTA更新。
- en: Main system writes a command `--wipe_data` or `--update_package=/cache/update.zip`
    to `/cache/recovery/command`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主系统将命令`--wipe_data`或`--update_package=/cache/update.zip`写入`/cache/recovery/command`。
- en: Main system reboots the device.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主系统重新启动设备。
- en: In the first stage boot, the init script will check whether the `/cache/recovery/command`
    file exists in the `/cache` partition.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一阶段引导中，init脚本将检查`/cache`分区中是否存在`/cache/recovery/command`文件。
- en: If `/cache/recovery/command` exists, it will load `ramdisk-recovery.img`, otherwise,
    it will load `ramdisk.img`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`/cache/recovery/command`存在，它将加载`ramdisk-recovery.img`，否则，它将加载`ramdisk.img`。
- en: The rest of the steps will be the same as the normal boot process or the recovery
    boot process.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余步骤将与正常引导过程或恢复引导过程相同。
- en: 'To implement the preceding logic, we added a shell function, `find_ramdisk`,
    to the `$AOSP/bootable/newinstaller/initrd/init` file as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前面的逻辑，我们在`$AOSP/bootable/newinstaller/initrd/init`文件中添加了一个shell函数`find_ramdisk`，如下所示：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this function, we mount the cache partition to `/hd` and check whether `/hd/recovery/command`
    exists or not. If it exists, we set the `RAMDISK` variable to `ramdisk-recovery.img`;
    otherwise, we set it to `ramdisk.img`. The init script will extract the ramdisk
    contained in the `RAMDISK` variable to the memory later as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将缓存分区挂载到`/hd`，并检查`/hd/recovery/command`是否存在。如果存在，我们将`RAMDISK`变量设置为`ramdisk-recovery.img`；否则，我们将其设置为`ramdisk.img`。init脚本将在稍后提取`RAMDISK`变量中包含的ramdisk，如下所示：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There is another variable called `RECOVERY` that is defined in `find_ramdisk`,
    which can be passed to the init script from the kernel command line. With this
    variable, we can force to boot to recovery.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`RECOVERY`的变量，它在`find_ramdisk`中定义，可以从内核命令行传递给init脚本。使用这个变量，我们可以强制引导到恢复模式。
- en: Testing recovery
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试恢复
- en: After we build the recovery and AOSP images, we can test them in VirtualBox.
    As we learnt from [Chapter 9](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml), *Booting
    Up x86vbox using PXE/NFS*, we can use PXE boot to boot the system and use NFS
    to access the AOSP images. To test recovery, we can add an option in the `$HOME/.VirtualBox/TFTP/pxelinux.cfg/default`
    file to boot using `kernel` and `ramdisk/recovery.img`. Even though we can boot
    the system to recovery now, we won't be able to update the system using the recovery
    in this chapter. We will find out more in the next two chapters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建了恢复和AOSP镜像之后，我们可以在VirtualBox中测试它们。正如我们在[第9章](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml)中学到的，*使用PXE/NFS启动x86vbox*，我们可以使用PXE引导系统，并使用NFS访问AOSP镜像。为了测试恢复，我们可以在`$HOME/.VirtualBox/TFTP/pxelinux.cfg/default`文件中添加一个选项，使用`kernel`和`ramdisk/recovery.img`引导。尽管我们现在可以引导系统到恢复模式，但我们无法使用本章中的恢复来更新系统。我们将在接下来的两章中了解更多信息。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have done all the analysis and implementation of recovery for the x86vbox
    device. We have analyzed the workflow and key elements in the recovery source
    code in the first part of this chapter. In the second part of this chapter, we
    applied the knowledge that we gained in the first part to the implementation of
    the recovery for the x86vbox device. We changed the x86vbox device itself to add
    the recovery support. We also changed recovery source code to fix the display
    issue. Finally, we modified newinstaller so that we can have a complete boot flow
    for both main system and recovery.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对x86vbox设备的恢复分析和实现。在本章的第一部分，我们分析了恢复源代码中的工作流程和关键元素。在本章的第二部分，我们将第一部分中获得的知识应用于x86vbox设备的恢复实现。我们修改了x86vbox设备本身以添加恢复支持。我们还修改了恢复源代码以修复显示问题。最后，我们修改了newinstaller，以便我们可以在主系统和恢复系统中都有完整的引导流程。
- en: In the next chapter, we will discuss how to create a recovery package and explain
    what is inside a recovery package.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何创建恢复包，并解释恢复包中包含的内容。
