<html><head></head><body>
		<div><h1 id="_idParaDest-154" class="chapter number"><a id="_idTextAnchor512"/><a id="_idTextAnchor513"/><a id="_idTextAnchor514"/><a id="_idTextAnchor515"/><a id="_idTextAnchor516"/>10</h1>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor517"/>Unit Tests and Integration Tests with JUnit, Mockito, and Espresso</h1>
			<p><a id="_idTextAnchor518"/>In this chapter, you will learn about testing on the Android platform and how to create unit tests, integration tests, and UI tests. You will see how to create each of these types of tests, analyze how they run, and work with frameworks such as JUnit, Mockito, Robolectric, and Espresso.</p>
			<p>You will also learn about test-driven development (TDD), a software development practice that prioritizes tests over implementation. By the end of this chapter, you will be able to combine your new testing skills to work on a realistic project.</p>
			<p><a id="_idTextAnchor519"/>In previous chapters, you learned about how to load background data and display it in the UI and how to set up API calls to retrieve data. But how can you be sure that things work well? What if you’re in a situation where you have to fix a bug in a project that you haven’t interacted much with in the past? How can you know that the fix you are applying won’t trigger another bug? The answer to these questions is through tests.</p>
			<p>In this chapter, we will analyze the types of tests developers can write and we will look at available testing tools to ease the testing experience. The first issue that arises is the fact that desktops or laptops (which have different operating systems) are used to develop mobile applications. This implies that the tests must also be run on the device or an emulator, which will slow the tests down.</p>
			<p>To solve this issue, we are presented with two types of tests: <code>test</code> folder and will run on your machine, and <code>androidTest</code> folder and will run on the device or emulator.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>JUnit</li>
				<li>Android Studio testing tips</li>
				<li>Mockito</li>
				<li>Integration tests</li>
				<li>UI tests</li>
				<li>TDD</li>
			</ul>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor520"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/pNbuk">https://packt.link/pNbuk</a></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor521"/>Types of testing</h1>
			<p>Both tests rely <a id="_idIndexMarker785"/>on the Java <strong class="bold">JUnit</strong> library, which <a id="_idIndexMarker786"/>helps developers set up their tests and group them into different categories. It also provides different configuration options, as well as extensions that other libraries can build upon. We will also investigate the testing pyramid, which helps guide developers as to how to structure their tests.</p>
			<p>We will start at the bottom of the pyramid, which is represented <a id="_idIndexMarker787"/>by <strong class="bold">unit tests</strong>, move upward through <strong class="bold">integration tests</strong>, and <a id="_idIndexMarker788"/>finally, reach the top, which is<a id="_idIndexMarker789"/> represented by <strong class="bold">end-to-end tests</strong> (UI tests). You’ll have the opportunity to learn about the tools that aid in writing each of these types of tests:</p>
			<ul>
				<li><code>mockito-kotlin</code>, which <a id="_idIndexMarker790"/>help mainly in unit tests and are useful for creating mocks or test doubles in which we can manipulate inputs so that we can assert different scenarios. (A mock or test double is an object that mimics the implementation of another object. Every time a test interacts with mocks, you can specify the behavior of these interactions.)</li>
				<li><strong class="bold">Robolectric</strong>, which is an<a id="_idIndexMarker791"/> open source library that brings the Android framework onto your machine, allows you to test activities and fragments locally and not on the emulator. This can be used for both unit tests and integration tests.</li>
				<li><code>EditText</code> components, and so on) and assertions (verifying that views display certain text, are currently being displayed to the user, are enabled, and so on) on an app’s UI in an instrumented test.</li>
			</ul>
			<p>In this chapter, we will also<a id="_idIndexMarker793"/> look at <strong class="bold">TDD</strong>. This is a software development process where tests take priority. A simple way of describing it is writing the test first. We will analyze how this approach is taken when developing features for Android applications. One of the things to keep in mind is that for an application to be properly tested, its classes must be properly written. One way to do this is by clearly defining the boundaries between your classes and splitting them based on the tasks you want them to accomplish.</p>
			<p>Once you have achieved this, you can also rely on<a id="_idIndexMarker794"/> the <strong class="bold">dependency inversion</strong> and <strong class="bold">dependency injection</strong> principles when writing your classes. When<a id="_idIndexMarker795"/> these principles are applied properly, you should be able to inject fake objects into the subjects of your tests and manipulate the input to suit your testing scenario.</p>
			<p>Dependency injection also helps when writing instrumented tests to help you swap modules that make network calls with local data in order to make your tests independent of external factors, such as networks. Instrumented tests are tests that run on a device or an emulator. The <code>instrument</code> keyword comes from the instrumentation<a id="_idIndexMarker796"/> framework, which assembles these tests and then executes them on<a id="_idTextAnchor522"/> the device.</p>
			<p>Ideally, each application should have three types of tests:</p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: These are<a id="_idIndexMarker797"/> local tests that validate individual classes and methods. They should represent most of your tests and they should be fast, easy to debug, and easy to maintain. They are also known as small tests.</li>
				<li><strong class="bold">Integration tests</strong>: These are either local tests with Robolectric or instrumented tests that validate interactions between your app’s modules and components. These are slower and more complex than unit tests. The increase in complexity is due to the interaction between the components. These are also known as medium tests.</li>
				<li><strong class="bold">UI tests (end-to-end tests)</strong>: These are instrumented tests that verify complete user journeys and scenarios. This makes them more complex and harder to maintain; they should represent the smallest number of your total test number. These are also known as large tests.</li>
			</ul>
			<p>In the following figure, you can observe the <strong class="bold">testing pyramid</strong>. The recommendation from Google is to keep a <a id="_idIndexMarker798"/>ratio of 70:20:10 (unit tests: integration tests: UI tests) for<a id="_idTextAnchor523"/> your tests:</p>
			<div><div><img src="img/B19411_10_01.jpg" alt="Figure 10.1 – Test﻿ing pyramid"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Test<a id="_idTextAnchor524"/>ing pyramid</p>
			<p>As mentioned in the previous section, a unit test is a test that verifies a small portion of your code, and most of your tests should be unit tests that cover all sorts of scenarios (success, errors, limits, and more). Ideally, these tests should be local, but there are a few exceptions <a id="_idIndexMarker799"/>where you can make them instrumented. Those cases are rare and should be limited to when you want to interact with specific hardware o<a id="_idTextAnchor525"/><a id="_idTextAnchor526"/>f<a id="_idTextAnchor527"/> the device.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor528"/>JUnit</h1>
			<p>JUnit is a framework <a id="_idIndexMarker800"/>for writing unit tests both in Java and Android. It is responsible for how tests are executed, allowing developers to configure their tests. It offers a multitude of features, such as the following:</p>
			<ul>
				<li><code>@Before</code> and <code>@</code><code>After</code> annotations.</li>
				<li><strong class="bold">Assertions</strong>: These are used to verify the result of an operation against an expected value.</li>
				<li><strong class="bold">Rules</strong>: These allow developers to set up inputs that are common for multiple tests.</li>
				<li><strong class="bold">Runners</strong>: Using these, you can specify how the tests can be executed.</li>
				<li><strong class="bold">Parameters</strong>: These allow a test method to be executed with multiple inputs.</li>
				<li><strong class="bold">Orderings</strong>: These specify in which order the tests should be executed.</li>
				<li><strong class="bold">Matchers</strong>: These allow you to define patterns that can then be used to validate the results of the<a id="_idIndexMarker802"/> subject of your tests, or help you control the behavior of mocks.</li>
			</ul>
			<p>In Android Studio, when a new project is created, the <code>app</code> module comes with the JUnit library in Gradle. This should be visible in <code>app/build.gradle</code>:</p>
			<pre class="source code">
testImplementation 'junit:junit:4.13.2'</pre>
			<p>Let’s look at <a id="_idIndexMarker803"/>the following class that we need to test:</p>
			<pre class="source code">
class MyClass {
    fun factorial(n: Int): Int {
        return IntArray(n) {
            it+1
        }.reduce { acc, i -&gt;
            acc * i
        }
    }
}</pre>
			<p>This method should return the factorial of the number <code>n</code>. We can start with a simple test that checks the value. To create a new unit test, you will need to create a new class in the <code>test</code> directory of your project.</p>
			<p>The typical convention most developers follow is to add the <code>Test</code> suffix to your class name and place it under the same package in the <code>test</code> directory. For example, <code>com.mypackage.ClassA</code> will have the test in <code>com.mypackage.ClassATest</code>:</p>
			<pre class="source code">
import org.junit.Assert.assertEquals
import org.junit.Test
class MyClassTest {
    private val myClass = MyClass()
    @Test
    fun computesFactorial() {
        val n = 3
        val result = myClass.factorial(n)
        assertEquals(6, result)
    }
}</pre>
			<p>In this test, you <a id="_idIndexMarker804"/>can see that we initialize the class under test, and the test method itself is annotated with the <code>@Test</code> annotation. The test method itself will assert that <code>(3!)==6</code>. The assertion is done using the <code>assertEquals</code> method from the JUnit library. A common practice in development is to split the test into three areas, also known <a id="_idIndexMarker805"/>as <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>):</p>
			<ul>
				<li><strong class="bold">Arrange</strong>: Where the input is initialized</li>
				<li><strong class="bold">Act</strong>: Where the method under test is called</li>
				<li><strong class="bold">Assert</strong>: Where the verification is done</li>
			</ul>
			<p>We can write another test to make sure that the value is correct, but we will end up duplicating the code. We can now attempt to write a parameterized test. To do this, we will need to use the parameterized test runner. The preceding test has its own built-in runner provided by JUnit.</p>
			<p>The parameterized runner will run the test repeatedly for different values that we provide, and it will look like the following – please note that <code>import</code> statements have been removed for brevity:</p>
			<pre class="source code">
@RunWith(Parameterized::class)
class MyClassTest(
    private val input: Int,
    private val expected: Int
) {
    companion object {
        @Parameterized.Parameters
        @JvmStatic
        fun getData(): Collection&lt;Array&lt;Int&gt;&gt; = listOf(
            arrayOf(0, 1),
            arrayOf(1, 1),
            arrayOf(2, 2),
            arrayOf(3, 6),
            arrayOf(4, 24),
            arrayOf(5, 120)
        )
    }
    private val myClass = MyClass()
    @Test
    fun computesFactorial() {
        val result = myClass.factorial(input)
        assertEquals(expected, result)
    }
}</pre>
			<p>This will run six<a id="_idIndexMarker806"/> tests. The usage of the <code>@Parameterized</code> annotation tells JUnit that this is a test with multiple parameters and allows us to add a constructor for the test that will represent the input value for our <code>factorial</code> function and the output. We then defined a collection of parameters with the use of the <code>@</code><code>Parameterized.Parameters</code> annotation.</p>
			<p>Each parameter for this test is a separate list containing the input and the expected output. When JUnit runs this test, it will run a new instance for each parameter and then execute the test method. This will produce five successes and one failure when we test <code>0!</code>, meaning that we have found a bug.</p>
			<p>We never accounted for a situation when <code>n = 0</code>. Now, we can go back to our code to fix the failure. We can do this by replacing the <code>reduce</code> function, which doesn’t allow us to specify an initial value, with a <code>fold</code> function, which allows us to give the initial value of <code>1</code>:</p>
			<pre class="source code">
fun factorial(n: Int): Int {
        return IntArray(n) {
            it + 1
        }.fold(1, { acc, i -&gt; acc * i })
    }</pre>
			<p>Running the tests <a id="_idIndexMarker807"/>now, they will all pass. But that doesn’t mean we are done here. There are many things that can go wrong. What happens if <code>n</code> is a negative number? Since we are dealing with factorials, we may get large numbers. We are working with integers in our examples, which means that the integer will overflow after <code>12!</code>.</p>
			<p>Normally, we would create new test methods in the <code>MyClassTest</code> class, but since the parameterized runner is used, all our new methods will be run multiple times, which will cost us time, so we will create a new test class to check our errors:</p>
			<pre class="source code">
class MyClassTest2 {
    private val myClass = MyClass()
    @Test(expected =
        MyClass.FactorialNotFoundException::class)
    fun computeNegatives() {
        myClass.factorial(-10)
    }
}</pre>
			<p>This would lead to the following change in the class that was tested:</p>
			<pre class="source code">
class MyClass {
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): Int {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        return IntArray(n) {
            it + 1
        }.fold(1, { acc, i -&gt; acc * i })
    }
    object FactorialNotFoundException : Throwable()
}</pre>
			<p>Let’s solve the issue<a id="_idIndexMarker808"/> with very large factorials. We can use the <code>BigInteger</code> class, which can hold large numbers. We can update the test as follows (<code>import</code> statements not shown):</p>
			<pre class="source code">
@RunWith(Parameterized::class)
class MyClassTest(
    private val input: Int,
    private val expected: BigInteger
) {
    companion object {
        @Parameterized.Parameters
        @JvmStatic
        fun getData(): Collection&lt;Array&lt;Any&gt;&gt; = listOf(
            arrayOf(0, BigInteger.ONE),
            arrayOf(1, BigInteger.ONE),
            arrayOf(2, BigInteger.valueOf(2)),
            arrayOf(3, BigInteger.valueOf(6)),
            arrayOf(4, BigInteger.valueOf(24)),
            arrayOf(5, BigInteger.valueOf(120)),
            arrayOf(13, BigInteger("6227020800")),
            arrayOf(25, BigInteger(
            "15511210043330985984000000"))
        )
    }
    private val myClass = MyClass()
    @Test
    fun computesFactorial() {
        val result = myClass.factorial(input)
        assertEquals(expected, result)
    }
}</pre>
			<p>The class under <a id="_idIndexMarker809"/>test now looks like this:</p>
			<pre class="source code">
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): BigInteger {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        return IntArray(n) {
            it + 1
        }.fold(BigInteger.ONE, { acc, i -&gt; acc *
            i.toBigInteger() })
    }</pre>
			<p>In the preceding example, we implemented the factorial with the help of <code>IntArray</code>. This implementation is based more on Kotlin’s ability to chain methods together, but it has one drawback: the fact that it uses memory for the array when it doesn’t need to.</p>
			<p>We only care about the factorial and not storing all the numbers from <code>1</code> to <code>n</code>. We can change the implementation to a simple <code>for</code> loop and use the tests to guide us during the refactoring process.</p>
			<p>We can observe here two benefits of having tests in your application:</p>
			<ul>
				<li>They serve as updated documentation of how the features should be implemented</li>
				<li>They guide us when refactoring code by maintaining the same assertion and detecting whether new changes to the code broke it</li>
			</ul>
			<p>Let’s update the<a id="_idIndexMarker810"/> code to get rid of <code>IntArray</code>:</p>
			<pre class="source code">
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): BigInteger {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        var result = BigInteger.ONE
        for (i in 1..n){
            result = result.times(i.toBigInteger())
        }
        return result
    }</pre>
			<p>If we modify the <code>factorial</code> function, as in the preceding example, and run the tests, we should see them all passing.</p>
			<p>In certain situations, your tests will use a resource that is common to the test or the application (databases, files, and so on). Ideally, this shouldn’t happen for unit tests, but there can always be exceptions to this.</p>
			<p>Let’s analyze that scenario and see how JUnit can aid us with it. We will add a <code>companion</code> object, which will store the result, to simulate this behavior:</p>
			<pre class="source code">
    companion object {
        var result: BigInteger = BigInteger.ONE
    }
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): BigInteger {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        for (i in 1..n) {
            result = result.times(i.toBigInteger())
        }
        return result
    }</pre>
			<p>If we execute<a id="_idIndexMarker811"/> the tests for the preceding code, we will start seeing that some will fail. That’s because after the first tests execute the <code>factorial</code> function, the result will have the value of the executed tests, and when a new test is executed, the result of the factorial will be multiplied by the previous value of the result.</p>
			<p>Normally, this would be good because the tests tell us that we are doing something wrong and we should remedy this, but for this example, we will address the issue directly in the tests:</p>
			<pre class="source code">
    @Before
    fun setUp(){
        MyClass.result = BigInteger.ONE
    }
    @After
    fun tearDown(){
        MyClass.result = BigInteger.ONE
    }
    @Test
    fun computesFactorial() {
        val result = myClass.factorial(input)
        assertEquals(expected, result)
    }</pre>
			<p>In the tests, we’ve added two methods with the <code>@Before</code> and <code>@After</code> annotations. When these methods are introduced, JUnit will change the execution flow as follows: all methods with the <code>@Before</code> annotation will be executed, a method with the <code>@Test</code> annotation will be executed, and then all methods with the <code>@After</code> annotation will be executed. This process will repeat for every <code>@Test</code> method in your class.</p>
			<p>If you find yourself repeating the same statements in your <code>@Before</code> method, you can consider using <code>@Rule</code> to remove the repetition. We can set up a test rule for the preceding <a id="_idIndexMarker812"/>example. Test rules should be in the <code>test</code> or <code>androidTest</code> packages, as their usage is only limited to testing. They tend to be used in multiple tests, so you can place your rules in a <code>rules</code> package (<code>import</code> statements not shown):</p>
			<pre class="source code">
class ResultRule : TestRule {
    override fun apply(
        base: Statement,
        description: Description?
    ): Statement? {
        return object : Statement() {
            @Throws(Throwable::class)
            override fun evaluate() {
                MyClass.result = BigInteger.ONE
                try {
                    base.evaluate()
                } finally {
                    MyClass.result = BigInteger.ONE
                }
            }
        }
    }
}</pre>
			<p>In the preceding example, we can see that the rule will implement <code>TestRule</code>, which, in turn, comes with the <code>apply()</code> method. We then create a new <code>Statement</code> object that will execute the <code>base</code> statement (the test itself) and reset the value of the result before and after <a id="_idIndexMarker813"/>the statement. We can now modify the test as follows:</p>
			<pre class="source code">
    @JvmField
    @Rule
    val resultRule = ResultRule()
    private val myClass = MyClass()
    @Test
    fun computesFactorial() {
        val result = myClass.factorial(input)
        assertEquals(expected, result)
    }</pre>
			<p>To add the rule to the test, we use the <code>@Rule</code> annotation. Since the test is written in Kotlin, we are using <code>@JvmField</code> to avoid generating getters and setters because <code>@Rule</code> requires a public field and not a method.</p>
			<p>In this section, we have learned how we can use JUnit to write tests that can verify small units of our code, by verifying the results, errors, or behavior for different parameters. We’ve also learned how each test is run when they are part of a testing class and the order of operations<a id="_idIndexMarker814"/> being invoked. In the next section, we will look at how we can use Android Studio to understand how we can run<a id="_idTextAnchor529"/> <a id="_idTextAnchor530"/>tests and view the results.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor531"/>Android Studio testing tips</h1>
			<p>Android Studio comes <a id="_idIndexMarker815"/>with a good set of shortcuts and visual tools to help with testing. If you want to create a new test for your class or go to existing tests for your class, you can use the <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">T</em> (Windows) or <em class="italic">Command</em> + <em class="italic">Shift</em> + <em class="italic">T</em> (Mac) shortcut. You will need to make sure that the contents of your class are currently in focus in the editor for the keyboard shortcut to take effect.</p>
			<p>In order to run tests, there are multiple options: right-click your file or the package and select the <strong class="bold">Run 'Tests in…'</strong> option, or if you want to run a test independently, you can go to the particular test method and select the green icon at the top of the class, which will execute all the tests in the class.</p>
			<div><div><img src="img/B19411_10_02.jpg" alt="Figure 10.2 – Running a group of tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Running a group of tests</p>
			<p>For an individual test, you can click the green icon next to the <code>@Test</code> annotated methods.</p>
			<div><div><img src="img/B19411_10_03.jpg" alt="Figure 10.3 – Icons for running individual tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Icons for running individual tests</p>
			<p>This will trigger the test execution, which will be displayed in the <strong class="bold">Run</strong> tab, as shown in the following <a id="_idIndexMarker816"/>screenshot. When the tests are completed, they will become either red or green, depend<a id="_idTextAnchor532"/>ing on their success state:</p>
			<div><div><img src="img/B19411_10_04.jpg" alt="Figure 10.4 – Test output in Android Studio"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Test output in Android Studio</p>
			<p>Another important feature that can be found in tests is the debug one. This is important because you can debug both the test and the method under test, so if you find problems in fixing an issue, you can use this to view what the test used as input and how your code handles the input. The third feature you can find in the green icon next to a test is the <strong class="bold">Run With </strong><strong class="bold">Coverage</strong> option.</p>
			<p>This helps developers identify which lines of code are covered by the test and which ones are skipped. The higher the coverage, the higher the chances of<a id="_idTextAnchor533"/> finding crashes and bugs:</p>
			<div><div><img src="img/B19411_10_05.jpg" alt="Figure 10.5 – Test coverage in Android Studio"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Test coverage in Android Studio</p>
			<p>In the preceding figure, you can see the coverage of our class broken down into the number of classes under test, the number of methods under test, and the number of lines under test.</p>
			<p>Another way to run tests for your Android app is through the command line. This is usually handy in situations where your<a id="_idIndexMarker817"/> project has <strong class="bold">continuous integration</strong> set up, meaning that <a id="_idIndexMarker818"/>every time you upload your code to a repository in the cloud, a set of scripts will be triggered to test it and ensure functionality.</p>
			<p>Since this is done in the cloud, there is no need for Android Studio to be installed. For simplicity, we will be using the <strong class="bold">Terminal</strong> tab in Android Studio to emulate that behavior. The <strong class="bold">Terminal</strong> tab is usually located in the bottom bar in Android Studio near the <strong class="bold">Logcat</strong> tab.</p>
			<p>In every Android Studio project, a file called <code>gradlew</code> is present. This is an executable file that allows developers to execute Gradle commands. To run your local unit tests, you can use the following:</p>
			<ul>
				<li><code>gradlew.bat test</code> (for Windows)</li>
				<li><code>./gradlew test</code> (for macOS and Linux)</li>
			</ul>
			<p>Once that command is executed, the app will be built and tested. You can find a variety of commands that you can input in <strong class="bold">Terminal</strong> in the <strong class="bold">Gradle</strong> tab located on the right-hand side of Android Studio.</p>
			<p>If you see the message saying <strong class="bold">Task list has not been built</strong>, click it and uncheck <strong class="bold">Do not build Gradle task list during Gradle Sync</strong>, click <strong class="bold">OK</strong>, and then sync the project’s Gradle files. The task list should then appear in the list.</p>
			<p>The output of the tests, when executed from either the <code>app/build/reports</code> folder.</p>
			<div><div><img src="img/B19411_10_06.jpg" alt="Figure 10.6 – Gradle commands in Android Studio"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Gradle commands in Android Studio</p>
			<p>In this section, we have learned about the various options for testing that Android Studio <a id="_idIndexMarker819"/>provides and how we can visualize testing results. In the section that follows, we will look at how we can mock objects in tests and how <a id="_idTextAnchor535"/>we c<a id="_idTextAnchor536"/>an use Mockito to do so.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor537"/>Mockito</h1>
			<p>In the preceding <a id="_idIndexMarker820"/>examples, we looked at how to set up a unit test and how to use assertions to verify the result of an operation. What if we want to verify whether a certain method was called? Or what if we want to manipulate the test input to test a specific scenario? In these types of situations, we can use <strong class="bold">Mockito</strong>.</p>
			<p>This is a library that helps developers set up dummy objects that can be injected into the objects under test and allows them to verify method calls, set up inputs, and even monitor the test objects themselves.</p>
			<p>The library should be added to your <code>test</code> Gradle setup, as follows:</p>
			<pre class="source code">
testImplementation 'org.mockito:mockito-core:4.5.1'</pre>
			<p>Now, let’s look at the following code example (please note that, for brevity, <code>import</code> statements have been removed from the following code snippets):</p>
			<pre class="source code">
class StringConcatenator(private val context: Context) {
    fun concatenate(@StringRes stringRes1: Int,
      @StringRes stringRes2: Int): String {
          return context.getString(stringRes1).plus(context
          .getString(stringRes2))
    }
}</pre>
			<p>Here, we have<a id="_idIndexMarker821"/> the <code>Context</code> object, which normally cannot be unit-tested because it’s part of the Android framework. We can use <code>mockito</code> to create a test double and inject it into the <code>StringConcatenator</code> object. Then, we can manipulate the call to <code>getString()</code> to return whatever input we chose. This process is referred <a id="_idIndexMarker822"/>to as <strong class="bold">mocking</strong>:</p>
			<pre class="source code">
class StringConcatenatorTest {
    private val context = Mockito.mock(Context::class.java)
    private val stringConcatenator =
        StringConcatenator(context)
    @Test
    fun concatenate() {
        val stringRes1 = 1
        val stringRes2 = 2
        val string1 = "string1"
        val string2 = "string2"
        Mockito.`when`(context.getString(stringRes1))
            .thenReturn(string1)
        Mockito.`when`(context.getString(stringRes2))
            .thenReturn(string2)
        val result =
            stringConcatenator.concatenate(stringRes1,
            stringRes2)
        assertEquals(string1.plus(string2), result)
    }
}</pre>
			<p>In the test, we created a <code>mock</code> context. When the <code>concatenate</code> method was tested, we used Mockito to return a specific string when the <code>getString()</code> method was called with a<a id="_idIndexMarker823"/> particular input. This allowed us to then assert the result.</p>
			<p class="callout heading">Note</p>
			<p class="callout"><code>`</code> is an escape character present in Kotlin and should not be confused with a quote mark. It allows the developer to give methods any name that they want, including special characters or reserved words.</p>
			<p>Mockito is not limited to mocking Android framework classes only. We can create a <code>SpecificStringConcatenator</code> class, which will use <code>StringConcatenator</code> to concatenate two specific strings from <code>strings.xml</code>:</p>
			<pre class="source code">
class SpecificStringConcatenator(private val
stringConcatenator: StringConcatenator) {
    fun concatenateSpecificStrings(): String {
        return stringConcatenator.concatenate(
            R.string.string_1, R.string.string_2)
    }
}</pre>
			<p>We can write the test for it as follows:</p>
			<pre class="source code">
class SpecificStringConcatenatorTest {
    private val stringConcatenator = Mockito
        .mock(StringConcatenator::class.java)
    private val specificStringConcatenator =
        SpecificStringConcatenator(stringConcatenator)
    @Test
    fun concatenateSpecificStrings() {
        val expected = "expected"
        Mockito.'<strong class="bold">when</strong>'(stringConcatenator.concatenate(
            R.string.string_1, R.string.string_2))
            .thenReturn(expected)
        val result = specificStringConcatenator
            .concatenateSpecificStrings()
        assertEquals(expected, result)
    }
}</pre>
			<p>Here, we are<a id="_idIndexMarker824"/> mocking the previous <code>StringConcatenator</code> and instructing the mock to return a specific result. If we run the test, it will fail because Mockito is not able to mock final classes. Here, it encounters a conflict with Kotlin that makes all classes <em class="italic">final</em> unless we specify them as <em class="italic">open</em>.</p>
			<p>Luckily, there is a configuration we can apply that solves this dilemma without making the classes under test <em class="italic">open</em>:</p>
			<ol>
				<li>Create a folder named <code>resources</code> in the <code>test</code> package.</li>
				<li>In <code>resources</code>, create a folder named <code>mockito-extensions</code>.</li>
				<li>In the <code>mockito-extensions</code> folder, create a file named <code>org.mockito.plugins.MockMaker</code>.</li>
				<li>Inside the file, add the following line:<pre class="source code">
mock-maker-inline</pre></li>
			</ol>
			<p>In situations where you have callbacks or asynchronous work and cannot use the JUnit assertions, you can use <code>mockito</code> to verify the invocation on the callback or lambdas:</p>
			<pre class="source code">
class SpecificStringConcatenator(private val
stringConcatenator: StringConcatenator) {
    fun concatenateSpecificStrings(): String {
        return stringConcatenator.concatenate(
        R.string.string_1, R.string.string_2)
    }
    fun concatenateWithCallback(callback: Callback) {
        callback.onStringReady(concatenateSpecificStrings())
    }
    interface Callback {
        fun onStringReady(input: String)
    }
}</pre>
			<p>In the preceding<a id="_idIndexMarker825"/> example, we have added the <code>concatenateWithCallback</code> method, which will invoke the callback with the result of the <code>concatenateSpecificStrings</code> method. The test for this method would look something like this:</p>
			<pre class="source code">
    @Test
    fun concatenateWithCallback() {
        val expected = "expected"
        Mockito.`when`(stringConcatenator.concatenate(
            R.string.string_1, R.string.string_2))
            .thenReturn(expected)
        val callback = Mockito.mock(
            SpecificStringConcatenator.Callback::class.java
        )
        specificStringConcatenator.concatenateWithCallback(
            callback)
        Mockito.verify(callback).onStringReady(expected)
    }</pre>
			<p>Here, we create a mock <code>Callback</code> object, which we can then verify at the end with the expected result. Notice that we had to duplicate the setup of the <code>concatenateSpecificStrings</code> method to test the <code>concatenateWithCallback</code> method. You should never mock the objects you are testing; however, you<a id="_idIndexMarker826"/> can use <code>spy</code> to change their behavior. We can spy the <code>stringConcatenator</code> object to change the outcome of the <code>concatenateSpecificStrings</code> method:</p>
			<pre class="source code">
    @Test
    fun concatenateWithCallback() {
        val expected = "expected"
        val spy = Mockito.spy(specificStringConcatenator)
        Mockito.`when`(spy.concatenateSpecificStrings())
            .thenReturn(expected)
        val callback =
         Mockito.mock(SpecificStringConcatenator.Callback::
            class.java)
        specificStringConcatenator.concatenateWithCallback(
            callback)
        Mockito.verify(callback).onStringReady(expected)
    }</pre>
			<p>Mockito also relies on dependency injection to initialize class variables and has a custom build JUnit test runner. This can simplify the initialization of our variables, as follows:</p>
			<pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class SpecificStringConcatenatorTest {
    @Mock
    lateinit var stringConcatenator: StringConcatenator
    @InjectMocks
    lateinit var specificStringConcatenator:
        SpecificStringConcatenator
}</pre>
			<p>In the preceding example, <code>MockitoRunner</code> will inject the variables with the <code>@Mock</code> annotation with mocks. Next, it will create a new non-mocked instance of the field with the <code>@InjectMocks</code> annotation. When this instance is created, Mockito will try to inject the mock objects that match the signature of the constructor of that object.</p>
			<p>In this section, we <a id="_idIndexMarker827"/>have looked at how we can mock objects when we write tests and how we can use Mockito to do so. In the section that follows, we will look at a specialized library for Mockito that is better suited to be use<a id="_idTextAnchor538"/><a id="_idTextAnchor539"/>d with the Kotlin programming language, mockito-kotlin.</p>
			<p>You may have noticed in the preceding example that the <code>when</code> method from Mockito has escaped. This is because of a conflict with the Kotlin programming language. Mockito is built mainly for Java, and when Kotlin was created, it introduced the <code>this</code> keyword. Conflicts like this are escaped using the <code>`</code> character.</p>
			<p>This, along with some other minor issues, causes some inconvenience when using Mockito in Kotlin. A few libraries were introduced to wrap Mockito and provide a nicer experience when using it. One of those is <code>mockito-kotlin</code>. You can add this library to your module using the following command:</p>
			<pre class="source code">
testImplementation "org.mockito.kotlin:
mockito-kotlin:4.1.0"</pre>
			<p>A big visible change this library adds is replacing the <code>when</code> method with <code>whenever</code>. Another useful change is replacing the <code>mock</code> method to rely on generics, rather than class objects. The rest of the syntax is like the Mockito syntax.</p>
			<p>We can now update the previous tests with the new library, starting with <code>StringConcatenatorTest</code> (<code>import</code> statements<a id="_idIndexMarker828"/> have been removed for brevity):</p>
			<pre class="source code">
class StringConcatenatorTest {
    private val context = mock&lt;Context&gt;()
    private val stringConcatenator =
        StringConcatenator(context)
    @Test
    fun concatenate() {
        val stringRes1 = 1
        val stringRes2 = 2
        val string1 = "string1"
        val string2 = "string2"
        whenever(context.getString(stringRes1)).thenReturn(
            string1)
        whenever(context.getString(stringRes2)).thenReturn(
            string2)
        val result = stringConcatenator.concatenate(
            stringRes1, stringRes2)
        assertEquals(string1.plus(string2), result)
    }
}</pre>
			<p>As you can observe, the <code>`</code> character has disappeared, and our mock initialization for the <code>Context</code> object has been simplified. We can apply the same thing for the <code>SpecificStringConcatenatorTest</code> class (<code>import</code> statements have been removed <a id="_idIndexMarker829"/>for brevity):</p>
			<pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class SpecificStringConcatenatorTest {
    @Mock
    lateinit var stringConcatenator: StringConcatenator
    @InjectMocks
    lateinit var specificStringConcatenator:
        SpecificStringConcatenator
    @Test
    fun concatenateSpecificStrings() {
        val expected = "expected"
        whenever(stringConcatenator.concatenate(
            R.string.string_1, R.string.string_2))
            .thenReturn(expected)
        val result = specificStringConcatenator
            .concatenateSpecificStrings()
        assertEquals(expected, result)
    }
    @Test
    fun concatenateWithCallback() {
        val expected = "expected"
        val spy = spy(specificStringConcatenator)
        whenever(spy.concatenateSpecificStrings())
            .thenReturn(expected)
        val callback =
            mock&lt;SpecificStringConcatenator.Callback&gt;()
        specificStringConcatenator.concatenateWithCallback(
            callback)
        verify(callback).onStringReady(expected)
    }
}</pre>
			<p>In this section, we have looked at how we can use the <code>mockito-kotlin</code> library and how it can<a id="_idIndexMarker830"/> simplify the Mockito functions in Kotlin. In what follows, we will do an exercise on how we can w<a id="_idTextAnchor540"/>rite<a id="_idTextAnchor541"/> unit tests with JUnit and Mockito.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor542"/>Exercise 10.01 – testing the sum of numbers</h2>
			<p>Using JUnit, Mockito, and <code>mockito-kotlin</code>, write a set of tests for the following class that <a id="_idIndexMarker831"/>should cover the following scenarios:</p>
			<ul>
				<li>Assert the values for <code>0</code>, <code>1</code>, <code>5</code>, <code>20</code>, and <code>Int.MAX_VALUE</code></li>
				<li>Assert the outcome for a negative number</li>
				<li>Fix the code and replace the sum of numbers with the formula <em class="italic">n*(n+1)/2</em></li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">Throughout this exercise, <code>import</code> statements are not shown. To see the full code files, refer to <a href="https://packt.link/rv8C2">https://packt.link/rv8C2</a>.</p>
			<p>The code to test is as follows:</p>
			<pre class="source code">
class NumberAdder {
    @Throws(InvalidNumberException::class)
    fun sum(n: Int, callback: (BigInteger) -&gt; Unit) {
        if (n &lt; 0) {
            throw InvalidNumberException
        }
        var result = BigInteger.ZERO
        for (i in 1..n){
            result = result.plus(i.toBigInteger())
        }
        callback(result)
    }
    object InvalidNumberException : Throwable()
}</pre>
			<p>Perform the following steps to complete this exercise:</p>
			<ol>
				<li>Let’s make<a id="_idIndexMarker832"/> sure the necessary libraries are added to the <code>app/build.gradle</code> file:<pre class="source code">
testImplementation 'junit:junit:4.13.2'
testImplementation 'org.mockito:mockito-core:4.5.1'
testImplementation 'org.mockito.kotlin:
mockito-kotlin:4.1.0'</pre></li>
				<li>Create a class named <code>NumberAdder</code> and copy the preceding code inside it.</li>
				<li>Move the cursor inside the newly created class and, with <em class="italic">Command</em> + <em class="italic">Shift</em> + <em class="italic">T</em> or <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">T</em>, create a test class called <code>NumberAdderParameterTest</code>.</li>
				<li>Create a parameterized test inside this class that will assert the outcomes for the <code>0</code>, <code>1</code>, <code>5</code>, <code>20</code>, and <code>Int.MAX_VALUE</code> values:<pre class="source code">
@RunWith(Parameterized::class)
class NumberAdderParameterTest(
    private val input: Int,
    private val expected: BigInteger
) {
    companion object {
        @Parameterized.Parameters
        @JvmStatic
        fun getData(): List&lt;Array&lt;out Any&gt;&gt; = listOf(
            arrayOf(0, BigInteger.ZERO),
            arrayOf(1, BigInteger.ONE),
            arrayOf(5, 15.toBigInteger()),
            arrayOf(20, 210.toBigInteger()),
            arrayOf(Int.MAX_VALUE, BigInteger(
            "2305843008139952128"))
        )
    }
    private val numberAdder = NumberAdder()
    @Test
    fun sum() {
        val callback = mock&lt;(BigInteger) -&gt; Unit&gt;()
        numberAdder.sum(input, callback)
        verify(callback).invoke(expected)
    }
}</pre></li>
				<li>Create a<a id="_idIndexMarker833"/> separate test class that handles the exception thrown when there are negative numbers, named <code>NumberAdderErrorHandlingTest</code>:<pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class NumberAdderErrorHandlingTest {
    @InjectMocks
    lateinit var numberAdder: NumberAdder
    @Test(expected =
        NumberAdder.InvalidNumberException::class)
    fun sum() {
        val input = -1
        val callback = mock&lt;(BigInteger) -&gt; Unit&gt;()
        numberAdder.sum(input, callback)
    }
}</pre></li>
				<li>Since <em class="italic">1 + 2 + ...n = n * (n + 1) / 2</em>, we can use the formula in the code, and this would <a id="_idIndexMarker834"/>make the execution of the method run faster:<pre class="source code">
class NumberAdder {
    @Throws(InvalidNumberException::class)
    fun sum(n: Int, callback: (BigInteger) -&gt; Unit) {
        if (n &lt; 0) {
            throw InvalidNumberException
        }
        callback(n.toBigInteger()
        .times((n.toBigInteger() +
        1.toBigInteger())).divide(2.toBigInteger()))
    }
    object InvalidNumberException : Throwable()
}</pre></li>
				<li>Run the tests by right-clicking the package in which the tests are located and selecting <strong class="bold">Run all in </strong>[<strong class="bold">package_name</strong>]. An output similar to the following will appe<a id="_idTextAnchor543"/>ar, signifying that the tests have passed:</li>
			</ol>
			<div><div><img src="img/B19411_10_07.jpg" alt="Figure 10.7 – Output of Exercise 10.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Output of Exercise 10.01</p>
			<p>By completing this exercise, we have taken the first steps into unit testing, managed to create multiple <a id="_idIndexMarker835"/>test cases for a single operation, taken the first steps into understanding Mockito, and used tests to guide us on how to refact<a id="_idTextAnchor544"/>or co<a id="_idTextAnchor545"/>de without introducing any new issues.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor546"/>Integration tests</h1>
			<p>Let’s assume your <a id="_idIndexMarker836"/>project is covered by unit tests where a lot of your logic is held. You now have to add these tested classes to an activity or a fragment and require them to update your UI. How can you be certain that these classes will work well with each other? The answer to that question is through integration testing.</p>
			<p>The idea behind this type of testing is to ensure that different components within your application integrate well with each other. Some examples include the following:</p>
			<ul>
				<li>Ensuring that your API-related components parse the data well and interact well with your storage components</li>
				<li>The storage components are capable of storing and retrieving the data correctly</li>
				<li>The UI components load and display the appropriate data</li>
				<li>The transition between different screens in your application</li>
			</ul>
			<p>To aid with integration testing, the requirements are sometimes written in the format <code>Given - When - Then</code>. These usually represent acceptance criteria for a user story. Take the following example:</p>
			<pre class="source code">
Given I am not logged in
And I open the application
When I enter my credentials
And click Login
Then I see the Main screen</pre>
			<p>We can use these steps to approach how we can write the integration tests for the feature we are developing.</p>
			<p>On the Android platform, integration<a id="_idIndexMarker837"/> testing can be achieved with two libraries:</p>
			<ul>
				<li><strong class="bold">Robolectric</strong>: This library gives developers the ability to test Android components as unit tests – that is, executing integration tests without an actual device or emulator</li>
				<li><strong class="bold">Espresso</strong>: This library is helpful in instrumentation tests on an Android device or emulator</li>
			</ul>
			<p>We’ll have a look at th<a id="_idTextAnchor547"/>ese l<a id="_idTextAnchor548"/>ibraries in detail in the next sections.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor549"/>Robolectric</h2>
			<p><strong class="bold">Robolectric</strong> started as <a id="_idIndexMarker838"/>an open source library, which was<a id="_idIndexMarker839"/> meant to give users the ability to unit test classes from the Android framework as part of their local tests instead of the instrumented tests. Recently, it has been endorsed by Google and has been integrated with AndroidX Jetpack components.</p>
			<p>One of the main benefits of this library is the simplicity of testing activities and fragments. This is a benefit when it comes to integration tests because we can use this feature to make sure that our components integrate well with each other.</p>
			<p>Some of Robolectric’s<a id="_idIndexMarker840"/> features are as follows:</p>
			<ul>
				<li>The possibility to instantiate and test the activity and fragment lifecycle</li>
				<li>The possibility to test view inflation</li>
				<li>The possibility to provide configurations for different Android APIs, orientations, screen sizes, layout directions, and so on</li>
				<li>The possibility to change the <code>Application</code> class, which then helps to change the modules to<a id="_idIndexMarker841"/> permit data mocks to be inserted</li>
			</ul>
			<p>To add Robolectric, along with the AndroidX integration, we will need the following libraries:</p>
			<pre class="source code">
    testImplementation 'org.robolectric:robolectric:4.9'
    testImplementation 'androidx.test.ext:junit:1.1.4'</pre>
			<p>The second library will bring a set of utility methods and classes required for testing Android components.</p>
			<p>Let’s assume we have to deliver a feature in which we display the text <code>Result x</code>, where <code>x</code> is the <code>factorial</code> function for a number that the user will insert in the <code>EditText</code> element. We will assume that we will use an Activity with an <code>EditText</code>, a <code>TextView</code>, and a <code>Button</code>. When the button is clicked, then we display in the <code>TextView</code> the<a id="_idIndexMarker842"/> factorial result of the number <a id="_idIndexMarker843"/>entered in the <code>EditText</code>.</p>
			<p>To achieve this, we have two classes, one that computes the factorial and another that concatenates the word <code>Result</code> with the factorial if the number is positive, or it will return the text <code>Error</code> if the number is negative.</p>
			<p>The <code>factorial</code> class will look something like this (throughout this example, <code>import</code> statements have been removed for brevity):</p>
			<pre class="source code">
class FactorialGenerator {
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): BigInteger {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        var result = BigInteger.ONE
        for (i in 1..n) {
            result = result.times(i.toBigInteger())
        }
        return result
    }
    object FactorialNotFoundException : Throwable()
}</pre>
			<p>The <code>TextFormatter</code> class will look like this:</p>
			<pre class="source code">
class TextFormatter(
    private val factorialGenerator: FactorialGenerator,
    private val context: Context
) {
    fun getFactorialResult(n: Int): String {
        return try {
            context.getString(R.string.result,
            factorialGenerator.factorial(n).toString())
        } catch (e: FactorialGenerator
          .FactorialNotFoundException) {
               context.getString(R.string.error)
        }
    }
}</pre>
			<p>We can combine<a id="_idIndexMarker844"/> these two components in our activity<a id="_idIndexMarker845"/> and have something like this:</p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    private lateinit var textFormatter: TextFormatter
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        textFormatter = TextFormatter(FactorialGenerator(),
            applicationContext)
        findViewById&lt;Button&gt;(R.id.button)
            .setOnClickListener {
                findViewById&lt;TextView&gt;(R.id.text_view)
                .text = textFormatter.getFactorialResult(
                findViewById&lt;EditText&gt;(R.id.edit_text).text
                .toString()
                .toInt())
        }
    }
}</pre>
			<p>We can observe three components interacting with each other in this case. We can use Robolectric to<a id="_idIndexMarker846"/> test our activity. By testing the activity that <a id="_idIndexMarker847"/>creates the components, we can also test the interaction between all three of the components. We can write a test that looks like this:</p>
			<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    private val context =
        getApplicationContext&lt;Application&gt;()
    @Test
    fun `show factorial result in text view`() {
        val scenario = launch(MainActivity::class.java)
        scenario.moveToState(Lifecycle.State.RESUMED)
        scenario.onActivity { activity -&gt;
            activity.findViewById&lt;EditText&gt;(R.id.edit_text)
                .setText(5.toString())
            activity.findViewById&lt;Button&gt;(R.id.button)
                .performClick()
            assertEquals(
                context.getString(R.string.result, "120"),
                activity.findViewById&lt;TextView&gt;(
                R.id.text_view).text
            )
        }
    }
}</pre>
			<p>In the preceding example, we can see the AndroidX support for the activity test. The <code>AndroidJUnit4</code> test runner will set up Robolectric and create the necessary configurations, while the <code>launch</code> method will return a <code>scenario</code> object, which we can then play with to achieve the necessary conditions for the test. We can also observe how we can use the <code>`</code> character to provide longer names to our functions, in which we can include whitespace characters.</p>
			<p>If we want to <a id="_idIndexMarker848"/>add configurations for the test, we can<a id="_idIndexMarker849"/> use the <code>@Config</code> annotation both on the class and on each of the test methods:</p>
			<pre class="source code">
@Config(
    sdk = [Build.VERSION_CODES.TIRAMISU],
    minSdk = Build.VERSION_CODES.KITKAT,
    maxSdk = Build.VERSION_CODES.TIRAMISU,
    application = Application::class,
    assetDir = "/assetDir/"
)
@RunWith(AndroidJUnit4::class)
class MainActivityTest</pre>
			<p>We can also specify global configurations in the <code>test/resources</code> folder in the <code>robolectric.properties</code> file, like so:</p>
			<pre class="source code">
sdk=33
minSdk = 14
maxSdk = 33</pre>
			<p>Another important feature that has recently been added to Robolectric is support for the Espresso library. This allows developers to use the syntax from Espresso to interact with views and make assertions on the views.</p>
			<p>Another library that can be used in combination with Robolectric is <code>FragmentScenario</code>, which allows the possibility to test fragments. These libraries can be added in Gradle using the following:</p>
			<pre class="source code">
    testImplementation 'androidx.fragment:
    fragment-testing:1.5.5'
    testImplementation 'androidx.test.espresso:
    espresso-core:3.5.0'</pre>
			<p>Testing<a id="_idIndexMarker850"/> fragments <a id="_idIndexMarker851"/>is like activities using the <code>scenario</code> setup:</p>
			<pre class="source code">
val scenario = launchFragmentInContainer&lt;Ma<a id="_idTextAnchor550"/>inFra<a id="_idTextAnchor551"/>gment&gt;()
scenario.moveToState(Lifecycle.State.CREATED)</pre>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor552"/>Espresso</h2>
			<p>Espresso is a library<a id="_idIndexMarker852"/> designed to perform interactions <a id="_idIndexMarker853"/>and assertions in a concise way. It was initially designed to be used in instrumented tests, and now it has migrated to be used with Robolectric as well. The typical usage for performing an action is as follows:</p>
			<pre class="source code">
onView(Matcher&lt;View&gt;).perform(ViewAction)</pre>
			<p>For verification, we can use the following:</p>
			<pre class="source code">
onView(Matcher&lt;View&gt;).check(ViewAssertion)</pre>
			<p>We can provide custom <code>ViewMatchers</code> if none can be found in the <code>ViewMatchers</code> class. Some of the most common ones are <code>withId</code> and <code>withText</code>. These two allow us to identify views based on their <code>R.id.myId</code> identifier or text identifier. Ideally, the first one should be used to identify a particular view.</p>
			<p>Another interesting aspect of Espresso is the reliance on the <code>Hamcrest</code> library for matchers. This is a Java library that aims to improve testing. This allows multiple matchers to be combined if necessary. Let’s say that the same ID is present in different views on your UI. You can narrow your search for a specific view using the following expression:</p>
			<pre class="source code">
onView(allOf(withId(R.id.edit_text),
withParent(withId(R.id.root))))</pre>
			<p>The <code>allOf</code> expression will evaluate all of the other operators and will pass only if all of the operators inside pass. The preceding expressions will translate to <em class="italic">Find the view with id=edit_text that has the parent with id=R.id.root</em>. Other <code>Hamcrest</code> operators may include <code>anyOf</code>, <code>both</code>, <code>either</code>, <code>is</code>, <code>isA</code>, <code>hasItem</code>, <code>equalTo</code>, <code>any</code>, <code>instanceOf</code>, <code>not</code>, <code>null</code>, and <code>notNull</code>.</p>
			<p><code>ViewActions</code> have a similar approach to <code>ViewMatchers</code>. We can find common ones in the <code>ViewActions</code> class. Common ones include <code>typeText</code>, <code>click</code>, <code>scrollTo</code>, <code>clearText</code>, <code>swipeLeft</code>, <code>swipeRight</code>, <code>swipeUp</code>, <code>swipeDown</code>, <code>closeSoftKeyboard</code>, <code>pressBack</code>, <code>pressKey</code>, <code>doubleClick</code>, and <code>longClick</code>. If you have custom views and certain actions are required, then you can implement<a id="_idIndexMarker854"/> your own <code>ViewAction</code> element by<a id="_idIndexMarker855"/> implementing the <code>ViewAction</code> interface.</p>
			<p>Similar to the preceding examples, <code>ViewAssertions</code> have their own class. Typically, the <code>matches</code> method is used, where you can then use <code>ViewMatchers</code> and <code>Hamcrest</code> matchers to validate the result:</p>
			<pre class="source code">
onView(withId(R.id.text_view)).check(matches(withText(
"My text"))))</pre>
			<p>The preceding example will verify that the view with the <code>text_view</code> ID will contain the text <code>My text</code>:</p>
			<pre class="source code">
onView(withId(R.id.button)).perform(click())</pre>
			<p>This will click the view with the ID button.</p>
			<p>We can now rewrite the Robolectric test and add Espresso, which will give us this (the <code>import</code> statement is not shown):</p>
			<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    @Test
    fun `show factorial result in text view`() {
        val scenario = launch(MainActivity::class.java)
        scenario.moveToState(Lifecycle.State.RESUMED)
        scenario.onActivity { activity -&gt;
            onView(withId(R.id.edit_text)).perform(
                typeText("5"))
            onView(withId(R.id.button)).perform(click())
            onView(withId(R.id.text_view))
                .check(matches(withText(activity.getString(
                R.string.result, "120"))))
        }
    }
}</pre>
			<p>In the preceding <a id="_idIndexMarker856"/>code sample, we can observe how, using<a id="_idIndexMarker857"/> Espresso, we input the number <code>5</code> into <code>EditText</code>, then click on the button, and then assert the text displayed in <code>TextView</code> with the help of the <code>onView()</code> method to obtain a reference to the view, and then execute actions using <code>perform()</code> or make assertions using <code>check()</code>.</p>
			<p class="callout heading">Note</p>
			<p class="callout">For the following exercise, you will need an emulator or a physical device with USB debugging enabled. You can do so by selecting <strong class="bold">Tools</strong> | <strong class="bold">AVD Manager</strong> in Android Studio. Then, you can create one with the <strong class="bold">Create Virtual Device</strong> option by selecting the type of emulator, clicking <strong class="bold">Next</strong>, and then selecting an x86 image. Any image larger than Lollipop should be alright for this<a id="_idTextAnchor553"/> exer<a id="_idTextAnchor554"/>cise. Next, you can give your image a name and click <strong class="bold">Finish</strong>.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor555"/>Exercise 10.02 – double integration</h2>
			<p>Develop an<a id="_idIndexMarker858"/> application that observes the following <a id="_idIndexMarker859"/>requirements:</p>
			<pre class="source code">
Given I open the application
And I insert the number n
When I press the Calculate button
Then I should see the text "The sum of numbers from 1 to n is [result]"
Given I open the application
And I insert the number -n
When I press the Calculate button
Then I should see the text "Error: Invalid number"</pre>
			<p>You should implement both unit tests and integration tests using Robolectric and Espresso and migrate the integration tests to become instrumentation tests.</p>
			<p class="callout heading">Note</p>
			<p class="callout">Throughout this exercise, <code>import</code> statements are not shown. To see the full code files, refer to <a href="https://packt.link/EcmiV">https://packt.link/EcmiV</a>.</p>
			<p>Implement the following steps to complete this exercise:</p>
			<ol>
				<li>Let’s start by adding the necessary test libraries to <code>app/build.gradle</code>:<pre class="source code">
    testImplementation 'junit:junit:4.13.2'
    testImplementation
        'org.mockito:mockito-core:4.5.1'
    testImplementation
        'org.mockito.kotlin:mockito-kotlin:4.1.0'
    testImplementation
        'org.robolectric:robolectric:4.9'
    testImplementation 'androidx.test.ext:junit:1.1.4'
    testImplementation
        'androidx.test.espresso:espresso-core:3.5.0'
    androidTestImplementation
        'androidx.test.ext:junit:1.1.4'
    androidTestImplementation
        'androidx.test.espresso:espresso-core:3.5.0'
    androidTestImplementation
        'androidx.test:rules:1.5.0'</pre></li>
				<li>For Robolectric, we will need to add extra configurations, the first of which is to add the <a id="_idIndexMarker860"/>following<a id="_idIndexMarker861"/> line to <code>app/build.gradle</code> in the <code>android</code> closure:<pre class="source code">
testOptions.unitTests.includeAndroidResources = true</pre></li>
				<li>Create a <code>resources</code> directory in the <code>test</code> package. You will need to switch your Android Studio project view from <strong class="bold">Android</strong> to <strong class="bold">Project</strong>.</li>
				<li>Add the <code>robolectric.properties</code> file and add the following configuration to that file:<pre class="source code">
sdk=32</pre></li>
				<li>In <code>resources</code>, create a folder named <code>mockito-extensions</code>.</li>
				<li>In the <code>mockito-extensions</code> folder, create a file named <code>org.mockito.plugins.MockMaker</code>, and inside the file, add the following line:<pre class="source code">
mock-maker-inline</pre></li>
				<li>Create the <code>NumberAdder</code> class. This is similar to the one in <em class="italic">Exercise 10.01</em>:<pre class="source code">
class NumberAdder {
    @Throws(InvalidNumberException::class)
    fun sum(n: Int, callback: (BigInteger) -&gt; Unit) {
        if (n &lt; 0) {
            throw InvalidNumberException
        }
        callback(n.toBigInteger().times((n.toLong() +
        1).toBigInteger()).divide(2.toBigInteger()))
    }
    object InvalidNumberException : Throwable()
}</pre></li>
				<li>Create the<a id="_idIndexMarker862"/> tests for <code>NumberAdder</code> in <a id="_idIndexMarker863"/>the <code>test</code> folder. First, create <code>NumberAdder</code><strong class="source inline">
</strong><code>ParameterTest</code>:<pre class="source code">
@RunWith(Parameterized::class)
class NumberAdderParameterTest(
    private val input: Int,
    private val expected: BigInteger
) {
    private val numberAdder = NumberAdder()
    @Test
    fun sum() {
        val callback = mock&lt;(BigInteger) -&gt; Unit&gt;()
        numberAdder.sum(input, callback)
        verify(callback).invoke(expected)
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/ghcTs">https://packt.link/ghcTs</a>.</p>
			<ol>
				<li value="9">Then, create the <code>NumberAdderErrorHandlingTest</code> test:<pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class NumberAdderErrorHandlingTest {
    @InjectMocks
    lateinit var numberAdder: NumberAdder
    @Test(expected =
        NumberAdder.InvalidNumberException::class)
    fun sum() {
        val input = -1
        val callback = mock&lt;(BigInteger) -&gt; Unit&gt;()
        numberAdder.sum(input, callback)
    }
}</pre></li>
				<li>In the <code>main</code> folder <a id="_idIndexMarker864"/>in the root package, create <a id="_idIndexMarker865"/>a class that will format the sum and concatenate it with the necessary strings:<pre class="source code">
class TextFormatter(
    private val numberAdder: NumberAdder,
    private val context: Context
) {
    fun getSumResult(n: Int, callback: (String) -&gt;
    Unit) {
        try {
            numberAdder.sum(n) {
                callback(context.getString(
                R.string
                .the_sum_of_numbers_from_1_to_is,
                n, it.toString())
                )
            }
        } catch (
          e: NumberAdder.InvalidNumberException) {
              callback(context.getString(
              R.string.error_invalid_number))
        }
    }
}</pre></li>
				<li>Unit-test this class <a id="_idIndexMarker866"/>for both the success and <a id="_idIndexMarker867"/>error scenarios. Start with the success scenario:<pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class TextFormatterTest {
    @InjectMocks
    lateinit var textFormatter: TextFormatter
    @Mock
    lateinit var numberAdder: NumberAdder
    @Mock
    lateinit var context: Context
    @Test
    fun getSumResult_success() {
        val n = 10
        val sumResult = BigInteger.TEN
        val expected = "expected"
        whenever(numberAdder.sum(eq(n),
        any())).thenAnswer {
            (it.arguments[1] as (BigInteger) -&gt;
            Unit).invoke(sumResult)
        }
        whenever(context.getString(
        R.string.the_sum_of_numbers_from_1_to_is,
        n, sumResult.toString())
        ).thenReturn(expected)
        val callback = mock&lt;(String) -&gt; Unit&gt;()
        textFormatter.getSumResult(n, callback)
        verify(callback).invoke(expected)
    }
}</pre></li>
			</ol>
			<p>Then, create <a id="_idIndexMarker868"/>the <a id="_idIndexMarker869"/>test for the error scenario:</p>
			<pre class="source code">
    @Test
    fun getSumResult_error() {
        val n = 10
        val expected = "expected"
        whenever(numberAdder.sum(eq(n),
            any())).thenThrow(NumberAdder
            .InvalidNumberException)
            whenever(context.getString(
            R.string.error_invalid_number))
            .thenReturn(expected)
        val callback = mock&lt;(String) -&gt; Unit&gt;()
        textFormatter.getSumResult(n, callback)
        verify(callback).invoke(expected)
    }</pre>
			<ol>
				<li value="12">In <code>main/res/values/strings.xml</code>, add the following strings:<pre class="source code">
    &lt;string name="the_sum_of_numbers_from_1_to_is"&gt;
        The sum of numbers from 1 to %1$d is:
        %2$s&lt;/string&gt;
    &lt;string name="error_invalid_number"&gt;Error: Invalid
        number&lt;/string&gt;
    &lt;string name="calculate"&gt;Calculate&lt;/string&gt;</pre></li>
				<li>Create <a id="_idIndexMarker870"/>the<a id="_idIndexMarker871"/> layout for <code>activity_main.xml</code> in the <code>main/res/layout</code> folder:<pre class="source code">
    &lt;EditText
        android:id="@+id/edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:inputType="number" /&gt;
    &lt;Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="@string/calculate" /&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/hxZ0I">https://packt.link/hxZ0I</a>.</p>
			<ol>
				<li value="14">In the <code>main</code> folder in the root package, create the <code>MainActivity</code> class, which<a id="_idIndexMarker872"/> will<a id="_idIndexMarker873"/> contain all the other components:<pre class="source code">
class MainActivity : AppCompatActivity() {
    private lateinit var textFormatter: TextFormatter
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        textFormatter = TextFormatter(NumberAdder(),
            applicationContext)
        findViewById&lt;Button&gt;(R.id.button)
        .setOnClickListener {
            textFormatter.getSumResult(findViewById
            &lt;EditText&gt;(R.id.edit_text).text.toString()
            .toIntOrNull() ?: 0) {
                findViewById&lt;TextView&gt;(R.id.text_view)
                .text = it
            }
        }
    }
}</pre></li>
				<li>Create a test for <code>MainActivity</code> and place it in the <code>test</code> directory. It will contain<a id="_idIndexMarker874"/> two test methods, one for success and<a id="_idIndexMarker875"/> one for errors:<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    @Test
    fun `show sum result in text view`() {
        val scenario =
            launch(MainActivity::class.java)
        scenario.moveToState(Lifecycle.State.RESUMED)
        scenario.onActivity { activity -&gt;
            onView(withId(R.id.edit_text))
                .perform(replaceText("5"))
            onView(withId(R.id.button)).perform(click(
            ))
            onView(withId(R.id.text_view))
              .check(matches(withText(
              activity.getString(
              R.string.the_sum_of_numbers_from_1_to_is
              , 5, "15"))))
        }
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/fZI3u">https://packt.link/fZI3u</a>.</p>
			<p>If you run the tests by right-clicking the package in which the tests are located and s<a id="_idTextAnchor556"/>electing <strong class="bold">Run all in </strong>[<strong class="bold">package_name</strong>], then an output like the following will appear:</p>
			<div><div><img src="img/B19411_10_08.jpg" alt="Figure 10.8 – Result of executing the tests in the test folder for Exercise 10.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Result of executing the tests in the test folder for Exercise 10.02</p>
			<p>If you execute<a id="_idIndexMarker876"/> the preceding tests, you should see<a id="_idIndexMarker877"/> an output like <em class="italic">Figure 10</em><em class="italic">.8</em>. The Robolectric test is executed in the same way as a regular unit test; however, there is an increase in the execution time.</p>
			<ol>
				<li value="16">Let’s now migrate the preceding test to an instrumented integration test. To do this, we will copy the preceding test from the <code>test</code> package into the <code>androidTest</code> package and remove the code related to scenarios from our tests. Make sure that in the <code>androidTest</code> folder, there is a Java folder that contains a package with the same name as the <code>main/java</code> folder. You will need to move your tests to this package.</li>
				<li>After copying the file, we will use <code>ActivityTestRule</code>, which will launch our activity before every test is executed. We will also need to rename the class to avoid duplicates and rename the test methods because the syntax is not supported <a id="_idIndexMarker878"/>for <a id="_idIndexMarker879"/>instrumented tests:<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityUiTest {
    @Test
    fun showSumResultInTextView() {
        val scenario =
            launch(MainActivity::class.java)
        scenario.moveToState(Lifecycle.State.RESUMED)
        onView(withId(R.id.edit_text)).perform(
            replaceText("5"))
        onView(withId(R.id.button)).perform(click())
        onView(withId(R.id.text_view)).check(matches(
           withText(getApplicationContext&lt;Application&gt;
           ().getString(R.string
           .the_sum_of_numbers_from_1_to_is, 5, "15"))
           ))
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/hNB4A">https://packt.link/hNB4A</a>.</p>
			<p>If you run the tests by right-clicking the package in which the tests are located an<a id="_idTextAnchor557"/>d selecting <strong class="bold">Run all in </strong>[<strong class="bold">package_name</strong>], then an output like the following will appear:</p>
			<div><div><img src="img/B19411_10_09.jpg" alt="Figure 10.9 – Result of executing the tests in the androidTest folder for Exercise 10.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Result of executing the tests in the androidTest folder for Exercise 10.02</p>
			<p>In <em class="italic">Figure 10</em><em class="italic">.9</em>, we can see what Android Studio displays as an output for the result. If you pay attention to the emulator while the tests are executing, you can see that for each test, your activity will be opened, the input will be set in the field, and the button will be clicked.</p>
			<p>Both of our integration tests (on the workstation and the emulator) try to match the accepted criteria of the requirement. The integration tests verify the same behavior, the only difference is that one checks it locally and the other checks it on an Android device or emulator. The main benefit here is the fact that Espresso was able to bridge the gap between them, making integration tests easier to set up and execute.</p>
			<p>In this section, we have implemented an exercise in which we have written tests with the Robolectric library combined with the Espresso library and looked at how we can migrate <a id="_idIndexMarker880"/>our <a id="_idIndexMarker881"/>Robolectric tests from the <code>test</code> folder to the <code>androidTest</code> folder. In the section that follows, we will look at how we can build upon the ex<a id="_idTextAnchor558"/>isting <a id="_idTextAnchor559"/>testing suite with instrumented tests that run on physical devices or emulators.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor560"/>UI tests</h1>
			<p>UI tests are instrumented <a id="_idIndexMarker882"/>tests where developers can simulate user journeys and verify the interactions between different modules of the application. They are also referred to as end-to-end tests. For small applications, you can have one test suite, but for larger applications, you should split your test suites to cover user journeys (logging in, creating an account, setting up flows, and so on).</p>
			<p>Because they are executed on the device, you will need to write them in the <code>androidTest</code> package, which means they will <a id="_idIndexMarker883"/>run with the <strong class="bold">Instrumentation</strong> framework. Instrumentation works as follows:</p>
			<ul>
				<li>The app is built and installed on the device</li>
				<li>A testing app will also be installed on the device that will monitor your app</li>
				<li>The testing app will execute the tests on your app and record the results</li>
			</ul>
			<p>One of the drawbacks of this is the fact that the tests will share persisted data, so if a test stores data on the device, then the second test can have access to that data, which means that there is a risk of failure. Another drawback is that if a test comes across a crash, this will stop the entire testing because the application under test is stopped.</p>
			<p>These issues were solved in the Jetpack updates with the introduction of the <strong class="bold">orchestrator</strong> framework. Orchestrators<a id="_idIndexMarker884"/> give you the ability to clear the data after each test is executed, sparing developers the need to make any adjustments. The orchestrator is represented by another application that will manage how the testing app will coordinate the tests and the data between the tests.</p>
			<p>In order to add it to your<a id="_idIndexMarker885"/> project, you need a configuration similar to this in the <code>app/build.gradle</code> file:</p>
			<pre class="source code">
android {
    ...
    defaultConfig {
        ...
        testInstrumentationRunner
            "androidx.test.runner.AndroidJUnitRunner"
        testInstrumentationRunnerArguments
            clearPackageData: 'true'
    }
    testOptions {
        execution 'ANDROIDX_TEST_ORCHESTRATOR'
    }
}
dependencies {
    ...
    androidTestUtil 'androidx.test:orchestrator:1.4.2'
}</pre>
			<p>You can execute the orchestrator test on a connected device using Gradle’s <code>connectedCheck</code> command, either from Terminal or from the list of Gradle commands.</p>
			<p>In the configuration, you will notice the following line: <code>testInstrumentationRunner</code>. This allows us to create a custom configuration for the test, which gives us the opportunity to inject mock data into the modules:</p>
			<pre class="source code">
testInstrumentationRunner "com.android.CustomTestRunner"</pre>
			<p><code>CustomTestRunner</code> looks <a id="_idIndexMarker886"/>like this (<code>import</code> statements are not shown in the following code snippets):</p>
			<pre class="source code">
class CustomTestRunner: AndroidJUnitRunner() {
    @Throws(Exception::class)
    override fun newApplication(
        cl: ClassLoader?,
        className: String?,
        context: Context?
    ): Application? {
        return super.newApplication(cl,
        MyApplication::class.java.name, context)
    }
}</pre>
			<p>The test classes themselves can be written by applying the JUnit4 syntax with the help of the <code>androidx.test.ext.junit.runners.AndroidJUnit4</code> test runner:</p>
			<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityUiTest {
}</pre>
			<p>The <code>@Test</code> methods themselves run in a dedicated test thread, which is why a library such as Espresso is helpful. Espresso will automatically move every interaction with a view on the UI thread. Espresso can be used for UI tests in a similar way as it is used with Robolectric tests:</p>
			<pre class="source code">
    @Test
    fun myTest() {
        onView(withId(R.id.edit_text)).perform(replaceText
            ("5"))
        onView(withId(R.id.button)).perform(click())
        onView(withId(R.id.text_view)).check(matches(
            withText("my test")))
    }</pre>
			<p>Typically, in UI tests, you will find interactions and assertions that may get repetitive. In order to avoid duplicating multiple scenarios in your code, you can apply a pattern called <code>Robot</code> class in which the interactions<a id="_idIndexMarker888"/> and assertions can be grouped into specific methods. Your test code will use the robots and assert them. A typical robot will look something like this:</p>
			<pre class="source code">
class MyScreenRobot {
    fun setText(): MyScreenRobot {
        onView(ViewMatchers.withId(R.id.edit_text))
            .perform(ViewActions.replaceText("5"))
        return this
    }
    fun pressButton(): MyScreenRobot {
        onView(ViewMatchers.withId(R.id.button))
            .perform(ViewActions.click())
        return this
    }
    fun assertText(): MyScreenRobot {
        onView(ViewMatchers.withId(R.id.text_view))
            .check(ViewAssertions.matches(ViewMatchers
            .withText("my test")))
        return this
    }
}</pre>
			<p>The test will look like this:</p>
			<pre class="source code">
    @Test
    fun myTest() {
       MyScreenRobot()
           .setText()
           .pressButton()
           .assertText()
    }</pre>
			<p>Because apps can <a id="_idIndexMarker889"/>be multithreaded and sometimes it takes a while to load data from various sources (internet, files, local storage, and so on), the UI tests will have to know when the UI is available for interactions. One way to implement this is through the use of idling resources.</p>
			<p>These are objects that can be registered to Espresso before the test and injected into your application’s components where multithreaded work is done. The apps will mark them as non-idle when the work is in progress and idle when the work is done. It is at this point that Espresso will then start executing the test. One of the most commonly used ones is <code>CountingIdlingResource</code>.</p>
			<p>This specific implementation uses a counter that should be incremented when you want Espresso to wait for your code to complete its execution and decremented when you want to let Espresso verify your code. When the counter reaches <code>0</code>, Espresso will resume testing. An example of a component with an idling resource looks something like this:</p>
			<pre class="source code">
class MyHeavyliftingComponent(private val
countingIdlingResource:CountingIdlingResource) {
    fun doHeavyWork() {
        countingIdlingResource.increment()
        // do work
        countingIdlingResource.decrement()
    }
}</pre>
			<p>The <code>Application</code> class can be used to inject the idling resource, like this:</p>
			<pre class="source code">
class MyApplication : Application(){
    val countingIdlingResource =
        CountingIdlingResource("My heavy work")
    val myHeavyliftingComponent =
        MyHeavyliftingComponent(countingIdlingResource)
}</pre>
			<p>Then, in the<a id="_idIndexMarker890"/> test, we can access the <code>Application</code> class and register the resource to Espresso:</p>
			<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MyTest {
    @Before
    fun setUp() {
        val myApplication =
            getApplicationContext&lt;MyApplication&gt;()
        IdlingRegistry.getInstance()
            .register(myApplication.countingIdlingResource)
    }
}</pre>
			<p>Espresso comes with a set of extensions that can be used to assert different Android components. One extension is intents testing. This is useful when you want to test an activity in isolation (more appropriate for integration tests). In order to use this, you need to add the library to Gradle:</p>
			<pre class="source code">
androidTestImplementation 'androidx.test.espresso:
espresso-intents:3.5.0'</pre>
			<p>After you add the library, you need to set up the necessary intent monitoring using the <code>init</code> method from the <code>Intents</code> class, and to stop monitoring, you can use the <code>release</code> method from the same class. These operations can be done in the <code>@Before</code> and <code>@After</code> annotated methods of your test class.</p>
			<p>To assert the values of the intent, you need to trigger the appropriate action and then use the <code>intended</code> method:</p>
			<pre class="source code">
        onView(withId(R.id.button)).perform(click())
        intended(allOf(hasComponent(hasShortClassName
            (".MainActivity")), hasExtra(MainActivity
            .MY_EXTRA, "myExtraValue")))</pre>
			<p>The <code>intended</code> method<a id="_idIndexMarker891"/> works in a similar way to the <code>onView</code> method. It requires a matcher that can be combined with a <code>Hamcrest</code> matcher. The intent-related matchers can be found in the <code>IntentMatchers</code> class. This class contains methods to assert different methods of the <code>Intent</code> class: extras, data, components, bundles, and so on.</p>
			<p>Another important extension library comes to the aid of <code>RecyclerView</code>. The <code>onData</code> method from Espresso is only capable of testing <code>AdapterViews</code> such as <code>ListView</code> and isn’t capable of asserting <code>RecyclerView</code>. In order to use the extension, you need to add the following library to your project:</p>
			<pre class="source code">
androidTestImplementation
'com.android.support.test.espresso:espresso-contrib:3.5.0'</pre>
			<p>This library provides a <code>RecyclerViewActions</code> class, which contains a set of methods that allow you to perform actions on items inside <code>RecyclerView</code>:</p>
			<pre class="source code">
onView(withId(R.id.recycler_view))
.perform(RecyclerViewActions.actionOnItemAtPosition(0,
click()))</pre>
			<p>The preceding statement will click the item at position <code>0</code>:</p>
			<pre class="source code">
onView(withId(R.id.recycler_view)).perform(
RecyclerViewActions.scrollToPosition&lt;RecyclerView
.ViewHolder&gt;(10))</pre>
			<p>This will scroll to the 10th item in the list:</p>
			<pre class="source code">
onView(withText("myText")).check(matches(isDisplayed()))</pre>
			<p>The preceding <a id="_idIndexMarker892"/>code will check whether a view with the <code>myText</code> text is displayed, which will also apply to <code>RecyclerView</code> items.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor561"/>Testing in Jetpack Compose</h2>
			<p>Jetpack Compose<a id="_idIndexMarker893"/> offers the ability to test <code>@Composable</code> functions <a id="_idIndexMarker894"/>with a similar approach to Espresso. If we are using Robolectric, we can write our testing code in the <code>test</code> folder, and if not, we can use the <code>androidTest</code> folder and our tests will be viewed as instrumented tests. The testing library is the following:</p>
			<pre class="source code">
androidTestImplementation "androidx.compose.ui:
ui-test-junit4:1.1.1"</pre>
			<p>If we want to also test the <code>Activity</code> that sets the <code>@Composable</code> function as content, then we will also need to add the following library:</p>
			<pre class="source code">
debugImplementation "androidx.compose.ui:
ui-test-manifest:1.1.1"</pre>
			<p>To test, we would need to use a test rule that provides a set of methods used for interacting with the <code>@Composable</code> elements and performing assertions on them. We have multiple ways of obtaining that rule through the following approaches:</p>
			<pre class="source code">
class MyTest {
    @get:Rule
    var composeTestRuleForActivity =
        createAndroidComposeRule(MyActivity::class.java)
    @get:Rule
    var composeTestRuleForNoActivity = createComposeRule()
    @Test
    fun testNoActivityFunction(){
        composeTestRuleForNoActivity.setContent {
            // Set method you want to test here
        }
    }
}</pre>
			<p>In the preceding snippet, we have two test rules. The first one, <code>composeTestRuleForActivity</code>, will start the <code>Activity</code> that holds the <code>@Composable</code> function that we want to test and will hold all the nodes we want to assert.</p>
			<p>The second<a id="_idIndexMarker895"/> one, <code>composeTestRuleForNoActivity</code>, provides <a id="_idIndexMarker896"/>the ability to set as content the function we want to test. This will then allow the rule to have access to all the <code>@</code><code>Composable</code> elements.</p>
			<p>If we want to identify elements from our function, we have the following methods:</p>
			<pre class="source code">
        composeTestRule.onNodeWithText("My text")
        composeTestRule.onNodeWithContentDescription(
            "My content description")
        composeTestRule.onNodeWithTag("My test tag")</pre>
			<p>In the preceding snippet, we have the <code>onNodeWithText</code> method, which will identify a particular UI element using a text label that’s visible to the user. The <code>onNodeWithContentDescription</code> method will identify an element using the content description set, and <code>onNodeWithTag</code> will identify an element using the test tag, which is set using the <code>Modifier.testTag</code> method.</p>
			<p>Like Espresso, once we identify the element we want to interact with or perform assertions on, we have similar methods for both situations. For interacting with the element, we have methods such as the following:</p>
			<pre class="source code">
        composeTestRule.onNodeWithText("My text")
            .performClick()
            .performScrollTo()
            .performTextInput("My new text")
            .performGesture {
            }</pre>
			<p>In the preceding snippet, we perform a click, scroll, text insertion, and gesture into the element. For <a id="_idIndexMarker897"/>assertions, some <a id="_idIndexMarker898"/>examples are as follows:</p>
			<pre class="source code">
        composeTestRule.onNodeWithText("My text")
            .assertIsDisplayed()
            .assertIsNotDisplayed()
            .assertIsEnabled()
            .assertIsNotEnabled()
            .assertIsSelected()
            .assertIsNotSelected()</pre>
			<p>In the preceding example, we assert whether an element is displayed, not displayed, enabled, not enabled, selected, or not selected.</p>
			<p>If our user interface has multiple elements with the same text, we have the option to extract all of them using the following:</p>
			<pre class="source code">
        composeTestRule.onAllNodesWithText("My text")
        composeTestRule.onAllNodesWithContentDescription(
            "My content description")
        composeTestRule.onAllNodesWithTag("My test tag")</pre>
			<p>Here, we extract all the nodes that have <code>My text</code> as a text, <code>My content description</code> as a content description, and <code>My test tag</code> as a test tag. The return is a collection, which allows us to assert each element of the collection individually, like so:</p>
			<pre class="source code">
        composeTestRule.onAllNodesWithText("My text")[0]
            .assertIsDisplayed()</pre>
			<p>Here, we assert that the first element that has <code>My text</code> is displayed. We also can perform assertions on the collection, like so:</p>
			<pre class="source code">
        composeTestRule.onAllNodesWithText("My text")
            .assertCountEquals(3)
            .assertAll(SemanticsMatcher.expectValue(
            SemanticsProperties.Selected, true))
            .assertAny(SemanticsMatcher.expectValue(
            SemanticsProperties.Selected, true))</pre>
			<p>Here, we assert<a id="_idIndexMarker899"/> that the number of elements that have <code>My text</code> as a text<a id="_idIndexMarker900"/> set is three, assert whether all elements match a <code>SemanticsMatcher</code>, or assert whether any of the elements match a <code>SemanticMatcher</code>. In this case, it would assert that all the elements are selected and at least one element is selected.</p>
			<p>Another similarity to Espresso that we have when testing Jetpack Compose is the usage of <code>IdlingResource</code>. Compose provides its own <code>IdlingResource</code> abstraction, which is separate from Espresso and can be registered to our test rule as follows:</p>
			<pre class="source code">
    @Before
    fun setUp() {
        composeTestRule.registerIdlingResource(
        idlingResource)
    }
    @After
    fun tearDown() {
        composeTestRule.unregisterIdlingResource(
        idlingResource)
    }</pre>
			<p>In the preceding <a id="_idIndexMarker901"/>s<a id="_idTextAnchor562"/>nippet,<a id="_idTextAnchor563"/> we register <code>IdlingResource</code> in the <code>@Before</code> annotated<a id="_idIndexMarker902"/> method and unregister it in the <code>@</code><code>After</code> method.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor564"/>Exercise 10.03 – random waiting times</h2>
			<p>Write an <a id="_idIndexMarker903"/>application that will have two screens. The first screen will have a button. When the user presses the button, it will wait a random time between 1 and 5 seconds and then launch the second screen, which will display the text <strong class="bold">Opened after x seconds</strong>, where <strong class="bold">x</strong> is the number of seconds that passed. Write a UI test that will cover this scenario with the following features adjusted for the test:</p>
			<ul>
				<li>The <code>random</code> function will return a value of <code>1</code> when the test is run</li>
				<li><code>CountingIdlingResource</code> will be used to indicate when the timer has stopped</li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">Throughout this exercise, <code>import</code> statements are not shown. To see the full code files, refer to <a href="https://packt.link/GG32r">https://packt.link/GG32r</a>.</p>
			<p>Take the following steps to complete this exercise:</p>
			<ol>
				<li>Create a new Android Studio Project with no Activity.</li>
				<li>Add the following libraries to <code>app/build.gradle</code>:<pre class="source code">
    implementation 'androidx.test.espresso:
        espresso-idling-resource:3.5.1'
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation
        'androidx.test.espresso:espresso-core:3.5.1'
    androidTestImplementation
        'androidx.test.ext:junit:1.1.5'
    androidTestImplementation
        'androidx.test:rules:1.5.0'</pre></li>
				<li>In the <code>main</code> folder in<a id="_idIndexMarker904"/> the root package, create a class; start with a <code>Randomizer</code> class:<pre class="source code">
open class Randomizer(private val random: Random) {
    open fun getTimeToWait(): Int {
        return random.nextInt(5) + 1
    }
}</pre></li>
				<li>In the <code>main</code> folder in the root package, create a class; create a <code>Synchronizer</code> class, which will use <code>Randomizer</code> and <code>Timer</code> to wait for the random time interval. It will also use <code>CountingIdlingResource</code> to mark the start of the task and the end of the task:<pre class="source code">
class Synchronizer(
    private val randomizer: Randomizer,
    private val timer: Timer,
    private val countingIdlingResource:
        CountingIdlingResource
) {
    fun executeAfterDelay(callback: (Int) -&gt; Unit) {
        val timeToWait = randomizer.getTimeToWait()
        countingIdlingResource.increment()
        timer.schedule(CallbackTask(callback,
            timeToWait), timeToWait * 1000L)
    }
    inner class CallbackTask(
        private val callback: (Int) -&gt; Unit,
        private val time: Int
    ) : TimerTask() {
        override fun run() {
            callback(time)
            countingIdlingResource.decrement()
        }
    }
}</pre></li>
				<li>Now, create an <code>Application</code> class, which will be responsible for creating all the instances <a id="_idIndexMarker905"/>of the preceding classes:<pre class="source code">
class MyApplication : Application() {
    val countingIdlingResource =
        CountingIdlingResource("Timer resource")
    val randomizer = Randomizer(Random())
    val synchronizer =
        Synchronizer(randomizer, Timer(),
        countingIdlingResource)
}</pre></li>
				<li>Add the <code>MyApplication</code> class to <code>AndroidManifest</code> in the <code>application</code> tag with the <code>android:name</code> attribute.</li>
				<li>Create an <code>activity_1</code> layout file, which will contain a parent layout and a button:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;
    &lt;Button
        android:id="@+id/activity_1_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="@string/press_me" /&gt;
&lt;/LinearLayout&gt;</pre></li>
				<li>Create an <code>activity_2</code> layout file, which <a id="_idIndexMarker906"/>will contain a parent layout and <code>TextView</code>:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;
    &lt;TextView
        android:id="@+id/activity_2_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center" /&gt;
&lt;/LinearLayout&gt;</pre></li>
				<li>Create the <code>Activity1</code> class, which<a id="_idIndexMarker907"/> will implement the logic for the button click:<pre class="source code">
class Activity1 : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_1)
        findViewById&lt;Button&gt;(R.id.activity_1_button)
        .setOnClickListener {
            (application as MyApplication)
            .synchronizer.executeAfterDelay {
                startActivity(Activity2.newIntent(this
                , it))
            }
        }
    }
}</pre></li>
				<li>Create the <code>Activity2</code> class, which will display the received data through the intent:<pre class="source code">
class Activity2 : AppCompatActivity() {
    companion object {
        private const val EXTRA_SECONDS =
            "extra_seconds"
        fun newIntent(context: Context, seconds: Int)
            = Intent(context, Activity2::class.java)
            .putExtra(EXTRA_SECONDS, seconds)
    }
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_2)
        findViewById&lt;TextView&gt;(
            R.id.activity_2_text_view).text =
            getString(R.string.opened_after_x_seconds,
            intent.getIntExtra(EXTRA_SECONDS, 0))
    }
}</pre></li>
				<li>Make sure <a id="_idIndexMarker908"/>that the relevant strings are added to <code>strings.xml</code>:<pre class="source code">
    &lt;string name="press_me"&gt;Press Me&lt;/string&gt;
    &lt;string name="opened_after_x_seconds"&gt;Opened after
    %d seconds&lt;/string&gt;</pre></li>
				<li>Make sure that the two activities are added to <code>AndroidManifest.xml</code>:<pre class="source code">
    &lt;application
        … &gt;
        &lt;activity
            android:name=".Activity1"
            android:exported="true"&gt;
    &lt;/application&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/TkEX9">https://packt.link/TkEX9</a>.</p>
			<ol>
				<li value="13">Create a <code>FlowTest</code> class in the <code>androidTest</code> directory, which will register <code>IdlingResource</code> from the <code>MyApplication</code> object and will assert the outcome<a id="_idIndexMarker909"/> of the click:<pre class="source code">
@RunWith(AndroidJUnit4::class)
@LargeTest
class FlowTest {
    @Test
    fun verifyFlow() {
        onView(withId(R.id.activity_1_button))
            .perform(click())
        onView(withId(R.id.activity_2_text_view))
           .check(matches(withText(myApplication
           .getString(R.string.opened_after_x_seconds,
           1))))
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/711Vw">https://packt.link/711Vw</a>.</p>
			<ol>
				<li value="14">Run the test multiple times and check the test results. Notice that the test will have a 20% chance of success, but it will wait until the button from <code>Activity1</code> is clicked. This means that the idling resource is working. Another thing to observe is that there is an element of randomness here.</li>
				<li>Tests don’t like randomness, so we need to eliminate it by making the <code>Randomizer</code> class open and creating a subclass in the <code>androidTest</code> directory. We can do the same for the <code>MyApplication</code> class and provide a different randomizer called <code>TestRandomizer</code>:<pre class="source code">
class TestRandomizer(random: Random) :
Randomizer(random) {
    override fun getTimeToWait(): Int {
        return 1
    }
}</pre></li>
				<li>Now, modify<a id="_idIndexMarker910"/> the <code>MyApplication</code> class in a way in which we can override the randomizer from a subclass:<pre class="source code">
open class MyApplication : Application() {
    val countingIdlingResource =
        CountingIdlingResource("Timer resource")
    lateinit var synchronizer: Synchronizer
    override fun onCreate() {
        super.onCreate()
        synchronizer =
            Synchronizer(createRandomizer(), Timer(),
            countingIdlingResource)
    }
    open fun createRandomizer() = Randomizer(Random())
}</pre></li>
				<li>In the <code>androidTest</code> directory, create <code>TestMyApplication</code>, which will extend <code>MyApplication</code> and override the <code>createRandomizer</code> method:<pre class="source code">
class TestMyApplication : MyApplication() {
    override fun createRandomizer(): Randomizer {
        return TestRandomizer(Random())
    }
}</pre></li>
				<li>Finally, in the <code>androidTest/java</code> folder in the root package, create an instrumentation <a id="_idIndexMarker911"/>test runner that will use this new <code>Application</code> class inside the test:<pre class="source code">
class MyApplicationTestRunner : AndroidJUnitRunner() {
    @Throws(Exception::class)
    override fun newApplication(
        cl: ClassLoader?,
        className: String?,
        context: Context?
    ): Application? {
        return super.newApplication(cl,
        TestMyApplication::class.java.name, context)
    }
}</pre></li>
				<li>Add the new test runner to the Gradle configuration:<pre class="source code">
android {
    ...
    defaultConfig {
        ...
        testInstrumentationRunner
            "com.android.testable.myapplication
            .MyApplicationTestRunner"
    }
}</pre></li>
			</ol>
			<p>If we run the test now, the test should pass; however, we have a couple of problems with our dependencies. For the <code>Randomizer</code> class, we had to make our class open so that it could be extended in the <code>androidTest</code> folder.</p>
			<p>Another issue is the fact that our application code contains references to idling resources that are part of the testing libraries. To solve both problems, we will need to define abstractions for the <code>Randomizer</code> and <code>Synchronizer</code> classes.</p>
			<ol>
				<li value="20">In the <code>main/java</code> folder<a id="_idIndexMarker912"/> in the root package, create an interface called <code>Randomizer</code>:<pre class="source code">
interface Randomizer {
    fun getTimeToWait(): Int
}</pre></li>
				<li>Rename the previous <code>Randomizer</code> class <code>RandomizerImpl</code> and implement the <code>Randomizer</code> interface as follows:<pre class="source code">
class RandomizerImpl(private val random: Random) :
Randomizer {
    override fun getTimeToWait(): Int {
        return random.nextInt(5) + 1
    }
}</pre></li>
				<li>In <code>MyApplication</code>, modify the <code>createRandomizer</code> method to have the <code>Randomizer</code> return type, which will return an instance of <code>RandomizerImpl</code>:<pre class="source code">
open class MyApplication : Application() {
    …
    open fun createRandomizer() : Randomizer =
        RandomizerImpl(Random())
}</pre></li>
				<li>Modify <code>TestRandomizer</code> to implement the <code>Randomizer</code> interface:<pre class="source code">
class TestRandomizer : Randomizer {
    override fun getTimeToWait(): Int {
        return 1
    }
}</pre></li>
				<li>Modify <code>TestMyApplication</code> to <a id="_idIndexMarker913"/>correct the compile errors:<pre class="source code">
class TestMyApplication : MyApplication() {
    override fun createRandomizer(): Randomizer {
        return TestRandomizer()
    }
}</pre></li>
				<li>In <code>app/build.gradle</code>, make the idling resource dependency <code>androidTestImplementation</code>:<pre class="source code">
    androidTestImplementation 'androidx.test.espresso:
    espresso-idling-resource:3.5.1'</pre></li>
				<li>In the <code>main/java</code> folder in the root package, create an interface called <code>Synchronizer</code>:<pre class="source code">
interface Synchronizer {
    fun executeAfterDelay(callback: (Int) -&gt; Unit)
}</pre></li>
				<li>Rename the previous <code>Synchronizer</code> class <code>SynchronizerImpl</code>, implement the <code>Synchronizer</code> interface, and remove the usages of <code>CountingIdlingResource</code>:<pre class="source code">
class SynchronizerImpl(
    private val randomizer: Randomizer,
    private val timer: Timer
) : Synchronizer {
    override fun executeAfterDelay(callback: (Int) -&gt;
    Unit) {
        val timeToWait = randomizer.getTimeToWait()
            timer.schedule(CallbackTask(callback,
            timeToWait), timeToWait * 1000L)
    }
    inner class CallbackTask(
        private val callback: (Int) -&gt; Unit,
        private val time: Int
    ) : TimerTask() {
        override fun run() {
            callback(time)
        }
    }
}</pre></li>
				<li>Modify <code>MyApplication</code> so that it will open the ability to provide different <code>Synchronizer</code> instances from the <code>TestMyApplication</code> class:<pre class="source code">
open class MyApplication : Application() {
    lateinit var synchronizer: Synchronizer
    override fun onCreate() {
        super.onCreate()
        synchronizer = createSynchronizer()
    }
    open fun createRandomizer(): Randomizer =
        RandomizerImpl(Random())
    open fun createSynchronizer(): Synchronizer =
        SynchronizerImpl(createRandomizer(), Timer())
}</pre></li>
				<li>In the <code>androidTest</code> folder, create a class called <code>TestSynchronizer</code>, which will<a id="_idIndexMarker914"/> wrap a <code>Synchronizer</code>, and then use <code>CountingIdlingResource</code> to increment and decrement a counter when <code>executeAfterDelay</code> is started and finished:<pre class="source code">
class TestSynchronizer(
    private val synchronizer: Synchronizer,
    private val countingIdlingResource:
        CountingIdlingResource
) : Synchronizer {
    override fun executeAfterDelay(callback: (Int) -&gt;
    Unit) {
        countingIdlingResource.increment()
        synchronizer.executeAfterDelay {
            callback(it)
            countingIdlingResource.decrement()
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding example, we have a reference to a <code>Synchronizer</code> instance. When <code>executeAfterDelay</code> is called, then we inform Espresso to wait. We then invoke the actual <code>Synchronizer</code> instance, and when it finishes the execution, we then inform Espresso to resume.</p>
			<ol>
				<li value="30">Modify <code>TestMyApplication</code> to <a id="_idIndexMarker915"/>provide an instance of <code>TestSynchronizer</code>:<pre class="source code">
class TestMyApplication : MyApplication() {
    val countingIdlingResource =
        CountingIdlingResource("Timer resource")
    override fun createRandomizer(): Randomizer {
        return TestRandomizer()
    }
    override fun createSynchronizer(): Synchronizer {
        return
          TestSynchronizer(super.createSynchronizer(),
          countingIdlingResource)
    }
}</pre></li>
			</ol>
			<p>In the preceding snippet, we create a new <code>TestSynchronizer</code> that wraps the <code>Synchronizer</code> defined in <code>MyApplication</code> and adds the <code>CountingIdlingResource</code>.</p>
			<ol>
				<li value="31">In <code>FlowTest</code>, change the reference to <code>MyApplication</code> with <code>TestMyApplication</code>:<pre class="source code">
private val myApplication =
    getApplicationContext&lt;TestMyApplication&gt;()</pre></li>
			</ol>
			<p>When running the test now, everything should pass, as shown in <em class="italic">Figure 10</em><em class="italic">.10</em>:</p>
			<div><div><img src="img/B19411_10_010.jpg" alt="Figure 10.10 – Output of Exercise 10.03"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Output of Exercise 10.03</p>
			<p>This type of exercise shows how to avoid randomness in a test and provides concrete and repeatable input to make our tests reliable. Similar approaches are taken with dependency injection frameworks, where entire modules can be replaced in the test suite to ensure the test’s reliability.</p>
			<p>One of the most<a id="_idIndexMarker916"/> common things to be replaced is API communication. Another issue this approach solves is the decrease in waiting time. If this type of scenario were to have been repeated across your tests, then the execution time of them would have increased because of this.</p>
			<p>In this exercise, we have looked at how we can write instrumented tests and execute them on an emulator or physical device. We have also analyzed how we can decorate our objects with <code>CountingIdlingResources</code> to be able t<a id="_idTextAnchor565"/><a id="_idTextAnchor566"/>o monitor asynchronous operations, and how we can switch dependencies that cause flakiness and provide stub data instead.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor567"/>TDD</h1>
			<p>Let’s assume <a id="_idIndexMarker917"/>that you are tasked with building an activity that displays a calculator with the add, subtract, multiply, and divide options. You must also write tests for your implementation. Typically, you would build your UI and your activity and a separate <code>Calculator</code> class. Then, you would write the unit tests for your <code>Calculator</code> class and then for your <code>activity</code> class.</p>
			<p>If you were to translate the TDD process to implementing features on an Android app, you would have to write your UI test with your scenarios first. To achieve this, you can create a skeleton UI to avoid compile-time errors. After your UI test, you would need to write your <code>Calculator</code> test. Here, you would also need to create the necessary methods in the <code>Calculator</code> class to avoid compile-time errors.</p>
			<p>If you ran your tests in this phase, they would fail. This would force you to implement your code until the tests pass. Once your <code>Calculator</code> tests pass, you can connect your calculator to your UI until your UI tests pass. While this seems like a counter-intuitive approach, it solves two issues once the process is mastered:</p>
			<ul>
				<li>Less time will be spent writing code because you will ensure that your code is testable, and you need to write only the amount of code necessary for the test to pass</li>
				<li>Fewer bugs will be introduced becau<a id="_idTextAnchor568"/>se developers will be able to analyze different outcomes</li>
			</ul>
			<p>Have a look at the following diagram, which shows the TDD cycle:</p>
			<div><div><img src="img/B19411_10_011.jpg" alt="Figure 10.11 – TDD cycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – TDD cycle</p>
			<p>In the preceding<a id="_idIndexMarker918"/> figure, we can see the development cycle in a TDD process. You should start from a point where your tests are failing. Implement changes for the tests to pass. When you update or add new features, you can repeat the process.</p>
			<p>Going back to our factorial examples, we started with a <code>factorial</code> function that didn’t cover all our scenarios and had to keep updating the function every time a new test was added. TDD is built with that idea in mind. You start with an empty function. You start defining your testing scenarios: what are the conditions for success? What’s the minimum? What’s the maximum? Are there any exceptions to the main rule? What are they? These questions can help developers define the<a id="_idTextAnchor569"/><a id="_idTextAnchor570"/>ir test cases. Then, these cases can be written. Let’s now see how this can be done practically through the next exercise.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor571"/>Exercise 10.04 – using TDD to calculate the sum of numbers</h2>
			<p>Write a function<a id="_idIndexMarker919"/> that has as input the integer <code>n</code> and will return the sum of numbers from <code>1</code> to <code>n</code>. The function should be written with a TDD approach, and the following criteria should be satisfied:</p>
			<ul>
				<li>For <code>n&lt;=0</code>, the function will return the value <code>-1</code></li>
				<li>The function should be able to return the correct value for <code>Int.MAX_VALUE</code></li>
				<li>The function should be quick, even for <code>Int.MAX_VALUE</code></li>
			</ul>
			<p>Perform the following steps to complete this exercise:</p>
			<ol>
				<li>Create a new Android Studio Project with No Activity.</li>
				<li>Make sure that the following library is added to <code>app/build.gradle</code>:<pre class="source code">
testImplementation 'junit:junit:4.13.2'</pre></li>
				<li>In the <code>main/java</code> folder in the root package, create an <code>Adder</code> class with the <code>sum</code> method, which will return <code>0</code>, to satisfy the compiler:<pre class="source code">
class Adder {
    fun sum(n: Int): Int = 0
}</pre></li>
				<li>Create an <code>AdderTest</code> class in the <code>test</code> directory and define our test cases. We will have the following test cases: <code>n=1</code>, <code>n=2</code>, <code>n=0</code>, <code>n=-1</code>, <code>n=10</code>, <code>n=20</code>, and <code>n=Int.MAX_VALUE</code>. We can split the successful scenarios into one method and the unsuccessful ones into a separate method:<pre class="source code">
class AdderTest {
    private val adder = Adder()
    @Test
    fun sumSuccess() {
        assertEquals(1, adder.sum(1))
        assertEquals(3, adder.sum(2))
        assertEquals(55, adder.sum(10))
        assertEquals(210, adder.sum(20))
        assertEquals(2305843008139952128L,
            adder.sum(Int.MAX_VALUE))
    }
    @Test
    fun sumError(){
        assertEquals(-1, adder.sum(0))
        assertEquals(-1, adder.sum(-1))
    }
}</pre></li>
			</ol>
			<p>If we <a id="_idTextAnchor572"/>run<a id="_idIndexMarker920"/> the tests for the <code>AdderTest</code> class, we will see an output like the following figure, meaning that all our tests failed:</p>
			<div><div><img src="img/B19411_10_012.jpg" alt="Figure 10.12 – Initial test status for Exercise 10.04"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Initial test status for Exercise 10.04</p>
			<ol>
				<li value="5">Let’s first address the success scenarios by implementing the sum in a loop from <code>1</code> to <code>n</code>:<pre class="source code">
class Adder {
    fun sum(n: Int): Long {
        var result = 0L
        for (i in 1..n) {
            result += i
        }
        return r<a id="_idTextAnchor573"/>esult
    }
}</pre></li>
			</ol>
			<p>If we run the tests now, you will see that one will pass and the other will fail, like the following figure:</p>
			<div><div><img src="img/B19411_10_013.jpg" alt="Figure 10.13 – Test status after resolving the success scenario for Exercise 10.04"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Test status after resolving the success scenario for Exercise 10.04</p>
			<ol>
				<li value="6">If we look at the time it took to execute the successful test, it seems a bit long. This can add up when thousands of unit tests are present in one project. We can now optimize <a id="_idIndexMarker921"/>our code to deal with the issue by applying the <em class="italic">n(n+1)/2</em> formula:<pre class="source code">
class Adder {
    fun sum(n: Int): Long {
        return (n * (n.toLong() + 1)) / 2
    }
}</pre></li>
			</ol>
			<p>Running the tests now will drastically reduce the execution time to a few milliseconds.</p>
			<ol>
				<li value="7">Now, let’s focus on solving our failure scenarios. We can do this by adding a condition for when <code>n</code> is smaller than or equal to <code>0</code>:<pre class="source code">
class Adder {
    fun sum(n: Int): Long {
        return if (n &gt; 0) (n * <a id="_idTextAnchor574"/>(n.toLong() + 1)) / 2
else -1
    }
}</pre></li>
			</ol>
			<p>If we run the tests now, we should see them all passing, like the following figure:</p>
			<div><div><img src="img/B19411_10_014.jpg" alt="Figure 10.14 – Passing tests for Exercise 10.04"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Passing tests for Exercise 10.04</p>
			<p>In this exercise, we have applied the concept of TDD to a very small example to demonstrate how the technique can be used. We have observed how, starting from the skeleton code, we can create a suite of tests to verify our conditions, and how by constantly running tests, we improved the code until a point where all the tests pass. As you have probably noticed, the concept isn’t an intuitive one. Some developers find it hard to define how big skeleton code should be to start creating the test cases, while others, out <a id="_idIndexMarker922"/>of habit, focus on writing the code first and then d<a id="_idTextAnchor575"/>eveloping the<a id="_idTextAnchor576"/><a id="_idTextAnchor577"/> test. In either case, developers will need a lot of practice with the technique until it’s properly mastered.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor578"/>Activity 10.01 – developing with TDD</h2>
			<p>Using the TDD<a id="_idIndexMarker923"/> approach, develop an application that contains three activities and works as follows:</p>
			<ul>
				<li>In activity 1, you will display a numeric <code>EditText</code> element and a button. When the button is clicked, the number in <code>EditText</code> will be passed to activity 2.</li>
				<li>Activity 2 will generate a list of items asynchronously. The number of items will be represented by the number passed from activity 1. You can use the <code>Timer</code> class with a delay of 1 second. Each item in the list will display the text <code>Item x</code> where <code>x</code> is the position in the list. When an item is clicked, you should pass the clicked item to activity 3.</li>
				<li>Activity 3 will display the text <code>You clicked y</code>, where <code>y</code> is the text of the item the user has clicked.</li>
			</ul>
			<p>The tests for the app will be the following:</p>
			<ul>
				<li>Unit tests with Mockito and <code>mockito-kotlin</code> annotated with <code>@SmallTest</code></li>
				<li>Integration tests with Robolectric and Espresso annotated with <code>@MediumTest</code></li>
				<li>UI tests with Espresso annotated with <code>@LargeTest</code> and using the <code>Robot</code> pattern</li>
			</ul>
			<p>Run the test commands from the command line. To complete this activity, you need to take the following steps:</p>
			<ol>
				<li>You will<a id="_idIndexMarker924"/> need Android Studio 4.1.1 or higher with Kotlin 1.4.21 or higher for the Parcelize Kotlin plugin.</li>
				<li>Create the three activities and the UI for each of them.</li>
				<li>In the <code>androidTest</code> folder, create three robots, one for each activity:<ul><li>Robot 1 will contain the interaction with <code>EditText</code> and the button</li><li>Robot 2 will assert the number of items on the screen and interact with an item in the list</li><li>Robot 3 will assert the text displayed in <code>TextView</code></li></ul></li>
				<li>Create an instrumented test class that will have one test method using the preceding robots.</li>
				<li>Create an <code>Application</code> class that will hold instances of all the classes that will be unit-tested.</li>
				<li>Create three classes representing integration tests, one for each of the activities. Each of these classes will contain one test method for interactions and data loading. Each integration test will assert the intents passed between the activities.</li>
				<li>Create a class that will provide the text required for the UI. It will have a reference to a <code>Context</code> object and will contain two methods that will provide the text for the UI, which will return an empty string.</li>
				<li>Create the test for the preceding class in which the two methods are tested.</li>
				<li>Implement the class for the preceding tests to pass.</li>
				<li>Create a class that will be responsible for loading the list in <code>Activity2</code>, and provide an empty method for loading. The class will have a reference to the timer and the idling resource. Here, you should also create a data class that will represent the model for <code>RecyclerView</code>.</li>
				<li>Create a unit test for the preceding class.</li>
				<li>Create the <a id="_idIndexMarker925"/>implementation for the preceding class and run the unit tests until they pass.</li>
				<li>In the <code>Application</code> class, instantiate the classes that were unit-tested and start using them in your activities. Do this until your integration tests pass.</li>
				<li>Provide <code>IntegrationTestApplication</code>, which will return a new implementation of the class responsible for loading. This is to avoid making your integration test for <code>Activity2</code> wait until loading is complete.</li>
				<li>Provide <code>UiTestApplication</code>, which will again reduce the loading time of your models and connect the idling resource to Espresso. Implement the remaining work for the UI test to pass.</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found at<a id="_idTextAnchor579"/><a id="_idTextAnchor580"/> <a href="https://packt.link/Ma4tD">https://packt.link/Ma4tD</a>.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor581"/>Summary</h1>
			<p>In this chapter, we looked at the different types of testing and the frameworks available for implementing these tests. We also looked at the testing environment and how to structure it for each environment, as well as structuring your code into multiple components that can be individually unit-tested.</p>
			<p>We analyzed different ways to test code, how we should approach testing, and how, by looking at different test results, we can improve our code. With TDD, we learned that by starting with testing, we can write our code faster and ensure it is less error-prone.</p>
			<p>The activity is where all these concepts came together into building a simple Android application, and we can observe how, by adding tests, the development time increases, but this pays off in the long term by eliminating possible bugs that appear when the code is modified.</p>
			<p>The frameworks we have studied are some of the most common ones, but there are others that build on top of these and are used by developers in their projects, such as Mockk (a mocking library designed for Kotlin that takes advantage of a lot of the features of the language) and Barista (written on top of Espresso and simplifies the syntax of UI tests), to note a few.</p>
			<p>Think of all the concepts presented here as building blocks that fit into two processes present in the software engineering world: automation and continuous integration. Automation takes redundant and repetitive work out of the hands of developers and puts it into the hands of machines.</p>
			<p>Instead of having a team of quality assurance people testing your application to make sure the requirements are met, you can instruct a machine through a variety of tests and test cases to test the application instead and just have one person reviewing the results of the tests.</p>
			<p>Continuous integration builds on the concept of automation to verify your code the moment you submit it for review from other developers. A project with continuous integration would have a setup along the following lines: a developer submits work for review in a source control repository such as GitHub.</p>
			<p>A machine in the cloud would then start executing the tests for the entire project, making sure that nothing was broken, and the developer can move on to a new task. If the tests pass, then the rest of the developers can review the code, and when it is correct, it can be merged, and a new build can be created in the cloud and distributed to the rest of the team and the testers.</p>
			<p>All of this takes place while the initial developer can safely work on something else. If anything fails in the process, then they can pause the new task and go and address any issues in their work. The continuous integration process can then be expanded into continuous delivery, where similar automation can be set up when preparing a submission to Google Play that can be handled almost entirely by machines with minor involvement from developers.</p>
			<p>In the chapters that follow, you will learn about how to organize your code when building more complex applications that use the storage capabilities of the device and connect to the cloud to request data. Each of those components can be individually unit-tested, and you can apply integration tests to assert a successful integration of multiple components.</p>
		</div>
	</body></html>