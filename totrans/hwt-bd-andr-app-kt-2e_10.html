<html><head></head><body>
		<div id="_idContainer183" class="IMG---Figure">
			<h1 id="_idParaDest-154" class="chapter number"><a id="_idTextAnchor512"/><a id="_idTextAnchor513"/><a id="_idTextAnchor514"/><a id="_idTextAnchor515"/><a id="_idTextAnchor516"/>10</h1>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor517"/>Unit Tests and Integration Tests with JUnit, Mockito, and Espresso</h1>
			<p><a id="_idTextAnchor518"/>In this chapter, you will learn about testing on the Android platform and how to create unit tests, integration tests, and UI tests. You will see how to create each of these types of tests, analyze how they run, and work with frameworks such as JUnit, Mockito, Robolectric, <span class="No-Break">and Espresso.</span></p>
			<p>You will also learn about test-driven development (TDD), a software development practice that prioritizes tests over implementation. By the end of this chapter, you will be able to combine your new testing skills to work on a <span class="No-Break">realistic project.</span></p>
			<p><a id="_idTextAnchor519"/>In previous chapters, you learned about how to load background data and display it in the UI and how to set up API calls to retrieve data. But how can you be sure that things work well? What if you’re in a situation where you have to fix a bug in a project that you haven’t interacted much with in the past? How can you know that the fix you are applying won’t trigger another bug? The answer to these questions is <span class="No-Break">through tests.</span></p>
			<p>In this chapter, we will analyze the types of tests developers can write and we will look at available testing tools to ease the testing experience. The first issue that arises is the fact that desktops or laptops (which have different operating systems) are used to develop mobile applications. This implies that the tests must also be run on the device or an emulator, which will slow the <span class="No-Break">tests down.</span></p>
			<p>To solve this issue, we are presented with two types of tests: <strong class="bold">local tests</strong>, which are located in the <strong class="source inline">test</strong> folder and will run on your machine, and <strong class="bold">instrumented tests</strong>, which are located in the <strong class="source inline">androidTest</strong> folder and will run on the device <span class="No-Break">or emulator.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">JUnit</span></li>
				<li>Android Studio <span class="No-Break">testing tips</span></li>
				<li><span class="No-Break">Mockito</span></li>
				<li><span class="No-Break">Integration tests</span></li>
				<li><span class="No-Break">UI tests</span></li>
				<li><span class="No-Break">TDD</span></li>
			</ul>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor520"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/pNbuk"><span class="No-Break">https://packt.link/pNbuk</span></a></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor521"/>Types of testing</h1>
			<p>Both tests rely <a id="_idIndexMarker785"/>on the Java <strong class="bold">JUnit</strong> library, which <a id="_idIndexMarker786"/>helps developers set up their tests and group them into different categories. It also provides different configuration options, as well as extensions that other libraries can build upon. We will also investigate the testing pyramid, which helps guide developers as to how to structure <span class="No-Break">their tests.</span></p>
			<p>We will start at the bottom of the pyramid, which is represented <a id="_idIndexMarker787"/>by <strong class="bold">unit tests</strong>, move upward through <strong class="bold">integration tests</strong>, and <a id="_idIndexMarker788"/>finally, reach the top, which is<a id="_idIndexMarker789"/> represented by <strong class="bold">end-to-end tests</strong> (UI tests). You’ll have the opportunity to learn about the tools that aid in writing each of these types <span class="No-Break">of tests:</span></p>
			<ul>
				<li><strong class="bold">Mockito</strong> and <strong class="source inline">mockito-kotlin</strong>, which <a id="_idIndexMarker790"/>help mainly in unit tests and are useful for creating mocks or test doubles in which we can manipulate inputs so that we can assert different scenarios. (A mock or test double is an object that mimics the implementation of another object. Every time a test interacts with mocks, you can specify the behavior of <span class="No-Break">these interactions.)</span></li>
				<li><strong class="bold">Robolectric</strong>, which is an<a id="_idIndexMarker791"/> open source library that brings the Android framework onto your machine, allows you to test activities and fragments locally and not on the emulator. This can be used for both unit tests and <span class="No-Break">integration tests.</span></li>
				<li><strong class="bold">Espresso</strong>, which<a id="_idIndexMarker792"/> allows developers to create interactions (clicking buttons, inserting text in <strong class="source inline">EditText</strong> components, and so on) and assertions (verifying that views display certain text, are currently being displayed to the user, are enabled, and so on) on an app’s UI in an <span class="No-Break">instrumented test.</span></li>
			</ul>
			<p>In this chapter, we will also<a id="_idIndexMarker793"/> look at <strong class="bold">TDD</strong>. This is a software development process where tests take priority. A simple way of describing it is writing the test first. We will analyze how this approach is taken when developing features for Android applications. One of the things to keep in mind is that for an application to be properly tested, its classes must be properly written. One way to do this is by clearly defining the boundaries between your classes and splitting them based on the tasks you want them <span class="No-Break">to accomplish.</span></p>
			<p>Once you have achieved this, you can also rely on<a id="_idIndexMarker794"/> the <strong class="bold">dependency inversion</strong> and <strong class="bold">dependency injection</strong> principles when writing your classes. When<a id="_idIndexMarker795"/> these principles are applied properly, you should be able to inject fake objects into the subjects of your tests and manipulate the input to suit your <span class="No-Break">testing scenario.</span></p>
			<p>Dependency injection also helps when writing instrumented tests to help you swap modules that make network calls with local data in order to make your tests independent of external factors, such as networks. Instrumented tests are tests that run on a device or an emulator. The <strong class="source inline">instrument</strong> keyword comes from the instrumentation<a id="_idIndexMarker796"/> framework, which assembles these tests and then executes them on<a id="_idTextAnchor522"/> <span class="No-Break">the device.</span></p>
			<p>Ideally, each application should have three types <span class="No-Break">of tests:</span></p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: These are<a id="_idIndexMarker797"/> local tests that validate individual classes and methods. They should represent most of your tests and they should be fast, easy to debug, and easy to maintain. They are also known as <span class="No-Break">small tests.</span></li>
				<li><strong class="bold">Integration tests</strong>: These are either local tests with Robolectric or instrumented tests that validate interactions between your app’s modules and components. These are slower and more complex than unit tests. The increase in complexity is due to the interaction between the components. These are also known as <span class="No-Break">medium tests.</span></li>
				<li><strong class="bold">UI tests (end-to-end tests)</strong>: These are instrumented tests that verify complete user journeys and scenarios. This makes them more complex and harder to maintain; they should represent the smallest number of your total test number. These are also known as <span class="No-Break">large tests.</span></li>
			</ul>
			<p>In the following figure, you can observe the <strong class="bold">testing pyramid</strong>. The recommendation from Google is to keep a <a id="_idIndexMarker798"/>ratio of 70:20:10 (unit tests: integration tests: UI tests) for<a id="_idTextAnchor523"/> <span class="No-Break">your tests:</span></p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B19411_10_01.jpg" alt="Figure 10.1 – Test﻿ing pyramid"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Test<a id="_idTextAnchor524"/>ing pyramid</p>
			<p>As mentioned in the previous section, a unit test is a test that verifies a small portion of your code, and most of your tests should be unit tests that cover all sorts of scenarios (success, errors, limits, and more). Ideally, these tests should be local, but there are a few exceptions <a id="_idIndexMarker799"/>where you can make them instrumented. Those cases are rare and should be limited to when you want to interact with specific hardware o<a id="_idTextAnchor525"/><a id="_idTextAnchor526"/>f<a id="_idTextAnchor527"/> <span class="No-Break">the device.</span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor528"/>JUnit</h1>
			<p>JUnit is a framework <a id="_idIndexMarker800"/>for writing unit tests both in Java and Android. It is responsible for how tests are executed, allowing developers to configure their tests. It offers a multitude of features, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Setup and teardown</strong>: These are<a id="_idIndexMarker801"/> called before and after each test method is executed, allowing developers to set up relevant data for the test and clear it once the test is executed. They are represented by the <strong class="source inline">@Before</strong> and <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">After</strong></span><span class="No-Break"> annotations.</span></li>
				<li><strong class="bold">Assertions</strong>: These are used to verify the result of an operation against an <span class="No-Break">expected value.</span></li>
				<li><strong class="bold">Rules</strong>: These allow developers to set up inputs that are common for <span class="No-Break">multiple tests.</span></li>
				<li><strong class="bold">Runners</strong>: Using these, you can specify how the tests can <span class="No-Break">be executed.</span></li>
				<li><strong class="bold">Parameters</strong>: These allow a test method to be executed with <span class="No-Break">multiple inputs.</span></li>
				<li><strong class="bold">Orderings</strong>: These specify in which order the tests should <span class="No-Break">be executed.</span></li>
				<li><strong class="bold">Matchers</strong>: These allow you to define patterns that can then be used to validate the results of the<a id="_idIndexMarker802"/> subject of your tests, or help you control the behavior <span class="No-Break">of mocks.</span></li>
			</ul>
			<p>In Android Studio, when a new project is created, the <strong class="source inline">app</strong> module comes with the JUnit library in Gradle. This should be visible <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
testImplementation 'junit:junit:4.13.2'</pre>
			<p>Let’s look at <a id="_idIndexMarker803"/>the following class that we need <span class="No-Break">to test:</span></p>
			<pre class="source code">
class MyClass {
    fun factorial(n: Int): Int {
        return IntArray(n) {
            it+1
        }.reduce { acc, i -&gt;
            acc * i
        }
    }
}</pre>
			<p>This method should return the factorial of the number <strong class="source inline">n</strong>. We can start with a simple test that checks the value. To create a new unit test, you will need to create a new class in the <strong class="source inline">test</strong> directory of <span class="No-Break">your project.</span></p>
			<p>The typical convention most developers follow is to add the <strong class="source inline">Test</strong> suffix to your class name and place it under the same package in the <strong class="source inline">test</strong> directory. For example, <strong class="source inline">com.mypackage.ClassA</strong> will have the test <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">com.mypackage.ClassATest</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
import org.junit.Assert.assertEquals
import org.junit.Test
class MyClassTest {
    private val myClass = MyClass()
    @Test
    fun computesFactorial() {
        val n = 3
        val result = myClass.factorial(n)
        assertEquals(6, result)
    }
}</pre>
			<p>In this test, you <a id="_idIndexMarker804"/>can see that we initialize the class under test, and the test method itself is annotated with the <strong class="source inline">@Test</strong> annotation. The test method itself will assert that <strong class="source inline">(3!)==6</strong>. The assertion is done using the <strong class="source inline">assertEquals</strong> method from the JUnit library. A common practice in development is to split the test into three areas, also known <a id="_idIndexMarker805"/>as <span class="No-Break"><strong class="bold">Arrange-Act-Assert</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">AAA</strong></span><span class="No-Break">):</span></p>
			<ul>
				<li><strong class="bold">Arrange</strong>: Where the input <span class="No-Break">is initialized</span></li>
				<li><strong class="bold">Act</strong>: Where the method under test <span class="No-Break">is called</span></li>
				<li><strong class="bold">Assert</strong>: Where the verification <span class="No-Break">is done</span></li>
			</ul>
			<p>We can write another test to make sure that the value is correct, but we will end up duplicating the code. We can now attempt to write a parameterized test. To do this, we will need to use the parameterized test runner. The preceding test has its own built-in runner provided <span class="No-Break">by JUnit.</span></p>
			<p>The parameterized runner will run the test repeatedly for different values that we provide, and it will look like the following – please note that <strong class="source inline">import</strong> statements have been removed <span class="No-Break">for brevity:</span></p>
			<pre class="source code">
@RunWith(Parameterized::class)
class MyClassTest(
    private val input: Int,
    private val expected: Int
) {
    companion object {
        @Parameterized.Parameters
        @JvmStatic
        fun getData(): Collection&lt;Array&lt;Int&gt;&gt; = listOf(
            arrayOf(0, 1),
            arrayOf(1, 1),
            arrayOf(2, 2),
            arrayOf(3, 6),
            arrayOf(4, 24),
            arrayOf(5, 120)
        )
    }
    private val myClass = MyClass()
    @Test
    fun computesFactorial() {
        val result = myClass.factorial(input)
        assertEquals(expected, result)
    }
}</pre>
			<p>This will run six<a id="_idIndexMarker806"/> tests. The usage of the <strong class="source inline">@Parameterized</strong> annotation tells JUnit that this is a test with multiple parameters and allows us to add a constructor for the test that will represent the input value for our <strong class="source inline">factorial</strong> function and the output. We then defined a collection of parameters with the use of the <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">Parameterized.Parameters</strong></span><span class="No-Break"> annotation.</span></p>
			<p>Each parameter for this test is a separate list containing the input and the expected output. When JUnit runs this test, it will run a new instance for each parameter and then execute the test method. This will produce five successes and one failure when we test <strong class="source inline">0!</strong>, meaning that we have found <span class="No-Break">a bug.</span></p>
			<p>We never accounted for a situation when <strong class="source inline">n = 0</strong>. Now, we can go back to our code to fix the failure. We can do this by replacing the <strong class="source inline">reduce</strong> function, which doesn’t allow us to specify an initial value, with a <strong class="source inline">fold</strong> function, which allows us to give the initial value <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">1</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
fun factorial(n: Int): Int {
        return IntArray(n) {
            it + 1
        }.fold(1, { acc, i -&gt; acc * i })
    }</pre>
			<p>Running the tests <a id="_idIndexMarker807"/>now, they will all pass. But that doesn’t mean we are done here. There are many things that can go wrong. What happens if <strong class="source inline">n</strong> is a negative number? Since we are dealing with factorials, we may get large numbers. We are working with integers in our examples, which means that the integer will overflow <span class="No-Break">after </span><span class="No-Break"><strong class="source inline">12!</strong></span><span class="No-Break">.</span></p>
			<p>Normally, we would create new test methods in the <strong class="source inline">MyClassTest</strong> class, but since the parameterized runner is used, all our new methods will be run multiple times, which will cost us time, so we will create a new test class to check <span class="No-Break">our errors:</span></p>
			<pre class="source code">
class MyClassTest2 {
    private val myClass = MyClass()
    @Test(expected =
        MyClass.FactorialNotFoundException::class)
    fun computeNegatives() {
        myClass.factorial(-10)
    }
}</pre>
			<p>This would lead to the following change in the class that <span class="No-Break">was tested:</span></p>
			<pre class="source code">
class MyClass {
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): Int {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        return IntArray(n) {
            it + 1
        }.fold(1, { acc, i -&gt; acc * i })
    }
    object FactorialNotFoundException : Throwable()
}</pre>
			<p>Let’s solve the issue<a id="_idIndexMarker808"/> with very large factorials. We can use the <strong class="source inline">BigInteger</strong> class, which can hold large numbers. We can update the test as follows (<strong class="source inline">import</strong> statements <span class="No-Break">not shown):</span></p>
			<pre class="source code">
@RunWith(Parameterized::class)
class MyClassTest(
    private val input: Int,
    private val expected: BigInteger
) {
    companion object {
        @Parameterized.Parameters
        @JvmStatic
        fun getData(): Collection&lt;Array&lt;Any&gt;&gt; = listOf(
            arrayOf(0, BigInteger.ONE),
            arrayOf(1, BigInteger.ONE),
            arrayOf(2, BigInteger.valueOf(2)),
            arrayOf(3, BigInteger.valueOf(6)),
            arrayOf(4, BigInteger.valueOf(24)),
            arrayOf(5, BigInteger.valueOf(120)),
            arrayOf(13, BigInteger("6227020800")),
            arrayOf(25, BigInteger(
            "15511210043330985984000000"))
        )
    }
    private val myClass = MyClass()
    @Test
    fun computesFactorial() {
        val result = myClass.factorial(input)
        assertEquals(expected, result)
    }
}</pre>
			<p>The class under <a id="_idIndexMarker809"/>test now looks <span class="No-Break">like this:</span></p>
			<pre class="source code">
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): BigInteger {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        return IntArray(n) {
            it + 1
        }.fold(BigInteger.ONE, { acc, i -&gt; acc *
            i.toBigInteger() })
    }</pre>
			<p>In the preceding example, we implemented the factorial with the help of <strong class="source inline">IntArray</strong>. This implementation is based more on Kotlin’s ability to chain methods together, but it has one drawback: the fact that it uses memory for the array when it doesn’t <span class="No-Break">need to.</span></p>
			<p>We only care about the factorial and not storing all the numbers from <strong class="source inline">1</strong> to <strong class="source inline">n</strong>. We can change the implementation to a simple <strong class="source inline">for</strong> loop and use the tests to guide us during the <span class="No-Break">refactoring process.</span></p>
			<p>We can observe here two benefits of having tests in <span class="No-Break">your application:</span></p>
			<ul>
				<li>They serve as updated documentation of how the features should <span class="No-Break">be implemented</span></li>
				<li>They guide us when refactoring code by maintaining the same assertion and detecting whether new changes to the code <span class="No-Break">broke it</span></li>
			</ul>
			<p>Let’s update the<a id="_idIndexMarker810"/> code to get rid <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">IntArray</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): BigInteger {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        var result = BigInteger.ONE
        for (i in 1..n){
            result = result.times(i.toBigInteger())
        }
        return result
    }</pre>
			<p>If we modify the <strong class="source inline">factorial</strong> function, as in the preceding example, and run the tests, we should see them <span class="No-Break">all passing.</span></p>
			<p>In certain situations, your tests will use a resource that is common to the test or the application (databases, files, and so on). Ideally, this shouldn’t happen for unit tests, but there can always be exceptions <span class="No-Break">to this.</span></p>
			<p>Let’s analyze that scenario and see how JUnit can aid us with it. We will add a <strong class="source inline">companion</strong> object, which will store the result, to simulate <span class="No-Break">this behavior:</span></p>
			<pre class="source code">
    companion object {
        var result: BigInteger = BigInteger.ONE
    }
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): BigInteger {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        for (i in 1..n) {
            result = result.times(i.toBigInteger())
        }
        return result
    }</pre>
			<p>If we execute<a id="_idIndexMarker811"/> the tests for the preceding code, we will start seeing that some will fail. That’s because after the first tests execute the <strong class="source inline">factorial</strong> function, the result will have the value of the executed tests, and when a new test is executed, the result of the factorial will be multiplied by the previous value of <span class="No-Break">the result.</span></p>
			<p>Normally, this would be good because the tests tell us that we are doing something wrong and we should remedy this, but for this example, we will address the issue directly in <span class="No-Break">the tests:</span></p>
			<pre class="source code">
    @Before
    fun setUp(){
        MyClass.result = BigInteger.ONE
    }
    @After
    fun tearDown(){
        MyClass.result = BigInteger.ONE
    }
    @Test
    fun computesFactorial() {
        val result = myClass.factorial(input)
        assertEquals(expected, result)
    }</pre>
			<p>In the tests, we’ve added two methods with the <strong class="source inline">@Before</strong> and <strong class="source inline">@After</strong> annotations. When these methods are introduced, JUnit will change the execution flow as follows: all methods with the <strong class="source inline">@Before</strong> annotation will be executed, a method with the <strong class="source inline">@Test</strong> annotation will be executed, and then all methods with the <strong class="source inline">@After</strong> annotation will be executed. This process will repeat for every <strong class="source inline">@Test</strong> method in <span class="No-Break">your class.</span></p>
			<p>If you find yourself repeating the same statements in your <strong class="source inline">@Before</strong> method, you can consider using <strong class="source inline">@Rule</strong> to remove the repetition. We can set up a test rule for the preceding <a id="_idIndexMarker812"/>example. Test rules should be in the <strong class="source inline">test</strong> or <strong class="source inline">androidTest</strong> packages, as their usage is only limited to testing. They tend to be used in multiple tests, so you can place your rules in a <strong class="source inline">rules</strong> package (<strong class="source inline">import</strong> statements <span class="No-Break">not shown):</span></p>
			<pre class="source code">
class ResultRule : TestRule {
    override fun apply(
        base: Statement,
        description: Description?
    ): Statement? {
        return object : Statement() {
            @Throws(Throwable::class)
            override fun evaluate() {
                MyClass.result = BigInteger.ONE
                try {
                    base.evaluate()
                } finally {
                    MyClass.result = BigInteger.ONE
                }
            }
        }
    }
}</pre>
			<p>In the preceding example, we can see that the rule will implement <strong class="source inline">TestRule</strong>, which, in turn, comes with the <strong class="source inline">apply()</strong> method. We then create a new <strong class="source inline">Statement</strong> object that will execute the <strong class="source inline">base</strong> statement (the test itself) and reset the value of the result before and after <a id="_idIndexMarker813"/>the statement. We can now modify the test <span class="No-Break">as follows:</span></p>
			<pre class="source code">
    @JvmField
    @Rule
    val resultRule = ResultRule()
    private val myClass = MyClass()
    @Test
    fun computesFactorial() {
        val result = myClass.factorial(input)
        assertEquals(expected, result)
    }</pre>
			<p>To add the rule to the test, we use the <strong class="source inline">@Rule</strong> annotation. Since the test is written in Kotlin, we are using <strong class="source inline">@JvmField</strong> to avoid generating getters and setters because <strong class="source inline">@Rule</strong> requires a public field and not <span class="No-Break">a method.</span></p>
			<p>In this section, we have learned how we can use JUnit to write tests that can verify small units of our code, by verifying the results, errors, or behavior for different parameters. We’ve also learned how each test is run when they are part of a testing class and the order of operations<a id="_idIndexMarker814"/> being invoked. In the next section, we will look at how we can use Android Studio to understand how we can run<a id="_idTextAnchor529"/> <a id="_idTextAnchor530"/>tests and view <span class="No-Break">the results.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor531"/>Android Studio testing tips</h1>
			<p>Android Studio comes <a id="_idIndexMarker815"/>with a good set of shortcuts and visual tools to help with testing. If you want to create a new test for your class or go to existing tests for your class, you can use the <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">T</em> (Windows) or <em class="italic">Command</em> + <em class="italic">Shift</em> + <em class="italic">T</em> (Mac) shortcut. You will need to make sure that the contents of your class are currently in focus in the editor for the keyboard shortcut to <span class="No-Break">take effect.</span></p>
			<p>In order to run tests, there are multiple options: right-click your file or the package and select the <strong class="bold">Run 'Tests in…'</strong> option, or if you want to run a test independently, you can go to the particular test method and select the green icon at the top of the class, which will execute all the tests in <span class="No-Break">the class.</span></p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B19411_10_02.jpg" alt="Figure 10.2 – Running a group of tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Running a group of tests</p>
			<p>For an individual test, you can click the green icon next to the <strong class="source inline">@Test</strong> <span class="No-Break">annotated methods.</span></p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B19411_10_03.jpg" alt="Figure 10.3 – Icons for running individual tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Icons for running individual tests</p>
			<p>This will trigger the test execution, which will be displayed in the <strong class="bold">Run</strong> tab, as shown in the following <a id="_idIndexMarker816"/>screenshot. When the tests are completed, they will become either red or green, depend<a id="_idTextAnchor532"/>ing on their <span class="No-Break">success state:</span></p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B19411_10_04.jpg" alt="Figure 10.4 – Test output in Android Studio"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Test output in Android Studio</p>
			<p>Another important feature that can be found in tests is the debug one. This is important because you can debug both the test and the method under test, so if you find problems in fixing an issue, you can use this to view what the test used as input and how your code handles the input. The third feature you can find in the green icon next to a test is the <strong class="bold">Run With </strong><span class="No-Break"><strong class="bold">Coverage</strong></span><span class="No-Break"> option.</span></p>
			<p>This helps developers identify which lines of code are covered by the test and which ones are skipped. The higher the coverage, the higher the chances of<a id="_idTextAnchor533"/> finding crashes <span class="No-Break">and bugs:</span></p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B19411_10_05.jpg" alt="Figure 10.5 – Test coverage in Android Studio"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Test coverage in Android Studio</p>
			<p>In the preceding figure, you can see the coverage of our class broken down into the number of classes under test, the number of methods under test, and the number of lines <span class="No-Break">under test.</span></p>
			<p>Another way to run tests for your Android app is through the command line. This is usually handy in situations where your<a id="_idIndexMarker817"/> project has <strong class="bold">continuous integration</strong> set up, meaning that <a id="_idIndexMarker818"/>every time you upload your code to a repository in the cloud, a set of scripts will be triggered to test it and <span class="No-Break">ensure functionality.</span></p>
			<p>Since this is done in the cloud, there is no need for Android Studio to be installed. For simplicity, we will be using the <strong class="bold">Terminal</strong> tab in Android Studio to emulate that behavior. The <strong class="bold">Terminal</strong> tab is usually located in the bottom bar in Android Studio near the <span class="No-Break"><strong class="bold">Logcat</strong></span><span class="No-Break"> tab.</span></p>
			<p>In every Android Studio project, a file called <strong class="source inline">gradlew</strong> is present. This is an executable file that allows developers to execute Gradle commands. To run your local unit tests, you can use <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source inline">gradlew.bat test</strong> (<span class="No-Break">for Windows)</span></li>
				<li><strong class="source inline">./gradlew test</strong> (for macOS <span class="No-Break">and Linux)</span></li>
			</ul>
			<p>Once that command is executed, the app will be built and tested. You can find a variety of commands that you can input in <strong class="bold">Terminal</strong> in the <strong class="bold">Gradle</strong> tab located on the right-hand side of <span class="No-Break">Android Studio.</span></p>
			<p>If you see the message saying <strong class="bold">Task list has not been built</strong>, click it and uncheck <strong class="bold">Do not build Gradle task list during Gradle Sync</strong>, click <strong class="bold">OK</strong>, and then sync the project’s Gradle files. The task list should then appear in <span class="No-Break">the list.</span></p>
			<p>The output of the tests, when executed from either the <strong class="bold">Terminal</strong> or <strong class="bold">Gradle</strong> tab, can be found in th<a id="_idTextAnchor534"/>e <span class="No-Break"><strong class="source inline">app/build/reports</strong></span><span class="No-Break"> folder.</span></p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B19411_10_06.jpg" alt="Figure 10.6 – Gradle commands in Android Studio"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Gradle commands in Android Studio</p>
			<p>In this section, we have learned about the various options for testing that Android Studio <a id="_idIndexMarker819"/>provides and how we can visualize testing results. In the section that follows, we will look at how we can mock objects in tests and how <a id="_idTextAnchor535"/>we c<a id="_idTextAnchor536"/>an use Mockito to <span class="No-Break">do so.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor537"/>Mockito</h1>
			<p>In the preceding <a id="_idIndexMarker820"/>examples, we looked at how to set up a unit test and how to use assertions to verify the result of an operation. What if we want to verify whether a certain method was called? Or what if we want to manipulate the test input to test a specific scenario? In these types of situations, we can <span class="No-Break">use </span><span class="No-Break"><strong class="bold">Mockito</strong></span><span class="No-Break">.</span></p>
			<p>This is a library that helps developers set up dummy objects that can be injected into the objects under test and allows them to verify method calls, set up inputs, and even monitor the test <span class="No-Break">objects themselves.</span></p>
			<p>The library should be added to your <strong class="source inline">test</strong> Gradle setup, <span class="No-Break">as follows:</span></p>
			<pre class="source code">
testImplementation 'org.mockito:mockito-core:4.5.1'</pre>
			<p>Now, let’s look at the following code example (please note that, for brevity, <strong class="source inline">import</strong> statements have been removed from the following <span class="No-Break">code snippets):</span></p>
			<pre class="source code">
class StringConcatenator(private val context: Context) {
    fun concatenate(@StringRes stringRes1: Int,
      @StringRes stringRes2: Int): String {
          return context.getString(stringRes1).plus(context
          .getString(stringRes2))
    }
}</pre>
			<p>Here, we have<a id="_idIndexMarker821"/> the <strong class="source inline">Context</strong> object, which normally cannot be unit-tested because it’s part of the Android framework. We can use <strong class="source inline">mockito</strong> to create a test double and inject it into the <strong class="source inline">StringConcatenator</strong> object. Then, we can manipulate the call to <strong class="source inline">getString()</strong> to return whatever input we chose. This process is referred <a id="_idIndexMarker822"/>to <span class="No-Break">as </span><span class="No-Break"><strong class="bold">mocking</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
class StringConcatenatorTest {
    private val context = Mockito.mock(Context::class.java)
    private val stringConcatenator =
        StringConcatenator(context)
    @Test
    fun concatenate() {
        val stringRes1 = 1
        val stringRes2 = 2
        val string1 = "string1"
        val string2 = "string2"
        Mockito.`when`(context.getString(stringRes1))
            .thenReturn(string1)
        Mockito.`when`(context.getString(stringRes2))
            .thenReturn(string2)
        val result =
            stringConcatenator.concatenate(stringRes1,
            stringRes2)
        assertEquals(string1.plus(string2), result)
    }
}</pre>
			<p>In the test, we created a <strong class="source inline">mock</strong> context. When the <strong class="source inline">concatenate</strong> method was tested, we used Mockito to return a specific string when the <strong class="source inline">getString()</strong> method was called with a<a id="_idIndexMarker823"/> particular input. This allowed us to then assert <span class="No-Break">the result.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout"><strong class="source inline">`</strong> is an escape character present in Kotlin and should not be confused with a quote mark. It allows the developer to give methods any name that they want, including special characters or <span class="No-Break">reserved words.</span></p>
			<p>Mockito is not limited to mocking Android framework classes only. We can create a <strong class="source inline">SpecificStringConcatenator</strong> class, which will use <strong class="source inline">StringConcatenator</strong> to concatenate two specific strings <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">strings.xml</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
class SpecificStringConcatenator(private val
stringConcatenator: StringConcatenator) {
    fun concatenateSpecificStrings(): String {
        return stringConcatenator.concatenate(
            R.string.string_1, R.string.string_2)
    }
}</pre>
			<p>We can write the test for it <span class="No-Break">as follows:</span></p>
			<pre class="source code">
class SpecificStringConcatenatorTest {
    private val stringConcatenator = Mockito
        .mock(StringConcatenator::class.java)
    private val specificStringConcatenator =
        SpecificStringConcatenator(stringConcatenator)
    @Test
    fun concatenateSpecificStrings() {
        val expected = "expected"
        Mockito.'<strong class="bold">when</strong>'(stringConcatenator.concatenate(
            R.string.string_1, R.string.string_2))
            .thenReturn(expected)
        val result = specificStringConcatenator
            .concatenateSpecificStrings()
        assertEquals(expected, result)
    }
}</pre>
			<p>Here, we are<a id="_idIndexMarker824"/> mocking the previous <strong class="source inline">StringConcatenator</strong> and instructing the mock to return a specific result. If we run the test, it will fail because Mockito is not able to mock final classes. Here, it encounters a conflict with Kotlin that makes all classes <em class="italic">final</em> unless we specify them <span class="No-Break">as </span><span class="No-Break"><em class="italic">open</em></span><span class="No-Break">.</span></p>
			<p>Luckily, there is a configuration we can apply that solves this dilemma without making the classes under <span class="No-Break">test </span><span class="No-Break"><em class="italic">open</em></span><span class="No-Break">:</span></p>
			<ol>
				<li>Create a folder named <strong class="source inline">resources</strong> in the <span class="No-Break"><strong class="source inline">test</strong></span><span class="No-Break"> package.</span></li>
				<li>In <strong class="source inline">resources</strong>, create a folder <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">mockito-extensions</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="source inline">mockito-extensions</strong> folder, create a file <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">org.mockito.plugins.MockMaker</strong></span><span class="No-Break">.</span></li>
				<li>Inside the file, add the <span class="No-Break">following line:</span><pre class="source code">
mock-maker-inline</pre></li>
			</ol>
			<p>In situations where you have callbacks or asynchronous work and cannot use the JUnit assertions, you can use <strong class="source inline">mockito</strong> to verify the invocation on the callback <span class="No-Break">or lambdas:</span></p>
			<pre class="source code">
class SpecificStringConcatenator(private val
stringConcatenator: StringConcatenator) {
    fun concatenateSpecificStrings(): String {
        return stringConcatenator.concatenate(
        R.string.string_1, R.string.string_2)
    }
    fun concatenateWithCallback(callback: Callback) {
        callback.onStringReady(concatenateSpecificStrings())
    }
    interface Callback {
        fun onStringReady(input: String)
    }
}</pre>
			<p>In the preceding<a id="_idIndexMarker825"/> example, we have added the <strong class="source inline">concatenateWithCallback</strong> method, which will invoke the callback with the result of the <strong class="source inline">concatenateSpecificStrings</strong> method. The test for this method would look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
    @Test
    fun concatenateWithCallback() {
        val expected = "expected"
        Mockito.`when`(stringConcatenator.concatenate(
            R.string.string_1, R.string.string_2))
            .thenReturn(expected)
        val callback = Mockito.mock(
            SpecificStringConcatenator.Callback::class.java
        )
        specificStringConcatenator.concatenateWithCallback(
            callback)
        Mockito.verify(callback).onStringReady(expected)
    }</pre>
			<p>Here, we create a mock <strong class="source inline">Callback</strong> object, which we can then verify at the end with the expected result. Notice that we had to duplicate the setup of the <strong class="source inline">concatenateSpecificStrings</strong> method to test the <strong class="source inline">concatenateWithCallback</strong> method. You should never mock the objects you are testing; however, you<a id="_idIndexMarker826"/> can use <strong class="source inline">spy</strong> to change their behavior. We can spy the <strong class="source inline">stringConcatenator</strong> object to change the outcome of the <span class="No-Break"><strong class="source inline">concatenateSpecificStrings</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source code">
    @Test
    fun concatenateWithCallback() {
        val expected = "expected"
        val spy = Mockito.spy(specificStringConcatenator)
        Mockito.`when`(spy.concatenateSpecificStrings())
            .thenReturn(expected)
        val callback =
         Mockito.mock(SpecificStringConcatenator.Callback::
            class.java)
        specificStringConcatenator.concatenateWithCallback(
            callback)
        Mockito.verify(callback).onStringReady(expected)
    }</pre>
			<p>Mockito also relies on dependency injection to initialize class variables and has a custom build JUnit test runner. This can simplify the initialization of our variables, <span class="No-Break">as follows:</span></p>
			<pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class SpecificStringConcatenatorTest {
    @Mock
    lateinit var stringConcatenator: StringConcatenator
    @InjectMocks
    lateinit var specificStringConcatenator:
        SpecificStringConcatenator
}</pre>
			<p>In the preceding example, <strong class="source inline">MockitoRunner</strong> will inject the variables with the <strong class="source inline">@Mock</strong> annotation with mocks. Next, it will create a new non-mocked instance of the field with the <strong class="source inline">@InjectMocks</strong> annotation. When this instance is created, Mockito will try to inject the mock objects that match the signature of the constructor of <span class="No-Break">that object.</span></p>
			<p>In this section, we <a id="_idIndexMarker827"/>have looked at how we can mock objects when we write tests and how we can use Mockito to do so. In the section that follows, we will look at a specialized library for Mockito that is better suited to be use<a id="_idTextAnchor538"/><a id="_idTextAnchor539"/>d with the Kotlin programming <span class="No-Break">language, mockito-kotlin.</span></p>
			<p>You may have noticed in the preceding example that the <strong class="source inline">when</strong> method from Mockito has escaped. This is because of a conflict with the Kotlin programming language. Mockito is built mainly for Java, and when Kotlin was created, it introduced the <strong class="source inline">this</strong> keyword. Conflicts like this are escaped using the <strong class="source inline">`</strong> <span class="No-Break">character.</span></p>
			<p>This, along with some other minor issues, causes some inconvenience when using Mockito in Kotlin. A few libraries were introduced to wrap Mockito and provide a nicer experience when using it. One of those is <strong class="source inline">mockito-kotlin</strong>. You can add this library to your module using the <span class="No-Break">following command:</span></p>
			<pre class="source code">
testImplementation "org.mockito.kotlin:
mockito-kotlin:4.1.0"</pre>
			<p>A big visible change this library adds is replacing the <strong class="source inline">when</strong> method with <strong class="source inline">whenever</strong>. Another useful change is replacing the <strong class="source inline">mock</strong> method to rely on generics, rather than class objects. The rest of the syntax is like the <span class="No-Break">Mockito syntax.</span></p>
			<p>We can now update the previous tests with the new library, starting with <strong class="source inline">StringConcatenatorTest</strong> (<strong class="source inline">import</strong> statements<a id="_idIndexMarker828"/> have been removed <span class="No-Break">for brevity):</span></p>
			<pre class="source code">
class StringConcatenatorTest {
    private val context = mock&lt;Context&gt;()
    private val stringConcatenator =
        StringConcatenator(context)
    @Test
    fun concatenate() {
        val stringRes1 = 1
        val stringRes2 = 2
        val string1 = "string1"
        val string2 = "string2"
        whenever(context.getString(stringRes1)).thenReturn(
            string1)
        whenever(context.getString(stringRes2)).thenReturn(
            string2)
        val result = stringConcatenator.concatenate(
            stringRes1, stringRes2)
        assertEquals(string1.plus(string2), result)
    }
}</pre>
			<p>As you can observe, the <strong class="source inline">`</strong> character has disappeared, and our mock initialization for the <strong class="source inline">Context</strong> object has been simplified. We can apply the same thing for the <strong class="source inline">SpecificStringConcatenatorTest</strong> class (<strong class="source inline">import</strong> statements have been removed <a id="_idIndexMarker829"/><span class="No-Break">for brevity):</span></p>
			<pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class SpecificStringConcatenatorTest {
    @Mock
    lateinit var stringConcatenator: StringConcatenator
    @InjectMocks
    lateinit var specificStringConcatenator:
        SpecificStringConcatenator
    @Test
    fun concatenateSpecificStrings() {
        val expected = "expected"
        whenever(stringConcatenator.concatenate(
            R.string.string_1, R.string.string_2))
            .thenReturn(expected)
        val result = specificStringConcatenator
            .concatenateSpecificStrings()
        assertEquals(expected, result)
    }
    @Test
    fun concatenateWithCallback() {
        val expected = "expected"
        val spy = spy(specificStringConcatenator)
        whenever(spy.concatenateSpecificStrings())
            .thenReturn(expected)
        val callback =
            mock&lt;SpecificStringConcatenator.Callback&gt;()
        specificStringConcatenator.concatenateWithCallback(
            callback)
        verify(callback).onStringReady(expected)
    }
}</pre>
			<p>In this section, we have looked at how we can use the <strong class="source inline">mockito-kotlin</strong> library and how it can<a id="_idIndexMarker830"/> simplify the Mockito functions in Kotlin. In what follows, we will do an exercise on how we can w<a id="_idTextAnchor540"/>rite<a id="_idTextAnchor541"/> unit tests with JUnit <span class="No-Break">and Mockito.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor542"/>Exercise 10.01 – testing the sum of numbers</h2>
			<p>Using JUnit, Mockito, and <strong class="source inline">mockito-kotlin</strong>, write a set of tests for the following class that <a id="_idIndexMarker831"/>should cover the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>Assert the values for <strong class="source inline">0</strong>, <strong class="source inline">1</strong>, <strong class="source inline">5</strong>, <strong class="source inline">20</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">Int.MAX_VALUE</strong></span></li>
				<li>Assert the outcome for a <span class="No-Break">negative number</span></li>
				<li>Fix the code and replace the sum of numbers with the <span class="No-Break">formula </span><span class="No-Break"><em class="italic">n*(n+1)/2</em></span></li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">Throughout this exercise, <strong class="source inline">import</strong> statements are not shown. To see the full code files, refer <span class="No-Break">to </span><a href="https://packt.link/rv8C2"><span class="No-Break">https://packt.link/rv8C2</span></a><span class="No-Break">.</span></p>
			<p>The code to test is <span class="No-Break">as follows:</span></p>
			<pre class="source code">
class NumberAdder {
    @Throws(InvalidNumberException::class)
    fun sum(n: Int, callback: (BigInteger) -&gt; Unit) {
        if (n &lt; 0) {
            throw InvalidNumberException
        }
        var result = BigInteger.ZERO
        for (i in 1..n){
            result = result.plus(i.toBigInteger())
        }
        callback(result)
    }
    object InvalidNumberException : Throwable()
}</pre>
			<p>Perform the following steps to complete <span class="No-Break">this exercise:</span></p>
			<ol>
				<li>Let’s make<a id="_idIndexMarker832"/> sure the necessary libraries are added to the <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file:</span><pre class="source code">
testImplementation 'junit:junit:4.13.2'
testImplementation 'org.mockito:mockito-core:4.5.1'
testImplementation 'org.mockito.kotlin:
mockito-kotlin:4.1.0'</pre></li>
				<li>Create a class named <strong class="source inline">NumberAdder</strong> and copy the preceding code <span class="No-Break">inside it.</span></li>
				<li>Move the cursor inside the newly created class and, with <em class="italic">Command</em> + <em class="italic">Shift</em> + <em class="italic">T</em> or <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">T</em>, create a test class <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">NumberAdderParameterTest</strong></span><span class="No-Break">.</span></li>
				<li>Create a parameterized test inside this class that will assert the outcomes for the <strong class="source inline">0</strong>, <strong class="source inline">1</strong>, <strong class="source inline">5</strong>, <strong class="source inline">20</strong>, and <span class="No-Break"><strong class="source inline">Int.MAX_VALUE</strong></span><span class="No-Break"> values:</span><pre class="source code">
@RunWith(Parameterized::class)
class NumberAdderParameterTest(
    private val input: Int,
    private val expected: BigInteger
) {
    companion object {
        @Parameterized.Parameters
        @JvmStatic
        fun getData(): List&lt;Array&lt;out Any&gt;&gt; = listOf(
            arrayOf(0, BigInteger.ZERO),
            arrayOf(1, BigInteger.ONE),
            arrayOf(5, 15.toBigInteger()),
            arrayOf(20, 210.toBigInteger()),
            arrayOf(Int.MAX_VALUE, BigInteger(
            "2305843008139952128"))
        )
    }
    private val numberAdder = NumberAdder()
    @Test
    fun sum() {
        val callback = mock&lt;(BigInteger) -&gt; Unit&gt;()
        numberAdder.sum(input, callback)
        verify(callback).invoke(expected)
    }
}</pre></li>
				<li>Create a<a id="_idIndexMarker833"/> separate test class that handles the exception thrown when there are negative numbers, <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">NumberAdderErrorHandlingTest</strong></span><span class="No-Break">:</span><pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class NumberAdderErrorHandlingTest {
    @InjectMocks
    lateinit var numberAdder: NumberAdder
    @Test(expected =
        NumberAdder.InvalidNumberException::class)
    fun sum() {
        val input = -1
        val callback = mock&lt;(BigInteger) -&gt; Unit&gt;()
        numberAdder.sum(input, callback)
    }
}</pre></li>
				<li>Since <em class="italic">1 + 2 + ...n = n * (n + 1) / 2</em>, we can use the formula in the code, and this would <a id="_idIndexMarker834"/>make the execution of the method <span class="No-Break">run faster:</span><pre class="source code">
class NumberAdder {
    @Throws(InvalidNumberException::class)
    fun sum(n: Int, callback: (BigInteger) -&gt; Unit) {
        if (n &lt; 0) {
            throw InvalidNumberException
        }
        callback(n.toBigInteger()
        .times((n.toBigInteger() +
        1.toBigInteger())).divide(2.toBigInteger()))
    }
    object InvalidNumberException : Throwable()
}</pre></li>
				<li>Run the tests by right-clicking the package in which the tests are located and selecting <strong class="bold">Run all in </strong>[<strong class="bold">package_name</strong>]. An output similar to the following will appe<a id="_idTextAnchor543"/>ar, signifying that the tests <span class="No-Break">have passed:</span></li>
			</ol>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B19411_10_07.jpg" alt="Figure 10.7 – Output of Exercise 10.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Output of Exercise 10.01</p>
			<p>By completing this exercise, we have taken the first steps into unit testing, managed to create multiple <a id="_idIndexMarker835"/>test cases for a single operation, taken the first steps into understanding Mockito, and used tests to guide us on how to refact<a id="_idTextAnchor544"/>or co<a id="_idTextAnchor545"/>de without introducing any <span class="No-Break">new issues.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor546"/>Integration tests</h1>
			<p>Let’s assume your <a id="_idIndexMarker836"/>project is covered by unit tests where a lot of your logic is held. You now have to add these tested classes to an activity or a fragment and require them to update your UI. How can you be certain that these classes will work well with each other? The answer to that question is through <span class="No-Break">integration testing.</span></p>
			<p>The idea behind this type of testing is to ensure that different components within your application integrate well with each other. Some examples include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Ensuring that your API-related components parse the data well and interact well with your <span class="No-Break">storage components</span></li>
				<li>The storage components are capable of storing and retrieving the <span class="No-Break">data correctly</span></li>
				<li>The UI components load and display the <span class="No-Break">appropriate data</span></li>
				<li>The transition between different screens in <span class="No-Break">your application</span></li>
			</ul>
			<p>To aid with integration testing, the requirements are sometimes written in the format <strong class="source inline">Given - When - Then</strong>. These usually represent acceptance criteria for a user story. Take the <span class="No-Break">following example:</span></p>
			<pre class="source code">
Given I am not logged in
And I open the application
When I enter my credentials
And click Login
Then I see the Main screen</pre>
			<p>We can use these steps to approach how we can write the integration tests for the feature we <span class="No-Break">are developing.</span></p>
			<p>On the Android platform, integration<a id="_idIndexMarker837"/> testing can be achieved with <span class="No-Break">two libraries:</span></p>
			<ul>
				<li><strong class="bold">Robolectric</strong>: This library gives developers the ability to test Android components as unit tests – that is, executing integration tests without an actual device <span class="No-Break">or emulator</span></li>
				<li><strong class="bold">Espresso</strong>: This library is helpful in instrumentation tests on an Android device <span class="No-Break">or emulator</span></li>
			</ul>
			<p>We’ll have a look at th<a id="_idTextAnchor547"/>ese l<a id="_idTextAnchor548"/>ibraries in detail in the <span class="No-Break">next sections.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor549"/>Robolectric</h2>
			<p><strong class="bold">Robolectric</strong> started as <a id="_idIndexMarker838"/>an open source library, which was<a id="_idIndexMarker839"/> meant to give users the ability to unit test classes from the Android framework as part of their local tests instead of the instrumented tests. Recently, it has been endorsed by Google and has been integrated with AndroidX <span class="No-Break">Jetpack components.</span></p>
			<p>One of the main benefits of this library is the simplicity of testing activities and fragments. This is a benefit when it comes to integration tests because we can use this feature to make sure that our components integrate well with <span class="No-Break">each other.</span></p>
			<p>Some of Robolectric’s<a id="_idIndexMarker840"/> features are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The possibility to instantiate and test the activity and <span class="No-Break">fragment lifecycle</span></li>
				<li>The possibility to test <span class="No-Break">view inflation</span></li>
				<li>The possibility to provide configurations for different Android APIs, orientations, screen sizes, layout directions, and <span class="No-Break">so on</span></li>
				<li>The possibility to change the <strong class="source inline">Application</strong> class, which then helps to change the modules to<a id="_idIndexMarker841"/> permit data mocks to <span class="No-Break">be inserted</span></li>
			</ul>
			<p>To add Robolectric, along with the AndroidX integration, we will need the <span class="No-Break">following libraries:</span></p>
			<pre class="source code">
    testImplementation 'org.robolectric:robolectric:4.9'
    testImplementation 'androidx.test.ext:junit:1.1.4'</pre>
			<p>The second library will bring a set of utility methods and classes required for testing <span class="No-Break">Android components.</span></p>
			<p>Let’s assume we have to deliver a feature in which we display the text <strong class="source inline">Result x</strong>, where <strong class="source inline">x</strong> is the <strong class="source inline">factorial</strong> function for a number that the user will insert in the <strong class="source inline">EditText</strong> element. We will assume that we will use an Activity with an <strong class="source inline">EditText</strong>, a <strong class="source inline">TextView</strong>, and a <strong class="source inline">Button</strong>. When the button is clicked, then we display in the <strong class="source inline">TextView</strong> the<a id="_idIndexMarker842"/> factorial result of the number <a id="_idIndexMarker843"/>entered in <span class="No-Break">the </span><span class="No-Break"><strong class="source inline">EditText</strong></span><span class="No-Break">.</span></p>
			<p>To achieve this, we have two classes, one that computes the factorial and another that concatenates the word <strong class="source inline">Result</strong> with the factorial if the number is positive, or it will return the text <strong class="source inline">Error</strong> if the number <span class="No-Break">is negative.</span></p>
			<p>The <strong class="source inline">factorial</strong> class will look something like this (throughout this example, <strong class="source inline">import</strong> statements have been removed <span class="No-Break">for brevity):</span></p>
			<pre class="source code">
class FactorialGenerator {
    @Throws(FactorialNotFoundException::class)
    fun factorial(n: Int): BigInteger {
        if (n &lt; 0) {
            throw FactorialNotFoundException
        }
        var result = BigInteger.ONE
        for (i in 1..n) {
            result = result.times(i.toBigInteger())
        }
        return result
    }
    object FactorialNotFoundException : Throwable()
}</pre>
			<p>The <strong class="source inline">TextFormatter</strong> class will look <span class="No-Break">like this:</span></p>
			<pre class="source code">
class TextFormatter(
    private val factorialGenerator: FactorialGenerator,
    private val context: Context
) {
    fun getFactorialResult(n: Int): String {
        return try {
            context.getString(R.string.result,
            factorialGenerator.factorial(n).toString())
        } catch (e: FactorialGenerator
          .FactorialNotFoundException) {
               context.getString(R.string.error)
        }
    }
}</pre>
			<p>We can combine<a id="_idIndexMarker844"/> these two components in our activity<a id="_idIndexMarker845"/> and have something <span class="No-Break">like this:</span></p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    private lateinit var textFormatter: TextFormatter
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        textFormatter = TextFormatter(FactorialGenerator(),
            applicationContext)
        findViewById&lt;Button&gt;(R.id.button)
            .setOnClickListener {
                findViewById&lt;TextView&gt;(R.id.text_view)
                .text = textFormatter.getFactorialResult(
                findViewById&lt;EditText&gt;(R.id.edit_text).text
                .toString()
                .toInt())
        }
    }
}</pre>
			<p>We can observe three components interacting with each other in this case. We can use Robolectric to<a id="_idIndexMarker846"/> test our activity. By testing the activity that <a id="_idIndexMarker847"/>creates the components, we can also test the interaction between all three of the components. We can write a test that looks <span class="No-Break">like this:</span></p>
			<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    private val context =
        getApplicationContext&lt;Application&gt;()
    @Test
    fun `show factorial result in text view`() {
        val scenario = launch(MainActivity::class.java)
        scenario.moveToState(Lifecycle.State.RESUMED)
        scenario.onActivity { activity -&gt;
            activity.findViewById&lt;EditText&gt;(R.id.edit_text)
                .setText(5.toString())
            activity.findViewById&lt;Button&gt;(R.id.button)
                .performClick()
            assertEquals(
                context.getString(R.string.result, "120"),
                activity.findViewById&lt;TextView&gt;(
                R.id.text_view).text
            )
        }
    }
}</pre>
			<p>In the preceding example, we can see the AndroidX support for the activity test. The <strong class="source inline">AndroidJUnit4</strong> test runner will set up Robolectric and create the necessary configurations, while the <strong class="source inline">launch</strong> method will return a <strong class="source inline">scenario</strong> object, which we can then play with to achieve the necessary conditions for the test. We can also observe how we can use the <strong class="source inline">`</strong> character to provide longer names to our functions, in which we can include <span class="No-Break">whitespace characters.</span></p>
			<p>If we want to <a id="_idIndexMarker848"/>add configurations for the test, we can<a id="_idIndexMarker849"/> use the <strong class="source inline">@Config</strong> annotation both on the class and on each of the <span class="No-Break">test methods:</span></p>
			<pre class="source code">
@Config(
    sdk = [Build.VERSION_CODES.TIRAMISU],
    minSdk = Build.VERSION_CODES.KITKAT,
    maxSdk = Build.VERSION_CODES.TIRAMISU,
    application = Application::class,
    assetDir = "/assetDir/"
)
@RunWith(AndroidJUnit4::class)
class MainActivityTest</pre>
			<p>We can also specify global configurations in the <strong class="source inline">test/resources</strong> folder in the <strong class="source inline">robolectric.properties</strong> file, <span class="No-Break">like so:</span></p>
			<pre class="source code">
sdk=33
minSdk = 14
maxSdk = 33</pre>
			<p>Another important feature that has recently been added to Robolectric is support for the Espresso library. This allows developers to use the syntax from Espresso to interact with views and make assertions on <span class="No-Break">the views.</span></p>
			<p>Another library that can be used in combination with Robolectric is <strong class="source inline">FragmentScenario</strong>, which allows the possibility to test fragments. These libraries can be added in Gradle using <span class="No-Break">the following:</span></p>
			<pre class="source code">
    testImplementation 'androidx.fragment:
    fragment-testing:1.5.5'
    testImplementation 'androidx.test.espresso:
    espresso-core:3.5.0'</pre>
			<p>Testing<a id="_idIndexMarker850"/> fragments <a id="_idIndexMarker851"/>is like activities using the <span class="No-Break"><strong class="source inline">scenario</strong></span><span class="No-Break"> setup:</span></p>
			<pre class="source code">
val scenario = launchFragmentInContainer&lt;Ma<a id="_idTextAnchor550"/>inFra<a id="_idTextAnchor551"/>gment&gt;()
scenario.moveToState(Lifecycle.State.CREATED)</pre>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor552"/>Espresso</h2>
			<p>Espresso is a library<a id="_idIndexMarker852"/> designed to perform interactions <a id="_idIndexMarker853"/>and assertions in a concise way. It was initially designed to be used in instrumented tests, and now it has migrated to be used with Robolectric as well. The typical usage for performing an action is <span class="No-Break">as follows:</span></p>
			<pre class="source code">
onView(Matcher&lt;View&gt;).perform(ViewAction)</pre>
			<p>For verification, we can use <span class="No-Break">the following:</span></p>
			<pre class="source code">
onView(Matcher&lt;View&gt;).check(ViewAssertion)</pre>
			<p>We can provide custom <strong class="source inline">ViewMatchers</strong> if none can be found in the <strong class="source inline">ViewMatchers</strong> class. Some of the most common ones are <strong class="source inline">withId</strong> and <strong class="source inline">withText</strong>. These two allow us to identify views based on their <strong class="source inline">R.id.myId</strong> identifier or text identifier. Ideally, the first one should be used to identify a <span class="No-Break">particular view.</span></p>
			<p>Another interesting aspect of Espresso is the reliance on the <strong class="source inline">Hamcrest</strong> library for matchers. This is a Java library that aims to improve testing. This allows multiple matchers to be combined if necessary. Let’s say that the same ID is present in different views on your UI. You can narrow your search for a specific view using the <span class="No-Break">following expression:</span></p>
			<pre class="source code">
onView(allOf(withId(R.id.edit_text),
withParent(withId(R.id.root))))</pre>
			<p>The <strong class="source inline">allOf</strong> expression will evaluate all of the other operators and will pass only if all of the operators inside pass. The preceding expressions will translate to <em class="italic">Find the view with id=edit_text that has the parent with id=R.id.root</em>. Other <strong class="source inline">Hamcrest</strong> operators may include <strong class="source inline">anyOf</strong>, <strong class="source inline">both</strong>, <strong class="source inline">either</strong>, <strong class="source inline">is</strong>, <strong class="source inline">isA</strong>, <strong class="source inline">hasItem</strong>, <strong class="source inline">equalTo</strong>, <strong class="source inline">any</strong>, <strong class="source inline">instanceOf</strong>, <strong class="source inline">not</strong>, <strong class="source inline">null</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">notNull</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source inline">ViewActions</strong> have a similar approach to <strong class="source inline">ViewMatchers</strong>. We can find common ones in the <strong class="source inline">ViewActions</strong> class. Common ones include <strong class="source inline">typeText</strong>, <strong class="source inline">click</strong>, <strong class="source inline">scrollTo</strong>, <strong class="source inline">clearText</strong>, <strong class="source inline">swipeLeft</strong>, <strong class="source inline">swipeRight</strong>, <strong class="source inline">swipeUp</strong>, <strong class="source inline">swipeDown</strong>, <strong class="source inline">closeSoftKeyboard</strong>, <strong class="source inline">pressBack</strong>, <strong class="source inline">pressKey</strong>, <strong class="source inline">doubleClick</strong>, and <strong class="source inline">longClick</strong>. If you have custom views and certain actions are required, then you can implement<a id="_idIndexMarker854"/> your own <strong class="source inline">ViewAction</strong> element by<a id="_idIndexMarker855"/> implementing the <span class="No-Break"><strong class="source inline">ViewAction</strong></span><span class="No-Break"> interface.</span></p>
			<p>Similar to the preceding examples, <strong class="source inline">ViewAssertions</strong> have their own class. Typically, the <strong class="source inline">matches</strong> method is used, where you can then use <strong class="source inline">ViewMatchers</strong> and <strong class="source inline">Hamcrest</strong> matchers to validate <span class="No-Break">the result:</span></p>
			<pre class="source code">
onView(withId(R.id.text_view)).check(matches(withText(
"My text"))))</pre>
			<p>The preceding example will verify that the view with the <strong class="source inline">text_view</strong> ID will contain the text <span class="No-Break"><strong class="source inline">My text</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
onView(withId(R.id.button)).perform(click())</pre>
			<p>This will click the view with the <span class="No-Break">ID button.</span></p>
			<p>We can now rewrite the Robolectric test and add Espresso, which will give us this (the <strong class="source inline">import</strong> statement is <span class="No-Break">not shown):</span></p>
			<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    @Test
    fun `show factorial result in text view`() {
        val scenario = launch(MainActivity::class.java)
        scenario.moveToState(Lifecycle.State.RESUMED)
        scenario.onActivity { activity -&gt;
            onView(withId(R.id.edit_text)).perform(
                typeText("5"))
            onView(withId(R.id.button)).perform(click())
            onView(withId(R.id.text_view))
                .check(matches(withText(activity.getString(
                R.string.result, "120"))))
        }
    }
}</pre>
			<p>In the preceding <a id="_idIndexMarker856"/>code sample, we can observe how, using<a id="_idIndexMarker857"/> Espresso, we input the number <strong class="source inline">5</strong> into <strong class="source inline">EditText</strong>, then click on the button, and then assert the text displayed in <strong class="source inline">TextView</strong> with the help of the <strong class="source inline">onView()</strong> method to obtain a reference to the view, and then execute actions using <strong class="source inline">perform()</strong> or make assertions <span class="No-Break">using </span><span class="No-Break"><strong class="source inline">check()</strong></span><span class="No-Break">.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">For the following exercise, you will need an emulator or a physical device with USB debugging enabled. You can do so by selecting <strong class="bold">Tools</strong> | <strong class="bold">AVD Manager</strong> in Android Studio. Then, you can create one with the <strong class="bold">Create Virtual Device</strong> option by selecting the type of emulator, clicking <strong class="bold">Next</strong>, and then selecting an x86 image. Any image larger than Lollipop should be alright for this<a id="_idTextAnchor553"/> exer<a id="_idTextAnchor554"/>cise. Next, you can give your image a name and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor555"/>Exercise 10.02 – double integration</h2>
			<p>Develop an<a id="_idIndexMarker858"/> application that observes the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker859"/></span><span class="No-Break">requirements:</span></p>
			<pre class="source code">
Given I open the application
And I insert the number n
When I press the Calculate button
Then I should see the text "The sum of numbers from 1 to n is [result]"
Given I open the application
And I insert the number -n
When I press the Calculate button
Then I should see the text "Error: Invalid number"</pre>
			<p>You should implement both unit tests and integration tests using Robolectric and Espresso and migrate the integration tests to become <span class="No-Break">instrumentation tests.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">Throughout this exercise, <strong class="source inline">import</strong> statements are not shown. To see the full code files, refer <span class="No-Break">to </span><a href="https://packt.link/EcmiV"><span class="No-Break">https://packt.link/EcmiV</span></a><span class="No-Break">.</span></p>
			<p>Implement the following steps to complete <span class="No-Break">this exercise:</span></p>
			<ol>
				<li>Let’s start by adding the necessary test libraries <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
    testImplementation 'junit:junit:4.13.2'
    testImplementation
        'org.mockito:mockito-core:4.5.1'
    testImplementation
        'org.mockito.kotlin:mockito-kotlin:4.1.0'
    testImplementation
        'org.robolectric:robolectric:4.9'
    testImplementation 'androidx.test.ext:junit:1.1.4'
    testImplementation
        'androidx.test.espresso:espresso-core:3.5.0'
    androidTestImplementation
        'androidx.test.ext:junit:1.1.4'
    androidTestImplementation
        'androidx.test.espresso:espresso-core:3.5.0'
    androidTestImplementation
        'androidx.test:rules:1.5.0'</pre></li>
				<li>For Robolectric, we will need to add extra configurations, the first of which is to add the <a id="_idIndexMarker860"/>following<a id="_idIndexMarker861"/> line to <strong class="source inline">app/build.gradle</strong> in the <span class="No-Break"><strong class="source inline">android</strong></span><span class="No-Break"> closure:</span><pre class="source code">
testOptions.unitTests.includeAndroidResources = true</pre></li>
				<li>Create a <strong class="source inline">resources</strong> directory in the <strong class="source inline">test</strong> package. You will need to switch your Android Studio project view from <strong class="bold">Android</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Project</strong></span><span class="No-Break">.</span></li>
				<li>Add the <strong class="source inline">robolectric.properties</strong> file and add the following configuration to <span class="No-Break">that file:</span><pre class="source code">
sdk=32</pre></li>
				<li>In <strong class="source inline">resources</strong>, create a folder <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">mockito-extensions</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="source inline">mockito-extensions</strong> folder, create a file named <strong class="source inline">org.mockito.plugins.MockMaker</strong>, and inside the file, add the <span class="No-Break">following line:</span><pre class="source code">
mock-maker-inline</pre></li>
				<li>Create the <strong class="source inline">NumberAdder</strong> class. This is similar to the one in <span class="No-Break"><em class="italic">Exercise 10.01</em></span><span class="No-Break">:</span><pre class="source code">
class NumberAdder {
    @Throws(InvalidNumberException::class)
    fun sum(n: Int, callback: (BigInteger) -&gt; Unit) {
        if (n &lt; 0) {
            throw InvalidNumberException
        }
        callback(n.toBigInteger().times((n.toLong() +
        1).toBigInteger()).divide(2.toBigInteger()))
    }
    object InvalidNumberException : Throwable()
}</pre></li>
				<li>Create the<a id="_idIndexMarker862"/> tests for <strong class="source inline">NumberAdder</strong> in <a id="_idIndexMarker863"/>the <strong class="source inline">test</strong> folder. First, <span class="No-Break">create </span><span class="No-Break"><strong class="source inline">NumberAdder</strong></span><strong class="source inline">
</strong><span class="No-Break"><strong class="source inline">ParameterTest</strong></span><span class="No-Break">:</span><pre class="source code">
@RunWith(Parameterized::class)
class NumberAdderParameterTest(
    private val input: Int,
    private val expected: BigInteger
) {
    private val numberAdder = NumberAdder()
    @Test
    fun sum() {
        val callback = mock&lt;(BigInteger) -&gt; Unit&gt;()
        numberAdder.sum(input, callback)
        verify(callback).invoke(expected)
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/ghcTs"><span class="No-Break">https://packt.link/ghcTs</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="9">Then, create the <span class="No-Break"><strong class="source inline">NumberAdderErrorHandlingTest</strong></span><span class="No-Break"> test:</span><pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class NumberAdderErrorHandlingTest {
    @InjectMocks
    lateinit var numberAdder: NumberAdder
    @Test(expected =
        NumberAdder.InvalidNumberException::class)
    fun sum() {
        val input = -1
        val callback = mock&lt;(BigInteger) -&gt; Unit&gt;()
        numberAdder.sum(input, callback)
    }
}</pre></li>
				<li>In the <strong class="source inline">main</strong> folder <a id="_idIndexMarker864"/>in the root package, create <a id="_idIndexMarker865"/>a class that will format the sum and concatenate it with the <span class="No-Break">necessary strings:</span><pre class="source code">
class TextFormatter(
    private val numberAdder: NumberAdder,
    private val context: Context
) {
    fun getSumResult(n: Int, callback: (String) -&gt;
    Unit) {
        try {
            numberAdder.sum(n) {
                callback(context.getString(
                R.string
                .the_sum_of_numbers_from_1_to_is,
                n, it.toString())
                )
            }
        } catch (
          e: NumberAdder.InvalidNumberException) {
              callback(context.getString(
              R.string.error_invalid_number))
        }
    }
}</pre></li>
				<li>Unit-test this class <a id="_idIndexMarker866"/>for both the success and <a id="_idIndexMarker867"/>error scenarios. Start with the <span class="No-Break">success scenario:</span><pre class="source code">
@RunWith(MockitoJUnitRunner::class)
class TextFormatterTest {
    @InjectMocks
    lateinit var textFormatter: TextFormatter
    @Mock
    lateinit var numberAdder: NumberAdder
    @Mock
    lateinit var context: Context
    @Test
    fun getSumResult_success() {
        val n = 10
        val sumResult = BigInteger.TEN
        val expected = "expected"
        whenever(numberAdder.sum(eq(n),
        any())).thenAnswer {
            (it.arguments[1] as (BigInteger) -&gt;
            Unit).invoke(sumResult)
        }
        whenever(context.getString(
        R.string.the_sum_of_numbers_from_1_to_is,
        n, sumResult.toString())
        ).thenReturn(expected)
        val callback = mock&lt;(String) -&gt; Unit&gt;()
        textFormatter.getSumResult(n, callback)
        verify(callback).invoke(expected)
    }
}</pre></li>
			</ol>
			<p>Then, create <a id="_idIndexMarker868"/>the <a id="_idIndexMarker869"/>test for the <span class="No-Break">error scenario:</span></p>
			<pre class="source code">
    @Test
    fun getSumResult_error() {
        val n = 10
        val expected = "expected"
        whenever(numberAdder.sum(eq(n),
            any())).thenThrow(NumberAdder
            .InvalidNumberException)
            whenever(context.getString(
            R.string.error_invalid_number))
            .thenReturn(expected)
        val callback = mock&lt;(String) -&gt; Unit&gt;()
        textFormatter.getSumResult(n, callback)
        verify(callback).invoke(expected)
    }</pre>
			<ol>
				<li value="12">In <strong class="source inline">main/res/values/strings.xml</strong>, add the <span class="No-Break">following strings:</span><pre class="source code">
    &lt;string name="the_sum_of_numbers_from_1_to_is"&gt;
        The sum of numbers from 1 to %1$d is:
        %2$s&lt;/string&gt;
    &lt;string name="error_invalid_number"&gt;Error: Invalid
        number&lt;/string&gt;
    &lt;string name="calculate"&gt;Calculate&lt;/string&gt;</pre></li>
				<li>Create <a id="_idIndexMarker870"/>the<a id="_idIndexMarker871"/> layout for <strong class="source inline">activity_main.xml</strong> in the <span class="No-Break"><strong class="source inline">main/res/layout</strong></span><span class="No-Break"> folder:</span><pre class="source code">
    &lt;EditText
        android:id="@+id/edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:inputType="number" /&gt;
    &lt;Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="@string/calculate" /&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/hxZ0I"><span class="No-Break">https://packt.link/hxZ0I</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="14">In the <strong class="source inline">main</strong> folder in the root package, create the <strong class="source inline">MainActivity</strong> class, which<a id="_idIndexMarker872"/> will<a id="_idIndexMarker873"/> contain all the <span class="No-Break">other components:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
    private lateinit var textFormatter: TextFormatter
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        textFormatter = TextFormatter(NumberAdder(),
            applicationContext)
        findViewById&lt;Button&gt;(R.id.button)
        .setOnClickListener {
            textFormatter.getSumResult(findViewById
            &lt;EditText&gt;(R.id.edit_text).text.toString()
            .toIntOrNull() ?: 0) {
                findViewById&lt;TextView&gt;(R.id.text_view)
                .text = it
            }
        }
    }
}</pre></li>
				<li>Create a test for <strong class="source inline">MainActivity</strong> and place it in the <strong class="source inline">test</strong> directory. It will contain<a id="_idIndexMarker874"/> two test methods, one for success and<a id="_idIndexMarker875"/> one <span class="No-Break">for errors:</span><pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    @Test
    fun `show sum result in text view`() {
        val scenario =
            launch(MainActivity::class.java)
        scenario.moveToState(Lifecycle.State.RESUMED)
        scenario.onActivity { activity -&gt;
            onView(withId(R.id.edit_text))
                .perform(replaceText("5"))
            onView(withId(R.id.button)).perform(click(
            ))
            onView(withId(R.id.text_view))
              .check(matches(withText(
              activity.getString(
              R.string.the_sum_of_numbers_from_1_to_is
              , 5, "15"))))
        }
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/fZI3u"><span class="No-Break">https://packt.link/fZI3u</span></a><span class="No-Break">.</span></p>
			<p>If you run the tests by right-clicking the package in which the tests are located and s<a id="_idTextAnchor556"/>electing <strong class="bold">Run all in </strong>[<strong class="bold">package_name</strong>], then an output like the following <span class="No-Break">will appear:</span></p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B19411_10_08.jpg" alt="Figure 10.8 – Result of executing the tests in the test folder for Exercise 10.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Result of executing the tests in the test folder for Exercise 10.02</p>
			<p>If you execute<a id="_idIndexMarker876"/> the preceding tests, you should see<a id="_idIndexMarker877"/> an output like <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>. The Robolectric test is executed in the same way as a regular unit test; however, there is an increase in the <span class="No-Break">execution time.</span></p>
			<ol>
				<li value="16">Let’s now migrate the preceding test to an instrumented integration test. To do this, we will copy the preceding test from the <strong class="source inline">test</strong> package into the <strong class="source inline">androidTest</strong> package and remove the code related to scenarios from our tests. Make sure that in the <strong class="source inline">androidTest</strong> folder, there is a Java folder that contains a package with the same name as the <strong class="source inline">main/java</strong> folder. You will need to move your tests to <span class="No-Break">this package.</span></li>
				<li>After copying the file, we will use <strong class="source inline">ActivityTestRule</strong>, which will launch our activity before every test is executed. We will also need to rename the class to avoid duplicates and rename the test methods because the syntax is not supported <a id="_idIndexMarker878"/>for <a id="_idIndexMarker879"/><span class="No-Break">instrumented tests:</span><pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityUiTest {
    @Test
    fun showSumResultInTextView() {
        val scenario =
            launch(MainActivity::class.java)
        scenario.moveToState(Lifecycle.State.RESUMED)
        onView(withId(R.id.edit_text)).perform(
            replaceText("5"))
        onView(withId(R.id.button)).perform(click())
        onView(withId(R.id.text_view)).check(matches(
           withText(getApplicationContext&lt;Application&gt;
           ().getString(R.string
           .the_sum_of_numbers_from_1_to_is, 5, "15"))
           ))
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/hNB4A"><span class="No-Break">https://packt.link/hNB4A</span></a><span class="No-Break">.</span></p>
			<p>If you run the tests by right-clicking the package in which the tests are located an<a id="_idTextAnchor557"/>d selecting <strong class="bold">Run all in </strong>[<strong class="bold">package_name</strong>], then an output like the following <span class="No-Break">will appear:</span></p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B19411_10_09.jpg" alt="Figure 10.9 – Result of executing the tests in the androidTest folder for Exercise 10.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Result of executing the tests in the androidTest folder for Exercise 10.02</p>
			<p>In <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.9</em>, we can see what Android Studio displays as an output for the result. If you pay attention to the emulator while the tests are executing, you can see that for each test, your activity will be opened, the input will be set in the field, and the button will <span class="No-Break">be clicked.</span></p>
			<p>Both of our integration tests (on the workstation and the emulator) try to match the accepted criteria of the requirement. The integration tests verify the same behavior, the only difference is that one checks it locally and the other checks it on an Android device or emulator. The main benefit here is the fact that Espresso was able to bridge the gap between them, making integration tests easier to set up <span class="No-Break">and execute.</span></p>
			<p>In this section, we have implemented an exercise in which we have written tests with the Robolectric library combined with the Espresso library and looked at how we can migrate <a id="_idIndexMarker880"/>our <a id="_idIndexMarker881"/>Robolectric tests from the <strong class="source inline">test</strong> folder to the <strong class="source inline">androidTest</strong> folder. In the section that follows, we will look at how we can build upon the ex<a id="_idTextAnchor558"/>isting <a id="_idTextAnchor559"/>testing suite with instrumented tests that run on physical devices <span class="No-Break">or emulators.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor560"/>UI tests</h1>
			<p>UI tests are instrumented <a id="_idIndexMarker882"/>tests where developers can simulate user journeys and verify the interactions between different modules of the application. They are also referred to as end-to-end tests. For small applications, you can have one test suite, but for larger applications, you should split your test suites to cover user journeys (logging in, creating an account, setting up flows, and <span class="No-Break">so on).</span></p>
			<p>Because they are executed on the device, you will need to write them in the <strong class="source inline">androidTest</strong> package, which means they will <a id="_idIndexMarker883"/>run with the <strong class="bold">Instrumentation</strong> framework. Instrumentation works <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The app is built and installed on <span class="No-Break">the device</span></li>
				<li>A testing app will also be installed on the device that will monitor <span class="No-Break">your app</span></li>
				<li>The testing app will execute the tests on your app and record <span class="No-Break">the results</span></li>
			</ul>
			<p>One of the drawbacks of this is the fact that the tests will share persisted data, so if a test stores data on the device, then the second test can have access to that data, which means that there is a risk of failure. Another drawback is that if a test comes across a crash, this will stop the entire testing because the application under test <span class="No-Break">is stopped.</span></p>
			<p>These issues were solved in the Jetpack updates with the introduction of the <strong class="bold">orchestrator</strong> framework. Orchestrators<a id="_idIndexMarker884"/> give you the ability to clear the data after each test is executed, sparing developers the need to make any adjustments. The orchestrator is represented by another application that will manage how the testing app will coordinate the tests and the data between <span class="No-Break">the tests.</span></p>
			<p>In order to add it to your<a id="_idIndexMarker885"/> project, you need a configuration similar to this in the <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source code">
android {
    ...
    defaultConfig {
        ...
        testInstrumentationRunner
            "androidx.test.runner.AndroidJUnitRunner"
        testInstrumentationRunnerArguments
            clearPackageData: 'true'
    }
    testOptions {
        execution 'ANDROIDX_TEST_ORCHESTRATOR'
    }
}
dependencies {
    ...
    androidTestUtil 'androidx.test:orchestrator:1.4.2'
}</pre>
			<p>You can execute the orchestrator test on a connected device using Gradle’s <strong class="source inline">connectedCheck</strong> command, either from Terminal or from the list of <span class="No-Break">Gradle commands.</span></p>
			<p>In the configuration, you will notice the following line: <strong class="source inline">testInstrumentationRunner</strong>. This allows us to create a custom configuration for the test, which gives us the opportunity to inject mock data into <span class="No-Break">the modules:</span></p>
			<pre class="source code">
testInstrumentationRunner "com.android.CustomTestRunner"</pre>
			<p><strong class="source inline">CustomTestRunner</strong> looks <a id="_idIndexMarker886"/>like this (<strong class="source inline">import</strong> statements are not shown in the following <span class="No-Break">code snippets):</span></p>
			<pre class="source code">
class CustomTestRunner: AndroidJUnitRunner() {
    @Throws(Exception::class)
    override fun newApplication(
        cl: ClassLoader?,
        className: String?,
        context: Context?
    ): Application? {
        return super.newApplication(cl,
        MyApplication::class.java.name, context)
    }
}</pre>
			<p>The test classes themselves can be written by applying the JUnit4 syntax with the help of the <strong class="source inline">androidx.test.ext.junit.runners.AndroidJUnit4</strong> <span class="No-Break">test runner:</span></p>
			<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MainActivityUiTest {
}</pre>
			<p>The <strong class="source inline">@Test</strong> methods themselves run in a dedicated test thread, which is why a library such as Espresso is helpful. Espresso will automatically move every interaction with a view on the UI thread. Espresso can be used for UI tests in a similar way as it is used with <span class="No-Break">Robolectric tests:</span></p>
			<pre class="source code">
    @Test
    fun myTest() {
        onView(withId(R.id.edit_text)).perform(replaceText
            ("5"))
        onView(withId(R.id.button)).perform(click())
        onView(withId(R.id.text_view)).check(matches(
            withText("my test")))
    }</pre>
			<p>Typically, in UI tests, you will find interactions and assertions that may get repetitive. In order to avoid duplicating multiple scenarios in your code, you can apply a pattern called <strong class="bold">Robot</strong>. Each <a id="_idIndexMarker887"/>screen will have an associated <strong class="source inline">Robot</strong> class in which the interactions<a id="_idIndexMarker888"/> and assertions can be grouped into specific methods. Your test code will use the robots and assert them. A typical robot will look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
class MyScreenRobot {
    fun setText(): MyScreenRobot {
        onView(ViewMatchers.withId(R.id.edit_text))
            .perform(ViewActions.replaceText("5"))
        return this
    }
    fun pressButton(): MyScreenRobot {
        onView(ViewMatchers.withId(R.id.button))
            .perform(ViewActions.click())
        return this
    }
    fun assertText(): MyScreenRobot {
        onView(ViewMatchers.withId(R.id.text_view))
            .check(ViewAssertions.matches(ViewMatchers
            .withText("my test")))
        return this
    }
}</pre>
			<p>The test will look <span class="No-Break">like this:</span></p>
			<pre class="source code">
    @Test
    fun myTest() {
       MyScreenRobot()
           .setText()
           .pressButton()
           .assertText()
    }</pre>
			<p>Because apps can <a id="_idIndexMarker889"/>be multithreaded and sometimes it takes a while to load data from various sources (internet, files, local storage, and so on), the UI tests will have to know when the UI is available for interactions. One way to implement this is through the use of <span class="No-Break">idling resources.</span></p>
			<p>These are objects that can be registered to Espresso before the test and injected into your application’s components where multithreaded work is done. The apps will mark them as non-idle when the work is in progress and idle when the work is done. It is at this point that Espresso will then start executing the test. One of the most commonly used ones <span class="No-Break">is </span><span class="No-Break"><strong class="source inline">CountingIdlingResource</strong></span><span class="No-Break">.</span></p>
			<p>This specific implementation uses a counter that should be incremented when you want Espresso to wait for your code to complete its execution and decremented when you want to let Espresso verify your code. When the counter reaches <strong class="source inline">0</strong>, Espresso will resume testing. An example of a component with an idling resource looks something <span class="No-Break">like this:</span></p>
			<pre class="source code">
class MyHeavyliftingComponent(private val
countingIdlingResource:CountingIdlingResource) {
    fun doHeavyWork() {
        countingIdlingResource.increment()
        // do work
        countingIdlingResource.decrement()
    }
}</pre>
			<p>The <strong class="source inline">Application</strong> class can be used to inject the idling resource, <span class="No-Break">like this:</span></p>
			<pre class="source code">
class MyApplication : Application(){
    val countingIdlingResource =
        CountingIdlingResource("My heavy work")
    val myHeavyliftingComponent =
        MyHeavyliftingComponent(countingIdlingResource)
}</pre>
			<p>Then, in the<a id="_idIndexMarker890"/> test, we can access the <strong class="source inline">Application</strong> class and register the resource <span class="No-Break">to Espresso:</span></p>
			<pre class="source code">
@RunWith(AndroidJUnit4::class)
class MyTest {
    @Before
    fun setUp() {
        val myApplication =
            getApplicationContext&lt;MyApplication&gt;()
        IdlingRegistry.getInstance()
            .register(myApplication.countingIdlingResource)
    }
}</pre>
			<p>Espresso comes with a set of extensions that can be used to assert different Android components. One extension is intents testing. This is useful when you want to test an activity in isolation (more appropriate for integration tests). In order to use this, you need to add the library <span class="No-Break">to Gradle:</span></p>
			<pre class="source code">
androidTestImplementation 'androidx.test.espresso:
espresso-intents:3.5.0'</pre>
			<p>After you add the library, you need to set up the necessary intent monitoring using the <strong class="source inline">init</strong> method from the <strong class="source inline">Intents</strong> class, and to stop monitoring, you can use the <strong class="source inline">release</strong> method from the same class. These operations can be done in the <strong class="source inline">@Before</strong> and <strong class="source inline">@After</strong> annotated methods of your <span class="No-Break">test class.</span></p>
			<p>To assert the values of the intent, you need to trigger the appropriate action and then use the <span class="No-Break"><strong class="source inline">intended</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source code">
        onView(withId(R.id.button)).perform(click())
        intended(allOf(hasComponent(hasShortClassName
            (".MainActivity")), hasExtra(MainActivity
            .MY_EXTRA, "myExtraValue")))</pre>
			<p>The <strong class="source inline">intended</strong> method<a id="_idIndexMarker891"/> works in a similar way to the <strong class="source inline">onView</strong> method. It requires a matcher that can be combined with a <strong class="source inline">Hamcrest</strong> matcher. The intent-related matchers can be found in the <strong class="source inline">IntentMatchers</strong> class. This class contains methods to assert different methods of the <strong class="source inline">Intent</strong> class: extras, data, components, bundles, and <span class="No-Break">so on.</span></p>
			<p>Another important extension library comes to the aid of <strong class="source inline">RecyclerView</strong>. The <strong class="source inline">onData</strong> method from Espresso is only capable of testing <strong class="source inline">AdapterViews</strong> such as <strong class="source inline">ListView</strong> and isn’t capable of asserting <strong class="source inline">RecyclerView</strong>. In order to use the extension, you need to add the following library to <span class="No-Break">your project:</span></p>
			<pre class="source code">
androidTestImplementation
'com.android.support.test.espresso:espresso-contrib:3.5.0'</pre>
			<p>This library provides a <strong class="source inline">RecyclerViewActions</strong> class, which contains a set of methods that allow you to perform actions on items <span class="No-Break">inside </span><span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
onView(withId(R.id.recycler_view))
.perform(RecyclerViewActions.actionOnItemAtPosition(0,
click()))</pre>
			<p>The preceding statement will click the item at <span class="No-Break">position </span><span class="No-Break"><strong class="source inline">0</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
onView(withId(R.id.recycler_view)).perform(
RecyclerViewActions.scrollToPosition&lt;RecyclerView
.ViewHolder&gt;(10))</pre>
			<p>This will scroll to the 10th item in <span class="No-Break">the list:</span></p>
			<pre class="source code">
onView(withText("myText")).check(matches(isDisplayed()))</pre>
			<p>The preceding <a id="_idIndexMarker892"/>code will check whether a view with the <strong class="source inline">myText</strong> text is displayed, which will also apply to <span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break"> items.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor561"/>Testing in Jetpack Compose</h2>
			<p>Jetpack Compose<a id="_idIndexMarker893"/> offers the ability to test <strong class="source inline">@Composable</strong> functions <a id="_idIndexMarker894"/>with a similar approach to Espresso. If we are using Robolectric, we can write our testing code in the <strong class="source inline">test</strong> folder, and if not, we can use the <strong class="source inline">androidTest</strong> folder and our tests will be viewed as instrumented tests. The testing library is <span class="No-Break">the following:</span></p>
			<pre class="source code">
androidTestImplementation "androidx.compose.ui:
ui-test-junit4:1.1.1"</pre>
			<p>If we want to also test the <strong class="source inline">Activity</strong> that sets the <strong class="source inline">@Composable</strong> function as content, then we will also need to add the <span class="No-Break">following library:</span></p>
			<pre class="source code">
debugImplementation "androidx.compose.ui:
ui-test-manifest:1.1.1"</pre>
			<p>To test, we would need to use a test rule that provides a set of methods used for interacting with the <strong class="source inline">@Composable</strong> elements and performing assertions on them. We have multiple ways of obtaining that rule through the <span class="No-Break">following approaches:</span></p>
			<pre class="source code">
class MyTest {
    @get:Rule
    var composeTestRuleForActivity =
        createAndroidComposeRule(MyActivity::class.java)
    @get:Rule
    var composeTestRuleForNoActivity = createComposeRule()
    @Test
    fun testNoActivityFunction(){
        composeTestRuleForNoActivity.setContent {
            // Set method you want to test here
        }
    }
}</pre>
			<p>In the preceding snippet, we have two test rules. The first one, <strong class="source inline">composeTestRuleForActivity</strong>, will start the <strong class="source inline">Activity</strong> that holds the <strong class="source inline">@Composable</strong> function that we want to test and will hold all the nodes we want <span class="No-Break">to assert.</span></p>
			<p>The second<a id="_idIndexMarker895"/> one, <strong class="source inline">composeTestRuleForNoActivity</strong>, provides <a id="_idIndexMarker896"/>the ability to set as content the function we want to test. This will then allow the rule to have access to all the <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">Composable</strong></span><span class="No-Break"> elements.</span></p>
			<p>If we want to identify elements from our function, we have the <span class="No-Break">following methods:</span></p>
			<pre class="source code">
        composeTestRule.onNodeWithText("My text")
        composeTestRule.onNodeWithContentDescription(
            "My content description")
        composeTestRule.onNodeWithTag("My test tag")</pre>
			<p>In the preceding snippet, we have the <strong class="source inline">onNodeWithText</strong> method, which will identify a particular UI element using a text label that’s visible to the user. The <strong class="source inline">onNodeWithContentDescription</strong> method will identify an element using the content description set, and <strong class="source inline">onNodeWithTag</strong> will identify an element using the test tag, which is set using the <span class="No-Break"><strong class="source inline">Modifier.testTag</strong></span><span class="No-Break"> method.</span></p>
			<p>Like Espresso, once we identify the element we want to interact with or perform assertions on, we have similar methods for both situations. For interacting with the element, we have methods such as <span class="No-Break">the following:</span></p>
			<pre class="source code">
        composeTestRule.onNodeWithText("My text")
            .performClick()
            .performScrollTo()
            .performTextInput("My new text")
            .performGesture {
            }</pre>
			<p>In the preceding snippet, we perform a click, scroll, text insertion, and gesture into the element. For <a id="_idIndexMarker897"/>assertions, some <a id="_idIndexMarker898"/>examples are <span class="No-Break">as follows:</span></p>
			<pre class="source code">
        composeTestRule.onNodeWithText("My text")
            .assertIsDisplayed()
            .assertIsNotDisplayed()
            .assertIsEnabled()
            .assertIsNotEnabled()
            .assertIsSelected()
            .assertIsNotSelected()</pre>
			<p>In the preceding example, we assert whether an element is displayed, not displayed, enabled, not enabled, selected, or <span class="No-Break">not selected.</span></p>
			<p>If our user interface has multiple elements with the same text, we have the option to extract all of them using <span class="No-Break">the following:</span></p>
			<pre class="source code">
        composeTestRule.onAllNodesWithText("My text")
        composeTestRule.onAllNodesWithContentDescription(
            "My content description")
        composeTestRule.onAllNodesWithTag("My test tag")</pre>
			<p>Here, we extract all the nodes that have <strong class="source inline">My text</strong> as a text, <strong class="source inline">My content description</strong> as a content description, and <strong class="source inline">My test tag</strong> as a test tag. The return is a collection, which allows us to assert each element of the collection individually, <span class="No-Break">like so:</span></p>
			<pre class="source code">
        composeTestRule.onAllNodesWithText("My text")[0]
            .assertIsDisplayed()</pre>
			<p>Here, we assert that the first element that has <strong class="source inline">My text</strong> is displayed. We also can perform assertions on the collection, <span class="No-Break">like so:</span></p>
			<pre class="source code">
        composeTestRule.onAllNodesWithText("My text")
            .assertCountEquals(3)
            .assertAll(SemanticsMatcher.expectValue(
            SemanticsProperties.Selected, true))
            .assertAny(SemanticsMatcher.expectValue(
            SemanticsProperties.Selected, true))</pre>
			<p>Here, we assert<a id="_idIndexMarker899"/> that the number of elements that have <strong class="source inline">My text</strong> as a text<a id="_idIndexMarker900"/> set is three, assert whether all elements match a <strong class="source inline">SemanticsMatcher</strong>, or assert whether any of the elements match a <strong class="source inline">SemanticMatcher</strong>. In this case, it would assert that all the elements are selected and at least one element <span class="No-Break">is selected.</span></p>
			<p>Another similarity to Espresso that we have when testing Jetpack Compose is the usage of <strong class="source inline">IdlingResource</strong>. Compose provides its own <strong class="source inline">IdlingResource</strong> abstraction, which is separate from Espresso and can be registered to our test rule <span class="No-Break">as follows:</span></p>
			<pre class="source code">
    @Before
    fun setUp() {
        composeTestRule.registerIdlingResource(
        idlingResource)
    }
    @After
    fun tearDown() {
        composeTestRule.unregisterIdlingResource(
        idlingResource)
    }</pre>
			<p>In the preceding <a id="_idIndexMarker901"/>s<a id="_idTextAnchor562"/>nippet,<a id="_idTextAnchor563"/> we register <strong class="source inline">IdlingResource</strong> in the <strong class="source inline">@Before</strong> annotated<a id="_idIndexMarker902"/> method and unregister it in the <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">After</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor564"/>Exercise 10.03 – random waiting times</h2>
			<p>Write an <a id="_idIndexMarker903"/>application that will have two screens. The first screen will have a button. When the user presses the button, it will wait a random time between 1 and 5 seconds and then launch the second screen, which will display the text <strong class="bold">Opened after x seconds</strong>, where <strong class="bold">x</strong> is the number of seconds that passed. Write a UI test that will cover this scenario with the following features adjusted for <span class="No-Break">the test:</span></p>
			<ul>
				<li>The <strong class="source inline">random</strong> function will return a value of <strong class="source inline">1</strong> when the test <span class="No-Break">is run</span></li>
				<li><strong class="source inline">CountingIdlingResource</strong> will be used to indicate when the timer <span class="No-Break">has stopped</span></li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">Throughout this exercise, <strong class="source inline">import</strong> statements are not shown. To see the full code files, refer <span class="No-Break">to </span><a href="https://packt.link/GG32r"><span class="No-Break">https://packt.link/GG32r</span></a><span class="No-Break">.</span></p>
			<p>Take the following steps to complete <span class="No-Break">this exercise:</span></p>
			<ol>
				<li>Create a new Android Studio Project with <span class="No-Break">no Activity.</span></li>
				<li>Add the following libraries <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
    implementation 'androidx.test.espresso:
        espresso-idling-resource:3.5.1'
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation
        'androidx.test.espresso:espresso-core:3.5.1'
    androidTestImplementation
        'androidx.test.ext:junit:1.1.5'
    androidTestImplementation
        'androidx.test:rules:1.5.0'</pre></li>
				<li>In the <strong class="source inline">main</strong> folder in<a id="_idIndexMarker904"/> the root package, create a class; start with a <span class="No-Break"><strong class="source inline">Randomizer</strong></span><span class="No-Break"> class:</span><pre class="source code">
open class Randomizer(private val random: Random) {
    open fun getTimeToWait(): Int {
        return random.nextInt(5) + 1
    }
}</pre></li>
				<li>In the <strong class="source inline">main</strong> folder in the root package, create a class; create a <strong class="source inline">Synchronizer</strong> class, which will use <strong class="source inline">Randomizer</strong> and <strong class="source inline">Timer</strong> to wait for the random time interval. It will also use <strong class="source inline">CountingIdlingResource</strong> to mark the start of the task and the end of <span class="No-Break">the task:</span><pre class="source code">
class Synchronizer(
    private val randomizer: Randomizer,
    private val timer: Timer,
    private val countingIdlingResource:
        CountingIdlingResource
) {
    fun executeAfterDelay(callback: (Int) -&gt; Unit) {
        val timeToWait = randomizer.getTimeToWait()
        countingIdlingResource.increment()
        timer.schedule(CallbackTask(callback,
            timeToWait), timeToWait * 1000L)
    }
    inner class CallbackTask(
        private val callback: (Int) -&gt; Unit,
        private val time: Int
    ) : TimerTask() {
        override fun run() {
            callback(time)
            countingIdlingResource.decrement()
        }
    }
}</pre></li>
				<li>Now, create an <strong class="source inline">Application</strong> class, which will be responsible for creating all the instances <a id="_idIndexMarker905"/>of the <span class="No-Break">preceding classes:</span><pre class="source code">
class MyApplication : Application() {
    val countingIdlingResource =
        CountingIdlingResource("Timer resource")
    val randomizer = Randomizer(Random())
    val synchronizer =
        Synchronizer(randomizer, Timer(),
        countingIdlingResource)
}</pre></li>
				<li>Add the <strong class="source inline">MyApplication</strong> class to <strong class="source inline">AndroidManifest</strong> in the <strong class="source inline">application</strong> tag with the <span class="No-Break"><strong class="source inline">android:name</strong></span><span class="No-Break"> attribute.</span></li>
				<li>Create an <strong class="source inline">activity_1</strong> layout file, which will contain a parent layout and <span class="No-Break">a button:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;
    &lt;Button
        android:id="@+id/activity_1_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="@string/press_me" /&gt;
&lt;/LinearLayout&gt;</pre></li>
				<li>Create an <strong class="source inline">activity_2</strong> layout file, which <a id="_idIndexMarker906"/>will contain a parent layout <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">TextView</strong></span><span class="No-Break">:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;
    &lt;TextView
        android:id="@+id/activity_2_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center" /&gt;
&lt;/LinearLayout&gt;</pre></li>
				<li>Create the <strong class="source inline">Activity1</strong> class, which<a id="_idIndexMarker907"/> will implement the logic for the <span class="No-Break">button click:</span><pre class="source code">
class Activity1 : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_1)
        findViewById&lt;Button&gt;(R.id.activity_1_button)
        .setOnClickListener {
            (application as MyApplication)
            .synchronizer.executeAfterDelay {
                startActivity(Activity2.newIntent(this
                , it))
            }
        }
    }
}</pre></li>
				<li>Create the <strong class="source inline">Activity2</strong> class, which will display the received data through <span class="No-Break">the intent:</span><pre class="source code">
class Activity2 : AppCompatActivity() {
    companion object {
        private const val EXTRA_SECONDS =
            "extra_seconds"
        fun newIntent(context: Context, seconds: Int)
            = Intent(context, Activity2::class.java)
            .putExtra(EXTRA_SECONDS, seconds)
    }
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_2)
        findViewById&lt;TextView&gt;(
            R.id.activity_2_text_view).text =
            getString(R.string.opened_after_x_seconds,
            intent.getIntExtra(EXTRA_SECONDS, 0))
    }
}</pre></li>
				<li>Make sure <a id="_idIndexMarker908"/>that the relevant strings are added <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">strings.xml</strong></span><span class="No-Break">:</span><pre class="source code">
    &lt;string name="press_me"&gt;Press Me&lt;/string&gt;
    &lt;string name="opened_after_x_seconds"&gt;Opened after
    %d seconds&lt;/string&gt;</pre></li>
				<li>Make sure that the two activities are added <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">AndroidManifest.xml</strong></span><span class="No-Break">:</span><pre class="source code">
    &lt;application
        … &gt;
        &lt;activity
            android:name=".Activity1"
            android:exported="true"&gt;
    &lt;/application&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/TkEX9"><span class="No-Break">https://packt.link/TkEX9</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="13">Create a <strong class="source inline">FlowTest</strong> class in the <strong class="source inline">androidTest</strong> directory, which will register <strong class="source inline">IdlingResource</strong> from the <strong class="source inline">MyApplication</strong> object and will assert the outcome<a id="_idIndexMarker909"/> of <span class="No-Break">the click:</span><pre class="source code">
@RunWith(AndroidJUnit4::class)
@LargeTest
class FlowTest {
    @Test
    fun verifyFlow() {
        onView(withId(R.id.activity_1_button))
            .perform(click())
        onView(withId(R.id.activity_2_text_view))
           .check(matches(withText(myApplication
           .getString(R.string.opened_after_x_seconds,
           1))))
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/711Vw"><span class="No-Break">https://packt.link/711Vw</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="14">Run the test multiple times and check the test results. Notice that the test will have a 20% chance of success, but it will wait until the button from <strong class="source inline">Activity1</strong> is clicked. This means that the idling resource is working. Another thing to observe is that there is an element of <span class="No-Break">randomness here.</span></li>
				<li>Tests don’t like randomness, so we need to eliminate it by making the <strong class="source inline">Randomizer</strong> class open and creating a subclass in the <strong class="source inline">androidTest</strong> directory. We can do the same for the <strong class="source inline">MyApplication</strong> class and provide a different randomizer <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">TestRandomizer</strong></span><span class="No-Break">:</span><pre class="source code">
class TestRandomizer(random: Random) :
Randomizer(random) {
    override fun getTimeToWait(): Int {
        return 1
    }
}</pre></li>
				<li>Now, modify<a id="_idIndexMarker910"/> the <strong class="source inline">MyApplication</strong> class in a way in which we can override the randomizer from <span class="No-Break">a subclass:</span><pre class="source code">
open class MyApplication : Application() {
    val countingIdlingResource =
        CountingIdlingResource("Timer resource")
    lateinit var synchronizer: Synchronizer
    override fun onCreate() {
        super.onCreate()
        synchronizer =
            Synchronizer(createRandomizer(), Timer(),
            countingIdlingResource)
    }
    open fun createRandomizer() = Randomizer(Random())
}</pre></li>
				<li>In the <strong class="source inline">androidTest</strong> directory, create <strong class="source inline">TestMyApplication</strong>, which will extend <strong class="source inline">MyApplication</strong> and override the <span class="No-Break"><strong class="source inline">createRandomizer</strong></span><span class="No-Break"> method:</span><pre class="source code">
class TestMyApplication : MyApplication() {
    override fun createRandomizer(): Randomizer {
        return TestRandomizer(Random())
    }
}</pre></li>
				<li>Finally, in the <strong class="source inline">androidTest/java</strong> folder in the root package, create an instrumentation <a id="_idIndexMarker911"/>test runner that will use this new <strong class="source inline">Application</strong> class inside <span class="No-Break">the test:</span><pre class="source code">
class MyApplicationTestRunner : AndroidJUnitRunner() {
    @Throws(Exception::class)
    override fun newApplication(
        cl: ClassLoader?,
        className: String?,
        context: Context?
    ): Application? {
        return super.newApplication(cl,
        TestMyApplication::class.java.name, context)
    }
}</pre></li>
				<li>Add the new test runner to the <span class="No-Break">Gradle configuration:</span><pre class="source code">
android {
    ...
    defaultConfig {
        ...
        testInstrumentationRunner
            "com.android.testable.myapplication
            .MyApplicationTestRunner"
    }
}</pre></li>
			</ol>
			<p>If we run the test now, the test should pass; however, we have a couple of problems with our dependencies. For the <strong class="source inline">Randomizer</strong> class, we had to make our class open so that it could be extended in the <span class="No-Break"><strong class="source inline">androidTest</strong></span><span class="No-Break"> folder.</span></p>
			<p>Another issue is the fact that our application code contains references to idling resources that are part of the testing libraries. To solve both problems, we will need to define abstractions for the <strong class="source inline">Randomizer</strong> and <span class="No-Break"><strong class="source inline">Synchronizer</strong></span><span class="No-Break"> classes.</span></p>
			<ol>
				<li value="20">In the <strong class="source inline">main/java</strong> folder<a id="_idIndexMarker912"/> in the root package, create an interface <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">Randomizer</strong></span><span class="No-Break">:</span><pre class="source code">
interface Randomizer {
    fun getTimeToWait(): Int
}</pre></li>
				<li>Rename the previous <strong class="source inline">Randomizer</strong> class <strong class="source inline">RandomizerImpl</strong> and implement the <strong class="source inline">Randomizer</strong> interface <span class="No-Break">as follows:</span><pre class="source code">
class RandomizerImpl(private val random: Random) :
Randomizer {
    override fun getTimeToWait(): Int {
        return random.nextInt(5) + 1
    }
}</pre></li>
				<li>In <strong class="source inline">MyApplication</strong>, modify the <strong class="source inline">createRandomizer</strong> method to have the <strong class="source inline">Randomizer</strong> return type, which will return an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">RandomizerImpl</strong></span><span class="No-Break">:</span><pre class="source code">
open class MyApplication : Application() {
    …
    open fun createRandomizer() : Randomizer =
        RandomizerImpl(Random())
}</pre></li>
				<li>Modify <strong class="source inline">TestRandomizer</strong> to implement the <span class="No-Break"><strong class="source inline">Randomizer</strong></span><span class="No-Break"> interface:</span><pre class="source code">
class TestRandomizer : Randomizer {
    override fun getTimeToWait(): Int {
        return 1
    }
}</pre></li>
				<li>Modify <strong class="source inline">TestMyApplication</strong> to <a id="_idIndexMarker913"/>correct the <span class="No-Break">compile errors:</span><pre class="source code">
class TestMyApplication : MyApplication() {
    override fun createRandomizer(): Randomizer {
        return TestRandomizer()
    }
}</pre></li>
				<li>In <strong class="source inline">app/build.gradle</strong>, make the idling resource <span class="No-Break">dependency </span><span class="No-Break"><strong class="source inline">androidTestImplementation</strong></span><span class="No-Break">:</span><pre class="source code">
    androidTestImplementation 'androidx.test.espresso:
    espresso-idling-resource:3.5.1'</pre></li>
				<li>In the <strong class="source inline">main/java</strong> folder in the root package, create an interface <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">Synchronizer</strong></span><span class="No-Break">:</span><pre class="source code">
interface Synchronizer {
    fun executeAfterDelay(callback: (Int) -&gt; Unit)
}</pre></li>
				<li>Rename the previous <strong class="source inline">Synchronizer</strong> class <strong class="source inline">SynchronizerImpl</strong>, implement the <strong class="source inline">Synchronizer</strong> interface, and remove the usages <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">CountingIdlingResource</strong></span><span class="No-Break">:</span><pre class="source code">
class SynchronizerImpl(
    private val randomizer: Randomizer,
    private val timer: Timer
) : Synchronizer {
    override fun executeAfterDelay(callback: (Int) -&gt;
    Unit) {
        val timeToWait = randomizer.getTimeToWait()
            timer.schedule(CallbackTask(callback,
            timeToWait), timeToWait * 1000L)
    }
    inner class CallbackTask(
        private val callback: (Int) -&gt; Unit,
        private val time: Int
    ) : TimerTask() {
        override fun run() {
            callback(time)
        }
    }
}</pre></li>
				<li>Modify <strong class="source inline">MyApplication</strong> so that it will open the ability to provide different <strong class="source inline">Synchronizer</strong> instances from the <span class="No-Break"><strong class="source inline">TestMyApplication</strong></span><span class="No-Break"> class:</span><pre class="source code">
open class MyApplication : Application() {
    lateinit var synchronizer: Synchronizer
    override fun onCreate() {
        super.onCreate()
        synchronizer = createSynchronizer()
    }
    open fun createRandomizer(): Randomizer =
        RandomizerImpl(Random())
    open fun createSynchronizer(): Synchronizer =
        SynchronizerImpl(createRandomizer(), Timer())
}</pre></li>
				<li>In the <strong class="source inline">androidTest</strong> folder, create a class called <strong class="source inline">TestSynchronizer</strong>, which will<a id="_idIndexMarker914"/> wrap a <strong class="source inline">Synchronizer</strong>, and then use <strong class="source inline">CountingIdlingResource</strong> to increment and decrement a counter when <strong class="source inline">executeAfterDelay</strong> is started <span class="No-Break">and finished:</span><pre class="source code">
class TestSynchronizer(
    private val synchronizer: Synchronizer,
    private val countingIdlingResource:
        CountingIdlingResource
) : Synchronizer {
    override fun executeAfterDelay(callback: (Int) -&gt;
    Unit) {
        countingIdlingResource.increment()
        synchronizer.executeAfterDelay {
            callback(it)
            countingIdlingResource.decrement()
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding example, we have a reference to a <strong class="source inline">Synchronizer</strong> instance. When <strong class="source inline">executeAfterDelay</strong> is called, then we inform Espresso to wait. We then invoke the actual <strong class="source inline">Synchronizer</strong> instance, and when it finishes the execution, we then inform Espresso <span class="No-Break">to resume.</span></p>
			<ol>
				<li value="30">Modify <strong class="source inline">TestMyApplication</strong> to <a id="_idIndexMarker915"/>provide an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">TestSynchronizer</strong></span><span class="No-Break">:</span><pre class="source code">
class TestMyApplication : MyApplication() {
    val countingIdlingResource =
        CountingIdlingResource("Timer resource")
    override fun createRandomizer(): Randomizer {
        return TestRandomizer()
    }
    override fun createSynchronizer(): Synchronizer {
        return
          TestSynchronizer(super.createSynchronizer(),
          countingIdlingResource)
    }
}</pre></li>
			</ol>
			<p>In the preceding snippet, we create a new <strong class="source inline">TestSynchronizer</strong> that wraps the <strong class="source inline">Synchronizer</strong> defined in <strong class="source inline">MyApplication</strong> and adds <span class="No-Break">the </span><span class="No-Break"><strong class="source inline">CountingIdlingResource</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="31">In <strong class="source inline">FlowTest</strong>, change the reference to <strong class="source inline">MyApplication</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">TestMyApplication</strong></span><span class="No-Break">:</span><pre class="source code">
private val myApplication =
    getApplicationContext&lt;TestMyApplication&gt;()</pre></li>
			</ol>
			<p>When running the test now, everything should pass, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B19411_10_010.jpg" alt="Figure 10.10 – Output of Exercise 10.03"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Output of Exercise 10.03</p>
			<p>This type of exercise shows how to avoid randomness in a test and provides concrete and repeatable input to make our tests reliable. Similar approaches are taken with dependency injection frameworks, where entire modules can be replaced in the test suite to ensure the <span class="No-Break">test’s reliability.</span></p>
			<p>One of the most<a id="_idIndexMarker916"/> common things to be replaced is API communication. Another issue this approach solves is the decrease in waiting time. If this type of scenario were to have been repeated across your tests, then the execution time of them would have increased because <span class="No-Break">of this.</span></p>
			<p>In this exercise, we have looked at how we can write instrumented tests and execute them on an emulator or physical device. We have also analyzed how we can decorate our objects with <strong class="source inline">CountingIdlingResources</strong> to be able t<a id="_idTextAnchor565"/><a id="_idTextAnchor566"/>o monitor asynchronous operations, and how we can switch dependencies that cause flakiness and provide stub <span class="No-Break">data instead.</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor567"/>TDD</h1>
			<p>Let’s assume <a id="_idIndexMarker917"/>that you are tasked with building an activity that displays a calculator with the add, subtract, multiply, and divide options. You must also write tests for your implementation. Typically, you would build your UI and your activity and a separate <strong class="source inline">Calculator</strong> class. Then, you would write the unit tests for your <strong class="source inline">Calculator</strong> class and then for your <span class="No-Break"><strong class="source inline">activity</strong></span><span class="No-Break"> class.</span></p>
			<p>If you were to translate the TDD process to implementing features on an Android app, you would have to write your UI test with your scenarios first. To achieve this, you can create a skeleton UI to avoid compile-time errors. After your UI test, you would need to write your <strong class="source inline">Calculator</strong> test. Here, you would also need to create the necessary methods in the <strong class="source inline">Calculator</strong> class to avoid <span class="No-Break">compile-time errors.</span></p>
			<p>If you ran your tests in this phase, they would fail. This would force you to implement your code until the tests pass. Once your <strong class="source inline">Calculator</strong> tests pass, you can connect your calculator to your UI until your UI tests pass. While this seems like a counter-intuitive approach, it solves two issues once the process <span class="No-Break">is mastered:</span></p>
			<ul>
				<li>Less time will be spent writing code because you will ensure that your code is testable, and you need to write only the amount of code necessary for the test <span class="No-Break">to pass</span></li>
				<li>Fewer bugs will be introduced becau<a id="_idTextAnchor568"/>se developers will be able to analyze <span class="No-Break">different outcomes</span></li>
			</ul>
			<p>Have a look at the following diagram, which shows the <span class="No-Break">TDD cycle:</span></p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B19411_10_011.jpg" alt="Figure 10.11 – TDD cycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – TDD cycle</p>
			<p>In the preceding<a id="_idIndexMarker918"/> figure, we can see the development cycle in a TDD process. You should start from a point where your tests are failing. Implement changes for the tests to pass. When you update or add new features, you can repeat <span class="No-Break">the process.</span></p>
			<p>Going back to our factorial examples, we started with a <strong class="source inline">factorial</strong> function that didn’t cover all our scenarios and had to keep updating the function every time a new test was added. TDD is built with that idea in mind. You start with an empty function. You start defining your testing scenarios: what are the conditions for success? What’s the minimum? What’s the maximum? Are there any exceptions to the main rule? What are they? These questions can help developers define the<a id="_idTextAnchor569"/><a id="_idTextAnchor570"/>ir test cases. Then, these cases can be written. Let’s now see how this can be done practically through the <span class="No-Break">next exercise.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor571"/>Exercise 10.04 – using TDD to calculate the sum of numbers</h2>
			<p>Write a function<a id="_idIndexMarker919"/> that has as input the integer <strong class="source inline">n</strong> and will return the sum of numbers from <strong class="source inline">1</strong> to <strong class="source inline">n</strong>. The function should be written with a TDD approach, and the following criteria should <span class="No-Break">be satisfied:</span></p>
			<ul>
				<li>For <strong class="source inline">n&lt;=0</strong>, the function will return the <span class="No-Break">value </span><span class="No-Break"><strong class="source inline">-1</strong></span></li>
				<li>The function should be able to return the correct value <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">Int.MAX_VALUE</strong></span></li>
				<li>The function should be quick, even <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">Int.MAX_VALUE</strong></span></li>
			</ul>
			<p>Perform the following steps to complete <span class="No-Break">this exercise:</span></p>
			<ol>
				<li>Create a new Android Studio Project with <span class="No-Break">No Activity.</span></li>
				<li>Make sure that the following library is added <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
testImplementation 'junit:junit:4.13.2'</pre></li>
				<li>In the <strong class="source inline">main/java</strong> folder in the root package, create an <strong class="source inline">Adder</strong> class with the <strong class="source inline">sum</strong> method, which will return <strong class="source inline">0</strong>, to satisfy <span class="No-Break">the compiler:</span><pre class="source code">
class Adder {
    fun sum(n: Int): Int = 0
}</pre></li>
				<li>Create an <strong class="source inline">AdderTest</strong> class in the <strong class="source inline">test</strong> directory and define our test cases. We will have the following test cases: <strong class="source inline">n=1</strong>, <strong class="source inline">n=2</strong>, <strong class="source inline">n=0</strong>, <strong class="source inline">n=-1</strong>, <strong class="source inline">n=10</strong>, <strong class="source inline">n=20</strong>, and <strong class="source inline">n=Int.MAX_VALUE</strong>. We can split the successful scenarios into one method and the unsuccessful ones into a <span class="No-Break">separate method:</span><pre class="source code">
class AdderTest {
    private val adder = Adder()
    @Test
    fun sumSuccess() {
        assertEquals(1, adder.sum(1))
        assertEquals(3, adder.sum(2))
        assertEquals(55, adder.sum(10))
        assertEquals(210, adder.sum(20))
        assertEquals(2305843008139952128L,
            adder.sum(Int.MAX_VALUE))
    }
    @Test
    fun sumError(){
        assertEquals(-1, adder.sum(0))
        assertEquals(-1, adder.sum(-1))
    }
}</pre></li>
			</ol>
			<p>If we <a id="_idTextAnchor572"/>run<a id="_idIndexMarker920"/> the tests for the <strong class="source inline">AdderTest</strong> class, we will see an output like the following figure, meaning that all our <span class="No-Break">tests failed:</span></p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B19411_10_012.jpg" alt="Figure 10.12 – Initial test status for Exercise 10.04"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Initial test status for Exercise 10.04</p>
			<ol>
				<li value="5">Let’s first address the success scenarios by implementing the sum in a loop from <strong class="source inline">1</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">n</strong></span><span class="No-Break">:</span><pre class="source code">
class Adder {
    fun sum(n: Int): Long {
        var result = 0L
        for (i in 1..n) {
            result += i
        }
        return r<a id="_idTextAnchor573"/>esult
    }
}</pre></li>
			</ol>
			<p>If we run the tests now, you will see that one will pass and the other will fail, like the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B19411_10_013.jpg" alt="Figure 10.13 – Test status after resolving the success scenario for Exercise 10.04"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Test status after resolving the success scenario for Exercise 10.04</p>
			<ol>
				<li value="6">If we look at the time it took to execute the successful test, it seems a bit long. This can add up when thousands of unit tests are present in one project. We can now optimize <a id="_idIndexMarker921"/>our code to deal with the issue by applying the <span class="No-Break"><em class="italic">n(n+1)/2</em></span><span class="No-Break"> formula:</span><pre class="source code">
class Adder {
    fun sum(n: Int): Long {
        return (n * (n.toLong() + 1)) / 2
    }
}</pre></li>
			</ol>
			<p>Running the tests now will drastically reduce the execution time to a <span class="No-Break">few milliseconds.</span></p>
			<ol>
				<li value="7">Now, let’s focus on solving our failure scenarios. We can do this by adding a condition for when <strong class="source inline">n</strong> is smaller than or equal <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">0</strong></span><span class="No-Break">:</span><pre class="source code">
class Adder {
    fun sum(n: Int): Long {
        return if (n &gt; 0) (n * <a id="_idTextAnchor574"/>(n.toLong() + 1)) / 2
else -1
    }
}</pre></li>
			</ol>
			<p>If we run the tests now, we should see them all passing, like the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B19411_10_014.jpg" alt="Figure 10.14 – Passing tests for Exercise 10.04"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Passing tests for Exercise 10.04</p>
			<p>In this exercise, we have applied the concept of TDD to a very small example to demonstrate how the technique can be used. We have observed how, starting from the skeleton code, we can create a suite of tests to verify our conditions, and how by constantly running tests, we improved the code until a point where all the tests pass. As you have probably noticed, the concept isn’t an intuitive one. Some developers find it hard to define how big skeleton code should be to start creating the test cases, while others, out <a id="_idIndexMarker922"/>of habit, focus on writing the code first and then d<a id="_idTextAnchor575"/>eveloping the<a id="_idTextAnchor576"/><a id="_idTextAnchor577"/> test. In either case, developers will need a lot of practice with the technique until it’s <span class="No-Break">properly mastered.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor578"/>Activity 10.01 – developing with TDD</h2>
			<p>Using the TDD<a id="_idIndexMarker923"/> approach, develop an application that contains three activities and works <span class="No-Break">as follows:</span></p>
			<ul>
				<li>In activity 1, you will display a numeric <strong class="source inline">EditText</strong> element and a button. When the button is clicked, the number in <strong class="source inline">EditText</strong> will be passed to <span class="No-Break">activity 2.</span></li>
				<li>Activity 2 will generate a list of items asynchronously. The number of items will be represented by the number passed from activity 1. You can use the <strong class="source inline">Timer</strong> class with a delay of 1 second. Each item in the list will display the text <strong class="source inline">Item x</strong> where <strong class="source inline">x</strong> is the position in the list. When an item is clicked, you should pass the clicked item to <span class="No-Break">activity 3.</span></li>
				<li>Activity 3 will display the text <strong class="source inline">You clicked y</strong>, where <strong class="source inline">y</strong> is the text of the item the user <span class="No-Break">has clicked.</span></li>
			</ul>
			<p>The tests for the app will be <span class="No-Break">the following:</span></p>
			<ul>
				<li>Unit tests with Mockito and <strong class="source inline">mockito-kotlin</strong> annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">@SmallTest</strong></span></li>
				<li>Integration tests with Robolectric and Espresso annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">@MediumTest</strong></span></li>
				<li>UI tests with Espresso annotated with <strong class="source inline">@LargeTest</strong> and using the <span class="No-Break"><strong class="source inline">Robot</strong></span><span class="No-Break"> pattern</span></li>
			</ul>
			<p>Run the test commands from the command line. To complete this activity, you need to take the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>You will<a id="_idIndexMarker924"/> need Android Studio 4.1.1 or higher with Kotlin 1.4.21 or higher for the Parcelize <span class="No-Break">Kotlin plugin.</span></li>
				<li>Create the three activities and the UI for each <span class="No-Break">of them.</span></li>
				<li>In the <strong class="source inline">androidTest</strong> folder, create three robots, one for <span class="No-Break">each activity:</span><ul><li>Robot 1 will contain the interaction with <strong class="source inline">EditText</strong> and <span class="No-Break">the button</span></li><li>Robot 2 will assert the number of items on the screen and interact with an item in <span class="No-Break">the list</span></li><li>Robot 3 will assert the text displayed <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">TextView</strong></span></li></ul></li>
				<li>Create an instrumented test class that will have one test method using the <span class="No-Break">preceding robots.</span></li>
				<li>Create an <strong class="source inline">Application</strong> class that will hold instances of all the classes that will <span class="No-Break">be unit-tested.</span></li>
				<li>Create three classes representing integration tests, one for each of the activities. Each of these classes will contain one test method for interactions and data loading. Each integration test will assert the intents passed between <span class="No-Break">the activities.</span></li>
				<li>Create a class that will provide the text required for the UI. It will have a reference to a <strong class="source inline">Context</strong> object and will contain two methods that will provide the text for the UI, which will return an <span class="No-Break">empty string.</span></li>
				<li>Create the test for the preceding class in which the two methods <span class="No-Break">are tested.</span></li>
				<li>Implement the class for the preceding tests <span class="No-Break">to pass.</span></li>
				<li>Create a class that will be responsible for loading the list in <strong class="source inline">Activity2</strong>, and provide an empty method for loading. The class will have a reference to the timer and the idling resource. Here, you should also create a data class that will represent the model <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break">.</span></li>
				<li>Create a unit test for the <span class="No-Break">preceding class.</span></li>
				<li>Create the <a id="_idIndexMarker925"/>implementation for the preceding class and run the unit tests until <span class="No-Break">they pass.</span></li>
				<li>In the <strong class="source inline">Application</strong> class, instantiate the classes that were unit-tested and start using them in your activities. Do this until your integration <span class="No-Break">tests pass.</span></li>
				<li>Provide <strong class="source inline">IntegrationTestApplication</strong>, which will return a new implementation of the class responsible for loading. This is to avoid making your integration test for <strong class="source inline">Activity2</strong> wait until loading <span class="No-Break">is complete.</span></li>
				<li>Provide <strong class="source inline">UiTestApplication</strong>, which will again reduce the loading time of your models and connect the idling resource to Espresso. Implement the remaining work for the UI test <span class="No-Break">to pass.</span></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found <span class="No-Break">at<a id="_idTextAnchor579"/><a id="_idTextAnchor580"/> </span><a href="https://packt.link/Ma4tD"><span class="No-Break">https://packt.link/Ma4tD</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor581"/>Summary</h1>
			<p>In this chapter, we looked at the different types of testing and the frameworks available for implementing these tests. We also looked at the testing environment and how to structure it for each environment, as well as structuring your code into multiple components that can be <span class="No-Break">individually unit-tested.</span></p>
			<p>We analyzed different ways to test code, how we should approach testing, and how, by looking at different test results, we can improve our code. With TDD, we learned that by starting with testing, we can write our code faster and ensure it is <span class="No-Break">less error-prone.</span></p>
			<p>The activity is where all these concepts came together into building a simple Android application, and we can observe how, by adding tests, the development time increases, but this pays off in the long term by eliminating possible bugs that appear when the code <span class="No-Break">is modified.</span></p>
			<p>The frameworks we have studied are some of the most common ones, but there are others that build on top of these and are used by developers in their projects, such as Mockk (a mocking library designed for Kotlin that takes advantage of a lot of the features of the language) and Barista (written on top of Espresso and simplifies the syntax of UI tests), to note <span class="No-Break">a few.</span></p>
			<p>Think of all the concepts presented here as building blocks that fit into two processes present in the software engineering world: automation and continuous integration. Automation takes redundant and repetitive work out of the hands of developers and puts it into the hands <span class="No-Break">of machines.</span></p>
			<p>Instead of having a team of quality assurance people testing your application to make sure the requirements are met, you can instruct a machine through a variety of tests and test cases to test the application instead and just have one person reviewing the results of <span class="No-Break">the tests.</span></p>
			<p>Continuous integration builds on the concept of automation to verify your code the moment you submit it for review from other developers. A project with continuous integration would have a setup along the following lines: a developer submits work for review in a source control repository such <span class="No-Break">as GitHub.</span></p>
			<p>A machine in the cloud would then start executing the tests for the entire project, making sure that nothing was broken, and the developer can move on to a new task. If the tests pass, then the rest of the developers can review the code, and when it is correct, it can be merged, and a new build can be created in the cloud and distributed to the rest of the team and <span class="No-Break">the testers.</span></p>
			<p>All of this takes place while the initial developer can safely work on something else. If anything fails in the process, then they can pause the new task and go and address any issues in their work. The continuous integration process can then be expanded into continuous delivery, where similar automation can be set up when preparing a submission to Google Play that can be handled almost entirely by machines with minor involvement <span class="No-Break">from developers.</span></p>
			<p>In the chapters that follow, you will learn about how to organize your code when building more complex applications that use the storage capabilities of the device and connect to the cloud to request data. Each of those components can be individually unit-tested, and you can apply integration tests to assert a successful integration of <span class="No-Break">multiple components.</span></p>
		</div>
	</body></html>