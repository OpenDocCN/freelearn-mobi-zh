- en: Chapter 3. Blast Off! Starting with Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now the fun really begins! We are going to start the development of our game!
    Are you as excited as I am? If you aren''t, you should be! Just look at what we''re
    going to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SpriteKit project in Xcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level design and implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gravity – player movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover all these and a whole lot more!
  prefs: []
  type: TYPE_NORMAL
- en: Buckle up because we are going to shift into high gear, and we aren't going
    to look back! Well, maybe we will once or twice, but you get the point. Let's
    begin! Let's create our project!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SpriteKit project in Xcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin straight away by opening up Xcode and clicking on **File** | **New**
    |**Project**. You will then be greeted by the New Project wizard, which will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this project, we are—obviously—going to select **iOS** | **Application**
    | **Single View Application** and then click on **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you do that, you will be required to fill in some details on the project,
    such as product name, organization name, and so on. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fill in the required fields (if they aren't already populated) and then click
    **Next**. To begin, we are going to make some changes to the project. For instance,
    locate the `LaunchScreen.xib` file in the sidebar on the left and delete it by
    pressing *Delete* on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `.xib` and storyboard files are the interface files that you can use to
    create the interface of a view. In them you can create buttons, text labels, and
    other user interface elements.
  prefs: []
  type: TYPE_NORMAL
- en: You will see a popup asking if you want to remove the reference or move it to
    the trash. We won't need it as we are going to program everything the player will
    see, so you can safely send it to the trash.
  prefs: []
  type: TYPE_NORMAL
- en: Then click on the main project file in the sidebar on the left; in the middle
    of the screen, you will see all the project's settings. We are also going to make
    some changes to this section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First things first. Under the **App Icons and Launch Images** rollout, locate
    the **Launch Screen File** dropdown. Where it says `LaunchScreen.xib`, simply
    select the text and delete it as shown in the following screenshot. Again, because
    we are going to be programming everything, we won't need it in our case.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Look down a little further and you will see the **Linked Frameworks and Libraries**
    roll out.
  prefs: []
  type: TYPE_NORMAL
- en: '**Frameworks** and **Libraries** are extensions you can add to further enhance
    the functionality of your app. Examples of what you can add are CoreGraphics and
    SpriteKit; even the Facebook API or Cocos2D can be downloaded and added for additional
    features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we add our various frameworks (if you didn''t know that already).
    We are going to add five frameworks and one library. To do this, click on the
    **+** button at the bottom of the section. The files we are going to add are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`libz.dlib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoreGraphics.framework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIKit.framework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpriteKit.framework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLKit.framework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Foundation.framework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a screenshot of **Linked Frameworks and Libraries**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our game is going to make good use of these frameworks, as we will see throughout
    this chapter. I like to keep things nice and organized whereas Xcode just throws
    files at the top of the sidebar on the left-hand side. I selected the new frameworks
    that were just added, right-clicked on them, selected **New Group from Selection**,
    and called that folder `Frameworks`. I personally like to keep things good and
    organized when developing; I even make sure all the paragraphs of code are indented
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: After you've added the new frameworks, you must download the two folders in
    the resource section of this book. They include additional frameworks that are
    provided for free online and that will assist us further, especially with our
    level design.
  prefs: []
  type: TYPE_NORMAL
- en: The Frameworks are `SKTUtils`, which is essentially an extension of `SpriteKit`,
    and `JSTileMap`, which we will use for our maps.
  prefs: []
  type: TYPE_NORMAL
- en: The `SKUtils` framework is an extension of `SpriteKit` that adds more visual
    effects as well as further mathematical calculations for additional physics (such
    as the use of π (pi) in calculations for even more complex physics calculations).
  prefs: []
  type: TYPE_NORMAL
- en: The `JSTileMap` framework allows us to import a tile map file into Xcode. As
    you will find out later, Xcode doesn't natively support map files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have them downloaded, simply select the two folders and drag them
    into the bar on the left-hand side of our project, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure you click on the **Copy items if needed** check box; this will copy
    these folders into your project folder so that any changes do not affect the originals.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the `SKTUtils` framework, I found, threw 20 errors at me, most of
    which were completely incomprehensible. So after much deliberation and debugging,
    I realized (halfway through writing this chapter, mind you), that we need to add
    a **prefix header**. The prefix header file is created to precompile headers a
    lot faster. So instead of compiling each header one by one, they are compiled
    once and way ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **File** | **New** | **File**. Once the wizard appears, click **Other**
    under **iOS**, select **PCH File (PreCompiledHeader File)**, and name it something
    like ***yourProjectName*-Prefix.pch**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that file is created, click on it to edit it; we are going to fill it
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We need to define our PCH file we just created in Xcode or else it will be rendered
    useless because it won't be doing anything!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are done filling out that file, we are going to click on our project
    in the bar on the left. You will now see tabs at the top of the navigation bar:
    **General**, **Capabilities**, **Info**, **Build Settings**, **Build Phases**,
    and **Build Rules**. Click on **Build Settings**. Scroll down to find **Apple
    LLVM 6.1 – Language** and change the **Precompile Prefix Header** selection to
    **Yes**. Below that, double-click on the empty field in the **Prefix Header**
    section and fill it out according to your project. I named my project Adesa, so
    I filled in **Adesa/Adesa-Prefix.pch**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Moving on!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to add in some more main and header files; one set will be called
    **Player**, and the other will be **GameLevelScene**. Unsure how to add these?
    No problem! Simply click **File** | **New** | **File** or press *Command* + *N*.
    For these files, we will select the `Cocoa Class` file and click **Next**, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a SpriteKit project in Xcode](img/B03553_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again fill out the name of the **Class**, and again one will be **Player** and
    the other **GameLevelScene**. I know setting things up is a little boring, but
    we have to do it. Now, on to editing our code!
  prefs: []
  type: TYPE_NORMAL
- en: Editing our code files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to start making a few changes to our source code files. We will start
    with the `ViewController` interface set of files, the `.h` and `.m` files, that
    is—the files that control a defined view. We will start with the `.h` file; at
    the moment, it should read like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We need to add `#import<SpriteKit/SpriteKit.h>` directly below the line `#import
    <UIKit/UIkit.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**WHAT?!**'
  prefs: []
  type: TYPE_NORMAL
- en: This line we just inserted into our code imports the SpriteKit framework into
    that header file so that we can access the features of SpriteKit in the header
    we are working on.
  prefs: []
  type: TYPE_NORMAL
- en: That's all for the `.h` file for the moment; we are going to be bouncing back
    and forth between files as we set our project up.
  prefs: []
  type: TYPE_NORMAL
- en: 'On to the `ViewController.m` file, which should be edited to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'I know what you''re thinking: *What does all this mean?* I''ll start from the
    beginning to make it easy on those who don''t have coding experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Again we have the import line; we import the `ViewController` header file where
    everything will be declared. Next we have the `GameLevelScene` header file; this
    will host the game scenes, where we will spend probably the majority of time in
    this file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With this paragraph of code, we have set up the SpriteKit view. The first line,
    `SKView * skView = (SKView *)self.view;`, declares a new instance of a SpriteKit
    view, named `skView`, and places it in the `ViewController` header file's view,
    hence `self.view`.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines are completely optional as they are more for testing purposes,
    and you will delete them before you release your app. The first line shows the
    frames-per-second count, and the next shows the number of nodes or objects within
    the scene. Feel free to remove these lines now if you don't want to see them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line actually creates and configures the scene. As `SKScene * scene
    = [GameLevelScene scenewithSize: skView.bound.size]` denotes, the data is being
    pulled from the `GameLevelScene` set of files we still have to set up. For now
    it will throw an error saying there is no known class method for selector `sceneWithSize`,
    but don''t worry because we haven''t done any declarations in the `GameLevelScene`
    set of files.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we see the scaling for the scene which is set to `AspectFill`. You
    can select either aspect fit or stretch, but for this example we will use aspect
    fill. You can change it if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we present the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s bounce on over to the `GameLevelScene` files. We will again start with
    the header file, which should read like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply, we have changed the `GameLevelScene` class to a `SpriteKit` scene;
    so now, when we go to build our project, the previously mentioned error will disappear.
    On to the `.m` file, which will read like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is a simple initializing of the scene and setting the size. Now
    let's build our project! You don't have to have a device plugged in at the moment;
    we will run on the simulator. If you're running an older computer, I suggest selecting
    the iPhone 4S for the simulator, as shown in the following screenshot, mainly
    because it takes less time to load and the screen size is small enough to fit
    nicely on your screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing our code files](img/B03553_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simply click on the button shown in the previous screenshot (the one beside
    the play and stop button), and select whatever device you like for the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's build the project. Click on the **Play** button at the top, or press
    *cmd* + *B* (or *cmd* + *R* to build and run the project).
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, it should build successfully and the iOS simulator should
    appear. Uh oh! Did you get an error that looks like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We also need to make changes to the `UIViewController` header file in the Storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand bar of our project, locate the `Main.storyboard` file (remember
    we discussed the storyboard and `.xib` files earlier?), and click on it. We can
    arrange the UI of the apps in this file, but we probably won't use it in this
    project. Now you will see a blank iOS layout, ripe for changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we are going to do here is launch the **ViewController Scene** rollout
    on the sidebar, just next to the bar where all our project files are, then roll
    out the **View Controller** rollout, and click on **View**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing our code files](img/B03553_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now look over to the bar on the far right, and you will see the top bar has
    six different buttons. Click the third one, in which you see **Show the Identity
    Inspector**. Now you will see a section right below the buttons called **Custom
    Class**. In the **Class** text field in this section, we are going to type in
    **SKView**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing our code files](img/B03553_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's try running our project yet again. Does it build successfully? Good! Does
    it open the iOS simulator? Awesome! Does it show a blank device with the frame
    rate and zero nodes printed on the bottom of the screen? Amazing! We are right
    on track!
  prefs: []
  type: TYPE_NORMAL
- en: 'For our final changes, we are going to quickly edit the `Player` set of files.
    At this moment, all we have to do is edit the header file. Change it so it reads
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are now going to work on "pause for effect."
  prefs: []
  type: TYPE_NORMAL
- en: Level design and implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where we can have a lot of fun! We are now going to start designing
    our levels. You can spend hours adding the little details to each level to make
    them look perfect. Remember, a well-designed level will impress players and will
    give your game a professional look.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Xcode just doesn't have the drag-and-drop ease of level design,
    so we are going to create our maps using a third-party program called *Tiled Map
    Editor*, which can be downloaded for free at [www.mapeditor.org](http://www.mapeditor.org).
  prefs: []
  type: TYPE_NORMAL
- en: I have included a sprite sheet for our levels as well as a built level in the
    *Resources* section of this book. Do you remember the `JSTileMap` library that
    was included as well in this chapter? It's what is going to display these maps
    as SpriteKit doesn't support TMXTileMaps. So sad!
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, moving on! Open up the level I have included, entitled `level1.tmx`,
    and get a feel for how the program works.
  prefs: []
  type: TYPE_NORMAL
- en: The side bar of Tiled shows you the different layers of the levels. In this
    case, we have **hazards**, which are things like spikes and other objects that
    could prove detrimental to our player's health. Then we have **walls**, fairly
    self-explanatory, and then **background**, for scene elements such as clouds and
    trees.
  prefs: []
  type: TYPE_NORMAL
- en: '![Level design and implementation](img/B03553_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try making some edits to the level, and make it your own little masterpiece.
    The following screenshot shows all the tools you need; the selected tool in the
    image is the stamp tool, which allows you to place the selected image in the scene
    on the selected layer. Then you have the Paint Bucket and Eraser tools. Give it
    a try! When you're done, we are going to program the level into our game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Level design and implementation](img/B03553_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's open up our `GameLevelScene.m` file and add `#import "JSTileMap.h"` at
    the top of the file, under `#import "GameLevelScene.h"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Directly under the import we just inserted, we are going to add in the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is adding a private variable for the map we will be using into our `GameLevelScene`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to actually load the map. In the `(id)initWithSize:(CGSize)size`
    block of code, inside the `if` statement, add in the following code to change
    the color of the sky, as well as load the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the project to see your awesome level is now in place on the screen. I decided
    to use a dark purple color for these levels because it's the environment I'm going
    for. You can go in for whatever you like, but remember to just adjust the colors
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If for some reason it''s not showing up correctly or you are getting an error,
    make sure your `GameLevelScene.m` file now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Looks pretty cool eh? Tiled is a great program, and you can add a whole lot
    more detail then I did here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Level design and implementation](img/B03553_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Something's missing, though, isn't it? Hmm... Oh yes! Our player!
  prefs: []
  type: TYPE_NORMAL
- en: Gravity – player movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, import the `Player` images (in the `sprites.atlas` file) I have provided
    in the resources section of this book. Unless you have your own! Then by all means
    use yours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `GameLevelScene.m` file and import yet another file.
    This time, it will be `#import "Player.h"`. Then, after the `@interface` section
    that we added earlier, we are going to add another property similar to the map
    property we just added: `@property (nonatomic, strong) Player *player1`. I used
    player1 because we will be adding in some multiplayer features later!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then again, inside the `initWithSize` function we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we build and run our project, we should get similar results as seen in
    the following image. I think it's starting to look pretty cool!
  prefs: []
  type: TYPE_NORMAL
- en: '![Gravity – player movement](img/B03553_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hold on cowboy! What did we just do? Well let me explain what happened. The
    code we just added loaded our little space man as a sprite object, positioned
    him on the map, and then added him to the map object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's something to keep in mind, as you may be wondering why our little guy
    is added to the map, instead of adding him directly to the scene. Well, let me
    tell you! It's all about control. I like to be in full control (and my wife says
    I can tell people that), and we want to control exactly which layers from our
    map are in front of and behind our little guy. So for example we can set the background
    objects, such as the trees and hills, to be way in the back, but if we want to
    we can position our space dude to be behind them. So then he needs to be a subobject,
    or a child, of the map class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make this guy move! First off, let''s add some gravity into
    the scene. Back in our `GameLevelScene.m` file, we are again going to add another
    property in the same location we''ve been adding them, in the `Interface` section
    of our code. It will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot to ensure your code is filled out correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gravity – player movement](img/B03553_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this we are going to code in an `update` method, which we will place
    just before the `-(id)initWithSize:(CGSize)size {` line of code. To create this
    method, we will add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will throw an error at the moment, saying there is no visible `@interface`
    for a player that declares the update selector. Confusing, right? Let's take it
    one step at a time and explain what we just did here.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we added in this update method, which is automatically built into a
    SpriteKit scene, or `SKScene` object. All we have to do is code it in! Then every
    frame that we call before the scene will be rendered accordingly. The update method
    provides us with a timer value, or the `NSTimerInterval` value, that is the current
    time of our program.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we get the `delta` value, which is the current time, subtracted by
    the previous time. What's the `delta` value? It's essentially the interval since
    the previous time the update was called. With this `delta` time value, we can
    create movement, gravity, and other forces with a neat and smooth motion, as well
    as smooth animations.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have an `if` statement; if the `delta` value goes above 0.02, it is
    kept at 0.02\. Sometimes our devices lag, stutter, or slow down, and especially
    when first booting the game up, the device has a lot to load; thus, this `delta`
    value could be quite large. We keep it at a consistent value to reduce the chances
    of the physics acting weird. Why would this happen?
  prefs: []
  type: TYPE_NORMAL
- en: Like I mentioned before, this `delta` value creates smooth movement and gravity
    by keeping a neat consistent value. If that value goes way over 0.02, the movement
    or any external forces we program won't work correctly and bad things could occur
    that we don't want happening. Call it preventative measures so we don't create
    any game-breaking bugs. After the `if` statement, we then set the current time
    (which for example could be 0.02), as the previous time so the device can determine
    the `delta` value. Let's clarify, in order to determine how quickly the time is
    advancing, we have the current time, and previous time, so before the time advances
    we set the current time as the previous time, and then the current time advances.
  prefs: []
  type: TYPE_NORMAL
- en: Broken down, the clock begins to count, the current time is 0.05, before the
    time advances we will set the previous time variable to 0.05, then the current
    time will increase to 0.06\. The device will then calculate the delta value. Make
    sense? I know it's a lot to take in.
  prefs: []
  type: TYPE_NORMAL
- en: Then we come to the line of code that causes the error. It's calling the error
    because we haven't implemented the `update` method in our `Player` set of files
    (or class). Let's do that now!
  prefs: []
  type: TYPE_NORMAL
- en: 'Go in to our `Player.h` file, and change the code so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Whoa, whoa buddy, this doesn't make sense! When programming a game, there's
    a lot of physics and math that goes into the coding. In the `@property (nonatomic,
    assign) CGPoint velocity;` line, we are creating a property that will measure
    how fast the player is moving.
  prefs: []
  type: TYPE_NORMAL
- en: What's a **CGPoint**, you ask? **CG** stands for **CoreGraphics** which is the
    main graphic rendering framework used by iOS devices, and **point** is a point
    on the screen, so `CGPoint` holds the positional value of an object; in this case
    the `velocity` will now have an `x` and `y` value, allowing us to calculate the
    exact speed the player is moving at and the exact direction they are moving in.
    Fun!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s hop on over to the `Player.m` class file and change the code to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's break down what we just did here. I know things can be confusing, but
    don't worry! I'm here to help you!
  prefs: []
  type: TYPE_NORMAL
- en: First, we imported the `SKUtils` framework into the `Player` class. After that,
    we created a new `initWithImageNamed` method and initialized the velocity variable
    to `0.0`. Then we declared the value of the gravity force. Each time the update
    method runs, we are increasing the velocity of the player 450 points downward.
    If the player starts out by standing still, after one second he'll be moving at
    450 pixels per second, at two seconds that value will be doubled, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds easy.... right?
  prefs: []
  type: TYPE_NORMAL
- en: Next, we used `CGPointMulitplyScalar` to decrease the acceleration down to the
    size of the current time step. Remember, `CGPointMulitplyScalar` increases the
    `CGPoint` values by a float value, and returns the `CGPoint` result. This is great
    because, when the device lags or for some odd reason we see a drop in frame rate,
    we will still get a consistent acceleration value.
  prefs: []
  type: TYPE_NORMAL
- en: In the `self.velocity =... block`, we calculate the gravity for the current
    time and then add it to the player's current velocity. With the new velocity calculated,
    we get the velocity for a single time step.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with the velocity all calculated, we use the `CGPointAdd` function
    to change the position of the player. As you can see, `CGPointAdd` is equal to
    the player's current position, with the gravity added.
  prefs: []
  type: TYPE_NORMAL
- en: OK! Let's run our project!
  prefs: []
  type: TYPE_NORMAL
- en: '![Gravity – player movement](img/B03553_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What? He's falling through the ground? Hmm, I guess that means we need to detect
    collisions now?
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know that collision detection is imperative to any game. Regardless of
    whether it's a hockey game, or Call of Angry eight year olds, the game needs to
    detect collisions of hockey pucks, bullets, swords, feet on the ground—you name
    it and there are a ton of collisions that need to be detected. For our game, we
    are only going to detect simple boxes colliding with each other between the player
    and enemies, the platforms, and the bullets colliding with enemies.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to make things super easy; first we are going to detect the player's
    bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What's a bounding box? Simple! Think of when you're creating your sprites; there's
    a box surrounding your image? You could think of a collision bounding box like
    that, the small box that your sprite fits in or within a defined space. You can
    (and we will) adjust the size of the bounding box to fit the sprite; you can have
    it larger or smaller depending on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that all explained, let''s hop into our `Player.h` file and add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We just created a core-graphics rectangle named `collisionBox`. Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code into `Player.m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The value of `CGRectInset` decreases the size of the rectangle, or our collision
    box, by the last two bracketed numbers, `2` and `0` respectively. We set the player's
    frame as the base size, and then shrink it by `two` pixels on each side of the
    player. If you want, you don't have to shrink the bounding box, you can leave
    the two values at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now things will start to get a little more complicated. We need to detect the
    various images in our level and select which one we want our player to collide
    with and those that we don''t. Let''s shoot on over to our `GameLevelScene.m`
    class and add in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This first block locates the pixel origin coordinate; we do this so we know
    exactly where to place the map in the scene. We need to flip the height coordinate
    because SpriteKit''s origin is in the bottom-left corner of the screen but the
    tile map''s origin is at the top left. In order to detect the origin, we need
    to add in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next we add `1` to the tile coordinate. Why do we do this? Actually, the tile
    coordinate system starts at `0`, so if we have 50 tiles, the 50th tile's actual
    coordinate will be 49\. So we need to add one to get the right value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This next method accesses our saved map''s layer info that is saved in *Tiled
    Map Editor*. Remember we had three layers: Background, walls, and hazards? If
    you want to have more than three layers, absolutely feel free to do so. I am only
    doing three in this example because we are going to add in our enemies and some
    special effects programmatically. This block of code will access those layers.'
  prefs: []
  type: TYPE_NORMAL
- en: For our collision system, we are going to detect the surrounding eight tiles
    of our player. In the following blocks of code, we are going to detect the surrounding
    tiles, which will inspect the `CGRect` (or Core-Graphics rectangles) for a collision
    with the player's collision bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `GameLevelScene.m` file and add in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Wow! So much code! Let's break it down. The first block creates an array that
    shows the position of the tiles surrounding our cool little player dude. As you
    can see, we find the eight surrounding tiles and then we store those values in
    the `tileIndex` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, remember what I said about the tile coordinates being flipped? Notice the
    order of tiles? `7`, `1`, `3`, `5`, `0`, `2`, `6`, `8`. Tile 7 is the tile that
    is directly below our player, so it needs to be figured out right away. We need
    to know if he's on the ground or not; if he is, he can jump, but if not, no jumping!
    If we don't resolve this tile immediately, the player could potentially jump without
    the character touching the ground—if they pressed the jump button quickly enough.
  prefs: []
  type: TYPE_NORMAL
- en: Then we retrieved the player's collision box that we coded earlier and found
    the exact tile location of the player. We did this so we could then locate the
    surrounding tiles of our player. After we located the position of the player,
    we then divided the `tileIndex` variable we created earlier to find the row and
    column values around the player.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's break this down into an example.
  prefs: []
  type: TYPE_NORMAL
- en: Say the value of `tileIndex` is `3`; the value of `tileColumn` would be `0`
    (3 % 3 = 0) and the value of `tileRow` would be `1` (3 / 3 = 1).
  prefs: []
  type: TYPE_NORMAL
- en: If our space guy's position was found to be at tile coordinate (`50`, `10)`,
    the surrounding tile at `tileIndex 3` would be 50 + (0 – 1) and 10 + (1 – 1) or
    `49` and `10`, respectively. This equals the tile directly to the left of our
    space man's tile position.
  prefs: []
  type: TYPE_NORMAL
- en: I know that this can be a little confusing, but don't worry; you'll start to
    get it soon!
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we look up the GID value for the tile at the coordinate found
    in the previous instance of `tileIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: Woah, halt! What in the wide, wide world of sports is a GID?
  prefs: []
  type: TYPE_NORMAL
- en: A **GID** is the number that represents the index of an image from a tile set.
    Each `TMXLayer` class has a tile set that has images arranged in a grid. Simply
    put, the GID is the position of a particular image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we figure if the GID has a value of `0`. There is no tile. It''s just
    blank space, so we don''t resolve or test a collision. However, if there is a
    value in the GID, we get the `CGRect` position for that tile. Then we simply log
    the results. This is not a required block of code, but it is very helpful when
    things aren''t working properly—you can look at the debugger to see what''s going
    on. The following figure shows you how tiles are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision detection](img/B03553_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The big bold numbers represent the order in which tile collisions are handled,
    bottom first, top second, left-hand side third, and right-hand side fourth, then
    the corners. The smaller numbers represent the order in which those tiles are
    stored in the `tileIndex` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we are going to go back into our `GameLevelScene.m` file, and add in the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you were to run the project now, it would just crash into the oblivion of
    **SIGABRT** (**signal abort**). SIGABRT signifies that, though an error wasn't
    shown within your code, your app failed when it attempted to run a section of
    code. You will be able to see what's going on and why it happened in the console
    log. We are going to further discuss debugging later in this book. We need to
    do a little more work.
  prefs: []
  type: TYPE_NORMAL
- en: When our `Player` class updates its position and the `GameLevelScene` class
    detects a collision, we will want the player to stop. So we need to create a new
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: This variable will allow the `Player` class to do all its positioning calculations,
    and the `GameLevelScene` class will update the position after the collisions have
    been detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go on over to our `Player.h` file and add this new property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to make changes to our `collisionBox` method in the `Player.m`
    file, which should now read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This creates a collision bounding box based on the desired position. The layer
    will now use this for collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s scroll down to our `update` method and locate this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now this will update our `desiredPosition` property instead of the actual position
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Back in our `GameLevelScene.m` file, look for our `-(void)checkForAndResolveCollisionsForPlayer:(Player
    *)player forLayer:(TMXLayer *)layer` method. We wrote `CGPoint playerCoord = [layer
    coordForPoint:player.position]`; we have to change this from `player.position`
    to `player.desiredPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back into our `checkForAndResolveCollisionsForPlayer` method, after the commented
    out text `//after this is where we write our collision resolving`, we need to
    add in our collision resolution code. So that there''s no confusion, the `checkForAndResolveCollisionsForPlayer`
    method should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What did we just do?
  prefs: []
  type: TYPE_NORMAL
- en: We used the `CGRectIntersectsRect` method to see if the player and the tile
    rectangles collide. We then used our `tileIndex` to determine the exact position
    of that tile and checked to see if it's a vertical or a horizontal collision.
    We also created a variable to determine the distance required to move our player
    so he no longer collides with the tile. Then, we checked to see if our player
    needs to be moved up or down. When that is determined, we either add or subtract
    the collision height from our player.
  prefs: []
  type: TYPE_NORMAL
- en: We also set up Booleans (true or false statements) that will detect whether
    the player is colliding with the ground; if he is, make him stop, and set the
    `onGround` Boolean to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we set the position of our player to finally resolve the collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our `Player.h` file, we need to add the `onGround` Boolean property.
    With all our other properties, add in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our little man working properly, we are going to get to programming
    his movement! Let's get him dancing! (I won't actually be programming him to dance;
    however, if that is something you want to do, absolutely be my guest. I won't
    judge.)
  prefs: []
  type: TYPE_NORMAL
- en: Making our player dance!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this game, we are going to make the controls super easy. Touch the right
    side of the screen, and the player will move forward; touch the left side, and
    he will jump. You can use the same methods to have him moving forwards and backwards,
    but this is how we will do it for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Player.h` file, add the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Popping over to our `GameLevelScene.m` file, we are going to add the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty simple set of methods. We set up the two touch areas on the
    device's screen, each half of the width of the screen. Once one is touched, it
    fires the respective Boolean for either walking or jumping, which we will then
    detect if the Booleans have been fired in our `Player` class. Easy? Yup!
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a small line of code up in our `(id)initWithSize` block of code
    so that we can enable touch controls in our app. Add this line anywhere in that
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This line just gives us the ability to detect user interaction. If we were to
    run our app right now and touch the sides of the screen, our player would do absolutely
    nothing. Because he's a rebel? Not really. We have only set up the touches; we
    haven't told him what to do when he receives those touches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump on over to our `Player.m` class and edit the `update` method so
    we can get him moving. The update method should look like this, with the highlighted
    code being the new lines we add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Seem easy enough? No? Ok, let's explain things a little more. First we added
    a moving forward "force" that will be added when the user touches the screen,
    which is being added at 750 points per second in relation to the delta frame step
    for smooth motion. Mmmm, smoooooth!
  prefs: []
  type: TYPE_NORMAL
- en: Next we controlled the moving forward force to imitate the friction of the ground
    so that, when the player stops moving, he glides briefly instead of coming to
    an immediate halt.
  prefs: []
  type: TYPE_NORMAL
- en: Next we checked if the screen is being touched, and if so we add velocity!
  prefs: []
  type: TYPE_NORMAL
- en: Then came the clamping. Clamping? Think of when you clamp a piece of wood to
    a work bench, that thing isn't moving. It's the same with the clamp methods; we
    are "clamping" or limiting the player's maximum and minimum horizontal and vertical
    speeds. The player will not move outside those limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall now add in the jumping method. Back in our `update` block of code,
    just above the `if (self.walking)` statement, we are going to add the following
    code to make our player jump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This jumping system is similar to that of *Super Mario* where, if you press
    and hold the jump button, he will accelerate to a certain point, at which juncture
    the `jumpTime` function then stops him from further accelerating. However, if
    the player stops pressing the jump button before the jump reaches the `jumpTime`
    function cut off, the jump will be reduced.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making our player dance!](img/B03553_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'See that? You''re on your way to creating the next *Super Mario*! If you run
    your project and click on the sides of the screen, he will move around and jump!
    But you know what, I don''t like the fact that our player can only move forward.
    What if he gets stuck? (Like in my level, he can get stuck almost immediately.
    Oops!) So let''s go back to our `Player.h` class and add another property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then on over to our `GameLevelScene.m` file, where we make a slight change
    to our `touchesBegan` function and the `TouchesMoved` block of code that we added
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, instead of having the screen halved with one walking button and one
    jumping button, we have the screen split into three, with the walking button as
    one half of the screen, and that half has been split height-wise, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making our player dance!](img/B03553_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s pop over to our `Player.m` file and make some very small adjustments
    to our `update` method. We are going to add in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines are a reverse of the walking forward method we created, hence the
    -750 value. Now under our `if (self.walking)` method, we are going to add the
    following `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This again is just a reverse of the walking forward movement. Test it out to
    see if it's working; if so, he should be backtracking on his steps like a scared
    cat!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to get the screen scrolling as our player moves towards the
    edge of the screen. On to our `GameLevelScene.m` class, to which we add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This block constrains the position of the screen to the player when he reaches
    the center of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Test it to see if it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Making our player dance!](img/B03553_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is starting to look so good! But if you've noticed, he can't die. Sadly,
    we do want him to die when he hits spikes or falls down those scary pits, don't
    we?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s integrate the hazards layer in our TMX map. To do this, we have to go
    to our `GameLevelScene.m` file and add in the following detection method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is essentially the same code that we used for our `checkForAndResolveCollisionsForPlayer`
    function. We only added a `gameOver` method whereby, when it equals `0`, the player
    dies, and when it's `1`, the player beats the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will have errors showing at the moment. We haven''t incorporated our game
    over feature yet, so let''s do that now. Again in our `GameLevelScene.m` file,
    let''s add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's break it down as we usually do. Firstly, we set up the new game over the
    Boolean, which we use whenever the player collides with a hazard, or later an
    enemy.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we set a level win and a level failed string (or text) to pop up
    whenever the player either beats the level or loses. I used *Avenir Next Heavy*
    as a font. There are a ton of fonts that you can use for your game. For an awesome
    site showing all the fonts you can use, check out [iosfonts.com](http://iosfonts.com).
  prefs: []
  type: TYPE_NORMAL
- en: We then created a `UIButton` the user will be able to tap to restart the level.
    (Don't forget to add in the `replay.png` and `replay@2x.png` image files that
    I supplied in the resources section of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally we added in the method that checks the player's position; if he is below
    the map—in other words, if he's fallen down a hole or crack in the map—we call
    game over.
  prefs: []
  type: TYPE_NORMAL
- en: But our poor little guy isn't going to experience just death! He needs to win
    every once and a while, right? Well we need to add those methods as well! Don't
    worry, it's super easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `GameLevelScene.m` file, we need to add a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a positionally based win, so once our player reaches the `x` value
    of `3200` on the map we will call a win. We can have a win layer on the TMX map
    and incorporate that layer, but this just seems easier! Finally, in the `handleHazardCollisions`
    section, we need to check if our little guy has won:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We now test this to see if it works and you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making our player dance!](img/B03553_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we fail a level, we land on spikes, ouch! But we reach the end of the
    level, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making our player dance!](img/B03553_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oh my goodness! It's starting to look great, isn't it? We've done a lot of work
    in this chapter! What with our level design, figuring a way around implementing
    our maps into our project, creating our little player, and making him move, collide,
    and jump around, we certainly have done a lot.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's go take a break! In the next chapter, we are going to do some
    more creation, such as adding awesome music and sound effects, to polish the game
    up a bit, and maybe add some menus, particle effects, and even some enemies!
  prefs: []
  type: TYPE_NORMAL
- en: Go get yourself a nice strong <insert beverage of choice here>, and I'll see
    you in the next chapter!
  prefs: []
  type: TYPE_NORMAL
