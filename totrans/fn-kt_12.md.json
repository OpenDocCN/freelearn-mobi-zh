["```kt\nimport arrow.syntax.function.andThen\nimport arrow.syntax.function.compose\nimport arrow.syntax.function.forwardCompose\nimport java.util.*\n\nval p: (String) -> String = { body -> \"<p>$body</p>\" }\n\nval span: (String) -> String = { body -> \"<span>$body</span>\" }\n\nval div: (String) -> String = { body -> \"<div>$body</div>\" }\n\nval randomNames: () -> String = {\n    if (Random().nextInt() % 2 == 0) {\n        \"foo\"\n    } else {\n        \"bar\"\n    }\n}\n\nfun main(args: Array<String>) {\n    val divStrong: (String) -> String = div compose strong\n\n    val spanP: (String) -> String = p forwardCompose span\n\n    val randomStrong: () -> String = randomNames andThen strong\n\n    println(divStrong(\"Hello composition world!\"))\n    println(spanP(\"Hello composition world!\"))\n    println(randomStrong())\n}\n```", "```kt\nval divStrong: (String) -> String = { body -> \"<div><strong>$body</div></strong>\"}\n```", "```kt\nval spanP: (String) -> String = { body -> \"<span><p>$body</p></span>\"}\n```", "```kt\ndata class Quote(val value: Double, val client: String, val item: String, val quantity: Int)\n\ndata class Bill(val value: Double, val client: String)\n\ndata class PickingOrder(val item: String, val quantity: Int)\n\nfun calculatePrice(quote: Quote) = Bill(quote.value * quote.quantity, quote.client) to PickingOrder(quote.item, quote.quantity)\n\nfun filterBills(billAndOrder: Pair<Bill, PickingOrder>): Pair<Bill, PickingOrder>? {\n   val (bill, _) = billAndOrder\n   return if (bill.value >= 100) {\n      billAndOrder\n   } else {\n      null\n   }\n}\n\nfun warehouse(order: PickingOrder) {\n   println(\"Processing order = $order\")\n}\n\nfun accounting(bill: Bill) {\n   println(\"processing = $bill\")\n}\n\nfun splitter(billAndOrder: Pair<Bill, PickingOrder>?) {\n   if (billAndOrder != null) {\n      warehouse(billAndOrder.second)\n      accounting(billAndOrder.first)\n   }\n}\n\nfun main(args: Array<String>) {\n   val salesSystem:(Quote) -> Unit = ::calculatePrice andThen ::filterBills forwardCompose ::splitter\n   salesSystem(Quote(20.0, \"Foo\", \"Shoes\", 1))\n   salesSystem(Quote(20.0, \"Bar\", \"Shoes\", 200))\n   salesSystem(Quote(2000.0, \"Foo\", \"Motorbike\", 1))\n}\n\n```", "```kt\npackage com.packtpub.functionalkotlin.chapter11\n\nimport arrow.syntax.function.invoke\nimport arrow.syntax.function.partially3\n\nfun main(args: Array<String>) {\n   val strong: (String, String, String) -> String = { body, id, style -> \"<strong id=\\\"$id\\\" style=\\\"$style\\\">$body</strong>\" }\n\n   val redStrong: (String, String) -> String = strong.partially3(\"font: red\") //Explicit\n\n   val blueStrong: (String, String) -> String = strong(p3 = \"font: blue\") //Implicit\n\n   println(redStrong(\"Red Sonja\", \"movie1\"))\n   println(blueStrong(\"Deep Blue Sea\", \"movie2\"))\n}\n```", "```kt\nfun partialSplitter(billAndOrder: Pair<Bill, PickingOrder>?, warehouse: (PickingOrder) -> Unit, accounting: (Bill) -> Unit) {\n   if (billAndOrder != null) {\n      warehouse(billAndOrder.second)\n      accounting(billAndOrder.first)\n   }\n}\n\nfun main(args: Array<String>) {\n   val splitter: (billAndOrder: Pair<Bill, PickingOrder>?) -> Unit = ::partialSplitter.partially2 { order -> println(\"TESTING $order\") }(p2 = ::accounting)\n\n   val salesSystem: (quote: Quote) -> Unit = ::calculatePrice andThen ::filterBills forwardCompose splitter\n   salesSystem(Quote(20.0, \"Foo\", \"Shoes\", 1))\n   salesSystem(Quote(20.0, \"Bar\", \"Shoes\", 200))\n   salesSystem(Quote(2000.0, \"Foo\", \"Motorbike\", 1))\n}\n```", "```kt\nfun main(args: Array<String>) {\n\n   val footer:(String) -> String = {content -> \"<footer&gt;$content</footer>\"}\n   val fixFooter: () -> String = footer.bind(\"Functional Kotlin - 2018\") //alias for partially1\n   println(fixFooter())\n}\n```", "```kt\nimport arrow.syntax.function.partially3\nimport arrow.syntax.function.reverse\n\nfun main(args: Array<String>) {\n   val strong: (String, String, String) -> String = { body, id, style -> \"<strong id=\\\"$id\\\" style=\\\"$style\\\">$body</strong>\" }\n\n   val redStrong: (String, String) -> String = strong.partially3(\"font: red\") //Explicit\n\n   println(redStrong(\"Red Sonja\", \"movie1\"))\n\n   println(redStrong.reverse()(\"movie2\", \"The Hunt for Red October\"))\n\n}\n```", "```kt\nimport arrow.syntax.function.pipe\n\nfun main(args: Array<String>) {\n    val strong: (String) -> String = { body -> \"<strong>$body</strong>\" }\n\n   \"From a pipe\".pipe(strong).pipe(::println)\n}\n```", "```kt\nfun main(args: Array<String>) {\n   splitter(filterBills(calculatePrice(Quote(20.0, \"Foo\", \"Shoes\", 1)))) //Nested\n\n   Quote(20.0, \"Foo\", \"Shoes\", 1) pipe ::calculatePrice pipe ::filterBills pipe ::splitter //Pipe\n}\n```", "```kt\nimport arrow.syntax.function.pipe\nimport arrow.syntax.function.pipe3\nimport arrow.syntax.function.reverse\n\nfun main(args: Array<String>) {\n   val strong: (String, String, String) -> String = { body, id, style -> \"<strong id=\\\"$id\\\" style=\\\"$style\\\">$body</strong>\" }\n\n   val redStrong: (String, String) -> String = \"color: red\" pipe3 strong.reverse()\n\n   redStrong(\"movie3\", \"Three colors: Red\") pipe ::println\n}\n```", "```kt\nimport arrow.syntax.function.curried\nimport arrow.syntax.function.pipe\nimport arrow.syntax.function.reverse\nimport arrow.syntax.function.uncurried\n\nfun main(args: Array<String>) {\n\n   val strong: (String, String, String) -> String = { body, id, style -> \"<strong id=\\\"$id\\\" style=\\\"$style\\\">$body</strong>\" }\n\n   val curriedStrong: (style: String) -> (id: String) -> (body: String) -> String = strong.reverse().curried()\n\n   val greenStrong: (id: String) -> (body: String) -> String = curriedStrong(\"color:green\")\n\n   val uncurriedGreenStrong: (id: String, body: String) -> String = greenStrong.uncurried()\n\n   println(greenStrong(\"movie5\")(\"Green Inferno\"))\n\n   println(uncurriedGreenStrong(\"movie6\", \"Green Hornet\"))\n\n   \"Fried Green Tomatoes\" pipe (\"movie7\" pipe greenStrong) pipe ::println\n}\n```", "```kt\nimport arrow.syntax.function.curried\nimport arrow.syntax.function.invoke\n\nfun main(args: Array<String>) {\n   val strong: (String, String, String) -> String = { body, id, style -> \"<strong id=\\\"$id\\\" style=\\\"$style\\\">$body</strong>\" }\n\n   println(strong.curried()(\"Batman Begins\")(\"trilogy1\")(\"color:black\")) // Curried\n\n   println(strong(\"The Dark Knight\")(\"trilogy2\")(\"color:black\")) // Fake curried, just partial application\n\n   println(strong(p2 = \"trilogy3\")(p2 = \"color:black\")(\"The Dark Knight rises\")) // partial application   \n}\n```", "```kt\nimport arrow.core.Predicate\nimport arrow.syntax.function.complement\n\nfun main(args: Array<String>) {\n   val evenPredicate: Predicate<Int> = { i: Int -> i % 2 == 0 }\n   val oddPredicate: (Int) -> Boolean = evenPredicate.complement()\n\n   val numbers: IntRange = 1..10\n   val evenNumbers: List<Int> = numbers.filter(evenPredicate)\n   val oddNumbers: List<Int> = numbers.filter(oddPredicate)\n\n   println(evenNumbers)\n   println(oddNumbers)\n}\n```", "```kt\nimport arrow.syntax.function.memoize\nimport kotlin.system.measureNanoTime\n\nfun recursiveFib(n: Long): Long = if (n < 2) {\n   n\n} else {\n   recursiveFib(n - 1) + recursiveFib(n - 2)\n}\n\nfun imperativeFib(n: Long): Long {\n   return when (n) {\n      0L -> 0\n      1L -> 1\n      else -> {\n         var a = 0L\n         var b = 1L\n         var c = 0L\n         for (i in 2..n) {\n            c = a + b\n            a = b\n            b = c\n         }\n         c\n      }\n   }\n}\n\nfun main(args: Array<String>) {\n\n   var lambdaFib: (Long) -> Long = { it } //Declared ahead to be used inside recursively\n\n   lambdaFib = { n: Long ->\n      if (n < 2) n else lambdaFib(n - 1) + lambdaFib(n - 2)\n   }\n\n   var memoizedFib: (Long) -> Long = { it }\n\n   memoizedFib = { n: Long ->\n      if (n < 2) n else memoizedFib(n - 1) + memoizedFib(n - 2)\n   }.memoize()\n\n   println(milliseconds(\"imperative fib\") { imperativeFib(40) }) //0.006\n\n   println(milliseconds(\"recursive fib\") { recursiveFib(40) }) //1143.167\n   println(milliseconds(\"lambda fib\") { lambdaFib(40) }) //4324.890\n   println(milliseconds(\"memoized fib\") { memoizedFib(40) }) //1.588\n}\n\ninline fun milliseconds(description: String, body: () -> Unit): String {\n   return \"$description:${measureNanoTime(body) / 1_000_000.00} ms\"\n}\n```", "```kt\nfun main(args: Array<String>) = runBlocking {\n\n   var lambdaFib: (Long) -> Long = { it } //Declared ahead to be used inside recursively\n\n   lambdaFib = { n: Long ->\n      if (n < 2) n else lambdaFib(n - 1) + lambdaFib(n - 2)\n   }\n\n   var memoizedFib: (Long) -> Long = { it }\n\n   memoizedFib = { n: Long ->\n      println(\"from memoized fib n = $n\")\n      if (n < 2) n else memoizedFib(n - 1) + memoizedFib(n - 2)\n   }.memoize()\n   val job = launch {\n      repeat(10) { i ->\n         launch(coroutineContext) { println(milliseconds(\"On coroutine $i - imperative fib\") { imperativeFib(40) }) }\n         launch(coroutineContext) { println(milliseconds(\"On coroutine $i - recursive fib\") { recursiveFib(40) }) }\n         launch(coroutineContext) { println(milliseconds(\"On coroutine $i - lambda fib\") { lambdaFib(40) }) }\n         launch(coroutineContext) { println(milliseconds(\"On coroutine $i - memoized fib\") { memoizedFib(40) }) }\n      }\n   }\n\n   job.join()\n\n}\n```", "```kt\nfun main(args: Array<String>) {\n   val upper: (String?) -> String = { s:String? -> s!!.toUpperCase()} //Partial function, it can't transform null\n\n   listOf(\"one\", \"two\", null, \"four\").map(upper).forEach(::println) //NPE\n}\n```", "```kt\nimport arrow.core.PartialFunction\n\nfun main(args: Array<String>) {\n val upper: (String?) -> String = { s: String? -> s!!.toUpperCase() } //Partial function, it can't transform null\n\n val partialUpper: PartialFunction<String?, String> = PartialFunction(definetAt = { s -> s != null }, f = upper)\n\n listOf(\"one\", \"two\", null, \"four\").map(partialUpper).forEach(::println) //IAE: Value: (null) isn't supported by this function \n}\n```", "```kt\nfun main(args: Array<String>) {\n\n   val upper: (String?) -> String = { s: String? -> s!!.toUpperCase() } //Partial function, it can't transform null\n\n   val partialUpper: PartialFunction<String?, String> = PartialFunction(definetAt = { s -> s != null }, f = upper)\n\n   listOf(\"one\", \"two\", null, \"four\").map{ s -> partialUpper.invokeOrElse(s, \"NULL\")}.forEach(::println)\n}\n```", "```kt\nfun main(args: Array<String>) {\n\n   val upper: (String?) -> String = { s: String? -> s!!.toUpperCase() } //Partial function, it can't transform null\n\n   val partialUpper: PartialFunction<String?, String> = PartialFunction(definetAt = { s -> s != null }, f = upper)\n\n   val upperForNull: PartialFunction<String?, String> = PartialFunction({ s -> s == null }) { \"NULL\" }\n\n   val totalUpper: PartialFunction<String?, String> = partialUpper orElse upperForNull\n\n   listOf(\"one\", \"two\", null, \"four\").map(totalUpper).forEach(::println)\n}\n```", "```kt\nfun main(args: Array<String>) {\n   val fizz = PartialFunction({ n: Int -> n % 3 == 0 }) { \"FIZZ\" }\n   val buzz = PartialFunction({ n: Int -> n % 5 == 0 }) { \"BUZZ\" }\n   val fizzBuzz = PartialFunction({ n: Int -> fizz.isDefinedAt(n) && buzz.isDefinedAt(n) }) { \"FIZZBUZZ\" }\n   val pass = PartialFunction({ true }) { n: Int -> n.toString() }\n\n   (1..50).map(fizzBuzz orElse buzz orElse fizz orElse pass).forEach(::println)\n}\n```", "```kt\nfun main(args: Array<String>) {\n\n   val oneToFour = 1..4\n\n   println(\"With identity: ${oneToFour.map(::identity).joinToString()}\") //1, 2, 3, 4\n\n   println(\"With constant: ${oneToFour.map(constant(1)).joinToString()}\") //1, 1, 1, 1\n\n}\n```", "```kt\nfun main(args: Array<String>) {\n   val fizz = PartialFunction({ n: Int -> n % 3 == 0 }, constant(\"FIZZ\"))\n   val buzz = PartialFunction({ n: Int -> n % 5 == 0 }, constant(\"BUZZ\"))\n   val fizzBuzz = PartialFunction({ n: Int -> fizz.isDefinedAt(n) && buzz.isDefinedAt(n) }, constant(\"FIZZBUZZ\"))\n   val pass = PartialFunction<Int, String>(constant(true)) { n -> n.toString() }\n\n   (1..50).map(fizzBuzz orElse buzz orElse fizz orElse pass).forEach(::println)\n}\n```", "```kt\ntypealias GB = Int\n\ndata class Memory(val size: GB)\ndata class MotherBoard(val brand: String, val memory: Memory)\ndata class Laptop(val price: Double, val motherBoard: MotherBoard)\n\nfun main(args: Array<String>) {\n   val laptopX8 = Laptop(500.0, MotherBoard(\"X\", Memory(8)))\n\n   val laptopX16 = laptopX8.copy(\n         price = 780.0,\n         motherBoard = laptopX8.motherBoard.copy(\n               memory = laptopX8.motherBoard.memory.copy(\n                     size = laptopX8.motherBoard.memory.size * 2\n               )\n         )\n   )\n\n   println(\"laptopX16 = $laptopX16\")\n}\n```", "```kt\nval laptopPrice: Lens<Laptop, Double> = Lens(\n      get = { laptop -> laptop.price },\n      set = { price -> { laptop -> laptop.copy(price = price) } }\n)\n```", "```kt\nimport arrow.optics.Lens\n\nval laptopPrice: Lens<Laptop, Double> = Lens(\n      get = { laptop -> laptop.price },\n      set = { price: Double, laptop: Laptop -> laptop.copy(price = price) }.curried()\n)\n```", "```kt\nimport arrow.optics.modify\n\nval laptopMotherBoard: Lens<Laptop, MotherBoard> = Lens(\n      get = { laptop -> laptop.motherBoard },\n      set = { mb -> { laptop -> laptop.copy(motherBoard = mb) } }\n)\n\nval motherBoardMemory: Lens<MotherBoard, Memory> = Lens(\n      get = { mb -> mb.memory },\n      set = { memory -> { mb -> mb.copy(memory = memory) } }\n)\n\nval memorySize: Lens<Memory, GB> = Lens(\n      get = { memory -> memory.size },\n      set = { size -> { memory -> memory.copy(size = size) } }\n)\n\nfun main(args: Array<String>) {\n   val laptopX8 = Laptop(500.0, MotherBoard(\"X\", Memory(8)))\n\n   val laptopMemorySize: Lens<Laptop, GB> = laptopMotherBoard compose motherBoardMemory compose memorySize\n\n   val laptopX16 = laptopMemorySize.modify(laptopPrice.set(laptopX8, 780.0)) { size ->\n      size * 2\n   }\n\n   println(\"laptopX16 = $laptopX16\")\n}\n```", "```kt\napply plugin: 'idea'\n\nidea {\n    module {\n        sourceDirs += files(\n            'build/generated/source/kapt/main',\n            'build/generated/source/kaptKotlin/main',\n            'build/tmp/kapt/main/kotlinGenerated')\n        generatedSourceDirs += files(\n            'build/generated/source/kapt/main',\n            'build/generated/source/kaptKotlin/main',\n            'build/tmp/kapt/main/kotlinGenerated')\n    }\n}\n```", "```kt\napply plugin: 'kotlin-kapt'\napply from: rootProject.file('gradle/generated-kotlin-sources.gradle')\n```", "```kt\ndependencies {\n    ...\n    kapt    'io.arrow-kt:arrow-annotations-processor:0.5.2'\n    ...     \n}\n```", "```kt\nimport arrow.lenses\nimport arrow.optics.Lens\nimport arrow.optics.modify\n\ntypealias GB = Int\n\n@lenses data class Memory(val size: GB)\n@lenses data class MotherBoard(val brand: String, val memory: Memory)\n@lenses data class Laptop(val price: Double, val motherBoard: MotherBoard)\n\nfun main(args: Array<String>) {\n   val laptopX8 = Laptop(500.0, MotherBoard(\"X\", Memory(8)))\n\n   val laptopMemorySize: Lens<Laptop, GB> = laptopMotherBoard() compose motherBoardMemory() compose memorySize()\n\n   val laptopX16 = laptopMemorySize.modify(laptopPrice().set(laptopX8, 780.0)) { size ->\n      size * 2\n   }\n\n   println(\"laptopX16 = $laptopX16\")\n}\n```"]