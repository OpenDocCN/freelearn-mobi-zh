<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Performance Enhancement and Extras</h1></div></div></div><p>In the previous chapter, we discussed about adding multiple levels in our game; adding multiple levels in a game is a normal functionality in most games. We also added the functionality to show the current level of the game by using a level label. Apart from this, we added a pause button and the button to access the node menu scene from the main menu.</p><p>This chapter is one of the most essential chapters in this book; here we are going to discuss about performance enhancement tips and tricks. Apart from this, we are going to add some really important features in our game. These<a id="id479" class="indexterm"/> features are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The scoring system</li><li class="listitem" style="list-style-type: disc">The sound</li><li class="listitem" style="list-style-type: disc">The running animation of the player</li></ul></div><p>Sound is an essential part of a game; it greatly enhances the overall gameplay experience for the player. The scoring system helps the player to measure his or her performance over time. Running texture produces a good animation effect in the game, which increases the gameplay experience a lot. We are going to add all of these features in this current chapter, along with discussing about some of the important performance enhancement techniques for a Sprite Kit game.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Performance enhancement</h1></div></div></div><p>Running a<a id="id480" class="indexterm"/> game requires extensive usage of memory and other resources of the device. This leads to accelerated drainage of the battery. We need to optimize the usage of the device resources for games. A game requires higher frames per second, hence more battery drainage occurs due to the excessive usage of the device resources. An optimized game will lead to efficient use of the device resources, hence<a id="id481" class="indexterm"/> less battery drainage. Following are listed some of the best practices to optimize the efficiency of a game:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Systemizing a game's content in the scene</li><li class="listitem" style="list-style-type: disc">Improving the drawing performance</li><li class="listitem" style="list-style-type: disc">Improving performance with <code class="literal">SKAction</code> and constraints</li><li class="listitem" style="list-style-type: disc">Improving the physics performance</li><li class="listitem" style="list-style-type: disc">Improving the shapes performance</li><li class="listitem" style="list-style-type: disc">Improving the effects performance</li><li class="listitem" style="list-style-type: disc">Improving the lighting</li></ul></div><p>Now we are going to discuss each of the previously listed methods in detail.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec77"/>Systemizing a game's content in the scene</h2></div></div></div><p>As we know, scenes are the<a id="id482" class="indexterm"/> elementary building blocks in a Sprite Kit game. A game can contain multiple scenes according to the requirements. A scene can contain multiple nodes, where the nodes can perform particular actions. We have a clear idea of how to create scenes, nodes, and actions for nodes. The challenging task is designing the game's scene and transition in such a way that it should not lower the game's performance.</p><p>One thing that should be kept in mind is that the scenes do not have a default behavior, as the storyboards do in traditional iOS app. Instead, we define and implement the behaviors for respective scenes, which may include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When to create new scenes</li><li class="listitem" style="list-style-type: disc">Defining the content of the scene</li><li class="listitem" style="list-style-type: disc">Defining when the transitions between the scenes should occur</li><li class="listitem" style="list-style-type: disc">Defining the visual effect for transition</li><li class="listitem" style="list-style-type: disc">Defining<a id="id483" class="indexterm"/> how the data is transferred from one scene to another</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec78"/>Performance enhancement by preloading textures</h2></div></div></div><p>This is one of the most powerful ways of increasing the performance of a game. Sprite Kit provides two<a id="id484" class="indexterm"/> methods for the same:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func preloadWithCompletionHandler(completionHandler: () -&gt; Void)</code>: This method<a id="id485" class="indexterm"/> uses a function that is responsible for loading the atlas textures into memory, which requires the parameter, <code class="literal">completionHandler</code>, which is called after the task is completed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func preloadTextureAtlases(textureAtlases: [AnyObject]!,</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">withCompletionHandler completionHandler: (() -&gt; Void)!)</code>: This method loads the textures <a id="id486" class="indexterm"/>of multiple atlases into memory and calls a completion handler after the task is completed. The completion handler expects two parameters: one is <code class="literal">textureAtlases</code>, which is an array of the <code class="literal">SKTextureAtlas</code> objects, and the second parameter is <code class="literal">completionHandler</code>, which is a block called after the texture atlases are loaded.</li></ul></div><p>Using texture atlases will reduce draw call, subsequently reducing the usage of the device resources. As of now, we have discussed some of the important techniques of performance enhancement in a game. Now, it is time to discuss about some essential elements of the game, such as scoring system, sounds, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec79"/>Improving the drawing performance</h2></div></div></div><p>The biggest<a id="id487" class="indexterm"/> part of building a node tree is organizing the graphical content that needs to be drawn. We should take care of what needs to drawn first and what should be drawn in the end. There are two factors which influence the drawing performance:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Drawing order, by which the graphics are submitted to the engine</li><li class="listitem" style="list-style-type: disc">Sharing of resources to accomplish the drawing</li></ul></div><p>With respect to drawing order, you can set the sibling order of the node tree to reduce the number of drawings submitted by ignoring the sibling order:</p><div><pre class="programlisting">View.ignoreSiblingOrder = true</pre></div><p>You can use<a id="id488" class="indexterm"/> depth order as the rule to batch them together, and texture maps to optimize the batching further.</p><p>Make sure to turn on the performance <a id="id489" class="indexterm"/>metrics, such as <strong>frames per second</strong> (<strong>FPS</strong>), node count, draw count, and quad count. These metrics will help you determine the performance of a game. Following are the codes that we can use to view the performance metrics:</p><div><pre class="programlisting">View.showsFPS = true          // #1

View.showsNodeCount = true    //#2

View.showsDrawCount = true    //#3

View.showsQuadCount = true    //#4</pre></div><p>In reference to the preceding code block, let's discuss each of the metrics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In code <code class="literal">#1</code>, we are displaying the number of frames per second in the game scene. The optimum FPS for a game is <code class="literal">60</code>. By displaying the FPS in the game, it becomes easy to measure the FPS.</li><li class="listitem" style="list-style-type: disc">In code <code class="literal">#2</code>, we are displaying the number of <code class="literal">SKNodes</code> in a scene. The lesser nodes we have in a scene, the better it performs. A game needs to have nodes in order to have elements in the game, but we can measure the FPS and nodes together to make sure how many nodes are producing the optimum FPS.</li><li class="listitem" style="list-style-type: disc">In code <code class="literal">#3</code>, we are displaying the number of batches for the scene count, that is, how many batches the scene is going to draw. The lesser draws your game has, the better it performs.</li><li class="listitem" style="list-style-type: disc">In code <code class="literal">#4</code>, we are displaying the quad count. Sprite Kit converts the node tree into rendered passes. Each of these rendering passes is rendered using quads. The lower the number of quads we have, the better the game performance.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec80"/>Improving performance with SKActions and constraints</h2></div></div></div><p>The main solution factor to<a id="id490" class="indexterm"/> increase the performance is by building the action once and using it for the maximum number of times possible. Try to avoid the custom animation code from the <code class="literal">update()</code> method. By using the <code class="literal">SKAction</code> and <code class="literal">SKConstraint</code> classes, you can optimize the animation effects in a game.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec81"/>Improving the physics performance</h2></div></div></div><p>Whenever <code class="literal">SKScene</code> computes a<a id="id491" class="indexterm"/> new frame of animation, it simulates the effects of forces and collisions on physics bodies connected to the node tree. It computes a final position, orientation, and velocity for each physics body.</p><p>With respect to<a id="id492" class="indexterm"/> improving the performance of the game, the dynamic objects cost more than static objects, so if possible, we can set the following property, so that the performance will be increased gradually.</p><p>Some guidelines<a id="id493" class="indexterm"/> for this are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You should use collision masks to group objects for performance</li><li class="listitem" style="list-style-type: disc">You can use force fields to replace game logic</li><li class="listitem" style="list-style-type: disc">You should turn on field debug drawing, if needed</li></ul></div><p>Before assigning a specified boundary to a physics body, you must consider the most efficient shape for your<a id="id494" class="indexterm"/> object. The shape of the boundary defines the number of calculations/operations required to be performed by the device, costing efficiency. The <strong>Circle</strong> is the cheapest, followed by the <strong>Rectangle</strong>, <strong>Polygon</strong>, <strong>Compound</strong>, and <strong>Alpha Mask</strong> bodies in the order of increasing cost of computation.</p><div><img src="img/4201_09_06.jpg" alt="Improving the physics performance"/><div><p>The computation cost scale for different shapes of boundaries</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec82"/>Improving shape's performance</h2></div></div></div><p>The shape of <a id="id495" class="indexterm"/>an object node plays an important role with respect to game performance. Where the performance will be increased if the node requires a lesser number of computations.</p><p>In the same way as described in the physics performance topic, you can improve the efficiency cost of shape nodes. The polygon is the cheapest in terms of performance cost, followed by curves, linear stroke, stroked curve, and filled curve in the order of increasing costs of computation.</p><div><img src="img/4201_09_07.jpg" alt="Improving shape's performance"/><div><p>The performance cost scale for shape nodes</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec83"/>Improving effect's performance</h2></div></div></div><p>With respect to effects<a id="id496" class="indexterm"/> in Sprite Kit, <code class="literal">SKEffectNodes</code> are expensive, hence, use it sparingly. It does its rendering off-screen and transfers to framebuffer, reducing efficiency. It is better to use <code class="literal">SKShaders</code> when no off-screen pass is needed.</p><p>If the effects do not change much, it is better to rasterize such effects by using the <code class="literal">shouldRasterize</code> property. If the <a id="id497" class="indexterm"/>
<code class="literal">shouldRastertize</code> property is <code class="literal">true</code>, the effect node caches the image for use in future frames.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec84"/>Improving lighting performance</h2></div></div></div><p>Lighting is<a id="id498" class="indexterm"/> computed on a per pixel basis, hence the computation cost is proportional to the amount of pixels lit. Ambient light does not cost in terms of computation power. Computation cost of shadows is proportional to the number of lights, hence it is advised to keep the number of shadows low.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Measuring performance with instruments</h1></div></div></div><p>Instruments is a<a id="id499" class="indexterm"/> performance measuring and testing tool provided by Apple in Xcode for the tracing and profiling of code. Instruments help in analyzing the performance of code. There are lot of instruments that can be used for checking performance issues, memory leaks, or other problems.</p><p>Once any issue gets identified, it becomes easy to rectify the issue. You can also see how much our game caches, and based on that, make a decision about the assets in the game.</p><p>You can access the instruments by navigating to <strong>Xcode</strong> | <strong>Open Developer Tool</strong> | <strong>Instruments</strong>. Then, you can choose the appropriate instrument to move with. It is better to have a look at the analysis in the initial phase of the development process, by this, you can easily understand which inclusion in the code was responsible for the error.</p><p>Instruments provide you with a list of trace templates. Trace templates are groups of preconfigured instruments. Let's discuss each of the trace templates in detail:</p><div><img src="img/4201_09_01.jpg" alt="Measuring performance with instruments"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Activity Monitor</strong>: The <strong>Activity Monitor</strong> is used to monitor the CPU, memory, disk, and network usage statistics processes.</li><li class="listitem" style="list-style-type: disc"><strong>Allocations</strong>: The allocation tool is used to track a process's anonymous virtual <a id="id500" class="indexterm"/>memory and heap.<p>This tool also provides the class names and optionally retained/released histories for objects.</p></li><li class="listitem" style="list-style-type: disc"><strong>Automation</strong>: The automation template executes a script that simulates the UI interaction for an iOS application, which is launched from the instruments.</li><li class="listitem" style="list-style-type: disc"><strong>Cocoa Layout</strong>: The <strong>Cocoa Layout</strong> observes the changes to the <code class="literal">NSLayoutConstraint</code> objects to help in determining when and where a layout constraint went away.</li><li class="listitem" style="list-style-type: disc"><strong>Core Animation</strong>: The <strong>Core Animation</strong> instrument measures application graphics performance as well as CPU usage of a process, via time profiling.</li><li class="listitem" style="list-style-type: disc"><strong>Core Data</strong>: This instrument template traces the <strong>Core Data</strong> filesystem activity, including fetches, cache misses, and saved caches too. This was discussed in <a class="link" href="ch08.html" title="Chapter 8. Handling Multiple Scenes and Levels">Chapter 8</a>, <em>Handling Multiple Scenes and Levels</em>.</li><li class="listitem" style="list-style-type: disc"><strong>Counters</strong>: The <strong>Counters</strong> will collect the<a id="id501" class="indexterm"/> <strong>performance monitor counter</strong> (<strong>PMC</strong>) events, using time or event-based sampling methods.</li><li class="listitem" style="list-style-type: disc"><strong>Dispatch</strong>: This template will monitor the dispatch queue activity, and record block invocations and their durations.</li><li class="listitem" style="list-style-type: disc"><strong>Energy Diagnostics</strong>: This template will provide the diagnostics regarding energy usage as well as the basic ON/OFF state of major device components.</li><li class="listitem" style="list-style-type: disc"><strong>File Activity</strong>: This will monitor the file and directory activity, including the file OPEN/CLOSE calls, file permission modifications, directory creation, file moves, and so on.</li><li class="listitem" style="list-style-type: disc"><strong>GPU Driver</strong>: This template is used to measure the GPU driver statistics and it also samples active CPU usage.</li><li class="listitem" style="list-style-type: disc"><strong>Leaks</strong>: The <strong>Leaks</strong> will measure the general memory usage; it periodically scans if an object is created and not accessed and detects the resulting memory loss.</li><li class="listitem" style="list-style-type: disc"><strong>Network</strong>: The <strong>Network</strong> analyses, how your applications are using the TCP/IP and UDP/IP connections, using the connections instrument.</li><li class="listitem" style="list-style-type: disc"><strong>OpenGL ES Analysis</strong>: This template measures and analyses openGL ES activity to detect openGL ES precision and performance problems. It also offers recommendations for addressing these problems.</li><li class="listitem" style="list-style-type: disc"><strong>Sudden Termination</strong>: The <strong>Sudden Termination</strong> is used to analyze the sudden termination support of a target process, reporting back traces of file system accesses and sudden termination enabled/disabled calls.</li><li class="listitem" style="list-style-type: disc"><strong>System Trace</strong>: This instrument provides system information such as process name, number of threads generated, CPU usage by each thread, and so on.</li><li class="listitem" style="list-style-type: disc"><strong>System Usage</strong>: This <a id="id502" class="indexterm"/>template is used to record the I/O system activity related to files, sockets, and shared memory for a single process launched via instruments.</li><li class="listitem" style="list-style-type: disc"><strong>Time Profiler</strong>: The <strong>Time Profiler</strong> is used to perform the low-overhead time-based sampling, where we can check the status of the processes that are running on the system CPUs. Profiling is a means of measuring, by which the output of a profiling session gives you an insight on what parts of your code are used most often, and tells you which part of the code can be improved.</li><li class="listitem" style="list-style-type: disc"><strong>Zombies</strong>: If a game has removed an object, but at a later stage tries to access that object, it will crash the game. The Zombies instrument keeps removed objects as dead, and later on releases it whenever called by the game, hence, avoiding a crash. This way, the Zombies instrument points out where the game may crash. A debugger cannot pin-point this anomaly.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec63"/>A scoring system in a game</h1></div></div></div><p>Adding a scoring<a id="id503" class="indexterm"/> or points system in a game makes it more<a id="id504" class="indexterm"/> interesting and fun to play. Having a scoring system in the game makes it easier for the players to measure their performance, making the objective clear for the user.</p><p>It always makes sense to display the score somewhere on the main screen, so that the player can have a look<a id="id505" class="indexterm"/> at the score while playing the game.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec85"/>Adding a scoring system in our Platformer game</h2></div></div></div><p>In the first step of<a id="id506" class="indexterm"/> adding a scoring system in our game, we create a label node to display the score to the player. The initial variable will be zero.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec08"/>Creating the Score label</h3></div></div></div><p>Let's add the<a id="id507" class="indexterm"/> following code snippet in the beginning of the <code class="literal">GameScene</code> class:</p><div><pre class="programlisting">let scoreText = SKLabelNode(fontNamed: "Chalkduster")
    var score = 0</pre></div><p>In the preceding code, you are creating an <code class="literal">SKLabelNode</code> and assigning it to the font, <code class="literal">Chalkduster</code>. Along with this, you are also initializing a variable <code class="literal">score</code> with the value as zero.</p><p>Now, let's set the <code class="literal">ScoreText</code> label created above zero. Also, we can set the size and position of the font in an <code class="literal">addScoreLabel()</code> method and we can call this from <code class="literal">didMoveToView()</code> of <code class="literal">GameScene</code>:</p><div><pre class="programlisting">func addScoreLabel()
    {
        self.scoreText.text = "Score: 0"
        self.scoreText.fontSize = 30
        self.scoreText.position = CGPointMake(CGRectGetMinX(self.frame) + scoreText.frame.width / 1.8  , CGRectGetMidY(self.frame) + scoreText.frame.height * 4.2)
        self.addChild(self.scoreText)
    }</pre></div><p>The preceding code will define the score text to <strong>Score: 0</strong> and the font size to <code class="literal">30</code>. Along with this, we have also defined the position of the <code class="literal">scoreText</code>.</p><p>Following is how the game screen will look after implementing the <strong>Score</strong> label:</p><div><img src="img/4201_09_02.jpg" alt="Creating the Score label"/></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec09"/>Incrementing the score when required</h3></div></div></div><p>It is important to<a id="id508" class="indexterm"/> define when we have to increment the score in our game. The same should also be displayed in the <code class="literal">scoreText</code> label we have created.</p><p>As our <em>Platformer</em> game deals with blocks, which act as an obstacle, it is better to reward points to the player when he jumps over a block.</p><p>Add the following lines of code in the <code class="literal">blockrunner()</code> method with the condition that the blocks should successfully cross the player's <em>X</em> position without colliding with him (the first <code class="literal">else</code> condition):</p><div><pre class="programlisting">self.score = score + 10

self.scoreText.text = "Score: \(String(self.score))"</pre></div><p>Now, to save the highest score and the user's name, we will use a special facility provided by iOS to save frequently required data via <code class="literal">NSUserDefaults</code>, in the following way:</p><div><pre class="programlisting">self.highestScore = self.score
NSUserDefaults.standardUserDefaults().setObject(highestScore, forKey:"HighestScore")
NSUserDefaults.standardUserDefaults().setInteger(highestScore, forKey:"SCORE")</pre></div><p>The preceding code is to be added just before the end of the <code class="literal">if</code> statement, <code class="literal">blockStatus.isRunning</code>. The <a id="id509" class="indexterm"/>code will successfully increment score. Now, it is time to save the high score.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec10"/>Saving the high score</h3></div></div></div><p>We will add a popup<a id="id510" class="indexterm"/> screen to save the high score when the<a id="id511" class="indexterm"/> user scores a high score. To make this happen, firstly, we have to create a new scene, <code class="literal">ScoreList.swift</code>, and call this scene when the player is out, that is, when the game is over.</p><p>In our <code class="literal">didBeginContact()</code> method, we have the following code line:</p><div><pre class="programlisting">self.player.runAction(SKAction.sequence(
[inOutActionWhenPlayerDied,
inOutActionWhenPlayerDied.reversedAction(),
upActionWhenPlayerDied,removeFromParent]),gotoMenuScreen)</pre></div><p>Replace the preceding lines with the following ones:</p><div><pre class="programlisting">self.player.runAction(SKAction.sequence(
[inOutActionWhenPlayerDied,
inOutActionWhenPlayerDied.reversedAction(),
upActionWhenPlayerDied,removeFromParent]),
completion: gotoSavePlayerScreen)</pre></div><p>The new lines add the <code class="literal">ScoreList</code> scene when the player dies.</p><p>Now, we will create a new<a id="id512" class="indexterm"/> method called <code class="literal">gotoSavePlayerScreen()</code>, to check if the current score is greater than the saved score. Then, the <code class="literal">ScoreList</code> scene should be called, or else the main screen, that is, the <code class="literal">MainMenu</code> scene. The code for the same is as follows:</p><div><pre class="programlisting">func gotoSavePlayerScreen()
    {
        self.player.removeFromParent()

        println("The Saved Score Is:  \(savedScore)")
        println("The Highest Score Is:  \(highestScore)")

        if self.highestScore &gt; savedScore
        {
            let transitionEffect = SKTransition.doorsCloseHorizontalWithDuration(1.5)
            highScorerListInstance = ScoreList
    (size: self.size) // , playbutton: "Play", background: "BG")
            highScorerListInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
            self.view?.presentScene(highScorerListInstance , transition:transitionEffect)
        }

        else if self.highestScore &lt;= savedScore

        {
           gotoMenuScreen()
        }
}</pre></div><p>We have<a id="id513" class="indexterm"/> implemented the method to select the scene to open <a id="id514" class="indexterm"/>after game completion. Now, let's construct the <code class="literal">ScoreList</code> scene.</p><div><div><div><div><h4 class="title"><a id="ch09lvl4sec01"/>Creating the scene to save the high score</h4></div></div></div><p>Let's create<a id="id515" class="indexterm"/> the <code class="literal">ScoreList</code> scene to display a popup<a id="id516" class="indexterm"/> for saving the highest score.</p><p>Also, add a label to congratulate the user. Following is the code for same:</p><div><pre class="programlisting">func congratsUserAndSaveScorerName()
    {
         var congratsUserLabel = SKLabelNode(fontNamed: "Chalkduster")
        congratsUserLabel.fontColor = UIColor.redColor()
        congratsUserLabel.name = "CONGRATS"
        congratsUserLabel.color = UIColor.lightGrayColor()
        congratsUserLabel.text = "Congratulations!! "
        congratsUserLabel.position = CGPointMake(CGRectGetMidX(self.frame), CGRectGetMidY(self.frame) + congratsUserLabel.frame.height * 2)
        congratsUserLabel.zPosition = 3
        self.addChild(congratsUserLabel)
    }</pre></div><p>We also need to add a <strong>CANCEL</strong> button if the user doesn't want to save the score with a name. Add the following code from the <code class="literal">didMoveToView()</code> method of <code class="literal">ScoreList.swift</code>, where<a id="id517" class="indexterm"/> the <strong>CANCEL</strong> button will take you to <code class="literal">MenuScene</code>:</p><div><pre class="programlisting">func addCancelBtn()
    {
        var Cancelbutton = SKLabelNode(fontNamed: FontFile)
        Cancelbutton.fontColor = UIColor.blueColor()
        Cancelbutton.name = "CANCEL"
        Cancelbutton.text = "CANCEL"
        Cancelbutton.position = CGPointMake(CGRectGetMinX(self.frame) + Cancelbutton.frame.width/2 , CGRectGetMinY(self.frame))
        Cancelbutton.zPosition = 3
        self.addChild(Cancelbutton)
    }
func gotoMenuScreen()
    {
        self.playerNameTextField.removeFromSuperview()
        let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
        menuSceneInstance = MenuScene(size: self.size , playbutton: "Play", background: "BG")
        menuSceneInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
        self.view?.presentScene(menuSceneInstance , transition:transitionEffect)

    }</pre></div><p>The preceding <a id="id518" class="indexterm"/>code adds a cancel button in blue color, and tapping on this button takes the player to the <code class="literal">MenuScene</code>. Now, to handle the tapping on the <strong>CANCEL</strong> button, add the following code within touches loop, inside the <code class="literal">touchesBegan()</code> method of <code class="literal">ScoreList.swift</code>:</p><div><pre class="programlisting">if node.name == "CANCEL"
{
     gotoMenuScreen()

}</pre></div><p>The score list will have been successfully created. We have also added a cancel button for the convenience<a id="id519" class="indexterm"/> of the user. Now, it is time to<a id="id520" class="indexterm"/> add a textbox in which the player will add his/her name.</p></div><div><div><div><div><h4 class="title"><a id="ch09lvl4sec02"/>Adding a textbox to save player name</h4></div></div></div><p>We need to display<a id="id521" class="indexterm"/> a textbox for the user to enter the player name that is to be saved. Add the following code line to insert a textfield inside a frame:</p><div><pre class="programlisting">let playerNameTextField = UITextField(frame: CGRectMake(50, 150, 250, 50))</pre></div><p>The following method will make the textbox that is to be used:</p><div><pre class="programlisting">func addPlayerNameTextBox()
    {
        playerNameTextField.center = CGPointMake(self.size.width / 2, self.size.height / 2)
        playerNameTextField.backgroundColor = UIColor.whiteColor()
        playerNameTextField.placeholder = "Enter Your Name"
        playerNameTextField.borderStyle = UITextBorderStyle.RoundedRect
        self.view?.addSubview(playerNameTextField)
    }</pre></div><p>Now, let's add a <code class="literal">textFieldShouldReturn</code> method of <code class="literal">UITextFieldDelegate</code>, to make the keypad disappear after tapping the return key while entering the player name in the textbox:</p><div><pre class="programlisting">func textFieldShouldReturn(playerNameTextField: UITextField) -&gt; Bool
    {
        println("Text Field Return Key")
        playerNameTextField.resignFirstResponder()
        return true

    }</pre></div><p>Now, add the <code class="literal">UITextFieldDelegate</code> delegate to the <code class="literal">Scorelist</code> class at the beginning. This delegate enables the keyboard to appear.</p><p>The preceding snippet will successfully make the keyboard disappear once the return key is pressed. Now, the next task will be to save the added name.</p><div><img src="img/4201_09_08.jpg" alt="Adding a textbox to save player name"/><div><p>This is how the screen will look when the keyboard is opened</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch09lvl4sec03"/>Saving the player name with high score</h4></div></div></div><p>We will name the<a id="id522" class="indexterm"/> button <strong>ADD PLAYER</strong>. This button will make the name entered by the user to get saved with the high score made. Firstly, create the following node, named <code class="literal">add-player</code>, with the image:</p><div><pre class="programlisting">let addPlayerButton = SKSpriteNode(imageNamed:"add-player")</pre></div><p>Add the following code method to set the properties of the <strong>ADD PLAYER</strong> button. Also, make sure to call the same from the <code class="literal">didmoveToView()</code> method:</p><div><pre class="programlisting">func addScoresSceneBtn()
    {
        addPlayerButton.name = "SCORES"
        self.addPlayerButton.position = CGPointMake(CGRectGetMidX(self.frame),CGRectGetMinY(self.frame)/3)
        self.addChild(self.addPlayerButton)
    }
declare the following variable before adding didMoveToView() method

var highestScorerName:String = String()</pre></div><p>Add the following lines of code in the <code class="literal">touchesBegan()</code> method of <code class="literal">ScoreList.swift</code>, as in the previous code, to handle the tap of the <strong>ADD PLAYER</strong> button within touches loop:</p><div><pre class="programlisting">if node.name == "SCORES"
            {
                if playerNameTextField.text.isEmpty
                {
                    playerNameTextField.placeholder = "Please Enter the Player Name"
                }
                else
                {
                    self.highestScorerName = self.playerNameTextField.text NSUserDefaults.standardUserDefaults().setObject(highestScorerName, forKey:"HighestScorerName")
                    NSUserDefaults.standardUserDefaults().synchronize()
                     gotoMenuScreen()
                }
            }</pre></div><p>We are also adding <code class="literal">gotoMenuScene()</code> to return to the main menu as we know. Following is<a id="id523" class="indexterm"/> the code for it:</p><div><pre class="programlisting">func gotoMenuScreen()
    {
        self.playerNameTextField.removeFromSuperview()
        let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
        menuSceneInstance = MenuScene(size: self.size , playbutton: "Play", background: "BG")
        menuSceneInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
self.view?.presentScene(menuSceneInstance , transition:transitionEffect)
    }</pre></div><p>Now, the work on <code class="literal">SceneList.swift</code> is complete. Time to work on the high score board. The following screenshot shows how the screen will look:</p><div><img src="img/4201_09_03.jpg" alt="Saving the player name with high score"/></div></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec11"/>Creating the high score board</h3></div></div></div><p>So far, we have <a id="id524" class="indexterm"/>saved the name of the player who makes a high score, but we have not made a score board to show the high score to the player. It is better to have access to the score board right from the main menu, as it makes it convenient.</p><p>In our game, we are going to create a high score menu scene with a button on the main menu to reach this screen.</p><p>Firstly, create a scene with the name, <code class="literal">AddScoreScene.swift</code>, to show the high score.</p><p>Now, create the method, <code class="literal">showHeightestScorerName()</code>,to <a id="id525" class="indexterm"/>display the name of the player who scored the highest score, and also call the same from the <code class="literal">didMoveToView()</code> method in the <code class="literal">AddScoreScene.swift</code> file:</p><div><pre class="programlisting">var savedScorerName: String = String()
func showHeighestScorerName()
    {
if(NSUserDefaults.standardUserDefaults().objectForKey
("HighestScorerName")) == (nil)
        { savedScorerName = " "
        }
        else
        { savedScorerName = NSUserDefaults.standardUserDefaults().objectForKey
("HighestScorerName") as String
            println(savedScorerName)
        }
var highScorerNameLabel = SKLabelNode(fontNamed: "Chalkduster")
        highScorerNameLabel.fontColor = UIColor.blueColor()
        highScorerNameLabel.name = "HIGHESTSCORERNAME"
        highScorerNameLabel.color = UIColor.lightGrayColor()
        highScorerNameLabel.text = "High Scorer :  \(savedScorerName)"
        highScorerNameLabel.position = CGPointMake(CGRectGetMidX(self.frame), CGRectGetMidY(self.frame) + (highScorerNameLabel.frame.height * 2))
        highScorerNameLabel.zPosition = 3
        self.addChild(highScorerNameLabel)
    }</pre></div><p>We have displayed the name of the player with the highest score, now it is time to show the highest score <a id="id526" class="indexterm"/>made by the player. For this, create the method, <code class="literal">showHeighestScores()</code>, and also call the same from the <code class="literal">didMoveToView()</code> method in the <code class="literal">AddScoreScene.swift</code> file. Following is the code to be added in the <code class="literal">showHeighestScores()</code> method:</p><div><pre class="programlisting">    func showHeighestScores()
    {
if(NSUserDefaults.standardUserDefaults().objectForKey
("HighestScore")) == (nil)
        {
            savedScore = 0
        }
        else
        {
            savedScore = NSUserDefaults.standardUserDefaults().objectForKey("HighestScore") as! Int
            println(savedScore)
        }
        
        var highScoreLabel = SKLabelNode(fontNamed: "Chalkduster")
        highScoreLabel.fontColor = UIColor.blueColor()
        highScoreLabel.name = "HIGHESTSCORE"
        highScoreLabel.color = UIColor.lightGrayColor()
        highScoreLabel.text = "The Score is: \(savedScore)"
        highScoreLabel.position = CGPointMake(CGRectGetMidX(self.frame), CGRectGetMidY(self.frame))
        highScoreLabel.zPosition = 3
        self.addChild(highScoreLabel)
    }</pre></div><p>Now, it is time to add <a id="id527" class="indexterm"/>a back button, which will return the player to the main menu. Add the following code to implement the back button functionality:</p><div><pre class="programlisting">func addBackBtn()
    {
        var mainMenubutton = SKLabelNode(fontNamed: FontFile)
        mainMenubutton.fontColor = UIColor.blueColor()
        mainMenubutton.name = "MAIN MENU"
        mainMenubutton.text = "MAIN MENU"
        mainMenubutton.position = CGPointMake(CGRectGetMinX(self.frame) + mainMenubutton.frame.width/2 , CGRectGetMinY(self.frame))
        mainMenubutton.zPosition = 3
        self.addChild(mainMenubutton)
    }

var menuSceneInstance : MenuScene?
 func goToMenuScene()
    {
        let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
        menuSceneInstance = MenuScene(size: self.size , playbutton: "Play", background: "BG")
        menuSceneInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
        self.view?.presentScene(menuSceneInstance , transition:transitionEffect)
    }</pre></div><p>The preceding code has added the back button functionality; now we have to handle the touch/tap on the button in the <code class="literal">touchesBegan()</code> method of <code class="literal">AddScore.swift</code>, as we did earlier. Add the following code in the <code class="literal">touchesBegan()</code> method:</p><div><pre class="programlisting">for touch: AnyObject in touches
        {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == "MAIN MENU"
            {
                goToMenuScene()
            }
        }</pre></div><p>Following is how the high score board will look:</p><div><img src="img/4201_09_04.jpg" alt="Creating the high score board"/></div><p>Finally, the<a id="id528" class="indexterm"/> high score screen is also complete. This concludes the integration of a scoring system in our <em>Platformer</em> game.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Adding sound into a game</h1></div></div></div><p>A game can only be<a id="id529" class="indexterm"/> complete with different music and sound effects. There can be background music in the game along with sound effects at each action, such as, when the user taps, we can play a sound, and later, we can play a sound when a player hits an obstacle or some other element in the main game. We can also have different music at different levels. Sound effects play a vital role in enhancing the overall gaming experience, as they indulge the user in a holistic gaming experience.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec86"/>Adding sounds into a Sprite Kit game</h2></div></div></div><p>There are two ways<a id="id530" class="indexterm"/> to add sound effects in a Sprite Kit game:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using <code class="literal">SKActions</code></li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">AVFoundation</code> framework</li></ul></div><p>Adding sound effects <a id="id531" class="indexterm"/>using <code class="literal">SKActions</code> is not efficient, as compared to the <code class="literal">AVFoundation</code> framework. <code class="literal">SKActions</code> has a lot of limitations, such as that one cannot pause or play the sound in the middle of gameplay, and so on. Hence, it is advisable to use <code class="literal">AVFoundation</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec87"/>Adding sound into our Platformer game</h2></div></div></div><p>Let's add sound<a id="id532" class="indexterm"/> effects in our <em>Platformer</em> game. We <a id="id533" class="indexterm"/>will be using the <code class="literal">AVFoundation</code> framework to add sounds.</p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, add the framework by clicking on your project, and then, under the <strong>General</strong> category, go to the <strong>Linked frameworks and Libraries</strong> section and add the <code class="literal">AVFoundation</code> framework.</li><li class="listitem">Now, add the following code to import the <code class="literal">AVFoundation</code> framework into our <code class="literal">GameScene.swift</code> file:<div><pre class="programlisting">Import AVFoundation</pre></div></li><li class="listitem">Add the <code class="literal">AVAudioPlayerDelegate</code> delegate to use specified properties and methods of <code class="literal">AVAudioPlayer</code> in the <code class="literal">GameScene</code> class.</li><li class="listitem">Now, create an instance of <code class="literal">AVAudioPlayer</code> for our <code class="literal">GameScene</code> file:<div><pre class="programlisting">var avPlayer:AVAudioPlayer!</pre></div></li><li class="listitem">We are adding two sound files named <code class="literal">game_music.mp3</code> and <code class="literal">Strong_Punch-Mike_Koenig-574430706.wav</code> into our project (the WAV file format is suitable for short sounds, and MP3 format is suitable for longer durational sounds) and assign their names with two string variable as shown as follows:<div><pre class="programlisting">let backgroundSound = "game_music"
    let gameOutSound = "Strong_Punch-Mike_Koenig-574430706"</pre></div></li><li class="listitem">Add the<a id="id534" class="indexterm"/> following method of code to make <code class="literal">AVAudioPlayer</code> get the specified audio file and <a id="id535" class="indexterm"/>play the same:<div><pre class="programlisting">func readFileIntoAVPlayer(soundName:String, ext:String)
    {
        var error: NSError?
        let fileURL:NSURL = NSBundle.mainBundle().URLForResource(soundName, withExtension: ext)!

        // the player must be a field. Otherwise it will be released before playing starts.
        self.avPlayer = AVAudioPlayer(contentsOfURL: fileURL, error: &amp;error)
        if avPlayer == nil
        {
            if let e = error {
                println(e.localizedDescription)
            }
        }
        if avPlayer.playing
        {
            avPlayer.stop()
        }

        println("playing \(fileURL)")
        avPlayer.delegate = self
        avPlayer.prepareToPlay()
        avPlayer.volume = 1.0
        avPlayer.play()

    }</pre></div><p>In the preceding code, we are passing the sound name and the file format as two parameters. The method will then play the sound file. If the user, while playing sound on the device, starts the game, this code will stop the earlier playing sound and then start the game sound.</p></li><li class="listitem">As we want the background sound to be always running, we will call the <code class="literal">readFileIntoAVPlayer()</code> method and pass <code class="literal">backgroundSound</code> and <code class="literal">mp3</code> as parameters. Add the method in the beginning of the <code class="literal">didMoveToView()</code> method of <code class="literal">GameScene.swift</code>. Following is the line to be added:<div><pre class="programlisting">readFileIntoAVPlayer(backgroundSound, ext: "mp3")</pre></div><p>The preceding line will play the background sound as the game starts.</p></li><li class="listitem">We have also<a id="id536" class="indexterm"/> added another sound file for when the player dies. Now it is time to add the code that will play the sound<a id="id537" class="indexterm"/> effect when the player dies. Add the following lines of code in the beginning of the <code class="literal">didBeginContact()</code> method of <code class="literal">GameScene.swift</code>:<div><pre class="programlisting">avPlayer.stop()

readFileIntoAVPlayer(gameOutSound, ext: "wav")</pre></div></li></ol></div><p>In the preceding code, we are stopping the background sound in the player and playing a new sound effect for the player's death by calling the same method as before, but with different parameters.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Animation frames using SKTexture</h1></div></div></div><p>So far, we have <a id="id538" class="indexterm"/>used static images in our game, but if you will see, most of the games have animated effects, such as player running effect, car running effect, or any other effect that enhances the gameplay and creates a much better experience for all.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec88"/>Adding the Run action texture to the player in the Platformer game</h2></div></div></div><p>We had earlier<a id="id539" class="indexterm"/> added an image<a id="id540" class="indexterm"/> atlas of the name, <code class="literal">idle.atlas</code>, which contained similar images of the player standing position.</p><p>Now, we are going to add running texture images for the player, which will make it look as though the player is running in the <code class="literal">GameScene</code>.</p><p>Firstly, add a texture image set called <code class="literal">bro5_run.atlas</code>, which we have provided. The image atlas contains sets of seven images, which are sometimes also referred to as a sprite sheet. In our case, it will be known as the player running sprite sheet. These sets of images will be running one after the other at a fast rate of time inside texture atlas.</p><p>Now, let's assign<a id="id541" class="indexterm"/> the texture image for the player. Add the following line of code in the beginning of the <code class="literal">didMoveToView()</code> method:</p><div><pre class="programlisting">player = SKSpriteNode(texture:atlasForPlayerRun.textureNamed("bro5_run0001.png"))</pre></div><p>In the next step, we will add a method to create an <code class="literal">SKAction</code> for adding an animated texture for<a id="id542" class="indexterm"/> the different textures of <code class="literal">atlasForPlayerRun.atlas</code>. Add the following line of code by creating a <code class="literal">runForwardTexture()</code> method and call it from <code class="literal">didMoveToView()</code>. Make sure to do this after you have added the texture image for the player:</p><div><pre class="programlisting">func runForwardTexture()
    {
        let hero_run_anim = SKAction.animateWithTextures([

            atlasForPlayerRun.textureNamed("bro5_run0002.png"),
            atlasForPlayerRun.textureNamed("bro5_run0002.png"),
            atlasForPlayerRun.textureNamed("bro5_run0003.png"),
            atlasForPlayerRun.textureNamed("bro5_run0004.png"),
            atlasForPlayerRun.textureNamed("bro5_run0005.png"),
            atlasForPlayerRun.textureNamed("bro5_run0006.png"),
            atlasForPlayerRun.textureNamed("bro5_run0007.png")
            ], timePerFrame: 0.06)

        let run = SKAction.repeatActionForever(hero_run_anim)

        player.runAction(run, withKey: "running")

    }</pre></div><p>The preceding code will have successfully implemented the running animation for the player. The following screenshot shows how a sprite sheet looks:</p><div><img src="img/4201_09_05.jpg" alt="Adding the Run action texture to the player in the Platformer game"/><div><p>The texture atlas for a running animation of the player</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Summary</h1></div></div></div><p>In this chapter, we have covered some important aspects of the game, along with reading about performance improvements. Further, you can enhance the performance of your game using performance measuring instruments provided by Xcode. We also integrated the scoring system, sounds, and player running animation in our platformer game.</p><p>In the next and final chapter of this book, we will discuss each element of our <em>Platformer</em> game, take an in-depth look at the Game Center provided by Apple, and discuss the newest additions in iOS 9 brought to us by Apple.</p></div></body></html>