["```swift\n    import UIKit\n    struct ReviewItem {\n       var date: Date?\n    var rating: Double? \n    var title: String? \n       var name: String?\n       var customerReview: String?\n       var restaurantID: Int64?\n       var uuid = UUID()\n    }\n    extension ReviewItem {\n       init(review: Review) {\n          self.date = review.date\n          self.rating = review.rating\n          self.title = review.title\n          self.name = review.name\n    self.customerReview = review.customerReview \n          self.restaurantID = review.restaurantID\n    if let reviewUUID = review.uuid { \n             self.uuid = reviewUUID\n          }\n       }\n    }\n    ```", "```swift\n    import ReviewItem structure, the properties of the RestaurantPhotoItem structure are the same as the RestaurantPhoto entity's attributes. There is one additional computed property, photoData, which is used to store the representation of photo in binary data format, as Core Data can't store UIImage instances.The initializer creates a `RestaurantPhotoItem` instance and maps the attributes from the `RestaurantPhoto` entity to properties in `RestaurantPhotoItem` instance. Note the conversion from binary data to `UIImage` when setting the value for `photo`.\n    ```", "```swift\n    import CoreData\n    ```", "```swift\n    struct CoreDataManager { \n       let container: NSPersistentContainer\n       init() {\n          container = NSPersistentContainer(name: \n          \"LetsEatModel\")\n          container.loadPersistentStores { \n             (storeDesc, error) in \n             error.map {\n                print($0)\n             }\n          }\n       }\n    }\n    ```", "```swift\n    extension CoreDataManager {\n       static var shared = CoreDataManager()\n    }\n    ```", "```swift\n    func addReview(_ reviewItem: ReviewItem) {\n       let review = Review(context: \n       container.viewContext)\n       review.date = Date()\n       if let reviewItemRating = reviewItem.rating { \n          review.rating = reviewItemRating\n       }\n       review.title = reviewItem.title \n       review.name = reviewItem.name\n       review.customerReview = \n       reviewItem.customerReview\n       if let reviewItemRestID = \n       reviewItem.restaurantID { \n          review.restaurantID = reviewItemRestID  \n       }\n       review.uuid = reviewItem.uuid\n       save()\n    }\n    ```", "```swift\n    func addPhoto(_ restPhotoItem: \n    RestaurantPhotoItem) {\n       let restPhoto = RestaurantPhoto(context: \n       container.viewContext)\n       restPhoto.date = Date()\n       restPhoto.photo = restPhotoItem.photoData\n       if let restPhotoID = \n          restPhotoItem.restaurantID { \n          restPhoto.restaurantID = restPhotoID \n       }\n       restPhoto.uuid = restPhotoItem.uuid\n       save()\n    }\n    ```", "```swift\n    private func save() {\n       do {\n          if container.viewContext.hasChanges {\n             try container.viewContext.save()\n          }\n       } catch let error {\n          print(error.localizedDescription)\n       }\n    }\n    ```", "```swift\nfunc fetchReviews(by identifier: Int) -> \n[ReviewItem] {\n   let moc = container.viewContext\n   let request = Review.fetchRequest()\n   let predicate = NSPredicate(format: \n   \"restaurantID = %i\", identifier)\n   var reviewItems: [ReviewItem] = []\n   request.sortDescriptors = \n   [NSSortDescriptor(key: \"date\", \n   ascending: false)]\n   request.predicate = predicate \n   do {\n      for review in try moc.fetch(request) {\n         reviewItems.append(ReviewItem(review: \n         review))\n      }\n      return reviewItems\n   } catch {\n      fatalError(\"Failed to fetch reviews: \n      \\(error)\")\n   }\n}\n\nfunc fetchRestPhotos(by identifier: Int) -> \n[RestaurantPhotoItem] {\n   let moc = container.viewContext\n   let request = RestaurantPhoto.fetchRequest()\n   let predicate = NSPredicate(format: \n   \"restaurantID = %i\", identifier) \n   var restPhotoItems: [RestaurantPhotoItem] = [] \n   request.sortDescriptors = \n   [NSSortDescriptor(key: \"date\", \n   ascending: false)]\n   request.predicate = predicate \n   do {\n      for restPhoto in try moc.fetch(request) {\n         restPhotoItems.append(RestaurantPhotoItem\n         (restaurantPhoto: restPhoto))\n      }\n      return restPhotoItems\n   } catch {\n      fatalError(\"Failed to fetch restaurant \n      photos: \\(error)\")\n   }\n}\n```", "```swift\nlet moc = container.viewContext\n```", "```swift\nlet request = Review.fetchRequest() \n```", "```swift\nlet predicate = NSPredicate(format: \"restaurantID = %i\", identifier)\n```", "```swift\nvar reviewItems: [ReviewItem] = []\n```", "```swift\nrequest.sortDescriptors = [NSSortDescriptor(key: \"date\", ascending: false)]\n```", "```swift\nrequest.predicate = predicate\n```", "```swift\ndo {\n   for review in try moc.fetch(request) {\n      reviewItems.append(ReviewItem(review: \n      review))\n   }\n   return reviewItems\n} catch {\n   fatalError(\"Failed to fetch reviews: \\(error)\")\n}\n```", "```swift\n    var selectedRestaurantID: Int?\n    ```", "```swift\n    private extension ReviewFormViewController {\n       @IBAction func onSaveTapped(_ sender: Any) {\n    onSaveTapped(_:) will now create a ReviewItem instance, assign data obtained from the CoreDataManager.shared.addReview(reviewItem) to save the review to the persistent store.\n    ```", "```swift\n    override func prepare(for segue: \n    UIStoryboardSegue, sender: Any?) {\n       if let identifier = segue.identifier {\n          switch identifier  {\n          case Segue.showReview.rawValue:\n             showReview(segue: segue)\n          default:\n             print(\"Segue not added\")\n          }\n       }\n    }\n    ```", "```swift\n    func showReview(segue: UIStoryboardSegue) {\n       guard let navController = segue.destination as? \n       UINavigationController, let viewController = \n       navController.topViewController as? \n       ReviewFormViewController else {\n          return\n       }\n       viewController.selectedRestaurantID = \n       selectedRestaurant?.restaurantID\n    }\n    ```", "```swift\n    super.viewDidLoad()\n    ReviewFormViewController.\n    ```", "```swift\n    func saveSelectedPhoto() {\n       if let mainImage = self.mainImageView.image {\n          var restPhotoItem = \n          RestaurantPhotoItem()\n          restPhotoItem.date = Date()\n          restPhotoItem.photo = \n          mainImage.preparingThumbnail(of: \n          CGSize(width: 100, height: 100))\n          if let selRestID = selectedRestaurantID \n          {\n             restPhotoItem.restaurantID = \n             Int64(selRestID)\n          }\n          CoreDataManager.shared\n          .addPhoto(restPhotoItem)\n       }\n       dismiss(animated: true, completion: nil)\n    }\n    ```", "```swift\n    @IBAction func onSaveTapped(_ sender: Any) { \n       saveSelectedPhoto()\n    }\n    ```", "```swift\n    override func prepare(for segue: UIStoryboardSegue,\n    sender: Any?){\n       if let identifier = segue.identifier {\n          switch identifier {\n          case Segue.showReview.rawValue:\n             showReview(segue: segue)\n    prepare(for:sender:) method check to see if the segue has the showPhotoFilter segue identifier. If it does, the showPhotoFilter(segue:) method is executed prior to transitioning from the showPhotoFilter(segue:) has not been implemented yet.\n    ```", "```swift\n    func showPhotoFilter(segue: UIStoryboardSegue) {\n       guard let navController = segue.destination as? \n       UINavigationController, let viewController = \n       navController.topViewController as? \n       PhotoFilterViewController else {\n          return\n       }\n       viewController.selectedRestaurantID = \n       selectedRestaurant?.restaurantID\n    }\n    ```", "```swift\n    import UIKit\n    class ReviewCell: UICollectionViewCell {\n       @IBOutlet var titleLabel: UILabel!\n       @IBOutlet var dateLabel: UILabel!\n       @IBOutlet var nameLabel: UILabel!\n       @IBOutlet var reviewLabel: UILabel!\n       @IBOutlet var ratingsView: RatingsView!\n    }\n    ```", "```swift\n    import UIKit\n    class ReviewsViewController: UIViewController {\n       ReviewsViewController is straightforward. You have an outlet for a collection view, collectionView. selectedRestaurantID stores the restaurant identifier. reviewItems contains an array of ReviewItem instances. dateFormatter is an instance of the DateFormatter class that will be used to format the date for display. Don't worry about the errors, as you'll be typing in the implementation of the initialize() and setupDefaults() methods in the next step.Important InformationTo learn more about the `DateFormatter` class, visit this link: [https://developer.apple.com/documentation/foundation/dateformatter](https://developer.apple.com/documentation/foundation/dateformatter).\n    ```", "```swift\n    private extension ReviewsViewController {\n       func initialize() {\n          setupCollectionView()\n       }\n       func setupCollectionView() {\n          let flow = UICollectionViewFlowLayout()\n          flow.sectionInset = UIEdgeInsets(top: 7,left: 7,\n          bottom: 7, right: 7)\n          flow.minimumInteritemSpacing = 0 \n          flow.minimumLineSpacing = 7 \n          flow.scrollDirection = .horizontal \n          collectionView.collectionViewLayout = flow\n       }\n    }\n    ```", "```swift\n    func checkReviews() {\n       let viewController = self.parent as? \n       RestaurantDetailViewController\n       if let restaurantID = \n       viewController?.selectedRestaurant?\n       .restaurantID {\n          reviewItems = \n          CoreDataManager.shared\n          .fetchReviews(by: restaurantID)\n          if !reviewItems.isEmpty {\n             collectionView.backgroundView = nil\n          } else {\n             let view = NoDataView(frame: \n             CGRect(x: 0, y: 0, width: \n             collectionView.frame.width,\n             height: \n             collectionView.frame.height))\n          view.set(title: \"Reviews\", desc: \n          \"There are currently no reviews\")\n          collectionView.backgroundView = view\n          }\n       }\n       collectionView.reloadData()\n    }\n    ```", "```swift\n    let viewController = self.parent as? \n    RestaurantDetailViewController\n    ```", "```swift\n    if let restaurantID = \n    viewController?.selectedRestaurant?.restaurantID { \n    ```", "```swift\n    reviewItems = CoreDataManager.shared\n    .fetchReviews(by: restaurantID)\n    ```", "```swift\n    if !reviewItems.isEmpty {\n       collectionView.backgroundView = nil\n    } else {\n       let view = NoDataView(frame: \n       CGRect(x: 0, y: 0, width: \n       collectionView.frame.width,\n       height: \n       collectionView.frame.height))\n       view.set(title: \"Reviews\", desc: \n       \"There are currently no reviews\")\n       collectionView.backgroundView = view\n    }\n    ```", "```swift\n    collectionView.reloadData()\n    ```", "```swift\n    extension ReviewsViewController: \n    UICollectionViewDataSource {\n       func collectionView(_ collectionView: \n       UICollectionView, numberOfItemsInSection \n       section: Int) -> Int {\n          reviewItems.count\n       }\n       func collectionView(_ collectionView: \n       UICollectionView, cellForItemAt indexPath: \n       IndexPath) -> UICollectionViewCell {\n          let cell = collectionView\n          .dequeueReusableCell \n          (withReuseIdentifier: \"reviewCell\", \n          for: indexPath) as! ReviewCell\n          let reviewItem = reviewItems[indexPath.item] \n          cell.nameLabel.text = reviewItem.name \n          cell.titleLabel.text = reviewItem.title \n          cell.reviewLabel.text = \n          reviewItem.customerReview \n          if let reviewItemDate = reviewItem.date {\n             cell.dateLabel.text = \n             dateFormatter.string(from: \n             reviewItemDate)\n          }\n          if let reviewItemRating = reviewItem.rating \n          {\n             cell.ratingsView.rating = \n             reviewItemRating\n          }\n          return cell\n       }\n    }\n    ```", "```swift\n    extension ReviewsViewController: UICollectionViewDelegateFlowLayout {\n       func collectionView(_ collectionView: \n       UICollectionView, layout collectionViewLayout: \n       UICollectionViewLayout, sizeForItemAt \n       indexPath: IndexPath) -> CGSize {\n          let edgeInset = 7.0\n          if reviewItems.count == 1 {\n             let cellWidth = \n             collectionView.frame.size.width - \n             (edgeInset * 2) \n             return CGSize(width: cellWidth, height: \n             200)\n          } else {\n             let cellWidth = \n             collectionView.frame.size.width - \n             (edgeInset * 3)\n             return CGSize(width: cellWidth, height: \n             200)\n          }\n       }\n    }\n    ```", "```swift\n    func fetchRestaurantRating(by identifier: Int) -> \n    Double { \n       let reviewItems = fetchReviews(by: identifier)\n       let sum = reviewItems.reduce(0, {$0 + \n       ($1.rating ?? 0)}) \n       return sum / Double(reviewItems.count)\n    }\n    ```", "```swift\n    func createRating() {\n       ratingsView.isEnabled = selectedRestaurant instance's restaurantID property to restaurantID. If successful, the CoreDataManager.shared.fetchRestaurantRating() method is called, which gets all the reviews with restaurantID's restaurant identifier value, and calculates the average rating. ratingValue is then set to the average rating and used to update the ratings view's rating property, which determines the number of stars displayed in the roundedValue is then calculated from ratingValue to return a number with 1 decimal point, and is used to set the text property for overallRatingLabel.\n    ```", "```swift\n    override func viewDidAppear(_ animated: Bool) {\n       super.viewDidAppear(animated)\n       createRating()\n    }\n    ```"]