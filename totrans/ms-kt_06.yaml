- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Network Calls with Kotlin Coroutines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kotlin 协程进行网络调用
- en: Most of the apps we use on our phones fetch data that is hosted online on a
    server. As such, we developers have to understand how to request and send data
    to the servers too. In this chapter, we will learn how to send and request data
    that is hosted online and display it in our apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在手机上使用的许多应用程序都会从服务器上托管的数据中获取数据。因此，作为开发者，我们必须了解如何向服务器请求和发送数据。在本章中，我们将学习如何发送和请求在线托管的数据，并在我们的应用程序中显示它。
- en: In this chapter, we will learn how to perform network calls with a networking
    library, **Retrofit**. We will learn how to consume **application programming
    interfaces** (**APIs**) using this library. Moreso, we will learn how to take
    advantage of **Kotlin coroutines** to perform asynchronous network requests in
    our app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用网络库 **Retrofit** 来执行网络调用。我们将学习如何使用此库消费 **应用程序编程接口**（**API**）。更重要的是，我们将学习如何利用
    **Kotlin 协程**在我们的应用程序中执行异步网络请求。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up Retrofit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Retrofit
- en: Introduction to Kotlin coroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 协程简介
- en: Using Kotlin coroutines for network calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kotlin 协程进行网络调用
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要下载 Android Studio Hedgehog 或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix)找到本章的代码。
- en: Setting up Retrofit
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Retrofit
- en: Retrofit is a type-safe REST client for Android, Java, and Kotlin developed
    by Square. The library provides a powerful framework for authenticating and interacting
    with APIs and sending network requests with OkHttp. In this book, we will be using
    Retrofit to perform our network requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit 是由 Square 开发的一个类型安全的 REST 客户端，适用于 Android、Java 和 Kotlin。该库提供了一个强大的框架，用于验证和与
    API 交互，以及使用 OkHttp 发送网络请求。在本书中，我们将使用 Retrofit 来执行我们的网络请求。
- en: 'To begin with, we will add the Retrofit dependencies using our newly created
    version catalog. Let’s define the versions in the `libs.versions.toml` file as
    follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用我们新创建的版本目录添加 Retrofit 依赖项。让我们在 `libs.versions.toml` 文件中定义以下版本：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let’s define the libraries in the `libs.versions.toml` file in the libraries
    section of our versions catalog as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在版本目录的库部分中定义 `libs.versions.toml` 文件中的库，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are adding these dependencies to our project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加以下依赖项到我们的项目中：
- en: '**Retrofit**: As mentioned earlier, we will use Retrofit to perform our network
    requests.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Retrofit**: 如前所述，我们将使用 Retrofit 来执行我们的网络请求。'
- en: '**Retrofit serialization**: This is a converter that uses **Kotlinx serialization**
    to convert Kotlin objects to and from JSON.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Retrofit 序列化**: 这是一个使用 **Kotlinx 序列化**将 Kotlin 对象转换为 JSON 并从 JSON 转换为 Kotlin
    对象的转换器。'
- en: '**Coroutines**: We will use Kotlin coroutines to perform our network requests
    asynchronously. We will be learning more about coroutines shortly.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程**: 我们将使用 Kotlin 协程来异步执行我们的网络请求。我们很快就会了解更多关于协程的内容。'
- en: '**Kotlinx serialization JSON**: This is a Kotlin serialization library for
    JSON. We will use this to parse our JSON responses. We have other serialization
    libraries, such as Moshi and Gson, but we used the Kotlinx serialization library
    for the following reasons:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kotlinx 序列化 JSON**: 这是一个用于 JSON 的 Kotlin 序列化库。我们将使用它来解析我们的 JSON 响应。我们还有其他序列化库，如
    Moshi 和 Gson，但我们选择使用 Kotlinx 序列化库的原因如下：'
- en: '**Kotlin-centric development**: Kotlinx serialization is designed with Kotlin
    in mind, providing seamless integration and native support for Kotlin serialization.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以 Kotlin 为中心的开发**: Kotlinx 序列化是针对 Kotlin 设计的，提供了无缝集成和原生支持 Kotlin 序列化。'
- en: '**Declarative syntax**: Kotlinx serialization uses a declarative syntax, leveraging
    Kotlin’s language features for concise and readable serialization code.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式语法**: Kotlinx 序列化使用声明式语法，利用 Kotlin 的语言特性来编写简洁且可读的序列化代码。'
- en: '**Compile-time safety**: Compile-time safety is a key feature, catching serialization-related
    errors during the compilation phase and reducing the likelihood of runtime errors.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时安全性**：编译时安全性是一个关键特性，在编译阶段捕获与序列化相关的错误，并减少运行时错误的可能性。'
- en: '**Custom serialization strategies**: We have the flexibility to define custom
    serialization strategies for specific types or scenarios, offering fine-grained
    control over the serialization process.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义序列化策略**：我们可以为特定类型或场景定义自定义序列化策略，提供对序列化过程的精细控制。'
- en: '**Seamless integration with Kotlin ecosystem**: Being part of the Kotlin ecosystem,
    Kotlinx serialization integrates seamlessly with other Kotlin libraries and frameworks,
    contributing to a cohesive development experience.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与Kotlin生态系统的无缝集成**：作为Kotlin生态系统的一部分，Kotlinx序列化与其它Kotlin库和框架无缝集成，有助于提供一致的开发体验。'
- en: '**OkHttp**: This is an HTTP client that is used to make network requests. It
    provides some utilities for working with Retrofit.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OkHttp**：这是一个用于发送网络请求的HTTP客户端。它为使用Retrofit提供了一些实用工具。'
- en: 'All these dependencies will be added together, so this is a chance for us to
    group them in our `libs.versions.toml` file, add this bundle below our Koin bundle:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些依赖项都将被累加在一起，因此这是我们有机会在`libs.versions.toml`文件中将它们分组的机会，在我们的Koin包下面添加此包：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we create a new bundle called `networking` and add all the dependencies
    that we specified earlier on. We have to sync the project for our changes to be
    added to the project. Tap on `libs.versions.toml` file. After syncing, let us
    start setting up the plugins and dependencies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`networking`的新包，并添加了之前指定的所有依赖项。我们必须同步项目，以便将我们的更改添加到项目中。点击`libs.versions.toml`文件。同步后，让我们开始设置插件和依赖项。
- en: 'First, in our project-level `build.gradle.kts` file, we need to add the Kotlinx
    serialization plugin. Open the project-level `build.gradle.kts` file and on the
    plugins block add the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的项目级别`build.gradle.kts`文件中，我们需要添加Kotlinx序列化插件。打开项目级别的`build.gradle.kts`文件，并在插件块中添加以下内容：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We define the Kotlinx serialization plugin and specify the version to use.
    This will set up the Kotlinx serialization plugin for us. The plugin generates
    Kotlin code for serializable classes. We will use this plugin to generate our
    models. Next, let us set up the plugin in our app module. Open the app-level `build.gradle.kts`
    file and add the following in the plugins block:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了Kotlinx序列化插件并指定了要使用的版本。这将为我们设置Kotlinx序列化插件。该插件为可序列化类生成Kotlin代码。我们将使用此插件来生成我们的模型。接下来，让我们在我们的应用模块中设置插件。打开应用级别的`build.gradle.kts`文件，并在插件块中添加以下内容：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This ensures our module is set up to use the Kotlinx serialization plugin.
    Next, we will add our `networking` bundle to our app module. In the app-level
    `build.gradle.kts` file, add the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了我们的模块已设置好以使用Kotlinx序列化插件。接下来，我们将添加我们的`networking`包到我们的应用模块。在应用级别的`build.gradle.kts`文件中，添加以下内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will add all the dependencies that we have specified in our `networking`
    bundle. Having done all these, our project is set up to use Retrofit. We will
    be using Koin to create a Retrofit instance that will be injected into classes
    that need it. Let us head over to the `Module.kt` file and add the `PetsViewModel`
    definition:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加我们在`networking`包中指定的所有依赖项。完成所有这些后，我们的项目已设置好以使用Retrofit。我们将使用Koin创建一个Retrofit实例，该实例将被注入到需要它的类中。让我们转到`Module.kt`文件并添加`PetsViewModel`定义：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, we created a Retrofit instance using the Retrofit builder.
    We also added a converter factory that uses Kotlinx serialization to convert Kotlin
    objects to and from JSON. We also specified the base URL for our API. We are using
    the `CatsAPI.kt` and add the following method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用Retrofit构建器创建了一个Retrofit实例。我们还添加了一个转换工厂，该工厂使用Kotlinx序列化将Kotlin对象转换为JSON，并将JSON转换为Kotlin对象。我们还指定了API的基础URL。我们使用了`CatsAPI.kt`并添加了以下方法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we use the `@GET` annotation to specify that we will
    be using the `GET` HTTP method for this request. Inside the method, we are also
    specifying a path that will be appended to our base URL to make the full URL for
    our request. Using the `GET` method means our method will only request data. We
    have the following built-in HTTP annotations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`@GET`注解来指定我们将使用`GET` HTTP方法进行此请求。在方法内部，我们还在指定一个将被附加到我们的基础URL的路径，以形成请求的完整URL。使用`GET`方法意味着我们的方法将只请求数据。我们有以下内置的HTTP注解：
- en: '`POST`: This is used when we want to send data to the server'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：当我们想要向服务器发送数据时使用'
- en: '`PUT`: This is used when we want to update data on the server'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 当我们想要在服务器上更新数据时使用'
- en: '`DELETE`: This is used when we want to delete data from the server'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 当我们想要从服务器删除数据时使用'
- en: '`HEAD`: This method asks for a response identical to the one that would correspond
    to a `GET` request but without the response body'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`: 此方法请求与`GET`请求对应的响应，但不包含响应体'
- en: '`PATCH`: This is used when we want to update data partially on the server'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`: 当我们想要在服务器上部分更新数据时使用'
- en: '`OPTIONS`: This method requests permitted communication options for the target
    resource'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`: 此方法请求目标资源的允许通信选项'
- en: 'Back to our `fetchCats()` function, you can notice that we use the `@Query`
    annotation to specify the query parameter for our request. We use the `tag` query
    parameter to specify the type of cat we want to fetch. We also use the `suspend`
    keyword to specify that this method will be called from a coroutine or another
    `suspend` function. We will learn more about coroutines shortly in the *Introduction
    to Kotlin coroutines* section of this chapter. We also use the `Response` class
    to wrap up our response. This class is provided by Retrofit and it contains the
    HTTP response metadata such as response code, headers, and the raw response body.
    We also specify that the response will be a list of `Cat` objects. Retrofit will
    map the response to a list of `Cat` objects. To resolve the error for the `Cat`
    `data class`, let us create it. Create a new Kotlin data class inside the data
    package called `Cat.kt` and add the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`fetchCats()`函数，你可以注意到我们使用`@Query`注解来指定请求的查询参数。我们使用`tag`查询参数来指定我们想要获取的猫的类型。我们还使用`suspend`关键字来指定此方法将从协程或另一个`suspend`函数中调用。我们将在本章的“Kotlin协程简介”部分稍后了解更多关于协程的内容。我们还使用`Response`类来封装我们的响应。这个类由Retrofit提供，它包含HTTP响应元数据，如响应代码、头信息和原始响应体。我们还指定响应将是一个`Cat`对象的列表。Retrofit将响应映射到`Cat`对象的列表。为了解决`Cat`数据类的错误，让我们创建它。在数据包中创建一个新的Kotlin数据类，命名为`Cat.kt`，并添加以下内容：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Cat` data class has the fields that correspond to the JSON response from
    the Cat as a Service API. It is also annotated with the `@Serializable` annotation.
    This annotation is provided by Kotlinx Serialization and it is used to mark a
    class as serializable. This annotation is required for all the classes that we
    want to serialize or deserialize. We have used the `@SerialName` annotation before
    each variable in our data class. The `@SerialName` is an annotation used to customize
    the mapping between Kotlin property names and the corresponding names used in
    the serialized form, such as JSON or other data interchange formats. This annotation
    allows you to specify a different name for a property when it is serialized or
    deserialized, providing flexibility in handling naming conventions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cat`数据类具有与猫作为服务的API的JSON响应对应的字段。它还注解了`@Serializable`注解。这个注解由Kotlinx Serialization提供，它用于标记一个类为可序列化。这个注解对于所有我们想要序列化或反序列化的类都是必需的。我们在数据类的每个变量之前都使用了`@SerialName`注解。`@SerialName`是一个用于自定义Kotlin属性名与序列化形式（如JSON或其他数据交换格式）中使用的对应名称之间的映射的注解。这个注解允许你在序列化或反序列化时为属性指定不同的名称，从而在处理命名约定时提供灵活性。'
- en: 'In our project, we are using Koin for dependency injection. So, we now need
    to create an instance of our `CatsAPI` class in our Koin modules. Let us head
    back to the `Module.kt` file and below the Retrofit instance add the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们使用Koin进行依赖注入。因此，我们现在需要在我们的Koin模块中创建我们的`CatsAPI`类的实例。让我们回到`Module.kt`文件，在Retrofit实例下方添加以下内容：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we get our Retrofit instance and use it to create an instance of our `CatsAPI`
    class, which we use to make the actual network requests. With that, our project
    is ready to make the network requests. But before that, let us learn more about
    Kotlin coroutines as we are going to modify our repository to use coroutines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取我们的Retrofit实例，并使用它来创建我们的`CatsAPI`类的实例，我们使用它来执行实际的网络请求。有了这个，我们的项目就准备好执行网络请求了。但在那之前，让我们更多地了解Kotlin协程，因为我们将修改我们的仓库以使用协程。
- en: Introduction to Kotlin coroutines
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin协程简介
- en: 'Coroutines, introduced by JetBrains for Kotlin, provide a way to write asynchronous
    code in a more readable and synchronous manner. We can use them to perform background
    tasks and they are a great way to perform network requests and long-running tasks
    such as reading and writing to a database. They do these tasks off the main thread
    and ensure that we don’t block our main thread while performing these operations.
    The main benefits of using coroutines are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains 为 Kotlin 引入的协程提供了一种以更易读和同步的方式编写异步代码的方法。我们可以使用它们来执行后台任务，并且它们是执行网络请求和长时间运行任务（如读取和写入数据库）的绝佳方式。它们在主线程之外执行这些任务，并确保我们在执行这些操作时不会阻塞主线程。使用协程的主要好处如下：
- en: They are lightweight and easy to use.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们轻量级且易于使用。
- en: They have built-in cancellation support.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有内置的取消支持。
- en: They lower the chances of apps having memory leaks.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们降低了应用出现内存泄漏的可能性。
- en: As mentioned in earlier chapters, Jetpack libraries also support and use coroutines.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前几章所述，Jetpack 库也支持并使用协程。
- en: We have already added the core and Android coroutines libraries in our app.
    Let us understand some coroutines basics before proceeding to use coroutines in
    our project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的应用中添加了核心和 Android 协程库。在继续在我们的项目中使用协程之前，让我们先了解一些协程的基础知识。
- en: Coroutine basics
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程基础
- en: 'In this section, we will be looking at different terms and concepts used in
    Kotlin coroutines:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Kotlin 协程中使用的不同术语和概念：
- en: '`suspend`: This is a keyword that is used to mark a function. A `suspend` function
    is a function that can be paused and resumed at a later time. We have already
    used this keyword in our `CatsAPI` class to mark the `fetchCats()` function as
    a `suspend` function. A `suspend` function can only be called from another `suspend`
    function or from a coroutine.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend`：这是一个用于标记函数的关键字。`suspend` 函数是一个可以在稍后暂停和恢复的函数。我们已经在我们的 `CatsAPI` 类中使用了这个关键字来标记
    `fetchCats()` 函数为一个 `suspend` 函数。`suspend` 函数只能从另一个 `suspend` 函数或从协程中调用。'
- en: '`launch` and `async` coroutine builders. `launch` is used to create a coroutine
    that does not return a result while `async` is used to create a coroutine that
    returns a result. The result is a `Deferred` object and we can use the `await()`
    method to get the result. Both of these builders return a `Job` object that we
    can use to check if the coroutine is still active or if it has been canceled.
    We can also use the job to wait for the coroutine to finish. A job ends when it’s
    completed or canceled.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch` 和 `async` 协程构建器。`launch` 用于创建一个不返回结果的协程，而 `async` 用于创建一个返回结果的协程。结果是
    `Deferred` 对象，我们可以使用 `await()` 方法来获取结果。这两个构建器都返回一个 `Job` 对象，我们可以使用它来检查协程是否仍然活跃或已被取消。我们还可以使用作业来等待协程完成。作业在完成或取消时结束。'
- en: '`launch` and `async` coroutine builders return a `Job` object which we use
    to manage the coroutine life cycle. We have a normal `Job` and `SupervisorJob`.
    A normal `Job` is canceled when any of its children fail. `SupervisorJob` is not
    canceled when any of its children fail. It is recommended to use `SupervisorJob`
    when we have multiple coroutines running concurrently.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch` 和 `async` 协程构建器返回一个 `Job` 对象，我们使用它来管理协程的生命周期。我们有一个普通的 `Job` 和 `SupervisorJob`。当一个普通的
    `Job` 的任何子任务失败时，它会被取消。`SupervisorJob` 在其任何子任务失败时不会被取消。当有多个协程同时运行时，建议使用 `SupervisorJob`。'
- en: '`launch` or `async` builders. It is responsible for knowing how long a coroutine
    will live. Every coroutine builder is defined as an extension function of scope.
    Coroutines cannot be launched without a scope. We have `GlobalScope`, which is
    a scope that is not tied to any life cycle. It is not recommended to use this
    scope as it can lead to memory leaks. In Android, the KTX libraries provide `viewModelScope`,
    which is a scope that is tied to `ViewModel`. We can use this scope to launch
    coroutines that will be canceled when `ViewModel` is destroyed. We also have `lifecycleScope`,
    which is a scope that is tied to an activity or fragment life cycle. We can use
    this scope to launch coroutines that will be canceled when the life cycle is destroyed.
    We can also create our own custom scopes if we want to launch coroutines that
    will be canceled when a custom life cycle is destroyed.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch` 或 `async` 构建器。它负责知道协程将存活多久。每个协程构建器都被定义为作用域的扩展函数。没有作用域就无法启动协程。我们有 `GlobalScope`，这是一个不与任何生命周期绑定的作用域。不建议使用此作用域，因为它可能导致内存泄漏。在
    Android 中，KTX 库提供了 `viewModelScope`，这是一个与 `ViewModel` 绑定的作用域。我们可以使用此作用域来启动当 `ViewModel`
    被销毁时将取消的协程。我们还有 `lifecycleScope`，这是一个与活动或片段生命周期绑定的作用域。我们可以使用此作用域来启动当生命周期被销毁时将取消的协程。如果我们想启动当自定义生命周期被销毁时将取消的协程，我们还可以创建自己的自定义作用域。'
- en: '`CoroutineContext` defines the behavior of our coroutines using elements such
    as the following:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoroutineContext` 使用如下元素定义了我们的协程的行为：'
- en: '`Job`: This manages the life cycle of the coroutine.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Job`: 这管理协程的生命周期。'
- en: '`CoroutineDispatcher`: This defines the thread on which the coroutine will
    run.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoroutineDispatcher`: 这定义了协程将在哪个线程上运行。'
- en: '`CoroutineName`: This defines the name of the coroutine.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoroutineName`: 这定义了协程的名称。'
- en: '`CoroutineExceptionHandler`: This handles uncaught exceptions in the coroutine.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoroutineExceptionHandler`: 这用于处理协程中的未捕获异常。'
- en: '`Dispatchers.Main`: This is the main thread. It is used when we need to interact
    with the UI in our coroutines.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Main`: 这是主线程。当我们需要在协程中与 UI 交互时使用它。'
- en: '`Dispatchers.IO`: This is a thread pool that is optimized for IO tasks such
    as reading and writing to a database or making network requests.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.IO`: 这是一个针对 IO 任务（如读取和写入数据库或进行网络请求）进行优化的线程池。'
- en: '`Dispatchers.Default`: This is a thread pool that is optimized for CPU-intensive
    tasks.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Default`: 这是一个针对 CPU 密集型任务进行优化的线程池。'
- en: '`Dispatchers.Unconfined`: This is a dispatcher that is not confined to any
    thread. It is used to create a coroutine that inherits the context of the parent
    coroutine.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Unconfined`: 这是一个不受任何线程限制的调度器。它用于创建一个继承父协程上下文的协程。'
- en: Inside coroutines, we can use the `withContext()` function to switch between
    different dispatchers. `withContext()` is a `suspend` function that switches the
    context of the coroutine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程内部，我们可以使用 `withContext()` 函数在不同的调度器之间切换。`withContext()` 是一个 `suspend` 函数，它切换协程的上下文。
- en: '`suspend` function. We can also use flows to perform asynchronous operations.
    Flows are `collect()` function to collect values from a flow. We have `StateFlow`
    and `SharedFlow`, which are types of flows. `StateFlow` is a flow that emits the
    current value to new collectors and emits new values to existing collectors. `SharedFlow`
    is a flow that emits new values to all collectors. We will be learning more about
    flows in the next chapter. In Android, we will normally use the two types of flows
    to emit data to our UI. We will see the usage of `StateFlow` in `ViewModel` as
    we refactor it to use coroutines.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend` 函数。我们还可以使用流来执行异步操作。流是 `collect()` 函数，用于从流中收集值。我们有 `StateFlow` 和 `SharedFlow`，它们是流的类型。`StateFlow`
    是一个向新收集器发出当前值并向现有收集器发出新值的流。`SharedFlow` 是一个向所有收集器发出新值的流。我们将在下一章中学习更多关于流的内容。在 Android
    中，我们通常使用这两种类型的流将数据发射到我们的 UI。我们将看到 `ViewModel` 在重构以使用协程时的 `StateFlow` 的用法。'
- en: With this understanding of the basics, in the next section, we will be refactoring
    our repository to use coroutines.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了基础知识之后，在下一节中，我们将重构我们的仓库以使用协程。
- en: Using Kotlin coroutines for network calls
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kotlin 协程进行网络调用
- en: In this section, we will refactor our repository to use coroutines. We will
    use `StateFlow` to emit data from `ViewModel` to the view layer. We will also
    use the `Dispatchers.IO` dispatcher to perform our network requests on a background
    thread.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重构我们的仓库以使用协程。我们将使用 `StateFlow` 从 `ViewModel` 发射数据到视图层。我们还将使用 `Dispatchers.IO`
    调度器在后台线程上执行我们的网络请求。
- en: 'Let us start by creating a `NetworkResult` `sealed class`, which will represent
    the different states of our network request:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个`NetworkResult` `sealed class`，它将表示我们的网络请求的不同状态：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `NetworkResult` class is a sealed class that has two subclasses. We have
    the `Success` data class that will be used to represent a successful network request.
    It has a data property that will be used to hold the data returned from the network
    request. We also have the `Error` class, which will be used to represent a failed
    network request. It has an `error` property that will be used to hold the error
    message returned from the network request. The sealed class encapsulates a generic
    data type `T`, which makes it easier for us to reuse the class in all our network
    calls. The `Success` data class also has a generic parameter for the same purpose.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkResult`类是一个密封类，有两个子类。我们有`Success`数据类，它将用于表示成功的网络请求。它有一个数据属性，用于存储从网络请求返回的数据。我们还有一个`Error`类，它将用于表示失败的网络请求。它有一个`error`属性，用于存储从网络请求返回的错误信息。密封类封装了一个泛型数据类型`T`，这使得我们更容易在所有网络调用中重用该类。`Success`数据类也有一个泛型参数，出于相同的目的。'
- en: 'Next, let us modify `PetsRepository` as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下方式修改`PetsRepository`：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have updated the interface to use the `NetworkResult` class. We have also
    marked the `getPets()` function as a `suspend` function. We will use this method
    to fetch the cats from the API. Next, let us modify `PetsRepositoryImpl` to add
    the changes from `PetsRepository`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了接口以使用`NetworkResult`类。我们还标记了`getPets()`函数为`suspend`函数。我们将使用此方法从API获取猫。接下来，让我们修改`PetsRepositoryImpl`以添加从`PetsRepository`的更改：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have changed a number of things here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们更改了多项内容：
- en: First, we added a constructor that takes in an instance of our `CatsAPI` class,
    which we will use to make our network requests. It also has a `dispatcher` parameter,
    which will be used to specify the dispatcher that we will use to perform our network
    requests. We will use the `Dispatchers.IO` dispatcher to perform our network requests
    on a background thread.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个构造函数，它接受我们的`CatsAPI`类的实例，我们将使用它来执行网络请求。它还有一个`dispatcher`参数，它将用于指定我们将用于执行网络请求的调度器。我们将使用`Dispatchers.IO`调度器在后台线程上执行我们的网络请求。
- en: We have also changed the return type of the `getPets()` function to `NetworkResult<List<Cat>>`.
    This is because we will return a `NetworkResult` object from this method.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将`getPets()`函数的返回类型更改为`NetworkResult<List<Cat>>`。这是因为我们将从这个方法返回一个`NetworkResult`对象。
- en: We use the `withContext()` function to switch the context of the coroutine to
    the `Dispatchers.IO` dispatcher. This ensures that the network request is performed
    on a background thread.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`withContext()`函数将协程的上下文切换到`Dispatchers.IO`调度器。这确保了网络请求是在后台线程上执行的。
- en: We have also wrapped our network request in a `try-catch` block. This is to
    ensure we catch all the errors that might occur during the network request.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还用`try-catch`块包裹了我们的网络请求。这是为了确保我们能够捕获网络请求过程中可能发生的所有错误。
- en: Inside our `try` block, we are making the network request using our `CatsAPI`
    instance. We use the `fetchCats()` method to make the request. We pass in the
    `cute` tag to specify the type of cats we want to fetch. We check if the response
    is successful. If it is, we return a `NetworkResult.Success` object with the response
    body. If it is not, we return a `NetworkResult.Error` object with the error message.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`try`块中，我们使用`CatsAPI`实例进行网络请求。我们使用`fetchCats()`方法进行请求。我们传入`cute`标签来指定我们想要获取的猫的类型。我们检查响应是否成功。如果是，我们返回一个包含响应体的`NetworkResult.Success`对象。如果不是，我们返回一个包含错误信息的`NetworkResult.Error`对象。
- en: Lastly, we catch all the exceptions that might occur during the network request
    and return a `NetworkResult.Error` object with the error message.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们捕获网络请求过程中可能发生的所有异常，并返回一个包含错误信息的`NetworkResult.Error`对象。
- en: 'In our Koin modules, we also need to change how we instantiate our repository.
    Let us head over to `Module.kt` and update the `PetsRepository` definition as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Koin模块中，我们还需要更改实例化我们的仓库的方式。让我们转到`Module.kt`并更新`PetsRepository`的定义如下：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We inject the `CatsAPI` instance and the `dispatcher` into our repository.
    We also declare the dispatcher as a single instance. Now we need to modify our
    `PetsViewModel` to accommodate these changes. To begin with, we need to create
    a state class that holds the state of our network request and exposes it to our
    view. Create a new Kotlin data class inside the `view` package called `PetsUIState.kt`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `CatsAPI` 实例和 `dispatcher` 注入到我们的仓库中。我们还声明 `dispatcher` 为一个单例实例。现在我们需要修改我们的
    `PetsViewModel` 以适应这些更改。首先，我们需要创建一个状态类来存储我们网络请求的状态，并将其暴露给我们的视图。在 `view` 包内创建一个新的
    Kotlin 数据类，命名为 `PetsUIState.kt`：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `PetsUIState` class is a data class that holds the state of our network
    request. It has three properties:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetsUIState` 类是一个数据类，用于存储我们网络请求的状态。它有三个属性：'
- en: '`isLoading`: This is a Boolean that is used to indicate whether the network
    request is loading or not.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading`：这是一个布尔值，用于指示网络请求是否正在加载。'
- en: '`pets`: This is a list of cats that will be returned from the network request.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pets`：这是一个将通过网络请求返回的猫的列表。'
- en: '`error`: This is a string that will be used to hold the error message returned
    from the network request.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：这是一个字符串，将用于存储从网络请求返回的错误信息。'
- en: 'Next, in `PetsViewModel`, let us create a variable that will hold the state
    of our network request:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `PetsViewModel` 中，让我们创建一个变量来存储我们网络请求的状态：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We use the `MutableStateFlow` class to hold the state of our network request.
    `MutableStateFlow` allows us to update the value of the state. We initialize it
    with an empty `PetsUIState` object. Next, let us update the `getPets()` method
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `MutableStateFlow` 类来存储我们网络请求的状态。`MutableStateFlow` 允许我们更新状态的值。我们用空的 `PetsUIState`
    对象初始化它。接下来，让我们更新 `getPets()` 方法如下：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we will break down the preceding code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将分解前面的代码：
- en: We update the value of the `petsUIState` variable to indicate that the network
    request is loading.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更新 `petsUIState` 变量的值以指示网络请求正在加载。
- en: We use `viewModelScope` to launch a coroutine. This ensures that the coroutine
    is canceled when the `ViewModel` is destroyed.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `viewModelScope` 来启动协程。这确保了当 `ViewModel` 被销毁时，协程会被取消。
- en: There is a `when` statement, which is a Kotlin pattern-matching feature to check
    the result of the network request. If the result is a `NetworkResult.Success`
    object, we update the value of `petsUIState` to indicate that the network request
    was successful and passed in the list of cats. If the result is a `NetworkResult.Error`
    object, we update the value of `petsUIState` to indicate that the network request
    failed and pass in the error message.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一个 `when` 语句，它是 Kotlin 的模式匹配功能，用于检查网络请求的结果。如果结果是 `NetworkResult.Success`
    对象，我们将更新 `petsUIState` 的值以指示网络请求成功，并传入猫的列表。如果结果是 `NetworkResult.Error` 对象，我们将更新
    `petsUIState` 的值以指示网络请求失败，并传入错误信息。
- en: 'In `PetsViewModel`, let us add a new `init` block that will call the `getPets()`
    function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PetsViewModel` 中，让我们添加一个新的 `init` 块，该块将调用 `getPets()` 函数：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will ensure that the `getPets()` function is called when `ViewModel` is
    created. We now need to update our `PetList` composable to accommodate these changes,
    too. We will also add more UI components since we need to show the loading state,
    images, and error messages. Let us start by adding a library that allows us to
    load images from a URL. We will use Coil ([https://coil-kt.github.io/coil/](https://coil-kt.github.io/coil/)),
    which is an image-loading library. In the versions catalog, let’s add the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在 `ViewModel` 创建时调用 `getPets()` 函数。我们现在需要更新我们的 `PetList` 可组合组件以适应这些更改，我们还将添加更多的
    UI 组件，因为我们需要显示加载状态、图片和错误信息。让我们先添加一个库，允许我们从 URL 加载图片。我们将使用 Coil ([https://coil-kt.github.io/coil/](https://coil-kt.github.io/coil/))，这是一个图片加载库。在版本目录中，让我们添加以下内容：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will also add the `coil-compose` dependency to our `compose` bundle so that
    it can be provided alongside other compose libraries. The updated compose bundle
    will be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把 `coil-compose` 依赖项添加到我们的 `compose` 包中，以便它可以与其他 `compose` 库一起提供。更新后的 `compose`
    包如下所示：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let us now create a new composable that displays an image and tags for each
    cat inside the `view` package called `PetListItem.kt` and add the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个新的可组合组件，用于在 `view` 包中的 `PetListItem.kt` 文件内显示每只猫的图片和标签，并添加以下内容：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This composable takes in a `Cat` object and displays the image and tags for
    the cat. We use the `AsyncImage` composable from the Coil library to load the
    image from the URL. We also use the `FlowRow` composable to display the tags for
    the cat. We use the `SuggestionChip` composable to display each tag. We display
    the image and tags in the `ElevatedCard` composable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合函数接收一个 `Cat` 对象，并显示猫咪的图片和标签。我们使用来自 Coil 库的 `AsyncImage` 组合函数从 URL 加载图片。我们还使用
    `FlowRow` 组合函数来显示猫咪的标签。我们使用 `SuggestionChip` 组合函数来显示每个标签。我们在 `ElevatedCard` 组合函数中显示图片和标签。
- en: 'Next, let us update our `PetList` composable to accommodate these changes.
    In the `PetList.kt` file, update the `PetList` composable as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新我们的 `PetList` 组合函数以适应这些更改。在 `PetList.kt` 文件中，按照以下方式更新 `PetList` 组合函数：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the breakdown of the preceding code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的分解：
- en: Same as before, we use the `koinViewModel()` function to get an instance of
    `PetsViewModel`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和之前一样，我们使用 `koinViewModel()` 函数来获取 `PetsViewModel` 的实例。
- en: We use the `collectAsStateWithLifecycle()` function to collect the state of
    our network request. This function is provided by the `lifecycle-runtime-compose`
    library. It is used to collect the state of a flow and automatically cancel the
    collection when the life cycle is destroyed. We use the `petsUIState` property
    of `PetsViewModel` to get the state of our network request.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `collectAsStateWithLifecycle()` 函数来收集我们的网络请求状态。这个函数由 `lifecycle-runtime-compose`
    库提供。它用于收集流程的状态，并在生命周期被销毁时自动取消收集。我们使用 `PetsViewModel` 的 `petsUIState` 属性来获取我们的网络请求状态。
- en: We have a `Column` composable that contains three `AnimatedVisibility` composables.
    The first one is used to display a `CircularProgressIndicator` when the network
    request is loading. The second one is used to display the list of cats when the
    network request is successful. The last one is used to display an error message
    when the network request fails.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个包含三个 `AnimatedVisibility` 组合函数的 `Column` 组合函数。第一个用于在网络请求加载时显示 `CircularProgressIndicator`。第二个用于在网络请求成功时显示猫咪列表。最后一个用于在网络请求失败时显示错误信息。
- en: 'The `collectAsStateWithLifecycle()` shows an error since we have not added
    its dependency. Let us add it to our libraries section in the versions catalog
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectAsStateWithLifecycle()` 显示错误，因为我们还没有添加其依赖项。让我们将其添加到版本目录中的库部分，如下所示：'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will also add it to our `compose` bundle so that it can be provided alongside
    other compose libraries. The updated compose bundle will be as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将将其添加到我们的 `compose` 包中，以便它可以与其他组合库一起提供。更新的组合包将如下所示：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Do a Gradle sync and the IDE will prompt you to add imports for the `collectAsStateWithLifecycle()`
    function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Gradle 同步，IDE 将提示您添加 `collectAsStateWithLifecycle()` 函数的导入。
- en: 'We have completed updating all our layers to use the new coroutines approach.
    Good work so far! One last thing: since our app is now fetching these items from
    an API hosted online, we need to add the `INTERNET` permission to our app. Open
    the `AndroidManifest.xml file` and add the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了将所有层更新为使用新的协程方法。到目前为止做得很好！最后一件事：由于我们的应用现在是从在线托管 API 获取这些项目，我们需要在我们的应用中添加
    `INTERNET` 权限。打开 `AndroidManifest.xml` 文件并添加以下内容：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the app and see if everything is working as expected. We can see a list
    of cute cats with their tags being displayed. We can also see the loading indicator
    when the network request is loading and the error message when the network request
    fails. We have successfully refactored our app to use coroutines.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用并查看一切是否按预期工作。我们可以看到显示标签的可爱猫咪列表。我们还可以在网络请求加载时看到加载指示器，在网络请求失败时看到错误信息。我们已经成功重构了我们的应用以使用协程。
- en: '![Figure 6.1 – Cute cats](img/B19779_06_01.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 可爱的猫咪](img/B19779_06_01.jpg)'
- en: Figure 6.1 – Cute cats
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 可爱的猫咪
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to perform network calls with Retrofit. Moreso,
    we learned how to take advantage of Kotlin coroutines to perform asynchronous
    network requests in our app and refactored our app to fetch some cute cats with
    Kotlin coroutines.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Retrofit 执行网络调用。更重要的是，我们学习了如何利用 Kotlin 协程在我们的应用中执行异步网络请求，并重构了我们的应用以使用
    Kotlin 协程获取一些可爱的猫咪。
- en: In the next chapter, we will be looking at another Jetpack library, **Jetpack
    Navigation**, to handle navigation in our app.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个 Jetpack 库，**Jetpack 导航**，以处理我们的应用中的导航。
