- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Calls with Kotlin Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the apps we use on our phones fetch data that is hosted online on a
    server. As such, we developers have to understand how to request and send data
    to the servers too. In this chapter, we will learn how to send and request data
    that is hosted online and display it in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to perform network calls with a networking
    library, **Retrofit**. We will learn how to consume **application programming
    interfaces** (**APIs**) using this library. Moreso, we will learn how to take
    advantage of **Kotlin coroutines** to perform asynchronous network requests in
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Retrofit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Kotlin coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kotlin coroutines for network calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Retrofit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrofit is a type-safe REST client for Android, Java, and Kotlin developed
    by Square. The library provides a powerful framework for authenticating and interacting
    with APIs and sending network requests with OkHttp. In this book, we will be using
    Retrofit to perform our network requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we will add the Retrofit dependencies using our newly created
    version catalog. Let’s define the versions in the `libs.versions.toml` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s define the libraries in the `libs.versions.toml` file in the libraries
    section of our versions catalog as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are adding these dependencies to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrofit**: As mentioned earlier, we will use Retrofit to perform our network
    requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrofit serialization**: This is a converter that uses **Kotlinx serialization**
    to convert Kotlin objects to and from JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coroutines**: We will use Kotlin coroutines to perform our network requests
    asynchronously. We will be learning more about coroutines shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kotlinx serialization JSON**: This is a Kotlin serialization library for
    JSON. We will use this to parse our JSON responses. We have other serialization
    libraries, such as Moshi and Gson, but we used the Kotlinx serialization library
    for the following reasons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kotlin-centric development**: Kotlinx serialization is designed with Kotlin
    in mind, providing seamless integration and native support for Kotlin serialization.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative syntax**: Kotlinx serialization uses a declarative syntax, leveraging
    Kotlin’s language features for concise and readable serialization code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compile-time safety**: Compile-time safety is a key feature, catching serialization-related
    errors during the compilation phase and reducing the likelihood of runtime errors.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom serialization strategies**: We have the flexibility to define custom
    serialization strategies for specific types or scenarios, offering fine-grained
    control over the serialization process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seamless integration with Kotlin ecosystem**: Being part of the Kotlin ecosystem,
    Kotlinx serialization integrates seamlessly with other Kotlin libraries and frameworks,
    contributing to a cohesive development experience.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OkHttp**: This is an HTTP client that is used to make network requests. It
    provides some utilities for working with Retrofit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these dependencies will be added together, so this is a chance for us to
    group them in our `libs.versions.toml` file, add this bundle below our Koin bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new bundle called `networking` and add all the dependencies
    that we specified earlier on. We have to sync the project for our changes to be
    added to the project. Tap on `libs.versions.toml` file. After syncing, let us
    start setting up the plugins and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in our project-level `build.gradle.kts` file, we need to add the Kotlinx
    serialization plugin. Open the project-level `build.gradle.kts` file and on the
    plugins block add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the Kotlinx serialization plugin and specify the version to use.
    This will set up the Kotlinx serialization plugin for us. The plugin generates
    Kotlin code for serializable classes. We will use this plugin to generate our
    models. Next, let us set up the plugin in our app module. Open the app-level `build.gradle.kts`
    file and add the following in the plugins block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures our module is set up to use the Kotlinx serialization plugin.
    Next, we will add our `networking` bundle to our app module. In the app-level
    `build.gradle.kts` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add all the dependencies that we have specified in our `networking`
    bundle. Having done all these, our project is set up to use Retrofit. We will
    be using Koin to create a Retrofit instance that will be injected into classes
    that need it. Let us head over to the `Module.kt` file and add the `PetsViewModel`
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a Retrofit instance using the Retrofit builder.
    We also added a converter factory that uses Kotlinx serialization to convert Kotlin
    objects to and from JSON. We also specified the base URL for our API. We are using
    the `CatsAPI.kt` and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use the `@GET` annotation to specify that we will
    be using the `GET` HTTP method for this request. Inside the method, we are also
    specifying a path that will be appended to our base URL to make the full URL for
    our request. Using the `GET` method means our method will only request data. We
    have the following built-in HTTP annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST`: This is used when we want to send data to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This is used when we want to update data on the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This is used when we want to delete data from the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: This method asks for a response identical to the one that would correspond
    to a `GET` request but without the response body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: This is used when we want to update data partially on the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: This method requests permitted communication options for the target
    resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Back to our `fetchCats()` function, you can notice that we use the `@Query`
    annotation to specify the query parameter for our request. We use the `tag` query
    parameter to specify the type of cat we want to fetch. We also use the `suspend`
    keyword to specify that this method will be called from a coroutine or another
    `suspend` function. We will learn more about coroutines shortly in the *Introduction
    to Kotlin coroutines* section of this chapter. We also use the `Response` class
    to wrap up our response. This class is provided by Retrofit and it contains the
    HTTP response metadata such as response code, headers, and the raw response body.
    We also specify that the response will be a list of `Cat` objects. Retrofit will
    map the response to a list of `Cat` objects. To resolve the error for the `Cat`
    `data class`, let us create it. Create a new Kotlin data class inside the data
    package called `Cat.kt` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Cat` data class has the fields that correspond to the JSON response from
    the Cat as a Service API. It is also annotated with the `@Serializable` annotation.
    This annotation is provided by Kotlinx Serialization and it is used to mark a
    class as serializable. This annotation is required for all the classes that we
    want to serialize or deserialize. We have used the `@SerialName` annotation before
    each variable in our data class. The `@SerialName` is an annotation used to customize
    the mapping between Kotlin property names and the corresponding names used in
    the serialized form, such as JSON or other data interchange formats. This annotation
    allows you to specify a different name for a property when it is serialized or
    deserialized, providing flexibility in handling naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we are using Koin for dependency injection. So, we now need
    to create an instance of our `CatsAPI` class in our Koin modules. Let us head
    back to the `Module.kt` file and below the Retrofit instance add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get our Retrofit instance and use it to create an instance of our `CatsAPI`
    class, which we use to make the actual network requests. With that, our project
    is ready to make the network requests. But before that, let us learn more about
    Kotlin coroutines as we are going to modify our repository to use coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Kotlin coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coroutines, introduced by JetBrains for Kotlin, provide a way to write asynchronous
    code in a more readable and synchronous manner. We can use them to perform background
    tasks and they are a great way to perform network requests and long-running tasks
    such as reading and writing to a database. They do these tasks off the main thread
    and ensure that we don’t block our main thread while performing these operations.
    The main benefits of using coroutines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They are lightweight and easy to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have built-in cancellation support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They lower the chances of apps having memory leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in earlier chapters, Jetpack libraries also support and use coroutines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already added the core and Android coroutines libraries in our app.
    Let us understand some coroutines basics before proceeding to use coroutines in
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutine basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will be looking at different terms and concepts used in
    Kotlin coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`suspend`: This is a keyword that is used to mark a function. A `suspend` function
    is a function that can be paused and resumed at a later time. We have already
    used this keyword in our `CatsAPI` class to mark the `fetchCats()` function as
    a `suspend` function. A `suspend` function can only be called from another `suspend`
    function or from a coroutine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch` and `async` coroutine builders. `launch` is used to create a coroutine
    that does not return a result while `async` is used to create a coroutine that
    returns a result. The result is a `Deferred` object and we can use the `await()`
    method to get the result. Both of these builders return a `Job` object that we
    can use to check if the coroutine is still active or if it has been canceled.
    We can also use the job to wait for the coroutine to finish. A job ends when it’s
    completed or canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch` and `async` coroutine builders return a `Job` object which we use
    to manage the coroutine life cycle. We have a normal `Job` and `SupervisorJob`.
    A normal `Job` is canceled when any of its children fail. `SupervisorJob` is not
    canceled when any of its children fail. It is recommended to use `SupervisorJob`
    when we have multiple coroutines running concurrently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch` or `async` builders. It is responsible for knowing how long a coroutine
    will live. Every coroutine builder is defined as an extension function of scope.
    Coroutines cannot be launched without a scope. We have `GlobalScope`, which is
    a scope that is not tied to any life cycle. It is not recommended to use this
    scope as it can lead to memory leaks. In Android, the KTX libraries provide `viewModelScope`,
    which is a scope that is tied to `ViewModel`. We can use this scope to launch
    coroutines that will be canceled when `ViewModel` is destroyed. We also have `lifecycleScope`,
    which is a scope that is tied to an activity or fragment life cycle. We can use
    this scope to launch coroutines that will be canceled when the life cycle is destroyed.
    We can also create our own custom scopes if we want to launch coroutines that
    will be canceled when a custom life cycle is destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoroutineContext` defines the behavior of our coroutines using elements such
    as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Job`: This manages the life cycle of the coroutine.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoroutineDispatcher`: This defines the thread on which the coroutine will
    run.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoroutineName`: This defines the name of the coroutine.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoroutineExceptionHandler`: This handles uncaught exceptions in the coroutine.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.Main`: This is the main thread. It is used when we need to interact
    with the UI in our coroutines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.IO`: This is a thread pool that is optimized for IO tasks such
    as reading and writing to a database or making network requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.Default`: This is a thread pool that is optimized for CPU-intensive
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatchers.Unconfined`: This is a dispatcher that is not confined to any
    thread. It is used to create a coroutine that inherits the context of the parent
    coroutine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside coroutines, we can use the `withContext()` function to switch between
    different dispatchers. `withContext()` is a `suspend` function that switches the
    context of the coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '`suspend` function. We can also use flows to perform asynchronous operations.
    Flows are `collect()` function to collect values from a flow. We have `StateFlow`
    and `SharedFlow`, which are types of flows. `StateFlow` is a flow that emits the
    current value to new collectors and emits new values to existing collectors. `SharedFlow`
    is a flow that emits new values to all collectors. We will be learning more about
    flows in the next chapter. In Android, we will normally use the two types of flows
    to emit data to our UI. We will see the usage of `StateFlow` in `ViewModel` as
    we refactor it to use coroutines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this understanding of the basics, in the next section, we will be refactoring
    our repository to use coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kotlin coroutines for network calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will refactor our repository to use coroutines. We will
    use `StateFlow` to emit data from `ViewModel` to the view layer. We will also
    use the `Dispatchers.IO` dispatcher to perform our network requests on a background
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by creating a `NetworkResult` `sealed class`, which will represent
    the different states of our network request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `NetworkResult` class is a sealed class that has two subclasses. We have
    the `Success` data class that will be used to represent a successful network request.
    It has a data property that will be used to hold the data returned from the network
    request. We also have the `Error` class, which will be used to represent a failed
    network request. It has an `error` property that will be used to hold the error
    message returned from the network request. The sealed class encapsulates a generic
    data type `T`, which makes it easier for us to reuse the class in all our network
    calls. The `Success` data class also has a generic parameter for the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us modify `PetsRepository` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have updated the interface to use the `NetworkResult` class. We have also
    marked the `getPets()` function as a `suspend` function. We will use this method
    to fetch the cats from the API. Next, let us modify `PetsRepositoryImpl` to add
    the changes from `PetsRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have changed a number of things here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we added a constructor that takes in an instance of our `CatsAPI` class,
    which we will use to make our network requests. It also has a `dispatcher` parameter,
    which will be used to specify the dispatcher that we will use to perform our network
    requests. We will use the `Dispatchers.IO` dispatcher to perform our network requests
    on a background thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also changed the return type of the `getPets()` function to `NetworkResult<List<Cat>>`.
    This is because we will return a `NetworkResult` object from this method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `withContext()` function to switch the context of the coroutine to
    the `Dispatchers.IO` dispatcher. This ensures that the network request is performed
    on a background thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also wrapped our network request in a `try-catch` block. This is to
    ensure we catch all the errors that might occur during the network request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside our `try` block, we are making the network request using our `CatsAPI`
    instance. We use the `fetchCats()` method to make the request. We pass in the
    `cute` tag to specify the type of cats we want to fetch. We check if the response
    is successful. If it is, we return a `NetworkResult.Success` object with the response
    body. If it is not, we return a `NetworkResult.Error` object with the error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we catch all the exceptions that might occur during the network request
    and return a `NetworkResult.Error` object with the error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our Koin modules, we also need to change how we instantiate our repository.
    Let us head over to `Module.kt` and update the `PetsRepository` definition as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We inject the `CatsAPI` instance and the `dispatcher` into our repository.
    We also declare the dispatcher as a single instance. Now we need to modify our
    `PetsViewModel` to accommodate these changes. To begin with, we need to create
    a state class that holds the state of our network request and exposes it to our
    view. Create a new Kotlin data class inside the `view` package called `PetsUIState.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PetsUIState` class is a data class that holds the state of our network
    request. It has three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isLoading`: This is a Boolean that is used to indicate whether the network
    request is loading or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pets`: This is a list of cats that will be returned from the network request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This is a string that will be used to hold the error message returned
    from the network request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, in `PetsViewModel`, let us create a variable that will hold the state
    of our network request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `MutableStateFlow` class to hold the state of our network request.
    `MutableStateFlow` allows us to update the value of the state. We initialize it
    with an empty `PetsUIState` object. Next, let us update the `getPets()` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will break down the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We update the value of the `petsUIState` variable to indicate that the network
    request is loading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `viewModelScope` to launch a coroutine. This ensures that the coroutine
    is canceled when the `ViewModel` is destroyed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a `when` statement, which is a Kotlin pattern-matching feature to check
    the result of the network request. If the result is a `NetworkResult.Success`
    object, we update the value of `petsUIState` to indicate that the network request
    was successful and passed in the list of cats. If the result is a `NetworkResult.Error`
    object, we update the value of `petsUIState` to indicate that the network request
    failed and pass in the error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `PetsViewModel`, let us add a new `init` block that will call the `getPets()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that the `getPets()` function is called when `ViewModel` is
    created. We now need to update our `PetList` composable to accommodate these changes,
    too. We will also add more UI components since we need to show the loading state,
    images, and error messages. Let us start by adding a library that allows us to
    load images from a URL. We will use Coil ([https://coil-kt.github.io/coil/](https://coil-kt.github.io/coil/)),
    which is an image-loading library. In the versions catalog, let’s add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add the `coil-compose` dependency to our `compose` bundle so that
    it can be provided alongside other compose libraries. The updated compose bundle
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now create a new composable that displays an image and tags for each
    cat inside the `view` package called `PetListItem.kt` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This composable takes in a `Cat` object and displays the image and tags for
    the cat. We use the `AsyncImage` composable from the Coil library to load the
    image from the URL. We also use the `FlowRow` composable to display the tags for
    the cat. We use the `SuggestionChip` composable to display each tag. We display
    the image and tags in the `ElevatedCard` composable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us update our `PetList` composable to accommodate these changes.
    In the `PetList.kt` file, update the `PetList` composable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Same as before, we use the `koinViewModel()` function to get an instance of
    `PetsViewModel`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `collectAsStateWithLifecycle()` function to collect the state of
    our network request. This function is provided by the `lifecycle-runtime-compose`
    library. It is used to collect the state of a flow and automatically cancel the
    collection when the life cycle is destroyed. We use the `petsUIState` property
    of `PetsViewModel` to get the state of our network request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a `Column` composable that contains three `AnimatedVisibility` composables.
    The first one is used to display a `CircularProgressIndicator` when the network
    request is loading. The second one is used to display the list of cats when the
    network request is successful. The last one is used to display an error message
    when the network request fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `collectAsStateWithLifecycle()` shows an error since we have not added
    its dependency. Let us add it to our libraries section in the versions catalog
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add it to our `compose` bundle so that it can be provided alongside
    other compose libraries. The updated compose bundle will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Do a Gradle sync and the IDE will prompt you to add imports for the `collectAsStateWithLifecycle()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have completed updating all our layers to use the new coroutines approach.
    Good work so far! One last thing: since our app is now fetching these items from
    an API hosted online, we need to add the `INTERNET` permission to our app. Open
    the `AndroidManifest.xml file` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Run the app and see if everything is working as expected. We can see a list
    of cute cats with their tags being displayed. We can also see the loading indicator
    when the network request is loading and the error message when the network request
    fails. We have successfully refactored our app to use coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Cute cats](img/B19779_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Cute cats
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to perform network calls with Retrofit. Moreso,
    we learned how to take advantage of Kotlin coroutines to perform asynchronous
    network requests in our app and refactored our app to fetch some cute cats with
    Kotlin coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at another Jetpack library, **Jetpack
    Navigation**, to handle navigation in our app.
  prefs: []
  type: TYPE_NORMAL
