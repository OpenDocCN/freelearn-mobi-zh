- en: Converting Your Game from 2D to 3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, be aware that making a 3D game from scratch in Android Studio is a Herculean
    task. It isn't absolutely essential to make a game from scratch in 3D because
    there are plenty of tools and game engines available on the market, which eliminate
    the requirement of having to work on creating everything from scratch. However,
    an understanding of how the nuts and bolts operate behind the scenes will definitely
    help you in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn the basics of some advanced concepts in this chapter, and by
    the end of this chapter, you will have an understanding of how to create a basic
    3D object in Android Studio. For the purpose of this chapter, we will create a
    new Android Studio project since we will not continue in our previous game project
    folder. However, before we get started, let''s take a look at the concepts that
    we will be learning in brief. We will learn the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OpenGL ES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the 3D coordinate system using OpenGL ES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scene using OpenGL ES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project folder
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Render class and main activity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining shapes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To create our 3D graphics, we will use OpenGL ES for rendering our graphics.
    Let's understand what OpenGL ES is.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-performance 2D and 3D graphics are supported on Android with the OpenGL
    library. We have the OpenGL ES API, which is used for this. This API specifies
    the interface for 3D graphics processing hardware. OpenGL is a huge library and
    from that, a part of it is OpenGL ES which is specifically created for embedded
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various versions of the OpenGL ES API supported on Android are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.0 and 1.1: Supported by Android 1.0 and higher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2.0: Supported by Android 2.2 (API level 8) and higher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3.0: Supported by Android 4.3 (API level 18) and higher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3.1: Supported by Android 5.0 (API level 21) and higher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more general information about this on the official website for Android
    here at [https://developer.android.com/guide/topics/graphics/opengl.html](https://developer.android.com/guide/topics/graphics/opengl.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using OpenGL ES, you can create 3D graphics on Android. Since we will be creating
    3D objects, we will need to understand the coordinate system. Let's take a quick
    look at the 3D coordinates system that we will use for our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the 3D coordinate system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While making our 2D game, we were only dealing with *x* and *y* axis values.
    However, when you are making a 3D game, you have to deal with three axis values:
    *x*, *y*, and *z*. We''re pretty much clear how our *x* and *y* axis values work
    by now. In a similar way, our *z* axis is projected on the front and back of our
    mobile device. The following image will explain the three axes in our 3D coordinate
    system better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: The positive x, y, and z axis on phone
  prefs: []
  type: TYPE_NORMAL
- en: The axes you see in the preceding image are positive directions. If you take
    their opposite sides, you will get negative values. The origin point starts from
    (0,0,0), and your values can be float values that will denote your object's location
    in 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a classic problem that you might encounter while dealing with OpenGL
    in terms of device screen sizes. The grid in OpenGL assumes a screen, which is
    square and has a uniform coordinate system. However, if your screen size varies,
    then a non-square screen is considered as if it is a perfectly square screen.
    In order to understand this, take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the default OpenGL coordinate system
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, we have two different screens, one is
    square shaped and the other is a rectangle. Now, what happens here is that even
    though your screen is a rectangle, it is considered a square and because of that,
    your graphics get stretched. To tackle this issue, you need to apply OpenGL projection
    modes and camera views to transform the coordinates in order to get a proper proportion
    on any display.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we create a projection matrix and a camera view matrix, and then apply
    that to our OpenGL rendering pipeline. The projection matrix helps us to process
    the coordinates by recalculating the matrix of our graphics so that they are mapped
    correctly onto our device screens. The camera view matrix helps create a transformation
    that renders the object from a specific eye position.
  prefs: []
  type: TYPE_NORMAL
- en: You can read up more about OpenGL ES over at [https://en.wikipedia.org/wiki/OpenGL_ES](https://en.wikipedia.org/wiki/OpenGL_ES).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about these basic concepts, we can get started with
    creating our 3D game scene using OpenGL ES in Android; let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 3D scene with OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we did in our 2D game example, most of our draw mechanism is going to
    remain the same. You will see that there are many similarities between both procedures.
    We will be working on a new project folder for this example, so let's go ahead
    and create a new project as we did in [Chapter 8](1942c8c2-08a2-4c18-8740-8b7e9103bc6e.xhtml),
    *Adding Explosion and Creating a UI*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our project folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will follow the steps we did in [Chapter 2](9563ed54-bb46-4d59-9225-ed418d3e0b29.xhtml),
    *Getting Familiar with Android Studio*. First, we will create a new project from
    our top menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new project, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to File | New | New Project..., as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B05066_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fill in your Application name, Company domain, and Package name details; then
    click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B05066_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select your target devices and click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B05066_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Empty Activity and click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B05066_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fill in your Activity Name, Layout Name, and click on Finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B05066_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Okay then, we are now set with our new project folder. Also, we will use the
    landscape mode orientation for this project, so we will define it in our `AndroidManifest.xml`
    file. Open up your manifest file from the `app/manifests/AndroidManifest.xml`
    file and make the following change that is marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's now define our main activity and create a render class for our 3D game
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a render class and defining a main activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to see anything on the screen, we have to render it on screen. Therefore,
    we need to create a render class that will handle the rendering part of our functioning.
    Rendering is the process of generating an image from a 2D or 3D model by means
    of computer programs. We will name our render class as `MyGLRenderer`, but before
    we do that, let''s define our main activity. So, open up your `MainActivity.java`
    file, and we will create three default methods there. Remove everything you see
    on screen, except for the first line that''s your package name. We will have three
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreate()`: This initializes our main activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPause()`: This handles the app if it goes into background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResume()`: After the user resumes back to the app, this method is called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we are dealing with OpenGL graphics here, and for that reason, we will
    need a `GLSurfaceView`, just as we worked in our 2D game wherein we had a surface
    view for our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create them in our `MainActivity.java` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that seems sorted, but now we are getting an error on our `MyGLRenderer`
    line. That's because we still haven't made our renderer class yet. Let's make
    our renderer class now. Create a new Java class file named `MyGLRenderer.java`,
    and let's get started with writing our renderer class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Renderer` class is where you will do most of your object displaying part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface `GLSurfaceView.Renderer` is responsible for making OpenGL render
    a frame, hence we will need to implement it as an interface in our code; so we
    will start with our very first line, which will do the same. We will extend our
    class to the `GLSurfaceView.Renderer` interface and write a default constructor,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, inside this class, as we had in our 2D sprite example game, we will need
    three methods to draw on the screen; they are `onSurfaceCreated()`, `onSurfaceChanged()`,
    and `onDraw()`. However, in OpenGL, the `onDraw()` method is actually `onDrawFrame()`,
    so let's define those three methods one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will start with our `onSurfaceChanged()` method. In this method,
    we will create our surface. This method is for the initialization of our scene.
    Here, we will create a simple black screen drawn on the screen. In order to set
    our color, we will use RGBA values. For a black color, we will need (0,0,0,1)
    RGBA values. We will also add in some more initialization factors here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These parameters are basically required to set various aspects in an OpenGL
    ES environment. You can read up more about these specific methods and more through
    [https://www.khronos.org/registry/OpenGL-Refpages/es3.0/](https://www.khronos.org/registry/OpenGL-Refpages/es3.0/).
  prefs: []
  type: TYPE_NORMAL
- en: 'This method gets called after the `onSurfaceCreated()` method and also every
    time our screen resolution changes. Basically, this method is responsible for
    creating the display matrix that we saw earlier in the chapter, which in turn
    creates a uniform shape on any screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have our `onDrawFrame()` function, which is used to draw the current
    frame. After every frame, we need to clear the previous screen drawn, and for
    that reason, we call `glClear()` in this before we render any code further. Right
    now, we will just write our clear code and when we will draw our object shapes
    in this function after our clear code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this is how your entire code will look like for your `Renderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will learn how to define and draw, or in proper terms *render*, our
    3D objects on the screen. First, we will start with a basic triangle shape and
    then we will draw a pyramid, then we will make both of them rotate on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Defining shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to draw something on the screen, we first need to define its shape
    and then render it. So we won't define our shape in our render class. We will
    create a new class in order to define our shape. As discussed, we will first create
    a basic triangle.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create our triangle, we need to first define its vertices. So, let's
    create a new class named `Triangle.java` and start writing our logic to define
    the shape of our 3D triangle. Before we start writing our code, let's try to understand
    what we are actually going to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take vertices and plot them on our screen. Also, as you saw previously
    how OpenGL coordinates work, we will plot our vertices in all three directions.
    For our triangle, we require three points to be plotted. So, we will plot one
    point on the positive **y-axis** and the other two points on the positive and
    negative x-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plotting our triangle
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will take a three-dimensional array of our vertices and
    define them as a variable in our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That takes care of our vertices, and we have defined its shape, well somewhat,
    but of course, there''s more to it. We also need to define a vertex buffer and
    transfer this data into it. To do so, we will define our vertex buffer variable
    as nio''s buffer, as they are placed on the native heap and are not garbage collected.
    We will do the same for our index buffer, which will arrange our triangle in a
    counter-clockwise (CCW) direction with positive *z* direction facing toward the
    screen. So, first we will define our `vertexBuffer` and `indexBuffer` variables,
    and then in our default constructor, we will set up our `vertexBuffer` and `indexBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, now that''s taken care of, we also have to actually draw our triangle
    on screen; for this, we will use our `draw()` method. To do so, we will go through
    the following four simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We enable vertex array client states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify the location of the buffers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We render our primitive shapes using `glDrayElements()` that uses index array
    to reference the vertex array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We disable our vertex array client state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have understood the working of its theory, let''s go ahead and
    do this in practice by writing it out in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our shape is defined perfectly, and our entire code block for the `Triangle.java`
    file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, if you deploy this to your device, you won't be able to see your triangle
    on the screen. This is because we still haven't rendered it on our screen yet.
    Remember how we discussed rendering all our objects using the help of the `MyGLRenderer`
    file? We haven't told that file to use our triangle to be rendered, but that's
    it for this chapter. We will cover the rendering of our object in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how to transition from a 2D to a 3D game along
    with concepts of OpenGL. We also learned how to create our main activity along
    with our own renderer. After this, we learned how to define a basic shape.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we covered the following topics in this chapter. We got introduced
    to OpenGL ES and took a look at the coordinates system in the same. We learned
    how to create a blank scene and the process of rendering. We then created our
    basic renderer and defined our triangle shape.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will learn how to render our defined shape on the screen
    and rotate it. We will also learn how to create a 3D pyramid in the next chapter,
    and by the end of the next chapter, you will complete this book and  also have
    a foundation for creating a 2D and 3D game.
  prefs: []
  type: TYPE_NORMAL
