- en: Converting Your Game from 2D to 3D
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的游戏从2D转换为3D
- en: Now, be aware that making a 3D game from scratch in Android Studio is a Herculean
    task. It isn't absolutely essential to make a game from scratch in 3D because
    there are plenty of tools and game engines available on the market, which eliminate
    the requirement of having to work on creating everything from scratch. However,
    an understanding of how the nuts and bolts operate behind the scenes will definitely
    help you in the long run.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，在Android Studio中从头开始制作3D游戏是一项艰巨的任务。并不是绝对必要在3D中从头开始制作游戏，因为市场上有很多工具和游戏引擎可用，这些工具和引擎消除了从头开始创建一切的需求。然而，了解幕后如何操作的知识将肯定有助于你长期发展。
- en: 'We will learn the basics of some advanced concepts in this chapter, and by
    the end of this chapter, you will have an understanding of how to create a basic
    3D object in Android Studio. For the purpose of this chapter, we will create a
    new Android Studio project since we will not continue in our previous game project
    folder. However, before we get started, let''s take a look at the concepts that
    we will be learning in brief. We will learn the following concepts in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些高级概念的基础知识，到本章结束时，你将了解如何在Android Studio中创建基本3D对象。为了本章的目的，我们将创建一个新的Android
    Studio项目，因为我们不会继续在先前的游戏项目文件夹中继续。然而，在我们开始之前，让我们简要地看看我们将学习的概念。在本章中，我们将学习以下概念：
- en: Introduction to OpenGL ES
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES简介
- en: Learning about the 3D coordinate system using OpenGL ES
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenGL ES学习3D坐标系
- en: Creating a scene using OpenGL ES
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenGL ES创建场景
- en: Project folder
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件夹
- en: Render class and main activity
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染类和主活动
- en: Defining shapes
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义形状
- en: To create our 3D graphics, we will use OpenGL ES for rendering our graphics.
    Let's understand what OpenGL ES is.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的3D图形，我们将使用OpenGL ES进行渲染。让我们了解OpenGL ES是什么。
- en: Introduction to OpenGL ES
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES简介
- en: High-performance 2D and 3D graphics are supported on Android with the OpenGL
    library. We have the OpenGL ES API, which is used for this. This API specifies
    the interface for 3D graphics processing hardware. OpenGL is a huge library and
    from that, a part of it is OpenGL ES which is specifically created for embedded
    devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，通过OpenGL库支持高性能的2D和3D图形。我们使用OpenGL ES API，该API用于此。此API指定了3D图形处理硬件的接口。OpenGL是一个庞大的库，其中一部分是OpenGL
    ES，它是专门为嵌入式设备创建的。
- en: 'The various versions of the OpenGL ES API supported on Android are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上支持的OpenGL ES API的各个版本如下：
- en: '1.0 and 1.1: Supported by Android 1.0 and higher'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.0和1.1：支持Android 1.0及更高版本
- en: '2.0: Supported by Android 2.2 (API level 8) and higher'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.0：支持Android 2.2（API级别8）及更高版本
- en: '3.0: Supported by Android 4.3 (API level 18) and higher'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.0：支持Android 4.3（API级别18）及更高版本
- en: '3.1: Supported by Android 5.0 (API level 21) and higher'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.1：支持Android 5.0（API级别21）及更高版本
- en: You can read more general information about this on the official website for Android
    here at [https://developer.android.com/guide/topics/graphics/opengl.html](https://developer.android.com/guide/topics/graphics/opengl.html).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Android官方网站上阅读更多关于此的信息：[https://developer.android.com/guide/topics/graphics/opengl.html](https://developer.android.com/guide/topics/graphics/opengl.html)。
- en: Using OpenGL ES, you can create 3D graphics on Android. Since we will be creating
    3D objects, we will need to understand the coordinate system. Let's take a quick
    look at the 3D coordinates system that we will use for our examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenGL ES，你可以在Android上创建3D图形。由于我们将创建3D对象，我们需要了解坐标系。让我们快速看一下我们将用于我们示例的3D坐标系。
- en: Learning about the 3D coordinate system
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习3D坐标系
- en: 'While making our 2D game, we were only dealing with *x* and *y* axis values.
    However, when you are making a 3D game, you have to deal with three axis values:
    *x*, *y*, and *z*. We''re pretty much clear how our *x* and *y* axis values work
    by now. In a similar way, our *z* axis is projected on the front and back of our
    mobile device. The following image will explain the three axes in our 3D coordinate
    system better:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作我们的2D游戏时，我们只处理*x*和*y*轴的值。然而，当你制作3D游戏时，你必须处理三个轴的值：*x*、*y*和*z*。到目前为止，我们对*x*和*y*轴的值是如何工作的已经很清楚。以类似的方式，我们的*z*轴被投影到我们移动设备的正面和背面。以下图像将更好地解释我们3D坐标系中的三个轴：
- en: '![](img/B05066_09_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_09_01.png)'
- en: The positive x, y, and z axis on phone
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 手机上的正*x*、*y*和*z*轴
- en: The axes you see in the preceding image are positive directions. If you take
    their opposite sides, you will get negative values. The origin point starts from
    (0,0,0), and your values can be float values that will denote your object's location
    in 3D space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中您看到的轴是正方向。如果您取它们的相反方向，您将得到负值。原点从(0,0,0)开始，您的值可以是浮点值，这将表示您的对象在3D空间中的位置。
- en: 'Here''s a classic problem that you might encounter while dealing with OpenGL
    in terms of device screen sizes. The grid in OpenGL assumes a screen, which is
    square and has a uniform coordinate system. However, if your screen size varies,
    then a non-square screen is considered as if it is a perfectly square screen.
    In order to understand this, take a look at the following figure:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个您在处理OpenGL时可能会遇到的一个经典问题，与设备屏幕尺寸有关。OpenGL中的网格假设一个屏幕，它是正方形并且具有统一的坐标系统。然而，如果您的屏幕尺寸不同，那么非正方形屏幕被视为一个完美的正方形屏幕。为了理解这一点，请看以下图示：
- en: '![](img/B05066_09_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_09_02.jpg)'
- en: Understanding the default OpenGL coordinate system
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解默认的OpenGL坐标系统
- en: As you can see in the preceding figure, we have two different screens, one is
    square shaped and the other is a rectangle. Now, what happens here is that even
    though your screen is a rectangle, it is considered a square and because of that,
    your graphics get stretched. To tackle this issue, you need to apply OpenGL projection
    modes and camera views to transform the coordinates in order to get a proper proportion
    on any display.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有两个不同的屏幕，一个是正方形形状的，另一个是矩形的。现在，这里发生的情况是，尽管您的屏幕是矩形，但它被视为正方形，因此您的图形被拉伸。为了解决这个问题，您需要应用OpenGL投影模式和相机视图来变换坐标，以便在任何显示上获得适当的比例。
- en: To do so, we create a projection matrix and a camera view matrix, and then apply
    that to our OpenGL rendering pipeline. The projection matrix helps us to process
    the coordinates by recalculating the matrix of our graphics so that they are mapped
    correctly onto our device screens. The camera view matrix helps create a transformation
    that renders the object from a specific eye position.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们创建一个投影矩阵和一个相机视图矩阵，然后将它们应用到我们的OpenGL渲染管线中。投影矩阵帮助我们通过重新计算我们的图形矩阵来处理坐标，以便它们正确地映射到我们的设备屏幕上。相机视图矩阵帮助创建一个变换，从特定的眼睛位置渲染对象。
- en: You can read up more about OpenGL ES over at [https://en.wikipedia.org/wiki/OpenGL_ES](https://en.wikipedia.org/wiki/OpenGL_ES).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://en.wikipedia.org/wiki/OpenGL_ES](https://en.wikipedia.org/wiki/OpenGL_ES)了解更多关于OpenGL
    ES的信息。
- en: Now that we have learned about these basic concepts, we can get started with
    creating our 3D game scene using OpenGL ES in Android; let's begin!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些基本概念，我们可以开始使用OpenGL ES在Android中创建我们的3D游戏场景；让我们开始吧！
- en: Creating a 3D scene with OpenGL ES
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenGL ES创建3D场景
- en: Just as we did in our 2D game example, most of our draw mechanism is going to
    remain the same. You will see that there are many similarities between both procedures.
    We will be working on a new project folder for this example, so let's go ahead
    and create a new project as we did in [Chapter 8](1942c8c2-08a2-4c18-8740-8b7e9103bc6e.xhtml),
    *Adding Explosion and Creating a UI*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在2D游戏示例中所做的那样，我们的大部分绘图机制将保持不变。您会发现这两个过程之间有很多相似之处。我们将为这个示例创建一个新的项目文件夹，所以让我们继续创建一个新的项目，就像我们在[第8章](1942c8c2-08a2-4c18-8740-8b7e9103bc6e.xhtml)中做的那样，*添加爆炸和创建用户界面*。
- en: Creating our project folder
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的项目文件夹
- en: We will follow the steps we did in [Chapter 2](9563ed54-bb46-4d59-9225-ed418d3e0b29.xhtml),
    *Getting Familiar with Android Studio*. First, we will create a new project from
    our top menu.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循我们在[第2章](9563ed54-bb46-4d59-9225-ed418d3e0b29.xhtml)中做的步骤，*熟悉Android Studio*。首先，我们将从我们的顶部菜单创建一个新的项目。
- en: 'To create a new project, perform the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的项目，请执行以下步骤：
- en: 'Go to File | New | New Project..., as shown in the following screenshot:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往文件 | 新建 | 新项目...，如下截图所示：
- en: '![](img/B05066_09_03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_09_03.png)'
- en: 'Fill in your Application name, Company domain, and Package name details; then
    click on Next:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写你的应用程序名称、公司域名和包名详细信息；然后点击下一步：
- en: '![](img/B05066_09_04.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_09_04.png)'
- en: 'Select your target devices and click on Next:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的目标设备并点击下一步：
- en: '![](img/B05066_09_05.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_09_05.png)'
- en: 'Select Empty Activity and click on Next:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择空活动并点击下一步：
- en: '![](img/B05066_09_06.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_09_06.png)'
- en: 'Fill in your Activity Name, Layout Name, and click on Finish:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写你的活动名称、布局名称，然后点击完成：
- en: '![](img/B05066_09_07.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_09_07.png)'
- en: 'Okay then, we are now set with our new project folder. Also, we will use the
    landscape mode orientation for this project, so we will define it in our `AndroidManifest.xml`
    file. Open up your manifest file from the `app/manifests/AndroidManifest.xml`
    file and make the following change that is marked in bold:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们现在已经设置了我们的新项目文件夹。此外，我们将为这个项目使用横屏模式方向，所以我们将它在`AndroidManifest.xml`文件中定义。从`app/manifests/AndroidManifest.xml`文件打开您的清单文件，并做出以下标记为粗体的更改：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's now define our main activity and create a render class for our 3D game
    view.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在定义我们的主活动并为我们的3D游戏视图创建一个渲染类。
- en: Creating a render class and defining a main activity
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个渲染类和定义主活动
- en: 'In order to see anything on the screen, we have to render it on screen. Therefore,
    we need to create a render class that will handle the rendering part of our functioning.
    Rendering is the process of generating an image from a 2D or 3D model by means
    of computer programs. We will name our render class as `MyGLRenderer`, but before
    we do that, let''s define our main activity. So, open up your `MainActivity.java`
    file, and we will create three default methods there. Remove everything you see
    on screen, except for the first line that''s your package name. We will have three
    methods:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上看到任何东西，我们必须在屏幕上渲染它。因此，我们需要创建一个渲染类来处理我们功能中的渲染部分。渲染是通过计算机程序从2D或3D模型生成图像的过程。我们将命名我们的渲染类为`MyGLRenderer`，但在我们这样做之前，让我们定义我们的主活动。所以打开您的`MainActivity.java`文件，我们将在那里创建三个默认方法。删除屏幕上的所有内容，除了您的包名第一行。我们将有三个方法：
- en: '`onCreate()`: This initializes our main activity'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`: 这个方法初始化我们的主活动'
- en: '`onPause()`: This handles the app if it goes into background'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause()`: 当应用进入后台时，这个方法处理应用。'
- en: '`onResume()`: After the user resumes back to the app, this method is called'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume()`: 用户返回应用后，这个方法会被调用。'
- en: Also, we are dealing with OpenGL graphics here, and for that reason, we will
    need a `GLSurfaceView`, just as we worked in our 2D game wherein we had a surface
    view for our game.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在这里处理的是OpenGL图形，因此我们需要一个`GLSurfaceView`，就像我们在我们的2D游戏中做的那样，我们有一个用于游戏的表面视图。
- en: 'So, let''s create them in our `MainActivity.java` file, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在`MainActivity.java`文件中创建它们，如下所示：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Okay, that seems sorted, but now we are getting an error on our `MyGLRenderer`
    line. That's because we still haven't made our renderer class yet. Let's make
    our renderer class now. Create a new Java class file named `MyGLRenderer.java`,
    and let's get started with writing our renderer class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，看起来没问题，但现在我们在`MyGLRenderer`行上遇到了错误。这是因为我们还没有创建我们的渲染器类。让我们现在创建我们的渲染器类。创建一个新的Java类文件，命名为`MyGLRenderer.java`，让我们开始编写我们的渲染器类。
- en: The `Renderer` class is where you will do most of your object displaying part.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer`类是您将进行大部分对象显示的地方。'
- en: 'The interface `GLSurfaceView.Renderer` is responsible for making OpenGL render
    a frame, hence we will need to implement it as an interface in our code; so we
    will start with our very first line, which will do the same. We will extend our
    class to the `GLSurfaceView.Renderer` interface and write a default constructor,
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`GLSurfaceView.Renderer`负责让OpenGL渲染一个帧，因此我们需要在我们的代码中实现它作为一个接口；所以我们将从我们的第一行开始，这将做同样的事情。我们将扩展我们的类到`GLSurfaceView.Renderer`接口，并编写一个默认构造函数，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, inside this class, as we had in our 2D sprite example game, we will need
    three methods to draw on the screen; they are `onSurfaceCreated()`, `onSurfaceChanged()`,
    and `onDraw()`. However, in OpenGL, the `onDraw()` method is actually `onDrawFrame()`,
    so let's define those three methods one by one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个类中，就像我们在我们的2D精灵示例游戏中做的那样，我们需要三个方法来在屏幕上绘制；它们是`onSurfaceCreated()`、`onSurfaceChanged()`和`onDraw()`。然而，在OpenGL中，`onDraw()`方法实际上是`onDrawFrame()`，所以让我们逐一定义这三个方法。
- en: 'First, we will start with our `onSurfaceChanged()` method. In this method,
    we will create our surface. This method is for the initialization of our scene.
    Here, we will create a simple black screen drawn on the screen. In order to set
    our color, we will use RGBA values. For a black color, we will need (0,0,0,1)
    RGBA values. We will also add in some more initialization factors here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从我们的`onSurfaceChanged()`方法开始。在这个方法中，我们将创建我们的表面。这个方法用于初始化我们的场景。在这里，我们将在屏幕上创建一个简单的黑色屏幕。为了设置我们的颜色，我们将使用RGBA值。对于黑色，我们需要(0,0,0,1)的RGBA值。我们还会在这里添加一些更多的初始化因素：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These parameters are basically required to set various aspects in an OpenGL
    ES environment. You can read up more about these specific methods and more through
    [https://www.khronos.org/registry/OpenGL-Refpages/es3.0/](https://www.khronos.org/registry/OpenGL-Refpages/es3.0/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数基本上是必需的，用于设置OpenGL ES环境中的各种方面。你可以通过[https://www.khronos.org/registry/OpenGL-Refpages/es3.0/](https://www.khronos.org/registry/OpenGL-Refpages/es3.0/)了解更多关于这些特定方法和更多信息。
- en: 'This method gets called after the `onSurfaceCreated()` method and also every
    time our screen resolution changes. Basically, this method is responsible for
    creating the display matrix that we saw earlier in the chapter, which in turn
    creates a uniform shape on any screen:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在`onSurfaceCreated()`方法之后被调用，并且每次屏幕分辨率改变时也会被调用。基本上，这个方法负责创建我们在本章中较早看到的显示矩阵，这反过来又会在任何屏幕上创建一个均匀的形状：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we have our `onDrawFrame()` function, which is used to draw the current
    frame. After every frame, we need to clear the previous screen drawn, and for
    that reason, we call `glClear()` in this before we render any code further. Right
    now, we will just write our clear code and when we will draw our object shapes
    in this function after our clear code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`onDrawFrame()`函数，它用于绘制当前帧。在每一帧之后，我们需要清除之前绘制的屏幕，因此在这个函数中，在渲染任何其他代码之前，我们调用`glClear()`。现在，我们只需编写我们的清除代码，然后在清除代码之后，在这个函数中绘制我们的对象形状：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, this is how your entire code will look like for your `Renderer` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是你的`Renderer`类的整个代码看起来像这样：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we will learn how to define and draw, or in proper terms *render*, our
    3D objects on the screen. First, we will start with a basic triangle shape and
    then we will draw a pyramid, then we will make both of them rotate on the screen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何定义和绘制，或者更准确地说，*渲染*我们的3D对象在屏幕上。首先，我们将从一个基本的三角形形状开始，然后我们将绘制一个金字塔，然后我们将使它们两个在屏幕上旋转。
- en: Defining shapes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义形状
- en: In order to draw something on the screen, we first need to define its shape
    and then render it. So we won't define our shape in our render class. We will
    create a new class in order to define our shape. As discussed, we will first create
    a basic triangle.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上绘制某些东西，我们首先需要定义其形状，然后渲染它。因此，我们不会在我们的渲染类中定义我们的形状。我们将创建一个新的类来定义我们的形状。正如讨论的那样，我们首先创建一个基本的三角形。
- en: In order to create our triangle, we need to first define its vertices. So, let's
    create a new class named `Triangle.java` and start writing our logic to define
    the shape of our 3D triangle. Before we start writing our code, let's try to understand
    what we are actually going to do.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的三角形，我们首先需要定义其顶点。因此，让我们创建一个新的类名为`Triangle.java`，并开始编写我们的逻辑来定义3D三角形的形状。在我们开始编写代码之前，让我们尝试理解我们实际上要做什么。
- en: 'We will take vertices and plot them on our screen. Also, as you saw previously
    how OpenGL coordinates work, we will plot our vertices in all three directions.
    For our triangle, we require three points to be plotted. So, we will plot one
    point on the positive **y-axis** and the other two points on the positive and
    negative x-axis:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在屏幕上绘制顶点。此外，正如你之前看到的OpenGL坐标如何工作，我们将在三个方向上绘制我们的顶点。对于我们的三角形，我们需要绘制三个点。因此，我们将在一个正**y轴**上绘制一个点，其他两个点分别绘制在正负**x轴**上：
- en: '![](img/B05066_09_08.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_09_08.jpg)'
- en: Plotting our triangle
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制我们的三角形
- en: 'For this purpose, we will take a three-dimensional array of our vertices and
    define them as a variable in our class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将使用一个三维数组来存储我们的顶点，并在我们的类中定义它们作为变量：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That takes care of our vertices, and we have defined its shape, well somewhat,
    but of course, there''s more to it. We also need to define a vertex buffer and
    transfer this data into it. To do so, we will define our vertex buffer variable
    as nio''s buffer, as they are placed on the native heap and are not garbage collected.
    We will do the same for our index buffer, which will arrange our triangle in a
    counter-clockwise (CCW) direction with positive *z* direction facing toward the
    screen. So, first we will define our `vertexBuffer` and `indexBuffer` variables,
    and then in our default constructor, we will set up our `vertexBuffer` and `indexBuffer`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就处理了顶点，并定义了其形状，好吧，某种程度上是这样，但当然，还有更多。我们还需要定义一个顶点缓冲区并将这些数据传输到其中。为此，我们将定义我们的顶点缓冲区变量为nio的缓冲区，因为它们位于本地堆上，不会被垃圾回收。我们也会为我们的索引缓冲区做同样的事情，这将使我们的三角形以逆时针（CCW）方向排列，并且正**z**方向朝向屏幕。因此，首先我们将定义我们的`vertexBuffer`和`indexBuffer`变量，然后在我们的默认构造函数中，我们将设置我们的`vertexBuffer`和`indexBuffer`：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alright, now that''s taken care of, we also have to actually draw our triangle
    on screen; for this, we will use our `draw()` method. To do so, we will go through
    the following four simple steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经处理好了这些，我们实际上还必须在屏幕上绘制我们的三角形；为此，我们将使用我们的`draw()`方法。要做到这一点，我们将遵循以下四个简单步骤：
- en: We enable vertex array client states.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启用了顶点数组客户端状态。
- en: We specify the location of the buffers.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定缓冲区位置。
- en: We render our primitive shapes using `glDrayElements()` that uses index array
    to reference the vertex array.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`glDrawElements()`来渲染我们的原始形状，该函数使用索引数组来引用顶点数组。
- en: We disable our vertex array client state.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们禁用了我们的顶点数组客户端状态。
- en: 'Now that we have understood the working of its theory, let''s go ahead and
    do this in practice by writing it out in our code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了其理论的工作原理，那么让我们继续通过在代码中实现它来实践：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our shape is defined perfectly, and our entire code block for the `Triangle.java`
    file will look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定义形状是完美的，我们的整个`Triangle.java`文件的代码块将看起来像这样：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, if you deploy this to your device, you won't be able to see your triangle
    on the screen. This is because we still haven't rendered it on our screen yet.
    Remember how we discussed rendering all our objects using the help of the `MyGLRenderer`
    file? We haven't told that file to use our triangle to be rendered, but that's
    it for this chapter. We will cover the rendering of our object in the next chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将此部署到你的设备上，你将无法在屏幕上看到你的三角形。这是因为我们还没有在我们的屏幕上渲染它。还记得我们讨论了如何使用`MyGLRenderer`文件来帮助渲染所有我们的对象吗？我们还没有告诉那个文件使用我们的三角形进行渲染，但这就是本章的全部内容。我们将在下一章中介绍对象的渲染。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how to transition from a 2D to a 3D game along
    with concepts of OpenGL. We also learned how to create our main activity along
    with our own renderer. After this, we learned how to define a basic shape.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何从2D游戏过渡到3D游戏，以及OpenGL的相关概念。我们还学习了如何创建我们的主活动以及我们的自定义渲染器。之后，我们学习了如何定义一个基本形状。
- en: To summarize, we covered the following topics in this chapter. We got introduced
    to OpenGL ES and took a look at the coordinates system in the same. We learned
    how to create a blank scene and the process of rendering. We then created our
    basic renderer and defined our triangle shape.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本章中，我们涵盖了以下内容。我们介绍了OpenGL ES，并查看了解同中的坐标系。我们学习了如何创建一个空白场景以及渲染过程。然后我们创建了我们的基本渲染器并定义了我们的三角形形状。
- en: In our next chapter, we will learn how to render our defined shape on the screen
    and rotate it. We will also learn how to create a 3D pyramid in the next chapter,
    and by the end of the next chapter, you will complete this book and  also have
    a foundation for creating a 2D and 3D game.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在屏幕上渲染我们定义的形状并对其进行旋转。我们还将学习如何在下一章中创建一个3D金字塔，并在下一章结束时，你将完成这本书，并且也将为创建2D和3D游戏打下基础。
